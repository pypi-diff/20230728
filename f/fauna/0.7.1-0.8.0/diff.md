# Comparing `tmp/fauna-0.7.1-py2.py3-none-any.whl.zip` & `tmp/fauna-0.8.0-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 25991 bytes, number of entries: 24
--rw-r--r--  2.0 unx      301 b- defN 23-Jun-29 10:08 fauna/__init__.py
--rw-r--r--  2.0 unx      102 b- defN 23-Jun-29 10:08 fauna/client/__init__.py
--rw-r--r--  2.0 unx    22085 b- defN 23-Jun-29 10:08 fauna/client/client.py
--rw-r--r--  2.0 unx       90 b- defN 23-Jun-29 10:08 fauna/client/endpoints.py
--rw-r--r--  2.0 unx     3201 b- defN 23-Jun-29 10:08 fauna/client/headers.py
--rw-r--r--  2.0 unx     2213 b- defN 23-Jun-29 10:08 fauna/client/utils.py
--rw-r--r--  2.0 unx      161 b- defN 23-Jun-29 10:08 fauna/encoding/__init__.py
--rw-r--r--  2.0 unx     6450 b- defN 23-Jun-29 10:08 fauna/encoding/decoder.py
--rw-r--r--  2.0 unx     8122 b- defN 23-Jun-29 10:08 fauna/encoding/encoder.py
--rw-r--r--  2.0 unx     5991 b- defN 23-Jun-29 10:08 fauna/encoding/wire_protocol.py
--rw-r--r--  2.0 unx      361 b- defN 23-Jun-29 10:08 fauna/errors/__init__.py
--rw-r--r--  2.0 unx     4853 b- defN 23-Jun-29 10:08 fauna/errors/errors.py
--rw-r--r--  2.0 unx       88 b- defN 23-Jun-29 10:08 fauna/http/__init__.py
--rw-r--r--  2.0 unx     1201 b- defN 23-Jun-29 10:08 fauna/http/http_client.py
--rw-r--r--  2.0 unx     2323 b- defN 23-Jun-29 10:08 fauna/http/httpx_client.py
--rw-r--r--  2.0 unx      153 b- defN 23-Jun-29 10:08 fauna/query/__init__.py
--rw-r--r--  2.0 unx     9411 b- defN 23-Jun-29 10:08 fauna/query/models.py
--rw-r--r--  2.0 unx     4005 b- defN 23-Jun-29 10:08 fauna/query/query_builder.py
--rw-r--r--  2.0 unx     2851 b- defN 23-Jun-29 10:08 fauna/query/template.py
--rw-r--r--  2.0 unx      545 b- defN 23-Jun-29 10:18 fauna-0.7.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     7565 b- defN 23-Jun-29 10:18 fauna-0.7.1.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 23-Jun-29 10:18 fauna-0.7.1.dist-info/WHEEL
--rw-r--r--  2.0 unx        6 b- defN 23-Jun-29 10:18 fauna-0.7.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1903 b- defN 23-Jun-29 10:18 fauna-0.7.1.dist-info/RECORD
-24 files, 84091 bytes uncompressed, 22941 bytes compressed:  72.7%
+Zip file size: 26320 bytes, number of entries: 24
+-rw-r--r--  2.0 unx      301 b- defN 23-Jul-28 12:26 fauna/__init__.py
+-rw-r--r--  2.0 unx      102 b- defN 23-Jul-28 12:26 fauna/client/__init__.py
+-rw-r--r--  2.0 unx    22613 b- defN 23-Jul-28 12:26 fauna/client/client.py
+-rw-r--r--  2.0 unx       86 b- defN 23-Jul-28 12:26 fauna/client/endpoints.py
+-rw-r--r--  2.0 unx     2907 b- defN 23-Jul-28 12:26 fauna/client/headers.py
+-rw-r--r--  2.0 unx     2063 b- defN 23-Jul-28 12:26 fauna/client/utils.py
+-rw-r--r--  2.0 unx      161 b- defN 23-Jul-28 12:26 fauna/encoding/__init__.py
+-rw-r--r--  2.0 unx     5775 b- defN 23-Jul-28 12:26 fauna/encoding/decoder.py
+-rw-r--r--  2.0 unx     7403 b- defN 23-Jul-28 12:26 fauna/encoding/encoder.py
+-rw-r--r--  2.0 unx     6031 b- defN 23-Jul-28 12:26 fauna/encoding/wire_protocol.py
+-rw-r--r--  2.0 unx      361 b- defN 23-Jul-28 12:26 fauna/errors/__init__.py
+-rw-r--r--  2.0 unx     4664 b- defN 23-Jul-28 12:26 fauna/errors/errors.py
+-rw-r--r--  2.0 unx       88 b- defN 23-Jul-28 12:26 fauna/http/__init__.py
+-rw-r--r--  2.0 unx     1095 b- defN 23-Jul-28 12:26 fauna/http/http_client.py
+-rw-r--r--  2.0 unx     2085 b- defN 23-Jul-28 12:26 fauna/http/httpx_client.py
+-rw-r--r--  2.0 unx      153 b- defN 23-Jul-28 12:26 fauna/query/__init__.py
+-rw-r--r--  2.0 unx     8562 b- defN 23-Jul-28 12:26 fauna/query/models.py
+-rw-r--r--  2.0 unx     3838 b- defN 23-Jul-28 12:26 fauna/query/query_builder.py
+-rw-r--r--  2.0 unx     2657 b- defN 23-Jul-28 12:26 fauna/query/template.py
+-rw-r--r--  2.0 unx      545 b- defN 23-Jul-28 12:26 fauna-0.8.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7569 b- defN 23-Jul-28 12:26 fauna-0.8.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Jul-28 12:26 fauna-0.8.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        6 b- defN 23-Jul-28 12:26 fauna-0.8.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1903 b- defN 23-Jul-28 12:26 fauna-0.8.0.dist-info/RECORD
+24 files, 81078 bytes uncompressed, 23270 bytes compressed:  71.3%
```

## zipnote {}

```diff
@@ -51,23 +51,23 @@
 
 Filename: fauna/query/query_builder.py
 Comment: 
 
 Filename: fauna/query/template.py
 Comment: 
 
-Filename: fauna-0.7.1.dist-info/LICENSE
+Filename: fauna-0.8.0.dist-info/LICENSE
 Comment: 
 
-Filename: fauna-0.7.1.dist-info/METADATA
+Filename: fauna-0.8.0.dist-info/METADATA
 Comment: 
 
-Filename: fauna-0.7.1.dist-info/WHEEL
+Filename: fauna-0.8.0.dist-info/WHEEL
 Comment: 
 
-Filename: fauna-0.7.1.dist-info/top_level.txt
+Filename: fauna-0.8.0.dist-info/top_level.txt
 Comment: 
 
-Filename: fauna-0.7.1.dist-info/RECORD
+Filename: fauna-0.8.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fauna/__init__.py

```diff
@@ -1,9 +1,9 @@
 __title__ = "Fauna"
-__version__ = "0.7.1"
+__version__ = "0.8.0"
 __api_version__ = "10"
 __author__ = "Fauna, Inc"
 __license__ = "MPL 2.0"
 __copyright__ = "2023 Fauna, Inc"
 
 from fauna.query import fql, Document, DocumentReference, NamedDocument, NamedDocumentReference, NullDocument, Module, Page
```

## fauna/client/client.py

```diff
@@ -14,181 +14,203 @@
 from fauna.encoding import QuerySuccess, ConstraintFailure, QueryTags, QueryStats
 
 DefaultHttpConnectTimeout = timedelta(seconds=5)
 DefaultHttpReadTimeout: Optional[timedelta] = None
 DefaultHttpWriteTimeout = timedelta(seconds=5)
 DefaultHttpPoolTimeout = timedelta(seconds=5)
 DefaultIdleConnectionTimeout = timedelta(seconds=5)
+DefaultQueryTimeout = timedelta(seconds=5)
+DefaultClientBufferTimeout = timedelta(seconds=5)
 DefaultMaxConnections = 20
 DefaultMaxIdleConnections = 20
 
 
 @dataclass
 class QueryOptions:
-    """
+  """
     A dataclass representing options available for a query.
 
     * linearized - If true, unconditionally run the query as strictly serialized. This affects read-only transactions. Transactions which write will always be strictly serialized.
     * max_contention_retries - The max number of times to retry the query if contention is encountered.
     * query_timeout - Controls the maximum amount of time Fauna will execute your query before marking it failed.
     * query_tags - Tags to associate with the query. See `logging <https://docs.fauna.com/fauna/current/build/logs/query_log/>`_
     * traceparent - A traceparent to associate with the query. See `logging <https://docs.fauna.com/fauna/current/build/logs/query_log/>`_ Must match format: https://www.w3.org/TR/trace-context/#traceparent-header
     * typecheck - Enable or disable typechecking of the query before evaluation. If not set, the value configured on the Client will be used. If neither is set, Fauna will use the value of the "typechecked" flag on the database configuration.
     * additional_headers - Add/update HTTP request headers for the query. In general, this should not be necessary.
     """
 
-    linearized: Optional[bool] = None
-    max_contention_retries: Optional[int] = None
-    query_timeout: Optional[timedelta] = None
-    query_tags: Optional[Mapping[str, str]] = None
-    traceparent: Optional[str] = None
-    typecheck: Optional[bool] = None
-    additional_headers: Optional[Dict[str, str]] = None
+  linearized: Optional[bool] = None
+  max_contention_retries: Optional[int] = None
+  query_timeout: Optional[timedelta] = DefaultQueryTimeout
+  query_tags: Optional[Mapping[str, str]] = None
+  traceparent: Optional[str] = None
+  typecheck: Optional[bool] = None
+  additional_headers: Optional[Dict[str, str]] = None
 
 
 class Client:
 
-    def __init__(
-        self,
-        endpoint: Optional[str] = None,
-        secret: Optional[str] = None,
-        http_client: Optional[HTTPClient] = None,
-        query_tags: Optional[Mapping[str, str]] = None,
-        linearized: Optional[bool] = None,
-        max_contention_retries: Optional[int] = None,
-        query_timeout: Optional[timedelta] = None,
-        typecheck: Optional[bool] = None,
-        additional_headers: Optional[Dict[str, str]] = None,
-    ):
-        """Initializes a Client.
+  def __init__(
+      self,
+      endpoint: Optional[str] = None,
+      secret: Optional[str] = None,
+      http_client: Optional[HTTPClient] = None,
+      query_tags: Optional[Mapping[str, str]] = None,
+      linearized: Optional[bool] = None,
+      max_contention_retries: Optional[int] = None,
+      typecheck: Optional[bool] = None,
+      additional_headers: Optional[Dict[str, str]] = None,
+      query_timeout: Optional[timedelta] = DefaultQueryTimeout,
+      client_buffer_timeout: Optional[timedelta] = DefaultClientBufferTimeout,
+      http_read_timeout: Optional[timedelta] = DefaultHttpReadTimeout,
+      http_write_timeout: Optional[timedelta] = DefaultHttpWriteTimeout,
+      http_connect_timeout: Optional[timedelta] = DefaultHttpConnectTimeout,
+      http_pool_timeout: Optional[timedelta] = DefaultHttpPoolTimeout,
+      http_idle_timeout: Optional[timedelta] = DefaultIdleConnectionTimeout,
+  ):
+    """Initializes a Client.
 
-        :param endpoint: The Fauna Endpoint to use. Defaults to https://db.fauna.com, or the FAUNA_ENDPOINT env variable.
-        :param secret: The Fauna Secret to use. Defaults to empty, or the FAUNA_SECRET env variable.
+        :param endpoint: The Fauna Endpoint to use. Defaults to https://db.fauna.com, or the `FAUNA_ENDPOINT` env variable.
+        :param secret: The Fauna Secret to use. Defaults to empty, or the `FAUNA_SECRET` env variable.
         :param http_client: An :class:`HTTPClient` implementation. Defaults to a global :class:`HTTPXClient`.
         :param query_tags: Tags to associate with the query. See `logging <https://docs.fauna.com/fauna/current/build/logs/query_log/>`_
         :param linearized: If true, unconditionally run the query as strictly serialized. This affects read-only transactions. Transactions which write will always be strictly serialized.
         :param max_contention_retries: The max number of times to retry the query if contention is encountered.
-        :param query_timeout: Controls the maximum amount of time (in milliseconds) Fauna will execute your query before marking it failed.
         :param typecheck: Enable or disable typechecking of the query before evaluation. If not set, Fauna will use the value of the "typechecked" flag on the database configuration.
         :param additional_headers: Add/update HTTP request headers for the query. In general, this should not be necessary.
-        """
-
-        self._set_endpoint(endpoint)
+        :param query_timeout: Controls the maximum amount of time Fauna will execute your query before marking it failed, default is :py:data:`DefaultQueryTimeout`.
+        :param client_buffer_timeout: Time in milliseconds beyond query_timeout at which the client will abort a request if it has not received a response. The default is :py:data:`DefaultClientBufferTimeout`, which should account for network latency for most clients. The value must be greater than zero. The closer to zero the value is, the more likely the client is to abort the request before the server can report a legitimate response or error.
+        :param http_read_timeout: Set HTTP Read timeout, default is :py:data:`DefaultHttpReadTimeout`.
+        :param http_write_timeout: Set HTTP Write timeout, default is :py:data:`DefaultHttpWriteTimeout`.
+        :param http_connect_timeout: Set HTTP Connect timeout, default is :py:data:`DefaultHttpConnectTimeout`.
+        :param http_pool_timeout: Set HTTP Pool timeout, default is :py:data:`DefaultHttpPoolTimeout`.
+        :param http_idle_timeout: Set HTTP Idle timeout, default is :py:data:`DefaultIdleConnectionTimeout`.
+        """
+
+    self._set_endpoint(endpoint)
+
+    if secret is None:
+      self._auth = _Auth(_Environment.EnvFaunaSecret())
+    else:
+      self._auth = _Auth(secret)
+
+    self._last_txn_ts = LastTxnTs()
+
+    self._query_tags = {}
+    if query_tags is not None:
+      self._query_tags.update(query_tags)
+
+    if query_timeout is not None:
+      self._query_timeout_ms = int(query_timeout.total_seconds() * 1000)
+    else:
+      self._query_timeout_ms = None
+
+    self._headers: Dict[str, str] = {
+        _Header.AcceptEncoding: "gzip",
+        _Header.ContentType: "application/json;charset=utf-8",
+        _Header.Driver: "python",
+        _Header.DriverEnv: str(_DriverEnvironment()),
+    }
+
+    if typecheck is not None:
+      self._headers[Header.Typecheck] = str(typecheck).lower()
+
+    if linearized is not None:
+      self._headers[Header.Linearized] = str(linearized).lower()
+
+    if max_contention_retries is not None and max_contention_retries > 0:
+      self._headers[Header.MaxContentionRetries] = \
+          f"{max_contention_retries}"
+
+    if additional_headers is not None:
+      self._headers = {
+          **self._headers,
+          **additional_headers,
+      }
+
+    self._session: HTTPClient
+
+    if http_client is not None:
+      self._session = http_client
+    else:
+      if fauna.global_http_client is None:
+        timeout_s: Optional[float] = None
+        if query_timeout is not None and client_buffer_timeout is not None:
+          timeout_s = (query_timeout + client_buffer_timeout).total_seconds()
+        read_timeout_s: Optional[float] = None
+        if http_read_timeout is not None:
+          read_timeout_s = http_read_timeout.total_seconds()
+
+        write_timeout_s: Optional[float] = http_write_timeout.total_seconds(
+        ) if http_write_timeout is not None else None
+        connect_timeout_s: Optional[float] = http_connect_timeout.total_seconds(
+        ) if http_connect_timeout is not None else None
+        pool_timeout_s: Optional[float] = http_pool_timeout.total_seconds(
+        ) if http_pool_timeout is not None else None
+        idle_timeout_s: Optional[float] = http_idle_timeout.total_seconds(
+        ) if http_idle_timeout is not None else None
+
+        import httpx
+        from fauna.http.httpx_client import HTTPXClient
+        c = HTTPXClient(
+            httpx.Client(
+                http1=False,
+                http2=True,
+                timeout=httpx.Timeout(
+                    timeout=timeout_s,
+                    connect=connect_timeout_s,
+                    read=read_timeout_s,
+                    write=write_timeout_s,
+                    pool=pool_timeout_s,
+                ),
+                limits=httpx.Limits(
+                    max_connections=DefaultMaxConnections,
+                    max_keepalive_connections=DefaultMaxIdleConnections,
+                    keepalive_expiry=idle_timeout_s,
+                ),
+            ))
+        fauna.global_http_client = c
 
-        if secret is None:
-            self._auth = _Auth(_Environment.EnvFaunaSecret())
-        else:
-            self._auth = _Auth(secret)
-
-        self._last_txn_ts = LastTxnTs()
-
-        self._query_tags = {}
-        if query_tags is not None:
-            self._query_tags.update(query_tags)
-
-        if query_timeout is not None:
-            self._query_timeout_ms = int(query_timeout.total_seconds() * 1000)
-        else:
-            self._query_timeout_ms = None
-
-        self._headers: Dict[str, str] = {
-            _Header.AcceptEncoding: "gzip",
-            _Header.ContentType: "application/json;charset=utf-8",
-            _Header.Driver: "python",
-            _Header.DriverEnv: str(_DriverEnvironment()),
-        }
-
-        if typecheck is not None:
-            self._headers[Header.Typecheck] = str(typecheck).lower()
-
-        if linearized is not None:
-            self._headers[Header.Linearized] = str(linearized).lower()
-
-        if max_contention_retries is not None and max_contention_retries > 0:
-            self._headers[Header.MaxContentionRetries] = \
-                f"{max_contention_retries}"
-
-        if additional_headers is not None:
-            self._headers = {
-                **self._headers,
-                **additional_headers,
-            }
-
-        self._session: HTTPClient
-
-        if http_client is not None:
-            self._session = http_client
-        else:
-            if fauna.global_http_client is None:
-                read_timeout: Optional[timedelta] = DefaultHttpReadTimeout
-                read_timeout_s: Optional[float] = None
-                if read_timeout is not None:
-                    read_timeout_s = read_timeout.total_seconds()
-
-                write_timeout_s = DefaultHttpWriteTimeout.total_seconds()
-                pool_timeout_s = DefaultHttpPoolTimeout.total_seconds()
-                idle_timeout_s = DefaultIdleConnectionTimeout.total_seconds()
-
-                import httpx
-                from fauna.http.httpx_client import HTTPXClient
-                c = HTTPXClient(
-                    httpx.Client(
-                        http1=False,
-                        http2=True,
-                        timeout=httpx.Timeout(
-                            connect=DefaultMaxConnections,
-                            read=read_timeout_s,
-                            write=write_timeout_s,
-                            pool=pool_timeout_s,
-                        ),
-                        limits=httpx.Limits(
-                            max_connections=DefaultMaxConnections,
-                            max_keepalive_connections=DefaultMaxIdleConnections,
-                            keepalive_expiry=idle_timeout_s,
-                        ),
-                    ))
-                fauna.global_http_client = c
+      self._session = fauna.global_http_client
 
-            self._session = fauna.global_http_client
-
-    def set_last_txn_ts(self, txn_ts: int):
-        """
+  def set_last_txn_ts(self, txn_ts: int):
+    """
         Set the last timestamp seen by this client.
         This has no effect if earlier than stored timestamp.
 
         .. WARNING:: This should be used only when coordinating timestamps across
         multiple clients. Moving the timestamp arbitrarily forward into
         the future will cause transactions to stall.
 
         :param txn_ts: the new transaction time.
         """
-        self._last_txn_ts.update_txn_time(txn_ts)
+    self._last_txn_ts.update_txn_time(txn_ts)
 
-    def get_last_txn_ts(self) -> Optional[int]:
-        """
+  def get_last_txn_ts(self) -> Optional[int]:
+    """
         Get the last timestamp seen by this client.
         :return:
         """
-        return self._last_txn_ts.time
+    return self._last_txn_ts.time
 
-    def get_query_timeout(self) -> Optional[timedelta]:
-        """
+  def get_query_timeout(self) -> Optional[timedelta]:
+    """
         Get the query timeout for all queries.
         """
-        if self._query_timeout_ms is not None:
-            return timedelta(milliseconds=self._query_timeout_ms)
-        else:
-            return None
-
-    def paginate(
-        self,
-        fql: Query,
-        opts: Optional[QueryOptions] = None,
-    ) -> "QueryIterator":
-        """
+    if self._query_timeout_ms is not None:
+      return timedelta(milliseconds=self._query_timeout_ms)
+    else:
+      return None
+
+  def paginate(
+      self,
+      fql: Query,
+      opts: Optional[QueryOptions] = None,
+  ) -> "QueryIterator":
+    """
         Run a query on Fauna and returning an iterator of results. If the query
         returns a Page, the iterator will fetch additional Pages until the
         after token is null.
 
         :param fql: A Query
         :param opts: (Optional) Query Options
 
@@ -197,382 +219,396 @@
         :raises NetworkError: HTTP Request failed in transit
         :raises ProtocolError: HTTP error not from Fauna
         :raises ServiceError: Fauna returned an error
         :raises ValueError: Encoding and decoding errors
         :raises TypeError: Invalid param types
         """
 
-        if not isinstance(fql, Query):
-            err_msg = f"'fql' must be a Query but was a {type(fql)}. You can build a " \
-                       f"Query by calling fauna.fql()"
-            raise TypeError(err_msg)
-
-        return QueryIterator(self, fql, opts)
-
-    def query(
-        self,
-        fql: Query,
-        opts: Optional[QueryOptions] = None,
-    ) -> QuerySuccess:
-        """
+    if not isinstance(fql, Query):
+      err_msg = f"'fql' must be a Query but was a {type(fql)}. You can build a " \
+                 f"Query by calling fauna.fql()"
+      raise TypeError(err_msg)
+
+    return QueryIterator(self, fql, opts)
+
+  def query(
+      self,
+      fql: Query,
+      opts: Optional[QueryOptions] = None,
+  ) -> QuerySuccess:
+    """
         Run a query on Fauna.
 
         :param fql: A Query
         :param opts: (Optional) Query Options
 
         :return: a :class:`QueryResponse`
 
         :raises NetworkError: HTTP Request failed in transit
         :raises ProtocolError: HTTP error not from Fauna
         :raises ServiceError: Fauna returned an error
         :raises ValueError: Encoding and decoding errors
         :raises TypeError: Invalid param types
         """
 
-        if not isinstance(fql, Query):
-            err_msg = f"'fql' must be a Query but was a {type(fql)}. You can build a " \
-                       f"Query by calling fauna.fql()"
-            raise TypeError(err_msg)
-
-        try:
-            encoded_query: Mapping[str, Any] = FaunaEncoder.encode(fql)
-        except Exception as e:
-            raise ClientError("Failed to encode Query") from e
-
-        return self._query(
-            "/query/1",
-            fql=encoded_query,
-            opts=opts,
+    if not isinstance(fql, Query):
+      err_msg = f"'fql' must be a Query but was a {type(fql)}. You can build a " \
+                 f"Query by calling fauna.fql()"
+      raise TypeError(err_msg)
+
+    try:
+      encoded_query: Mapping[str, Any] = FaunaEncoder.encode(fql)
+    except Exception as e:
+      raise ClientError("Failed to encode Query") from e
+
+    return self._query(
+        "/query/1",
+        fql=encoded_query,
+        opts=opts,
+    )
+
+  def _query(
+      self,
+      path: str,
+      fql: Mapping[str, Any],
+      arguments: Optional[Mapping[str, Any]] = None,
+      opts: Optional[QueryOptions] = None,
+  ) -> QuerySuccess:
+
+    headers = self._headers.copy()
+    headers[_Header.Format] = "tagged"
+    headers[_Header.Authorization] = self._auth.bearer()
+
+    if self._query_timeout_ms is not None:
+      headers[Header.QueryTimeoutMs] = str(self._query_timeout_ms)
+
+    headers.update(self._last_txn_ts.request_header)
+
+    query_tags = {}
+    if self._query_tags is not None:
+      query_tags.update(self._query_tags)
+
+    if opts is not None:
+      if opts.linearized is not None:
+        headers[Header.Linearized] = str(opts.linearized).lower()
+      if opts.max_contention_retries is not None:
+        headers[Header.MaxContentionRetries] = \
+            f"{opts.max_contention_retries}"
+      if opts.traceparent is not None:
+        headers[Header.Traceparent] = opts.traceparent
+      if opts.query_timeout is not None:
+        timeout_ms = f"{int(opts.query_timeout.total_seconds() * 1000)}"
+        headers[Header.QueryTimeoutMs] = timeout_ms
+      if opts.query_tags is not None:
+        query_tags.update(opts.query_tags)
+      if opts.typecheck is not None:
+        headers[Header.Typecheck] = str(opts.typecheck).lower()
+      if opts.additional_headers is not None:
+        headers.update(opts.additional_headers)
+
+    if len(query_tags) > 0:
+      headers[Header.Tags] = QueryTags.encode(query_tags)
+
+    data: dict[str, Any] = {
+        "query": fql,
+        "arguments": arguments or {},
+    }
+
+    with self._session.request(
+        method="POST",
+        url=self._endpoint + path,
+        headers=headers,
+        data=data,
+    ) as response:
+      response_json = response.json()
+      headers = response.headers()
+      status_code = response.status_code()
+
+      self._check_protocol(response_json, status_code)
+
+      dec: Any = FaunaDecoder.decode(response_json)
+
+      if status_code > 399:
+        self._handle_error(dec, status_code)
+
+      if "txn_ts" in dec:
+        self.set_last_txn_ts(int(response_json["txn_ts"]))
+
+      stats = QueryStats(dec["stats"]) if "stats" in dec else None
+      summary = dec["summary"] if "summary" in dec else None
+      query_tags = QueryTags.decode(
+          dec["query_tags"]) if "query_tags" in dec else None
+      txn_ts = dec["txn_ts"] if "txn_ts" in dec else None
+      schema_version = dec["schema_version"] if "schema_version" in dec else None
+      traceparent = headers.get("traceparent", None)
+      static_type = dec["static_type"] if "static_type" in dec else None
+
+      return QuerySuccess(
+          data=dec["data"],
+          query_tags=query_tags,
+          static_type=static_type,
+          stats=stats,
+          summary=summary,
+          traceparent=traceparent,
+          txn_ts=txn_ts,
+          schema_version=schema_version,
+      )
+
+  def _check_protocol(self, response_json: Any, status_code):
+    # TODO: Logic to validate wire protocol belongs elsewhere.
+    should_raise = False
+
+    # check for QuerySuccess
+    if status_code <= 399 and "data" not in response_json:
+      should_raise = True
+
+    # check for QueryFailure
+    if status_code > 399:
+      if "error" not in response_json:
+        should_raise = True
+      else:
+        e = response_json["error"]
+        if "code" not in e or "message" not in e:
+          should_raise = True
+
+    if should_raise:
+      raise ProtocolError(
+          status_code,
+          f"Response is in an unknown format: \n{response_json}",
+      )
+
+  def _handle_error(self, body: Any, status_code: int):
+    err = body["error"]
+    code = err["code"]
+    message = err["message"]
+
+    query_tags = QueryTags.decode(
+        body["query_tags"]) if "query_tags" in body else None
+    stats = QueryStats(body["stats"]) if "stats" in body else None
+    txn_ts = body["txn_ts"] if "txn_ts" in body else None
+    schema_version = body["schema_version"] if "schema_version" in body else None
+    summary = body["summary"] if "summary" in body else None
+
+    constraint_failures: Optional[List[ConstraintFailure]] = None
+    if "constraint_failures" in err:
+      constraint_failures = [
+          ConstraintFailure(
+              message=cf["message"],
+              name=cf["name"] if "name" in cf else None,
+              paths=cf["paths"] if "paths" in cf else None,
+          ) for cf in err["constraint_failures"]
+      ]
+
+    if status_code == 400:
+      if code == "invalid_query":
+        raise QueryCheckError(
+            status_code=status_code,
+            code=code,
+            message=message,
+            summary=summary,
+            constraint_failures=constraint_failures,
+            query_tags=query_tags,
+            stats=stats,
+            txn_ts=txn_ts,
+            schema_version=schema_version,
+        )
+      elif code == "invalid_request":
+        raise InvalidRequestError(
+            status_code=status_code,
+            code=code,
+            message=message,
+            summary=summary,
+            constraint_failures=constraint_failures,
+            query_tags=query_tags,
+            stats=stats,
+            txn_ts=txn_ts,
+            schema_version=schema_version,
+        )
+      elif code == "abort":
+        abort = err["abort"] if "abort" in err else None
+        raise AbortError(
+            status_code=status_code,
+            code=code,
+            message=message,
+            summary=summary,
+            abort=abort,
+            constraint_failures=constraint_failures,
+            query_tags=query_tags,
+            stats=stats,
+            txn_ts=txn_ts,
+            schema_version=schema_version,
         )
 
-    def _query(
-        self,
-        path: str,
-        fql: Mapping[str, Any],
-        arguments: Optional[Mapping[str, Any]] = None,
-        opts: Optional[QueryOptions] = None,
-    ) -> QuerySuccess:
-
-        headers = self._headers.copy()
-        headers[_Header.Format] = "tagged"
-        headers[_Header.Authorization] = self._auth.bearer()
-
-        if self._query_timeout_ms is not None:
-            headers[Header.QueryTimeoutMs] = str(self._query_timeout_ms)
-
-        headers.update(self._last_txn_ts.request_header)
-
-        query_tags = {}
-        if self._query_tags is not None:
-            query_tags.update(self._query_tags)
-
-        if opts is not None:
-            if opts.linearized is not None:
-                headers[Header.Linearized] = str(opts.linearized).lower()
-            if opts.max_contention_retries is not None:
-                headers[Header.MaxContentionRetries] = \
-                    f"{opts.max_contention_retries}"
-            if opts.traceparent is not None:
-                headers[Header.Traceparent] = opts.traceparent
-            if opts.query_timeout is not None:
-                timeout_ms = f"{int(opts.query_timeout.total_seconds() * 1000)}"
-                headers[Header.QueryTimeoutMs] = timeout_ms
-            if opts.query_tags is not None:
-                query_tags.update(opts.query_tags)
-            if opts.typecheck is not None:
-                headers[Header.Typecheck] = str(opts.typecheck).lower()
-            if opts.additional_headers is not None:
-                headers.update(opts.additional_headers)
-
-        if len(query_tags) > 0:
-            headers[Header.Tags] = QueryTags.encode(query_tags)
-
-        data: dict[str, Any] = {
-            "query": fql,
-            "arguments": arguments or {},
-        }
-
-        with self._session.request(
-                method="POST",
-                url=self._endpoint + path,
-                headers=headers,
-                data=data,
-        ) as response:
-            response_json = response.json()
-            headers = response.headers()
-            status_code = response.status_code()
-
-            self._check_protocol(response_json, status_code)
-
-            dec: Any = FaunaDecoder.decode(response_json)
-
-            if status_code > 399:
-                self._handle_error(dec, status_code)
-
-            if "txn_ts" in dec:
-                self.set_last_txn_ts(int(response_json["txn_ts"]))
-
-            stats = QueryStats(dec["stats"]) if "stats" in dec else None
-            summary = dec["summary"] if "summary" in dec else None
-            query_tags = QueryTags.decode(
-                dec["query_tags"]) if "query_tags" in dec else None
-            txn_ts = dec["txn_ts"] if "txn_ts" in dec else None
-            traceparent = headers.get("traceparent", None)
-            static_type = dec["static_type"] if "static_type" in dec else None
-
-            return QuerySuccess(
-                data=dec["data"],
-                query_tags=query_tags,
-                static_type=static_type,
-                stats=stats,
-                summary=summary,
-                traceparent=traceparent,
-                txn_ts=txn_ts,
-            )
-
-    def _check_protocol(self, response_json: Any, status_code):
-        # TODO: Logic to validate wire protocol belongs elsewhere.
-        should_raise = False
-
-        # check for QuerySuccess
-        if status_code <= 399 and "data" not in response_json:
-            should_raise = True
-
-        # check for QueryFailure
-        if status_code > 399:
-            if "error" not in response_json:
-                should_raise = True
-            else:
-                e = response_json["error"]
-                if "code" not in e or "message" not in e:
-                    should_raise = True
-
-        if should_raise:
-            raise ProtocolError(
-                status_code,
-                f"Response is in an unknown format: \n{response_json}",
-            )
-
-    def _handle_error(self, body: Any, status_code: int):
-        err = body["error"]
-        code = err["code"]
-        message = err["message"]
-
-        query_tags = QueryTags.decode(
-            body["query_tags"]) if "query_tags" in body else None
-        stats = QueryStats(body["stats"]) if "stats" in body else None
-        txn_ts = body["txn_ts"] if "txn_ts" in body else None
-        summary = body["summary"] if "summary" in body else None
-
-        constraint_failures: Optional[List[ConstraintFailure]] = None
-        if "constraint_failures" in err:
-            constraint_failures = [
-                ConstraintFailure(
-                    message=cf["message"],
-                    name=cf["name"] if "name" in cf else None,
-                    paths=cf["paths"] if "paths" in cf else None,
-                ) for cf in err["constraint_failures"]
-            ]
-
-        if status_code == 400:
-            if code == "invalid_query":
-                raise QueryCheckError(
-                    status_code=status_code,
-                    code=code,
-                    message=message,
-                    summary=summary,
-                    constraint_failures=constraint_failures,
-                    query_tags=query_tags,
-                    stats=stats,
-                    txn_ts=txn_ts,
-                )
-            elif code == "invalid_request":
-                raise InvalidRequestError(
-                    status_code=status_code,
-                    code=code,
-                    message=message,
-                    summary=summary,
-                    constraint_failures=constraint_failures,
-                    query_tags=query_tags,
-                    stats=stats,
-                    txn_ts=txn_ts,
-                )
-            elif code == "abort":
-                abort = err["abort"] if "abort" in err else None
-                raise AbortError(
-                    status_code=status_code,
-                    code=code,
-                    message=message,
-                    summary=summary,
-                    abort=abort,
-                    constraint_failures=constraint_failures,
-                    query_tags=query_tags,
-                    stats=stats,
-                    txn_ts=txn_ts,
-                )
-
-            else:
-                raise QueryRuntimeError(
-                    status_code=status_code,
-                    code=code,
-                    message=message,
-                    summary=summary,
-                    constraint_failures=constraint_failures,
-                    query_tags=query_tags,
-                    stats=stats,
-                    txn_ts=txn_ts,
-                )
-        elif status_code == 401:
-            raise AuthenticationError(
-                status_code=status_code,
-                code=code,
-                message=message,
-                summary=summary,
-                constraint_failures=constraint_failures,
-                query_tags=query_tags,
-                stats=stats,
-                txn_ts=txn_ts,
-            )
-        elif status_code == 403:
-            raise AuthorizationError(
-                status_code=status_code,
-                code=code,
-                message=message,
-                summary=summary,
-                constraint_failures=constraint_failures,
-                query_tags=query_tags,
-                stats=stats,
-                txn_ts=txn_ts,
-            )
-        elif status_code == 429:
-            raise ThrottlingError(
-                status_code=status_code,
-                code=code,
-                message=message,
-                summary=summary,
-                constraint_failures=constraint_failures,
-                query_tags=query_tags,
-                stats=stats,
-                txn_ts=txn_ts,
-            )
-        elif status_code == 440:
-            raise QueryTimeoutError(
-                status_code=status_code,
-                code=code,
-                message=message,
-                summary=summary,
-                constraint_failures=constraint_failures,
-                query_tags=query_tags,
-                stats=stats,
-                txn_ts=txn_ts,
-            )
-        elif status_code == 500:
-            raise ServiceInternalError(
-                status_code=status_code,
-                code=code,
-                message=message,
-                summary=summary,
-                constraint_failures=constraint_failures,
-                query_tags=query_tags,
-                stats=stats,
-                txn_ts=txn_ts,
-            )
-        elif status_code == 503:
-            raise ServiceTimeoutError(
-                status_code=status_code,
-                code=code,
-                message=message,
-                summary=summary,
-                constraint_failures=constraint_failures,
-                query_tags=query_tags,
-                stats=stats,
-                txn_ts=txn_ts,
-            )
-        else:
-            raise ServiceError(
-                status_code=status_code,
-                code=code,
-                message=message,
-                summary=summary,
-                constraint_failures=constraint_failures,
-                query_tags=query_tags,
-                stats=stats,
-                txn_ts=txn_ts,
-            )
-
-    def _set_endpoint(self, endpoint):
-        if endpoint is None:
-            endpoint = _Environment.EnvFaunaEndpoint()
+      else:
+        raise QueryRuntimeError(
+            status_code=status_code,
+            code=code,
+            message=message,
+            summary=summary,
+            constraint_failures=constraint_failures,
+            query_tags=query_tags,
+            stats=stats,
+            txn_ts=txn_ts,
+            schema_version=schema_version,
+        )
+    elif status_code == 401:
+      raise AuthenticationError(
+          status_code=status_code,
+          code=code,
+          message=message,
+          summary=summary,
+          constraint_failures=constraint_failures,
+          query_tags=query_tags,
+          stats=stats,
+          txn_ts=txn_ts,
+          schema_version=schema_version,
+      )
+    elif status_code == 403:
+      raise AuthorizationError(
+          status_code=status_code,
+          code=code,
+          message=message,
+          summary=summary,
+          constraint_failures=constraint_failures,
+          query_tags=query_tags,
+          stats=stats,
+          txn_ts=txn_ts,
+          schema_version=schema_version,
+      )
+    elif status_code == 429:
+      raise ThrottlingError(
+          status_code=status_code,
+          code=code,
+          message=message,
+          summary=summary,
+          constraint_failures=constraint_failures,
+          query_tags=query_tags,
+          stats=stats,
+          txn_ts=txn_ts,
+          schema_version=schema_version,
+      )
+    elif status_code == 440:
+      raise QueryTimeoutError(
+          status_code=status_code,
+          code=code,
+          message=message,
+          summary=summary,
+          constraint_failures=constraint_failures,
+          query_tags=query_tags,
+          stats=stats,
+          txn_ts=txn_ts,
+          schema_version=schema_version,
+      )
+    elif status_code == 500:
+      raise ServiceInternalError(
+          status_code=status_code,
+          code=code,
+          message=message,
+          summary=summary,
+          constraint_failures=constraint_failures,
+          query_tags=query_tags,
+          stats=stats,
+          txn_ts=txn_ts,
+          schema_version=schema_version,
+      )
+    elif status_code == 503:
+      raise ServiceTimeoutError(
+          status_code=status_code,
+          code=code,
+          message=message,
+          summary=summary,
+          constraint_failures=constraint_failures,
+          query_tags=query_tags,
+          stats=stats,
+          txn_ts=txn_ts,
+          schema_version=schema_version,
+      )
+    else:
+      raise ServiceError(
+          status_code=status_code,
+          code=code,
+          message=message,
+          summary=summary,
+          constraint_failures=constraint_failures,
+          query_tags=query_tags,
+          stats=stats,
+          txn_ts=txn_ts,
+          schema_version=schema_version,
+      )
+
+  def _set_endpoint(self, endpoint):
+    if endpoint is None:
+      endpoint = _Environment.EnvFaunaEndpoint()
 
-        if endpoint[-1:] == "/":
-            endpoint = endpoint[:-1]
+    if endpoint[-1:] == "/":
+      endpoint = endpoint[:-1]
 
-        self._endpoint = endpoint
+    self._endpoint = endpoint
 
 
 class QueryIterator:
-    """A class to provider an iterator on top of Fauna queries."""
+  """A class to provider an iterator on top of Fauna queries."""
 
-    def __init__(self,
-                 client: Client,
-                 fql: Query,
-                 opts: Optional[QueryOptions] = None):
-        """Initializes the QueryIterator
+  def __init__(self,
+               client: Client,
+               fql: Query,
+               opts: Optional[QueryOptions] = None):
+    """Initializes the QueryIterator
 
         :param fql: A Query
         :param opts: (Optional) Query Options
 
         :raises TypeError: Invalid param types
         """
-        if not isinstance(client, Client):
-            err_msg = f"'client' must be a Client but was a {type(client)}. You can build a " \
-                        f"Client by calling fauna.client.Client()"
-            raise TypeError(err_msg)
-
-        if not isinstance(fql, Query):
-            err_msg = f"'fql' must be a Query but was a {type(fql)}. You can build a " \
-                       f"Query by calling fauna.fql()"
-            raise TypeError(err_msg)
-
-        self.client = client
-        self.fql = fql
-        self.opts = opts
+    if not isinstance(client, Client):
+      err_msg = f"'client' must be a Client but was a {type(client)}. You can build a " \
+                  f"Client by calling fauna.client.Client()"
+      raise TypeError(err_msg)
+
+    if not isinstance(fql, Query):
+      err_msg = f"'fql' must be a Query but was a {type(fql)}. You can build a " \
+                 f"Query by calling fauna.fql()"
+      raise TypeError(err_msg)
+
+    self.client = client
+    self.fql = fql
+    self.opts = opts
 
-    def __iter__(self) -> Iterator:
-        return self.iter()
+  def __iter__(self) -> Iterator:
+    return self.iter()
 
-    def iter(self) -> Iterator:
-        """
+  def iter(self) -> Iterator:
+    """
         A generator function that immediately fetches and yields the results of
         the stored query. Yields additional pages on subsequent iterations if
         they exist
         """
 
-        cursor = None
-        initial_response = self.client.query(self.fql, self.opts)
+    cursor = None
+    initial_response = self.client.query(self.fql, self.opts)
 
-        if isinstance(initial_response.data, Page):
-            cursor = initial_response.data.after
-            yield initial_response.data.data
-
-            while cursor is not None:
-                next_response = self.client.query(
-                    fql("Set.paginate(${after})", after=cursor), self.opts)
-                # TODO: `Set.paginate` does not yet return a `@set` tagged value
-                #       so we will get back a plain object that might not have
-                #       an after property.
-                cursor = next_response.data.get("after")
-                yield next_response.data.get("data")
+    if isinstance(initial_response.data, Page):
+      cursor = initial_response.data.after
+      yield initial_response.data.data
+
+      while cursor is not None:
+        next_response = self.client.query(
+            fql("Set.paginate(${after})", after=cursor), self.opts)
+        # TODO: `Set.paginate` does not yet return a `@set` tagged value
+        #       so we will get back a plain object that might not have
+        #       an after property.
+        cursor = next_response.data.get("after")
+        yield next_response.data.get("data")
 
-        else:
-            yield [initial_response.data]
+    else:
+      yield [initial_response.data]
 
-    def flatten(self) -> Iterator:
-        """
+  def flatten(self) -> Iterator:
+    """
         A generator function that immediately fetches and yields the results of
         the stored query. Yields each item individually, rather than a whole
         Page at a time. Fetches additional pages as required if they exist.
         """
 
-        for page in self.iter():
-            for item in page:
-                yield item
+    for page in self.iter():
+      for item in page:
+        yield item
```

## fauna/client/endpoints.py

```diff
@@ -1,3 +1,3 @@
 class Endpoints:
-    Default = "https://db.fauna.com"
-    Local = "http://localhost:8443"
+  Default = "https://db.fauna.com"
+  Local = "http://localhost:8443"
```

## fauna/client/headers.py

```diff
@@ -4,107 +4,107 @@
 from dataclasses import dataclass
 from typing import Callable
 
 from fauna import __version__
 
 
 class Header:
-    LastTxnTs = "X-Last-Txn-Ts"
-    Linearized = "X-Linearized"
-    MaxContentionRetries = "X-Max-Contention-Retries"
-    QueryTimeoutMs = "X-Query-Timeout-Ms"
-    Typecheck = "X-Typecheck"
-    Tags = "X-Query-Tags"
-    Traceparent = "Traceparent"
+  LastTxnTs = "X-Last-Txn-Ts"
+  Linearized = "X-Linearized"
+  MaxContentionRetries = "X-Max-Contention-Retries"
+  QueryTimeoutMs = "X-Query-Timeout-Ms"
+  Typecheck = "X-Typecheck"
+  Tags = "X-Query-Tags"
+  Traceparent = "Traceparent"
 
 
 class _Header:
-    AcceptEncoding = "Accept-Encoding"
-    Authorization = "Authorization"
-    ContentType = "Content-Type"
-    Driver = "X-Driver"
-    DriverEnv = "X-Driver-Env"
-    Format = "X-Format"
+  AcceptEncoding = "Accept-Encoding"
+  Authorization = "Authorization"
+  ContentType = "Content-Type"
+  Driver = "X-Driver"
+  DriverEnv = "X-Driver-Env"
+  Format = "X-Format"
 
 
 class _Auth:
-    """Creates an auth helper object"""
+  """Creates an auth helper object"""
 
-    def bearer(self):
-        return "Bearer {}".format(self.secret)
+  def bearer(self):
+    return "Bearer {}".format(self.secret)
 
-    def __init__(self, secret):
-        self.secret = secret
+  def __init__(self, secret):
+    self.secret = secret
 
-    def __eq__(self, other):
-        return self.secret == getattr(other, 'secret', None)
+  def __eq__(self, other):
+    return self.secret == getattr(other, 'secret', None)
 
-    def __ne__(self, other):
-        return not self == other
+  def __ne__(self, other):
+    return not self == other
 
 
 class _DriverEnvironment:
 
-    def __init__(self):
-        self.pythonVersion = "{0}.{1}.{2}-{3}".format(*sys.version_info)
-        self.driverVersion = __version__
-        self.env = self._get_runtime_env()
-        self.os = "{0}-{1}".format(platform.system(), platform.release())
-
-    @staticmethod
-    def _get_runtime_env():
-
-        @dataclass
-        class EnvChecker:
-            name: str
-            check: Callable[[], bool]
-
-        env: list[EnvChecker] = [
-            EnvChecker(
-                name="Netlify",
-                check=lambda: "NETLIFY_IMAGES_CDN_DOMAIN" in os.environ,
-            ),
-            EnvChecker(
-                name="Vercel",
-                check=lambda: "VERCEL" in os.environ,
-            ),
-            EnvChecker(
-                name="Heroku",
-                check=lambda: "PATH" in \
-                    os.environ and ".heroku" in os.environ["PATH"],
-            ),
-            EnvChecker(
-                name="AWS Lambda",
-                check=lambda: "AWS_LAMBDA_FUNCTION_VERSION" in os.environ,
-            ),
-            EnvChecker(
-                name="GCP Cloud Functions",
-                check=lambda: "_" in \
-                    os.environ and "google" in os.environ["_"],
-            ),
-            EnvChecker(
-                name="GCP Compute Instances",
-                check=lambda: "GOOGLE_CLOUD_PROJECT" in os.environ,
-            ),
-            EnvChecker(
-                name="Azure Cloud Functions",
-                check=lambda: "WEBSITE_FUNCTIONS_AZUREMONITOR_CATEGORIES" in \
-                    os.environ,
-            ),
-            EnvChecker(
-                name="Azure Compute",
-                check=lambda: "ORYX_ENV_TYPE" in os.environ and \
-                    "WEBSITE_INSTANCE_ID" in os.environ and \
-                    os.environ["ORYX_ENV_TYPE"] == "AppService",
-            ),
-        ]
-
-        try:
-            recognized = next(e for e in env if e.check())
-            if recognized is not None:
-                return recognized.name
-        except:
-            return "Unknown"
-
-    def __str__(self):
-        return "driver=python-{0}; runtime=python-{1} env={2}; os={3}".format(
-            self.driverVersion, self.pythonVersion, self.env, self.os).lower()
+  def __init__(self):
+    self.pythonVersion = "{0}.{1}.{2}-{3}".format(*sys.version_info)
+    self.driverVersion = __version__
+    self.env = self._get_runtime_env()
+    self.os = "{0}-{1}".format(platform.system(), platform.release())
+
+  @staticmethod
+  def _get_runtime_env():
+
+    @dataclass
+    class EnvChecker:
+      name: str
+      check: Callable[[], bool]
+
+    env: list[EnvChecker] = [
+        EnvChecker(
+            name="Netlify",
+            check=lambda: "NETLIFY_IMAGES_CDN_DOMAIN" in os.environ,
+        ),
+        EnvChecker(
+            name="Vercel",
+            check=lambda: "VERCEL" in os.environ,
+        ),
+        EnvChecker(
+            name="Heroku",
+            check=lambda: "PATH" in \
+                os.environ and ".heroku" in os.environ["PATH"],
+        ),
+        EnvChecker(
+            name="AWS Lambda",
+            check=lambda: "AWS_LAMBDA_FUNCTION_VERSION" in os.environ,
+        ),
+        EnvChecker(
+            name="GCP Cloud Functions",
+            check=lambda: "_" in \
+                os.environ and "google" in os.environ["_"],
+        ),
+        EnvChecker(
+            name="GCP Compute Instances",
+            check=lambda: "GOOGLE_CLOUD_PROJECT" in os.environ,
+        ),
+        EnvChecker(
+            name="Azure Cloud Functions",
+            check=lambda: "WEBSITE_FUNCTIONS_AZUREMONITOR_CATEGORIES" in \
+                os.environ,
+        ),
+        EnvChecker(
+            name="Azure Compute",
+            check=lambda: "ORYX_ENV_TYPE" in os.environ and \
+                "WEBSITE_INSTANCE_ID" in os.environ and \
+                os.environ["ORYX_ENV_TYPE"] == "AppService",
+        ),
+    ]
+
+    try:
+      recognized = next(e for e in env if e.check())
+      if recognized is not None:
+        return recognized.name
+    except:
+      return "Unknown"
+
+  def __str__(self):
+    return "driver=python-{0}; runtime=python-{1} env={2}; os={3}".format(
+        self.driverVersion, self.pythonVersion, self.env, self.os).lower()
```

## fauna/client/utils.py

```diff
@@ -3,80 +3,80 @@
 from typing import Generic, Callable, TypeVar, Optional
 
 from fauna.client.endpoints import Endpoints
 from fauna.client.headers import Header
 
 
 def _fancy_bool_from_str(val: str) -> bool:
-    return val.lower() in ["1", "true", "yes", "y"]
+  return val.lower() in ["1", "true", "yes", "y"]
 
 
 class LastTxnTs(object):
-    """Wraps tracking the last transaction time supplied from the database."""
+  """Wraps tracking the last transaction time supplied from the database."""
 
-    def __init__(
-        self,
-        time: Optional[int] = None,
-    ):
-        self._lock: threading.Lock = threading.Lock()
-        self._time: Optional[int] = time
-
-    @property
-    def time(self):
-        """Produces the last transaction time, or, None if not yet updated."""
-        with self._lock:
-            return self._time
-
-    @property
-    def request_header(self):
-        """Produces a dictionary with a non-zero `X-Last-Seen-Txn` header; or,
+  def __init__(
+      self,
+      time: Optional[int] = None,
+  ):
+    self._lock: threading.Lock = threading.Lock()
+    self._time: Optional[int] = time
+
+  @property
+  def time(self):
+    """Produces the last transaction time, or, None if not yet updated."""
+    with self._lock:
+      return self._time
+
+  @property
+  def request_header(self):
+    """Produces a dictionary with a non-zero `X-Last-Seen-Txn` header; or,
         if one has not yet been set, the empty header dictionary."""
-        t = self._time
-        if t is None:
-            return {}
-        return {Header.LastTxnTs: str(t)}
+    t = self._time
+    if t is None:
+      return {}
+    return {Header.LastTxnTs: str(t)}
 
-    def update_txn_time(self, new_txn_time: int):
-        """Updates the internal transaction time.
+  def update_txn_time(self, new_txn_time: int):
+    """Updates the internal transaction time.
         In order to maintain a monotonically-increasing value, `newTxnTime`
         is discarded if it is behind the current timestamp."""
-        with self._lock:
-            self._time = max(self._time or 0, new_txn_time)
+    with self._lock:
+      self._time = max(self._time or 0, new_txn_time)
 
 
 T = TypeVar('T')
 
 
 class _SettingFromEnviron(Generic[T]):
 
-    def __init__(
-        self,
-        var_name: str,
-        default_value: str,
-        adapt_from_str: Callable[[str], T],
-    ):
-        self.__var_name = var_name
-        self.__default_value = default_value
-        self.__adapt_from_str = adapt_from_str
-
-    def __call__(self) -> T:
-        return self.__adapt_from_str(
-            os.environ.get(
-                self.__var_name,
-                default=self.__default_value,
-            ))
+  def __init__(
+      self,
+      var_name: str,
+      default_value: str,
+      adapt_from_str: Callable[[str], T],
+  ):
+    self.__var_name = var_name
+    self.__default_value = default_value
+    self.__adapt_from_str = adapt_from_str
+
+  def __call__(self) -> T:
+    return self.__adapt_from_str(
+        os.environ.get(
+            self.__var_name,
+            default=self.__default_value,
+        ))
 
 
 class _Environment:
-    EnvFaunaEndpoint = _SettingFromEnviron(
-        "FAUNA_ENDPOINT",
-        Endpoints.Default,
-        str,
-    )
-    """environment variable for Fauna Client HTTP endpoint"""
-
-    EnvFaunaSecret = _SettingFromEnviron(
-        "FAUNA_SECRET",
-        "",
-        str,
-    )
-    """environment variable for Fauna Client authentication"""
+  EnvFaunaEndpoint = _SettingFromEnviron(
+      "FAUNA_ENDPOINT",
+      Endpoints.Default,
+      str,
+  )
+  """environment variable for Fauna Client HTTP endpoint"""
+
+  EnvFaunaSecret = _SettingFromEnviron(
+      "FAUNA_SECRET",
+      "",
+      str,
+  )
+  """environment variable for Fauna Client authentication"""
```

## fauna/encoding/decoder.py

```diff
@@ -3,15 +3,15 @@
 from iso8601 import parse_date
 
 from fauna.query.models import Module, DocumentReference, Document, NamedDocument, NamedDocumentReference, Page, \
     NullDocument
 
 
 class FaunaDecoder:
-    """Supports the following types:
+  """Supports the following types:
 
      +--------------------+---------------+
      | Python             | Fauna         |
      +====================+===============+
      | dict               | object        |
      +--------------------+---------------+
      | list, tuple        | array         |
@@ -41,129 +41,128 @@
      | Module             | @mod          |
      +--------------------+---------------+
      | Page               | @set          |
      +--------------------+---------------+
 
      """
 
-    @staticmethod
-    def decode(obj: Any):
-        """Decodes supported objects from the tagged typed into untagged.
+  @staticmethod
+  def decode(obj: Any):
+    """Decodes supported objects from the tagged typed into untagged.
 
         Examples:
             - { "@int": "100" } decodes to 100 of type int
             - { "@double": "100" } decodes to 100.0 of type float
             - { "@long": "100" } decodes to 100 of type int
             - { "@time": "..." } decodes to a datetime
             - { "@date": "..." } decodes to a date
             - { "@doc": ... } decodes to a Document or NamedDocument
             - { "@ref": ... } decodes to a DocumentReference or NamedDocumentReference
             - { "@mod": ... } decodes to a Module
             - { "@set": ... } decodes to a Page
 
         :param obj: the object to decode
         """
-        return FaunaDecoder._decode(obj)
+    return FaunaDecoder._decode(obj)
 
-    @staticmethod
-    def _decode(o: Any, escaped: bool = False):
-        if isinstance(o, (str, bool, int, float)):
-            return o
-        elif isinstance(o, list):
-            return FaunaDecoder._decode_list(o)
-        elif isinstance(o, dict):
-            return FaunaDecoder._decode_dict(o, escaped)
-
-    @staticmethod
-    def _decode_list(lst: List):
-        return [FaunaDecoder._decode(i) for i in lst]
-
-    @staticmethod
-    def _decode_dict(dct: dict, escaped: bool):
-        keys = dct.keys()
-
-        # If escaped, everything is user-specified
-        if escaped:
-            return {k: FaunaDecoder._decode(v) for k, v in dct.items()}
-
-        if len(keys) == 1:
-            if "@int" in keys:
-                return int(dct["@int"])
-            if "@long" in keys:
-                return int(dct["@long"])
-            if "@double" in dct:
-                return float(dct["@double"])
-            if "@object" in dct:
-                return FaunaDecoder._decode(dct["@object"], True)
-            if "@mod" in dct:
-                return Module(dct["@mod"])
-            if "@time" in dct:
-                return parse_date(dct["@time"])
-            if "@date" in dct:
-                return parse_date(dct["@date"]).date()
-            if "@doc" in dct:
-                value = dct["@doc"]
-                if isinstance(value, str):
-                    # Not distinguishing between DocumentReference and NamedDocumentReference because this shouldn't
-                    # be an issue much longer
-                    return DocumentReference.from_string(value)
-
-                contents = FaunaDecoder._decode(value)
-
-                if "id" in contents and "coll" in contents and "ts" in contents:
-                    doc_id = contents.pop("id")
-                    doc_coll = contents.pop("coll")
-                    doc_ts = contents.pop("ts")
-
-                    return Document(
-                        id=doc_id,
-                        coll=doc_coll,
-                        ts=doc_ts,
-                        data=contents,
-                    )
-                elif "name" in contents and "coll" in contents and "ts" in contents:
-                    doc_name = contents.pop("name")
-                    doc_coll = contents.pop("coll")
-                    doc_ts = contents.pop("ts")
-
-                    return NamedDocument(
-                        name=doc_name,
-                        coll=doc_coll,
-                        ts=doc_ts,
-                        data=contents,
-                    )
-                else:
-                    # Unsupported document reference. Return the unwrapped value to futureproof.
-                    return contents
-
-            if "@ref" in dct:
-                value = dct["@ref"]
-                if "id" not in value and "name" not in value:
-                    # Unsupported document reference. Return the unwrapped value to futureproof.
-                    return value
-
-                col = FaunaDecoder._decode(value["coll"])
-                doc_ref: Union[DocumentReference, NamedDocumentReference]
-
-                if "id" in value:
-                    doc_ref = DocumentReference(col, value["id"])
-                else:
-                    doc_ref = NamedDocumentReference(col, value["name"])
-
-                if "exists" in value and not value["exists"]:
-                    cause = value["cause"] if "cause" in value else None
-                    return NullDocument(doc_ref, cause)
-
-                return doc_ref
-
-            if "@set" in dct:
-                value = dct["@set"]
-                if isinstance(value, str):
-                    return Page(after=value)
-
-                after = value["after"] if "after" in value else None
-                data = FaunaDecoder._decode(
-                    value["data"]) if "data" in value else None
+  @staticmethod
+  def _decode(o: Any, escaped: bool = False):
+    if isinstance(o, (str, bool, int, float)):
+      return o
+    elif isinstance(o, list):
+      return FaunaDecoder._decode_list(o)
+    elif isinstance(o, dict):
+      return FaunaDecoder._decode_dict(o, escaped)
+
+  @staticmethod
+  def _decode_list(lst: List):
+    return [FaunaDecoder._decode(i) for i in lst]
+
+  @staticmethod
+  def _decode_dict(dct: dict, escaped: bool):
+    keys = dct.keys()
+
+    # If escaped, everything is user-specified
+    if escaped:
+      return {k: FaunaDecoder._decode(v) for k, v in dct.items()}
+
+    if len(keys) == 1:
+      if "@int" in keys:
+        return int(dct["@int"])
+      if "@long" in keys:
+        return int(dct["@long"])
+      if "@double" in dct:
+        return float(dct["@double"])
+      if "@object" in dct:
+        return FaunaDecoder._decode(dct["@object"], True)
+      if "@mod" in dct:
+        return Module(dct["@mod"])
+      if "@time" in dct:
+        return parse_date(dct["@time"])
+      if "@date" in dct:
+        return parse_date(dct["@date"]).date()
+      if "@doc" in dct:
+        value = dct["@doc"]
+        if isinstance(value, str):
+          # Not distinguishing between DocumentReference and NamedDocumentReference because this shouldn't
+          # be an issue much longer
+          return DocumentReference.from_string(value)
+
+        contents = FaunaDecoder._decode(value)
+
+        if "id" in contents and "coll" in contents and "ts" in contents:
+          doc_id = contents.pop("id")
+          doc_coll = contents.pop("coll")
+          doc_ts = contents.pop("ts")
+
+          return Document(
+              id=doc_id,
+              coll=doc_coll,
+              ts=doc_ts,
+              data=contents,
+          )
+        elif "name" in contents and "coll" in contents and "ts" in contents:
+          doc_name = contents.pop("name")
+          doc_coll = contents.pop("coll")
+          doc_ts = contents.pop("ts")
+
+          return NamedDocument(
+              name=doc_name,
+              coll=doc_coll,
+              ts=doc_ts,
+              data=contents,
+          )
+        else:
+          # Unsupported document reference. Return the unwrapped value to futureproof.
+          return contents
+
+      if "@ref" in dct:
+        value = dct["@ref"]
+        if "id" not in value and "name" not in value:
+          # Unsupported document reference. Return the unwrapped value to futureproof.
+          return value
+
+        col = FaunaDecoder._decode(value["coll"])
+        doc_ref: Union[DocumentReference, NamedDocumentReference]
+
+        if "id" in value:
+          doc_ref = DocumentReference(col, value["id"])
+        else:
+          doc_ref = NamedDocumentReference(col, value["name"])
+
+        if "exists" in value and not value["exists"]:
+          cause = value["cause"] if "cause" in value else None
+          return NullDocument(doc_ref, cause)
+
+        return doc_ref
+
+      if "@set" in dct:
+        value = dct["@set"]
+        if isinstance(value, str):
+          return Page(after=value)
 
-                return Page(data=data, after=after)
+        after = value["after"] if "after" in value else None
+        data = FaunaDecoder._decode(value["data"]) if "data" in value else None
 
-        return {k: FaunaDecoder._decode(v) for k, v in dct.items()}
+        return Page(data=data, after=after)
+
+    return {k: FaunaDecoder._decode(v) for k, v in dct.items()}
```

## fauna/encoding/encoder.py

```diff
@@ -15,15 +15,15 @@
     "@ref",
     "@set",
     "@time",
 ]
 
 
 class FaunaEncoder:
-    """Supports the following types:
+  """Supports the following types:
 
     +-------------------------------+---------------+
     | Python                        | Fauna Tags    |
     +===============================+===============+
     | dict                          | @object       |
     +-------------------------------+---------------+
     | list, tuple                   | array         |
@@ -57,17 +57,17 @@
     | ValueFragment                 | value         |
     +-------------------------------+---------------+
     | TemplateFragment              | string        |
     +-------------------------------+---------------+
 
     """
 
-    @staticmethod
-    def encode(obj: Any) -> Any:
-        """Encodes supported objects into the tagged format.
+  @staticmethod
+  def encode(obj: Any) -> Any:
+    """Encodes supported objects into the tagged format.
 
         Examples:
             - Up to 32-bit ints encode to { "@int": "..." }
             - Up to 64-bit ints encode to { "@long": "..." }
             - Floats encode to { "@double": "..." }
             - datetime encodes to { "@time": "..." }
             - date encodes to { "@date": "..." }
@@ -76,160 +76,145 @@
             - Query encodes to { "fql": [...] }
             - ValueFragment encodes to { "value": <encoded_val> }
             - LiteralFragment encodes to a string
 
         :raises ValueError: If value cannot be encoded, cannot be encoded safely, or there's a circular reference.
         :param obj: the object to decode
         """
-        return FaunaEncoder._encode(obj)
+    return FaunaEncoder._encode(obj)
 
-    @staticmethod
-    def from_int(obj: int):
-        if -2**31 <= obj <= 2**31 - 1:
-            return {"@int": repr(obj)}
-        elif -2**63 <= obj <= 2**63 - 1:
-            return {"@long": repr(obj)}
-        else:
-            raise ValueError(
-                "Precision loss when converting int to Fauna type")
-
-    @staticmethod
-    def from_bool(obj: bool):
-        return obj
-
-    @staticmethod
-    def from_float(obj: float):
-        return {"@double": repr(obj)}
-
-    @staticmethod
-    def from_str(obj: str):
-        return obj
-
-    @staticmethod
-    def from_datetime(obj: datetime):
-        if obj.utcoffset() is None:
-            raise ValueError("datetimes must be timezone-aware")
-
-        return {"@time": obj.isoformat(sep="T")}
-
-    @staticmethod
-    def from_date(obj: date):
-        return {"@date": obj.isoformat()}
-
-    @staticmethod
-    def from_doc_ref(obj: DocumentReference):
-        return {
-            "@ref": {
-                "id": obj.id,
-                "coll": FaunaEncoder.from_mod(obj.coll)
-            }
-        }
-
-    @staticmethod
-    def from_named_doc_ref(obj: NamedDocumentReference):
-        return {
-            "@ref": {
-                "name": obj.name,
-                "coll": FaunaEncoder.from_mod(obj.coll)
-            }
-        }
-
-    @staticmethod
-    def from_mod(obj: Module):
-        return {"@mod": obj.name}
-
-    @staticmethod
-    def from_dict(obj: Any):
-        return {"@object": obj}
-
-    @staticmethod
-    def from_none():
-        return None
-
-    @staticmethod
-    def from_fragment(obj: Fragment):
-        if isinstance(obj, LiteralFragment):
-            return obj.get()
-        elif isinstance(obj, ValueFragment):
-            v = obj.get()
-            if isinstance(v, Query):
-                return FaunaEncoder.from_query_interpolation_builder(v)
-            else:
-                return {"value": FaunaEncoder.encode(v)}
-        else:
-            raise ValueError(f"Unknown fragment type: {type(obj)}")
-
-    @staticmethod
-    def from_query_interpolation_builder(obj: Query):
-        return {"fql": [FaunaEncoder.from_fragment(f) for f in obj.fragments]}
-
-    @staticmethod
-    def _encode(o: Any, _markers: Optional[Set] = None):
-        if _markers is None:
-            _markers = set()
-
-        if isinstance(o, str):
-            return FaunaEncoder.from_str(o)
-        elif o is None:
-            return FaunaEncoder.from_none()
-        elif o is True:
-            return FaunaEncoder.from_bool(o)
-        elif o is False:
-            return FaunaEncoder.from_bool(o)
-        elif isinstance(o, int):
-            return FaunaEncoder.from_int(o)
-        elif isinstance(o, float):
-            return FaunaEncoder.from_float(o)
-        elif isinstance(o, Module):
-            return FaunaEncoder.from_mod(o)
-        elif isinstance(o, DocumentReference):
-            return FaunaEncoder.from_doc_ref(o)
-        elif isinstance(o, NamedDocumentReference):
-            return FaunaEncoder.from_named_doc_ref(o)
-        elif isinstance(o, datetime):
-            return FaunaEncoder.from_datetime(o)
-        elif isinstance(o, date):
-            return FaunaEncoder.from_date(o)
-        elif isinstance(o, Document):
-            return FaunaEncoder.from_doc_ref(DocumentReference(o.coll, o.id))
-        elif isinstance(o, NamedDocument):
-            return FaunaEncoder.from_named_doc_ref(
-                NamedDocumentReference(o.coll, o.name))
-        elif isinstance(o, NullDocument):
-            return FaunaEncoder.encode(o.ref)
-        elif isinstance(o, (list, tuple)):
-            return FaunaEncoder._encode_list(o, _markers)
-        elif isinstance(o, dict):
-            return FaunaEncoder._encode_dict(o, _markers)
-        elif isinstance(o, Query):
-            return FaunaEncoder.from_query_interpolation_builder(o)
-        else:
-            raise ValueError(f"Object {o} of type {type(o)} cannot be encoded")
-
-    @staticmethod
-    def _encode_list(lst, markers):
-        _id = id(lst)
-        if _id in markers:
-            raise ValueError("Circular reference detected")
-
-        markers.add(id(lst))
-        return [FaunaEncoder._encode(elem, markers) for elem in lst]
-
-    @staticmethod
-    def _encode_dict(dct, markers):
-        _id = id(dct)
-        if _id in markers:
-            raise ValueError("Circular reference detected")
-
-        markers.add(id(dct))
-        if any(i in _RESERVED_TAGS for i in dct.keys()):
-            return {
-                "@object": {
-                    k: FaunaEncoder._encode(v, markers)
-                    for k, v in dct.items()
-                }
-            }
-        else:
-            return {
-                k: FaunaEncoder._encode(v, markers)
-                for k, v in dct.items()
-            }
+  @staticmethod
+  def from_int(obj: int):
+    if -2**31 <= obj <= 2**31 - 1:
+      return {"@int": repr(obj)}
+    elif -2**63 <= obj <= 2**63 - 1:
+      return {"@long": repr(obj)}
+    else:
+      raise ValueError("Precision loss when converting int to Fauna type")
+
+  @staticmethod
+  def from_bool(obj: bool):
+    return obj
+
+  @staticmethod
+  def from_float(obj: float):
+    return {"@double": repr(obj)}
+
+  @staticmethod
+  def from_str(obj: str):
+    return obj
+
+  @staticmethod
+  def from_datetime(obj: datetime):
+    if obj.utcoffset() is None:
+      raise ValueError("datetimes must be timezone-aware")
+
+    return {"@time": obj.isoformat(sep="T")}
+
+  @staticmethod
+  def from_date(obj: date):
+    return {"@date": obj.isoformat()}
+
+  @staticmethod
+  def from_doc_ref(obj: DocumentReference):
+    return {"@ref": {"id": obj.id, "coll": FaunaEncoder.from_mod(obj.coll)}}
+
+  @staticmethod
+  def from_named_doc_ref(obj: NamedDocumentReference):
+    return {"@ref": {"name": obj.name, "coll": FaunaEncoder.from_mod(obj.coll)}}
+
+  @staticmethod
+  def from_mod(obj: Module):
+    return {"@mod": obj.name}
+
+  @staticmethod
+  def from_dict(obj: Any):
+    return {"@object": obj}
+
+  @staticmethod
+  def from_none():
+    return None
+
+  @staticmethod
+  def from_fragment(obj: Fragment):
+    if isinstance(obj, LiteralFragment):
+      return obj.get()
+    elif isinstance(obj, ValueFragment):
+      v = obj.get()
+      if isinstance(v, Query):
+        return FaunaEncoder.from_query_interpolation_builder(v)
+      else:
+        return {"value": FaunaEncoder.encode(v)}
+    else:
+      raise ValueError(f"Unknown fragment type: {type(obj)}")
+
+  @staticmethod
+  def from_query_interpolation_builder(obj: Query):
+    return {"fql": [FaunaEncoder.from_fragment(f) for f in obj.fragments]}
+
+  @staticmethod
+  def _encode(o: Any, _markers: Optional[Set] = None):
+    if _markers is None:
+      _markers = set()
+
+    if isinstance(o, str):
+      return FaunaEncoder.from_str(o)
+    elif o is None:
+      return FaunaEncoder.from_none()
+    elif o is True:
+      return FaunaEncoder.from_bool(o)
+    elif o is False:
+      return FaunaEncoder.from_bool(o)
+    elif isinstance(o, int):
+      return FaunaEncoder.from_int(o)
+    elif isinstance(o, float):
+      return FaunaEncoder.from_float(o)
+    elif isinstance(o, Module):
+      return FaunaEncoder.from_mod(o)
+    elif isinstance(o, DocumentReference):
+      return FaunaEncoder.from_doc_ref(o)
+    elif isinstance(o, NamedDocumentReference):
+      return FaunaEncoder.from_named_doc_ref(o)
+    elif isinstance(o, datetime):
+      return FaunaEncoder.from_datetime(o)
+    elif isinstance(o, date):
+      return FaunaEncoder.from_date(o)
+    elif isinstance(o, Document):
+      return FaunaEncoder.from_doc_ref(DocumentReference(o.coll, o.id))
+    elif isinstance(o, NamedDocument):
+      return FaunaEncoder.from_named_doc_ref(
+          NamedDocumentReference(o.coll, o.name))
+    elif isinstance(o, NullDocument):
+      return FaunaEncoder.encode(o.ref)
+    elif isinstance(o, (list, tuple)):
+      return FaunaEncoder._encode_list(o, _markers)
+    elif isinstance(o, dict):
+      return FaunaEncoder._encode_dict(o, _markers)
+    elif isinstance(o, Query):
+      return FaunaEncoder.from_query_interpolation_builder(o)
+    else:
+      raise ValueError(f"Object {o} of type {type(o)} cannot be encoded")
+
+  @staticmethod
+  def _encode_list(lst, markers):
+    _id = id(lst)
+    if _id in markers:
+      raise ValueError("Circular reference detected")
+
+    markers.add(id(lst))
+    return [FaunaEncoder._encode(elem, markers) for elem in lst]
+
+  @staticmethod
+  def _encode_dict(dct, markers):
+    _id = id(dct)
+    if _id in markers:
+      raise ValueError("Circular reference detected")
+
+    markers.add(id(dct))
+    if any(i in _RESERVED_TAGS for i in dct.keys()):
+      return {
+          "@object": {
+              k: FaunaEncoder._encode(v, markers) for k, v in dct.items()
+          }
+      }
+    else:
+      return {k: FaunaEncoder._encode(v, markers) for k, v in dct.items()}
```

## fauna/encoding/wire_protocol.py

```diff
@@ -1,188 +1,202 @@
 from dataclasses import dataclass
 from typing import Optional, Mapping, Any, List
 
 
 class QueryStats:
-    """Query stats"""
+  """Query stats"""
 
-    @property
-    def compute_ops(self) -> int:
-        """The amount of Transactional Compute Ops consumed by the query."""
-        return self._compute_ops
-
-    @property
-    def read_ops(self) -> int:
-        """The amount of Transactional Read Ops consumed by the query."""
-        return self._read_ops
-
-    @property
-    def write_ops(self) -> int:
-        """The amount of Transactional Write Ops consumed by the query."""
-        return self._write_ops
-
-    @property
-    def query_time_ms(self) -> int:
-        """The query run time in milliseconds."""
-        return self._query_time_ms
-
-    @property
-    def storage_bytes_read(self) -> int:
-        """The amount of data read from storage, in bytes."""
-        return self._storage_bytes_read
-
-    @property
-    def storage_bytes_write(self) -> int:
-        """The amount of data written to storage, in bytes."""
-        return self._storage_bytes_write
-
-    @property
-    def contention_retries(self) -> int:
-        """The number of times the transaction was retried due to write contention."""
-        return self._contention_retries
-
-    def __init__(self, stats: Mapping[str, Any]):
-        self._compute_ops = stats.get("compute_ops", 0)
-        self._read_ops = stats.get("read_ops", 0)
-        self._write_ops = stats.get("write_ops", 0)
-        self._query_time_ms = stats.get("query_time_ms", 0)
-        self._storage_bytes_read = stats.get("storage_bytes_read", 0)
-        self._storage_bytes_write = stats.get("storage_bytes_write", 0)
-        self._contention_retries = stats.get("contention_retries", 0)
-
-    def __repr__(self):
-        stats = {
-            "compute_ops": self._compute_ops,
-            "read_ops": self._read_ops,
-            "write_ops": self._write_ops,
-            "query_time_ms": self._query_time_ms,
-            "storage_bytes_read": self._storage_bytes_read,
-            "storage_bytes_write": self._storage_bytes_write,
-            "contention_retries": self._contention_retries,
-        }
-
-        return f"{self.__class__.__name__}(stats={repr(stats)})"
-
-    def __eq__(self, other):
-        return type(self) == type(other) \
-            and self.compute_ops == other.compute_ops \
-            and self.read_ops == other.read_ops \
-            and self.write_ops == other.write_ops \
-            and self.query_time_ms == other.query_time_ms \
-            and self.storage_bytes_read == other.storage_bytes_read \
-            and self.storage_bytes_write == other.storage_bytes_write \
-            and self.contention_retries == other.contention_retries
+  @property
+  def compute_ops(self) -> int:
+    """The amount of Transactional Compute Ops consumed by the query."""
+    return self._compute_ops
+
+  @property
+  def read_ops(self) -> int:
+    """The amount of Transactional Read Ops consumed by the query."""
+    return self._read_ops
+
+  @property
+  def write_ops(self) -> int:
+    """The amount of Transactional Write Ops consumed by the query."""
+    return self._write_ops
+
+  @property
+  def query_time_ms(self) -> int:
+    """The query run time in milliseconds."""
+    return self._query_time_ms
+
+  @property
+  def storage_bytes_read(self) -> int:
+    """The amount of data read from storage, in bytes."""
+    return self._storage_bytes_read
+
+  @property
+  def storage_bytes_write(self) -> int:
+    """The amount of data written to storage, in bytes."""
+    return self._storage_bytes_write
+
+  @property
+  def contention_retries(self) -> int:
+    """The number of times the transaction was retried due to write contention."""
+    return self._contention_retries
+
+  def __init__(self, stats: Mapping[str, Any]):
+    self._compute_ops = stats.get("compute_ops", 0)
+    self._read_ops = stats.get("read_ops", 0)
+    self._write_ops = stats.get("write_ops", 0)
+    self._query_time_ms = stats.get("query_time_ms", 0)
+    self._storage_bytes_read = stats.get("storage_bytes_read", 0)
+    self._storage_bytes_write = stats.get("storage_bytes_write", 0)
+    self._contention_retries = stats.get("contention_retries", 0)
+
+  def __repr__(self):
+    stats = {
+        "compute_ops": self._compute_ops,
+        "read_ops": self._read_ops,
+        "write_ops": self._write_ops,
+        "query_time_ms": self._query_time_ms,
+        "storage_bytes_read": self._storage_bytes_read,
+        "storage_bytes_write": self._storage_bytes_write,
+        "contention_retries": self._contention_retries,
+    }
+
+    return f"{self.__class__.__name__}(stats={repr(stats)})"
+
+  def __eq__(self, other):
+    return type(self) == type(other) \
+        and self.compute_ops == other.compute_ops \
+        and self.read_ops == other.read_ops \
+        and self.write_ops == other.write_ops \
+        and self.query_time_ms == other.query_time_ms \
+        and self.storage_bytes_read == other.storage_bytes_read \
+        and self.storage_bytes_write == other.storage_bytes_write \
+        and self.contention_retries == other.contention_retries
 
-    def __ne__(self, other):
-        return not self.__eq__(other)
+  def __ne__(self, other):
+    return not self.__eq__(other)
 
 
 class QueryInfo:
 
-    @property
-    def query_tags(self) -> Mapping[str, Any]:
-        """The tags associated with the query."""
-        return self._query_tags
-
-    @property
-    def summary(self) -> str:
-        """A comprehensive, human readable summary of any errors, warnings and/or logs returned from the query."""
-        return self._summary
-
-    @property
-    def stats(self) -> QueryStats:
-        """Query stats associated with the query."""
-        return self._stats
-
-    @property
-    def txn_ts(self) -> int:
-        return self._txn_ts
-
-    def __init__(
-        self,
-        query_tags: Optional[Mapping[str, str]] = None,
-        stats: Optional[QueryStats] = None,
-        summary: Optional[str] = None,
-        txn_ts: Optional[int] = None,
-    ):
-        self._query_tags = query_tags or {}
-        self._stats = stats or QueryStats({})
-        self._summary = summary or ""
-        self._txn_ts = txn_ts or 0
-
-    def __repr__(self):
-        return f"{self.__class__.__name__}(" \
-               f"query_tags={repr(self.query_tags)}," \
-               f"stats={repr(self.stats)}," \
-               f"summary={repr(self.summary)}," \
-               f"txn_ts={repr(self.txn_ts)})"
+  @property
+  def query_tags(self) -> Mapping[str, Any]:
+    """The tags associated with the query."""
+    return self._query_tags
+
+  @property
+  def summary(self) -> str:
+    """A comprehensive, human readable summary of any errors, warnings and/or logs returned from the query."""
+    return self._summary
+
+  @property
+  def stats(self) -> QueryStats:
+    """Query stats associated with the query."""
+    return self._stats
+
+  @property
+  def txn_ts(self) -> int:
+    """The last transaction timestamp of the query. A Unix epoch in microseconds."""
+    return self._txn_ts
+
+  @property
+  def schema_version(self) -> int:
+    """The schema version that was used for the query execution."""
+    return self._schema_version
+
+  def __init__(
+      self,
+      query_tags: Optional[Mapping[str, str]] = None,
+      stats: Optional[QueryStats] = None,
+      summary: Optional[str] = None,
+      txn_ts: Optional[int] = None,
+      schema_version: Optional[int] = None,
+  ):
+    self._query_tags = query_tags or {}
+    self._stats = stats or QueryStats({})
+    self._summary = summary or ""
+    self._txn_ts = txn_ts or 0
+    self._schema_version = schema_version or 0
+
+  def __repr__(self):
+    return f"{self.__class__.__name__}(" \
+           f"query_tags={repr(self.query_tags)}," \
+           f"stats={repr(self.stats)}," \
+           f"summary={repr(self.summary)}," \
+           f"txn_ts={repr(self.txn_ts)}," \
+           f"schema_version={repr(self.schema_version)})"
 
 
 class QuerySuccess(QueryInfo):
-    """The result of the query."""
+  """The result of the query."""
 
-    @property
-    def data(self) -> Any:
-        """The data returned by the query. This is the result of the FQL query."""
-        return self._data
-
-    @property
-    def static_type(self) -> Optional[str]:
-        """If typechecked, the query's inferred static result type, if the query was typechecked."""
-        return self._static_type
-
-    @property
-    def traceparent(self) -> Optional[str]:
-        """The traceparent for the query."""
-        return self._traceparent
-
-    def __init__(
-        self,
-        data: Any,
-        query_tags: Optional[Mapping[str, str]],
-        static_type: Optional[str],
-        stats: Optional[QueryStats],
-        summary: Optional[str],
-        traceparent: Optional[str],
-        txn_ts: Optional[int],
-    ):
-
-        super().__init__(query_tags=query_tags,
-                         stats=stats,
-                         summary=summary,
-                         txn_ts=txn_ts)
-
-        self._traceparent = traceparent
-        self._static_type = static_type
-        self._data = data
-
-    def __repr__(self):
-        return f"{self.__class__.__name__}(" \
-               f"query_tags={repr(self.query_tags)}," \
-               f"static_type={repr(self.static_type)}," \
-               f"stats={repr(self.stats)}," \
-               f"summary={repr(self.summary)}," \
-               f"traceparent={repr(self.traceparent)}," \
-               f"txn_ts={repr(self.txn_ts)}," \
-               f"data={repr(self.data)})"
+  @property
+  def data(self) -> Any:
+    """The data returned by the query. This is the result of the FQL query."""
+    return self._data
+
+  @property
+  def static_type(self) -> Optional[str]:
+    """If typechecked, the query's inferred static result type, if the query was typechecked."""
+    return self._static_type
+
+  @property
+  def traceparent(self) -> Optional[str]:
+    """The traceparent for the query."""
+    return self._traceparent
+
+  def __init__(
+      self,
+      data: Any,
+      query_tags: Optional[Mapping[str, str]],
+      static_type: Optional[str],
+      stats: Optional[QueryStats],
+      summary: Optional[str],
+      traceparent: Optional[str],
+      txn_ts: Optional[int],
+      schema_version: Optional[int],
+  ):
+
+    super().__init__(
+        query_tags=query_tags,
+        stats=stats,
+        summary=summary,
+        txn_ts=txn_ts,
+        schema_version=schema_version,
+    )
+
+    self._traceparent = traceparent
+    self._static_type = static_type
+    self._data = data
+
+  def __repr__(self):
+    return f"{self.__class__.__name__}(" \
+           f"query_tags={repr(self.query_tags)}," \
+           f"static_type={repr(self.static_type)}," \
+           f"stats={repr(self.stats)}," \
+           f"summary={repr(self.summary)}," \
+           f"traceparent={repr(self.traceparent)}," \
+           f"txn_ts={repr(self.txn_ts)}," \
+           f"schema_version={repr(self.schema_version)}," \
+           f"data={repr(self.data)})"
 
 
 @dataclass
 class ConstraintFailure:
-    message: str
-    name: Optional[str] = None
-    paths: Optional[List[Any]] = None
+  message: str
+  name: Optional[str] = None
+  paths: Optional[List[Any]] = None
 
 
 class QueryTags:
 
-    @staticmethod
-    def encode(tags: Mapping[str, str]) -> str:
-        return ",".join([f"{k}={v}" for k, v in tags.items()])
-
-    @staticmethod
-    def decode(tag_str: str) -> Mapping[str, str]:
-        res: dict[str, str] = {}
-        for pair in tag_str.split(","):
-            kv = pair.split("=")
-            res[kv[0]] = kv[1]
-        return res
+  @staticmethod
+  def encode(tags: Mapping[str, str]) -> str:
+    return ",".join([f"{k}={v}" for k, v in tags.items()])
+
+  @staticmethod
+  def decode(tag_str: str) -> Mapping[str, str]:
+    res: dict[str, str] = {}
+    for pair in tag_str.split(","):
+      kv = pair.split("=")
+      res[kv[0]] = kv[1]
+    return res
```

## fauna/errors/errors.py

```diff
@@ -1,178 +1,180 @@
 from typing import Optional, List, Any, Mapping
 
 from fauna.encoding import ConstraintFailure, QueryStats, QueryInfo
 
 
 class FaunaException(Exception):
-    """Base class Fauna Exceptions"""
-    pass
+  """Base class Fauna Exceptions"""
+  pass
 
 
 class ClientError(FaunaException):
-    """An error representing a failure internal to the client, itself.
+  """An error representing a failure internal to the client, itself.
     This indicates Fauna was never called - the client failed internally
     prior to sending the request."""
-    pass
+  pass
 
 
 class NetworkError(FaunaException):
-    """An error representing a failure due to the network.
+  """An error representing a failure due to the network.
     This indicates Fauna was never reached."""
-    pass
+  pass
 
 
 class ProtocolError(FaunaException):
-    """An error representing a HTTP failure - but one not directly emitted by Fauna."""
+  """An error representing a HTTP failure - but one not directly emitted by Fauna."""
 
-    @property
-    def status_code(self) -> int:
-        return self._status_code
-
-    @property
-    def message(self) -> str:
-        return self._message
-
-    def __init__(self, status_code: int, message: str):
-        self._status_code = status_code
-        self._message = message
+  @property
+  def status_code(self) -> int:
+    return self._status_code
+
+  @property
+  def message(self) -> str:
+    return self._message
+
+  def __init__(self, status_code: int, message: str):
+    self._status_code = status_code
+    self._message = message
 
-    def __str__(self):
-        return f"{self.status_code}: {self.message}"
+  def __str__(self):
+    return f"{self.status_code}: {self.message}"
 
 
 class FaunaError(FaunaException):
-    """Base class Fauna Errors"""
+  """Base class Fauna Errors"""
 
-    @property
-    def status_code(self) -> int:
-        return self._status_code
+  @property
+  def status_code(self) -> int:
+    return self._status_code
+
+  @property
+  def code(self) -> str:
+    return self._code
+
+  @property
+  def message(self) -> str:
+    return self._message
+
+  @property
+  def abort(self) -> Optional[Any]:
+    return self._abort
+
+  @property
+  def constraint_failures(self) -> Optional[List['ConstraintFailure']]:
+    return self._constraint_failures
+
+  def __init__(
+      self,
+      status_code: int,
+      code: str,
+      message: str,
+      abort: Optional[Any] = None,
+      constraint_failures: Optional[List['ConstraintFailure']] = None,
+  ):
+    self._status_code = status_code
+    self._code = code
+    self._message = message
+    self._abort = abort
+    self._constraint_failures = constraint_failures
 
-    @property
-    def code(self) -> str:
-        return self._code
+  def __str__(self):
+    return f"{self.status_code}: {self.code}\n{self.message}"
 
-    @property
-    def message(self) -> str:
-        return self._message
 
-    @property
-    def abort(self) -> Optional[Any]:
-        return self._abort
-
-    @property
-    def constraint_failures(self) -> Optional[List['ConstraintFailure']]:
-        return self._constraint_failures
+class ServiceError(FaunaError, QueryInfo):
+  """An error representing a query failure returned by Fauna."""
 
-    def __init__(
+  def __init__(
+      self,
+      status_code: int,
+      code: str,
+      message: str,
+      summary: Optional[str] = None,
+      abort: Optional[Any] = None,
+      constraint_failures: Optional[List['ConstraintFailure']] = None,
+      query_tags: Optional[Mapping[str, str]] = None,
+      stats: Optional[QueryStats] = None,
+      txn_ts: Optional[int] = None,
+      schema_version: Optional[int] = None,
+  ):
+    QueryInfo.__init__(
         self,
-        status_code: int,
-        code: str,
-        message: str,
-        abort: Optional[Any] = None,
-        constraint_failures: Optional[List['ConstraintFailure']] = None,
-    ):
-        self._status_code = status_code
-        self._code = code
-        self._message = message
-        self._abort = abort
-        self._constraint_failures = constraint_failures
-
-    def __str__(self):
-        return f"{self.status_code}: {self.code}\n{self.message}"
-
-
-class ServiceError(FaunaError, QueryInfo):
-    """An error representing a query failure returned by Fauna."""
+        query_tags=query_tags,
+        stats=stats,
+        summary=summary,
+        txn_ts=txn_ts,
+        schema_version=schema_version,
+    )
 
-    def __init__(
+    FaunaError.__init__(
         self,
-        status_code: int,
-        code: str,
-        message: str,
-        summary: Optional[str] = None,
-        abort: Optional[Any] = None,
-        constraint_failures: Optional[List['ConstraintFailure']] = None,
-        query_tags: Optional[Mapping[str, str]] = None,
-        stats: Optional[QueryStats] = None,
-        txn_ts: Optional[int] = None,
-    ):
-        QueryInfo.__init__(
-            self,
-            query_tags=query_tags,
-            stats=stats,
-            summary=summary,
-            txn_ts=txn_ts,
-        )
-
-        FaunaError.__init__(
-            self,
-            status_code=status_code,
-            code=code,
-            message=message,
-            abort=abort,
-            constraint_failures=constraint_failures,
-        )
-
-    def __str__(self):
-        constraint_str = "---"
-        if self._constraint_failures:
-            constraint_str = f"---\nconstraint failures: {self._constraint_failures}\n---"
+        status_code=status_code,
+        code=code,
+        message=message,
+        abort=abort,
+        constraint_failures=constraint_failures,
+    )
+
+  def __str__(self):
+    constraint_str = "---"
+    if self._constraint_failures:
+      constraint_str = f"---\nconstraint failures: {self._constraint_failures}\n---"
 
-        return f"{self._status_code}: {self.code}\n{self.message}\n{constraint_str}\n{self.summary or ''}"
+    return f"{self._status_code}: {self.code}\n{self.message}\n{constraint_str}\n{self.summary or ''}"
 
 
 class AbortError(ServiceError):
-    pass
+  pass
 
 
 class InvalidRequestError(ServiceError):
-    pass
+  pass
 
 
 class QueryCheckError(ServiceError):
-    """An error due to a "compile-time" check of the query failing."""
-    pass
+  """An error due to a "compile-time" check of the query failing."""
+  pass
 
 
 class QueryRuntimeError(ServiceError):
-    """An error response that is the result of the query failing during execution.
+  """An error response that is the result of the query failing during execution.
     QueryRuntimeError's occur when a bug in your query causes an invalid execution
     to be requested.
     The 'code' field will vary based on the specific error cause."""
-    pass
+  pass
 
 
 class AuthenticationError(ServiceError):
-    """AuthenticationError indicates invalid credentials were used."""
-    pass
+  """AuthenticationError indicates invalid credentials were used."""
+  pass
 
 
 class AuthorizationError(ServiceError):
-    """AuthorizationError indicates the credentials used do not have
+  """AuthorizationError indicates the credentials used do not have
     permission to perform the requested action."""
-    pass
+  pass
 
 
 class ThrottlingError(ServiceError):
-    """ThrottlingError indicates some capacity limit was exceeded
+  """ThrottlingError indicates some capacity limit was exceeded
     and thus the request could not be served."""
-    pass
+  pass
 
 
 class QueryTimeoutError(ServiceError):
-    """A failure due to the timeout being exceeded, but the timeout
+  """A failure due to the timeout being exceeded, but the timeout
     was set lower than the query's expected processing time.
     This response is distinguished from a ServiceTimeoutException
     in that a QueryTimeoutError shows Fauna behaving in an expected manner."""
-    pass
+  pass
 
 
 class ServiceInternalError(ServiceError):
-    """ServiceInternalError indicates Fauna failed unexpectedly."""
-    pass
+  """ServiceInternalError indicates Fauna failed unexpectedly."""
+  pass
 
 
 class ServiceTimeoutError(ServiceError):
-    """ServiceTimeoutError indicates Fauna was not available to service
+  """ServiceTimeoutError indicates Fauna was not available to service
     the request before the timeout was reached."""
-    pass
+  pass
```

## fauna/http/http_client.py

```diff
@@ -2,66 +2,66 @@
 
 from typing import Iterator, Mapping, Any
 from dataclasses import dataclass
 
 
 @dataclass(frozen=True)
 class ErrorResponse:
-    status_code: int
-    error_code: str
-    error_message: str
-    summary: str
+  status_code: int
+  error_code: str
+  error_message: str
+  summary: str
 
 
 class HTTPResponse(abc.ABC):
 
-    @abc.abstractmethod
-    def headers(self) -> Mapping[str, str]:
-        pass
-
-    @abc.abstractmethod
-    def status_code(self) -> int:
-        pass
-
-    @abc.abstractmethod
-    def json(self) -> Any:
-        pass
-
-    @abc.abstractmethod
-    def read(self) -> bytes:
-        pass
-
-    @abc.abstractmethod
-    def iter_bytes(self) -> Iterator[bytes]:
-        pass
-
-    @abc.abstractmethod
-    def close(self):
-        pass
+  @abc.abstractmethod
+  def headers(self) -> Mapping[str, str]:
+    pass
+
+  @abc.abstractmethod
+  def status_code(self) -> int:
+    pass
+
+  @abc.abstractmethod
+  def json(self) -> Any:
+    pass
+
+  @abc.abstractmethod
+  def read(self) -> bytes:
+    pass
+
+  @abc.abstractmethod
+  def iter_bytes(self) -> Iterator[bytes]:
+    pass
+
+  @abc.abstractmethod
+  def close(self):
+    pass
 
-    def __enter__(self):
-        return self
+  def __enter__(self):
+    return self
 
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.close()
+  def __exit__(self, exc_type, exc_val, exc_tb):
+    self.close()
 
 
 class HTTPClient(abc.ABC):
 
-    @abc.abstractmethod
-    def request(
-        self,
-        method: str,
-        url: str,
-        headers: Mapping[str, str],
-        data: Mapping[str, Any],
-    ) -> HTTPResponse:
-        pass
-
-    @abc.abstractmethod
-    def stream(
-        self,
-        url: str,
-        headers: Mapping[str, str],
-        data: Mapping[str, Any],
-    ) -> HTTPResponse:
-        pass
+  @abc.abstractmethod
+  def request(
+      self,
+      method: str,
+      url: str,
+      headers: Mapping[str, str],
+      data: Mapping[str, Any],
+  ) -> HTTPResponse:
+    pass
+
+  @abc.abstractmethod
+  def stream(
+      self,
+      url: str,
+      headers: Mapping[str, str],
+      data: Mapping[str, Any],
+  ) -> HTTPResponse:
+    pass
```

## fauna/http/httpx_client.py

```diff
@@ -6,82 +6,82 @@
 
 from fauna.errors import ClientError, NetworkError
 from fauna.http.http_client import HTTPResponse, HTTPClient
 
 
 class HTTPXResponse(HTTPResponse):
 
-    def __init__(self, response: httpx.Response):
-        self._r = response
+  def __init__(self, response: httpx.Response):
+    self._r = response
 
-    def headers(self) -> Mapping[str, str]:
-        h = {}
-        for (k, v) in self._r.headers.items():
-            h[k] = v
-        return h
-
-    def json(self) -> Any:
-        try:
-            decoded = self._r.read().decode("utf-8")
-            return json.loads(decoded)
-        except (JSONDecodeError, UnicodeDecodeError) as e:
-            raise ClientError(
-                f"Unable to decode response from endpoint {self._r.request.url}. Check that your endpoint is valid."
-            ) from e
-
-    def status_code(self) -> int:
-        return self._r.status_code
-
-    def read(self) -> bytes:
-        return self._r.read()
-
-    def iter_bytes(self, size: Optional[int] = None) -> Iterator[bytes]:
-        return self._r.iter_bytes(size)
-
-    def close(self) -> None:
-        try:
-            self._r.close()
-        except Exception as e:
-            raise ClientError("Error closing response") from e
+  def headers(self) -> Mapping[str, str]:
+    h = {}
+    for (k, v) in self._r.headers.items():
+      h[k] = v
+    return h
+
+  def json(self) -> Any:
+    try:
+      decoded = self._r.read().decode("utf-8")
+      return json.loads(decoded)
+    except (JSONDecodeError, UnicodeDecodeError) as e:
+      raise ClientError(
+          f"Unable to decode response from endpoint {self._r.request.url}. Check that your endpoint is valid."
+      ) from e
+
+  def status_code(self) -> int:
+    return self._r.status_code
+
+  def read(self) -> bytes:
+    return self._r.read()
+
+  def iter_bytes(self, size: Optional[int] = None) -> Iterator[bytes]:
+    return self._r.iter_bytes(size)
+
+  def close(self) -> None:
+    try:
+      self._r.close()
+    except Exception as e:
+      raise ClientError("Error closing response") from e
 
 
 class HTTPXClient(HTTPClient):
 
-    def __init__(self, client: httpx.Client):
-        super(HTTPXClient, self).__init__()
-        self._c = client
-
-    def request(
-        self,
-        method: str,
-        url: str,
-        headers: Mapping[str, str],
-        data: Mapping[str, Any],
-    ) -> HTTPResponse:
-
-        try:
-            request = self._c.build_request(
-                method,
-                url,
-                json=data,
-                headers=headers,
-            )
-        except httpx.InvalidURL as e:
-            raise ClientError("Invalid URL Format") from e
-
-        try:
-            response = self._c.send(
-                request,
-                stream=False,
-            )
-        except (httpx.HTTPError, httpx.InvalidURL) as e:
-            raise NetworkError("Exception re-raised from HTTP request") from e
-
-        return HTTPXResponse(response)
-
-    def stream(
-        self,
-        url: str,
-        headers: Mapping[str, str],
-        data: Mapping[str, Any],
-    ) -> Iterator[HTTPResponse]:
-        raise NotImplementedError()
+  def __init__(self, client: httpx.Client):
+    super(HTTPXClient, self).__init__()
+    self._c = client
+
+  def request(
+      self,
+      method: str,
+      url: str,
+      headers: Mapping[str, str],
+      data: Mapping[str, Any],
+  ) -> HTTPResponse:
+
+    try:
+      request = self._c.build_request(
+          method,
+          url,
+          json=data,
+          headers=headers,
+      )
+    except httpx.InvalidURL as e:
+      raise ClientError("Invalid URL Format") from e
+
+    try:
+      response = self._c.send(
+          request,
+          stream=False,
+      )
+    except (httpx.HTTPError, httpx.InvalidURL) as e:
+      raise NetworkError("Exception re-raised from HTTP request") from e
+
+    return HTTPXResponse(response)
+
+  def stream(
+      self,
+      url: str,
+      headers: Mapping[str, str],
+      data: Mapping[str, Any],
+  ) -> Iterator[HTTPResponse]:
+    raise NotImplementedError()
```

## fauna/query/models.py

```diff
@@ -1,342 +1,334 @@
 from collections.abc import Mapping
 from datetime import datetime
 from typing import Union, Iterator, Any, Optional, List
 
 
 class Page:
-    """A class representing a Set in Fauna."""
+  """A class representing a Set in Fauna."""
 
-    def __init__(self,
-                 data: Optional[List[Any]] = None,
-                 after: Optional[str] = None):
-        self.data = data
-        self.after = after
+  def __init__(self,
+               data: Optional[List[Any]] = None,
+               after: Optional[str] = None):
+    self.data = data
+    self.after = after
 
-    def __repr__(self):
-        args = []
-        if self.data is not None:
-            args.append(f"data={repr(self.data)}")
+  def __repr__(self):
+    args = []
+    if self.data is not None:
+      args.append(f"data={repr(self.data)}")
 
-        if self.after is not None:
-            args.append(f"after={repr(self.after)}")
+    if self.after is not None:
+      args.append(f"after={repr(self.after)}")
 
-        return f"{self.__class__.__name__}({','.join(args)})"
+    return f"{self.__class__.__name__}({','.join(args)})"
 
-    def __iter__(self) -> Iterator[Any]:
-        return iter(self.data or [])
+  def __iter__(self) -> Iterator[Any]:
+    return iter(self.data or [])
 
-    def __eq__(self, other):
-        return isinstance(
-            other,
-            Page) and self.data == other.data and self.after == other.after
+  def __eq__(self, other):
+    return isinstance(
+        other, Page) and self.data == other.data and self.after == other.after
 
-    def __hash__(self):
-        hash((type(self), self.data, self.after))
+  def __hash__(self):
+    hash((type(self), self.data, self.after))
 
-    def __ne__(self, other):
-        return not self.__eq__(other)
+  def __ne__(self, other):
+    return not self.__eq__(other)
 
 
 class Module:
-    """A class representing a Module in Fauna. Examples of modules include Collection, Math, and a user-defined
+  """A class representing a Module in Fauna. Examples of modules include Collection, Math, and a user-defined
     collection, among others.
 
     Usage:
 
        dogs = Module("Dogs")
        query = fql("${col}.all", col=dogs)
     """
 
-    def __init__(self, name: str):
-        self.name = name
+  def __init__(self, name: str):
+    self.name = name
 
-    def __repr__(self):
-        return f"{self.__class__.__name__}(name={repr(self.name)})"
+  def __repr__(self):
+    return f"{self.__class__.__name__}(name={repr(self.name)})"
 
-    def __eq__(self, other):
-        return isinstance(other, Module) and str(self) == str(other)
+  def __eq__(self, other):
+    return isinstance(other, Module) and str(self) == str(other)
 
-    def __hash__(self):
-        hash(self.name)
+  def __hash__(self):
+    hash(self.name)
 
 
 class BaseReference:
-    _collection: Module
+  _collection: Module
 
-    @property
-    def coll(self) -> Module:
-        return self._collection
-
-    def __init__(self, coll: Union[str, Module]):
-        if isinstance(coll, Module):
-            self._collection = coll
-        elif isinstance(coll, str):
-            self._collection = Module(coll)
-        else:
-            raise TypeError(
-                f"'coll' should be of type Module or str, but was {type(coll)}"
-            )
+  @property
+  def coll(self) -> Module:
+    return self._collection
+
+  def __init__(self, coll: Union[str, Module]):
+    if isinstance(coll, Module):
+      self._collection = coll
+    elif isinstance(coll, str):
+      self._collection = Module(coll)
+    else:
+      raise TypeError(
+          f"'coll' should be of type Module or str, but was {type(coll)}")
 
-    def __repr__(self):
-        return f"{self.__class__.__name__}(coll={repr(self._collection)})"
+  def __repr__(self):
+    return f"{self.__class__.__name__}(coll={repr(self._collection)})"
 
-    def __eq__(self, other):
-        return isinstance(other, type(self)) and str(self) == str(other)
+  def __eq__(self, other):
+    return isinstance(other, type(self)) and str(self) == str(other)
 
 
 class DocumentReference(BaseReference):
-    """A class representing a reference to a :class:`Document` stored in Fauna.
+  """A class representing a reference to a :class:`Document` stored in Fauna.
     """
 
-    @property
-    def id(self) -> str:
-        """The ID for the :class:`Document`. Valid IDs are 64-bit integers, stored as strings.
+  @property
+  def id(self) -> str:
+    """The ID for the :class:`Document`. Valid IDs are 64-bit integers, stored as strings.
 
         :rtype: str
         """
-        return self._id
+    return self._id
 
-    def __init__(self, coll: Union[str, Module], id: str):
-        super().__init__(coll)
+  def __init__(self, coll: Union[str, Module], id: str):
+    super().__init__(coll)
 
-        if not isinstance(id, str):
-            raise TypeError(f"'id' should be of type str, but was {type(id)}")
-        self._id = id
-
-    def __hash__(self):
-        hash((type(self), self._collection, self._id))
-
-    def __repr__(self):
-        return f"{self.__class__.__name__}(id={repr(self._id)},coll={repr(self._collection)})"
-
-    @staticmethod
-    def from_string(ref: str):
-        rs = ref.split(":")
-        if len(rs) != 2:
-            raise ValueError("Expects string of format <CollectionName>:<ID>")
-        return DocumentReference(rs[0], rs[1])
+    if not isinstance(id, str):
+      raise TypeError(f"'id' should be of type str, but was {type(id)}")
+    self._id = id
+
+  def __hash__(self):
+    hash((type(self), self._collection, self._id))
+
+  def __repr__(self):
+    return f"{self.__class__.__name__}(id={repr(self._id)},coll={repr(self._collection)})"
+
+  @staticmethod
+  def from_string(ref: str):
+    rs = ref.split(":")
+    if len(rs) != 2:
+      raise ValueError("Expects string of format <CollectionName>:<ID>")
+    return DocumentReference(rs[0], rs[1])
 
 
 class NamedDocumentReference(BaseReference):
-    """A class representing a reference to a :class:`NamedDocument` stored in Fauna.
+  """A class representing a reference to a :class:`NamedDocument` stored in Fauna.
     """
 
-    @property
-    def name(self) -> str:
-        """The name of the :class:`NamedDocument`.
+  @property
+  def name(self) -> str:
+    """The name of the :class:`NamedDocument`.
 
         :rtype: str
         """
-        return self._name
+    return self._name
 
-    def __init__(self, coll: Union[str, Module], name: str):
-        super().__init__(coll)
+  def __init__(self, coll: Union[str, Module], name: str):
+    super().__init__(coll)
 
-        if not isinstance(name, str):
-            raise TypeError(
-                f"'name' should be of type str, but was {type(name)}")
+    if not isinstance(name, str):
+      raise TypeError(f"'name' should be of type str, but was {type(name)}")
 
-        self._name = name
+    self._name = name
 
-    def __hash__(self):
-        hash((type(self), self._collection, self._name))
+  def __hash__(self):
+    hash((type(self), self._collection, self._name))
 
-    def __repr__(self):
-        return f"{self.__class__.__name__}(name={repr(self._name)},coll={repr(self._collection)})"
+  def __repr__(self):
+    return f"{self.__class__.__name__}(name={repr(self._name)},coll={repr(self._collection)})"
 
 
 class NullDocument:
 
-    @property
-    def cause(self) -> Optional[str]:
-        return self._cause
-
-    @property
-    def ref(self) -> Union[DocumentReference, NamedDocumentReference]:
-        return self._ref
-
-    def __init__(
-        self,
-        ref: Union[DocumentReference, NamedDocumentReference],
-        cause: Optional[str] = None,
-    ):
-        self._cause = cause
-        self._ref = ref
-
-    def __repr__(self):
-        return f"{self.__class__.__name__}(ref={repr(self.ref)},cause={repr(self._cause)})"
-
-    def __eq__(self, other):
-        if not isinstance(other, type(self)):
-            return False
+  @property
+  def cause(self) -> Optional[str]:
+    return self._cause
+
+  @property
+  def ref(self) -> Union[DocumentReference, NamedDocumentReference]:
+    return self._ref
+
+  def __init__(
+      self,
+      ref: Union[DocumentReference, NamedDocumentReference],
+      cause: Optional[str] = None,
+  ):
+    self._cause = cause
+    self._ref = ref
+
+  def __repr__(self):
+    return f"{self.__class__.__name__}(ref={repr(self.ref)},cause={repr(self._cause)})"
+
+  def __eq__(self, other):
+    if not isinstance(other, type(self)):
+      return False
 
-        return self.ref == other.ref and self.cause == other.cause
+    return self.ref == other.ref and self.cause == other.cause
 
-    def __ne__(self, other):
-        return not self == other
+  def __ne__(self, other):
+    return not self == other
 
 
 class BaseDocument(Mapping):
-    """A base document class implementing an immutable mapping.
+  """A base document class implementing an immutable mapping.
     """
 
-    def __init__(self, *args, **kwargs):
-        self._store = dict(*args, **kwargs)
+  def __init__(self, *args, **kwargs):
+    self._store = dict(*args, **kwargs)
 
-    def __getitem__(self, __k: str) -> Any:
-        return self._store[__k]
+  def __getitem__(self, __k: str) -> Any:
+    return self._store[__k]
 
-    def __len__(self) -> int:
-        return len(self._store)
+  def __len__(self) -> int:
+    return len(self._store)
 
-    def __iter__(self) -> Iterator[Any]:
-        return iter(self._store)
+  def __iter__(self) -> Iterator[Any]:
+    return iter(self._store)
 
-    def __eq__(self, other):
-        if not isinstance(other, type(self)):
-            return False
+  def __eq__(self, other):
+    if not isinstance(other, type(self)):
+      return False
 
-        if len(self) != len(other):
-            return False
+    if len(self) != len(other):
+      return False
 
-        for k, v in self.items():
-            if k not in other:
-                return False
-            if self[k] != other[k]:
-                return False
+    for k, v in self.items():
+      if k not in other:
+        return False
+      if self[k] != other[k]:
+        return False
 
-        return True
+    return True
 
-    def __ne__(self, other):
-        return not self.__eq__(other)
+  def __ne__(self, other):
+    return not self.__eq__(other)
 
 
 class Document(BaseDocument):
-    """A class representing a user document stored in Fauna.
+  """A class representing a user document stored in Fauna.
 
     User data should be stored directly on the map, while id, ts, and coll should only be stored on the related
     properties. When working with a :class:`Document` in code, it should be considered immutable.
     """
 
-    @property
-    def id(self) -> str:
-        return self._id
-
-    @property
-    def ts(self) -> datetime:
-        return self._ts
-
-    @property
-    def coll(self) -> Module:
-        return self._coll
-
-    def __init__(self,
-                 id: str,
-                 ts: datetime,
-                 coll: Union[str, Module],
-                 data: Optional[Mapping] = None):
-        if not isinstance(id, str):
-            raise TypeError(f"'id' should be of type str, but was {type(id)}")
-
-        if not isinstance(ts, datetime):
-            raise TypeError(
-                f"'ts' should be of type datetime, but was {type(ts)}")
-
-        if not (isinstance(coll, str) or isinstance(coll, Module)):
-            raise TypeError(
-                f"'coll' should be of type Module or str, but was {type(coll)}"
-            )
-
-        if isinstance(coll, str):
-            coll = Module(coll)
-
-        self._id = id
-        self._ts = ts
-        self._coll = coll
-
-        super().__init__(data or {})
-
-    def __eq__(self, other):
-        return type(self) == type(other) \
-            and self.id == other.id \
-            and self.coll == other.coll \
-            and self.ts == other.ts \
-            and super().__eq__(other)
-
-    def __ne__(self, other):
-        return not self.__eq__(other)
-
-    def __repr__(self):
-        kvs = ",".join([f"{repr(k)}:{repr(v)}" for k, v in self.items()])
-
-        return f"{self.__class__.__name__}(" \
-               f"id={repr(self.id)}," \
-               f"coll={repr(self.coll)}," \
-               f"ts={repr(self.ts)}," \
-               f"data={{{kvs}}})"
+  @property
+  def id(self) -> str:
+    return self._id
+
+  @property
+  def ts(self) -> datetime:
+    return self._ts
+
+  @property
+  def coll(self) -> Module:
+    return self._coll
+
+  def __init__(self,
+               id: str,
+               ts: datetime,
+               coll: Union[str, Module],
+               data: Optional[Mapping] = None):
+    if not isinstance(id, str):
+      raise TypeError(f"'id' should be of type str, but was {type(id)}")
+
+    if not isinstance(ts, datetime):
+      raise TypeError(f"'ts' should be of type datetime, but was {type(ts)}")
+
+    if not (isinstance(coll, str) or isinstance(coll, Module)):
+      raise TypeError(
+          f"'coll' should be of type Module or str, but was {type(coll)}")
+
+    if isinstance(coll, str):
+      coll = Module(coll)
+
+    self._id = id
+    self._ts = ts
+    self._coll = coll
+
+    super().__init__(data or {})
+
+  def __eq__(self, other):
+    return type(self) == type(other) \
+        and self.id == other.id \
+        and self.coll == other.coll \
+        and self.ts == other.ts \
+        and super().__eq__(other)
+
+  def __ne__(self, other):
+    return not self.__eq__(other)
+
+  def __repr__(self):
+    kvs = ",".join([f"{repr(k)}:{repr(v)}" for k, v in self.items()])
+
+    return f"{self.__class__.__name__}(" \
+           f"id={repr(self.id)}," \
+           f"coll={repr(self.coll)}," \
+           f"ts={repr(self.ts)}," \
+           f"data={{{kvs}}})"
 
 
 class NamedDocument(BaseDocument):
-    """A class representing a named document stored in Fauna. Examples of named documents include Collection
+  """A class representing a named document stored in Fauna. Examples of named documents include Collection
     definitions, Index definitions, and Roles, among others.
 
     When working with a :class:`NamedDocument` in code, it should be considered immutable.
     """
 
-    @property
-    def name(self) -> str:
-        return self._name
-
-    @property
-    def ts(self) -> datetime:
-        return self._ts
-
-    @property
-    def coll(self) -> Module:
-        return self._coll
-
-    def __init__(self,
-                 name: str,
-                 ts: datetime,
-                 coll: Union[Module, str],
-                 data: Optional[Mapping] = None):
-        if not isinstance(name, str):
-            raise TypeError(
-                f"'name' should be of type str, but was {type(name)}")
-
-        if not isinstance(ts, datetime):
-            raise TypeError(
-                f"'ts' should be of type datetime, but was {type(ts)}")
-
-        if not (isinstance(coll, str) or isinstance(coll, Module)):
-            raise TypeError(
-                f"'coll' should be of type Module or str, but was {type(coll)}"
-            )
-
-        if isinstance(coll, str):
-            coll = Module(coll)
-
-        self._name = name
-        self._ts = ts
-        self._coll = coll
-
-        super().__init__(data or {})
-
-    def __eq__(self, other):
-        return type(self) == type(other) \
-            and self.name == other.name \
-            and self.coll == other.coll \
-            and self.ts == other.ts \
-            and super().__eq__(other)
-
-    def __ne__(self, other):
-        return not self.__eq__(other)
-
-    def __repr__(self):
-        kvs = ",".join([f"{repr(k)}:{repr(v)}" for k, v in self.items()])
-
-        return f"{self.__class__.__name__}(" \
-               f"name={repr(self.name)}," \
-               f"coll={repr(self.coll)}," \
-               f"ts={repr(self.ts)}," \
-               f"data={{{kvs}}})"
+  @property
+  def name(self) -> str:
+    return self._name
+
+  @property
+  def ts(self) -> datetime:
+    return self._ts
+
+  @property
+  def coll(self) -> Module:
+    return self._coll
+
+  def __init__(self,
+               name: str,
+               ts: datetime,
+               coll: Union[Module, str],
+               data: Optional[Mapping] = None):
+    if not isinstance(name, str):
+      raise TypeError(f"'name' should be of type str, but was {type(name)}")
+
+    if not isinstance(ts, datetime):
+      raise TypeError(f"'ts' should be of type datetime, but was {type(ts)}")
+
+    if not (isinstance(coll, str) or isinstance(coll, Module)):
+      raise TypeError(
+          f"'coll' should be of type Module or str, but was {type(coll)}")
+
+    if isinstance(coll, str):
+      coll = Module(coll)
+
+    self._name = name
+    self._ts = ts
+    self._coll = coll
+
+    super().__init__(data or {})
+
+  def __eq__(self, other):
+    return type(self) == type(other) \
+        and self.name == other.name \
+        and self.coll == other.coll \
+        and self.ts == other.ts \
+        and super().__eq__(other)
+
+  def __ne__(self, other):
+    return not self.__eq__(other)
+
+  def __repr__(self):
+    kvs = ",".join([f"{repr(k)}:{repr(v)}" for k, v in self.items()])
+
+    return f"{self.__class__.__name__}(" \
+           f"name={repr(self.name)}," \
+           f"coll={repr(self.coll)}," \
+           f"ts={repr(self.ts)}," \
+           f"data={{{kvs}}})"
```

## fauna/query/query_builder.py

```diff
@@ -1,86 +1,86 @@
 import abc
 from typing import Any, Optional, List
 
 from .template import FaunaTemplate
 
 
 class Fragment(abc.ABC):
-    """An abstract class representing a Fragment of a query.
+  """An abstract class representing a Fragment of a query.
     """
 
-    @abc.abstractmethod
-    def get(self) -> Any:
-        """An abstract method for returning a stored value.
+  @abc.abstractmethod
+  def get(self) -> Any:
+    """An abstract method for returning a stored value.
         """
-        pass
+    pass
 
 
 class ValueFragment(Fragment):
-    """A concrete :class:`Fragment` representing a part of a query that can represent a template variable.
+  """A concrete :class:`Fragment` representing a part of a query that can represent a template variable.
     For example, if a template contains a variable ``${foo}``, and an object ``{ "prop": 1 }`` is provided for foo,
     then ``{ "prop": 1 }`` should be wrapped as a :class:`ValueFragment`.
 
     :param Any val: The value to be used as a fragment.
     """
 
-    def __init__(self, val: Any):
-        self._val = val
+  def __init__(self, val: Any):
+    self._val = val
 
-    def get(self) -> Any:
-        """Gets the stored value.
+  def get(self) -> Any:
+    """Gets the stored value.
 
         :returns: The stored value.
         """
-        return self._val
+    return self._val
 
 
 class LiteralFragment(Fragment):
-    """A concrete :class:`Fragment` representing a query literal For example, in the template ```let x = ${foo}```,
+  """A concrete :class:`Fragment` representing a query literal For example, in the template ```let x = ${foo}```,
     the portion ```let x = ``` is a query literal and should be wrapped as a :class:`LiteralFragment`.
 
     :param str val: The query literal to be used as a fragment.
     """
 
-    def __init__(self, val: str):
-        self._val = val
+  def __init__(self, val: str):
+    self._val = val
 
-    def get(self) -> str:
-        """Returns the stored value.
+  def get(self) -> str:
+    """Returns the stored value.
 
         :returns: The stored value.
         """
-        return self._val
+    return self._val
 
 
 class Query:
-    """A class for representing a query.
+  """A class for representing a query.
 
        e.g. { "fql": [...] }
     """
-    _fragments: List[Fragment]
+  _fragments: List[Fragment]
 
-    def __init__(self, fragments: Optional[List[Fragment]] = None):
-        self._fragments = fragments or []
+  def __init__(self, fragments: Optional[List[Fragment]] = None):
+    self._fragments = fragments or []
 
-    @property
-    def fragments(self) -> List[Fragment]:
-        """The list of stored Fragments"""
-        return self._fragments
-
-    def __str__(self) -> str:
-        res = ""
-        for f in self._fragments:
-            res += str(f.get())
+  @property
+  def fragments(self) -> List[Fragment]:
+    """The list of stored Fragments"""
+    return self._fragments
+
+  def __str__(self) -> str:
+    res = ""
+    for f in self._fragments:
+      res += str(f.get())
 
-        return res
+    return res
 
 
 def fql(query: str, **kwargs: Any) -> Query:
-    """Creates a Query - capable of performing query composition and simple querying. It can accept a
+  """Creates a Query - capable of performing query composition and simple querying. It can accept a
     simple string query, or can perform composition using ``${}`` sigil string template with ``**kwargs`` as
     substitutions.
 
     The ``**kwargs`` can be Fauna data types - such as strings, document references, or modules - and embedded
     Query - allowing you to compose arbitrarily complex queries.
 
     When providing ``**kwargs``, following types are accepted:
@@ -108,22 +108,21 @@
         def get_vet_phone(id):
             return fql('${dog} { .vet_phone_number }', dog=get_dog(id))
 
         get_vet_phone('d123')
 
     """
 
-    fragments: List[Any] = []
-    template = FaunaTemplate(query)
-    for text, field_name in template.iter():
-        if text is not None and len(text) > 0:
-            fragments.append(LiteralFragment(text))
-
-        if field_name is not None:
-            if field_name not in kwargs:
-                raise ValueError(
-                    f"template variable `{field_name}` not found in provided kwargs"
-                )
-
-            # TODO: Reject if it's already a fragment, or accept *Fragment? Decide on API here
-            fragments.append(ValueFragment(kwargs[field_name]))
-    return Query(fragments)
+  fragments: List[Any] = []
+  template = FaunaTemplate(query)
+  for text, field_name in template.iter():
+    if text is not None and len(text) > 0:
+      fragments.append(LiteralFragment(text))
+
+    if field_name is not None:
+      if field_name not in kwargs:
+        raise ValueError(
+            f"template variable `{field_name}` not found in provided kwargs")
+
+      # TODO: Reject if it's already a fragment, or accept *Fragment? Decide on API here
+      fragments.append(ValueFragment(kwargs[field_name]))
+  return Query(fragments)
```

## fauna/query/template.py

```diff
@@ -1,79 +1,79 @@
 from typing import Optional, Tuple, Iterator, Match
 import re as _re
 
 
 class FaunaTemplate:
-    """A template class that supports variables marked with a ${}-sigil. Its primary purpose
+  """A template class that supports variables marked with a ${}-sigil. Its primary purpose
     is to expose an iterator for the template parts that support composition of FQL queries.
 
     Implementation adapted from https://github.com/python/cpython/blob/main/Lib/string.py
 
     :param template: A string template e.g. "${my_var} { name }"
     :type template: str
     """
 
-    _delimiter = '$'
-    _idpattern = r'[_a-zA-Z][_a-zA-Z0-9]*'
-    _flags = _re.VERBOSE
-
-    def __init__(self, template: str):
-        """The initializer"""
-        delim = _re.escape(self._delimiter)
-        pattern = fr"""
+  _delimiter = '$'
+  _idpattern = r'[_a-zA-Z][_a-zA-Z0-9]*'
+  _flags = _re.VERBOSE
+
+  def __init__(self, template: str):
+    """The initializer"""
+    delim = _re.escape(self._delimiter)
+    pattern = fr"""
         {delim}(?:
           (?P<escaped>{delim})  |   # Escape sequence of two delimiters
           {{(?P<braced>{self._idpattern})}} |   # delimiter and a braced identifier
           (?P<invalid>)             # Other ill-formed delimiter exprs
         ) 
         """
-        self._pattern = _re.compile(pattern, self._flags)
-        self._template = template
+    self._pattern = _re.compile(pattern, self._flags)
+    self._template = template
 
-    def iter(self) -> Iterator[Tuple[Optional[str], Optional[str]]]:
-        """A method that returns an iterator over tuples representing template parts. The
+  def iter(self) -> Iterator[Tuple[Optional[str], Optional[str]]]:
+    """A method that returns an iterator over tuples representing template parts. The
         first value of the tuple, if not None, is a template literal. The second value of
         the tuple, if not None, is a template variable. If both are not None, then the
         template literal comes *before* the variable.
 
         :raises ValueError: If there is an invalid template placeholder
 
         :return: An iterator of template parts
         :rtype: collections.Iterable[Tuple[Optional[str], Optional[str]]]
         """
-        match_objects = self._pattern.finditer(self._template)
-        cur_pos = 0
-        for mo in match_objects:
-            if mo.group("invalid") is not None:
-                self._handle_invalid(mo)
-
-            span_start_pos = mo.span()[0]
-            span_end_pos = mo.span()[1]
-            escaped_part = mo.group("escaped") or ""
-            variable_part = mo.group("braced")
-            literal_part: Optional[str] = None
-
-            if cur_pos != span_start_pos:
-                literal_part = \
-                    self._template[cur_pos:span_start_pos] \
-                        + escaped_part
-
-            cur_pos = span_end_pos
-
-            yield literal_part, variable_part
-
-        if cur_pos != len(self._template):
-            yield self._template[cur_pos:], None
-
-    def _handle_invalid(self, mo: Match) -> None:
-        i = mo.start("invalid")
-        lines = self._template[:i].splitlines(keepends=True)
-
-        if not lines:
-            colno = 1
-            lineno = 1
-        else:
-            colno = i - len(''.join(lines[:-1]))
-            lineno = len(lines)
+    match_objects = self._pattern.finditer(self._template)
+    cur_pos = 0
+    for mo in match_objects:
+      if mo.group("invalid") is not None:
+        self._handle_invalid(mo)
+
+      span_start_pos = mo.span()[0]
+      span_end_pos = mo.span()[1]
+      escaped_part = mo.group("escaped") or ""
+      variable_part = mo.group("braced")
+      literal_part: Optional[str] = None
+
+      if cur_pos != span_start_pos:
+        literal_part = \
+            self._template[cur_pos:span_start_pos] \
+                + escaped_part
+
+      cur_pos = span_end_pos
+
+      yield literal_part, variable_part
+
+    if cur_pos != len(self._template):
+      yield self._template[cur_pos:], None
+
+  def _handle_invalid(self, mo: Match) -> None:
+    i = mo.start("invalid")
+    lines = self._template[:i].splitlines(keepends=True)
+
+    if not lines:
+      colno = 1
+      lineno = 1
+    else:
+      colno = i - len(''.join(lines[:-1]))
+      lineno = len(lines)
 
-        raise ValueError(
-            f"Invalid placeholder in template: line {lineno}, col {colno}")
+    raise ValueError(
+        f"Invalid placeholder in template: line {lineno}, col {colno}")
```

## Comparing `fauna-0.7.1.dist-info/LICENSE` & `fauna-0.8.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `fauna-0.7.1.dist-info/METADATA` & `fauna-0.8.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: fauna
-Version: 0.7.1
+Version: 0.8.0
 Summary: Fauna Python driver for FQL 10+
 Home-page: https://github.com/fauna/fauna-python
 Author: Fauna, Inc
 Author-email: priority@fauna.com
 License: MPL 2.0
 Keywords: faunadb fauna
 Platform: UNKNOWN
@@ -40,27 +40,27 @@
 
 .. warning::
     This driver is in beta release and not recommended for production use.
     It operates with the Fauna database service via an API which is also in
     beta release and is not recommended for production use. This driver is
     not compatible with v4 or earlier versions of Fauna. Please feel free to
     contact product@fauna.com to learn about our special Early Access program
-    for FQL X.
+    for FQL v10.
 
 
 
 .. image:: https://img.shields.io/pypi/v/fauna.svg?maxAge=21600
   :target: https://pypi.python.org/pypi/fauna
 .. image:: https://img.shields.io/badge/license-MPL_2.0-blue.svg?maxAge=2592000
   :target: https://raw.githubusercontent.com/fauna/fauna-python/main/LICENSE
 
 See the `Fauna Documentation <https://fqlx-beta--fauna-docs.netlify.app/fqlx/beta/>`_ 
 for additional information how to configure and query your databases.
 
-This driver can only be used with FQL X, and is not compatible with earlier versions
+This driver can only be used with FQL v10, and is not compatible with earlier versions
 of FQL. To query your databases with earlier API versions, see
 the `faunadb <https://pypi.org/project/faunadb/>`_ package.
 
 
 Installation
 ------------
```

## Comparing `fauna-0.7.1.dist-info/RECORD` & `fauna-0.8.0.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-fauna/__init__.py,sha256=BbY7Wxwvy_OSXtoL51unfTZwxebPMLi0hHbyq6EQQjY,301
+fauna/__init__.py,sha256=qDu2IRg5wHo7IjiPqDoX_8NPokTgb4xIPII1QvtSfYE,301
 fauna/client/__init__.py,sha256=SH5k-XCHlGKbsSwvRPUzlyXpsN-Bk_uHNNj78D5zpis,102
-fauna/client/client.py,sha256=ErPS4oU1Gx7AZ4H89aQQDs6DCLCgtLiNqHk7Cc3O3sk,22085
-fauna/client/endpoints.py,sha256=nXe1EX-OaVuWc8GRreLcyMDUvfvsJWkec9JlyMAGGzY,90
-fauna/client/headers.py,sha256=qFIHtEfRnSvhXwxq5dRNrw3l3vqp41ECdLpKGtUdd5E,3201
-fauna/client/utils.py,sha256=N6zaexuSCdsCyyLnsXI7naqp3Qxwdn_yzwCtEIEkwFA,2213
+fauna/client/client.py,sha256=9b9w0Zeu0Or86W4civKB2-W07FgkmR2CoBevb4s86ww,22613
+fauna/client/endpoints.py,sha256=nYEaZ7fJ4RPsXcLQToOO1BMWRWdgJFGr1mB4-BOa2-w,86
+fauna/client/headers.py,sha256=ueCezo2KJhaiNTOgA8qrFQVNkPg38re5jlofPQoXoL4,2907
+fauna/client/utils.py,sha256=TEwlZDMOl1XqxQbOCZWsgr-VqwaBQVIYPBGme7pBPzk,2063
 fauna/encoding/__init__.py,sha256=_IWx06Wiqa2jrpIEjbGAPcCFyFj0y39KuGhXc3YMPyg,161
-fauna/encoding/decoder.py,sha256=cxx845g5uDQdFPG9j1Wgr3T8AOTbyRFlJbPSKxlmwsw,6450
-fauna/encoding/encoder.py,sha256=7tlXTkxr9BusVtkicQWoL384b8cZZiigu8HeT5exTh4,8122
-fauna/encoding/wire_protocol.py,sha256=gEvtRjsOZfC7fm1xDlEXNP8h_MtJgxYr5LJZ5hylzyY,5991
+fauna/encoding/decoder.py,sha256=GdgC_oiMVF9SX-AoZ_-0DvTnvN3mvPIiW9Vl0EpPSvI,5775
+fauna/encoding/encoder.py,sha256=kJRd4WZv2PFZmhv7h4U_Kx3ZiDra9TsqFEIcHNMHZGI,7403
+fauna/encoding/wire_protocol.py,sha256=D_DMO_jSSQgBh-gctEZO9PNYl-dtaLHZRO-5FQ5SQg8,6031
 fauna/errors/__init__.py,sha256=w0rUF3kSFPDxjQB8YyZ1oHvU8lo8TOyNrB_G7_fNlJM,361
-fauna/errors/errors.py,sha256=HRXZ24Sju-9vz0qnnPGbuTjj3qot90l4k3hx4UImAD0,4853
+fauna/errors/errors.py,sha256=9olUEIbJ4Z8R4YX4oOLUqk0vH7Tr22gm3HQA55mUJqk,4664
 fauna/http/__init__.py,sha256=bPdaa7lvksdkCrazHEnqHPTHi0kWD-13bxryDwSguM8,88
-fauna/http/http_client.py,sha256=AS6-dCZ5MmfZ14o5FdxWP5waeYIKMJEqrxEn-fXAE-A,1201
-fauna/http/httpx_client.py,sha256=QG4lkmzYdwiTiXM93EhKPeToGqDf8tLOViFX4fR3Gw8,2323
+fauna/http/http_client.py,sha256=0ouVqlc4h6Y8u9ep4ICz3onYP0kCRWf8_a7DU8jYo2I,1095
+fauna/http/httpx_client.py,sha256=sYZclCj-Flxcwby7HHJ7z6aqpPp8GhIVDFRZAE7nlhI,2085
 fauna/query/__init__.py,sha256=Ip51imOskDJpQhDahuq-VcX3o3cb4Y62HUG26rzXCh0,153
-fauna/query/models.py,sha256=T5B1o9YUGGqhQh2QreBwqqiDtQqa43WyZ6RQO5EVUAw,9411
-fauna/query/query_builder.py,sha256=0WqByty8V5NmAYb0rYZw5BP8SUwFtXQYkhaVKFblb0Q,4005
-fauna/query/template.py,sha256=JVAz5cLS_xvTTn0yoUO8bToh7PWgz_BH09a5_XKKHYI,2851
-fauna-0.7.1.dist-info/LICENSE,sha256=0uf36d4oXjlrnYCeCbzUq9413zcktAbg1y5V_dKmNlQ,545
-fauna-0.7.1.dist-info/METADATA,sha256=4jKBOAFLsSenEZxvWPav9V9Nsu-FF5PxiP3FPswTWXM,7565
-fauna-0.7.1.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
-fauna-0.7.1.dist-info/top_level.txt,sha256=Ftl5tOivmmW8rHU9QbV0qMG8M9WQp3JhmYM-s3HU10s,6
-fauna-0.7.1.dist-info/RECORD,,
+fauna/query/models.py,sha256=JvNhzmHqD0yErRTG4_evKyOUjfLZbohFW_KKPUgOjRA,8562
+fauna/query/query_builder.py,sha256=QD5w7ohKdJd00XLtSs_Y7Dplos64BzfC0rqxNCluI7g,3838
+fauna/query/template.py,sha256=cFvLR639MqpH_en8PH7gE89PgPSfR3sd0iKaOKm3pQI,2657
+fauna-0.8.0.dist-info/LICENSE,sha256=0uf36d4oXjlrnYCeCbzUq9413zcktAbg1y5V_dKmNlQ,545
+fauna-0.8.0.dist-info/METADATA,sha256=bzpLTZwdn8834z5axnhme8VpKS5tcbzp20X5saA6m2o,7569
+fauna-0.8.0.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+fauna-0.8.0.dist-info/top_level.txt,sha256=Ftl5tOivmmW8rHU9QbV0qMG8M9WQp3JhmYM-s3HU10s,6
+fauna-0.8.0.dist-info/RECORD,,
```

