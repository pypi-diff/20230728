# Comparing `tmp/opentf_tools_nightly-0.43.0.dev455-py3-none-any.whl.zip` & `tmp/opentf_tools_nightly-0.43.0.dev460-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,16 +1,16 @@
-Zip file size: 40264 bytes, number of entries: 14
--rw-r--r--  2.0 unx    27544 b- defN 23-Jul-26 15:47 opentf/tools/ctl.py
--rw-r--r--  2.0 unx     7773 b- defN 23-Jul-26 15:47 opentf/tools/ctlcommons.py
--rw-r--r--  2.0 unx    29452 b- defN 23-Jul-26 15:47 opentf/tools/ctlconfig.py
--rw-r--r--  2.0 unx     8878 b- defN 23-Jul-26 15:47 opentf/tools/ctlnetworking.py
--rw-r--r--  2.0 unx    12037 b- defN 23-Jul-26 15:47 opentf/tools/ctlqualitygate.py
--rw-r--r--  2.0 unx    29356 b- defN 23-Jul-26 15:47 opentf/tools/ctlworkflows.py
--rw-r--r--  2.0 unx     3188 b- defN 23-Jul-26 15:47 opentf/tools/done.py
--rw-r--r--  2.0 unx     9391 b- defN 23-Jul-26 15:47 opentf/tools/ready.py
--rw-rw-rw-  2.0 unx    11357 b- defN 23-Jul-26 15:47 opentf_tools_nightly-0.43.0.dev455.dist-info/LICENSE
--rw-r--r--  2.0 unx     1808 b- defN 23-Jul-26 15:47 opentf_tools_nightly-0.43.0.dev455.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-26 15:47 opentf_tools_nightly-0.43.0.dev455.dist-info/WHEEL
--rw-r--r--  2.0 unx      139 b- defN 23-Jul-26 15:47 opentf_tools_nightly-0.43.0.dev455.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        7 b- defN 23-Jul-26 15:47 opentf_tools_nightly-0.43.0.dev455.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1266 b- defN 23-Jul-26 15:47 opentf_tools_nightly-0.43.0.dev455.dist-info/RECORD
-14 files, 142288 bytes uncompressed, 38132 bytes compressed:  73.2%
+Zip file size: 39959 bytes, number of entries: 14
+-rw-r--r--  2.0 unx    23214 b- defN 23-Jul-27 16:27 opentf/tools/ctl.py
+-rw-r--r--  2.0 unx     9256 b- defN 23-Jul-27 16:27 opentf/tools/ctlcommons.py
+-rw-r--r--  2.0 unx    29452 b- defN 23-Jul-27 16:27 opentf/tools/ctlconfig.py
+-rw-r--r--  2.0 unx     8878 b- defN 23-Jul-27 16:27 opentf/tools/ctlnetworking.py
+-rw-r--r--  2.0 unx    12377 b- defN 23-Jul-27 16:27 opentf/tools/ctlqualitygate.py
+-rw-r--r--  2.0 unx    28573 b- defN 23-Jul-27 16:27 opentf/tools/ctlworkflows.py
+-rw-r--r--  2.0 unx     3188 b- defN 23-Jul-27 16:27 opentf/tools/done.py
+-rw-r--r--  2.0 unx     9391 b- defN 23-Jul-27 16:27 opentf/tools/ready.py
+-rw-rw-rw-  2.0 unx    11357 b- defN 23-Jul-27 16:27 opentf_tools_nightly-0.43.0.dev460.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1808 b- defN 23-Jul-27 16:27 opentf_tools_nightly-0.43.0.dev460.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-27 16:27 opentf_tools_nightly-0.43.0.dev460.dist-info/WHEEL
+-rw-r--r--  2.0 unx      139 b- defN 23-Jul-27 16:27 opentf_tools_nightly-0.43.0.dev460.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 23-Jul-27 16:27 opentf_tools_nightly-0.43.0.dev460.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1266 b- defN 23-Jul-27 16:27 opentf_tools_nightly-0.43.0.dev460.dist-info/RECORD
+14 files, 138998 bytes uncompressed, 37827 bytes compressed:  72.8%
```

## zipnote {}

```diff
@@ -18,26 +18,26 @@
 
 Filename: opentf/tools/done.py
 Comment: 
 
 Filename: opentf/tools/ready.py
 Comment: 
 
-Filename: opentf_tools_nightly-0.43.0.dev455.dist-info/LICENSE
+Filename: opentf_tools_nightly-0.43.0.dev460.dist-info/LICENSE
 Comment: 
 
-Filename: opentf_tools_nightly-0.43.0.dev455.dist-info/METADATA
+Filename: opentf_tools_nightly-0.43.0.dev460.dist-info/METADATA
 Comment: 
 
-Filename: opentf_tools_nightly-0.43.0.dev455.dist-info/WHEEL
+Filename: opentf_tools_nightly-0.43.0.dev460.dist-info/WHEEL
 Comment: 
 
-Filename: opentf_tools_nightly-0.43.0.dev455.dist-info/entry_points.txt
+Filename: opentf_tools_nightly-0.43.0.dev460.dist-info/entry_points.txt
 Comment: 
 
-Filename: opentf_tools_nightly-0.43.0.dev455.dist-info/top_level.txt
+Filename: opentf_tools_nightly-0.43.0.dev460.dist-info/top_level.txt
 Comment: 
 
-Filename: opentf_tools_nightly-0.43.0.dev455.dist-info/RECORD
+Filename: opentf_tools_nightly-0.43.0.dev460.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## opentf/tools/ctl.py

```diff
@@ -10,29 +10,28 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 """opentf-ctl"""
 
-import json
-from typing import Any, Dict, Iterable, List
+from typing import List
 
+import json
 import sys
 
 import jwt
 
 from opentf.tools.ctlcommons import (
     _make_params_from_selectors,
     _ensure_options,
     _is_command,
     _error,
     _warning,
-    _get_columns,
-    _emit_csv,
+    _emit_output,
     _get_arg,
 )
 from opentf.tools.ctlconfig import (
     read_configuration,
     config_cmd,
     print_config_help,
     CONFIG,
@@ -137,14 +136,15 @@
   # List the subscriptions with more details
   opentf-ctl get subscriptions --output=wide
 
   # Get just the subscription names and IDs
   opentf-ctl get subscriptions --output=custom-columns=NAME:.metadata.name,ID:.metadata.subscription_id
 
 Options:
+  --output={yaml,json} or -o {yaml,json}: show information as YAML or JSON.
   --output=wide or -o wide: show additional information.
   --output=custom-columns= or -o custom-columns=: show specified information.
 
 Usage:
   opentf-ctl get subscriptions [options]
 
 Use "opentf-ctl options" for a list of global command-line options (applies to all commands).
@@ -168,14 +168,15 @@
   # List the channels
   opentf-ctl get channels
 
   # List the channels with more details
   opentf-ctl get channels --output=wide
 
 Options:
+  --output={yaml,json} or -o {yaml,json}: show information as YAML or JSON.
   --output=wide or -o wide: show additional information.
   --output=custom-columns= or -o custom-columns=: show specified information.
 
 Usage:
   opentf-ctl get channels [options]
 
 Use "opentf-ctl options" for a list of global command-line options (applies to all commands).
@@ -208,14 +209,15 @@
   # List the agents with more details
   opentf-ctl get agents --output=wide
 
   # Get just the agent IDs
   opentf-ctl get agents --output=custom-columns=ID:.metadata.agent_id
 
 Options:
+  --output={yaml,json} or -o {yaml,json}: show information as YAML or JSON.
   --output=wide or -o wide: show additional information.
   --output=custom-columns= or -o custom-columns=: show specified information.
 
 Usage:
   opentf-ctl get agents [options]
 
 Use "opentf-ctl options" for a list of global command-line options (applies to all commands).
@@ -275,73 +277,44 @@
 
 
 SUBSCRIPTION_COLUMNS = (
     'NAME:.metadata.name',
     'ENDPOINT:.spec.subscriber.endpoint',
     'CREATION:.metadata.creationTimestamp',
     'COUNT:.status.publicationCount',
-    'SUBSCRIPTIONS:.metadata.annotations',
+    'SUBSCRIPTIONS:.metadata.annotations.*',
 )
 
 WIDE_SUBSCRIPTION_COLUMNS = (
     'ID:.metadata.subscription_id',
     'NAME:.metadata.name',
     'ENDPOINT:.spec.subscriber.endpoint',
     'CREATION:.metadata.creationTimestamp',
     'COUNT:.status.publicationCount',
-    'SUBSCRIPTIONS:.metadata.annotations',
+    'SUBSCRIPTIONS:.metadata.annotations.*',
 )
 
 
-def _generate_subscription_row(
-    manifest: Dict[str, Any], columns: Iterable[str]
-) -> List[str]:
-    row = []
-    for item in columns:
-        field = item.split(':')[1]
-        if field == '.metadata.subscription_id':
-            row.append(manifest['metadata'].get('subscription_id', ''))
-        if field == '.metadata.name':
-            row.append(manifest['metadata']['name'])
-        if field == '.metadata.creationTimestamp':
-            row.append(manifest['metadata'].get('creationTimestamp', ''))
-        if field == '.spec.subscriber.endpoint':
-            row.append(manifest['spec']['subscriber']['endpoint'])
-        if field == '.status.publicationCount':
-            row.append(manifest['status']['publicationCount'])
-        if field == '.metadata.annotations':
-            row.append(':'.join(manifest['metadata']['annotations'].values()))
-    return row
-
-
-def _generate_subscriptions_rows(data: Dict[str, Any], columns: Iterable[str]):
-    for _, manifest in data.items():
-        yield _generate_subscription_row(manifest, columns)
-
-
 def list_subscriptions() -> None:
     """List all active subscriptions.
 
     Outputs information in CSV format (using ',' as a column delimiter).
 
     # Raised exceptions
 
     Abort with an error code 1 if the orchestrator replied with a non-ok
     code.
 
     Abort with an error code 2 if another error occurred.
     """
     what = _get(_eventbus(), '/subscriptions', 'Could not get subscriptions list')
 
-    try:
-        columns = _get_columns(WIDE_SUBSCRIPTION_COLUMNS, SUBSCRIPTION_COLUMNS)
-    except ValueError as err:
-        _error('Invalid parameters: %s.', err)
-        sys.exit(2)
-    _emit_csv(_generate_subscriptions_rows(what['items'], columns), columns)
+    _emit_output(
+        list(what['items'].values()), SUBSCRIPTION_COLUMNS, WIDE_SUBSCRIPTION_COLUMNS
+    )
 
 
 def delete_subscription(subscription_id: str) -> None:
     """Cancel a subscription."""
     what = _delete(
         _eventbus(),
         f'/subscriptions/{subscription_id}',
@@ -366,45 +339,14 @@
     'NAMESPACES:.metadata.namespaces',
     'TAGS:.spec.tags',
     'LAST_REFRESH_TIMESTAMP:.status.lastCommunicationTimestamp',
     'STATUS:.status.phase',
 )
 
 
-def _generate_channel_row(
-    manifest: Dict[str, Any], columns: Iterable[str]
-) -> List[str]:
-    row = []
-    for item in columns:
-        field = item.split(':')[1]
-        if field == '.metadata.name':
-            row.append(manifest['metadata']['name'])
-        if field == '.metadata.namespaces':
-            row.append(':'.join(manifest['metadata']['namespaces'].split(',')))
-        if field == '.spec.tags':
-            row.append(':'.join(manifest['spec']['tags']))
-        if field == '.status.lastCommunicationTimestamp':
-            row.append(manifest['status']['lastCommunicationTimestamp'][:22])
-        if field == '.status.phase':
-            row.append(manifest['status']['phase'])
-        if field == '.status.currentJobID':
-            row.append(manifest['status']['currentJobID'])
-        if field == '.metadata.channelhandler_id':
-            row.append(manifest['metadata']['channelhandler_id'])
-        # New in 2022-11
-        if field == '.status.lastSeenTimestamp':
-            row.append(manifest['status'].get('lastSeenTimestamp', '')[:22])
-    return row
-
-
-def _generate_channels_rows(data, columns: Iterable[str]):
-    for manifest in data:
-        yield _generate_channel_row(manifest, columns)
-
-
 def list_channels() -> None:
     """List all active agents.
 
     Outputs information in CSV format (using ',' as a column delimiter).
 
     # Raised exceptions
 
@@ -416,20 +358,15 @@
     what = _get(
         _observer(),
         '/channels',
         'Could not get channels list',
         params=_make_params_from_selectors(),
     )
 
-    try:
-        columns = _get_columns(WIDE_CHANNEL_COLUMNS, CHANNEL_COLUMNS)
-    except ValueError as err:
-        _error('Invalid parameters: %s.', err)
-        sys.exit(2)
-    _emit_csv(_generate_channels_rows(what['details']['items'], columns), columns)
+    _emit_output(what['details']['items'], CHANNEL_COLUMNS, WIDE_CHANNEL_COLUMNS)
 
 
 # Namepaces
 
 
 def list_namespaces() -> None:
     """List namespaces.
@@ -492,87 +429,37 @@
     'TAGS:.spec.tags',
     'REGISTRATION_TIMESTAMP:.metadata.creationTimestamp',
     'LAST_SEEN_TIMESTAMP:.status.lastCommunicationTimestamp',
     'RUNNING_JOB:.status.currentJobID',
 )
 
 
-def _generate_agent_row(manifest: Dict[str, Any], columns: Iterable[str]) -> List[str]:
-    # apiVersion: opentestfactory.org/v1alpha1
-    # kind: AgentRegistration
-    # metadata:
-    #   creationTimestamp': 2021-12-03T17:52:36.335360
-    #   name: test agent
-    #   namespaces: a,b
-    #   agent_id: id
-    # spec:
-    #   encoding: utf-8
-    #   script_path': '/where/to/put/scripts'
-    #   tags: ['windows', 'robotframework']
-    # status:
-    #   communicationCount: 0
-    #   communicationStatusSummary: {}
-    #   lastCommunicationTimestamp: '2021-12-03T17:53:41.560939'
-    #   currentJobID: currently running job ID or None if idle
-    row = []
-    for item in columns:
-        field = item.split(':')[1]
-        if field == '.metadata.name':
-            row.append(manifest['metadata']['name'])
-        if field == '.metadata.agent_id':
-            row.append(manifest['metadata']['agent_id'])
-        if field == '.metadata.namespaces':
-            row.append(
-                ':'.join(
-                    manifest['metadata'].get('namespaces', DEFAULT_NAMESPACE).split(',')
-                )
-            )
-        if field == '.metadata.creationTimestamp':
-            row.append(manifest['metadata']['creationTimestamp'])
-        if field == '.spec.tags':
-            row.append(':'.join(manifest['spec']['tags']))
-        if field == '.status.lastCommunicationTimestamp':
-            row.append(manifest['status']['lastCommunicationTimestamp'][:22])
-        if field == '.status.currentJobID':
-            row.append(manifest['status'].get('currentJobID', ''))
-    return row
-
-
-def _generate_agents_rows(data, columns: Iterable[str]):
-    # pre-2022-05 orchestrators where returning a dictionary, not a list
-    # of manifests.
-    if isinstance(data, dict):
-        for agent_id, manifest in data.items():
-            manifest['metadata']['agent_id'] = agent_id
-            yield _generate_agent_row(manifest, columns)
-    else:
-        for manifest in data:
-            yield _generate_agent_row(manifest, columns)
-
-
 def list_agents() -> None:
     """List all active agents.
 
     Outputs information in CSV format (using ',' as a column delimiter).
 
     # Raised exceptions
 
     Abort with an error code 1 if the orchestrator replied with a non-ok
     code.
 
     Abort with an error code 2 if another error occurred.
     """
     what = _get(_agentchannel(), '/agents', 'Could not get agents list')
+    data = what['items']
 
-    try:
-        columns = _get_columns(AGENT_COLUMNS, AGENT_COLUMNS)
-    except ValueError as err:
-        _error('Invalid parameters: %s.', err)
-        sys.exit(2)
-    _emit_csv(_generate_agents_rows(what['items'], columns), columns)
+    # pre-2022-05 orchestrators where returning a dictionary, not a list
+    # of manifests.
+    if isinstance(data, dict):
+        data = []
+        for agent_id, manifest in what['items'].items():
+            manifest['metadata']['agent_id'] = agent_id
+            data.append(manifest)
+    _emit_output(data, AGENT_COLUMNS, AGENT_COLUMNS)
 
 
 def delete_agent(agent_id: str) -> None:
     """Deregister agent."""
     what = _delete(
         _agentchannel(), f'/agents/{agent_id}', f'Could not delete agent {agent_id}'
     )
```

## opentf/tools/ctlcommons.py

```diff
@@ -10,21 +10,24 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 """opentf-ctl commons"""
 
-from typing import Iterable, List, Optional
+from typing import Any, Dict, Iterable, List, Optional
 
 import csv
+import json
 import logging
 import re
 import sys
 
+import yaml
+
 
 ########################################################################
 # debug
 
 
 def _error(*msg) -> None:
     logging.error(*msg)
@@ -214,14 +217,63 @@
             )
         return ccs
     if _get_arg('custom-columns='):
         raise ValueError('Missing "-o" parameter (found lone "custom-columns=")')
     return default
 
 
+def _generate_row(manifest: Dict[str, Any], columns: Iterable[str]) -> List[str]:
+    row = []
+    for item in columns:
+        fields = item.split(':')[1].lstrip('.').split('.')
+        value = manifest
+        for field in fields:
+            if field == '*' and isinstance(value, dict):
+                value = list(value.values())
+            else:
+                value = value.get(field)
+                if value is None:
+                    break
+        if isinstance(value, dict):
+            value = str(value)
+        elif isinstance(value, (list, set)):
+            value = ':'.join(value)
+        elif value is None:
+            value = '<none>'
+        elif isinstance(value, str) and field == 'namespaces':
+            value = ':'.join(value.split(','))
+        row.append(str(value))
+    return row
+
+
+def _emit_output(
+    data: Iterable[Dict[str, Any]],
+    default: Iterable[str],
+    wide: Iterable[str],
+    file=sys.stdout,
+):
+    try:
+        columns = _get_columns(wide, default)
+    except ValueError as err:
+        _error('Invalid parameters: %s', err)
+        sys.exit(2)
+
+    output = _get_arg('--output=')
+    if output is None:
+        output = _get_arg('-o=')
+    if output == 'yaml':
+        yaml.safe_dump(data, file)
+    elif output == 'json':
+        json.dump(data, file, indent=2)
+    else:
+        _emit_csv(
+            (_generate_row(manifest, columns) for manifest in data), columns, file=file
+        )
+
+
 def _emit_csv(
     data: Iterable[Iterable[str]], columns: Iterable[str], file=sys.stdout
 ) -> None:
     """Generate csv.
 
     `data` is an iterable.  `columns` is a columns specification
     ('title:path').
```

## opentf/tools/ctlqualitygate.py

```diff
@@ -42,14 +42,17 @@
 Examples:
   # Get the quality gate status of a workflow applying the specific quality gate from the definition file
   opentf-ctl get qualitygate 9ea3be45-ee90-4135-b47f-e66e4f793383 --using=my.qualitygate.yaml --mode=my.quality.gate
 
   # Get the quality gate status of a workflow applying the default strict quality gate (threshold=100%)
   opentf-ctl get qualitygate 9ea3be45-ee90-4135-b47f-e66e4f793383
 
+  # Get the quality gate status of a workflow applying a specific quality gate showing scope and ratio only
+  opentf-ctl get qualitygate a13f0572-b23b-40bc-a6eb-a12429f0143c --mode custom.quality.gate -o custom-columns=RULE_SCOPE:rule.scope,RATIO:rule.success_ratio
+
 Options:
   --mode=my.quality.gate|strict|passing|... or -m=...: use the specific quality gate from the definition file
   or one of the default quality gates (strict with 100% threshold and passing with 0% threshold)
   --using=/path/to/definition.yaml: use the specific quality gate definition file.
   --output=wide or -o wide: show additional information (rule threshold and scope).
   --output=custom-columns= or -o custom-columns=: show specified information.
 
@@ -79,30 +82,30 @@
 Use "opentf-ctl options" for a list of global command-line options (applies to all commands).
 '''
 
 ########################################################################
 # Quality gate
 
 DEFAULT_COLUMNS = (
-    'RULE:rule',
-    'RESULT:rule.result',
-    'TESTS_IN_SCOPE:rule.tests_in_scope',
-    'TESTS_FAILED:rule.tests_failed',
-    'TESTS_PASSED:rule.tests_passed',
-    'SUCCESS_RATIO:rule.success_ratio',
+    'RULE:.rule.name',
+    'RESULT:.rule.result',
+    'TESTS_IN_SCOPE:.rule.tests_in_scope',
+    'TESTS_FAILED:.rule.tests_failed',
+    'TESTS_PASSED:.rule.tests_passed',
+    'SUCCESS_RATIO:.rule.success_ratio',
 )
 WIDE_COLUMNS = (
-    'RULE:rule',
-    'RESULT:rule.result',
-    'TESTS_IN_SCOPE:rule.tests_in_scope',
-    'TESTS_FAILED:rule.tests_failed',
-    'TESTS_PASSED:rule.tests_passed',
-    'SUCCESS_RATIO:rule.success_ratio',
-    'THRESHOLD:rule.threshold',
-    'SCOPE:rule.scope',
+    'RULE:.rule.name',
+    'RESULT:.rule.result',
+    'TESTS_IN_SCOPE:.rule.tests_in_scope',
+    'TESTS_FAILED:.rule.tests_failed',
+    'TESTS_PASSED:.rule.tests_passed',
+    'SUCCESS_RATIO:.rule.success_ratio',
+    'THRESHOLD:.rule.threshold',
+    'SCOPE:.rule.scope',
 )
 
 NOTEST = 'NOTEST'
 FAILURE = 'FAILURE'
 RUNNING = 'RUNNING'
 SUCCESS = 'SUCCESS'
 INVALIDSCOPE = 'INVALID_SCOPE'
@@ -157,15 +160,16 @@
 def _make_rule_row(name: str, data: Dict[str, Any], fields: List[str]) -> List[str]:
     if data['result'] not in (SUCCESS, NOTEST, FAILURE, INVALIDSCOPE):
         _fatal(
             f'Unexpected quality gate result when applying rule `{name}`: {data["result"]} (was expecting {", ".join(STATUS_TEMPLATES)}).'
         )
     row = []
     for field in fields:
-        if field == 'rule':
+        field = field.lstrip('.')
+        if field in ('rule', 'rule.name'):
             row.append(name)
         elif field.startswith('rule.') and data:
             row.append(data.get(field.split('.')[1], ''))
         else:
             row.append('')
     return row
```

## opentf/tools/ctlworkflows.py

```diff
@@ -27,15 +27,15 @@
 
 from opentf.tools.ctlcommons import (
     _make_params_from_selectors,
     _ensure_options,
     _is_command,
     _get_arg,
     _get_columns,
-    _emit_csv,
+    _emit_output,
     _ensure_uuid,
     _error,
     _warning,
     _debug,
 )
 from opentf.tools.ctlconfig import read_configuration, CONFIG
 from opentf.tools.ctlnetworking import (
@@ -161,14 +161,15 @@
   # Get the status of active and recent workflows
   opentf-ctl get workflows --output=wide
 
   # Get just the workflow IDs of active and recent workflows
   opentf-ctl get workflows --output=custom-columns=ID:.metadata.workflow_id
 
 Options:
+  --output={yaml,json} or -o {yaml,json}: show information as YAML or JSON.
   --output=wide or -o wide: show additional information.
   --output=custom-columns= or -o custom-columns=: show specified information.
 
 Usage:
   opentf-ctl get workflows [--output=wide] [options]
 
 Use "opentf-ctl options" for a list of global command-line options (applies to all commands).
@@ -279,44 +280,22 @@
     """
     for manifest in what:
         if manifest.get('kind') == 'Workflow':
             return manifest
     return None
 
 
-def _generate_row(
-    workflow_id: str, response: Dict[str, Any], columns: Iterable[str]
-) -> List[str]:
-    row = []
-    for item in columns:
-        field = item.split(':')[1]
-        if field == '.metadata.workflow_id':
-            row.append(workflow_id)
-        if field == '.details.status':
-            row.append(response['details']['status'])
-        if field == '.metadata.name':
-            if manifest := _get_workflow_manifest(response['details']['items']):
-                row.append(manifest['metadata']['name'])
-            else:
-                row.append('')
-        if field == '.metadata.creationTimestamp':
-            what = response['details']['items']
-            if what:
-                manifest = _get_workflow_manifest(what) or what[0]
-                row.append(manifest.get('metadata', {}).get('creationTimestamp', ''))
-            else:
-                row.append('')
-    return row
-
-
-def _generate_rows(workflows_ids, columns: Iterable[str]) -> Iterable[List[str]]:
+def _get_manifests(workflows_ids) -> Iterable[Dict[str, Any]]:
     for workflow_id in workflows_ids:
         response = _get_first_page(workflow_id)
         if response.status_code == 200:
-            yield _generate_row(workflow_id, response.json(), columns)
+            wf = _get_workflow_manifest(response.json()['details']['items'])
+            if wf:
+                wf['details'] = {'status': response.json()['details']['status']}
+            yield wf
         else:
             print(workflow_id, 'got response code', response.status_code)
 
 
 def _handler_maybe_outdated(response) -> NoReturn:
     if response.status_code in (404, 405):
         _error('Could not get workflows list.  Maybe an outdated orchestrator version.')
@@ -341,24 +320,22 @@
     except Exception as err:
         _error('Could not get columns specification: %s.', err)
         sys.exit(2)
 
 
 def list_workflows() -> None:
     """List active and recent workflows."""
-    columns = _retrieve_columns_to_display(WIDE_COLUMNS, DEFAULT_COLUMNS)
-
     response = _get_json(
         _observer(),
         '/workflows',
         'Could not get workflows list',
         handler=_handler_maybe_outdated,
     )
     workflows_ids = response['details']['items']
-    _emit_csv(_generate_rows(workflows_ids, columns), columns)
+    _emit_output(list(_get_manifests(workflows_ids)), DEFAULT_COLUMNS, WIDE_COLUMNS)
 
 
 def _handler_maybe_details(response) -> NoReturn:
     _error(response.json()['message'])
     if response.json().get('details'):
         _error(response.json()['details'].get('error'))
     sys.exit(1)
```

## Comparing `opentf_tools_nightly-0.43.0.dev455.dist-info/LICENSE` & `opentf_tools_nightly-0.43.0.dev460.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `opentf_tools_nightly-0.43.0.dev455.dist-info/METADATA` & `opentf_tools_nightly-0.43.0.dev460.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: opentf-tools-nightly
-Version: 0.43.0.dev455
+Version: 0.43.0.dev460
 Summary: OpenTestFactory Orchestrator Tools
 Home-page: https://opentestfactory.org/tools/
 Author: Martin Lafaix
 Author-email: mlafaix@henix.com
 Maintainer: Henix
 Maintainer-email: opentestfactory@henix.com
 License: Apache Software License (https://www.apache.org/licenses/LICENSE-2.0)
```

## Comparing `opentf_tools_nightly-0.43.0.dev455.dist-info/RECORD` & `opentf_tools_nightly-0.43.0.dev460.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,14 +1,14 @@
-opentf/tools/ctl.py,sha256=H930DQ1e0Iv3zwpL_ZiXXxiixVrF55A89N8MH9deftI,27544
-opentf/tools/ctlcommons.py,sha256=A1HKWqLQfQY1BFJA0ugXERK2klC23c8u0jn5lYz8uxE,7773
+opentf/tools/ctl.py,sha256=L0FUp9FCx9ISYunmw1pWtJb9U2vWs28VEjMsqZv7HSU,23214
+opentf/tools/ctlcommons.py,sha256=hWmQLwq7c1-TEwVtlf127uW9yFap_of6VKqVskThhmQ,9256
 opentf/tools/ctlconfig.py,sha256=dWY0RHgpa7GeC1GMMBniUctuCQKrnXyY-AcNm5xhrNQ,29452
 opentf/tools/ctlnetworking.py,sha256=NO_U5VZ49w5vEcbOzX7cjXFY8ygsOb6NaoEgj4U1oW0,8878
-opentf/tools/ctlqualitygate.py,sha256=wUnEK5PVbESMFJkr5zQEEjTx9sp3if5b3n26FGzbddY,12037
-opentf/tools/ctlworkflows.py,sha256=Fl6sG84U8IaDhQDjIbpB3dINhWmjvVEmhI7Tfq3pDsU,29356
+opentf/tools/ctlqualitygate.py,sha256=TL9-fL1BIUX9Zqjb-0EbCgIuu_6V4uv9_tkBfU1hz90,12377
+opentf/tools/ctlworkflows.py,sha256=DW6e3SnDcH4G1JPAhd1aO8kK5qJYN-_aZurKLQtHsX0,28573
 opentf/tools/done.py,sha256=1X5s9IjpphD0LZvcQ0h36mKHkbLjjYDzlqqwat6kKdE,3188
 opentf/tools/ready.py,sha256=WHPdnWCMOKLCxLlF0FTCCpW-8y0BF7rrGCl7H2AJ-DM,9391
-opentf_tools_nightly-0.43.0.dev455.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-opentf_tools_nightly-0.43.0.dev455.dist-info/METADATA,sha256=JM2ANH8psZM_5MVtbZ8RyZd0WJUUUk7QDZ2aj-V4_zY,1808
-opentf_tools_nightly-0.43.0.dev455.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-opentf_tools_nightly-0.43.0.dev455.dist-info/entry_points.txt,sha256=u5qYtmUbgIMcq8360YobnI9CtDvrjptf4lDkmKojoa0,139
-opentf_tools_nightly-0.43.0.dev455.dist-info/top_level.txt,sha256=_gPuE6GTT6UNXy1DjtmQSfCcZb_qYA2vWmjg7a30AGk,7
-opentf_tools_nightly-0.43.0.dev455.dist-info/RECORD,,
+opentf_tools_nightly-0.43.0.dev460.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+opentf_tools_nightly-0.43.0.dev460.dist-info/METADATA,sha256=bwENIS-vT8PjR3iBn7AI-CtEN3rqCfc7EfQu5vU1bwg,1808
+opentf_tools_nightly-0.43.0.dev460.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+opentf_tools_nightly-0.43.0.dev460.dist-info/entry_points.txt,sha256=u5qYtmUbgIMcq8360YobnI9CtDvrjptf4lDkmKojoa0,139
+opentf_tools_nightly-0.43.0.dev460.dist-info/top_level.txt,sha256=_gPuE6GTT6UNXy1DjtmQSfCcZb_qYA2vWmjg7a30AGk,7
+opentf_tools_nightly-0.43.0.dev460.dist-info/RECORD,,
```

