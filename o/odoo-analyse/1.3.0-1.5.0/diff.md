# Comparing `tmp/odoo_analyse-1.3.0-py3-none-any.whl.zip` & `tmp/odoo_analyse-1.5.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,20 +1,18 @@
-Zip file size: 28117 bytes, number of entries: 18
--rw-rw-r--  2.0 unx      327 b- defN 23-Feb-06 07:40 odoo_analyse/__init__.py
--rw-rw-r--  2.0 unx     9770 b- defN 23-Feb-06 07:40 odoo_analyse/__main__.py
--rw-rw-r--  2.0 unx      562 b- defN 23-Feb-06 07:40 odoo_analyse/field.py
--rw-rw-r--  2.0 unx      824 b- defN 23-Feb-06 07:40 odoo_analyse/function.py
--rw-r--r--  2.0 unx     2359 b- defN 21-May-30 13:51 odoo_analyse/js_module.py
--rw-rw-r--  2.0 unx     9846 b- defN 21-Jun-05 11:26 odoo_analyse/main.py
--rw-rw-r--  2.0 unx     4946 b- defN 23-Feb-06 07:40 odoo_analyse/model.py
--rw-rw-r--  2.0 unx    15179 b- defN 23-Feb-06 07:40 odoo_analyse/module.py
--rw-rw-r--  2.0 unx    20399 b- defN 23-Feb-06 07:40 odoo_analyse/odoo.py
--rw-rw-r--  2.0 unx     4447 b- defN 23-Feb-06 07:40 odoo_analyse/record.py
--rw-rw-r--  2.0 unx     4083 b- defN 23-Feb-06 07:40 odoo_analyse/utils.py
--rw-r--r--  2.0 unx     3975 b- defN 23-Feb-02 10:57 odoo_analyse/view.py
--rw-rw-r--  2.0 unx     7652 b- defN 23-Feb-06 07:42 odoo_analyse-1.3.0.dist-info/LICENSE
--rw-rw-r--  2.0 unx     4590 b- defN 23-Feb-06 07:42 odoo_analyse-1.3.0.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Feb-06 07:42 odoo_analyse-1.3.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       61 b- defN 23-Feb-06 07:42 odoo_analyse-1.3.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       13 b- defN 23-Feb-06 07:42 odoo_analyse-1.3.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1458 b- defN 23-Feb-06 07:42 odoo_analyse-1.3.0.dist-info/RECORD
-18 files, 90583 bytes uncompressed, 25741 bytes compressed:  71.6%
+Zip file size: 26025 bytes, number of entries: 16
+-rw-r--r--  2.0 unx      469 b- defN 23-Jul-28 07:33 odoo_analyse/__init__.py
+-rw-r--r--  2.0 unx     9770 b- defN 23-Jul-28 07:33 odoo_analyse/__main__.py
+-rw-r--r--  2.0 unx      562 b- defN 23-Jul-28 07:33 odoo_analyse/field.py
+-rw-r--r--  2.0 unx     1015 b- defN 23-Jul-28 07:33 odoo_analyse/function.py
+-rw-r--r--  2.0 unx     4838 b- defN 23-Jul-28 07:33 odoo_analyse/js_module.py
+-rw-r--r--  2.0 unx     5216 b- defN 23-Jul-28 07:33 odoo_analyse/model.py
+-rw-r--r--  2.0 unx    16689 b- defN 23-Jul-28 07:33 odoo_analyse/module.py
+-rw-r--r--  2.0 unx    20525 b- defN 23-Jul-28 07:33 odoo_analyse/odoo.py
+-rw-r--r--  2.0 unx     4447 b- defN 23-Jul-28 07:33 odoo_analyse/record.py
+-rw-r--r--  2.0 unx     4847 b- defN 23-Jul-28 07:33 odoo_analyse/utils.py
+-rw-r--r--  2.0 unx     7652 b- defN 23-Jul-28 07:34 odoo_analyse-1.5.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     4645 b- defN 23-Jul-28 07:34 odoo_analyse-1.5.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-28 07:34 odoo_analyse-1.5.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       60 b- defN 23-Jul-28 07:34 odoo_analyse-1.5.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       13 b- defN 23-Jul-28 07:34 odoo_analyse-1.5.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1305 b- defN 23-Jul-28 07:34 odoo_analyse-1.5.0.dist-info/RECORD
+16 files, 82145 bytes uncompressed, 23881 bytes compressed:  70.9%
```

## zipnote {}

```diff
@@ -9,17 +9,14 @@
 
 Filename: odoo_analyse/function.py
 Comment: 
 
 Filename: odoo_analyse/js_module.py
 Comment: 
 
-Filename: odoo_analyse/main.py
-Comment: 
-
 Filename: odoo_analyse/model.py
 Comment: 
 
 Filename: odoo_analyse/module.py
 Comment: 
 
 Filename: odoo_analyse/odoo.py
@@ -27,29 +24,26 @@
 
 Filename: odoo_analyse/record.py
 Comment: 
 
 Filename: odoo_analyse/utils.py
 Comment: 
 
-Filename: odoo_analyse/view.py
-Comment: 
-
-Filename: odoo_analyse-1.3.0.dist-info/LICENSE
+Filename: odoo_analyse-1.5.0.dist-info/LICENSE
 Comment: 
 
-Filename: odoo_analyse-1.3.0.dist-info/METADATA
+Filename: odoo_analyse-1.5.0.dist-info/METADATA
 Comment: 
 
-Filename: odoo_analyse-1.3.0.dist-info/WHEEL
+Filename: odoo_analyse-1.5.0.dist-info/WHEEL
 Comment: 
 
-Filename: odoo_analyse-1.3.0.dist-info/entry_points.txt
+Filename: odoo_analyse-1.5.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: odoo_analyse-1.3.0.dist-info/top_level.txt
+Filename: odoo_analyse-1.5.0.dist-info/top_level.txt
 Comment: 
 
-Filename: odoo_analyse-1.3.0.dist-info/RECORD
+Filename: odoo_analyse-1.5.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## odoo_analyse/__init__.py

```diff
@@ -1,10 +1,22 @@
 # © 2020 initOS GmbH
 # License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl.html)
 
 from .model import Model
 from .module import Module
 from .odoo import Odoo
 from .record import Record, View
-from .utils import folder_blacklist, stopwords
+from .utils import eslint_complexity, folder_blacklist, geometric_mean, stopwords
 
-__all__ = ["Model", "Module", "Odoo", "folder_blacklist", "stopwords", "View"]
+__all__ = [
+    "Model",
+    "Module",
+    "Odoo",
+    "folder_blacklist",
+    "stopwords",
+    "Record",
+    "View",
+    "eslint_complexity",
+    "geometric_mean",
+]
+
+VERSION = "1.5.0"
```

## odoo_analyse/function.py

```diff
@@ -1,28 +1,37 @@
 # © 2023 initOS GmbH
 # License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl.html)
 
 from typing import Union
 
 
 class Function:
-    def __init__(self, args: list, complexity: int = None, lines: int = None):
+    def __init__(
+        self, args: list, complexity: int = None, lines: int = None, halstead: int = 0
+    ):
         self.args = args
         self.complexity = complexity or 0
         self.lines = lines or 0
+        self.halstead = halstead or 0
 
     def __repr__(self) -> str:
         return f"<Function: {self.args}>"
 
     def to_json(self) -> dict:
         return {
             "args": self.args,
             "arg_count": len(self.args),
             "complexity": self.complexity,
             "lines": self.lines,
+            "halstead": self.halstead,
         }
 
     @classmethod
     def from_json(cls, data: Union[dict, list]) -> "Function":
         if isinstance(data, (list, tuple)):
             return cls(data)
-        return cls(data["args"], data.get("complexity"), data.get("lines"))
+        return cls(
+            data["args"],
+            data.get("complexity"),
+            data.get("lines"),
+            data.get("halstead"),
+        )
```

## odoo_analyse/js_module.py

```diff
@@ -1,74 +1,163 @@
 import logging
 import os
 import re
 
-ODOO_MODULE_RE = re.compile(r"""
+from .utils import eslint_complexity
+
+# Adapted from odoo.tools.js_transpiler
+ODOO_MODULE_RE = re.compile(
+    r"""
     \s*                                       # some starting space
     \/(\*|\/).*\s*                            # // or /*
     @odoo-module                              # @odoo-module
     (\s+alias=(?P<alias>[\w.]+))?             # alias=web.AbstractAction (optional)
     (\s+default=(?P<default>False|false|0))?  # default=False or false or 0 (optional)
-""", re.VERBOSE)
+""",
+    re.VERBOSE,
+)
 
 
-REQUIRE_RE = re.compile(r"""
-    require\s*                 # require
-    \(\s*                      # (
-    (?P<quote>["'`])(?P<path>[^"'`]*?)(?P=quote)
-    \s*\)                      # )
-""", re.MULTILINE | re.VERBOSE)
+REQUIRE_RE = re.compile(
+    r"""require\s*\(\s*(?P<quote>["'`])(?P<path>[^"'`]*?)(?P=quote)\s*\)""",
+    re.MULTILINE | re.VERBOSE,
+)
 
 
-ODOO_DEFINE_RE = re.compile(r"""
-    odoo\s*\.\s*define\s*
-    \(\s*
-    (?P<quote>["'`])(?P<path>[^"'`]*?)(?P=quote)
-""", re.MULTILINE | re.VERBOSE)
+ODOO_DEFINE_RE = re.compile(
+    r"""odoo\s*\.\s*define\s*\(\s*(?P<quote>["'`])(?P<path>[^"'`]*?)(?P=quote)""",
+    re.MULTILINE | re.VERBOSE,
+)
 
 
-IMPORT_BASIC_RE = re.compile(r"""
+IMPORT_BASIC_RE = re.compile(
+    r"""
     ^
-    (?P<space>\s*)                      # space and empty line
-    import\s+                           # import
+    \s*import\s+                           # import
     (?P<object>{(\s*\w+\s*,?\s*)+})\s*  # { a, b, c as x, ... }
     from\s*                             # from
     (?P<quote>["'`])(?P<path>[^"'`]+)(?P=quote)   # "file path" ("some/path")
-""", re.MULTILINE | re.VERBOSE)
+""",
+    re.MULTILINE | re.VERBOSE,
+)
+
+URL_RE = re.compile(
+    r"""
+    /?(?P<module>\S+)    # /module name
+    /([\S/]*/)?static/   # ... /static/
+    (?P<type>src|tests)  # src or test file
+    (?P<url>/[\S/]*)     # URL (/...)
+    """,
+    re.VERBOSE,
+)
+
+
+def url_to_module_path(url):
+    """
+    Odoo modules each have a name. (odoo.define("<the name>", function (require) {...});
+    It is used in to be required later. (const { something } = require("<the name>").
+    The transpiler transforms the url of the file in the project to this name.
+    It takes the module name and add a @ on the start of it, and map it to be the source
+    of the static/src (or static/tests) folder in that module.
+
+    in: web/static/src/one/two/three.js
+    out: @web/one/two/three.js
+    The module would therefore be defined and required by this path.
+
+    :param url: an url in the project
+    :return: a special path starting with @<module-name>.
+    """
+    match = URL_RE.match(url)
+    if match:
+        url = match["url"]
+        if url.endswith(("/index.js", "/index")):
+            url, _ = url.rsplit("/", 1)
+        if url.endswith(".js"):
+            url = url[:-3]
+        if match["type"] == "src":
+            return "@%s%s" % (match["module"], url)
+
+        return "@%s/../tests%s" % (match["module"], url)
+    return url
 
 
 _logger = logging.getLogger(__name__)
 
 
 class JSModule:
-    def __init__(self, name, alias=None, default=True, dependencies=None):
+    def __init__(self, name, alias=None, complexity=None, default=True, requires=None):
         self.name = name
         self.alias = alias or None
-        self.default = default
-        self.dependencies = set(dependencies or [])
+        self.default = bool(default)
+        self.requires = set(requires or [])
+        self.complexity = complexity or 0
+
+    def __repr__(self):
+        name = self.name
+        if self.alias:
+            name = "%s/%s" % (name, self.alias)
+        return "<JS: %s>" % name
+
+    def copy(self):
+        return JSModule(
+            self.name,
+            self.alias,
+            self.complexity,
+            self.default,
+            self.requires,
+        )
+
+    def to_json(self):
+        return {
+            "name": self.name,
+            "alias": self.alias,
+            "complexity": self.complexity,
+            "default": self.default,
+            "requires": list(self.requires),
+        }
+
+    @classmethod
+    def from_json(cls, data):
+        return cls(
+            data["name"],
+            alias=data.get("alias", None),
+            complexity=data.get("complexity", None),
+            default=data.get("default", True),
+            requires=data.get("requires", None),
+        )
 
     @classmethod
     def from_file(cls, path, file):
         if not os.path.isfile(path):
             return None
 
-        with open(path) as fp:
+        with open(path, encoding="utf-8") as fp:
             content = fp.read()
 
+        name = url_to_module_path(file)
+
+        complexity = eslint_complexity(path)
+
         # Old odoo.define format
         defines = ODOO_DEFINE_RE.findall(content)
         if defines:
             if len(defines) > 1:
-                _logger.warning("Multiple odoo.define in single JS %s", file)
+                _logger.warning("Multiple odoo.define in single JS %s", name)
 
             define = defines[0][1]
             requires = [x[1] for x in REQUIRE_RE.findall(content)]
-            return cls(file, alias=define, dependencies=requires)
+            return cls(name, alias=define, complexity=complexity, requires=requires)
 
         # Newer odoo-module format
         module = ODOO_MODULE_RE.findall(content)
         if module:
-            alias, default = module[0][2::2]
             imports = [x[-1] for x in IMPORT_BASIC_RE.findall(content)]
-            return cls(file, alias=alias, default=not default, dependencies=imports)
+            requires = [x[1] for x in REQUIRE_RE.findall(content)]
+            return cls(
+                name,
+                alias=module[0][2],
+                complexity=complexity,
+                default=not module[0][4],
+                requires=imports + requires,
+            )
 
-        return None
+        return cls(name, complexity=complexity)
```

## odoo_analyse/model.py

```diff
@@ -1,18 +1,19 @@
 # © 2020 initOS GmbH
 # License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl.html)
 
 import ast
 from statistics import median
 
 from mccabe import PathGraphingAstVisitor
+from radon.metrics import h_visit_ast
 
 from .field import Field
 from .function import Function
-from .utils import get_ast_source_segment
+from .utils import geometric_mean, get_ast_source_segment
 
 
 class Model:
     def __init__(self, name=None, inherit=None, inherits=None, fields=None, funcs=None):
         self.name = name
         self.inherit = set(inherit or [])
         self.inherits = inherits or {}
@@ -28,14 +29,18 @@
     def max_complexity(self) -> int:
         return max((f.complexity for f in self.funcs.values()), default=0)
 
     @property
     def min_complexity(self) -> int:
         return min((f.complexity for f in self.funcs.values()), default=0)
 
+    @property
+    def halstead(self) -> int:
+        return geometric_mean([f.halstead for f in self.funcs.values()])
+
     def is_model(self) -> bool:
         return bool(self.name or self.inherit)
 
     def __repr__(self) -> str:
         if self.is_model():
             return f"<Model: {self.name}>"
         return f"<Class: {self.name}>"
@@ -90,22 +95,25 @@
                 definition = get_ast_source_segment(content, value)
                 self.fields[assign] = Field(f"fields.{f.attr}", definition)
 
     def _parse_function(self, obj: ast.FunctionDef) -> None:
         visitor = PathGraphingAstVisitor()
         visitor.preorder(obj, visitor)
 
+        halstead_visitor = h_visit_ast(obj)
+
         complexity = 0
         for graph in visitor.graphs.values():
             complexity = max(complexity, graph.complexity())
 
         self.funcs[obj.name] = Function(
             [a.arg for a in obj.args.args],
             complexity=complexity,
             lines=obj.end_lineno - obj.lineno,
+            halstead=halstead_visitor.total.volume,
         )
 
     def to_json(self) -> dict:
         return {
             "name": self.name,
             "inherit": list(self.inherit),
             "inherits": self.inherits,
```

## odoo_analyse/module.py

```diff
@@ -1,21 +1,24 @@
 # © 2020 initOS GmbH
 # License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl.html)
 
 import ast
+import glob
 import logging
 import os
 import re
 import sys
 import tempfile
 import time
 from functools import partial
+from pathlib import Path
 
 from lxml import etree
 
+from .js_module import JSModule
 from .model import Model
 from .record import Record
 from .utils import (
     analyse_language,
     fix_indentation,
     folder_blacklist,
     hexhash_files,
@@ -39,14 +42,16 @@
         self.name = path.rstrip("/").split("/")[-1]
         # Manifest of the module
         self.manifest = {}
         # Models defined in the module
         self.models = {}
         # Additional defined classes in the module
         self.classes = {}
+        # JS modules
+        self.js_modules = {}
         # Views defined in the module
         self.views = {}
         # Records (non views) defined in the module
         self.records = {}
         # Modules this module depends on
         self.depends = set()
         # Modules this module imports in python files
@@ -193,15 +198,15 @@
         funcs.append(port_fix_file)
 
         exc = None
         filepath = os.path.join(path, filename)
         for func in funcs:
             try:
                 return func(filepath)
-            except (SyntaxError, TabError) as e:
+            except SyntaxError as e:
                 exc = e
 
         _logger.error(f"Not parsable {filepath}: {exc}")
         raise exc
 
     def _parse_class_def(self, obj: ast.ClassDef, content: str) -> None:
         model = Model.from_ast(obj, content)
@@ -274,15 +279,41 @@
                 )
 
     def _parse_csv(self, path):
         if not os.path.isfile(path):
             self.status.add("missing-file")
             return
 
-    def _parse_xml(self, path):
+    def _parse_js(self, path, pattern):
+        """Parse JavaScript files.
+        `path` .. directory of the module
+        `pattern` .. relative path/glob of the JS files"""
+
+        for file in glob.glob(os.path.join(path, pattern.strip("/")), recursive=True):
+            if not file.endswith(".js"):
+                continue
+
+            module = JSModule.from_file(file, pattern)
+            if not module:
+                return
+
+            self.js_modules[module.name] = module
+
+    def _parse_assets(self, parent_path):
+        for files in self.manifest.get("assets", {}).values():
+            for file in files:
+                # Might be a tuple with include/remove
+                if not isinstance(file, str) and file[0] == "remove":
+                    continue
+                if not isinstance(file, str):
+                    file = file[-1]
+
+                self._parse_js(parent_path, file)
+
+    def _parse_xml(self, path, parent_path=None):
         if not os.path.isfile(path):
             self.status.add("missing-file")
             return
 
         obj = etree.parse(path)
         # Supported special tags defining data
         tags = [
@@ -324,14 +355,18 @@
                     self.records[rec.name] = rec
 
             elif rec.name in self.views:
                 self.views[rec.name].update(rec)
             else:
                 self.views[rec.name] = rec
 
+            for script in obj.xpath("//script/@src"):
+                # this will return string a path,
+                self._parse_js(parent_path, script)
+
     def _parse_text_for_keywords(self, texts):
         if not isinstance(texts, list):
             texts = [texts]
 
         words = stopwords()
         for text in texts:
             tmp = {w.lower() for w in re.findall(r"\b[a-zA-Z]{2,}\b", text)}
@@ -345,14 +380,15 @@
         return {
             "path": self.path,
             "name": self.name,
             "duration": self.duration,
             "manifest": self.manifest,
             "models": {n: m.to_json() for n, m in self.models.items()},
             "classes": {n: c.to_json() for n, c in self.classes.items()},
+            "js_modules": {n: m.to_json() for n, m in self.js_modules.items()},
             "views": {n: v.to_json() for n, v in self.views.items()},
             "records": {n: d.to_json() for n, d in self.records.items()},
             "depends": list(self.depends),
             "imports": list(self.imports),
             "refers": list(self.refers),
             "files": list(self.files),
             "status": list(self.status),
@@ -364,14 +400,17 @@
     @classmethod
     def from_json(cls, data):
         module = cls(data.get("path"))
         module.name = data["name"]
         module.manifest = data["manifest"]
         module.models = {n: Model.from_json(m) for n, m in data["models"].items()}
         module.views = {n: Record.from_json(m) for n, m in data["views"].items()}
+        module.js_modules = {
+            n: JSModule.from_json(m) for n, m in data.get("js_modules", {}).items()
+        }
         module.depends = set(data["depends"])
         module.imports = set(data["imports"])
         module.refers = set(data["refers"])
         module.files = set(data["files"])
         module.status = set(data["status"])
         module.language = data["language"]
         module.words = set(data["words"])
@@ -384,14 +423,15 @@
         classes = data.get("classes", {})
         module.classes = {n: Model.from_json(m) for n, m in classes.items()}
 
         return module
 
     @classmethod
     def from_path(cls, path):
+        parent_path = str(Path(path).parent.absolute())
         files_list = []
         analyse_start = time.time()
         module = cls(path)
         found_init, found_manifest = False, 0
         if not path.endswith("/"):
             path += "/"
 
@@ -423,19 +463,21 @@
                 files_list.append(filepath)
 
         if not found_init:
             return None
 
         module.analyse_language()
 
+        module._parse_assets(parent_path)
+
         for file in module.files:
             file_path = os.path.join(path, file)
             files_list.append(file_path)
             if file.endswith(".xml"):
-                module._parse_xml(file_path)
+                module._parse_xml(file_path, parent_path)
             elif file.endswith(".csv"):
                 module._parse_csv(file_path)
 
         module.analyse_hash(files_list)
 
         _logger.info("Found module %s", module.name)
         if module.status:
```

## odoo_analyse/odoo.py

```diff
@@ -206,14 +206,15 @@
             if mod not in res and mod in self.full:
                 res.add(mod)
                 mods.extend(self.full[mod].depends)
         return res
 
     def interactive(self):
         local_vars = {"analyse": self}
+        # pylint: disable=C0415
         try:
             from IPython import start_ipython
 
             start_ipython(argv=[], user_ns=local_vars)
         except ImportError:
             from code import interact
 
@@ -264,15 +265,15 @@
                 res[name]["missing_dependency"] = sorted(missing)
 
         if out_format == "csv":
             self._analyse_out_csv(res, file_path)
         else:
             self._analyse_out_json(res, file_path)
 
-    def _analyse_out_csv(self, data, file_path):
+    def _analyse_out_csv(self, data, file_path):  # pylint: disable=R0201
         """Output the analyse result as CSV"""
         fields = {"name"}
         rows = []
 
         for name, module in data.items():
             tmp = {"name": name}
             for key, value in module.items():
@@ -283,22 +284,22 @@
                     tmp[key] = ",".join(value)
                 else:
                     tmp[key] = str(value)
 
             fields.update(tmp)
             rows.append(tmp)
 
-        # pylint: disable=R1732
+        # pylint: disable=E0012,R1732
         fp = sys.stdout if file_path == "-" else open(file_path, "w+", encoding="utf-8")
         writer = csv.DictWriter(fp, sorted(fields))
         writer.writeheader()
         for row in rows:
             writer.writerow(row)
 
-    def _analyse_out_json(self, data, file_path):
+    def _analyse_out_json(self, data, file_path):  # pylint: disable=R0201
         """Output the analyse result as JSON"""
         # Write to a file or stdout
         if file_path == "-":
             json.dump(data, sys.stdout, indent=2)
         else:
             with open(file_path, "w+", encoding="utf-8") as fp:
                 json.dump(data, fp, indent=2)
@@ -326,15 +327,15 @@
         data = {k: m.to_json() for k, m in self.full.items()}
         if filename == "-":
             json.dump(data, sys.stdout)
         else:
             with open(filename, "w+", encoding="utf-8") as fp:
                 json.dump(data, fp)
 
-    def _find_edges_in_loop(self, graph):
+    def _find_edges_in_loop(self, graph):  # pylint: disable=R0201
         # Eliminate not referenced and not referring modules
         while True:
             before = len(graph)
 
             tmp = {k: v.intersection(graph) for k, v in graph.items()}
             deps = reduce(lambda a, b: a.union(b), tmp.values(), set())
             graph = {k: v for k, v in tmp.items() if v and k in deps}
@@ -420,15 +421,15 @@
                 if callable(color_edge):
                     output.edge(name, dep, color=color_edge(name, dep))
                 else:
                     output.edge(name, dep)
 
         self._show_output(output, filename=filename)
 
-    def _show_output(self, graph, filename):
+    def _show_output(self, graph, filename):  # pylint: disable=R0201
         graph.render(filename=filename)
 
     def show_structure_graph(
         self, modules="*", models="*", views="*", fields=True, filename=None
     ):
         module_color = self.opt("structure.module_color")
         module_shape = self.opt("structure.module_shape", "doubleoctagon")
@@ -439,31 +440,31 @@
         field_color = self.opt("structure.field_color")
         field_shape = self.opt("structure.field_shape", "octagon")
 
         output = Graph()
 
         def render_field(model_id, model):
             for field_name in model.fields:
-                field_id = "%s/%s" % (model_id, field_name)
+                field_id = f"{model_id}/{field_name}"
                 output.node(
                     field_id, label=field_name, color=field_color, shape=field_shape
                 )
                 output.edge(model_id, field_id)
 
         def render_model(module_id, model_name, model):
-            model_id = "%s/%s" % (module_id, model_name)
+            model_id = f"{module_id}{model_name}"
             output.node(
                 model_id, label=model_name, color=model_color, shape=model_shape
             )
             output.edge(module_id, model_id)
 
             if fields:
                 render_field(model_id, model)
 
-        def render_view(module_id, view_name, view):
+        def render_view(module_id, view_name, _view):
             view_id = f"{module_id}/{view_name}"
             output.node(view_id, label=view_name, color=view_color, shape=view_shape)
             output.edge(module_id, view_id)
 
         for module_name, module in self.items():
             if not match(module_name, modules):
                 continue
```

## odoo_analyse/utils.py

```diff
@@ -1,17 +1,19 @@
 # © 2019 initOS GmbH
 # License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl.html)
 
 import ast
 import hashlib
+import json
 import logging
 import os
-import re
 import shutil
 import subprocess
+from functools import reduce
+from json.decoder import JSONDecodeError
 
 _logger = logging.getLogger(__name__)
 
 
 def call(cmd, cwd=None):
     with subprocess.Popen(
         cmd,
@@ -107,27 +109,34 @@
 def analyse_language(path):
     """Analyse the languages of a directory"""
     cmd = shutil.which("cloc")
     if cmd is None:
         _logger.warning("Language analyse needs cloc")
         return {}
 
-    output, error = call([cmd, path])
+    output, error = call([cmd, path, "--json"])
     if error:
+        _logger.warning(error)
+
+    try:
+        output = json.loads(output)
+    except ValueError as err:
+        _logger.warning(err)
         return {}
 
-    result = {}
-    reg = re.compile(r"([^:]*?)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)")
     total_code = 0
-    for line in output.splitlines():
-        match = reg.match(line)
-        if match:
-            lang, _, _, _, code = match.groups()
-            total_code += int(code)
-            result[lang] = {"lines": int(code), "fraction_from_total": 0}
+    result = {}
+    for key, val in output.items():
+        if "code" not in val:
+            # skipping 'header' and anyother non-lang keys
+            continue
+
+        code = int(val["code"])
+        total_code += code
+        result[key] = {"lines": code, "fraction_from_total": 0}
 
     for value in result.values():
         value["fraction_from_total"] = value["lines"] / total_code
 
     return result
 
 
@@ -145,7 +154,30 @@
     if end == start:
         return lines[start].encode()[start_offset:end_offset].decode()
 
     segment = [lines[start].encode()[start_offset:].decode()]
     segment.extend(lines[start + 1 : end])
     segment.append(lines[end].encode()[:end_offset].decode())
     return "".join(segment)
+
+
+def eslint_complexity(js_file):
+    """Return the JS complexity using eslintcc"""
+    cmd = shutil.which("eslintcc")
+    if not cmd:
+        _logger.warning(f"eslintcc not found. Skipping complexity for js {js_file}")
+        return None
+
+    output, _ = call([cmd, "-a", "-f=json", js_file])
+    try:
+        output = json.loads(output)
+    except JSONDecodeError:
+        return None
+    return output["average"]["rank"]
+
+
+def geometric_mean(data):
+    data = list(filter(None, data))
+    if not data:
+        return 0
+
+    return pow(reduce(lambda x, y: x * y, data), 1 / len(data))
```

## Comparing `odoo_analyse-1.3.0.dist-info/LICENSE` & `odoo_analyse-1.5.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `odoo_analyse-1.3.0.dist-info/METADATA` & `odoo_analyse-1.5.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,43 +1,44 @@
 Metadata-Version: 2.1
 Name: odoo-analyse
-Version: 1.3.0
+Version: 1.5.0
 Summary: Package to analyse odoo modules
 Home-page: https://github.com/initOS/odoo-analyse
 Author: initOS GmbH
 Author-email: info@initos.com
 License: LGPL-3.0
 Project-URL: Documentation, https://github.com/initOS/odoo-analyse/blob/master/README.md
 Project-URL: Usage, https://odoo-code-search.com
-Keywords: odoo,modules,analyze,dependency,graph
-Platform: UNKNOWN
+Keywords: odoo modules analyze dependency graph
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
 Classifier: Topic :: Software Development
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: 2to3
 Requires-Dist: cloc
 Requires-Dist: lxml
 Requires-Dist: mccabe
+Requires-Dist: radon
 Provides-Extra: graph
 Requires-Dist: graphviz ; extra == 'graph'
 Requires-Dist: psycopg2 ; extra == 'graph'
 
 # odoo-analyse
 
 Analyse tool for odoo modules
 
 ## Installation
 
 Install the module with the ability to render graphs:
-```
-$ apt install cloc graphviz
-$ pip3 install "odoo-analyse[graph]"
+```bash
+apt install cloc graphviz
+npm install -g eslintcc  # required for JS complexity
+pip3 install "odoo-analyse[graph]"
 ```
 
 ## Usage
 
 ```odoo_analyse --help```
 
 ### Read in modules
@@ -134,9 +135,7 @@
 
 # Create the full dependency graph of all modules starting with `sale_`
 $ odoo_analyse -l /path/to/cache.json --modules 'sale_*' --show-dependency --full-graph
 
 # Connect to the database from the odoo.cfg and create the dependency graph of all installed modules
 $ odoo_analyse -l /path/to/cache.json -c /path/to/odoo.cfg --state-filter installed --show-dependency
 ```
-
-
```

