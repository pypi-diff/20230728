# Comparing `tmp/harbor_api_client-2.7.5.tar.gz` & `tmp/harbor_api_client-2.7.6.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "harbor_api_client-2.7.5.tar", max compression
+gzip compressed data, was "harbor_api_client-2.7.6.tar", max compression
```

## Comparing `harbor_api_client-2.7.5.tar` & `harbor_api_client-2.7.6.tar`

### file list

```diff
@@ -1,234 +1,234 @@
--rw-r--r--   0        0        0    11347 2023-01-30 02:22:10.791710 harbor_api_client-2.7.5/LICENSE
--rw-r--r--   0        0        0    39668 2023-01-30 02:22:10.791710 harbor_api_client-2.7.5/README.md
--rw-r--r--   0        0        0      968 2023-04-06 02:47:58.616525 harbor_api_client-2.7.5/pyproject.toml
--rw-r--r--   0        0        0    12116 2023-01-30 02:22:10.848376 harbor_api_client-2.7.5/src/harbor_client/__init__.py
--rw-r--r--   0        0        0     2098 2023-01-30 02:22:10.848376 harbor_api_client-2.7.5/src/harbor_client/api/__init__.py
--rw-r--r--   0        0        0    96251 2023-01-30 02:22:10.848376 harbor_api_client-2.7.5/src/harbor_client/api/artifact_api.py
--rw-r--r--   0        0        0     7111 2023-01-30 02:22:10.848376 harbor_api_client-2.7.5/src/harbor_client/api/auditlog_api.py
--rw-r--r--   0        0        0    13831 2023-01-30 02:22:10.848376 harbor_api_client-2.7.5/src/harbor_client/api/configure_api.py
--rw-r--r--   0        0        0    33211 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/gc_api.py
--rw-r--r--   0        0        0     4641 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/health_api.py
--rw-r--r--   0        0        0     5501 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/icon_api.py
--rw-r--r--   0        0        0    28213 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/immutable_api.py
--rw-r--r--   0        0        0    22842 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/jobservice_api.py
--rw-r--r--   0        0        0    26360 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/label_api.py
--rw-r--r--   0        0        0    19461 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/ldap_api.py
--rw-r--r--   0        0        0    32309 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/member_api.py
--rw-r--r--   0        0        0     5427 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/oidc_api.py
--rw-r--r--   0        0        0     4751 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/ping_api.py
--rw-r--r--   0        0        0   111031 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/preheat_api.py
--rw-r--r--   0        0        0    73546 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/project_api.py
--rw-r--r--   0        0        0    31323 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/project_metadata_api.py
--rw-r--r--   0        0        0    35279 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/purge_api.py
--rw-r--r--   0        0        0    15653 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/quota_api.py
--rw-r--r--   0        0        0    42272 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/registry_api.py
--rw-r--r--   0        0        0    57429 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/replication_api.py
--rw-r--r--   0        0        0    31313 2023-01-30 02:22:10.851709 harbor_api_client-2.7.5/src/harbor_client/api/repository_api.py
--rw-r--r--   0        0        0    51748 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/retention_api.py
--rw-r--r--   0        0        0    30725 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/robot_api.py
--rw-r--r--   0        0        0    33911 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/robotv1_api.py
--rw-r--r--   0        0        0    26559 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/scan_all_api.py
--rw-r--r--   0        0        0    20426 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/scan_api.py
--rw-r--r--   0        0        0    20254 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/scan_data_export_api.py
--rw-r--r--   0        0        0    41656 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/scanner_api.py
--rw-r--r--   0        0        0     9998 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/schedule_api.py
--rw-r--r--   0        0        0     5610 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/search_api.py
--rw-r--r--   0        0        0     4754 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/statistic_api.py
--rw-r--r--   0        0        0     9270 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/system_cve_allowlist_api.py
--rw-r--r--   0        0        0    12941 2023-01-30 02:22:10.855042 harbor_api_client-2.7.5/src/harbor_client/api/systeminfo_api.py
--rw-r--r--   0        0        0    55612 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/api/user_api.py
--rw-r--r--   0        0        0    29080 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/api/usergroup_api.py
--rw-r--r--   0        0        0    47105 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/api/webhook_api.py
--rw-r--r--   0        0        0     9594 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/api/webhookjob_api.py
--rw-r--r--   0        0        0    25052 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/api_client.py
--rw-r--r--   0        0        0     8131 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/configuration.py
--rw-r--r--   0        0        0     1950 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/__init__.py
--rw-r--r--   0        0        0    96251 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/artifact_api.py
--rw-r--r--   0        0        0     7111 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/auditlog_api.py
--rw-r--r--   0        0        0    13831 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/configure_api.py
--rw-r--r--   0        0        0    33211 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/gc_api.py
--rw-r--r--   0        0        0     4641 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/health_api.py
--rw-r--r--   0        0        0     5501 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/icon_api.py
--rw-r--r--   0        0        0    28213 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/immutable_api.py
--rw-r--r--   0        0        0    22842 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/jobservice_api.py
--rw-r--r--   0        0        0    26360 2023-01-30 02:22:10.858376 harbor_api_client-2.7.5/src/harbor_client/harbor_client/label_api.py
--rw-r--r--   0        0        0    19461 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/ldap_api.py
--rw-r--r--   0        0        0    32309 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/member_api.py
--rw-r--r--   0        0        0     5427 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/oidc_api.py
--rw-r--r--   0        0        0     4751 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/ping_api.py
--rw-r--r--   0        0        0   111031 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/preheat_api.py
--rw-r--r--   0        0        0    73546 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/project_api.py
--rw-r--r--   0        0        0    31323 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/project_metadata_api.py
--rw-r--r--   0        0        0    35279 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/purge_api.py
--rw-r--r--   0        0        0    15653 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/quota_api.py
--rw-r--r--   0        0        0    42272 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/registry_api.py
--rw-r--r--   0        0        0    57429 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/replication_api.py
--rw-r--r--   0        0        0    31313 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/repository_api.py
--rw-r--r--   0        0        0    51748 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/retention_api.py
--rw-r--r--   0        0        0    30725 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/robot_api.py
--rw-r--r--   0        0        0    33911 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/robotv1_api.py
--rw-r--r--   0        0        0    26559 2023-01-30 02:22:10.861709 harbor_api_client-2.7.5/src/harbor_client/harbor_client/scan_all_api.py
--rw-r--r--   0        0        0    20426 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/scan_api.py
--rw-r--r--   0        0        0    20254 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/scan_data_export_api.py
--rw-r--r--   0        0        0    41656 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/scanner_api.py
--rw-r--r--   0        0        0     9998 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/schedule_api.py
--rw-r--r--   0        0        0     5610 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/search_api.py
--rw-r--r--   0        0        0     4754 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/statistic_api.py
--rw-r--r--   0        0        0     9270 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/system_cve_allowlist_api.py
--rw-r--r--   0        0        0    12941 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/systeminfo_api.py
--rw-r--r--   0        0        0    55612 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/user_api.py
--rw-r--r--   0        0        0    29080 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/usergroup_api.py
--rw-r--r--   0        0        0    47105 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/webhook_api.py
--rw-r--r--   0        0        0     9594 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/harbor_client/webhookjob_api.py
--rw-r--r--   0        0        0     9954 2023-01-30 02:22:10.865042 harbor_api_client-2.7.5/src/harbor_client/models/__init__.py
--rw-r--r--   0        0        0     4767 2023-01-30 02:22:10.868376 harbor_api_client-2.7.5/src/harbor_client/models/access.py
--rw-r--r--   0        0        0     8716 2023-01-30 02:22:10.871709 harbor_api_client-2.7.5/src/harbor_client/models/accessory.py
--rw-r--r--   0        0        0     3830 2023-01-30 02:22:10.878375 harbor_api_client-2.7.5/src/harbor_client/models/action_request.py
--rw-r--r--   0        0        0     4173 2023-01-30 02:22:10.878375 harbor_api_client-2.7.5/src/harbor_client/models/addition_link.py
--rw-r--r--   0        0        0     2697 2023-01-30 02:22:10.878375 harbor_api_client-2.7.5/src/harbor_client/models/addition_links.py
--rw-r--r--   0        0        0     2687 2023-01-30 02:22:10.878375 harbor_api_client-2.7.5/src/harbor_client/models/annotations.py
--rw-r--r--   0        0        0    16831 2023-01-30 02:22:10.881709 harbor_api_client-2.7.5/src/harbor_client/models/artifact.py
--rw-r--r--   0        0        0     7283 2023-01-30 02:22:10.881709 harbor_api_client-2.7.5/src/harbor_client/models/audit_log.py
--rw-r--r--   0        0        0     7789 2023-01-30 02:22:10.881709 harbor_api_client-2.7.5/src/harbor_client/models/authproxy_setting.py
--rw-r--r--   0        0        0     3260 2023-01-30 02:22:10.881709 harbor_api_client-2.7.5/src/harbor_client/models/body.py
--rw-r--r--   0        0        0     3246 2023-01-30 02:22:10.881709 harbor_api_client-2.7.5/src/harbor_client/models/body1.py
--rw-r--r--   0        0        0     4230 2023-01-30 02:22:10.881709 harbor_api_client-2.7.5/src/harbor_client/models/bool_config_item.py
--rw-r--r--   0        0        0    11908 2023-01-30 02:22:10.885042 harbor_api_client-2.7.5/src/harbor_client/models/chart_metadata.py
--rw-r--r--   0        0        0     6372 2023-01-30 02:22:10.885042 harbor_api_client-2.7.5/src/harbor_client/models/chart_version.py
--rw-r--r--   0        0        0     4992 2023-01-30 02:22:10.885042 harbor_api_client-2.7.5/src/harbor_client/models/component_health_status.py
--rw-r--r--   0        0        0    54274 2023-01-30 02:22:10.885042 harbor_api_client-2.7.5/src/harbor_client/models/configurations.py
--rw-r--r--   0        0        0    56684 2023-01-30 02:22:10.888375 harbor_api_client-2.7.5/src/harbor_client/models/configurations_response.py
--rw-r--r--   0        0        0     4578 2023-01-30 02:22:10.888375 harbor_api_client-2.7.5/src/harbor_client/models/configurations_response_scan_all_policy.py
--rw-r--r--   0        0        0     3891 2023-01-30 02:22:10.888375 harbor_api_client-2.7.5/src/harbor_client/models/configurations_response_scan_all_policy_parameter.py
--rw-r--r--   0        0        0     7707 2023-01-30 02:22:10.888375 harbor_api_client-2.7.5/src/harbor_client/models/cve_allowlist.py
--rw-r--r--   0        0        0     3481 2023-01-30 02:22:10.888375 harbor_api_client-2.7.5/src/harbor_client/models/cve_allowlist_item.py
--rw-r--r--   0        0        0     4169 2023-01-30 02:22:10.888375 harbor_api_client-2.7.5/src/harbor_client/models/endpoint.py
--rw-r--r--   0        0        0     3969 2023-01-30 02:22:10.888375 harbor_api_client-2.7.5/src/harbor_client/models/error.py
--rw-r--r--   0        0        0     3279 2023-01-30 02:22:10.891708 harbor_api_client-2.7.5/src/harbor_client/models/errors.py
--rw-r--r--   0        0        0     2677 2023-01-30 02:22:10.891708 harbor_api_client-2.7.5/src/harbor_client/models/event_type.py
--rw-r--r--   0        0        0     9595 2023-01-30 02:22:10.891708 harbor_api_client-2.7.5/src/harbor_client/models/exec_history.py
--rw-r--r--   0        0        0    10034 2023-01-30 02:22:10.891708 harbor_api_client-2.7.5/src/harbor_client/models/execution.py
--rw-r--r--   0        0        0     2682 2023-01-30 02:22:10.891708 harbor_api_client-2.7.5/src/harbor_client/models/extra_attrs.py
--rw-r--r--   0        0        0     4718 2023-01-30 02:22:10.891708 harbor_api_client-2.7.5/src/harbor_client/models/filter_style.py
--rw-r--r--   0        0        0     9465 2023-01-30 02:22:10.895042 harbor_api_client-2.7.5/src/harbor_client/models/gc_history.py
--rw-r--r--   0        0        0    16333 2023-01-30 02:22:10.895042 harbor_api_client-2.7.5/src/harbor_client/models/general_info.py
--rw-r--r--   0        0        0     4186 2023-01-30 02:22:10.895042 harbor_api_client-2.7.5/src/harbor_client/models/icon.py
--rw-r--r--   0        0        0     8223 2023-01-30 02:22:10.895042 harbor_api_client-2.7.5/src/harbor_client/models/immutable_rule.py
--rw-r--r--   0        0        0     5325 2023-01-30 02:22:10.895042 harbor_api_client-2.7.5/src/harbor_client/models/immutable_selector.py
--rw-r--r--   0        0        0    11610 2023-01-30 02:22:10.898375 harbor_api_client-2.7.5/src/harbor_client/models/instance.py
--rw-r--r--   0        0        0     4266 2023-01-30 02:22:10.898375 harbor_api_client-2.7.5/src/harbor_client/models/integer_config_item.py
--rw-r--r--   0        0        0     4376 2023-01-30 02:22:10.898375 harbor_api_client-2.7.5/src/harbor_client/models/internal_configuration_value.py
--rw-r--r--   0        0        0     2782 2023-01-30 02:22:10.898375 harbor_api_client-2.7.5/src/harbor_client/models/internal_configurations_response.py
--rw-r--r--   0        0        0     3531 2023-01-30 02:22:10.898375 harbor_api_client-2.7.5/src/harbor_client/models/is_default.py
--rw-r--r--   0        0        0     5559 2023-01-30 02:22:10.898375 harbor_api_client-2.7.5/src/harbor_client/models/job_queue.py
--rw-r--r--   0        0        0     8423 2023-01-30 02:22:10.898375 harbor_api_client-2.7.5/src/harbor_client/models/label.py
--rw-r--r--   0        0        0    10466 2023-01-30 02:22:10.901708 harbor_api_client-2.7.5/src/harbor_client/models/ldap_conf.py
--rw-r--r--   0        0        0     4122 2023-01-30 02:22:10.901708 harbor_api_client-2.7.5/src/harbor_client/models/ldap_failed_import_user.py
--rw-r--r--   0        0        0     3574 2023-01-30 02:22:10.901708 harbor_api_client-2.7.5/src/harbor_client/models/ldap_import_users.py
--rw-r--r--   0        0        0     4179 2023-01-30 02:22:10.901708 harbor_api_client-2.7.5/src/harbor_client/models/ldap_ping_result.py
--rw-r--r--   0        0        0     4923 2023-01-30 02:22:10.901708 harbor_api_client-2.7.5/src/harbor_client/models/ldap_user.py
--rw-r--r--   0        0        0     6600 2023-01-30 02:22:10.901708 harbor_api_client-2.7.5/src/harbor_client/models/metadata.py
--rw-r--r--   0        0        0     9022 2023-01-30 02:22:10.901708 harbor_api_client-2.7.5/src/harbor_client/models/metrics.py
--rw-r--r--   0        0        0    10177 2023-01-30 02:22:10.905042 harbor_api_client-2.7.5/src/harbor_client/models/native_report_summary.py
--rw-r--r--   0        0        0     2682 2023-01-30 02:22:10.905042 harbor_api_client-2.7.5/src/harbor_client/models/notify_type.py
--rw-r--r--   0        0        0     3419 2023-01-30 02:22:10.905042 harbor_api_client-2.7.5/src/harbor_client/models/oidc_cli_secret_req.py
--rw-r--r--   0        0        0     7412 2023-01-30 02:22:10.905042 harbor_api_client-2.7.5/src/harbor_client/models/oidc_user_info.py
--rw-r--r--   0        0        0     4409 2023-01-30 02:22:10.905042 harbor_api_client-2.7.5/src/harbor_client/models/overall_health_status.py
--rw-r--r--   0        0        0     4387 2023-01-30 02:22:10.905042 harbor_api_client-2.7.5/src/harbor_client/models/password_req.py
--rw-r--r--   0        0        0     4120 2023-01-30 02:22:10.905042 harbor_api_client-2.7.5/src/harbor_client/models/permission.py
--rw-r--r--   0        0        0     6583 2023-01-30 02:22:10.905042 harbor_api_client-2.7.5/src/harbor_client/models/platform.py
--rw-r--r--   0        0        0    11349 2023-01-30 02:22:10.905042 harbor_api_client-2.7.5/src/harbor_client/models/preheat_policy.py
--rw-r--r--   0        0        0    15479 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/project.py
--rw-r--r--   0        0        0     4333 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/project_deletable.py
--rw-r--r--   0        0        0     5041 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/project_member.py
--rw-r--r--   0        0        0     8506 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/project_member_entity.py
--rw-r--r--   0        0        0    11509 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/project_metadata.py
--rw-r--r--   0        0        0     7953 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/project_req.py
--rw-r--r--   0        0        0     3547 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/project_scanner.py
--rw-r--r--   0        0        0    10494 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/project_summary.py
--rw-r--r--   0        0        0     4195 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/project_summary_quota.py
--rw-r--r--   0        0        0     5334 2023-01-30 02:22:10.908375 harbor_api_client-2.7.5/src/harbor_client/models/provider_under_project.py
--rw-r--r--   0        0        0     6928 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/quota.py
--rw-r--r--   0        0        0     2702 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/quota_ref_object.py
--rw-r--r--   0        0        0     3426 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/quota_update_req.py
--rw-r--r--   0        0        0     7084 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/reference.py
--rw-r--r--   0        0        0    10012 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/registry.py
--rw-r--r--   0        0        0     5287 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/registry_credential.py
--rw-r--r--   0        0        0     4058 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/registry_endpoint.py
--rw-r--r--   0        0        0     7414 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/registry_info.py
--rw-r--r--   0        0        0     8102 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/registry_ping.py
--rw-r--r--   0        0        0     6789 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/registry_provider_credential_pattern.py
--rw-r--r--   0        0        0     4590 2023-01-30 02:22:10.911708 harbor_api_client-2.7.5/src/harbor_client/models/registry_provider_endpoint_pattern.py
--rw-r--r--   0        0        0     4820 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/registry_provider_info.py
--rw-r--r--   0        0        0     8336 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/registry_update.py
--rw-r--r--   0        0        0    12076 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/replication_execution.py
--rw-r--r--   0        0        0     5003 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/replication_filter.py
--rw-r--r--   0        0        0    17398 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/replication_policy.py
--rw-r--r--   0        0        0    10791 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/replication_task.py
--rw-r--r--   0        0        0     4463 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/replication_trigger.py
--rw-r--r--   0        0        0     3515 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/replication_trigger_settings.py
--rw-r--r--   0        0        0     9106 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/repository.py
--rw-r--r--   0        0        0     2692 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/resource_list.py
--rw-r--r--   0        0        0     7352 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/retention_execution.py
--rw-r--r--   0        0        0    10509 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/retention_execution_task.py
--rw-r--r--   0        0        0     5500 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/retention_metadata.py
--rw-r--r--   0        0        0     5962 2023-01-30 02:22:10.915042 harbor_api_client-2.7.5/src/harbor_client/models/retention_policy.py
--rw-r--r--   0        0        0     3950 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/retention_policy_scope.py
--rw-r--r--   0        0        0     8223 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/retention_rule.py
--rw-r--r--   0        0        0     5972 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/retention_rule_metadata.py
--rw-r--r--   0        0        0     4744 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/retention_rule_param_metadata.py
--rw-r--r--   0        0        0     4777 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/retention_rule_trigger.py
--rw-r--r--   0        0        0     5325 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/retention_selector.py
--rw-r--r--   0        0        0     4962 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/retention_selector_metadata.py
--rw-r--r--   0        0        0    11437 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/robot.py
--rw-r--r--   0        0        0     7861 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/robot_create.py
--rw-r--r--   0        0        0     5872 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/robot_create_v1.py
--rw-r--r--   0        0        0     6370 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/robot_created.py
--rw-r--r--   0        0        0     4847 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/robot_permission.py
--rw-r--r--   0        0        0     3365 2023-01-30 02:22:10.918375 harbor_api_client-2.7.5/src/harbor_client/models/robot_sec.py
--rw-r--r--   0        0        0     3522 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/role_request.py
--rw-r--r--   0        0        0    10003 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scan_data_export_execution.py
--rw-r--r--   0        0        0     3626 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scan_data_export_execution_list.py
--rw-r--r--   0        0        0     3388 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scan_data_export_job.py
--rw-r--r--   0        0        0     8324 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scan_data_export_request.py
--rw-r--r--   0        0        0     2692 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scan_overview.py
--rw-r--r--   0        0        0     4730 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scanner.py
--rw-r--r--   0        0        0     5038 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scanner_adapter_metadata.py
--rw-r--r--   0        0        0     4547 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scanner_capability.py
--rw-r--r--   0        0        0    16738 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scanner_registration.py
--rw-r--r--   0        0        0    10428 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scanner_registration_req.py
--rw-r--r--   0        0        0     6648 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/scanner_registration_settings.py
--rw-r--r--   0        0        0     7176 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/schedule.py
--rw-r--r--   0        0        0     5769 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/schedule_obj.py
--rw-r--r--   0        0        0     6516 2023-01-30 02:22:10.921708 harbor_api_client-2.7.5/src/harbor_client/models/schedule_task.py
--rw-r--r--   0        0        0     3437 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/scheduler_status.py
--rw-r--r--   0        0        0     5179 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/search.py
--rw-r--r--   0        0        0     8219 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/search_repository.py
--rw-r--r--   0        0        0     4674 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/search_result.py
--rw-r--r--   0        0        0     3626 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/start_replication_execution.py
--rw-r--r--   0        0        0     9802 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/statistic.py
--rw-r--r--   0        0        0     6825 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/stats.py
--rw-r--r--   0        0        0     3963 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/storage.py
--rw-r--r--   0        0        0     4251 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/string_config_item.py
--rw-r--r--   0        0        0     4363 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/supported_webhook_event_types.py
--rw-r--r--   0        0        0     3431 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/system_info.py
--rw-r--r--   0        0        0     8545 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/tag.py
--rw-r--r--   0        0        0    10043 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/task.py
--rw-r--r--   0        0        0     6445 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/user_creation_req.py
--rw-r--r--   0        0        0     4132 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/user_entity.py
--rw-r--r--   0        0        0     5853 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/user_group.py
--rw-r--r--   0        0        0     5118 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/user_group_search_item.py
--rw-r--r--   0        0        0     4566 2023-01-30 02:22:10.925041 harbor_api_client-2.7.5/src/harbor_client/models/user_profile.py
--rw-r--r--   0        0        0    10107 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/user_resp.py
--rw-r--r--   0        0        0     4044 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/user_search.py
--rw-r--r--   0        0        0     4148 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/user_search_resp_item.py
--rw-r--r--   0        0        0     3590 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/user_sys_admin_flag.py
--rw-r--r--   0        0        0     5150 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/vulnerability_summary.py
--rw-r--r--   0        0        0     8860 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/webhook_job.py
--rw-r--r--   0        0        0     7080 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/webhook_last_trigger.py
--rw-r--r--   0        0        0    10394 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/webhook_policy.py
--rw-r--r--   0        0        0     6008 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/webhook_target_object.py
--rw-r--r--   0        0        0     7759 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/worker.py
--rw-r--r--   0        0        0     7314 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/models/worker_pool.py
--rw-r--r--   0        0        0    13155 2023-01-30 02:22:10.928375 harbor_api_client-2.7.5/src/harbor_client/rest.py
--rw-r--r--   0        0        0    40897 1970-01-01 00:00:00.000000 harbor_api_client-2.7.5/PKG-INFO
+-rw-r--r--   0        0        0    11347 2023-01-30 06:03:39.450241 harbor_api_client-2.7.6/LICENSE
+-rw-r--r--   0        0        0    39668 2023-01-30 06:03:39.450241 harbor_api_client-2.7.6/README.md
+-rw-r--r--   0        0        0     1110 2023-07-28 03:11:54.849125 harbor_api_client-2.7.6/pyproject.toml
+-rw-r--r--   0        0        0    12144 2023-07-28 03:11:29.701413 harbor_api_client-2.7.6/src/harbor_client/__init__.py
+-rw-r--r--   0        0        0     2098 2023-01-30 06:03:39.506907 harbor_api_client-2.7.6/src/harbor_client/api/__init__.py
+-rw-r--r--   0        0        0    98683 2023-07-28 03:11:29.704746 harbor_api_client-2.7.6/src/harbor_client/api/artifact_api.py
+-rw-r--r--   0        0        0     7180 2023-07-28 03:11:29.704746 harbor_api_client-2.7.6/src/harbor_client/api/auditlog_api.py
+-rw-r--r--   0        0        0    13929 2023-07-28 03:11:29.704746 harbor_api_client-2.7.6/src/harbor_client/api/configure_api.py
+-rw-r--r--   0        0        0    33307 2023-07-28 03:11:29.708079 harbor_api_client-2.7.6/src/harbor_client/api/gc_api.py
+-rw-r--r--   0        0        0     4658 2023-07-28 03:11:29.708079 harbor_api_client-2.7.6/src/harbor_client/api/health_api.py
+-rw-r--r--   0        0        0     5515 2023-07-28 03:11:29.708079 harbor_api_client-2.7.6/src/harbor_client/api/icon_api.py
+-rw-r--r--   0        0        0    28829 2023-07-28 03:11:29.708079 harbor_api_client-2.7.6/src/harbor_client/api/immutable_api.py
+-rw-r--r--   0        0        0    22975 2023-07-28 03:11:29.708079 harbor_api_client-2.7.6/src/harbor_client/api/jobservice_api.py
+-rw-r--r--   0        0        0    26589 2023-07-28 03:11:29.708079 harbor_api_client-2.7.6/src/harbor_client/api/label_api.py
+-rw-r--r--   0        0        0    19526 2023-07-28 03:11:29.711413 harbor_api_client-2.7.6/src/harbor_client/api/ldap_api.py
+-rw-r--r--   0        0        0    33133 2023-07-28 03:11:29.711413 harbor_api_client-2.7.6/src/harbor_client/api/member_api.py
+-rw-r--r--   0        0        0     5441 2023-07-28 03:11:29.714746 harbor_api_client-2.7.6/src/harbor_client/api/oidc_api.py
+-rw-r--r--   0        0        0     4746 2023-07-28 03:11:29.714746 harbor_api_client-2.7.6/src/harbor_client/api/ping_api.py
+-rw-r--r--   0        0        0   112826 2023-07-28 03:11:29.714746 harbor_api_client-2.7.6/src/harbor_client/api/preheat_api.py
+-rw-r--r--   0        0        0    74780 2023-07-28 03:11:29.718079 harbor_api_client-2.7.6/src/harbor_client/api/project_api.py
+-rw-r--r--   0        0        0    32074 2023-07-28 03:11:29.718079 harbor_api_client-2.7.6/src/harbor_client/api/project_metadata_api.py
+-rw-r--r--   0        0        0    35453 2023-07-28 03:11:29.718079 harbor_api_client-2.7.6/src/harbor_client/api/purge_api.py
+-rw-r--r--   0        0        0    15828 2023-07-28 03:11:29.718079 harbor_api_client-2.7.6/src/harbor_client/api/quota_api.py
+-rw-r--r--   0        0        0    42496 2023-07-28 03:11:29.721412 harbor_api_client-2.7.6/src/harbor_client/api/registry_api.py
+-rw-r--r--   0        0        0    58097 2023-07-28 03:11:29.721412 harbor_api_client-2.7.6/src/harbor_client/api/replication_api.py
+-rw-r--r--   0        0        0    31789 2023-07-28 03:11:29.721412 harbor_api_client-2.7.6/src/harbor_client/api/repository_api.py
+-rw-r--r--   0        0        0    52066 2023-07-28 03:11:29.724745 harbor_api_client-2.7.6/src/harbor_client/api/retention_api.py
+-rw-r--r--   0        0        0    30858 2023-07-28 03:11:29.724745 harbor_api_client-2.7.6/src/harbor_client/api/robot_api.py
+-rw-r--r--   0        0        0    34629 2023-07-28 03:11:29.724745 harbor_api_client-2.7.6/src/harbor_client/api/robotv1_api.py
+-rw-r--r--   0        0        0    26785 2023-07-28 03:11:29.724745 harbor_api_client-2.7.6/src/harbor_client/api/scan_all_api.py
+-rw-r--r--   0        0        0    20732 2023-07-28 03:11:29.724745 harbor_api_client-2.7.6/src/harbor_client/api/scan_api.py
+-rw-r--r--   0        0        0    20448 2023-07-28 03:11:29.728079 harbor_api_client-2.7.6/src/harbor_client/api/scan_data_export_api.py
+-rw-r--r--   0        0        0    42021 2023-07-28 03:11:29.758077 harbor_api_client-2.7.6/src/harbor_client/api/scanner_api.py
+-rw-r--r--   0        0        0    10081 2023-07-28 03:11:29.761411 harbor_api_client-2.7.6/src/harbor_client/api/schedule_api.py
+-rw-r--r--   0        0        0     5586 2023-07-28 03:11:29.761411 harbor_api_client-2.7.6/src/harbor_client/api/search_api.py
+-rw-r--r--   0        0        0     4771 2023-07-28 03:11:29.761411 harbor_api_client-2.7.6/src/harbor_client/api/statistic_api.py
+-rw-r--r--   0        0        0     9344 2023-07-28 03:11:29.761411 harbor_api_client-2.7.6/src/harbor_client/api/system_cve_allowlist_api.py
+-rw-r--r--   0        0        0    12992 2023-07-28 03:11:29.761411 harbor_api_client-2.7.6/src/harbor_client/api/systeminfo_api.py
+-rw-r--r--   0        0        0    56075 2023-07-28 03:11:29.764744 harbor_api_client-2.7.6/src/harbor_client/api/user_api.py
+-rw-r--r--   0        0        0    29345 2023-07-28 03:11:29.764744 harbor_api_client-2.7.6/src/harbor_client/api/usergroup_api.py
+-rw-r--r--   0        0        0    48175 2023-07-28 03:11:29.768077 harbor_api_client-2.7.6/src/harbor_client/api/webhook_api.py
+-rw-r--r--   0        0        0     9850 2023-07-28 03:11:29.768077 harbor_api_client-2.7.6/src/harbor_client/api/webhookjob_api.py
+-rw-r--r--   0        0        0    24045 2023-07-28 03:11:29.768077 harbor_api_client-2.7.6/src/harbor_client/api_client.py
+-rw-r--r--   0        0        0     8086 2023-07-28 03:11:29.768077 harbor_api_client-2.7.6/src/harbor_client/configuration.py
+-rw-r--r--   0        0        0     1950 2023-01-30 06:03:39.523573 harbor_api_client-2.7.6/src/harbor_client/harbor_client/__init__.py
+-rw-r--r--   0        0        0    98683 2023-07-28 03:11:29.768077 harbor_api_client-2.7.6/src/harbor_client/harbor_client/artifact_api.py
+-rw-r--r--   0        0        0     7180 2023-07-28 03:11:29.771410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/auditlog_api.py
+-rw-r--r--   0        0        0    13929 2023-07-28 03:11:29.771410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/configure_api.py
+-rw-r--r--   0        0        0    33307 2023-07-28 03:11:29.771410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/gc_api.py
+-rw-r--r--   0        0        0     4658 2023-07-28 03:11:29.771410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/health_api.py
+-rw-r--r--   0        0        0     5515 2023-07-28 03:11:29.771410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/icon_api.py
+-rw-r--r--   0        0        0    28829 2023-07-28 03:11:29.771410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/immutable_api.py
+-rw-r--r--   0        0        0    22975 2023-07-28 03:11:29.771410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/jobservice_api.py
+-rw-r--r--   0        0        0    26589 2023-07-28 03:11:29.771410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/label_api.py
+-rw-r--r--   0        0        0    19526 2023-07-28 03:11:29.771410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/ldap_api.py
+-rw-r--r--   0        0        0    33133 2023-07-28 03:11:29.774744 harbor_api_client-2.7.6/src/harbor_client/harbor_client/member_api.py
+-rw-r--r--   0        0        0     5441 2023-07-28 03:11:29.774744 harbor_api_client-2.7.6/src/harbor_client/harbor_client/oidc_api.py
+-rw-r--r--   0        0        0     4746 2023-07-28 03:11:29.774744 harbor_api_client-2.7.6/src/harbor_client/harbor_client/ping_api.py
+-rw-r--r--   0        0        0   112826 2023-07-28 03:11:29.774744 harbor_api_client-2.7.6/src/harbor_client/harbor_client/preheat_api.py
+-rw-r--r--   0        0        0    74780 2023-07-28 03:11:29.774744 harbor_api_client-2.7.6/src/harbor_client/harbor_client/project_api.py
+-rw-r--r--   0        0        0    32074 2023-07-28 03:11:29.774744 harbor_api_client-2.7.6/src/harbor_client/harbor_client/project_metadata_api.py
+-rw-r--r--   0        0        0    35453 2023-07-28 03:11:29.774744 harbor_api_client-2.7.6/src/harbor_client/harbor_client/purge_api.py
+-rw-r--r--   0        0        0    15828 2023-07-28 03:11:29.778077 harbor_api_client-2.7.6/src/harbor_client/harbor_client/quota_api.py
+-rw-r--r--   0        0        0    42496 2023-07-28 03:11:29.778077 harbor_api_client-2.7.6/src/harbor_client/harbor_client/registry_api.py
+-rw-r--r--   0        0        0    58097 2023-07-28 03:11:29.781410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/replication_api.py
+-rw-r--r--   0        0        0    31789 2023-07-28 03:11:29.781410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/repository_api.py
+-rw-r--r--   0        0        0    52066 2023-07-28 03:11:29.781410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/retention_api.py
+-rw-r--r--   0        0        0    30858 2023-07-28 03:11:29.781410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/robot_api.py
+-rw-r--r--   0        0        0    34629 2023-07-28 03:11:29.781410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/robotv1_api.py
+-rw-r--r--   0        0        0    26785 2023-07-28 03:11:29.781410 harbor_api_client-2.7.6/src/harbor_client/harbor_client/scan_all_api.py
+-rw-r--r--   0        0        0    20732 2023-07-28 03:11:29.784743 harbor_api_client-2.7.6/src/harbor_client/harbor_client/scan_api.py
+-rw-r--r--   0        0        0    20448 2023-07-28 03:11:29.784743 harbor_api_client-2.7.6/src/harbor_client/harbor_client/scan_data_export_api.py
+-rw-r--r--   0        0        0    42021 2023-07-28 03:11:29.784743 harbor_api_client-2.7.6/src/harbor_client/harbor_client/scanner_api.py
+-rw-r--r--   0        0        0    10081 2023-07-28 03:11:29.784743 harbor_api_client-2.7.6/src/harbor_client/harbor_client/schedule_api.py
+-rw-r--r--   0        0        0     5586 2023-07-28 03:11:29.784743 harbor_api_client-2.7.6/src/harbor_client/harbor_client/search_api.py
+-rw-r--r--   0        0        0     4771 2023-07-28 03:11:29.784743 harbor_api_client-2.7.6/src/harbor_client/harbor_client/statistic_api.py
+-rw-r--r--   0        0        0     9344 2023-07-28 03:11:29.784743 harbor_api_client-2.7.6/src/harbor_client/harbor_client/system_cve_allowlist_api.py
+-rw-r--r--   0        0        0    12992 2023-07-28 03:11:29.784743 harbor_api_client-2.7.6/src/harbor_client/harbor_client/systeminfo_api.py
+-rw-r--r--   0        0        0    56075 2023-07-28 03:11:29.788076 harbor_api_client-2.7.6/src/harbor_client/harbor_client/user_api.py
+-rw-r--r--   0        0        0    29345 2023-07-28 03:11:29.788076 harbor_api_client-2.7.6/src/harbor_client/harbor_client/usergroup_api.py
+-rw-r--r--   0        0        0    48175 2023-07-28 03:11:29.788076 harbor_api_client-2.7.6/src/harbor_client/harbor_client/webhook_api.py
+-rw-r--r--   0        0        0     9850 2023-07-28 03:11:29.788076 harbor_api_client-2.7.6/src/harbor_client/harbor_client/webhookjob_api.py
+-rw-r--r--   0        0        0     9981 2023-07-28 03:11:29.794743 harbor_api_client-2.7.6/src/harbor_client/models/__init__.py
+-rw-r--r--   0        0        0     4766 2023-07-28 03:11:29.794743 harbor_api_client-2.7.6/src/harbor_client/models/access.py
+-rw-r--r--   0        0        0     8864 2023-07-28 03:11:29.794743 harbor_api_client-2.7.6/src/harbor_client/models/accessory.py
+-rw-r--r--   0        0        0     3864 2023-07-28 03:11:29.794743 harbor_api_client-2.7.6/src/harbor_client/models/action_request.py
+-rw-r--r--   0        0        0     4188 2023-07-28 03:11:29.794743 harbor_api_client-2.7.6/src/harbor_client/models/addition_link.py
+-rw-r--r--   0        0        0     2746 2023-07-28 03:11:29.794743 harbor_api_client-2.7.6/src/harbor_client/models/addition_links.py
+-rw-r--r--   0        0        0     2736 2023-07-28 03:11:29.794743 harbor_api_client-2.7.6/src/harbor_client/models/annotations.py
+-rw-r--r--   0        0        0    17067 2023-07-28 03:11:29.798076 harbor_api_client-2.7.6/src/harbor_client/models/artifact.py
+-rw-r--r--   0        0        0     7415 2023-07-28 03:11:29.798076 harbor_api_client-2.7.6/src/harbor_client/models/audit_log.py
+-rw-r--r--   0        0        0     7913 2023-07-28 03:11:29.798076 harbor_api_client-2.7.6/src/harbor_client/models/authproxy_setting.py
+-rw-r--r--   0        0        0     3291 2023-07-28 03:11:29.798076 harbor_api_client-2.7.6/src/harbor_client/models/body.py
+-rw-r--r--   0        0        0     3277 2023-07-28 03:11:29.798076 harbor_api_client-2.7.6/src/harbor_client/models/body1.py
+-rw-r--r--   0        0        0     4245 2023-07-28 03:11:29.798076 harbor_api_client-2.7.6/src/harbor_client/models/bool_config_item.py
+-rw-r--r--   0        0        0    12080 2023-07-28 03:11:29.798076 harbor_api_client-2.7.6/src/harbor_client/models/chart_metadata.py
+-rw-r--r--   0        0        0     6447 2023-07-28 03:11:29.798076 harbor_api_client-2.7.6/src/harbor_client/models/chart_version.py
+-rw-r--r--   0        0        0     4991 2023-07-28 03:11:29.801409 harbor_api_client-2.7.6/src/harbor_client/models/component_health_status.py
+-rw-r--r--   0        0        0    54766 2023-07-28 03:11:29.801409 harbor_api_client-2.7.6/src/harbor_client/models/configurations.py
+-rw-r--r--   0        0        0    57168 2023-07-28 03:11:29.801409 harbor_api_client-2.7.6/src/harbor_client/models/configurations_response.py
+-rw-r--r--   0        0        0     4593 2023-07-28 03:11:29.804742 harbor_api_client-2.7.6/src/harbor_client/models/configurations_response_scan_all_policy.py
+-rw-r--r--   0        0        0     3922 2023-07-28 03:11:29.804742 harbor_api_client-2.7.6/src/harbor_client/models/configurations_response_scan_all_policy_parameter.py
+-rw-r--r--   0        0        0     7839 2023-07-28 03:11:29.804742 harbor_api_client-2.7.6/src/harbor_client/models/cve_allowlist.py
+-rw-r--r--   0        0        0     3512 2023-07-28 03:11:29.804742 harbor_api_client-2.7.6/src/harbor_client/models/cve_allowlist_item.py
+-rw-r--r--   0        0        0     4184 2023-07-28 03:11:29.804742 harbor_api_client-2.7.6/src/harbor_client/models/endpoint.py
+-rw-r--r--   0        0        0     3984 2023-07-28 03:11:29.804742 harbor_api_client-2.7.6/src/harbor_client/models/error.py
+-rw-r--r--   0        0        0     3310 2023-07-28 03:11:29.804742 harbor_api_client-2.7.6/src/harbor_client/models/errors.py
+-rw-r--r--   0        0        0     2726 2023-07-28 03:11:29.804742 harbor_api_client-2.7.6/src/harbor_client/models/event_type.py
+-rw-r--r--   0        0        0     9751 2023-07-28 03:11:29.804742 harbor_api_client-2.7.6/src/harbor_client/models/exec_history.py
+-rw-r--r--   0        0        0    10198 2023-07-28 03:11:29.808076 harbor_api_client-2.7.6/src/harbor_client/models/execution.py
+-rw-r--r--   0        0        0     2731 2023-07-28 03:11:29.808076 harbor_api_client-2.7.6/src/harbor_client/models/extra_attrs.py
+-rw-r--r--   0        0        0     4717 2023-07-28 03:11:29.808076 harbor_api_client-2.7.6/src/harbor_client/models/filter_style.py
+-rw-r--r--   0        0        0     9621 2023-07-28 03:11:29.808076 harbor_api_client-2.7.6/src/harbor_client/models/gc_history.py
+-rw-r--r--   0        0        0    16529 2023-07-28 03:11:29.808076 harbor_api_client-2.7.6/src/harbor_client/models/general_info.py
+-rw-r--r--   0        0        0     4201 2023-07-28 03:11:29.808076 harbor_api_client-2.7.6/src/harbor_client/models/icon.py
+-rw-r--r--   0        0        0     8371 2023-07-28 03:11:29.808076 harbor_api_client-2.7.6/src/harbor_client/models/immutable_rule.py
+-rw-r--r--   0        0        0     5361 2023-07-28 03:11:29.808076 harbor_api_client-2.7.6/src/harbor_client/models/immutable_selector.py
+-rw-r--r--   0        0        0    11790 2023-07-28 03:11:29.811409 harbor_api_client-2.7.6/src/harbor_client/models/instance.py
+-rw-r--r--   0        0        0     4281 2023-07-28 03:11:29.811409 harbor_api_client-2.7.6/src/harbor_client/models/integer_config_item.py
+-rw-r--r--   0        0        0     4391 2023-07-28 03:11:29.811409 harbor_api_client-2.7.6/src/harbor_client/models/internal_configuration_value.py
+-rw-r--r--   0        0        0     2831 2023-07-28 03:11:29.811409 harbor_api_client-2.7.6/src/harbor_client/models/internal_configurations_response.py
+-rw-r--r--   0        0        0     3562 2023-07-28 03:11:29.811409 harbor_api_client-2.7.6/src/harbor_client/models/is_default.py
+-rw-r--r--   0        0        0     5595 2023-07-28 03:11:29.811409 harbor_api_client-2.7.6/src/harbor_client/models/job_queue.py
+-rw-r--r--   0        0        0     8571 2023-07-28 03:11:29.811409 harbor_api_client-2.7.6/src/harbor_client/models/label.py
+-rw-r--r--   0        0        0    10622 2023-07-28 03:11:29.811409 harbor_api_client-2.7.6/src/harbor_client/models/ldap_conf.py
+-rw-r--r--   0        0        0     4137 2023-07-28 03:11:29.811409 harbor_api_client-2.7.6/src/harbor_client/models/ldap_failed_import_user.py
+-rw-r--r--   0        0        0     3605 2023-07-28 03:11:29.814742 harbor_api_client-2.7.6/src/harbor_client/models/ldap_import_users.py
+-rw-r--r--   0        0        0     4194 2023-07-28 03:11:29.814742 harbor_api_client-2.7.6/src/harbor_client/models/ldap_ping_result.py
+-rw-r--r--   0        0        0     4922 2023-07-28 03:11:29.814742 harbor_api_client-2.7.6/src/harbor_client/models/ldap_user.py
+-rw-r--r--   0        0        0     6732 2023-07-28 03:11:29.814742 harbor_api_client-2.7.6/src/harbor_client/models/metadata.py
+-rw-r--r--   0        0        0     9162 2023-07-28 03:11:29.814742 harbor_api_client-2.7.6/src/harbor_client/models/metrics.py
+-rw-r--r--   0        0        0    10333 2023-07-28 03:11:29.814742 harbor_api_client-2.7.6/src/harbor_client/models/native_report_summary.py
+-rw-r--r--   0        0        0     2731 2023-07-28 03:11:29.814742 harbor_api_client-2.7.6/src/harbor_client/models/notify_type.py
+-rw-r--r--   0        0        0     3450 2023-07-28 03:11:29.814742 harbor_api_client-2.7.6/src/harbor_client/models/oidc_cli_secret_req.py
+-rw-r--r--   0        0        0     7544 2023-07-28 03:11:29.818075 harbor_api_client-2.7.6/src/harbor_client/models/oidc_user_info.py
+-rw-r--r--   0        0        0     4424 2023-07-28 03:11:29.818075 harbor_api_client-2.7.6/src/harbor_client/models/overall_health_status.py
+-rw-r--r--   0        0        0     4402 2023-07-28 03:11:29.818075 harbor_api_client-2.7.6/src/harbor_client/models/password_req.py
+-rw-r--r--   0        0        0     4135 2023-07-28 03:11:29.818075 harbor_api_client-2.7.6/src/harbor_client/models/permission.py
+-rw-r--r--   0        0        0     6707 2023-07-28 03:11:29.818075 harbor_api_client-2.7.6/src/harbor_client/models/platform.py
+-rw-r--r--   0        0        0    11521 2023-07-28 03:11:29.818075 harbor_api_client-2.7.6/src/harbor_client/models/preheat_policy.py
+-rw-r--r--   0        0        0    15683 2023-07-28 03:11:29.818075 harbor_api_client-2.7.6/src/harbor_client/models/project.py
+-rw-r--r--   0        0        0     4348 2023-07-28 03:11:29.818075 harbor_api_client-2.7.6/src/harbor_client/models/project_deletable.py
+-rw-r--r--   0        0        0     5085 2023-07-28 03:11:29.821408 harbor_api_client-2.7.6/src/harbor_client/models/project_member.py
+-rw-r--r--   0        0        0     8646 2023-07-28 03:11:29.821408 harbor_api_client-2.7.6/src/harbor_client/models/project_member_entity.py
+-rw-r--r--   0        0        0    11657 2023-07-28 03:11:29.821408 harbor_api_client-2.7.6/src/harbor_client/models/project_metadata.py
+-rw-r--r--   0        0        0     8145 2023-07-28 03:11:29.821408 harbor_api_client-2.7.6/src/harbor_client/models/project_req.py
+-rw-r--r--   0        0        0     3578 2023-07-28 03:11:29.821408 harbor_api_client-2.7.6/src/harbor_client/models/project_scanner.py
+-rw-r--r--   0        0        0    10650 2023-07-28 03:11:29.821408 harbor_api_client-2.7.6/src/harbor_client/models/project_summary.py
+-rw-r--r--   0        0        0     4210 2023-07-28 03:11:29.821408 harbor_api_client-2.7.6/src/harbor_client/models/project_summary_quota.py
+-rw-r--r--   0        0        0     5331 2023-07-28 03:11:29.821408 harbor_api_client-2.7.6/src/harbor_client/models/provider_under_project.py
+-rw-r--r--   0        0        0     7060 2023-07-28 03:11:29.824742 harbor_api_client-2.7.6/src/harbor_client/models/quota.py
+-rw-r--r--   0        0        0     2751 2023-07-28 03:11:29.824742 harbor_api_client-2.7.6/src/harbor_client/models/quota_ref_object.py
+-rw-r--r--   0        0        0     3457 2023-07-28 03:11:29.824742 harbor_api_client-2.7.6/src/harbor_client/models/quota_update_req.py
+-rw-r--r--   0        0        0     7216 2023-07-28 03:11:29.824742 harbor_api_client-2.7.6/src/harbor_client/models/reference.py
+-rw-r--r--   0        0        0    10176 2023-07-28 03:11:29.824742 harbor_api_client-2.7.6/src/harbor_client/models/registry.py
+-rw-r--r--   0        0        0     5300 2023-07-28 03:11:29.824742 harbor_api_client-2.7.6/src/harbor_client/models/registry_credential.py
+-rw-r--r--   0        0        0     4073 2023-07-28 03:11:29.824742 harbor_api_client-2.7.6/src/harbor_client/models/registry_endpoint.py
+-rw-r--r--   0        0        0     7538 2023-07-28 03:11:29.824742 harbor_api_client-2.7.6/src/harbor_client/models/registry_info.py
+-rw-r--r--   0        0        0     8242 2023-07-28 03:11:29.824742 harbor_api_client-2.7.6/src/harbor_client/models/registry_ping.py
+-rw-r--r--   0        0        0     6905 2023-07-28 03:11:29.828075 harbor_api_client-2.7.6/src/harbor_client/models/registry_provider_credential_pattern.py
+-rw-r--r--   0        0        0     4605 2023-07-28 03:11:29.828075 harbor_api_client-2.7.6/src/harbor_client/models/registry_provider_endpoint_pattern.py
+-rw-r--r--   0        0        0     4895 2023-07-28 03:11:29.828075 harbor_api_client-2.7.6/src/harbor_client/models/registry_provider_info.py
+-rw-r--r--   0        0        0     8476 2023-07-28 03:11:29.828075 harbor_api_client-2.7.6/src/harbor_client/models/registry_update.py
+-rw-r--r--   0        0        0    12256 2023-07-28 03:11:29.828075 harbor_api_client-2.7.6/src/harbor_client/models/replication_execution.py
+-rw-r--r--   0        0        0     5002 2023-07-28 03:11:29.828075 harbor_api_client-2.7.6/src/harbor_client/models/replication_filter.py
+-rw-r--r--   0        0        0    17618 2023-07-28 03:11:29.828075 harbor_api_client-2.7.6/src/harbor_client/models/replication_policy.py
+-rw-r--r--   0        0        0    10955 2023-07-28 03:11:29.831408 harbor_api_client-2.7.6/src/harbor_client/models/replication_task.py
+-rw-r--r--   0        0        0     4478 2023-07-28 03:11:29.831408 harbor_api_client-2.7.6/src/harbor_client/models/replication_trigger.py
+-rw-r--r--   0        0        0     3546 2023-07-28 03:11:29.831408 harbor_api_client-2.7.6/src/harbor_client/models/replication_trigger_settings.py
+-rw-r--r--   0        0        0     9254 2023-07-28 03:11:29.831408 harbor_api_client-2.7.6/src/harbor_client/models/repository.py
+-rw-r--r--   0        0        0     2741 2023-07-28 03:11:29.831408 harbor_api_client-2.7.6/src/harbor_client/models/resource_list.py
+-rw-r--r--   0        0        0     7492 2023-07-28 03:11:29.831408 harbor_api_client-2.7.6/src/harbor_client/models/retention_execution.py
+-rw-r--r--   0        0        0    10681 2023-07-28 03:11:29.834741 harbor_api_client-2.7.6/src/harbor_client/models/retention_execution_task.py
+-rw-r--r--   0        0        0     5575 2023-07-28 03:11:29.834741 harbor_api_client-2.7.6/src/harbor_client/models/retention_metadata.py
+-rw-r--r--   0        0        0     6037 2023-07-28 03:11:29.834741 harbor_api_client-2.7.6/src/harbor_client/models/retention_policy.py
+-rw-r--r--   0        0        0     3965 2023-07-28 03:11:29.834741 harbor_api_client-2.7.6/src/harbor_client/models/retention_policy_scope.py
+-rw-r--r--   0        0        0     8371 2023-07-28 03:11:29.834741 harbor_api_client-2.7.6/src/harbor_client/models/retention_rule.py
+-rw-r--r--   0        0        0     6047 2023-07-28 03:11:29.834741 harbor_api_client-2.7.6/src/harbor_client/models/retention_rule_metadata.py
+-rw-r--r--   0        0        0     4743 2023-07-28 03:11:29.834741 harbor_api_client-2.7.6/src/harbor_client/models/retention_rule_param_metadata.py
+-rw-r--r--   0        0        0     4790 2023-07-28 03:11:29.834741 harbor_api_client-2.7.6/src/harbor_client/models/retention_rule_trigger.py
+-rw-r--r--   0        0        0     5361 2023-07-28 03:11:29.834741 harbor_api_client-2.7.6/src/harbor_client/models/retention_selector.py
+-rw-r--r--   0        0        0     4975 2023-07-28 03:11:29.838074 harbor_api_client-2.7.6/src/harbor_client/models/retention_selector_metadata.py
+-rw-r--r--   0        0        0    11617 2023-07-28 03:11:29.838074 harbor_api_client-2.7.6/src/harbor_client/models/robot.py
+-rw-r--r--   0        0        0     8001 2023-07-28 03:11:29.838074 harbor_api_client-2.7.6/src/harbor_client/models/robot_create.py
+-rw-r--r--   0        0        0     5947 2023-07-28 03:11:29.838074 harbor_api_client-2.7.6/src/harbor_client/models/robot_create_v1.py
+-rw-r--r--   0        0        0     6494 2023-07-28 03:11:29.838074 harbor_api_client-2.7.6/src/harbor_client/models/robot_created.py
+-rw-r--r--   0        0        0     4846 2023-07-28 03:11:29.838074 harbor_api_client-2.7.6/src/harbor_client/models/robot_permission.py
+-rw-r--r--   0        0        0     3396 2023-07-28 03:11:29.838074 harbor_api_client-2.7.6/src/harbor_client/models/robot_sec.py
+-rw-r--r--   0        0        0     3553 2023-07-28 03:11:29.838074 harbor_api_client-2.7.6/src/harbor_client/models/role_request.py
+-rw-r--r--   0        0        0    10159 2023-07-28 03:11:29.841408 harbor_api_client-2.7.6/src/harbor_client/models/scan_data_export_execution.py
+-rw-r--r--   0        0        0     3657 2023-07-28 03:11:29.841408 harbor_api_client-2.7.6/src/harbor_client/models/scan_data_export_execution_list.py
+-rw-r--r--   0        0        0     3419 2023-07-28 03:11:29.841408 harbor_api_client-2.7.6/src/harbor_client/models/scan_data_export_job.py
+-rw-r--r--   0        0        0     8456 2023-07-28 03:11:29.841408 harbor_api_client-2.7.6/src/harbor_client/models/scan_data_export_request.py
+-rw-r--r--   0        0        0     2741 2023-07-28 03:11:29.841408 harbor_api_client-2.7.6/src/harbor_client/models/scan_overview.py
+-rw-r--r--   0        0        0     4729 2023-07-28 03:11:29.841408 harbor_api_client-2.7.6/src/harbor_client/models/scanner.py
+-rw-r--r--   0        0        0     5113 2023-07-28 03:11:29.841408 harbor_api_client-2.7.6/src/harbor_client/models/scanner_adapter_metadata.py
+-rw-r--r--   0        0        0     4599 2023-07-28 03:11:29.841408 harbor_api_client-2.7.6/src/harbor_client/models/scanner_capability.py
+-rw-r--r--   0        0        0    16950 2023-07-28 03:11:29.841408 harbor_api_client-2.7.6/src/harbor_client/models/scanner_registration.py
+-rw-r--r--   0        0        0    10576 2023-07-28 03:11:29.844741 harbor_api_client-2.7.6/src/harbor_client/models/scanner_registration_req.py
+-rw-r--r--   0        0        0     6684 2023-07-28 03:11:29.844741 harbor_api_client-2.7.6/src/harbor_client/models/scanner_registration_settings.py
+-rw-r--r--   0        0        0     7308 2023-07-28 03:11:29.844741 harbor_api_client-2.7.6/src/harbor_client/models/schedule.py
+-rw-r--r--   0        0        0     5785 2023-07-28 03:11:29.844741 harbor_api_client-2.7.6/src/harbor_client/models/schedule_obj.py
+-rw-r--r--   0        0        0     6640 2023-07-28 03:11:29.844741 harbor_api_client-2.7.6/src/harbor_client/models/schedule_task.py
+-rw-r--r--   0        0        0     3468 2023-07-28 03:11:29.844741 harbor_api_client-2.7.6/src/harbor_client/models/scheduler_status.py
+-rw-r--r--   0        0        0     5223 2023-07-28 03:11:29.844741 harbor_api_client-2.7.6/src/harbor_client/models/search.py
+-rw-r--r--   0        0        0     8351 2023-07-28 03:11:29.844741 harbor_api_client-2.7.6/src/harbor_client/models/search_repository.py
+-rw-r--r--   0        0        0     4673 2023-07-28 03:11:29.844741 harbor_api_client-2.7.6/src/harbor_client/models/search_result.py
+-rw-r--r--   0        0        0     3657 2023-07-28 03:11:29.848074 harbor_api_client-2.7.6/src/harbor_client/models/start_replication_execution.py
+-rw-r--r--   0        0        0     9942 2023-07-28 03:11:29.848074 harbor_api_client-2.7.6/src/harbor_client/models/statistic.py
+-rw-r--r--   0        0        0     6952 2023-07-28 03:11:29.848074 harbor_api_client-2.7.6/src/harbor_client/models/stats.py
+-rw-r--r--   0        0        0     3978 2023-07-28 03:11:29.848074 harbor_api_client-2.7.6/src/harbor_client/models/storage.py
+-rw-r--r--   0        0        0     4266 2023-07-28 03:11:29.848074 harbor_api_client-2.7.6/src/harbor_client/models/string_config_item.py
+-rw-r--r--   0        0        0     4378 2023-07-28 03:11:29.848074 harbor_api_client-2.7.6/src/harbor_client/models/supported_webhook_event_types.py
+-rw-r--r--   0        0        0     3462 2023-07-28 03:11:29.848074 harbor_api_client-2.7.6/src/harbor_client/models/system_info.py
+-rw-r--r--   0        0        0     8693 2023-07-28 03:11:29.848074 harbor_api_client-2.7.6/src/harbor_client/models/tag.py
+-rw-r--r--   0        0        0    10207 2023-07-28 03:11:29.848074 harbor_api_client-2.7.6/src/harbor_client/models/task.py
+-rw-r--r--   0        0        0     6641 2023-07-28 03:11:29.851407 harbor_api_client-2.7.6/src/harbor_client/models/user_creation_req.py
+-rw-r--r--   0        0        0     4147 2023-07-28 03:11:29.851407 harbor_api_client-2.7.6/src/harbor_client/models/user_entity.py
+-rw-r--r--   0        0        0     5889 2023-07-28 03:11:29.851407 harbor_api_client-2.7.6/src/harbor_client/models/user_group.py
+-rw-r--r--   0        0        0     5131 2023-07-28 03:11:29.851407 harbor_api_client-2.7.6/src/harbor_client/models/user_group_search_item.py
+-rw-r--r--   0        0        0     4565 2023-07-28 03:11:29.851407 harbor_api_client-2.7.6/src/harbor_client/models/user_profile.py
+-rw-r--r--   0        0        0    10271 2023-07-28 03:11:29.851407 harbor_api_client-2.7.6/src/harbor_client/models/user_resp.py
+-rw-r--r--   0        0        0     4059 2023-07-28 03:11:29.851407 harbor_api_client-2.7.6/src/harbor_client/models/user_search.py
+-rw-r--r--   0        0        0     4163 2023-07-28 03:11:29.851407 harbor_api_client-2.7.6/src/harbor_client/models/user_search_resp_item.py
+-rw-r--r--   0        0        0     3621 2023-07-28 03:11:29.854740 harbor_api_client-2.7.6/src/harbor_client/models/user_sys_admin_flag.py
+-rw-r--r--   0        0        0     5149 2023-07-28 03:11:29.854740 harbor_api_client-2.7.6/src/harbor_client/models/vulnerability_summary.py
+-rw-r--r--   0        0        0     9008 2023-07-28 03:11:29.854740 harbor_api_client-2.7.6/src/harbor_client/models/webhook_job.py
+-rw-r--r--   0        0        0     7204 2023-07-28 03:11:29.854740 harbor_api_client-2.7.6/src/harbor_client/models/webhook_last_trigger.py
+-rw-r--r--   0        0        0    10558 2023-07-28 03:11:29.854740 harbor_api_client-2.7.6/src/harbor_client/models/webhook_policy.py
+-rw-r--r--   0        0        0     6083 2023-07-28 03:11:29.854740 harbor_api_client-2.7.6/src/harbor_client/models/webhook_target_object.py
+-rw-r--r--   0        0        0     7899 2023-07-28 03:11:29.854740 harbor_api_client-2.7.6/src/harbor_client/models/worker.py
+-rw-r--r--   0        0        0     7446 2023-07-28 03:11:29.854740 harbor_api_client-2.7.6/src/harbor_client/models/worker_pool.py
+-rw-r--r--   0        0        0    13134 2023-07-28 03:11:29.858074 harbor_api_client-2.7.6/src/harbor_client/rest.py
+-rw-r--r--   0        0        0    40687 1970-01-01 00:00:00.000000 harbor_api_client-2.7.6/PKG-INFO
```

### Comparing `harbor_api_client-2.7.5/LICENSE` & `harbor_api_client-2.7.6/LICENSE`

 * *Files identical despite different names*

### Comparing `harbor_api_client-2.7.5/README.md` & `harbor_api_client-2.7.6/README.md`

 * *Files identical despite different names*

### Comparing `harbor_api_client-2.7.5/pyproject.toml` & `harbor_api_client-2.7.6/pyproject.toml`

 * *Files 21% similar despite different names*

```diff
@@ -1,34 +1,44 @@
 [tool.poetry]
 name = "harbor-api-client"
-version = "2.7.5"
+version = "2.7.6"
 description = "Client for the Harbor API"
 authors = ["Vadim Bauer <vb@container-registry.com>", "Alexandre Krispin <development.s004k@simplelogin.com>"]
 keywords = ["Swagger", "Harbor API"]
 packages = [{include = "harbor_client", from = "src"}]
 license = "Apache-2.0"
 repository = "https://github.com/container-registry/harbor-api-client"
 homepage = "https://container-registry.com"
 documentation = "https://container-registry.com/docs/"
 readme = "README.md"
 
 [tool.poetry.urls]
 "Bug Tracker" = "https://github.com/container-registry/harbor-api-client/issues"
 
 [tool.poetry.dependencies]
-python = ">=3.4"
-certifi = "^2022.12.7"
+python = ">=3.8"
+certifi = ">=2022.12.7"
 six = "^1.10"
 python_dateutil = "^2.8.1"
 urllib3 = "^1.15.1"
 
 [tool.poetry.group.dev.dependencies]
 coverage = "^4.0.3"
 nose = "^1.3.7"
 pluggy = "^0.3.1"
 py = "^1.4.31"
 randomize = "^0.13"
+black = "^23.3.0"
+mypy = "^1.1.1"
+ruff = "^0.0.261"
 
 [build-system]
 requires = ["poetry-core>=1.0.0"]
 build-backend = "poetry.core.masonry.api"
 
+[tool.black]
+line-length = 100
+target-version = ['py38']
+
+[tool.ruff]
+line-length = 100
+
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/__init__.py` & `harbor_api_client-2.7.6/src/harbor_client/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -53,14 +53,15 @@
 from harbor_client.api.usergroup_api import UsergroupApi
 from harbor_client.api.webhook_api import WebhookApi
 from harbor_client.api.webhookjob_api import WebhookjobApi
 
 # import ApiClient
 from harbor_client.api_client import ApiClient
 from harbor_client.configuration import Configuration
+
 # import models into sdk package
 from harbor_client.models.access import Access
 from harbor_client.models.accessory import Accessory
 from harbor_client.models.action_request import ActionRequest
 from harbor_client.models.addition_link import AdditionLink
 from harbor_client.models.addition_links import AdditionLinks
 from harbor_client.models.annotations import Annotations
@@ -73,16 +74,20 @@
 from harbor_client.models.cve_allowlist import CVEAllowlist
 from harbor_client.models.cve_allowlist_item import CVEAllowlistItem
 from harbor_client.models.chart_metadata import ChartMetadata
 from harbor_client.models.chart_version import ChartVersion
 from harbor_client.models.component_health_status import ComponentHealthStatus
 from harbor_client.models.configurations import Configurations
 from harbor_client.models.configurations_response import ConfigurationsResponse
-from harbor_client.models.configurations_response_scan_all_policy import ConfigurationsResponseScanAllPolicy
-from harbor_client.models.configurations_response_scan_all_policy_parameter import ConfigurationsResponseScanAllPolicyParameter
+from harbor_client.models.configurations_response_scan_all_policy import (
+    ConfigurationsResponseScanAllPolicy,
+)
+from harbor_client.models.configurations_response_scan_all_policy_parameter import (
+    ConfigurationsResponseScanAllPolicyParameter,
+)
 from harbor_client.models.endpoint import Endpoint
 from harbor_client.models.error import Error
 from harbor_client.models.errors import Errors
 from harbor_client.models.event_type import EventType
 from harbor_client.models.exec_history import ExecHistory
 from harbor_client.models.execution import Execution
 from harbor_client.models.extra_attrs import ExtraAttrs
@@ -130,15 +135,17 @@
 from harbor_client.models.quota_update_req import QuotaUpdateReq
 from harbor_client.models.reference import Reference
 from harbor_client.models.registry import Registry
 from harbor_client.models.registry_credential import RegistryCredential
 from harbor_client.models.registry_endpoint import RegistryEndpoint
 from harbor_client.models.registry_info import RegistryInfo
 from harbor_client.models.registry_ping import RegistryPing
-from harbor_client.models.registry_provider_credential_pattern import RegistryProviderCredentialPattern
+from harbor_client.models.registry_provider_credential_pattern import (
+    RegistryProviderCredentialPattern,
+)
 from harbor_client.models.registry_provider_endpoint_pattern import RegistryProviderEndpointPattern
 from harbor_client.models.registry_provider_info import RegistryProviderInfo
 from harbor_client.models.registry_update import RegistryUpdate
 from harbor_client.models.replication_execution import ReplicationExecution
 from harbor_client.models.replication_filter import ReplicationFilter
 from harbor_client.models.replication_policy import ReplicationPolicy
 from harbor_client.models.replication_task import ReplicationTask
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/__init__.py` & `harbor_api_client-2.7.6/src/harbor_client/api/__init__.py`

 * *Files identical despite different names*

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/artifact_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/artifact_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -48,22 +48,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param Label label: The label that added to the artifact. Only the ID property is needed. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.add_label_with_http_info(project_name, repository_name, reference, label, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.add_label_with_http_info(
+                project_name, repository_name, reference, label, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.add_label_with_http_info(project_name, repository_name, reference, label, **kwargs)  # noqa: E501
+            (data) = self.add_label_with_http_info(
+                project_name, repository_name, reference, label, **kwargs
+            )  # noqa: E501
             return data
 
-    def add_label_with_http_info(self, project_name, repository_name, reference, label, **kwargs):  # noqa: E501
+    def add_label_with_http_info(
+        self, project_name, repository_name, reference, label, **kwargs
+    ):  # noqa: E501
         """Add label to artifact  # noqa: E501
 
         Add label to the specified artiact.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_label_with_http_info(project_name, repository_name, reference, label, async_req=True)
         >>> result = thread.get()
@@ -75,97 +81,121 @@
         :param Label label: The label that added to the artifact. Only the ID property is needed. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'label', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "label",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method add_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method add_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `add_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `add_label`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `add_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `add_label`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `add_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `add_label`"
+            )  # noqa: E501
         # verify the required parameter 'label' is set
-        if self.api_client.client_side_validation and ('label' not in params or
-                                                       params['label'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label` when calling `add_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `add_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label" not in params or params["label"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label` when calling `add_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `add_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'label' in params:
-            body_params = params['label']
+        if "label" in params:
+            body_params = params["label"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def copy_artifact(self, project_name, repository_name, _from, **kwargs):  # noqa: E501
         """Copy artifact  # noqa: E501
 
         Copy the artifact specified in the \"from\" parameter to the repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -177,22 +207,28 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str _from: The artifact from which the new artifact is copied from, the format should be \"project/repository:tag\" or \"project/repository@digest\". (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.copy_artifact_with_http_info(project_name, repository_name, _from, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.copy_artifact_with_http_info(
+                project_name, repository_name, _from, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.copy_artifact_with_http_info(project_name, repository_name, _from, **kwargs)  # noqa: E501
+            (data) = self.copy_artifact_with_http_info(
+                project_name, repository_name, _from, **kwargs
+            )  # noqa: E501
             return data
 
-    def copy_artifact_with_http_info(self, project_name, repository_name, _from, **kwargs):  # noqa: E501
+    def copy_artifact_with_http_info(
+        self, project_name, repository_name, _from, **kwargs
+    ):  # noqa: E501
         """Copy artifact  # noqa: E501
 
         Copy the artifact specified in the \"from\" parameter to the repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.copy_artifact_with_http_info(project_name, repository_name, _from, async_req=True)
         >>> result = thread.get()
@@ -203,91 +239,106 @@
         :param str _from: The artifact from which the new artifact is copied from, the format should be \"project/repository:tag\" or \"project/repository@digest\". (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', '_from', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "_from", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method copy_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method copy_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `copy_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `copy_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `copy_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `copy_artifact`"
+            )  # noqa: E501
         # verify the required parameter '_from' is set
-        if self.api_client.client_side_validation and ('_from' not in params or
-                                                       params['_from'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `_from` when calling `copy_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `copy_artifact`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "_from" not in params or params["_from"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `_from` when calling `copy_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `copy_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
-        if '_from' in params:
-            query_params.append(('from', params['_from']))  # noqa: E501
+        if "_from" in params:
+            query_params.append(("from", params["_from"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def create_tag(self, project_name, repository_name, reference, tag, **kwargs):  # noqa: E501
         """Create tag  # noqa: E501
 
         Create a tag for the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -300,22 +351,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param Tag tag: The JSON object of tag. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_tag_with_http_info(project_name, repository_name, reference, tag, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_tag_with_http_info(
+                project_name, repository_name, reference, tag, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_tag_with_http_info(project_name, repository_name, reference, tag, **kwargs)  # noqa: E501
+            (data) = self.create_tag_with_http_info(
+                project_name, repository_name, reference, tag, **kwargs
+            )  # noqa: E501
             return data
 
-    def create_tag_with_http_info(self, project_name, repository_name, reference, tag, **kwargs):  # noqa: E501
+    def create_tag_with_http_info(
+        self, project_name, repository_name, reference, tag, **kwargs
+    ):  # noqa: E501
         """Create tag  # noqa: E501
 
         Create a tag for the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_tag_with_http_info(project_name, repository_name, reference, tag, async_req=True)
         >>> result = thread.get()
@@ -327,97 +384,121 @@
         :param Tag tag: The JSON object of tag. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'tag', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "tag",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_tag" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_tag" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `create_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `create_tag`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `create_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `create_tag`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `create_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `create_tag`"
+            )  # noqa: E501
         # verify the required parameter 'tag' is set
-        if self.api_client.client_side_validation and ('tag' not in params or
-                                                       params['tag'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `tag` when calling `create_tag`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_tag`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "tag" not in params or params["tag"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `tag` when calling `create_tag`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_tag`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'tag' in params:
-            body_params = params['tag']
+        if "tag" in params:
+            body_params = params["tag"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_artifact(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """Delete the specific artifact  # noqa: E501
 
         Delete the artifact specified by the reference under the project and repository. The reference can be digest or tag  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -429,22 +510,28 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.delete_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_artifact_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def delete_artifact_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Delete the specific artifact  # noqa: E501
 
         Delete the artifact specified by the reference under the project and repository. The reference can be digest or tag  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_artifact_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -455,93 +542,110 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "reference", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `delete_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `delete_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `delete_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `delete_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `delete_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_artifact`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `delete_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}', 'DELETE',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_tag(self, project_name, repository_name, reference, tag_name, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def delete_tag(
+        self, project_name, repository_name, reference, tag_name, **kwargs
+    ):  # noqa: E501
         """Delete tag  # noqa: E501
 
         Delete the tag of the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_tag(project_name, repository_name, reference, tag_name, async_req=True)
         >>> result = thread.get()
@@ -552,22 +656,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str tag_name: The name of the tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_tag_with_http_info(project_name, repository_name, reference, tag_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_tag_with_http_info(
+                project_name, repository_name, reference, tag_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_tag_with_http_info(project_name, repository_name, reference, tag_name, **kwargs)  # noqa: E501
+            (data) = self.delete_tag_with_http_info(
+                project_name, repository_name, reference, tag_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_tag_with_http_info(self, project_name, repository_name, reference, tag_name, **kwargs):  # noqa: E501
+    def delete_tag_with_http_info(
+        self, project_name, repository_name, reference, tag_name, **kwargs
+    ):  # noqa: E501
         """Delete tag  # noqa: E501
 
         Delete the tag of the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_tag_with_http_info(project_name, repository_name, reference, tag_name, async_req=True)
         >>> result = thread.get()
@@ -579,99 +689,125 @@
         :param str tag_name: The name of the tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'tag_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "tag_name",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_tag" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_tag" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `delete_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `delete_tag`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `delete_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `delete_tag`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `delete_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `delete_tag`"
+            )  # noqa: E501
         # verify the required parameter 'tag_name' is set
-        if self.api_client.client_side_validation and ('tag_name' not in params or
-                                                       params['tag_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `tag_name` when calling `delete_tag`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_tag`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "tag_name" not in params or params["tag_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `tag_name` when calling `delete_tag`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_tag`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
-        if 'tag_name' in params:
-            path_params['tag_name'] = params['tag_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
+        if "tag_name" in params:
+            path_params["tag_name"] = params["tag_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags/{tag_name}', 'DELETE',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags/{tag_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_addition(self, project_name, repository_name, reference, addition, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def get_addition(
+        self, project_name, repository_name, reference, addition, **kwargs
+    ):  # noqa: E501
         """Get the addition of the specific artifact  # noqa: E501
 
         Get the addition of the artifact specified by the reference under the project and repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_addition(project_name, repository_name, reference, addition, async_req=True)
         >>> result = thread.get()
@@ -682,22 +818,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str addition: The type of addition. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_addition_with_http_info(project_name, repository_name, reference, addition, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_addition_with_http_info(
+                project_name, repository_name, reference, addition, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_addition_with_http_info(project_name, repository_name, reference, addition, **kwargs)  # noqa: E501
+            (data) = self.get_addition_with_http_info(
+                project_name, repository_name, reference, addition, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_addition_with_http_info(self, project_name, repository_name, reference, addition, **kwargs):  # noqa: E501
+    def get_addition_with_http_info(
+        self, project_name, repository_name, reference, addition, **kwargs
+    ):  # noqa: E501
         """Get the addition of the specific artifact  # noqa: E501
 
         Get the addition of the artifact specified by the reference under the project and repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_addition_with_http_info(project_name, repository_name, reference, addition, async_req=True)
         >>> result = thread.get()
@@ -709,97 +851,121 @@
         :param str addition: The type of addition. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'addition', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "addition",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_addition" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_addition" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_addition`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_addition`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `get_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `get_addition`"
+            )  # noqa: E501
         # verify the required parameter 'addition' is set
-        if self.api_client.client_side_validation and ('addition' not in params or
-                                                       params['addition'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `addition` when calling `get_addition`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_addition`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "addition" not in params or params["addition"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `addition` when calling `get_addition`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_addition`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
-        if 'addition' in params:
-            path_params['addition'] = params['addition']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
+        if "addition" in params:
+            path_params["addition"] = params["addition"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/{addition}', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/{addition}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_artifact(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """Get the specific artifact  # noqa: E501
 
         Get the artifact specified by the reference under the project and repository. The reference can be digest or tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -820,22 +986,28 @@
         :param bool with_accessory: Specify whether the accessories are included of the returning artifacts.
         :param bool with_signature: Specify whether the signature is inclued inside the returning artifacts
         :param bool with_immutable_status: Specify whether the immutable status is inclued inside the tags of the returning artifacts.
         :return: Artifact
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.get_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_artifact_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def get_artifact_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Get the specific artifact  # noqa: E501
 
         Get the artifact specified by the reference under the project and repository. The reference can be digest or tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_artifact_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -855,113 +1027,152 @@
         :param bool with_signature: Specify whether the signature is inclued inside the returning artifacts
         :param bool with_immutable_status: Specify whether the immutable status is inclued inside the tags of the returning artifacts.
         :return: Artifact
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id', 'page', 'page_size', 'x_accept_vulnerabilities', 'with_tag', 'with_label', 'with_scan_overview', 'with_accessory', 'with_signature', 'with_immutable_status']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "x_request_id",
+            "page",
+            "page_size",
+            "x_accept_vulnerabilities",
+            "with_tag",
+            "with_label",
+            "with_scan_overview",
+            "with_accessory",
+            "with_signature",
+            "with_immutable_status",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `get_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_artifact`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `get_artifact`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `get_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `get_artifact`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'with_tag' in params:
-            query_params.append(('with_tag', params['with_tag']))  # noqa: E501
-        if 'with_label' in params:
-            query_params.append(('with_label', params['with_label']))  # noqa: E501
-        if 'with_scan_overview' in params:
-            query_params.append(('with_scan_overview', params['with_scan_overview']))  # noqa: E501
-        if 'with_accessory' in params:
-            query_params.append(('with_accessory', params['with_accessory']))  # noqa: E501
-        if 'with_signature' in params:
-            query_params.append(('with_signature', params['with_signature']))  # noqa: E501
-        if 'with_immutable_status' in params:
-            query_params.append(('with_immutable_status', params['with_immutable_status']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "with_tag" in params:
+            query_params.append(("with_tag", params["with_tag"]))  # noqa: E501
+        if "with_label" in params:
+            query_params.append(("with_label", params["with_label"]))  # noqa: E501
+        if "with_scan_overview" in params:
+            query_params.append(("with_scan_overview", params["with_scan_overview"]))  # noqa: E501
+        if "with_accessory" in params:
+            query_params.append(("with_accessory", params["with_accessory"]))  # noqa: E501
+        if "with_signature" in params:
+            query_params.append(("with_signature", params["with_signature"]))  # noqa: E501
+        if "with_immutable_status" in params:
+            query_params.append(
+                ("with_immutable_status", params["with_immutable_status"])
+            )  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_accept_vulnerabilities' in params:
-            header_params['X-Accept-Vulnerabilities'] = params['x_accept_vulnerabilities']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_accept_vulnerabilities" in params:
+            header_params["X-Accept-Vulnerabilities"] = params[
+                "x_accept_vulnerabilities"
+            ]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Artifact',  # noqa: E501
+            response_type="Artifact",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_vulnerabilities_addition(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def get_vulnerabilities_addition(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Get the vulnerabilities addition of the specific artifact  # noqa: E501
 
         Get the vulnerabilities addition of the artifact specified by the reference under the project and repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_vulnerabilities_addition(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -972,22 +1183,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :param str x_accept_vulnerabilities: A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it. Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_vulnerabilities_addition_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_vulnerabilities_addition_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_vulnerabilities_addition_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.get_vulnerabilities_addition_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_vulnerabilities_addition_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def get_vulnerabilities_addition_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Get the vulnerabilities addition of the specific artifact  # noqa: E501
 
         Get the vulnerabilities addition of the artifact specified by the reference under the project and repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_vulnerabilities_addition_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -999,93 +1216,117 @@
         :param str x_request_id: An unique ID for the request
         :param str x_accept_vulnerabilities: A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it. Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id', 'x_accept_vulnerabilities']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "x_request_id",
+            "x_accept_vulnerabilities",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_vulnerabilities_addition" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_vulnerabilities_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_vulnerabilities_addition`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_vulnerabilities_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_vulnerabilities_addition`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `get_vulnerabilities_addition`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_vulnerabilities_addition`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `get_vulnerabilities_addition`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_vulnerabilities_addition`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_accept_vulnerabilities' in params:
-            header_params['X-Accept-Vulnerabilities'] = params['x_accept_vulnerabilities']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_accept_vulnerabilities" in params:
+            header_params["X-Accept-Vulnerabilities"] = params[
+                "x_accept_vulnerabilities"
+            ]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/vulnerabilities', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/vulnerabilities",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_accessories(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """List accessories  # noqa: E501
 
         List accessories of the specific artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1101,22 +1342,28 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Accessory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_accessories_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_accessories_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_accessories_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.list_accessories_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_accessories_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def list_accessories_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """List accessories  # noqa: E501
 
         List accessories of the specific artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_accessories_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -1131,101 +1378,129 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Accessory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_accessories" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_accessories" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_accessories`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_accessories`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `list_accessories`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `list_accessories`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `list_accessories`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_accessories`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_accessories`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `list_accessories`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_accessories`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_accessories`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/accessories', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/accessories",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Accessory]',  # noqa: E501
+            response_type="list[Accessory]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_artifacts(self, project_name, repository_name, **kwargs):  # noqa: E501
         """List artifacts  # noqa: E501
 
         List artifacts under the specific project and repository. Except the basic properties, the other supported queries in \"q\" includes \"tags=*\" to list only tagged artifacts, \"tags=nil\" to list only untagged artifacts, \"tags=~v\" to list artifacts whose tag fuzzy matches \"v\", \"tags=v\" to list artifact whose tag exactly matches \"v\", \"labels=(id1, id2)\" to list artifacts that both labels with id1 and id2 are added to  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1247,19 +1522,23 @@
         :param bool with_signature: Specify whether the signature is included inside the tags of the returning artifacts. Only works when setting \"with_tag=true\"
         :param bool with_immutable_status: Specify whether the immutable status is included inside the tags of the returning artifacts. Only works when setting \"with_immutable_status=true\"
         :param bool with_accessory: Specify whether the accessories are included of the returning artifacts. Only works when setting \"with_accessory=true\"
         :return: list[Artifact]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_artifacts_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_artifacts_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_artifacts_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+            (data) = self.list_artifacts_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
             return data
 
     def list_artifacts_with_http_info(self, project_name, repository_name, **kwargs):  # noqa: E501
         """List artifacts  # noqa: E501
 
         List artifacts under the specific project and repository. Except the basic properties, the other supported queries in \"q\" includes \"tags=*\" to list only tagged artifacts, \"tags=nil\" to list only untagged artifacts, \"tags=~v\" to list artifacts whose tag fuzzy matches \"v\", \"tags=v\" to list artifact whose tag exactly matches \"v\", \"labels=(id1, id2)\" to list artifacts that both labels with id1 and id2 are added to  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -1283,109 +1562,144 @@
         :param bool with_immutable_status: Specify whether the immutable status is included inside the tags of the returning artifacts. Only works when setting \"with_immutable_status=true\"
         :param bool with_accessory: Specify whether the accessories are included of the returning artifacts. Only works when setting \"with_accessory=true\"
         :return: list[Artifact]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'x_request_id', 'q', 'sort', 'page', 'page_size', 'x_accept_vulnerabilities', 'with_tag', 'with_label', 'with_scan_overview', 'with_signature', 'with_immutable_status', 'with_accessory']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+            "x_accept_vulnerabilities",
+            "with_tag",
+            "with_label",
+            "with_scan_overview",
+            "with_signature",
+            "with_immutable_status",
+            "with_accessory",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_artifacts" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_artifacts" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_artifacts`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_artifacts`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `list_artifacts`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_artifacts`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_artifacts`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `list_artifacts`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_artifacts`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_artifacts`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'with_tag' in params:
-            query_params.append(('with_tag', params['with_tag']))  # noqa: E501
-        if 'with_label' in params:
-            query_params.append(('with_label', params['with_label']))  # noqa: E501
-        if 'with_scan_overview' in params:
-            query_params.append(('with_scan_overview', params['with_scan_overview']))  # noqa: E501
-        if 'with_signature' in params:
-            query_params.append(('with_signature', params['with_signature']))  # noqa: E501
-        if 'with_immutable_status' in params:
-            query_params.append(('with_immutable_status', params['with_immutable_status']))  # noqa: E501
-        if 'with_accessory' in params:
-            query_params.append(('with_accessory', params['with_accessory']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "with_tag" in params:
+            query_params.append(("with_tag", params["with_tag"]))  # noqa: E501
+        if "with_label" in params:
+            query_params.append(("with_label", params["with_label"]))  # noqa: E501
+        if "with_scan_overview" in params:
+            query_params.append(("with_scan_overview", params["with_scan_overview"]))  # noqa: E501
+        if "with_signature" in params:
+            query_params.append(("with_signature", params["with_signature"]))  # noqa: E501
+        if "with_immutable_status" in params:
+            query_params.append(
+                ("with_immutable_status", params["with_immutable_status"])
+            )  # noqa: E501
+        if "with_accessory" in params:
+            query_params.append(("with_accessory", params["with_accessory"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_accept_vulnerabilities' in params:
-            header_params['X-Accept-Vulnerabilities'] = params['x_accept_vulnerabilities']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_accept_vulnerabilities" in params:
+            header_params["X-Accept-Vulnerabilities"] = params[
+                "x_accept_vulnerabilities"
+            ]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Artifact]',  # noqa: E501
+            response_type="list[Artifact]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_tags(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """List tags  # noqa: E501
 
         List tags of the specific artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1403,22 +1717,28 @@
         :param int page_size: The size of per page
         :param bool with_signature: Specify whether the signature is included inside the returning tags
         :param bool with_immutable_status: Specify whether the immutable status is included inside the returning tags
         :return: list[Tag]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_tags_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_tags_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_tags_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.list_tags_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_tags_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def list_tags_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """List tags  # noqa: E501
 
         List tags of the specific artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_tags_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -1435,107 +1755,141 @@
         :param bool with_signature: Specify whether the signature is included inside the returning tags
         :param bool with_immutable_status: Specify whether the immutable status is included inside the returning tags
         :return: list[Tag]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id', 'q', 'sort', 'page', 'page_size', 'with_signature', 'with_immutable_status']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+            "with_signature",
+            "with_immutable_status",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_tags" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_tags" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_tags`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_tags`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `list_tags`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `list_tags`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `list_tags`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_tags`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_tags`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `list_tags`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_tags`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_tags`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'with_signature' in params:
-            query_params.append(('with_signature', params['with_signature']))  # noqa: E501
-        if 'with_immutable_status' in params:
-            query_params.append(('with_immutable_status', params['with_immutable_status']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "with_signature" in params:
+            query_params.append(("with_signature", params["with_signature"]))  # noqa: E501
+        if "with_immutable_status" in params:
+            query_params.append(
+                ("with_immutable_status", params["with_immutable_status"])
+            )  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Tag]',  # noqa: E501
+            response_type="list[Tag]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def remove_label(self, project_name, repository_name, reference, label_id, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def remove_label(
+        self, project_name, repository_name, reference, label_id, **kwargs
+    ):  # noqa: E501
         """Remove label from artifact  # noqa: E501
 
         Remove the label from the specified artiact.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_label(project_name, repository_name, reference, label_id, async_req=True)
         >>> result = thread.get()
@@ -1546,22 +1900,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param int label_id: The ID of the label that removed from the artifact. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.remove_label_with_http_info(project_name, repository_name, reference, label_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.remove_label_with_http_info(
+                project_name, repository_name, reference, label_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.remove_label_with_http_info(project_name, repository_name, reference, label_id, **kwargs)  # noqa: E501
+            (data) = self.remove_label_with_http_info(
+                project_name, repository_name, reference, label_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def remove_label_with_http_info(self, project_name, repository_name, reference, label_id, **kwargs):  # noqa: E501
+    def remove_label_with_http_info(
+        self, project_name, repository_name, reference, label_id, **kwargs
+    ):  # noqa: E501
         """Remove label from artifact  # noqa: E501
 
         Remove the label from the specified artiact.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_label_with_http_info(project_name, repository_name, reference, label_id, async_req=True)
         >>> result = thread.get()
@@ -1573,90 +1933,114 @@
         :param int label_id: The ID of the label that removed from the artifact. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'label_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "label_id",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method remove_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method remove_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `remove_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `remove_label`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `remove_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `remove_label`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `remove_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `remove_label`"
+            )  # noqa: E501
         # verify the required parameter 'label_id' is set
-        if self.api_client.client_side_validation and ('label_id' not in params or
-                                                       params['label_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label_id` when calling `remove_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `remove_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label_id" not in params or params["label_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label_id` when calling `remove_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `remove_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
-        if 'label_id' in params:
-            path_params['label_id'] = params['label_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
+        if "label_id" in params:
+            path_params["label_id"] = params["label_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels/{label_id}', 'DELETE',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels/{label_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/auditlog_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/auditlog_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -48,16 +48,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[AuditLog]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_audit_logs_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_audit_logs_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_audit_logs_with_http_info(self, **kwargs):  # noqa: E501
         """Get recent logs of the projects which the user is a member of  # noqa: E501
@@ -75,76 +75,86 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[AuditLog]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_audit_logs" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_audit_logs" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_audit_logs`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_audit_logs`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_audit_logs`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_audit_logs`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/audit-logs', 'GET',
+            "/audit-logs",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[AuditLog]',  # noqa: E501
+            response_type="list[AuditLog]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/configure_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/configure_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ConfigurationsResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_configurations_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_configurations_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_configurations_with_http_info(self, **kwargs):  # noqa: E501
         """Get system configurations.  # noqa: E501
@@ -67,73 +67,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ConfigurationsResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_configurations" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_configurations" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_configurations`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_configurations`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/configurations', 'GET',
+            "/configurations",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ConfigurationsResponse',  # noqa: E501
+            response_type="ConfigurationsResponse",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_internalconfig(self, **kwargs):  # noqa: E501
         """Get internal configurations.  # noqa: E501
 
         This endpoint is for retrieving system configurations that only provides for internal api call.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -142,16 +148,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: InternalConfigurationsResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_internalconfig_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_internalconfig_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_internalconfig_with_http_info(self, **kwargs):  # noqa: E501
         """Get internal configurations.  # noqa: E501
@@ -165,73 +171,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: InternalConfigurationsResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_internalconfig" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_internalconfig" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_internalconfig`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_internalconfig`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/internalconfig', 'GET',
+            "/internalconfig",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='InternalConfigurationsResponse',  # noqa: E501
+            response_type="InternalConfigurationsResponse",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_configurations(self, configurations, **kwargs):  # noqa: E501
         """Modify system configurations.  # noqa: E501
 
         This endpoint is for modifying system configurations that only provides for admin user.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -241,19 +253,21 @@
         :param async_req bool
         :param Configurations configurations: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_configurations_with_http_info(configurations, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_configurations_with_http_info(configurations, **kwargs)  # noqa: E501
+            (data) = self.update_configurations_with_http_info(
+                configurations, **kwargs
+            )  # noqa: E501
             return data
 
     def update_configurations_with_http_info(self, configurations, **kwargs):  # noqa: E501
         """Modify system configurations.  # noqa: E501
 
         This endpoint is for modifying system configurations that only provides for admin user.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -265,72 +279,82 @@
         :param Configurations configurations: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['configurations', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["configurations", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_configurations" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'configurations' is set
-        if self.api_client.client_side_validation and ('configurations' not in params or
-                                                       params['configurations'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `configurations` when calling `update_configurations`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_configurations`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "configurations" not in params or params["configurations"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `configurations` when calling `update_configurations`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_configurations`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'configurations' in params:
-            body_params = params['configurations']
+        if "configurations" in params:
+            body_params = params["configurations"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/configurations', 'PUT',
+            "/configurations",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/gc_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/gc_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Schedule schedule: Updates of gc's schedule. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_gc_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.create_gc_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def create_gc_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Create a gc schedule.  # noqa: E501
@@ -69,79 +69,88 @@
         :param Schedule schedule: Updates of gc's schedule. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_gc_schedule" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_gc_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `create_gc_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_gc_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `create_gc_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_gc_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/schedule', 'POST',
+            "/system/gc/schedule",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_gc(self, gc_id, **kwargs):  # noqa: E501
         """Get gc status.  # noqa: E501
 
         This endpoint let user get gc status filtered by specific ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: GCHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_gc_with_http_info(gc_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_gc_with_http_info(gc_id, **kwargs)  # noqa: E501
             return data
 
     def get_gc_with_http_info(self, gc_id, **kwargs):  # noqa: E501
         """Get gc status.  # noqa: E501
@@ -175,79 +184,86 @@
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: GCHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['gc_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["gc_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_gc" % key
-                )
+                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_gc" % key)
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'gc_id' is set
-        if self.api_client.client_side_validation and ('gc_id' not in params or
-                                                       params['gc_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `gc_id` when calling `get_gc`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_gc`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "gc_id" not in params or params["gc_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `gc_id` when calling `get_gc`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_gc`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'gc_id' in params:
-            path_params['gc_id'] = params['gc_id']  # noqa: E501
+        if "gc_id" in params:
+            path_params["gc_id"] = params["gc_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/{gc_id}', 'GET',
+            "/system/gc/{gc_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GCHistory',  # noqa: E501
+            response_type="GCHistory",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_gc_history(self, **kwargs):  # noqa: E501
         """Get gc results.  # noqa: E501
 
         This endpoint let user get gc execution history.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -260,16 +276,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[GCHistory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_gc_history_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_gc_history_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_gc_history_with_http_info(self, **kwargs):  # noqa: E501
         """Get gc results.  # noqa: E501
@@ -287,83 +303,93 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[GCHistory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_gc_history" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_gc_history" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_gc_history`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `get_gc_history`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_gc_history`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `get_gc_history`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc', 'GET',
+            "/system/gc",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[GCHistory]',  # noqa: E501
+            response_type="list[GCHistory]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_gc_log(self, gc_id, **kwargs):  # noqa: E501
         """Get gc job log.  # noqa: E501
 
         This endpoint let user get gc job logs filtered by specific ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -373,16 +399,16 @@
         :param async_req bool
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_gc_log_with_http_info(gc_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_gc_log_with_http_info(gc_id, **kwargs)  # noqa: E501
             return data
 
     def get_gc_log_with_http_info(self, gc_id, **kwargs):  # noqa: E501
         """Get gc job log.  # noqa: E501
@@ -397,79 +423,86 @@
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['gc_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["gc_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_gc_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_gc_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'gc_id' is set
-        if self.api_client.client_side_validation and ('gc_id' not in params or
-                                                       params['gc_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `gc_id` when calling `get_gc_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_gc_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "gc_id" not in params or params["gc_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `gc_id` when calling `get_gc_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_gc_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'gc_id' in params:
-            path_params['gc_id'] = params['gc_id']  # noqa: E501
+        if "gc_id" in params:
+            path_params["gc_id"] = params["gc_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/{gc_id}/log', 'GET',
+            "/system/gc/{gc_id}/log",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_gc_schedule(self, **kwargs):  # noqa: E501
         """Get gc's schedule.  # noqa: E501
 
         This endpoint is for get schedule of gc job.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -478,16 +511,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: GCHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_gc_schedule_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_gc_schedule_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_gc_schedule_with_http_info(self, **kwargs):  # noqa: E501
         """Get gc's schedule.  # noqa: E501
@@ -501,73 +534,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: GCHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_gc_schedule" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_gc_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_gc_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_gc_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/schedule', 'GET',
+            "/system/gc/schedule",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GCHistory',  # noqa: E501
+            response_type="GCHistory",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_gc(self, gc_id, **kwargs):  # noqa: E501
         """Stop the specific GC execution  # noqa: E501
 
         Stop the GC execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -577,16 +616,16 @@
         :param async_req bool
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_gc_with_http_info(gc_id, **kwargs)  # noqa: E501
         else:
             (data) = self.stop_gc_with_http_info(gc_id, **kwargs)  # noqa: E501
             return data
 
     def stop_gc_with_http_info(self, gc_id, **kwargs):  # noqa: E501
         """Stop the specific GC execution  # noqa: E501
@@ -601,79 +640,88 @@
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['gc_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["gc_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_gc" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_gc" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'gc_id' is set
-        if self.api_client.client_side_validation and ('gc_id' not in params or
-                                                       params['gc_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `gc_id` when calling `stop_gc`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_gc`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "gc_id" not in params or params["gc_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `gc_id` when calling `stop_gc`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_gc`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'gc_id' in params:
-            path_params['gc_id'] = params['gc_id']  # noqa: E501
+        if "gc_id" in params:
+            path_params["gc_id"] = params["gc_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/{gc_id}', 'PUT',
+            "/system/gc/{gc_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_gc_schedule(self, schedule, **kwargs):  # noqa: E501
         """Update gc's schedule.  # noqa: E501
 
         This endpoint is for update gc schedule.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -683,16 +731,16 @@
         :param async_req bool
         :param Schedule schedule: Updates of gc's schedule. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_gc_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.update_gc_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def update_gc_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Update gc's schedule.  # noqa: E501
@@ -707,72 +755,81 @@
         :param Schedule schedule: Updates of gc's schedule. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_gc_schedule" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_gc_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `update_gc_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_gc_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `update_gc_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_gc_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/schedule', 'PUT',
+            "/system/gc/schedule",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/health_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/health_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: OverallHealthStatus
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_health_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_health_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_health_with_http_info(self, **kwargs):  # noqa: E501
         """Check the status of Harbor components  # noqa: E501
@@ -67,66 +67,72 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: OverallHealthStatus
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_health" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_health" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_health`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_health`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/health', 'GET',
+            "/health",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='OverallHealthStatus',  # noqa: E501
+            response_type="OverallHealthStatus",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/icon_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/icon_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param str digest: The digest of the resource (required)
         :param str x_request_id: An unique ID for the request
         :return: Icon
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_icon_with_http_info(digest, **kwargs)  # noqa: E501
         else:
             (data) = self.get_icon_with_http_info(digest, **kwargs)  # noqa: E501
             return data
 
     def get_icon_with_http_info(self, digest, **kwargs):  # noqa: E501
         """Get artifact icon  # noqa: E501
@@ -69,72 +69,81 @@
         :param str digest: The digest of the resource (required)
         :param str x_request_id: An unique ID for the request
         :return: Icon
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['digest', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["digest", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_icon" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_icon" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'digest' is set
-        if self.api_client.client_side_validation and ('digest' not in params or
-                                                       params['digest'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `digest` when calling `get_icon`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_icon`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "digest" not in params or params["digest"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `digest` when calling `get_icon`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_icon`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'digest' in params:
-            path_params['digest'] = params['digest']  # noqa: E501
+        if "digest" in params:
+            path_params["digest"] = params["digest"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/icons/{digest}', 'GET',
+            "/icons/{digest}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Icon',  # noqa: E501
+            response_type="Icon",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/immutable_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/immutable_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -47,22 +47,28 @@
         :param ImmutableRule immutable_rule: (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_immu_rule_with_http_info(project_name_or_id, immutable_rule, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_immu_rule_with_http_info(project_name_or_id, immutable_rule, **kwargs)  # noqa: E501
+            (data) = self.create_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule, **kwargs
+            )  # noqa: E501
             return data
 
-    def create_immu_rule_with_http_info(self, project_name_or_id, immutable_rule, **kwargs):  # noqa: E501
+    def create_immu_rule_with_http_info(
+        self, project_name_or_id, immutable_rule, **kwargs
+    ):  # noqa: E501
         """Add an immutable tag rule to current project  # noqa: E501
 
         This endpoint add an immutable tag rule to the project   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_immu_rule_with_http_info(project_name_or_id, immutable_rule, async_req=True)
         >>> result = thread.get()
@@ -73,87 +79,104 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'immutable_rule', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "immutable_rule",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_immu_rule" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_immu_rule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `create_immu_rule`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `create_immu_rule`"
+            )  # noqa: E501
         # verify the required parameter 'immutable_rule' is set
-        if self.api_client.client_side_validation and ('immutable_rule' not in params or
-                                                       params['immutable_rule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `immutable_rule` when calling `create_immu_rule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_immu_rule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "immutable_rule" not in params or params["immutable_rule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `immutable_rule` when calling `create_immu_rule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_immu_rule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'immutable_rule' in params:
-            body_params = params['immutable_rule']
+        if "immutable_rule" in params:
+            body_params = params["immutable_rule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/immutabletagrules', 'POST',
+            "/projects/{project_name_or_id}/immutabletagrules",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_immu_rule(self, project_name_or_id, immutable_rule_id, **kwargs):  # noqa: E501
         """Delete the immutable tag rule.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_immu_rule(project_name_or_id, immutable_rule_id, async_req=True)
@@ -164,22 +187,28 @@
         :param int immutable_rule_id: The ID of the immutable rule (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, **kwargs)  # noqa: E501
+            (data) = self.delete_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_immu_rule_with_http_info(self, project_name_or_id, immutable_rule_id, **kwargs):  # noqa: E501
+    def delete_immu_rule_with_http_info(
+        self, project_name_or_id, immutable_rule_id, **kwargs
+    ):  # noqa: E501
         """Delete the immutable tag rule.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, async_req=True)
         >>> result = thread.get()
 
@@ -189,87 +218,104 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'immutable_rule_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "immutable_rule_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_immu_rule" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_immu_rule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_immu_rule`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_immu_rule`"
+            )  # noqa: E501
         # verify the required parameter 'immutable_rule_id' is set
-        if self.api_client.client_side_validation and ('immutable_rule_id' not in params or
-                                                       params['immutable_rule_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `immutable_rule_id` when calling `delete_immu_rule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_immu_rule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "immutable_rule_id" not in params or params["immutable_rule_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `immutable_rule_id` when calling `delete_immu_rule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_immu_rule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'immutable_rule_id' in params:
-            path_params['immutable_rule_id'] = params['immutable_rule_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "immutable_rule_id" in params:
+            path_params["immutable_rule_id"] = params["immutable_rule_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}', 'DELETE',
+            "/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_immu_rules(self, project_name_or_id, **kwargs):  # noqa: E501
         """List all immutable tag rules of current project  # noqa: E501
 
         This endpoint returns the immutable tag rules of a project   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -284,16 +330,16 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[ImmutableRule]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_immu_rules_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
             (data) = self.list_immu_rules_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
     def list_immu_rules_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """List all immutable tag rules of current project  # noqa: E501
@@ -313,93 +359,116 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[ImmutableRule]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_immu_rules" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_immu_rules" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_immu_rules`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_immu_rules`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_immu_rules`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_immu_rules`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_immu_rules`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_immu_rules`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/immutabletagrules', 'GET',
+            "/projects/{project_name_or_id}/immutabletagrules",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ImmutableRule]',  # noqa: E501
+            response_type="list[ImmutableRule]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_immu_rule(self, project_name_or_id, immutable_rule_id, immutable_rule, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def update_immu_rule(
+        self, project_name_or_id, immutable_rule_id, immutable_rule, **kwargs
+    ):  # noqa: E501
         """Update the immutable tag rule or enable or disable the rule  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_immu_rule(project_name_or_id, immutable_rule_id, immutable_rule, async_req=True)
         >>> result = thread.get()
 
@@ -409,22 +478,28 @@
         :param ImmutableRule immutable_rule: (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, immutable_rule, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule_id, immutable_rule, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, immutable_rule, **kwargs)  # noqa: E501
+            (data) = self.update_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule_id, immutable_rule, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_immu_rule_with_http_info(self, project_name_or_id, immutable_rule_id, immutable_rule, **kwargs):  # noqa: E501
+    def update_immu_rule_with_http_info(
+        self, project_name_or_id, immutable_rule_id, immutable_rule, **kwargs
+    ):  # noqa: E501
         """Update the immutable tag rule or enable or disable the rule  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, immutable_rule, async_req=True)
         >>> result = thread.get()
 
@@ -435,86 +510,107 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'immutable_rule_id', 'immutable_rule', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "immutable_rule_id",
+            "immutable_rule",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_immu_rule" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_immu_rule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_immu_rule`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_immu_rule`"
+            )  # noqa: E501
         # verify the required parameter 'immutable_rule_id' is set
-        if self.api_client.client_side_validation and ('immutable_rule_id' not in params or
-                                                       params['immutable_rule_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `immutable_rule_id` when calling `update_immu_rule`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "immutable_rule_id" not in params or params["immutable_rule_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `immutable_rule_id` when calling `update_immu_rule`"
+            )  # noqa: E501
         # verify the required parameter 'immutable_rule' is set
-        if self.api_client.client_side_validation and ('immutable_rule' not in params or
-                                                       params['immutable_rule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `immutable_rule` when calling `update_immu_rule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_immu_rule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "immutable_rule" not in params or params["immutable_rule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `immutable_rule` when calling `update_immu_rule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_immu_rule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'immutable_rule_id' in params:
-            path_params['immutable_rule_id'] = params['immutable_rule_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "immutable_rule_id" in params:
+            path_params["immutable_rule_id"] = params["immutable_rule_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'immutable_rule' in params:
-            body_params = params['immutable_rule']
+        if "immutable_rule" in params:
+            body_params = params["immutable_rule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}', 'PUT',
+            "/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/jobservice_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/jobservice_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -46,19 +46,23 @@
         :param str job_type: The type of the job. 'all' stands for all job types (required)
         :param ActionRequest action_request: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.action_pending_jobs_with_http_info(job_type, action_request, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.action_pending_jobs_with_http_info(
+                job_type, action_request, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.action_pending_jobs_with_http_info(job_type, action_request, **kwargs)  # noqa: E501
+            (data) = self.action_pending_jobs_with_http_info(
+                job_type, action_request, **kwargs
+            )  # noqa: E501
             return data
 
     def action_pending_jobs_with_http_info(self, job_type, action_request, **kwargs):  # noqa: E501
         """stop and clean, pause, resume pending jobs in the queue  # noqa: E501
 
         stop and clean, pause, resume pending jobs in the queue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -71,85 +75,97 @@
         :param ActionRequest action_request: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['job_type', 'action_request', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["job_type", "action_request", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method action_pending_jobs" % key
+                    "Got an unexpected keyword argument '%s'" " to method action_pending_jobs" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'job_type' is set
-        if self.api_client.client_side_validation and ('job_type' not in params or
-                                                       params['job_type'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `job_type` when calling `action_pending_jobs`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "job_type" not in params or params["job_type"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `job_type` when calling `action_pending_jobs`"
+            )  # noqa: E501
         # verify the required parameter 'action_request' is set
-        if self.api_client.client_side_validation and ('action_request' not in params or
-                                                       params['action_request'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `action_request` when calling `action_pending_jobs`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `action_pending_jobs`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "action_request" not in params or params["action_request"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `action_request` when calling `action_pending_jobs`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `action_pending_jobs`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'job_type' in params:
-            path_params['job_type'] = params['job_type']  # noqa: E501
+        if "job_type" in params:
+            path_params["job_type"] = params["job_type"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'action_request' in params:
-            body_params = params['action_request']
+        if "action_request" in params:
+            body_params = params["action_request"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/queues/{job_type}', 'PUT',
+            "/jobservice/queues/{job_type}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_worker_pools(self, **kwargs):  # noqa: E501
         """Get worker pools  # noqa: E501
 
         Get worker pools  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -158,16 +174,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[WorkerPool]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_worker_pools_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_worker_pools_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_worker_pools_with_http_info(self, **kwargs):  # noqa: E501
         """Get worker pools  # noqa: E501
@@ -181,73 +197,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[WorkerPool]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_worker_pools" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_worker_pools" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_worker_pools`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_worker_pools`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/pools', 'GET',
+            "/jobservice/pools",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[WorkerPool]',  # noqa: E501
+            response_type="list[WorkerPool]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_workers(self, pool_id, **kwargs):  # noqa: E501
         """Get workers  # noqa: E501
 
         Get workers in current pool  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +279,16 @@
         :param async_req bool
         :param str pool_id: The name of the pool. 'all' stands for all pools (required)
         :param str x_request_id: An unique ID for the request
         :return: list[Worker]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_workers_with_http_info(pool_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_workers_with_http_info(pool_id, **kwargs)  # noqa: E501
             return data
 
     def get_workers_with_http_info(self, pool_id, **kwargs):  # noqa: E501
         """Get workers  # noqa: E501
@@ -281,79 +303,88 @@
         :param str pool_id: The name of the pool. 'all' stands for all pools (required)
         :param str x_request_id: An unique ID for the request
         :return: list[Worker]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['pool_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["pool_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_workers" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_workers" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'pool_id' is set
-        if self.api_client.client_side_validation and ('pool_id' not in params or
-                                                       params['pool_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `pool_id` when calling `get_workers`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_workers`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "pool_id" not in params or params["pool_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `pool_id` when calling `get_workers`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_workers`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'pool_id' in params:
-            path_params['pool_id'] = params['pool_id']  # noqa: E501
+        if "pool_id" in params:
+            path_params["pool_id"] = params["pool_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/pools/{pool_id}/workers', 'GET',
+            "/jobservice/pools/{pool_id}/workers",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Worker]',  # noqa: E501
+            response_type="list[Worker]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_job_queues(self, **kwargs):  # noqa: E501
         """list job queues  # noqa: E501
 
         list job queue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -362,16 +393,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[JobQueue]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_job_queues_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_job_queues_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_job_queues_with_http_info(self, **kwargs):  # noqa: E501
         """list job queues  # noqa: E501
@@ -385,73 +416,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[JobQueue]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_job_queues" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_job_queues" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_job_queues`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_job_queues`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/queues', 'GET',
+            "/jobservice/queues",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[JobQueue]',  # noqa: E501
+            response_type="list[JobQueue]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_running_job(self, job_id, **kwargs):  # noqa: E501
         """Stop running job  # noqa: E501
 
         Stop running job  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -461,16 +498,16 @@
         :param async_req bool
         :param str job_id: The id of the job. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_running_job_with_http_info(job_id, **kwargs)  # noqa: E501
         else:
             (data) = self.stop_running_job_with_http_info(job_id, **kwargs)  # noqa: E501
             return data
 
     def stop_running_job_with_http_info(self, job_id, **kwargs):  # noqa: E501
         """Stop running job  # noqa: E501
@@ -485,72 +522,81 @@
         :param str job_id: The id of the job. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['job_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["job_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_running_job" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_running_job" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'job_id' is set
-        if self.api_client.client_side_validation and ('job_id' not in params or
-                                                       params['job_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `job_id` when calling `stop_running_job`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_running_job`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "job_id" not in params or params["job_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `job_id` when calling `stop_running_job`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_running_job`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'job_id' in params:
-            path_params['job_id'] = params['job_id']  # noqa: E501
+        if "job_id" in params:
+            path_params["job_id"] = params["job_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/jobs/{job_id}', 'PUT',
+            "/jobservice/jobs/{job_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/label_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/label_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Label label: The json object of label. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_label_with_http_info(label, **kwargs)  # noqa: E501
         else:
             (data) = self.create_label_with_http_info(label, **kwargs)  # noqa: E501
             return data
 
     def create_label_with_http_info(self, label, **kwargs):  # noqa: E501
         """Post creates a label  # noqa: E501
@@ -69,79 +69,88 @@
         :param Label label: The json object of label. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['label', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["label", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'label' is set
-        if self.api_client.client_side_validation and ('label' not in params or
-                                                       params['label'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label` when calling `create_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label" not in params or params["label"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label` when calling `create_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'label' in params:
-            body_params = params['label']
+        if "label" in params:
+            body_params = params["label"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels', 'POST',
+            "/labels",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_label(self, label_id, **kwargs):  # noqa: E501
         """Delete the label specified by ID.  # noqa: E501
 
         Delete the label specified by ID.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int label_id: Label ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_label_with_http_info(label_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_label_with_http_info(label_id, **kwargs)  # noqa: E501
             return data
 
     def delete_label_with_http_info(self, label_id, **kwargs):  # noqa: E501
         """Delete the label specified by ID.  # noqa: E501
@@ -175,79 +184,88 @@
         :param int label_id: Label ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['label_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["label_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'label_id' is set
-        if self.api_client.client_side_validation and ('label_id' not in params or
-                                                       params['label_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label_id` when calling `delete_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label_id" not in params or params["label_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label_id` when calling `delete_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'label_id' in params:
-            path_params['label_id'] = params['label_id']  # noqa: E501
+        if "label_id" in params:
+            path_params["label_id"] = params["label_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels/{label_id}', 'DELETE',
+            "/labels/{label_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_label_by_id(self, label_id, **kwargs):  # noqa: E501
         """Get the label specified by ID.  # noqa: E501
 
         This endpoint let user get the label by specific ID.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +275,16 @@
         :param async_req bool
         :param int label_id: Label ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Label
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_label_by_id_with_http_info(label_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_label_by_id_with_http_info(label_id, **kwargs)  # noqa: E501
             return data
 
     def get_label_by_id_with_http_info(self, label_id, **kwargs):  # noqa: E501
         """Get the label specified by ID.  # noqa: E501
@@ -281,79 +299,88 @@
         :param int label_id: Label ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Label
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['label_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["label_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_label_by_id" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_label_by_id" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'label_id' is set
-        if self.api_client.client_side_validation and ('label_id' not in params or
-                                                       params['label_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label_id` when calling `get_label_by_id`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_label_by_id`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label_id" not in params or params["label_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label_id` when calling `get_label_by_id`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_label_by_id`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'label_id' in params:
-            path_params['label_id'] = params['label_id']  # noqa: E501
+        if "label_id" in params:
+            path_params["label_id"] = params["label_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels/{label_id}', 'GET',
+            "/labels/{label_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Label',  # noqa: E501
+            response_type="Label",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_labels(self, **kwargs):  # noqa: E501
         """List labels according to the query strings.  # noqa: E501
 
         This endpoint let user list labels by name, scope and project_id   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -369,16 +396,16 @@
         :param str name: The label name.
         :param str scope: The label scope. Valid values are g and p. g for global labels and p for project labels.
         :param int project_id: Relevant project ID, required when scope is p.
         :return: list[Label]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_labels_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_labels_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_labels_with_http_info(self, **kwargs):  # noqa: E501
         """List labels according to the query strings.  # noqa: E501
@@ -399,89 +426,108 @@
         :param str scope: The label scope. Valid values are g and p. g for global labels and p for project labels.
         :param int project_id: Relevant project ID, required when scope is p.
         :return: list[Label]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size', 'name', 'scope', 'project_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+            "name",
+            "scope",
+            "project_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_labels" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_labels" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_labels`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_labels`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_labels`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_labels`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'name' in params:
-            query_params.append(('name', params['name']))  # noqa: E501
-        if 'scope' in params:
-            query_params.append(('scope', params['scope']))  # noqa: E501
-        if 'project_id' in params:
-            query_params.append(('project_id', params['project_id']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "name" in params:
+            query_params.append(("name", params["name"]))  # noqa: E501
+        if "scope" in params:
+            query_params.append(("scope", params["scope"]))  # noqa: E501
+        if "project_id" in params:
+            query_params.append(("project_id", params["project_id"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels', 'GET',
+            "/labels",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Label]',  # noqa: E501
+            response_type="list[Label]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_label(self, label_id, label, **kwargs):  # noqa: E501
         """Update the label properties.  # noqa: E501
 
         This endpoint let user update label properties.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -492,16 +538,16 @@
         :param int label_id: Label ID (required)
         :param Label label: The updated label json object. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_label_with_http_info(label_id, label, **kwargs)  # noqa: E501
         else:
             (data) = self.update_label_with_http_info(label_id, label, **kwargs)  # noqa: E501
             return data
 
     def update_label_with_http_info(self, label_id, label, **kwargs):  # noqa: E501
         """Update the label properties.  # noqa: E501
@@ -517,78 +563,90 @@
         :param Label label: The updated label json object. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['label_id', 'label', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["label_id", "label", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'label_id' is set
-        if self.api_client.client_side_validation and ('label_id' not in params or
-                                                       params['label_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label_id` when calling `update_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label_id" not in params or params["label_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label_id` when calling `update_label`"
+            )  # noqa: E501
         # verify the required parameter 'label' is set
-        if self.api_client.client_side_validation and ('label' not in params or
-                                                       params['label'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label` when calling `update_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label" not in params or params["label"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label` when calling `update_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'label_id' in params:
-            path_params['label_id'] = params['label_id']  # noqa: E501
+        if "label_id" in params:
+            path_params["label_id"] = params["label_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'label' in params:
-            body_params = params['label']
+        if "label" in params:
+            body_params = params["label"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels/{label_id}', 'PUT',
+            "/labels/{label_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/ldap_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/ldap_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param LdapImportUsers uid_list: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.import_ldap_user_with_http_info(uid_list, **kwargs)  # noqa: E501
         else:
             (data) = self.import_ldap_user_with_http_info(uid_list, **kwargs)  # noqa: E501
             return data
 
     def import_ldap_user_with_http_info(self, uid_list, **kwargs):  # noqa: E501
         """Import selected available ldap users.  # noqa: E501
@@ -69,79 +69,88 @@
         :param LdapImportUsers uid_list: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['uid_list', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["uid_list", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method import_ldap_user" % key
+                    "Got an unexpected keyword argument '%s'" " to method import_ldap_user" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'uid_list' is set
-        if self.api_client.client_side_validation and ('uid_list' not in params or
-                                                       params['uid_list'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `uid_list` when calling `import_ldap_user`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `import_ldap_user`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "uid_list" not in params or params["uid_list"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `uid_list` when calling `import_ldap_user`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `import_ldap_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'uid_list' in params:
-            body_params = params['uid_list']
+        if "uid_list" in params:
+            body_params = params["uid_list"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ldap/users/import', 'POST',
+            "/ldap/users/import",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def ping_ldap(self, **kwargs):  # noqa: E501
         """Ping available ldap service.  # noqa: E501
 
         This endpoint ping the available ldap service for test related configuration parameters.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param LdapConf ldapconf: ldap configuration. support input ldap service configuration. If it is a empty request, will load current configuration from the system.
         :return: LdapPingResult
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_ldap_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.ping_ldap_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def ping_ldap_with_http_info(self, **kwargs):  # noqa: E501
         """Ping available ldap service.  # noqa: E501
@@ -175,75 +184,81 @@
         :param str x_request_id: An unique ID for the request
         :param LdapConf ldapconf: ldap configuration. support input ldap service configuration. If it is a empty request, will load current configuration from the system.
         :return: LdapPingResult
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'ldapconf']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "ldapconf"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_ldap" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_ldap" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_ldap`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_ldap`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'ldapconf' in params:
-            body_params = params['ldapconf']
+        if "ldapconf" in params:
+            body_params = params["ldapconf"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ldap/ping', 'POST',
+            "/ldap/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='LdapPingResult',  # noqa: E501
+            response_type="LdapPingResult",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def search_ldap_group(self, **kwargs):  # noqa: E501
         """Search available ldap groups.  # noqa: E501
 
         This endpoint searches the available ldap groups based on related configuration parameters. support to search by groupname or groupdn.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -254,16 +269,16 @@
         :param str x_request_id: An unique ID for the request
         :param str groupname: Ldap group name
         :param str groupdn: The LDAP group DN
         :return: list[UserGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.search_ldap_group_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.search_ldap_group_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def search_ldap_group_with_http_info(self, **kwargs):  # noqa: E501
         """Search available ldap groups.  # noqa: E501
@@ -279,77 +294,83 @@
         :param str groupname: Ldap group name
         :param str groupdn: The LDAP group DN
         :return: list[UserGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'groupname', 'groupdn']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "groupname", "groupdn"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search_ldap_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method search_ldap_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search_ldap_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search_ldap_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'groupname' in params:
-            query_params.append(('groupname', params['groupname']))  # noqa: E501
-        if 'groupdn' in params:
-            query_params.append(('groupdn', params['groupdn']))  # noqa: E501
+        if "groupname" in params:
+            query_params.append(("groupname", params["groupname"]))  # noqa: E501
+        if "groupdn" in params:
+            query_params.append(("groupdn", params["groupdn"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ldap/groups/search', 'GET',
+            "/ldap/groups/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[UserGroup]',  # noqa: E501
+            response_type="list[UserGroup]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def search_ldap_user(self, **kwargs):  # noqa: E501
         """Search available ldap users.  # noqa: E501
 
         This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -359,16 +380,16 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param str username: Registered user ID
         :return: list[LdapUser]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.search_ldap_user_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.search_ldap_user_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def search_ldap_user_with_http_info(self, **kwargs):  # noqa: E501
         """Search available ldap users.  # noqa: E501
@@ -383,68 +404,74 @@
         :param str x_request_id: An unique ID for the request
         :param str username: Registered user ID
         :return: list[LdapUser]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'username']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "username"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search_ldap_user" % key
+                    "Got an unexpected keyword argument '%s'" " to method search_ldap_user" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search_ldap_user`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search_ldap_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'username' in params:
-            query_params.append(('username', params['username']))  # noqa: E501
+        if "username" in params:
+            query_params.append(("username", params["username"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ldap/users/search', 'GET',
+            "/ldap/users/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[LdapUser]',  # noqa: E501
+            response_type="list[LdapUser]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/member_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/member_api.py`

 * *Files 15% similar despite different names*

```diff
@@ -47,19 +47,23 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param ProjectMember project_member:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_project_member_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_project_member_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_project_member_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.create_project_member_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def create_project_member_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Create project member  # noqa: E501
 
         Create project member relationship, the member can be one of the user_member and group_member,  The user_member need to specify user_id or username. If the user already exist in harbor DB, specify the user_id,  If does not exist in harbor DB, it will SearchAndOnBoard the user. The group_member need to specify id or ldap_group_dn. If the group already exist in harbor DB. specify the user group's id,  If does not exist, it will SearchAndOnBoard the group.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -73,83 +77,98 @@
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param ProjectMember project_member:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'project_member']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "project_member",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_project_member" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `create_project_member`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_project_member`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `create_project_member`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_project_member`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'project_member' in params:
-            body_params = params['project_member']
+        if "project_member" in params:
+            body_params = params["project_member"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members', 'POST',
+            "/projects/{project_name_or_id}/members",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_project_member(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Delete project member  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_project_member(project_name_or_id, mid, async_req=True)
@@ -160,19 +179,23 @@
         :param int mid: Member ID. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+            (data) = self.delete_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
             return data
 
     def delete_project_member_with_http_info(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Delete project member  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -185,87 +208,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'mid', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "mid",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_project_member" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_project_member`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_project_member`"
+            )  # noqa: E501
         # verify the required parameter 'mid' is set
-        if self.api_client.client_side_validation and ('mid' not in params or
-                                                       params['mid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `mid` when calling `delete_project_member`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_project_member`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "mid" not in params or params["mid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `mid` when calling `delete_project_member`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_project_member`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'mid' in params:
-            path_params['mid'] = params['mid']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "mid" in params:
+            path_params["mid"] = params["mid"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members/{mid}', 'DELETE',
+            "/projects/{project_name_or_id}/members/{mid}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project_member(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Get the project member information  # noqa: E501
 
         Get the project member information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -277,19 +318,23 @@
         :param int mid: The member ID (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectMemberEntity
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+            (data) = self.get_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
             return data
 
     def get_project_member_with_http_info(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Get the project member information  # noqa: E501
 
         Get the project member information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -303,87 +348,104 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectMemberEntity
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'mid', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "mid",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_project_member" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_project_member" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project_member`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project_member`"
+            )  # noqa: E501
         # verify the required parameter 'mid' is set
-        if self.api_client.client_side_validation and ('mid' not in params or
-                                                       params['mid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `mid` when calling `get_project_member`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project_member`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "mid" not in params or params["mid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `mid` when calling `get_project_member`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project_member`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'mid' in params:
-            path_params['mid'] = params['mid']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "mid" in params:
+            path_params["mid"] = params["mid"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members/{mid}', 'GET',
+            "/projects/{project_name_or_id}/members/{mid}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectMemberEntity',  # noqa: E501
+            response_type="ProjectMemberEntity",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_project_members(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get all project member information  # noqa: E501
 
         Get all project member information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -397,19 +459,23 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :param str entityname: The entity name to search.
         :return: list[ProjectMemberEntity]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_project_members_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_project_members_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_project_members_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.list_project_members_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def list_project_members_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get all project member information  # noqa: E501
 
         Get all project member information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -425,89 +491,110 @@
         :param int page_size: The size of per page
         :param str entityname: The entity name to search.
         :return: list[ProjectMemberEntity]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'page', 'page_size', 'entityname']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "page",
+            "page_size",
+            "entityname",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_project_members" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_project_members`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_project_members`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_project_members`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_project_members`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_project_members`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_project_members`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'entityname' in params:
-            query_params.append(('entityname', params['entityname']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "entityname" in params:
+            query_params.append(("entityname", params["entityname"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members', 'GET',
+            "/projects/{project_name_or_id}/members",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ProjectMemberEntity]',  # noqa: E501
+            response_type="list[ProjectMemberEntity]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_project_member(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Update project member  # noqa: E501
 
         Update project member relationship  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -520,19 +607,23 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param RoleRequest role:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+            (data) = self.update_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
             return data
 
     def update_project_member_with_http_info(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Update project member  # noqa: E501
 
         Update project member relationship  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -547,82 +638,101 @@
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param RoleRequest role:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'mid', 'x_request_id', 'x_is_resource_name', 'role']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "mid",
+            "x_request_id",
+            "x_is_resource_name",
+            "role",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_project_member" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_project_member`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_project_member`"
+            )  # noqa: E501
         # verify the required parameter 'mid' is set
-        if self.api_client.client_side_validation and ('mid' not in params or
-                                                       params['mid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `mid` when calling `update_project_member`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_project_member`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "mid" not in params or params["mid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `mid` when calling `update_project_member`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_project_member`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'mid' in params:
-            path_params['mid'] = params['mid']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "mid" in params:
+            path_params["mid"] = params["mid"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'role' in params:
-            body_params = params['role']
+        if "role" in params:
+            body_params = params["role"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members/{mid}', 'PUT',
+            "/projects/{project_name_or_id}/members/{mid}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/oidc_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/oidc_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Endpoint endpoint: Request body for OIDC endpoint to be tested. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_oidc_with_http_info(endpoint, **kwargs)  # noqa: E501
         else:
             (data) = self.ping_oidc_with_http_info(endpoint, **kwargs)  # noqa: E501
             return data
 
     def ping_oidc_with_http_info(self, endpoint, **kwargs):  # noqa: E501
         """Test the OIDC endpoint.  # noqa: E501
@@ -69,72 +69,81 @@
         :param Endpoint endpoint: Request body for OIDC endpoint to be tested. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['endpoint', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["endpoint", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_oidc" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_oidc" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'endpoint' is set
-        if self.api_client.client_side_validation and ('endpoint' not in params or
-                                                       params['endpoint'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `endpoint` when calling `ping_oidc`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_oidc`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "endpoint" not in params or params["endpoint"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `endpoint` when calling `ping_oidc`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_oidc`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'endpoint' in params:
-            body_params = params['endpoint']
+        if "endpoint" in params:
+            body_params = params["endpoint"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/oidc/ping', 'POST',
+            "/system/oidc/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/ping_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/ping_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_ping_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_ping_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_ping_with_http_info(self, **kwargs):  # noqa: E501
         """Ping Harbor to check if it's alive.  # noqa: E501
@@ -67,66 +67,70 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_ping" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_ping" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_ping`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_ping`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ping', 'GET',
+            "/ping",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/preheat_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/preheat_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Instance instance: The JSON object of instance. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_instance_with_http_info(instance, **kwargs)  # noqa: E501
         else:
             (data) = self.create_instance_with_http_info(instance, **kwargs)  # noqa: E501
             return data
 
     def create_instance_with_http_info(self, instance, **kwargs):  # noqa: E501
         """Create p2p provider instances  # noqa: E501
@@ -69,79 +69,88 @@
         :param Instance instance: The JSON object of instance. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['instance', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["instance", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_instance" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_instance" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'instance' is set
-        if self.api_client.client_side_validation and ('instance' not in params or
-                                                       params['instance'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `instance` when calling `create_instance`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_instance`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "instance" not in params or params["instance"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `instance` when calling `create_instance`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_instance`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'instance' in params:
-            body_params = params['instance']
+        if "instance" in params:
+            body_params = params["instance"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances', 'POST',
+            "/p2p/preheat/instances",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def create_policy(self, project_name, policy, **kwargs):  # noqa: E501
         """Create a preheat policy under a project  # noqa: E501
 
         Create a preheat policy under a project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -152,16 +161,16 @@
         :param str project_name: The name of the project (required)
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_policy_with_http_info(project_name, policy, **kwargs)  # noqa: E501
         else:
             (data) = self.create_policy_with_http_info(project_name, policy, **kwargs)  # noqa: E501
             return data
 
     def create_policy_with_http_info(self, project_name, policy, **kwargs):  # noqa: E501
         """Create a preheat policy under a project  # noqa: E501
@@ -177,85 +186,97 @@
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_policy" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `create_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `create_policy`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `create_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `create_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies', 'POST',
+            "/projects/{project_name}/preheat/policies",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_instance(self, preheat_instance_name, **kwargs):  # noqa: E501
         """Delete the specified P2P provider instance  # noqa: E501
 
         Delete the specified P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -265,19 +286,23 @@
         :param async_req bool
         :param str preheat_instance_name: Instance Name (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_instance_with_http_info(preheat_instance_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_instance_with_http_info(
+                preheat_instance_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_instance_with_http_info(preheat_instance_name, **kwargs)  # noqa: E501
+            (data) = self.delete_instance_with_http_info(
+                preheat_instance_name, **kwargs
+            )  # noqa: E501
             return data
 
     def delete_instance_with_http_info(self, preheat_instance_name, **kwargs):  # noqa: E501
         """Delete the specified P2P provider instance  # noqa: E501
 
         Delete the specified P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -289,79 +314,88 @@
         :param str preheat_instance_name: Instance Name (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['preheat_instance_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["preheat_instance_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_instance" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_instance" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'preheat_instance_name' is set
-        if self.api_client.client_side_validation and ('preheat_instance_name' not in params or
-                                                       params['preheat_instance_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_instance_name` when calling `delete_instance`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_instance`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_instance_name" not in params or params["preheat_instance_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_instance_name` when calling `delete_instance`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_instance`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'preheat_instance_name' in params:
-            path_params['preheat_instance_name'] = params['preheat_instance_name']  # noqa: E501
+        if "preheat_instance_name" in params:
+            path_params["preheat_instance_name"] = params["preheat_instance_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances/{preheat_instance_name}', 'DELETE',
+            "/p2p/preheat/instances/{preheat_instance_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_policy(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
         """Delete a preheat policy  # noqa: E501
 
         Delete a preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -372,22 +406,28 @@
         :param str project_name: The name of the project (required)
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_policy_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_policy_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_policy_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+            (data) = self.delete_policy_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_policy_with_http_info(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
+    def delete_policy_with_http_info(
+        self, project_name, preheat_policy_name, **kwargs
+    ):  # noqa: E501
         """Delete a preheat policy  # noqa: E501
 
         Delete a preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_policy_with_http_info(project_name, preheat_policy_name, async_req=True)
         >>> result = thread.get()
@@ -397,87 +437,101 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "preheat_policy_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_policy" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `delete_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `delete_policy`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `delete_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `delete_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}', 'DELETE',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_execution(self, project_name, preheat_policy_name, execution_id, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def get_execution(
+        self, project_name, preheat_policy_name, execution_id, **kwargs
+    ):  # noqa: E501
         """Get a execution detail by id  # noqa: E501
 
         Get a execution detail by id  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_execution(project_name, preheat_policy_name, execution_id, async_req=True)
         >>> result = thread.get()
@@ -487,22 +541,28 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Execution
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_execution_with_http_info(project_name, preheat_policy_name, execution_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_execution_with_http_info(
+                project_name, preheat_policy_name, execution_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_execution_with_http_info(project_name, preheat_policy_name, execution_id, **kwargs)  # noqa: E501
+            (data) = self.get_execution_with_http_info(
+                project_name, preheat_policy_name, execution_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_execution_with_http_info(self, project_name, preheat_policy_name, execution_id, **kwargs):  # noqa: E501
+    def get_execution_with_http_info(
+        self, project_name, preheat_policy_name, execution_id, **kwargs
+    ):  # noqa: E501
         """Get a execution detail by id  # noqa: E501
 
         Get a execution detail by id  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_execution_with_http_info(project_name, preheat_policy_name, execution_id, async_req=True)
         >>> result = thread.get()
@@ -513,91 +573,111 @@
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Execution
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'execution_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "execution_id",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_execution" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_execution`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `get_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `get_execution`"
+            )  # noqa: E501
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `get_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `get_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Execution',  # noqa: E501
+            response_type="Execution",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_instance(self, preheat_instance_name, **kwargs):  # noqa: E501
         """Get a P2P provider instance  # noqa: E501
 
         Get a P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -607,16 +687,16 @@
         :param async_req bool
         :param str preheat_instance_name: Instance Name (required)
         :param str x_request_id: An unique ID for the request
         :return: Instance
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_instance_with_http_info(preheat_instance_name, **kwargs)  # noqa: E501
         else:
             (data) = self.get_instance_with_http_info(preheat_instance_name, **kwargs)  # noqa: E501
             return data
 
     def get_instance_with_http_info(self, preheat_instance_name, **kwargs):  # noqa: E501
         """Get a P2P provider instance  # noqa: E501
@@ -631,79 +711,88 @@
         :param str preheat_instance_name: Instance Name (required)
         :param str x_request_id: An unique ID for the request
         :return: Instance
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['preheat_instance_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["preheat_instance_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_instance" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_instance" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'preheat_instance_name' is set
-        if self.api_client.client_side_validation and ('preheat_instance_name' not in params or
-                                                       params['preheat_instance_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_instance_name` when calling `get_instance`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_instance`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_instance_name" not in params or params["preheat_instance_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_instance_name` when calling `get_instance`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_instance`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'preheat_instance_name' in params:
-            path_params['preheat_instance_name'] = params['preheat_instance_name']  # noqa: E501
+        if "preheat_instance_name" in params:
+            path_params["preheat_instance_name"] = params["preheat_instance_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances/{preheat_instance_name}', 'GET',
+            "/p2p/preheat/instances/{preheat_instance_name}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Instance',  # noqa: E501
+            response_type="Instance",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_policy(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
         """Get a preheat policy  # noqa: E501
 
         Get a preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -714,19 +803,23 @@
         :param str project_name: The name of the project (required)
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param str x_request_id: An unique ID for the request
         :return: PreheatPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_policy_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_policy_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_policy_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+            (data) = self.get_policy_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
             return data
 
     def get_policy_with_http_info(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
         """Get a preheat policy  # noqa: E501
 
         Get a preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -739,87 +832,101 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param str x_request_id: An unique ID for the request
         :return: PreheatPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "preheat_policy_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_policy" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_policy`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `get_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `get_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PreheatPolicy',  # noqa: E501
+            response_type="PreheatPolicy",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_preheat_log(self, project_name, preheat_policy_name, execution_id, task_id, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def get_preheat_log(
+        self, project_name, preheat_policy_name, execution_id, task_id, **kwargs
+    ):  # noqa: E501
         """Get the log text stream of the specified task for the given execution  # noqa: E501
 
         Get the log text stream of the specified task for the given execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_preheat_log(project_name, preheat_policy_name, execution_id, task_id, async_req=True)
         >>> result = thread.get()
@@ -830,22 +937,28 @@
         :param int execution_id: Execution ID (required)
         :param int task_id: Task ID (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_preheat_log_with_http_info(project_name, preheat_policy_name, execution_id, task_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_preheat_log_with_http_info(
+                project_name, preheat_policy_name, execution_id, task_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_preheat_log_with_http_info(project_name, preheat_policy_name, execution_id, task_id, **kwargs)  # noqa: E501
+            (data) = self.get_preheat_log_with_http_info(
+                project_name, preheat_policy_name, execution_id, task_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_preheat_log_with_http_info(self, project_name, preheat_policy_name, execution_id, task_id, **kwargs):  # noqa: E501
+    def get_preheat_log_with_http_info(
+        self, project_name, preheat_policy_name, execution_id, task_id, **kwargs
+    ):  # noqa: E501
         """Get the log text stream of the specified task for the given execution  # noqa: E501
 
         Get the log text stream of the specified task for the given execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_preheat_log_with_http_info(project_name, preheat_policy_name, execution_id, task_id, async_req=True)
         >>> result = thread.get()
@@ -857,97 +970,119 @@
         :param int task_id: Task ID (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'execution_id', 'task_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "execution_id",
+            "task_id",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_preheat_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_preheat_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_preheat_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_preheat_log`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `get_preheat_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `get_preheat_log`"
+            )  # noqa: E501
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `get_preheat_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `get_preheat_log`"
+            )  # noqa: E501
         # verify the required parameter 'task_id' is set
-        if self.api_client.client_side_validation and ('task_id' not in params or
-                                                       params['task_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `task_id` when calling `get_preheat_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_preheat_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "task_id" not in params or params["task_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `task_id` when calling `get_preheat_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_preheat_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
-        if 'task_id' in params:
-            path_params['task_id'] = params['task_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
+        if "task_id" in params:
+            path_params["task_id"] = params["task_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks/{task_id}/logs', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks/{task_id}/logs",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_executions(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
         """List executions for the given policy  # noqa: E501
 
         List executions for the given policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -962,22 +1097,28 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Execution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_executions_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_executions_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_executions_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+            (data) = self.list_executions_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_executions_with_http_info(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
+    def list_executions_with_http_info(
+        self, project_name, preheat_policy_name, **kwargs
+    ):  # noqa: E501
         """List executions for the given policy  # noqa: E501
 
         List executions for the given policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_executions_with_http_info(project_name, preheat_policy_name, async_req=True)
         >>> result = thread.get()
@@ -991,95 +1132,119 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Execution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'x_request_id', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "x_request_id",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_executions" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_executions" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_executions`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_executions`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `list_executions`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_executions`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_executions`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `list_executions`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_executions`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_executions`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Execution]',  # noqa: E501
+            response_type="list[Execution]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_instances(self, **kwargs):  # noqa: E501
         """List P2P provider instances  # noqa: E501
 
         List P2P provider instances  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1092,16 +1257,16 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Instance]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_instances_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_instances_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_instances_with_http_info(self, **kwargs):  # noqa: E501
         """List P2P provider instances  # noqa: E501
@@ -1119,83 +1284,93 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Instance]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "page", "page_size", "q", "sort"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_instances" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_instances" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_instances`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_instances`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_instances`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_instances`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances', 'GET',
+            "/p2p/preheat/instances",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Instance]',  # noqa: E501
+            response_type="list[Instance]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_policies(self, project_name, **kwargs):  # noqa: E501
         """List preheat policies  # noqa: E501
 
         List preheat policies  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1209,16 +1384,16 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[PreheatPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_policies_with_http_info(project_name, **kwargs)  # noqa: E501
         else:
             (data) = self.list_policies_with_http_info(project_name, **kwargs)  # noqa: E501
             return data
 
     def list_policies_with_http_info(self, project_name, **kwargs):  # noqa: E501
         """List preheat policies  # noqa: E501
@@ -1237,89 +1412,109 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[PreheatPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "x_request_id",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_policies" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_policies" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_policies`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_policies`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_policies`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_policies`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_policies`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_policies`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies', 'GET',
+            "/projects/{project_name}/preheat/policies",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[PreheatPolicy]',  # noqa: E501
+            response_type="list[PreheatPolicy]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_providers(self, **kwargs):  # noqa: E501
         """List P2P providers  # noqa: E501
 
         List P2P providers  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1328,16 +1523,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[Metadata]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_providers_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_providers_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_providers_with_http_info(self, **kwargs):  # noqa: E501
         """List P2P providers  # noqa: E501
@@ -1351,73 +1546,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[Metadata]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_providers" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_providers" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_providers`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_providers`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/providers', 'GET',
+            "/p2p/preheat/providers",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Metadata]',  # noqa: E501
+            response_type="list[Metadata]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_providers_under_project(self, project_name, **kwargs):  # noqa: E501
         """Get all providers at project level  # noqa: E501
 
         Get all providers at project level  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1427,19 +1628,23 @@
         :param async_req bool
         :param str project_name: The name of the project (required)
         :param str x_request_id: An unique ID for the request
         :return: list[ProviderUnderProject]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_providers_under_project_with_http_info(project_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_providers_under_project_with_http_info(
+                project_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_providers_under_project_with_http_info(project_name, **kwargs)  # noqa: E501
+            (data) = self.list_providers_under_project_with_http_info(
+                project_name, **kwargs
+            )  # noqa: E501
             return data
 
     def list_providers_under_project_with_http_info(self, project_name, **kwargs):  # noqa: E501
         """Get all providers at project level  # noqa: E501
 
         Get all providers at project level  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -1451,79 +1656,89 @@
         :param str project_name: The name of the project (required)
         :param str x_request_id: An unique ID for the request
         :return: list[ProviderUnderProject]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_providers_under_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_providers_under_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_providers_under_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_providers_under_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_providers_under_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/providers', 'GET',
+            "/projects/{project_name}/preheat/providers",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ProviderUnderProject]',  # noqa: E501
+            response_type="list[ProviderUnderProject]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_tasks(self, project_name, preheat_policy_name, execution_id, **kwargs):  # noqa: E501
         """List all the related tasks for the given execution  # noqa: E501
 
         List all the related tasks for the given execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1539,22 +1754,28 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Task]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_tasks_with_http_info(project_name, preheat_policy_name, execution_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_tasks_with_http_info(
+                project_name, preheat_policy_name, execution_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_tasks_with_http_info(project_name, preheat_policy_name, execution_id, **kwargs)  # noqa: E501
+            (data) = self.list_tasks_with_http_info(
+                project_name, preheat_policy_name, execution_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_tasks_with_http_info(self, project_name, preheat_policy_name, execution_id, **kwargs):  # noqa: E501
+    def list_tasks_with_http_info(
+        self, project_name, preheat_policy_name, execution_id, **kwargs
+    ):  # noqa: E501
         """List all the related tasks for the given execution  # noqa: E501
 
         List all the related tasks for the given execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_tasks_with_http_info(project_name, preheat_policy_name, execution_id, async_req=True)
         >>> result = thread.get()
@@ -1569,101 +1790,129 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Task]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'execution_id', 'x_request_id', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "execution_id",
+            "x_request_id",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_tasks" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_tasks" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_tasks`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_tasks`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `list_tasks`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `list_tasks`"
+            )  # noqa: E501
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `list_tasks`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_tasks`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_tasks`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `list_tasks`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_tasks`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_tasks`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Task]',  # noqa: E501
+            response_type="list[Task]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def manual_preheat(self, project_name, preheat_policy_name, policy, **kwargs):  # noqa: E501
         """Manual preheat  # noqa: E501
 
         Manual preheat  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1675,22 +1924,28 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.manual_preheat_with_http_info(project_name, preheat_policy_name, policy, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.manual_preheat_with_http_info(
+                project_name, preheat_policy_name, policy, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.manual_preheat_with_http_info(project_name, preheat_policy_name, policy, **kwargs)  # noqa: E501
+            (data) = self.manual_preheat_with_http_info(
+                project_name, preheat_policy_name, policy, **kwargs
+            )  # noqa: E501
             return data
 
-    def manual_preheat_with_http_info(self, project_name, preheat_policy_name, policy, **kwargs):  # noqa: E501
+    def manual_preheat_with_http_info(
+        self, project_name, preheat_policy_name, policy, **kwargs
+    ):  # noqa: E501
         """Manual preheat  # noqa: E501
 
         Manual preheat  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.manual_preheat_with_http_info(project_name, preheat_policy_name, policy, async_req=True)
         >>> result = thread.get()
@@ -1701,91 +1956,106 @@
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "preheat_policy_name", "policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method manual_preheat" % key
+                    "Got an unexpected keyword argument '%s'" " to method manual_preheat" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `manual_preheat`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `manual_preheat`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `manual_preheat`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `manual_preheat`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `manual_preheat`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `manual_preheat`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `manual_preheat`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `manual_preheat`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}', 'POST',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def ping_instances(self, instance, **kwargs):  # noqa: E501
         """Ping status of a instance.  # noqa: E501
 
         This endpoint checks status of a instance, the instance can be given by ID or Endpoint URL (together with credential)   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1795,16 +2065,16 @@
         :param async_req bool
         :param Instance instance: The JSON object of instance. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_instances_with_http_info(instance, **kwargs)  # noqa: E501
         else:
             (data) = self.ping_instances_with_http_info(instance, **kwargs)  # noqa: E501
             return data
 
     def ping_instances_with_http_info(self, instance, **kwargs):  # noqa: E501
         """Ping status of a instance.  # noqa: E501
@@ -1819,81 +2089,92 @@
         :param Instance instance: The JSON object of instance. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['instance', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["instance", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_instances" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_instances" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'instance' is set
-        if self.api_client.client_side_validation and ('instance' not in params or
-                                                       params['instance'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `instance` when calling `ping_instances`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_instances`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "instance" not in params or params["instance"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `instance` when calling `ping_instances`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_instances`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'instance' in params:
-            body_params = params['instance']
+        if "instance" in params:
+            body_params = params["instance"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances/ping', 'POST',
+            "/p2p/preheat/instances/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def stop_execution(self, project_name, preheat_policy_name, execution_id, execution, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def stop_execution(
+        self, project_name, preheat_policy_name, execution_id, execution, **kwargs
+    ):  # noqa: E501
         """Stop a execution  # noqa: E501
 
         Stop a execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.stop_execution(project_name, preheat_policy_name, execution_id, execution, async_req=True)
         >>> result = thread.get()
@@ -1904,22 +2185,28 @@
         :param int execution_id: Execution ID (required)
         :param Execution execution: The data of execution (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.stop_execution_with_http_info(project_name, preheat_policy_name, execution_id, execution, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.stop_execution_with_http_info(
+                project_name, preheat_policy_name, execution_id, execution, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.stop_execution_with_http_info(project_name, preheat_policy_name, execution_id, execution, **kwargs)  # noqa: E501
+            (data) = self.stop_execution_with_http_info(
+                project_name, preheat_policy_name, execution_id, execution, **kwargs
+            )  # noqa: E501
             return data
 
-    def stop_execution_with_http_info(self, project_name, preheat_policy_name, execution_id, execution, **kwargs):  # noqa: E501
+    def stop_execution_with_http_info(
+        self, project_name, preheat_policy_name, execution_id, execution, **kwargs
+    ):  # noqa: E501
         """Stop a execution  # noqa: E501
 
         Stop a execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.stop_execution_with_http_info(project_name, preheat_policy_name, execution_id, execution, async_req=True)
         >>> result = thread.get()
@@ -1931,97 +2218,121 @@
         :param Execution execution: The data of execution (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'execution_id', 'execution', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "execution_id",
+            "execution",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_execution" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `stop_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `stop_execution`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `stop_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `stop_execution`"
+            )  # noqa: E501
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `stop_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `stop_execution`"
+            )  # noqa: E501
         # verify the required parameter 'execution' is set
-        if self.api_client.client_side_validation and ('execution' not in params or
-                                                       params['execution'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution` when calling `stop_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution" not in params or params["execution"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution` when calling `stop_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'execution' in params:
-            body_params = params['execution']
+        if "execution" in params:
+            body_params = params["execution"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}', 'PATCH',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}",
+            "PATCH",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_instance(self, preheat_instance_name, instance, **kwargs):  # noqa: E501
         """Update the specified P2P provider instance  # noqa: E501
 
         Update the specified P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -2032,22 +2343,28 @@
         :param str preheat_instance_name: Instance Name (required)
         :param Instance instance: The instance to update (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_instance_with_http_info(preheat_instance_name, instance, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_instance_with_http_info(
+                preheat_instance_name, instance, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_instance_with_http_info(preheat_instance_name, instance, **kwargs)  # noqa: E501
+            (data) = self.update_instance_with_http_info(
+                preheat_instance_name, instance, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_instance_with_http_info(self, preheat_instance_name, instance, **kwargs):  # noqa: E501
+    def update_instance_with_http_info(
+        self, preheat_instance_name, instance, **kwargs
+    ):  # noqa: E501
         """Update the specified P2P provider instance  # noqa: E501
 
         Update the specified P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_instance_with_http_info(preheat_instance_name, instance, async_req=True)
         >>> result = thread.get()
@@ -2057,85 +2374,97 @@
         :param Instance instance: The instance to update (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['preheat_instance_name', 'instance', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["preheat_instance_name", "instance", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_instance" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_instance" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'preheat_instance_name' is set
-        if self.api_client.client_side_validation and ('preheat_instance_name' not in params or
-                                                       params['preheat_instance_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_instance_name` when calling `update_instance`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_instance_name" not in params or params["preheat_instance_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_instance_name` when calling `update_instance`"
+            )  # noqa: E501
         # verify the required parameter 'instance' is set
-        if self.api_client.client_side_validation and ('instance' not in params or
-                                                       params['instance'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `instance` when calling `update_instance`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_instance`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "instance" not in params or params["instance"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `instance` when calling `update_instance`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_instance`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'preheat_instance_name' in params:
-            path_params['preheat_instance_name'] = params['preheat_instance_name']  # noqa: E501
+        if "preheat_instance_name" in params:
+            path_params["preheat_instance_name"] = params["preheat_instance_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'instance' in params:
-            body_params = params['instance']
+        if "instance" in params:
+            body_params = params["instance"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances/{preheat_instance_name}', 'PUT',
+            "/p2p/preheat/instances/{preheat_instance_name}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_policy(self, project_name, preheat_policy_name, policy, **kwargs):  # noqa: E501
         """Update preheat policy  # noqa: E501
 
         Update preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -2147,22 +2476,28 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_policy_with_http_info(project_name, preheat_policy_name, policy, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_policy_with_http_info(
+                project_name, preheat_policy_name, policy, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_policy_with_http_info(project_name, preheat_policy_name, policy, **kwargs)  # noqa: E501
+            (data) = self.update_policy_with_http_info(
+                project_name, preheat_policy_name, policy, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_policy_with_http_info(self, project_name, preheat_policy_name, policy, **kwargs):  # noqa: E501
+    def update_policy_with_http_info(
+        self, project_name, preheat_policy_name, policy, **kwargs
+    ):  # noqa: E501
         """Update preheat policy  # noqa: E501
 
         Update preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_policy_with_http_info(project_name, preheat_policy_name, policy, async_req=True)
         >>> result = thread.get()
@@ -2173,84 +2508,99 @@
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "preheat_policy_name", "policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_policy" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `update_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `update_policy`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `update_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `update_policy`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `update_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `update_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}', 'PUT',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/project_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/project_api.py`

 * *Files 17% similar despite different names*

```diff
@@ -46,16 +46,16 @@
         :param ProjectReq project: New created project. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_resource_name_in_location: The flag to indicate whether to return the name of the resource in Location. When X-Resource-Name-In-Location is true, the Location will return the name of the resource.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_project_with_http_info(project, **kwargs)  # noqa: E501
         else:
             (data) = self.create_project_with_http_info(project, **kwargs)  # noqa: E501
             return data
 
     def create_project_with_http_info(self, project, **kwargs):  # noqa: E501
         """Create a new project.  # noqa: E501
@@ -71,81 +71,92 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_resource_name_in_location: The flag to indicate whether to return the name of the resource in Location. When X-Resource-Name-In-Location is true, the Location will return the name of the resource.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project', 'x_request_id', 'x_resource_name_in_location']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project", "x_request_id", "x_resource_name_in_location"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project' is set
-        if self.api_client.client_side_validation and ('project' not in params or
-                                                       params['project'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project` when calling `create_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project" not in params or params["project"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project` when calling `create_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_resource_name_in_location' in params:
-            header_params['X-Resource-Name-In-Location'] = params['x_resource_name_in_location']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_resource_name_in_location" in params:
+            header_params["X-Resource-Name-In-Location"] = params[
+                "x_resource_name_in_location"
+            ]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'project' in params:
-            body_params = params['project']
+        if "project" in params:
+            body_params = params["project"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects', 'POST',
+            "/projects",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_project(self, project_name_or_id, **kwargs):  # noqa: E501
         """Delete project by projectID  # noqa: E501
 
         This endpoint is aimed to delete project by project ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -156,16 +167,16 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
     def delete_project_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Delete project by projectID  # noqa: E501
@@ -181,81 +192,90 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}', 'DELETE',
+            "/projects/{project_name_or_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_logs(self, project_name, **kwargs):  # noqa: E501
         """Get recent logs of the projects  # noqa: E501
 
         Get recent logs of the projects  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -269,16 +289,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[AuditLog]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_logs_with_http_info(project_name, **kwargs)  # noqa: E501
         else:
             (data) = self.get_logs_with_http_info(project_name, **kwargs)  # noqa: E501
             return data
 
     def get_logs_with_http_info(self, project_name, **kwargs):  # noqa: E501
         """Get recent logs of the projects  # noqa: E501
@@ -297,89 +317,109 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[AuditLog]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_logs" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_logs" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_logs`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_logs`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `get_logs`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_logs`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_logs`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `get_logs`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/logs', 'GET',
+            "/projects/{project_name}/logs",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[AuditLog]',  # noqa: E501
+            response_type="list[AuditLog]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project(self, project_name_or_id, **kwargs):  # noqa: E501
         """Return specific project detail information  # noqa: E501
 
         This endpoint returns specific project information by project ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -390,16 +430,16 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: Project
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
     def get_project_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Return specific project detail information  # noqa: E501
@@ -415,81 +455,90 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: Project
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}', 'GET',
+            "/projects/{project_name_or_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Project',  # noqa: E501
+            response_type="Project",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project_deletable(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get the deletable status of the project  # noqa: E501
 
         Get the deletable status of the project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -500,19 +549,23 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectDeletable
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_project_deletable_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_project_deletable_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_project_deletable_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.get_project_deletable_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_project_deletable_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get the deletable status of the project  # noqa: E501
 
         Get the deletable status of the project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -525,81 +578,91 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectDeletable
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_project_deletable" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project_deletable`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project_deletable`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project_deletable`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project_deletable`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/_deletable', 'GET',
+            "/projects/{project_name_or_id}/_deletable",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectDeletable',  # noqa: E501
+            response_type="ProjectDeletable",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project_summary(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get summary of the project.  # noqa: E501
 
         Get summary of the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -610,19 +673,23 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectSummary
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_project_summary_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_project_summary_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_project_summary_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.get_project_summary_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_project_summary_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get summary of the project.  # noqa: E501
 
         Get summary of the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -635,81 +702,90 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectSummary
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_project_summary" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_project_summary" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project_summary`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project_summary`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project_summary`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project_summary`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/summary', 'GET',
+            "/projects/{project_name_or_id}/summary",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectSummary',  # noqa: E501
+            response_type="ProjectSummary",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scanner_of_project(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get project level scanner  # noqa: E501
 
         Get the scanner registration of the specified project. If no scanner registration is configured for the specified project, the system default scanner registration will be returned.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -720,19 +796,23 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_scanner_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_scanner_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_scanner_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.get_scanner_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_scanner_of_project_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get project level scanner  # noqa: E501
 
         Get the scanner registration of the specified project. If no scanner registration is configured for the specified project, the system default scanner registration will be returned.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -745,81 +825,91 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scanner_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_scanner_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scanner_of_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_scanner_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scanner_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/scanner', 'GET',
+            "/projects/{project_name_or_id}/scanner",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScannerRegistration',  # noqa: E501
+            response_type="ScannerRegistration",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def head_project(self, project_name, **kwargs):  # noqa: E501
         """Check if the project name user provided already exists.  # noqa: E501
 
         This endpoint is used to check if the project name provided already exist.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -829,16 +919,16 @@
         :param async_req bool
         :param str project_name: Project name for checking exists. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.head_project_with_http_info(project_name, **kwargs)  # noqa: E501
         else:
             (data) = self.head_project_with_http_info(project_name, **kwargs)  # noqa: E501
             return data
 
     def head_project_with_http_info(self, project_name, **kwargs):  # noqa: E501
         """Check if the project name user provided already exists.  # noqa: E501
@@ -853,79 +943,88 @@
         :param str project_name: Project name for checking exists. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method head_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method head_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `head_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `head_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `head_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `head_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'project_name' in params:
-            query_params.append(('project_name', params['project_name']))  # noqa: E501
+        if "project_name" in params:
+            query_params.append(("project_name", params["project_name"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects', 'HEAD',
+            "/projects",
+            "HEAD",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_projects(self, **kwargs):  # noqa: E501
         """List projects  # noqa: E501
 
         This endpoint returns projects created by Harbor.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -942,16 +1041,16 @@
         :param bool public: The project is public or private.
         :param str owner: The name of project owner.
         :param bool with_detail: Bool value indicating whether return detailed information of the project
         :return: list[Project]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_projects_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_projects_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_projects_with_http_info(self, **kwargs):  # noqa: E501
         """List projects  # noqa: E501
@@ -973,91 +1072,111 @@
         :param str owner: The name of project owner.
         :param bool with_detail: Bool value indicating whether return detailed information of the project
         :return: list[Project]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'page', 'page_size', 'sort', 'name', 'public', 'owner', 'with_detail']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "q",
+            "page",
+            "page_size",
+            "sort",
+            "name",
+            "public",
+            "owner",
+            "with_detail",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_projects" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_projects" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_projects`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_projects`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_projects`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_projects`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'name' in params:
-            query_params.append(('name', params['name']))  # noqa: E501
-        if 'public' in params:
-            query_params.append(('public', params['public']))  # noqa: E501
-        if 'owner' in params:
-            query_params.append(('owner', params['owner']))  # noqa: E501
-        if 'with_detail' in params:
-            query_params.append(('with_detail', params['with_detail']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "name" in params:
+            query_params.append(("name", params["name"]))  # noqa: E501
+        if "public" in params:
+            query_params.append(("public", params["public"]))  # noqa: E501
+        if "owner" in params:
+            query_params.append(("owner", params["owner"]))  # noqa: E501
+        if "with_detail" in params:
+            query_params.append(("with_detail", params["with_detail"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects', 'GET',
+            "/projects",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Project]',  # noqa: E501
+            response_type="list[Project]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_scanner_candidates_of_project(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get scanner registration candidates for configurating project level scanner  # noqa: E501
 
         Retrieve the system configured scanner registrations as candidates of setting project level scanner.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1072,22 +1191,28 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScannerRegistration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_scanner_candidates_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_scanner_candidates_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_scanner_candidates_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.list_scanner_candidates_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_scanner_candidates_of_project_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
+    def list_scanner_candidates_of_project_with_http_info(
+        self, project_name_or_id, **kwargs
+    ):  # noqa: E501
         """Get scanner registration candidates for configurating project level scanner  # noqa: E501
 
         Retrieve the system configured scanner registrations as candidates of setting project level scanner.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_scanner_candidates_of_project_with_http_info(project_name_or_id, async_req=True)
         >>> result = thread.get()
@@ -1101,91 +1226,113 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScannerRegistration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_scanner_candidates_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_scanner_candidates_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_scanner_candidates_of_project`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_scanner_candidates_of_project`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_scanner_candidates_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_scanner_candidates_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_scanner_candidates_of_project`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/scanner/candidates', 'GET',
+            "/projects/{project_name_or_id}/scanner/candidates",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ScannerRegistration]',  # noqa: E501
+            response_type="list[ScannerRegistration]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def set_scanner_of_project(self, project_name_or_id, payload, **kwargs):  # noqa: E501
         """Configure scanner for the specified project  # noqa: E501
 
         Set one of the system configured scanner registration as the indepndent scanner of the specified project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1197,22 +1344,28 @@
         :param ProjectScanner payload: (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.set_scanner_of_project_with_http_info(project_name_or_id, payload, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.set_scanner_of_project_with_http_info(
+                project_name_or_id, payload, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.set_scanner_of_project_with_http_info(project_name_or_id, payload, **kwargs)  # noqa: E501
+            (data) = self.set_scanner_of_project_with_http_info(
+                project_name_or_id, payload, **kwargs
+            )  # noqa: E501
             return data
 
-    def set_scanner_of_project_with_http_info(self, project_name_or_id, payload, **kwargs):  # noqa: E501
+    def set_scanner_of_project_with_http_info(
+        self, project_name_or_id, payload, **kwargs
+    ):  # noqa: E501
         """Configure scanner for the specified project  # noqa: E501
 
         Set one of the system configured scanner registration as the indepndent scanner of the specified project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.set_scanner_of_project_with_http_info(project_name_or_id, payload, async_req=True)
         >>> result = thread.get()
@@ -1223,87 +1376,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'payload', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "payload",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method set_scanner_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `set_scanner_of_project`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `set_scanner_of_project`"
+            )  # noqa: E501
         # verify the required parameter 'payload' is set
-        if self.api_client.client_side_validation and ('payload' not in params or
-                                                       params['payload'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `payload` when calling `set_scanner_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `set_scanner_of_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "payload" not in params or params["payload"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `payload` when calling `set_scanner_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `set_scanner_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'payload' in params:
-            body_params = params['payload']
+        if "payload" in params:
+            body_params = params["payload"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/scanner', 'PUT',
+            "/projects/{project_name_or_id}/scanner",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_project(self, project_name_or_id, project, **kwargs):  # noqa: E501
         """Update properties for a selected project.  # noqa: E501
 
         This endpoint is aimed to update the properties of a project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1315,19 +1486,23 @@
         :param ProjectReq project: Updates of project. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_project_with_http_info(project_name_or_id, project, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_project_with_http_info(
+                project_name_or_id, project, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_project_with_http_info(project_name_or_id, project, **kwargs)  # noqa: E501
+            (data) = self.update_project_with_http_info(
+                project_name_or_id, project, **kwargs
+            )  # noqa: E501
             return data
 
     def update_project_with_http_info(self, project_name_or_id, project, **kwargs):  # noqa: E501
         """Update properties for a selected project.  # noqa: E501
 
         This endpoint is aimed to update the properties of a project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -1341,80 +1516,97 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'project', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "project",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_project`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_project`"
+            )  # noqa: E501
         # verify the required parameter 'project' is set
-        if self.api_client.client_side_validation and ('project' not in params or
-                                                       params['project'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project` when calling `update_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project" not in params or params["project"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project` when calling `update_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'project' in params:
-            body_params = params['project']
+        if "project" in params:
+            body_params = params["project"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}', 'PUT',
+            "/projects/{project_name_or_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/project_metadata_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/project_metadata_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -47,19 +47,23 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param object metadata:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.add_project_metadatas_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.add_project_metadatas_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.add_project_metadatas_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.add_project_metadatas_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def add_project_metadatas_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Add metadata for the specific project  # noqa: E501
 
         Add metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -73,83 +77,98 @@
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param object metadata:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'metadata']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "metadata",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_project_metadatas" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `add_project_metadatas`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `add_project_metadatas`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `add_project_metadatas`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `add_project_metadatas`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'metadata' in params:
-            body_params = params['metadata']
+        if "metadata" in params:
+            body_params = params["metadata"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/', 'POST',
+            "/projects/{project_name_or_id}/metadatas/",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_project_metadata(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
         """Delete the specific metadata for the specific project  # noqa: E501
 
         Delete the specific metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -161,22 +180,28 @@
         :param str meta_name: The name of metadata. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+            (data) = self.delete_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_project_metadata_with_http_info(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
+    def delete_project_metadata_with_http_info(
+        self, project_name_or_id, meta_name, **kwargs
+    ):  # noqa: E501
         """Delete the specific metadata for the specific project  # noqa: E501
 
         Delete the specific metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_project_metadata_with_http_info(project_name_or_id, meta_name, async_req=True)
         >>> result = thread.get()
@@ -187,87 +212,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'meta_name', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "meta_name",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_project_metadata" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_project_metadata`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_project_metadata`"
+            )  # noqa: E501
         # verify the required parameter 'meta_name' is set
-        if self.api_client.client_side_validation and ('meta_name' not in params or
-                                                       params['meta_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `meta_name` when calling `delete_project_metadata`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_project_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "meta_name" not in params or params["meta_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `meta_name` when calling `delete_project_metadata`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_project_metadata`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'meta_name' in params:
-            path_params['meta_name'] = params['meta_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "meta_name" in params:
+            path_params["meta_name"] = params["meta_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/{meta_name}', 'DELETE',
+            "/projects/{project_name_or_id}/metadatas/{meta_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project_metadata(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
         """Get the specific metadata of the specific project  # noqa: E501
 
         Get the specific metadata of the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -279,22 +322,28 @@
         :param str meta_name: The name of metadata. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: dict(str, str)
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+            (data) = self.get_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_project_metadata_with_http_info(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
+    def get_project_metadata_with_http_info(
+        self, project_name_or_id, meta_name, **kwargs
+    ):  # noqa: E501
         """Get the specific metadata of the specific project  # noqa: E501
 
         Get the specific metadata of the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_metadata_with_http_info(project_name_or_id, meta_name, async_req=True)
         >>> result = thread.get()
@@ -305,87 +354,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: dict(str, str)
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'meta_name', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "meta_name",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_project_metadata" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project_metadata`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project_metadata`"
+            )  # noqa: E501
         # verify the required parameter 'meta_name' is set
-        if self.api_client.client_side_validation and ('meta_name' not in params or
-                                                       params['meta_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `meta_name` when calling `get_project_metadata`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "meta_name" not in params or params["meta_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `meta_name` when calling `get_project_metadata`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project_metadata`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'meta_name' in params:
-            path_params['meta_name'] = params['meta_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "meta_name" in params:
+            path_params["meta_name"] = params["meta_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/{meta_name}', 'GET',
+            "/projects/{project_name_or_id}/metadatas/{meta_name}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='dict(str, str)',  # noqa: E501
+            response_type="dict(str, str)",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_project_metadatas(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get the metadata of the specific project  # noqa: E501
 
         Get the metadata of the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -396,19 +463,23 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: dict(str, str)
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_project_metadatas_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_project_metadatas_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_project_metadatas_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.list_project_metadatas_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def list_project_metadatas_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get the metadata of the specific project  # noqa: E501
 
         Get the metadata of the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -421,81 +492,91 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: dict(str, str)
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_project_metadatas" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_project_metadatas`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_project_metadatas`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_project_metadatas`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_project_metadatas`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/', 'GET',
+            "/projects/{project_name_or_id}/metadatas/",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='dict(str, str)',  # noqa: E501
+            response_type="dict(str, str)",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_project_metadata(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
         """Update the specific metadata for the specific project  # noqa: E501
 
         Update the specific metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -508,22 +589,28 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param object metadata:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+            (data) = self.update_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_project_metadata_with_http_info(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
+    def update_project_metadata_with_http_info(
+        self, project_name_or_id, meta_name, **kwargs
+    ):  # noqa: E501
         """Update the specific metadata for the specific project  # noqa: E501
 
         Update the specific metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_project_metadata_with_http_info(project_name_or_id, meta_name, async_req=True)
         >>> result = thread.get()
@@ -535,82 +622,101 @@
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param object metadata:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'meta_name', 'x_request_id', 'x_is_resource_name', 'metadata']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "meta_name",
+            "x_request_id",
+            "x_is_resource_name",
+            "metadata",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_project_metadata" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_project_metadata`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_project_metadata`"
+            )  # noqa: E501
         # verify the required parameter 'meta_name' is set
-        if self.api_client.client_side_validation and ('meta_name' not in params or
-                                                       params['meta_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `meta_name` when calling `update_project_metadata`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_project_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "meta_name" not in params or params["meta_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `meta_name` when calling `update_project_metadata`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_project_metadata`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'meta_name' in params:
-            path_params['meta_name'] = params['meta_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "meta_name" in params:
+            path_params["meta_name"] = params["meta_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'metadata' in params:
-            body_params = params['metadata']
+        if "metadata" in params:
+            body_params = params["metadata"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/{meta_name}', 'PUT',
+            "/projects/{project_name_or_id}/metadatas/{meta_name}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/purge_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/purge_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Schedule schedule: The purge job's schedule, it is a json object. ｜ The sample format is ｜ {\"parameters\":{\"audit_retention_hour\":168,\"dry_run\":true, \"include_operations\":\"create,delete,pull\"},\"schedule\":{\"type\":\"Hourly\",\"cron\":\"0 0 * * * *\"}} ｜ the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.  (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_purge_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.create_purge_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def create_purge_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Create a purge job schedule.  # noqa: E501
@@ -69,79 +69,89 @@
         :param Schedule schedule: The purge job's schedule, it is a json object. ｜ The sample format is ｜ {\"parameters\":{\"audit_retention_hour\":168,\"dry_run\":true, \"include_operations\":\"create,delete,pull\"},\"schedule\":{\"type\":\"Hourly\",\"cron\":\"0 0 * * * *\"}} ｜ the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.  (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_purge_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `create_purge_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_purge_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `create_purge_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_purge_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/schedule', 'POST',
+            "/system/purgeaudit/schedule",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_purge_history(self, **kwargs):  # noqa: E501
         """Get purge job results.  # noqa: E501
 
         get purge job execution history.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -154,16 +164,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ExecHistory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_purge_history_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_purge_history_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_purge_history_with_http_info(self, **kwargs):  # noqa: E501
         """Get purge job results.  # noqa: E501
@@ -181,83 +191,93 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ExecHistory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_purge_history" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_purge_history" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_purge_history`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `get_purge_history`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_purge_history`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `get_purge_history`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit', 'GET',
+            "/system/purgeaudit",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ExecHistory]',  # noqa: E501
+            response_type="list[ExecHistory]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_purge_job(self, purge_id, **kwargs):  # noqa: E501
         """Get purge job status.  # noqa: E501
 
         This endpoint let user get purge job status filtered by specific ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -267,16 +287,16 @@
         :param async_req bool
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: ExecHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_purge_job_with_http_info(purge_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_purge_job_with_http_info(purge_id, **kwargs)  # noqa: E501
             return data
 
     def get_purge_job_with_http_info(self, purge_id, **kwargs):  # noqa: E501
         """Get purge job status.  # noqa: E501
@@ -291,79 +311,88 @@
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: ExecHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['purge_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["purge_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_purge_job" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_purge_job" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'purge_id' is set
-        if self.api_client.client_side_validation and ('purge_id' not in params or
-                                                       params['purge_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `purge_id` when calling `get_purge_job`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_purge_job`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "purge_id" not in params or params["purge_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `purge_id` when calling `get_purge_job`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_purge_job`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'purge_id' in params:
-            path_params['purge_id'] = params['purge_id']  # noqa: E501
+        if "purge_id" in params:
+            path_params["purge_id"] = params["purge_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/{purge_id}', 'GET',
+            "/system/purgeaudit/{purge_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ExecHistory',  # noqa: E501
+            response_type="ExecHistory",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_purge_job_log(self, purge_id, **kwargs):  # noqa: E501
         """Get purge job log.  # noqa: E501
 
         This endpoint let user get purge job logs filtered by specific ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -373,16 +402,16 @@
         :param async_req bool
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_purge_job_log_with_http_info(purge_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_purge_job_log_with_http_info(purge_id, **kwargs)  # noqa: E501
             return data
 
     def get_purge_job_log_with_http_info(self, purge_id, **kwargs):  # noqa: E501
         """Get purge job log.  # noqa: E501
@@ -397,79 +426,86 @@
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['purge_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["purge_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_purge_job_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_purge_job_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'purge_id' is set
-        if self.api_client.client_side_validation and ('purge_id' not in params or
-                                                       params['purge_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `purge_id` when calling `get_purge_job_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_purge_job_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "purge_id" not in params or params["purge_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `purge_id` when calling `get_purge_job_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_purge_job_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'purge_id' in params:
-            path_params['purge_id'] = params['purge_id']  # noqa: E501
+        if "purge_id" in params:
+            path_params["purge_id"] = params["purge_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/{purge_id}/log', 'GET',
+            "/system/purgeaudit/{purge_id}/log",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_purge_schedule(self, **kwargs):  # noqa: E501
         """Get purge's schedule.  # noqa: E501
 
         This endpoint is for get schedule of purge job.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -478,16 +514,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ExecHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_purge_schedule_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_purge_schedule_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_purge_schedule_with_http_info(self, **kwargs):  # noqa: E501
         """Get purge's schedule.  # noqa: E501
@@ -501,73 +537,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ExecHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_purge_schedule" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_purge_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_purge_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_purge_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/schedule', 'GET',
+            "/system/purgeaudit/schedule",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ExecHistory',  # noqa: E501
+            response_type="ExecHistory",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_purge(self, purge_id, **kwargs):  # noqa: E501
         """Stop the specific purge audit log execution  # noqa: E501
 
         Stop the purge audit log execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -577,16 +619,16 @@
         :param async_req bool
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_purge_with_http_info(purge_id, **kwargs)  # noqa: E501
         else:
             (data) = self.stop_purge_with_http_info(purge_id, **kwargs)  # noqa: E501
             return data
 
     def stop_purge_with_http_info(self, purge_id, **kwargs):  # noqa: E501
         """Stop the specific purge audit log execution  # noqa: E501
@@ -601,79 +643,88 @@
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['purge_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["purge_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_purge" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_purge" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'purge_id' is set
-        if self.api_client.client_side_validation and ('purge_id' not in params or
-                                                       params['purge_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `purge_id` when calling `stop_purge`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_purge`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "purge_id" not in params or params["purge_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `purge_id` when calling `stop_purge`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_purge`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'purge_id' in params:
-            path_params['purge_id'] = params['purge_id']  # noqa: E501
+        if "purge_id" in params:
+            path_params["purge_id"] = params["purge_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/{purge_id}', 'PUT',
+            "/system/purgeaudit/{purge_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_purge_schedule(self, schedule, **kwargs):  # noqa: E501
         """Update purge job's schedule.  # noqa: E501
 
         This endpoint is for update purge job schedule.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -683,16 +734,16 @@
         :param async_req bool
         :param Schedule schedule: The purge job's schedule, it is a json object. ｜ The sample format is ｜ {\"parameters\":{\"audit_retention_hour\":168,\"dry_run\":true, \"include_operations\":\"create,delete,pull\"},\"schedule\":{\"type\":\"Hourly\",\"cron\":\"0 0 * * * *\"}} ｜ the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.  (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_purge_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.update_purge_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def update_purge_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Update purge job's schedule.  # noqa: E501
@@ -707,72 +758,82 @@
         :param Schedule schedule: The purge job's schedule, it is a json object. ｜ The sample format is ｜ {\"parameters\":{\"audit_retention_hour\":168,\"dry_run\":true, \"include_operations\":\"create,delete,pull\"},\"schedule\":{\"type\":\"Hourly\",\"cron\":\"0 0 * * * *\"}} ｜ the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.  (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_purge_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `update_purge_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_purge_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `update_purge_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_purge_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/schedule', 'PUT',
+            "/system/purgeaudit/schedule",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/quota_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/quota_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param int id: Quota ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Quota
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_quota_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_quota_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_quota_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the specified quota  # noqa: E501
@@ -69,79 +69,88 @@
         :param int id: Quota ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Quota
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_quota" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_quota" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_quota`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_quota`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_quota`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_quota`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/quotas/{id}', 'GET',
+            "/quotas/{id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Quota',  # noqa: E501
+            response_type="Quota",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_quotas(self, **kwargs):  # noqa: E501
         """List quotas  # noqa: E501
 
         List quotas  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -150,21 +159,21 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
         :param str reference: The reference type of quota.
         :param str reference_id: The reference id of quota.
-        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota. 
+        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota.
         :return: list[Quota]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_quotas_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_quotas_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_quotas_with_http_info(self, **kwargs):  # noqa: E501
         """List quotas  # noqa: E501
@@ -177,91 +186,108 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
         :param str reference: The reference type of quota.
         :param str reference_id: The reference id of quota.
-        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota. 
+        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota.
         :return: list[Quota]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'page', 'page_size', 'reference', 'reference_id', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "page",
+            "page_size",
+            "reference",
+            "reference_id",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_quotas" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_quotas" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_quotas`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_quotas`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_quotas`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_quotas`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'reference' in params:
-            query_params.append(('reference', params['reference']))  # noqa: E501
-        if 'reference_id' in params:
-            query_params.append(('reference_id', params['reference_id']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "reference" in params:
+            query_params.append(("reference", params["reference"]))  # noqa: E501
+        if "reference_id" in params:
+            query_params.append(("reference_id", params["reference_id"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/quotas', 'GET',
+            "/quotas",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Quota]',  # noqa: E501
+            response_type="list[Quota]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_quota(self, id, hard, **kwargs):  # noqa: E501
         """Update the specified quota  # noqa: E501
 
         Update hard limits of the specified quota  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -272,16 +298,16 @@
         :param int id: Quota ID (required)
         :param QuotaUpdateReq hard: The new hard limits for the quota (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_quota_with_http_info(id, hard, **kwargs)  # noqa: E501
         else:
             (data) = self.update_quota_with_http_info(id, hard, **kwargs)  # noqa: E501
             return data
 
     def update_quota_with_http_info(self, id, hard, **kwargs):  # noqa: E501
         """Update the specified quota  # noqa: E501
@@ -297,78 +323,90 @@
         :param QuotaUpdateReq hard: The new hard limits for the quota (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'hard', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "hard", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_quota" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_quota" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `update_quota`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `update_quota`"
+            )  # noqa: E501
         # verify the required parameter 'hard' is set
-        if self.api_client.client_side_validation and ('hard' not in params or
-                                                       params['hard'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `hard` when calling `update_quota`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_quota`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "hard" not in params or params["hard"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `hard` when calling `update_quota`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_quota`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'hard' in params:
-            body_params = params['hard']
+        if "hard" in params:
+            body_params = params["hard"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/quotas/{id}', 'PUT',
+            "/quotas/{id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/registry_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/registry_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Registry registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_registry_with_http_info(registry, **kwargs)  # noqa: E501
         else:
             (data) = self.create_registry_with_http_info(registry, **kwargs)  # noqa: E501
             return data
 
     def create_registry_with_http_info(self, registry, **kwargs):  # noqa: E501
         """Create a registry  # noqa: E501
@@ -69,79 +69,88 @@
         :param Registry registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registry', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registry", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registry' is set
-        if self.api_client.client_side_validation and ('registry' not in params or
-                                                       params['registry'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registry` when calling `create_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registry" not in params or params["registry"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registry` when calling `create_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registry' in params:
-            body_params = params['registry']
+        if "registry" in params:
+            body_params = params["registry"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries', 'POST',
+            "/registries",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_registry(self, id, **kwargs):  # noqa: E501
         """Delete the specific registry  # noqa: E501
 
         Delete the specific registry  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_registry_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_registry_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def delete_registry_with_http_info(self, id, **kwargs):  # noqa: E501
         """Delete the specific registry  # noqa: E501
@@ -175,79 +184,88 @@
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `delete_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `delete_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/{id}', 'DELETE',
+            "/registries/{id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_registry(self, id, **kwargs):  # noqa: E501
         """Get the specific registry  # noqa: E501
 
         Get the specific registry  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +275,16 @@
         :param async_req bool
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Registry
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_registry_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_registry_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_registry_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the specific registry  # noqa: E501
@@ -281,79 +299,88 @@
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Registry
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/{id}', 'GET',
+            "/registries/{id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Registry',  # noqa: E501
+            response_type="Registry",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_registry_info(self, id, **kwargs):  # noqa: E501
         """Get the registry info  # noqa: E501
 
         Get the registry info  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -363,16 +390,16 @@
         :param async_req bool
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: RegistryInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_registry_info_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_registry_info_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_registry_info_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the registry info  # noqa: E501
@@ -387,79 +414,88 @@
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: RegistryInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_registry_info" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_registry_info" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_registry_info`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_registry_info`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_registry_info`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_registry_info`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/{id}/info', 'GET',
+            "/registries/{id}/info",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RegistryInfo',  # noqa: E501
+            response_type="RegistryInfo",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_registries(self, **kwargs):  # noqa: E501
         """List the registries  # noqa: E501
 
         List the registries  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -473,16 +509,16 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :param str name: Deprecated, use `q` instead.
         :return: list[Registry]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_registries_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_registries_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_registries_with_http_info(self, **kwargs):  # noqa: E501
         """List the registries  # noqa: E501
@@ -501,85 +537,95 @@
         :param int page_size: The size of per page
         :param str name: Deprecated, use `q` instead.
         :return: list[Registry]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size', 'name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size", "name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_registries" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_registries" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_registries`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_registries`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_registries`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_registries`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'name' in params:
-            query_params.append(('name', params['name']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "name" in params:
+            query_params.append(("name", params["name"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries', 'GET',
+            "/registries",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Registry]',  # noqa: E501
+            response_type="list[Registry]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_registry_provider_infos(self, **kwargs):  # noqa: E501
         """List all registered registry provider information  # noqa: E501
 
         List all registered registry provider information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -588,16 +634,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: dict(str, RegistryProviderInfo)
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_registry_provider_infos_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_registry_provider_infos_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_registry_provider_infos_with_http_info(self, **kwargs):  # noqa: E501
         """List all registered registry provider information  # noqa: E501
@@ -611,73 +657,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: dict(str, RegistryProviderInfo)
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_registry_provider_infos" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_registry_provider_infos`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_registry_provider_infos`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/adapterinfos', 'GET',
+            "/replication/adapterinfos",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='dict(str, RegistryProviderInfo)',  # noqa: E501
+            response_type="dict(str, RegistryProviderInfo)",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_registry_provider_types(self, **kwargs):  # noqa: E501
         """List registry adapters  # noqa: E501
 
         List registry adapters  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -686,16 +739,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[str]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_registry_provider_types_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_registry_provider_types_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_registry_provider_types_with_http_info(self, **kwargs):  # noqa: E501
         """List registry adapters  # noqa: E501
@@ -709,73 +762,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[str]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_registry_provider_types" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_registry_provider_types`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_registry_provider_types`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/adapters', 'GET',
+            "/replication/adapters",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[str]',  # noqa: E501
+            response_type="list[str]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def ping_registry(self, registry, **kwargs):  # noqa: E501
         """Check status of a registry  # noqa: E501
 
         Check status of a registry  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -785,16 +845,16 @@
         :param async_req bool
         :param RegistryPing registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_registry_with_http_info(registry, **kwargs)  # noqa: E501
         else:
             (data) = self.ping_registry_with_http_info(registry, **kwargs)  # noqa: E501
             return data
 
     def ping_registry_with_http_info(self, registry, **kwargs):  # noqa: E501
         """Check status of a registry  # noqa: E501
@@ -809,79 +869,88 @@
         :param RegistryPing registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registry', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registry", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registry' is set
-        if self.api_client.client_side_validation and ('registry' not in params or
-                                                       params['registry'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registry` when calling `ping_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registry" not in params or params["registry"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registry` when calling `ping_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registry' in params:
-            body_params = params['registry']
+        if "registry" in params:
+            body_params = params["registry"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/ping', 'POST',
+            "/registries/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_registry(self, id, registry, **kwargs):  # noqa: E501
         """Update the registry  # noqa: E501
 
         Update the registry  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -892,16 +961,16 @@
         :param int id: The registry ID (required)
         :param RegistryUpdate registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_registry_with_http_info(id, registry, **kwargs)  # noqa: E501
         else:
             (data) = self.update_registry_with_http_info(id, registry, **kwargs)  # noqa: E501
             return data
 
     def update_registry_with_http_info(self, id, registry, **kwargs):  # noqa: E501
         """Update the registry  # noqa: E501
@@ -917,78 +986,90 @@
         :param RegistryUpdate registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'registry', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "registry", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `update_registry`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `update_registry`"
+            )  # noqa: E501
         # verify the required parameter 'registry' is set
-        if self.api_client.client_side_validation and ('registry' not in params or
-                                                       params['registry'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registry` when calling `update_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registry" not in params or params["registry"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registry` when calling `update_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registry' in params:
-            body_params = params['registry']
+        if "registry" in params:
+            body_params = params["registry"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/{id}', 'PUT',
+            "/registries/{id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/replication_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/replication_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param ReplicationPolicy policy: The replication policy (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_replication_policy_with_http_info(policy, **kwargs)  # noqa: E501
         else:
             (data) = self.create_replication_policy_with_http_info(policy, **kwargs)  # noqa: E501
             return data
 
     def create_replication_policy_with_http_info(self, policy, **kwargs):  # noqa: E501
         """Create a replication policy  # noqa: E501
@@ -69,79 +69,89 @@
         :param ReplicationPolicy policy: The replication policy (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_replication_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `create_replication_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_replication_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `create_replication_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_replication_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies', 'POST',
+            "/replication/policies",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_replication_policy(self, id, **kwargs):  # noqa: E501
         """Delete the specific replication policy  # noqa: E501
 
         Delete the specific replication policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +161,16 @@
         :param async_req bool
         :param int id: Replication policy ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_replication_policy_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_replication_policy_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def delete_replication_policy_with_http_info(self, id, **kwargs):  # noqa: E501
         """Delete the specific replication policy  # noqa: E501
@@ -175,79 +185,89 @@
         :param int id: Replication policy ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_replication_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `delete_replication_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_replication_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `delete_replication_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_replication_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies/{id}', 'DELETE',
+            "/replication/policies/{id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_replication_execution(self, id, **kwargs):  # noqa: E501
         """Get the specific replication execution  # noqa: E501
 
         Get the replication execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +277,16 @@
         :param async_req bool
         :param int id: The ID of the execution. (required)
         :param str x_request_id: An unique ID for the request
         :return: ReplicationExecution
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_replication_execution_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_replication_execution_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_replication_execution_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the specific replication execution  # noqa: E501
@@ -281,79 +301,89 @@
         :param int id: The ID of the execution. (required)
         :param str x_request_id: An unique ID for the request
         :return: ReplicationExecution
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_replication_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_replication_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_replication_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_replication_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_replication_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions/{id}', 'GET',
+            "/replication/executions/{id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ReplicationExecution',  # noqa: E501
+            response_type="ReplicationExecution",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_replication_log(self, id, task_id, **kwargs):  # noqa: E501
         """Get the log of the specific replication task  # noqa: E501
 
         Get the log of the specific replication task  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -364,16 +394,16 @@
         :param int id: The ID of the execution that the tasks belongs to. (required)
         :param int task_id: The ID of the task. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_replication_log_with_http_info(id, task_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_replication_log_with_http_info(id, task_id, **kwargs)  # noqa: E501
             return data
 
     def get_replication_log_with_http_info(self, id, task_id, **kwargs):  # noqa: E501
         """Get the log of the specific replication task  # noqa: E501
@@ -389,85 +419,95 @@
         :param int task_id: The ID of the task. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'task_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "task_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_replication_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_replication_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_replication_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_replication_log`"
+            )  # noqa: E501
         # verify the required parameter 'task_id' is set
-        if self.api_client.client_side_validation and ('task_id' not in params or
-                                                       params['task_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `task_id` when calling `get_replication_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_replication_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "task_id" not in params or params["task_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `task_id` when calling `get_replication_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_replication_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
-        if 'task_id' in params:
-            path_params['task_id'] = params['task_id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
+        if "task_id" in params:
+            path_params["task_id"] = params["task_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions/{id}/tasks/{task_id}/log', 'GET',
+            "/replication/executions/{id}/tasks/{task_id}/log",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_replication_policy(self, id, **kwargs):  # noqa: E501
         """Get the specific replication policy  # noqa: E501
 
         Get the specific replication policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -477,16 +517,16 @@
         :param async_req bool
         :param int id: Policy ID (required)
         :param str x_request_id: An unique ID for the request
         :return: ReplicationPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_replication_policy_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_replication_policy_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_replication_policy_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the specific replication policy  # noqa: E501
@@ -501,79 +541,89 @@
         :param int id: Policy ID (required)
         :param str x_request_id: An unique ID for the request
         :return: ReplicationPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_replication_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_replication_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_replication_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_replication_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_replication_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies/{id}', 'GET',
+            "/replication/policies/{id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ReplicationPolicy',  # noqa: E501
+            response_type="ReplicationPolicy",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_replication_executions(self, **kwargs):  # noqa: E501
         """List replication executions  # noqa: E501
 
         List replication executions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -588,16 +638,16 @@
         :param int policy_id: The ID of the policy that the executions belong to.
         :param str status: The execution status.
         :param str trigger: The trigger mode.
         :return: list[ReplicationExecution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_replication_executions_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_replication_executions_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_replication_executions_with_http_info(self, **kwargs):  # noqa: E501
         """List replication executions  # noqa: E501
@@ -617,87 +667,106 @@
         :param str status: The execution status.
         :param str trigger: The trigger mode.
         :return: list[ReplicationExecution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'sort', 'page', 'page_size', 'policy_id', 'status', 'trigger']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "sort",
+            "page",
+            "page_size",
+            "policy_id",
+            "status",
+            "trigger",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_replication_executions" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_replication_executions`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_replication_executions`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_replication_executions`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_replication_executions`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'policy_id' in params:
-            query_params.append(('policy_id', params['policy_id']))  # noqa: E501
-        if 'status' in params:
-            query_params.append(('status', params['status']))  # noqa: E501
-        if 'trigger' in params:
-            query_params.append(('trigger', params['trigger']))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "policy_id" in params:
+            query_params.append(("policy_id", params["policy_id"]))  # noqa: E501
+        if "status" in params:
+            query_params.append(("status", params["status"]))  # noqa: E501
+        if "trigger" in params:
+            query_params.append(("trigger", params["trigger"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions', 'GET',
+            "/replication/executions",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ReplicationExecution]',  # noqa: E501
+            response_type="list[ReplicationExecution]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_replication_policies(self, **kwargs):  # noqa: E501
         """List replication policies  # noqa: E501
 
         List replication policies  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -711,16 +780,16 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :param str name: Deprecated, use \"query\" instead. The policy name.
         :return: list[ReplicationPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_replication_policies_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_replication_policies_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_replication_policies_with_http_info(self, **kwargs):  # noqa: E501
         """List replication policies  # noqa: E501
@@ -739,85 +808,96 @@
         :param int page_size: The size of per page
         :param str name: Deprecated, use \"query\" instead. The policy name.
         :return: list[ReplicationPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size', 'name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size", "name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_replication_policies" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_replication_policies`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_replication_policies`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_replication_policies`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_replication_policies`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'name' in params:
-            query_params.append(('name', params['name']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "name" in params:
+            query_params.append(("name", params["name"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies', 'GET',
+            "/replication/policies",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ReplicationPolicy]',  # noqa: E501
+            response_type="list[ReplicationPolicy]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_replication_tasks(self, id, **kwargs):  # noqa: E501
         """List replication tasks for a specific execution  # noqa: E501
 
         List replication tasks for a specific execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -832,16 +912,16 @@
         :param int page_size: The size of per page
         :param str status: The task status.
         :param str resource_type: The resource type.
         :return: list[ReplicationTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_replication_tasks_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.list_replication_tasks_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def list_replication_tasks_with_http_info(self, id, **kwargs):  # noqa: E501
         """List replication tasks for a specific execution  # noqa: E501
@@ -861,91 +941,113 @@
         :param str status: The task status.
         :param str resource_type: The resource type.
         :return: list[ReplicationTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id', 'sort', 'page', 'page_size', 'status', 'resource_type']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "id",
+            "x_request_id",
+            "sort",
+            "page",
+            "page_size",
+            "status",
+            "resource_type",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_replication_tasks" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `list_replication_tasks`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_replication_tasks`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_replication_tasks`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `list_replication_tasks`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_replication_tasks`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_replication_tasks`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'status' in params:
-            query_params.append(('status', params['status']))  # noqa: E501
-        if 'resource_type' in params:
-            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "status" in params:
+            query_params.append(("status", params["status"]))  # noqa: E501
+        if "resource_type" in params:
+            query_params.append(("resource_type", params["resource_type"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions/{id}/tasks', 'GET',
+            "/replication/executions/{id}/tasks",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ReplicationTask]',  # noqa: E501
+            response_type="list[ReplicationTask]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def start_replication(self, execution, **kwargs):  # noqa: E501
         """Start one replication execution  # noqa: E501
 
         Start one replication execution according to the policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -955,16 +1057,16 @@
         :param async_req bool
         :param StartReplicationExecution execution: The ID of policy that the execution belongs to (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.start_replication_with_http_info(execution, **kwargs)  # noqa: E501
         else:
             (data) = self.start_replication_with_http_info(execution, **kwargs)  # noqa: E501
             return data
 
     def start_replication_with_http_info(self, execution, **kwargs):  # noqa: E501
         """Start one replication execution  # noqa: E501
@@ -979,79 +1081,88 @@
         :param StartReplicationExecution execution: The ID of policy that the execution belongs to (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['execution', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["execution", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method start_replication" % key
+                    "Got an unexpected keyword argument '%s'" " to method start_replication" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'execution' is set
-        if self.api_client.client_side_validation and ('execution' not in params or
-                                                       params['execution'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution` when calling `start_replication`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `start_replication`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution" not in params or params["execution"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution` when calling `start_replication`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `start_replication`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'execution' in params:
-            body_params = params['execution']
+        if "execution" in params:
+            body_params = params["execution"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions', 'POST',
+            "/replication/executions",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_replication(self, id, **kwargs):  # noqa: E501
         """Stop the specific replication execution  # noqa: E501
 
         Stop the replication execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1061,16 +1172,16 @@
         :param async_req bool
         :param int id: The ID of the execution. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_replication_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.stop_replication_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def stop_replication_with_http_info(self, id, **kwargs):  # noqa: E501
         """Stop the specific replication execution  # noqa: E501
@@ -1085,79 +1196,88 @@
         :param int id: The ID of the execution. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_replication" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_replication" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `stop_replication`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_replication`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `stop_replication`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_replication`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions/{id}', 'PUT',
+            "/replication/executions/{id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_replication_policy(self, id, policy, **kwargs):  # noqa: E501
         """Update the replication policy  # noqa: E501
 
         Update the replication policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1168,19 +1288,21 @@
         :param int id: The policy ID (required)
         :param ReplicationPolicy policy: The replication policy (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_replication_policy_with_http_info(id, policy, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_replication_policy_with_http_info(id, policy, **kwargs)  # noqa: E501
+            (data) = self.update_replication_policy_with_http_info(
+                id, policy, **kwargs
+            )  # noqa: E501
             return data
 
     def update_replication_policy_with_http_info(self, id, policy, **kwargs):  # noqa: E501
         """Update the replication policy  # noqa: E501
 
         Update the replication policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -1193,78 +1315,91 @@
         :param ReplicationPolicy policy: The replication policy (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_replication_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `update_replication_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `update_replication_policy`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `update_replication_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_replication_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `update_replication_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_replication_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies/{id}', 'PUT',
+            "/replication/policies/{id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/repository_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/robotv1_api.py`

 * *Files 13% similar despite different names*

```diff
@@ -17,608 +17,739 @@
 
 # python 2 and python 3 compatibility library
 import six
 
 from harbor_client.api_client import ApiClient
 
 
-class RepositoryApi(object):
+class Robotv1Api(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def delete_repository(self, project_name, repository_name, **kwargs):  # noqa: E501
-        """Delete repository  # noqa: E501
+    def create_robot_v1(self, project_name_or_id, robot, **kwargs):  # noqa: E501
+        """Create a robot account  # noqa: E501
 
-        Delete the repository specified by name  # noqa: E501
+        Create a robot account  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_repository(project_name, repository_name, async_req=True)
+        >>> thread = api.create_robot_v1(project_name_or_id, robot, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name: The name of the project (required)
-        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param RobotCreateV1 robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
-        :return: None
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: RobotCreated
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_repository_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_robot_v1_with_http_info(
+                project_name_or_id, robot, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_repository_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+            (data) = self.create_robot_v1_with_http_info(
+                project_name_or_id, robot, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_repository_with_http_info(self, project_name, repository_name, **kwargs):  # noqa: E501
-        """Delete repository  # noqa: E501
+    def create_robot_v1_with_http_info(self, project_name_or_id, robot, **kwargs):  # noqa: E501
+        """Create a robot account  # noqa: E501
 
-        Delete the repository specified by name  # noqa: E501
+        Create a robot account  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_repository_with_http_info(project_name, repository_name, async_req=True)
+        >>> thread = api.create_robot_v1_with_http_info(project_name_or_id, robot, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name: The name of the project (required)
-        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param RobotCreateV1 robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
-        :return: None
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: RobotCreated
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "robot",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_repository" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_robot_v1" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `delete_repository`")  # noqa: E501
-        # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `delete_repository`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_repository`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `create_robot_v1`"
+            )  # noqa: E501
+        # verify the required parameter 'robot' is set
+        if self.api_client.client_side_validation and (
+            "robot" not in params or params["robot"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot` when calling `create_robot_v1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_robot_v1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+        if "robot" in params:
+            body_params = params["robot"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}', 'DELETE',
+            "/projects/{project_name_or_id}/robots",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,  # noqa: E501
+            response_type="RobotCreated",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def get_repository(self, project_name, repository_name, **kwargs):  # noqa: E501
-        """Get repository  # noqa: E501
+    def delete_robot_v1(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
+        """Delete a robot account  # noqa: E501
 
-        Get the repository specified by name  # noqa: E501
+        This endpoint deletes specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_repository(project_name, repository_name, async_req=True)
+        >>> thread = api.delete_robot_v1(project_name_or_id, robot_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name: The name of the project (required)
-        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
-        :return: Repository
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_repository_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_robot_v1_with_http_info(
+                project_name_or_id, robot_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_repository_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+            (data) = self.delete_robot_v1_with_http_info(
+                project_name_or_id, robot_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_repository_with_http_info(self, project_name, repository_name, **kwargs):  # noqa: E501
-        """Get repository  # noqa: E501
+    def delete_robot_v1_with_http_info(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
+        """Delete a robot account  # noqa: E501
 
-        Get the repository specified by name  # noqa: E501
+        This endpoint deletes specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_repository_with_http_info(project_name, repository_name, async_req=True)
+        >>> thread = api.delete_robot_v1_with_http_info(project_name_or_id, robot_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name: The name of the project (required)
-        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
-        :return: Repository
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "robot_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_repository" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_robot_v1" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_repository`")  # noqa: E501
-        # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_repository`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_repository`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_robot_v1`"
+            )  # noqa: E501
+        # verify the required parameter 'robot_id' is set
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `delete_robot_v1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_robot_v1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}', 'GET',
+            "/projects/{project_name_or_id}/robots/{robot_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Repository',  # noqa: E501
+            response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def list_all_repositories(self, **kwargs):  # noqa: E501
-        """List all authorized repositories  # noqa: E501
+    def get_robot_by_idv1(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
+        """Get a robot account  # noqa: E501
 
-        List all authorized repositories  # noqa: E501
+        This endpoint returns specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_all_repositories(async_req=True)
+        >>> thread = api.get_robot_by_idv1(project_name_or_id, robot_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
-        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
-        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
-        :param int page: The page number
-        :param int page_size: The size of per page
-        :return: list[Repository]
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: Robot
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_all_repositories_with_http_info(**kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_robot_by_idv1_with_http_info(
+                project_name_or_id, robot_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_all_repositories_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_robot_by_idv1_with_http_info(
+                project_name_or_id, robot_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_all_repositories_with_http_info(self, **kwargs):  # noqa: E501
-        """List all authorized repositories  # noqa: E501
+    def get_robot_by_idv1_with_http_info(
+        self, project_name_or_id, robot_id, **kwargs
+    ):  # noqa: E501
+        """Get a robot account  # noqa: E501
 
-        List all authorized repositories  # noqa: E501
+        This endpoint returns specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_all_repositories_with_http_info(async_req=True)
+        >>> thread = api.get_robot_by_idv1_with_http_info(project_name_or_id, robot_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
-        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
-        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
-        :param int page: The page number
-        :param int page_size: The size of per page
-        :return: list[Repository]
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: Robot
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "robot_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_all_repositories" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_robot_by_idv1" % key
                 )
             params[key] = val
-        del params['kwargs']
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_all_repositories`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_all_repositories`, must be a value less than or equal to `100`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_robot_by_idv1`"
+            )  # noqa: E501
+        # verify the required parameter 'robot_id' is set
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `get_robot_by_idv1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_robot_by_idv1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/repositories', 'GET',
+            "/projects/{project_name_or_id}/robots/{robot_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Repository]',  # noqa: E501
+            response_type="Robot",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def list_repositories(self, project_name, **kwargs):  # noqa: E501
-        """List repositories  # noqa: E501
+    def list_robot_v1(self, project_name_or_id, **kwargs):  # noqa: E501
+        """Get all robot accounts of specified project  # noqa: E501
 
-        List repositories of the specified project  # noqa: E501
+        Get all robot accounts of specified project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_repositories(project_name, async_req=True)
+        >>> thread = api.list_robot_v1(project_name_or_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name: The name of the project (required)
+        :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
-        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
-        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param int page: The page number
         :param int page_size: The size of per page
-        :return: list[Repository]
+        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
+        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
+        :return: list[Robot]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_repositories_with_http_info(project_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_robot_v1_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
-            (data) = self.list_repositories_with_http_info(project_name, **kwargs)  # noqa: E501
+            (data) = self.list_robot_v1_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
-    def list_repositories_with_http_info(self, project_name, **kwargs):  # noqa: E501
-        """List repositories  # noqa: E501
+    def list_robot_v1_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
+        """Get all robot accounts of specified project  # noqa: E501
 
-        List repositories of the specified project  # noqa: E501
+        Get all robot accounts of specified project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_repositories_with_http_info(project_name, async_req=True)
+        >>> thread = api.list_robot_v1_with_http_info(project_name_or_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name: The name of the project (required)
+        :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
-        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
-        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param int page: The page number
         :param int page_size: The size of per page
-        :return: list[Repository]
+        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
+        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
+        :return: list[Robot]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_repositories" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_robot_v1" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_repositories`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_repositories`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_repositories`, must be a value less than or equal to `100`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_robot_v1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_robot_v1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_robot_v1`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories', 'GET',
+            "/projects/{project_name_or_id}/robots",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Repository]',  # noqa: E501
+            response_type="list[Robot]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def update_repository(self, project_name, repository_name, repository, **kwargs):  # noqa: E501
-        """Update repository  # noqa: E501
+    def update_robot_v1(self, project_name_or_id, robot_id, robot, **kwargs):  # noqa: E501
+        """Update status of robot account.  # noqa: E501
 
-        Update the repository specified by name  # noqa: E501
+        Used to disable/enable a specified robot account.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_repository(project_name, repository_name, repository, async_req=True)
+        >>> thread = api.update_robot_v1(project_name_or_id, robot_id, robot, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name: The name of the project (required)
-        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
-        :param Repository repository: The JSON object of repository. (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int robot_id: Robot ID (required)
+        :param Robot robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_repository_with_http_info(project_name, repository_name, repository, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_robot_v1_with_http_info(
+                project_name_or_id, robot_id, robot, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_repository_with_http_info(project_name, repository_name, repository, **kwargs)  # noqa: E501
+            (data) = self.update_robot_v1_with_http_info(
+                project_name_or_id, robot_id, robot, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_repository_with_http_info(self, project_name, repository_name, repository, **kwargs):  # noqa: E501
-        """Update repository  # noqa: E501
+    def update_robot_v1_with_http_info(
+        self, project_name_or_id, robot_id, robot, **kwargs
+    ):  # noqa: E501
+        """Update status of robot account.  # noqa: E501
 
-        Update the repository specified by name  # noqa: E501
+        Used to disable/enable a specified robot account.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_repository_with_http_info(project_name, repository_name, repository, async_req=True)
+        >>> thread = api.update_robot_v1_with_http_info(project_name_or_id, robot_id, robot, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name: The name of the project (required)
-        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
-        :param Repository repository: The JSON object of repository. (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int robot_id: Robot ID (required)
+        :param Robot robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'repository', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "robot_id",
+            "robot",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_repository" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_robot_v1" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `update_repository`")  # noqa: E501
-        # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `update_repository`")  # noqa: E501
-        # verify the required parameter 'repository' is set
-        if self.api_client.client_side_validation and ('repository' not in params or
-                                                       params['repository'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository` when calling `update_repository`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_repository`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_robot_v1`"
+            )  # noqa: E501
+        # verify the required parameter 'robot_id' is set
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `update_robot_v1`"
+            )  # noqa: E501
+        # verify the required parameter 'robot' is set
+        if self.api_client.client_side_validation and (
+            "robot" not in params or params["robot"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot` when calling `update_robot_v1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_robot_v1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'repository' in params:
-            body_params = params['repository']
+        if "robot" in params:
+            body_params = params["robot"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}', 'PUT',
+            "/projects/{project_name_or_id}/robots/{robot_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/retention_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/user_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -17,1142 +17,1339 @@
 
 # python 2 and python 3 compatibility library
 import six
 
 from harbor_client.api_client import ApiClient
 
 
-class RetentionApi(object):
+class UserApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_retention(self, policy, **kwargs):  # noqa: E501
-        """Create Retention Policy  # noqa: E501
+    def create_user(self, user_req, **kwargs):  # noqa: E501
+        """Create a local user.  # noqa: E501
 
-        Create Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when no retention policy binded to project yet.  # noqa: E501
+        This API can be used only when the authentication mode is for local DB.  When self registration is disabled.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_retention(policy, async_req=True)
+        >>> thread = api.create_user(user_req, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param RetentionPolicy policy: Create Retention Policy successfully. (required)
+        :param UserCreationReq user_req: The new user (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_retention_with_http_info(policy, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_user_with_http_info(user_req, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_retention_with_http_info(policy, **kwargs)  # noqa: E501
+            (data) = self.create_user_with_http_info(user_req, **kwargs)  # noqa: E501
             return data
 
-    def create_retention_with_http_info(self, policy, **kwargs):  # noqa: E501
-        """Create Retention Policy  # noqa: E501
+    def create_user_with_http_info(self, user_req, **kwargs):  # noqa: E501
+        """Create a local user.  # noqa: E501
 
-        Create Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when no retention policy binded to project yet.  # noqa: E501
+        This API can be used only when the authentication mode is for local DB.  When self registration is disabled.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_retention_with_http_info(policy, async_req=True)
+        >>> thread = api.create_user_with_http_info(user_req, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param RetentionPolicy policy: Create Retention Policy successfully. (required)
+        :param UserCreationReq user_req: The new user (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_req", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_retention" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_user" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `create_retention`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_retention`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'user_req' is set
+        if self.api_client.client_side_validation and (
+            "user_req" not in params or params["user_req"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_req` when calling `create_user`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "user_req" in params:
+            body_params = params["user_req"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions', 'POST',
+            "/users",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def delete_retention(self, id, **kwargs):  # noqa: E501
-        """Delete Retention Policy  # noqa: E501
+    def delete_user(self, user_id, **kwargs):  # noqa: E501
+        """Mark a registered user as be removed.  # noqa: E501
 
-        Delete Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.  # noqa: E501
+        This endpoint let administrator of Harbor mark a registered user as removed.It actually won't be deleted from DB.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_retention(id, async_req=True)
+        >>> thread = api.delete_user(user_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
+        :param int user_id: User ID for marking as to be removed. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_retention_with_http_info(id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_user_with_http_info(user_id, **kwargs)  # noqa: E501
         else:
-            (data) = self.delete_retention_with_http_info(id, **kwargs)  # noqa: E501
+            (data) = self.delete_user_with_http_info(user_id, **kwargs)  # noqa: E501
             return data
 
-    def delete_retention_with_http_info(self, id, **kwargs):  # noqa: E501
-        """Delete Retention Policy  # noqa: E501
+    def delete_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
+        """Mark a registered user as be removed.  # noqa: E501
 
-        Delete Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.  # noqa: E501
+        This endpoint let administrator of Harbor mark a registered user as removed.It actually won't be deleted from DB.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_retention_with_http_info(id, async_req=True)
+        >>> thread = api.delete_user_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
+        :param int user_id: User ID for marking as to be removed. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_retention" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_user" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `delete_retention`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_retention`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'user_id' is set
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `delete_user`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}', 'DELETE',
+            "/users/{user_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def get_rentenition_metadata(self, **kwargs):  # noqa: E501
-        """Get Retention Metadatas  # noqa: E501
+    def get_current_user_info(self, **kwargs):  # noqa: E501
+        """Get current user info.  # noqa: E501
 
-        Get Retention Metadatas.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_rentenition_metadata(async_req=True)
+        >>> thread = api.get_current_user_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
-        :return: RetentionMetadata
+        :return: UserResp
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_rentenition_metadata_with_http_info(**kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_current_user_info_with_http_info(**kwargs)  # noqa: E501
         else:
-            (data) = self.get_rentenition_metadata_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_current_user_info_with_http_info(**kwargs)  # noqa: E501
             return data
 
-    def get_rentenition_metadata_with_http_info(self, **kwargs):  # noqa: E501
-        """Get Retention Metadatas  # noqa: E501
+    def get_current_user_info_with_http_info(self, **kwargs):  # noqa: E501
+        """Get current user info.  # noqa: E501
 
-        Get Retention Metadatas.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_rentenition_metadata_with_http_info(async_req=True)
+        >>> thread = api.get_current_user_info_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
-        :return: RetentionMetadata
+        :return: UserResp
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_rentenition_metadata" % key
+                    " to method get_current_user_info" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_rentenition_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_current_user_info`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/metadatas', 'GET',
+            "/users/current",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RetentionMetadata',  # noqa: E501
+            response_type="UserResp",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def get_retention(self, id, **kwargs):  # noqa: E501
-        """Get Retention Policy  # noqa: E501
+    def get_current_user_permissions(self, **kwargs):  # noqa: E501
+        """Get current user permissions.  # noqa: E501
 
-        Get Retention Policy.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_retention(id, async_req=True)
+        >>> thread = api.get_current_user_permissions(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
         :param str x_request_id: An unique ID for the request
-        :return: RetentionPolicy
+        :param str scope: The scope for the permission
+        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'.
+        :return: list[Permission]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_retention_with_http_info(id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_current_user_permissions_with_http_info(**kwargs)  # noqa: E501
         else:
-            (data) = self.get_retention_with_http_info(id, **kwargs)  # noqa: E501
+            (data) = self.get_current_user_permissions_with_http_info(**kwargs)  # noqa: E501
             return data
 
-    def get_retention_with_http_info(self, id, **kwargs):  # noqa: E501
-        """Get Retention Policy  # noqa: E501
+    def get_current_user_permissions_with_http_info(self, **kwargs):  # noqa: E501
+        """Get current user permissions.  # noqa: E501
 
-        Get Retention Policy.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_retention_with_http_info(id, async_req=True)
+        >>> thread = api.get_current_user_permissions_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
         :param str x_request_id: An unique ID for the request
-        :return: RetentionPolicy
+        :param str scope: The scope for the permission
+        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'.
+        :return: list[Permission]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "scope", "relative"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_retention" % key
+                    " to method get_current_user_permissions" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_retention`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_retention`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_current_user_permissions`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
 
         query_params = []
+        if "scope" in params:
+            query_params.append(("scope", params["scope"]))  # noqa: E501
+        if "relative" in params:
+            query_params.append(("relative", params["relative"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}', 'GET',
+            "/users/current/permissions",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RetentionPolicy',  # noqa: E501
+            response_type="list[Permission]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def get_retention_task_log(self, id, eid, tid, **kwargs):  # noqa: E501
-        """Get Retention job task log  # noqa: E501
+    def get_user(self, user_id, **kwargs):  # noqa: E501
+        """Get a user's profile.  # noqa: E501
 
-        Get Retention job task log, tags ratain or deletion detail will be shown in a table.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_retention_task_log(id, eid, tid, async_req=True)
+        >>> thread = api.get_user(user_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param int eid: Retention execution ID. (required)
-        :param int tid: Retention execution ID. (required)
+        :param int user_id: (required)
         :param str x_request_id: An unique ID for the request
-        :return: str
+        :return: UserResp
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_retention_task_log_with_http_info(id, eid, tid, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_retention_task_log_with_http_info(id, eid, tid, **kwargs)  # noqa: E501
+            (data) = self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
             return data
 
-    def get_retention_task_log_with_http_info(self, id, eid, tid, **kwargs):  # noqa: E501
-        """Get Retention job task log  # noqa: E501
+    def get_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
+        """Get a user's profile.  # noqa: E501
 
-        Get Retention job task log, tags ratain or deletion detail will be shown in a table.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_retention_task_log_with_http_info(id, eid, tid, async_req=True)
+        >>> thread = api.get_user_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param int eid: Retention execution ID. (required)
-        :param int tid: Retention execution ID. (required)
+        :param int user_id: (required)
         :param str x_request_id: An unique ID for the request
-        :return: str
+        :return: UserResp
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'eid', 'tid', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_retention_task_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_user" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_retention_task_log`")  # noqa: E501
-        # verify the required parameter 'eid' is set
-        if self.api_client.client_side_validation and ('eid' not in params or
-                                                       params['eid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `eid` when calling `get_retention_task_log`")  # noqa: E501
-        # verify the required parameter 'tid' is set
-        if self.api_client.client_side_validation and ('tid' not in params or
-                                                       params['tid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `tid` when calling `get_retention_task_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_retention_task_log`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'user_id' is set
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `get_user`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
-        if 'eid' in params:
-            path_params['eid'] = params['eid']  # noqa: E501
-        if 'tid' in params:
-            path_params['tid'] = params['tid']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions/{eid}/tasks/{tid}', 'GET',
+            "/users/{user_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="UserResp",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def list_retention_executions(self, id, **kwargs):  # noqa: E501
-        """Get Retention executions  # noqa: E501
+    def list_users(self, **kwargs):  # noqa: E501
+        """List users  # noqa: E501
 
-        Get Retention executions, execution status may be delayed before job service schedule it up.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_retention_executions(id, async_req=True)
+        >>> thread = api.list_users(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
         :param str x_request_id: An unique ID for the request
-        :param int page: The page number.
-        :param int page_size: The size of per page.
-        :return: list[RetentionExecution]
+        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
+        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
+        :param int page: The page number
+        :param int page_size: The size of per page
+        :return: list[UserResp]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_retention_executions_with_http_info(id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_users_with_http_info(**kwargs)  # noqa: E501
         else:
-            (data) = self.list_retention_executions_with_http_info(id, **kwargs)  # noqa: E501
+            (data) = self.list_users_with_http_info(**kwargs)  # noqa: E501
             return data
 
-    def list_retention_executions_with_http_info(self, id, **kwargs):  # noqa: E501
-        """Get Retention executions  # noqa: E501
+    def list_users_with_http_info(self, **kwargs):  # noqa: E501
+        """List users  # noqa: E501
 
-        Get Retention executions, execution status may be delayed before job service schedule it up.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_retention_executions_with_http_info(id, async_req=True)
+        >>> thread = api.list_users_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
         :param str x_request_id: An unique ID for the request
-        :param int page: The page number.
-        :param int page_size: The size of per page.
-        :return: list[RetentionExecution]
+        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
+        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
+        :param int page: The page number
+        :param int page_size: The size of per page
+        :return: list[UserResp]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_retention_executions" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_users" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `list_retention_executions`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_retention_executions`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_users`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_users`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions', 'GET',
+            "/users",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[RetentionExecution]',  # noqa: E501
+            response_type="list[UserResp]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def list_retention_tasks(self, id, eid, **kwargs):  # noqa: E501
-        """Get Retention tasks  # noqa: E501
+    def search_users(self, username, **kwargs):  # noqa: E501
+        """Search users by username  # noqa: E501
 
-        Get Retention tasks, each repository as a task.  # noqa: E501
+        This endpoint is to search the users by username.  It's open for all authenticated requests.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_retention_tasks(id, eid, async_req=True)
+        >>> thread = api.search_users(username, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param int eid: Retention execution ID. (required)
+        :param str username: Username for filtering results. (required)
         :param str x_request_id: An unique ID for the request
-        :param int page: The page number.
-        :param int page_size: The size of per page.
-        :return: list[RetentionExecutionTask]
+        :param int page: The page number
+        :param int page_size: The size of per page
+        :return: list[UserSearchRespItem]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_retention_tasks_with_http_info(id, eid, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.search_users_with_http_info(username, **kwargs)  # noqa: E501
         else:
-            (data) = self.list_retention_tasks_with_http_info(id, eid, **kwargs)  # noqa: E501
+            (data) = self.search_users_with_http_info(username, **kwargs)  # noqa: E501
             return data
 
-    def list_retention_tasks_with_http_info(self, id, eid, **kwargs):  # noqa: E501
-        """Get Retention tasks  # noqa: E501
+    def search_users_with_http_info(self, username, **kwargs):  # noqa: E501
+        """Search users by username  # noqa: E501
 
-        Get Retention tasks, each repository as a task.  # noqa: E501
+        This endpoint is to search the users by username.  It's open for all authenticated requests.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_retention_tasks_with_http_info(id, eid, async_req=True)
+        >>> thread = api.search_users_with_http_info(username, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param int eid: Retention execution ID. (required)
+        :param str username: Username for filtering results. (required)
         :param str x_request_id: An unique ID for the request
-        :param int page: The page number.
-        :param int page_size: The size of per page.
-        :return: list[RetentionExecutionTask]
+        :param int page: The page number
+        :param int page_size: The size of per page
+        :return: list[UserSearchRespItem]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'eid', 'x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["username", "x_request_id", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_retention_tasks" % key
+                    "Got an unexpected keyword argument '%s'" " to method search_users" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `list_retention_tasks`")  # noqa: E501
-        # verify the required parameter 'eid' is set
-        if self.api_client.client_side_validation and ('eid' not in params or
-                                                       params['eid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `eid` when calling `list_retention_tasks`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_retention_tasks`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'username' is set
+        if self.api_client.client_side_validation and (
+            "username" not in params or params["username"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `username` when calling `search_users`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search_users`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `search_users`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
-        if 'eid' in params:
-            path_params['eid'] = params['eid']  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "username" in params:
+            query_params.append(("username", params["username"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions/{eid}/tasks', 'GET',
+            "/users/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[RetentionExecutionTask]',  # noqa: E501
+            response_type="list[UserSearchRespItem]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def operate_retention_execution(self, id, eid, body, **kwargs):  # noqa: E501
-        """Stop a Retention execution  # noqa: E501
+    def set_cli_secret(self, user_id, secret, **kwargs):  # noqa: E501
+        """Set CLI secret for a user.  # noqa: E501
 
-        Stop a Retention execution, only support \"stop\" action now.  # noqa: E501
+        This endpoint let user generate a new CLI secret for himself.  This API only works when auth mode is set to 'OIDC'. Once this API returns with successful status, the old secret will be invalid, as there will be only one CLI secret for a user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.operate_retention_execution(id, eid, body, async_req=True)
+        >>> thread = api.set_cli_secret(user_id, secret, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param int eid: Retention execution ID. (required)
-        :param Body1 body: The action, only support \"stop\" now. (required)
+        :param int user_id: User ID (required)
+        :param OIDCCliSecretReq secret: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.operate_retention_execution_with_http_info(id, eid, body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.set_cli_secret_with_http_info(user_id, secret, **kwargs)  # noqa: E501
         else:
-            (data) = self.operate_retention_execution_with_http_info(id, eid, body, **kwargs)  # noqa: E501
+            (data) = self.set_cli_secret_with_http_info(user_id, secret, **kwargs)  # noqa: E501
             return data
 
-    def operate_retention_execution_with_http_info(self, id, eid, body, **kwargs):  # noqa: E501
-        """Stop a Retention execution  # noqa: E501
+    def set_cli_secret_with_http_info(self, user_id, secret, **kwargs):  # noqa: E501
+        """Set CLI secret for a user.  # noqa: E501
 
-        Stop a Retention execution, only support \"stop\" action now.  # noqa: E501
+        This endpoint let user generate a new CLI secret for himself.  This API only works when auth mode is set to 'OIDC'. Once this API returns with successful status, the old secret will be invalid, as there will be only one CLI secret for a user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.operate_retention_execution_with_http_info(id, eid, body, async_req=True)
+        >>> thread = api.set_cli_secret_with_http_info(user_id, secret, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param int eid: Retention execution ID. (required)
-        :param Body1 body: The action, only support \"stop\" now. (required)
+        :param int user_id: User ID (required)
+        :param OIDCCliSecretReq secret: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'eid', 'body', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "secret", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method operate_retention_execution" % key
+                    "Got an unexpected keyword argument '%s'" " to method set_cli_secret" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `operate_retention_execution`")  # noqa: E501
-        # verify the required parameter 'eid' is set
-        if self.api_client.client_side_validation and ('eid' not in params or
-                                                       params['eid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `eid` when calling `operate_retention_execution`")  # noqa: E501
-        # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and ('body' not in params or
-                                                       params['body'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `body` when calling `operate_retention_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `operate_retention_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'user_id' is set
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `set_cli_secret`"
+            )  # noqa: E501
+        # verify the required parameter 'secret' is set
+        if self.api_client.client_side_validation and (
+            "secret" not in params or params["secret"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `secret` when calling `set_cli_secret`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `set_cli_secret`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
-        if 'eid' in params:
-            path_params['eid'] = params['eid']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        if "secret" in params:
+            body_params = params["secret"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions/{eid}', 'PATCH',
+            "/users/{user_id}/cli_secret",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def trigger_retention_execution(self, id, body, **kwargs):  # noqa: E501
-        """Trigger a Retention Execution  # noqa: E501
+    def set_user_sys_admin(self, user_id, sysadmin_flag, **kwargs):  # noqa: E501
+        """Update a registered user to change to be an administrator of Harbor.  # noqa: E501
 
-        Trigger a Retention Execution, if dry_run is True, nothing would be deleted actually.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.trigger_retention_execution(id, body, async_req=True)
+        >>> thread = api.set_user_sys_admin(user_id, sysadmin_flag, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param Body body: (required)
+        :param int user_id: (required)
+        :param UserSysAdminFlag sysadmin_flag: Toggle a user to admin or not. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.trigger_retention_execution_with_http_info(id, body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.set_user_sys_admin_with_http_info(
+                user_id, sysadmin_flag, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.trigger_retention_execution_with_http_info(id, body, **kwargs)  # noqa: E501
+            (data) = self.set_user_sys_admin_with_http_info(
+                user_id, sysadmin_flag, **kwargs
+            )  # noqa: E501
             return data
 
-    def trigger_retention_execution_with_http_info(self, id, body, **kwargs):  # noqa: E501
-        """Trigger a Retention Execution  # noqa: E501
+    def set_user_sys_admin_with_http_info(self, user_id, sysadmin_flag, **kwargs):  # noqa: E501
+        """Update a registered user to change to be an administrator of Harbor.  # noqa: E501
 
-        Trigger a Retention Execution, if dry_run is True, nothing would be deleted actually.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.trigger_retention_execution_with_http_info(id, body, async_req=True)
+        >>> thread = api.set_user_sys_admin_with_http_info(user_id, sysadmin_flag, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param Body body: (required)
+        :param int user_id: (required)
+        :param UserSysAdminFlag sysadmin_flag: Toggle a user to admin or not. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'body', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "sysadmin_flag", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method trigger_retention_execution" % key
+                    "Got an unexpected keyword argument '%s'" " to method set_user_sys_admin" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `trigger_retention_execution`")  # noqa: E501
-        # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and ('body' not in params or
-                                                       params['body'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `body` when calling `trigger_retention_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `trigger_retention_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'user_id' is set
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `set_user_sys_admin`"
+            )  # noqa: E501
+        # verify the required parameter 'sysadmin_flag' is set
+        if self.api_client.client_side_validation and (
+            "sysadmin_flag" not in params or params["sysadmin_flag"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `sysadmin_flag` when calling `set_user_sys_admin`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `set_user_sys_admin`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        if "sysadmin_flag" in params:
+            body_params = params["sysadmin_flag"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions', 'POST',
+            "/users/{user_id}/sysadmin",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def update_retention(self, id, policy, **kwargs):  # noqa: E501
-        """Update Retention Policy  # noqa: E501
+    def update_user_password(self, user_id, password, **kwargs):  # noqa: E501
+        """Change the password on a user that already exists.  # noqa: E501
 
-        Update Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.  # noqa: E501
+        This endpoint is for user to update password. Users with the admin role can change any user's password. Regular users can change only their own password.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_retention(id, policy, async_req=True)
+        >>> thread = api.update_user_password(user_id, password, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param RetentionPolicy policy: (required)
+        :param int user_id: (required)
+        :param PasswordReq password: Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_retention_with_http_info(id, policy, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_user_password_with_http_info(
+                user_id, password, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_retention_with_http_info(id, policy, **kwargs)  # noqa: E501
+            (data) = self.update_user_password_with_http_info(
+                user_id, password, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_retention_with_http_info(self, id, policy, **kwargs):  # noqa: E501
-        """Update Retention Policy  # noqa: E501
+    def update_user_password_with_http_info(self, user_id, password, **kwargs):  # noqa: E501
+        """Change the password on a user that already exists.  # noqa: E501
 
-        Update Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.  # noqa: E501
+        This endpoint is for user to update password. Users with the admin role can change any user's password. Regular users can change only their own password.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_retention_with_http_info(id, policy, async_req=True)
+        >>> thread = api.update_user_password_with_http_info(user_id, password, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int id: Retention ID. (required)
-        :param RetentionPolicy policy: (required)
+        :param int user_id: (required)
+        :param PasswordReq password: Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "password", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_retention" % key
+                    " to method update_user_password" % key
+                )
+            params[key] = val
+        del params["kwargs"]
+        # verify the required parameter 'user_id' is set
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `update_user_password`"
+            )  # noqa: E501
+        # verify the required parameter 'password' is set
+        if self.api_client.client_side_validation and (
+            "password" not in params or params["password"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `password` when calling `update_user_password`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_user_password`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        collection_formats = {}
+
+        path_params = {}
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if "password" in params:
+            body_params = params["password"]
+        # HTTP header `Accept`
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ["basic"]  # noqa: E501
+
+        return self.api_client.call_api(
+            "/users/{user_id}/password",
+            "PUT",
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type=None,  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def update_user_profile(self, user_id, profile, **kwargs):  # noqa: E501
+        """Update user's profile.  # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_user_profile(user_id, profile, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int user_id: Registered user ID (required)
+        :param UserProfile profile: Only email, realname and comment can be modified. (required)
+        :param str x_request_id: An unique ID for the request
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_user_profile_with_http_info(user_id, profile, **kwargs)  # noqa: E501
+        else:
+            (data) = self.update_user_profile_with_http_info(
+                user_id, profile, **kwargs
+            )  # noqa: E501
+            return data
+
+    def update_user_profile_with_http_info(self, user_id, profile, **kwargs):  # noqa: E501
+        """Update user's profile.  # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_user_profile_with_http_info(user_id, profile, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param int user_id: Registered user ID (required)
+        :param UserProfile profile: Only email, realname and comment can be modified. (required)
+        :param str x_request_id: An unique ID for the request
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        all_params = ["user_id", "profile", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
+
+        params = locals()
+        for key, val in six.iteritems(params["kwargs"]):
+            if key not in all_params:
+                raise TypeError(
+                    "Got an unexpected keyword argument '%s'" " to method update_user_profile" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `update_retention`")  # noqa: E501
-        # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `update_retention`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_retention`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'user_id' is set
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `update_user_profile`"
+            )  # noqa: E501
+        # verify the required parameter 'profile' is set
+        if self.api_client.client_side_validation and (
+            "profile" not in params or params["profile"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `profile` when calling `update_user_profile`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_user_profile`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "profile" in params:
+            body_params = params["profile"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}', 'PUT',
+            "/users/{user_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/robot_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/robot_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param RobotCreate robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: RobotCreated
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_robot_with_http_info(robot, **kwargs)  # noqa: E501
         else:
             (data) = self.create_robot_with_http_info(robot, **kwargs)  # noqa: E501
             return data
 
     def create_robot_with_http_info(self, robot, **kwargs):  # noqa: E501
         """Create a robot account  # noqa: E501
@@ -69,79 +69,88 @@
         :param RobotCreate robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: RobotCreated
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_robot" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_robot" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot' is set
-        if self.api_client.client_side_validation and ('robot' not in params or
-                                                       params['robot'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot` when calling `create_robot`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_robot`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot" not in params or params["robot"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot` when calling `create_robot`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_robot`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot' in params:
-            body_params = params['robot']
+        if "robot" in params:
+            body_params = params["robot"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots', 'POST',
+            "/robots",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RobotCreated',  # noqa: E501
+            response_type="RobotCreated",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_robot(self, robot_id, **kwargs):  # noqa: E501
         """Delete a robot account  # noqa: E501
 
         This endpoint deletes specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_robot_with_http_info(robot_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_robot_with_http_info(robot_id, **kwargs)  # noqa: E501
             return data
 
     def delete_robot_with_http_info(self, robot_id, **kwargs):  # noqa: E501
         """Delete a robot account  # noqa: E501
@@ -175,79 +184,88 @@
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_robot" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_robot" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `delete_robot`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_robot`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `delete_robot`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_robot`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots/{robot_id}', 'DELETE',
+            "/robots/{robot_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_robot_by_id(self, robot_id, **kwargs):  # noqa: E501
         """Get a robot account  # noqa: E501
 
         This endpoint returns specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +275,16 @@
         :param async_req bool
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Robot
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_robot_by_id_with_http_info(robot_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_robot_by_id_with_http_info(robot_id, **kwargs)  # noqa: E501
             return data
 
     def get_robot_by_id_with_http_info(self, robot_id, **kwargs):  # noqa: E501
         """Get a robot account  # noqa: E501
@@ -281,79 +299,88 @@
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Robot
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_robot_by_id" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_robot_by_id" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `get_robot_by_id`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_robot_by_id`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `get_robot_by_id`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_robot_by_id`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots/{robot_id}', 'GET',
+            "/robots/{robot_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Robot',  # noqa: E501
+            response_type="Robot",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_robot(self, **kwargs):  # noqa: E501
         """Get robot account  # noqa: E501
 
         List the robot accounts with the specified level and project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -366,16 +393,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Robot]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_robot_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_robot_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_robot_with_http_info(self, **kwargs):  # noqa: E501
         """Get robot account  # noqa: E501
@@ -393,83 +420,93 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Robot]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_robot" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_robot" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_robot`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_robot`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_robot`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_robot`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots', 'GET',
+            "/robots",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Robot]',  # noqa: E501
+            response_type="list[Robot]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def refresh_sec(self, robot_id, robot_sec, **kwargs):  # noqa: E501
         """Refresh the robot secret  # noqa: E501
 
         Refresh the robot secret  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -480,16 +517,16 @@
         :param int robot_id: Robot ID (required)
         :param RobotSec robot_sec: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: RobotSec
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.refresh_sec_with_http_info(robot_id, robot_sec, **kwargs)  # noqa: E501
         else:
             (data) = self.refresh_sec_with_http_info(robot_id, robot_sec, **kwargs)  # noqa: E501
             return data
 
     def refresh_sec_with_http_info(self, robot_id, robot_sec, **kwargs):  # noqa: E501
         """Refresh the robot secret  # noqa: E501
@@ -505,85 +542,97 @@
         :param RobotSec robot_sec: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: RobotSec
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot_id', 'robot_sec', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot_id", "robot_sec", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method refresh_sec" % key
+                    "Got an unexpected keyword argument '%s'" " to method refresh_sec" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `refresh_sec`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `refresh_sec`"
+            )  # noqa: E501
         # verify the required parameter 'robot_sec' is set
-        if self.api_client.client_side_validation and ('robot_sec' not in params or
-                                                       params['robot_sec'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_sec` when calling `refresh_sec`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `refresh_sec`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_sec" not in params or params["robot_sec"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_sec` when calling `refresh_sec`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `refresh_sec`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot_sec' in params:
-            body_params = params['robot_sec']
+        if "robot_sec" in params:
+            body_params = params["robot_sec"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots/{robot_id}', 'PATCH',
+            "/robots/{robot_id}",
+            "PATCH",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RobotSec',  # noqa: E501
+            response_type="RobotSec",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_robot(self, robot_id, robot, **kwargs):  # noqa: E501
         """Update a robot account  # noqa: E501
 
         This endpoint updates specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -594,16 +643,16 @@
         :param int robot_id: Robot ID (required)
         :param Robot robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_robot_with_http_info(robot_id, robot, **kwargs)  # noqa: E501
         else:
             (data) = self.update_robot_with_http_info(robot_id, robot, **kwargs)  # noqa: E501
             return data
 
     def update_robot_with_http_info(self, robot_id, robot, **kwargs):  # noqa: E501
         """Update a robot account  # noqa: E501
@@ -619,78 +668,90 @@
         :param Robot robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot_id', 'robot', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot_id", "robot", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_robot" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_robot" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `update_robot`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `update_robot`"
+            )  # noqa: E501
         # verify the required parameter 'robot' is set
-        if self.api_client.client_side_validation and ('robot' not in params or
-                                                       params['robot'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot` when calling `update_robot`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_robot`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot" not in params or params["robot"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot` when calling `update_robot`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_robot`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot' in params:
-            body_params = params['robot']
+        if "robot" in params:
+            body_params = params["robot"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots/{robot_id}', 'PUT',
+            "/robots/{robot_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/robotv1_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/robotv1_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -47,19 +47,23 @@
         :param RobotCreateV1 robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: RobotCreated
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_robot_v1_with_http_info(project_name_or_id, robot, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_robot_v1_with_http_info(
+                project_name_or_id, robot, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_robot_v1_with_http_info(project_name_or_id, robot, **kwargs)  # noqa: E501
+            (data) = self.create_robot_v1_with_http_info(
+                project_name_or_id, robot, **kwargs
+            )  # noqa: E501
             return data
 
     def create_robot_v1_with_http_info(self, project_name_or_id, robot, **kwargs):  # noqa: E501
         """Create a robot account  # noqa: E501
 
         Create a robot account  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -73,87 +77,104 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: RobotCreated
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'robot', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "robot",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_robot_v1" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_robot_v1" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `create_robot_v1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `create_robot_v1`"
+            )  # noqa: E501
         # verify the required parameter 'robot' is set
-        if self.api_client.client_side_validation and ('robot' not in params or
-                                                       params['robot'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot` when calling `create_robot_v1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_robot_v1`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot" not in params or params["robot"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot` when calling `create_robot_v1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_robot_v1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot' in params:
-            body_params = params['robot']
+        if "robot" in params:
+            body_params = params["robot"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots', 'POST',
+            "/projects/{project_name_or_id}/robots",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RobotCreated',  # noqa: E501
+            response_type="RobotCreated",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_robot_v1(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
         """Delete a robot account  # noqa: E501
 
         This endpoint deletes specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -165,19 +186,23 @@
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_robot_v1_with_http_info(project_name_or_id, robot_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_robot_v1_with_http_info(
+                project_name_or_id, robot_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_robot_v1_with_http_info(project_name_or_id, robot_id, **kwargs)  # noqa: E501
+            (data) = self.delete_robot_v1_with_http_info(
+                project_name_or_id, robot_id, **kwargs
+            )  # noqa: E501
             return data
 
     def delete_robot_v1_with_http_info(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
         """Delete a robot account  # noqa: E501
 
         This endpoint deletes specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -191,87 +216,104 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'robot_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "robot_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_robot_v1" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_robot_v1" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_robot_v1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_robot_v1`"
+            )  # noqa: E501
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `delete_robot_v1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_robot_v1`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `delete_robot_v1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_robot_v1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots/{robot_id}', 'DELETE',
+            "/projects/{project_name_or_id}/robots/{robot_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_robot_by_idv1(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
         """Get a robot account  # noqa: E501
 
         This endpoint returns specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -283,22 +325,28 @@
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: Robot
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_robot_by_idv1_with_http_info(project_name_or_id, robot_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_robot_by_idv1_with_http_info(
+                project_name_or_id, robot_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_robot_by_idv1_with_http_info(project_name_or_id, robot_id, **kwargs)  # noqa: E501
+            (data) = self.get_robot_by_idv1_with_http_info(
+                project_name_or_id, robot_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_robot_by_idv1_with_http_info(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
+    def get_robot_by_idv1_with_http_info(
+        self, project_name_or_id, robot_id, **kwargs
+    ):  # noqa: E501
         """Get a robot account  # noqa: E501
 
         This endpoint returns specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_robot_by_idv1_with_http_info(project_name_or_id, robot_id, async_req=True)
         >>> result = thread.get()
@@ -309,87 +357,104 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: Robot
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'robot_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "robot_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_robot_by_idv1" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_robot_by_idv1" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_robot_by_idv1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_robot_by_idv1`"
+            )  # noqa: E501
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `get_robot_by_idv1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_robot_by_idv1`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `get_robot_by_idv1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_robot_by_idv1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots/{robot_id}', 'GET',
+            "/projects/{project_name_or_id}/robots/{robot_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Robot',  # noqa: E501
+            response_type="Robot",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_robot_v1(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get all robot accounts of specified project  # noqa: E501
 
         Get all robot accounts of specified project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -404,16 +469,16 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Robot]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_robot_v1_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
             (data) = self.list_robot_v1_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
     def list_robot_v1_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get all robot accounts of specified project  # noqa: E501
@@ -433,91 +498,112 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Robot]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_robot_v1" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_robot_v1" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_robot_v1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_robot_v1`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_robot_v1`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_robot_v1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_robot_v1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_robot_v1`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots', 'GET',
+            "/projects/{project_name_or_id}/robots",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Robot]',  # noqa: E501
+            response_type="list[Robot]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_robot_v1(self, project_name_or_id, robot_id, robot, **kwargs):  # noqa: E501
         """Update status of robot account.  # noqa: E501
 
         Used to disable/enable a specified robot account.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -530,22 +616,28 @@
         :param Robot robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_robot_v1_with_http_info(project_name_or_id, robot_id, robot, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_robot_v1_with_http_info(
+                project_name_or_id, robot_id, robot, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_robot_v1_with_http_info(project_name_or_id, robot_id, robot, **kwargs)  # noqa: E501
+            (data) = self.update_robot_v1_with_http_info(
+                project_name_or_id, robot_id, robot, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_robot_v1_with_http_info(self, project_name_or_id, robot_id, robot, **kwargs):  # noqa: E501
+    def update_robot_v1_with_http_info(
+        self, project_name_or_id, robot_id, robot, **kwargs
+    ):  # noqa: E501
         """Update status of robot account.  # noqa: E501
 
         Used to disable/enable a specified robot account.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_robot_v1_with_http_info(project_name_or_id, robot_id, robot, async_req=True)
         >>> result = thread.get()
@@ -557,86 +649,107 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'robot_id', 'robot', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "robot_id",
+            "robot",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_robot_v1" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_robot_v1" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_robot_v1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_robot_v1`"
+            )  # noqa: E501
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `update_robot_v1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `update_robot_v1`"
+            )  # noqa: E501
         # verify the required parameter 'robot' is set
-        if self.api_client.client_side_validation and ('robot' not in params or
-                                                       params['robot'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot` when calling `update_robot_v1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_robot_v1`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot" not in params or params["robot"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot` when calling `update_robot_v1`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_robot_v1`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot' in params:
-            body_params = params['robot']
+        if "robot" in params:
+            body_params = params["robot"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots/{robot_id}', 'PUT',
+            "/projects/{project_name_or_id}/robots/{robot_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/scan_all_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/scan_all_api.py`

 * *Files 11% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Schedule schedule: Create a schedule or a manual trigger for the scan all job. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_scan_all_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.create_scan_all_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def create_scan_all_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Create a schedule or a manual trigger for the scan all job.  # noqa: E501
@@ -69,79 +69,89 @@
         :param Schedule schedule: Create a schedule or a manual trigger for the scan all job. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_scan_all_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `create_scan_all_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_scan_all_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `create_scan_all_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_scan_all_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/scanAll/schedule', 'POST',
+            "/system/scanAll/schedule",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_latest_scan_all_metrics(self, **kwargs):  # noqa: E501
         """Get the metrics of the latest scan all process  # noqa: E501
 
         Get the metrics of the latest scan all process  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -150,16 +160,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Stats
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_latest_scan_all_metrics_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_latest_scan_all_metrics_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_latest_scan_all_metrics_with_http_info(self, **kwargs):  # noqa: E501
         """Get the metrics of the latest scan all process  # noqa: E501
@@ -173,73 +183,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Stats
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_latest_scan_all_metrics" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_latest_scan_all_metrics`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_latest_scan_all_metrics`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scans/all/metrics', 'GET',
+            "/scans/all/metrics",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Stats',  # noqa: E501
+            response_type="Stats",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_latest_scheduled_scan_all_metrics(self, **kwargs):  # noqa: E501
         """Get the metrics of the latest scheduled scan all process  # noqa: E501
 
         Get the metrics of the latest scheduled scan all process  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -248,19 +265,21 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Stats
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_latest_scheduled_scan_all_metrics_with_http_info(**kwargs)  # noqa: E501
         else:
-            (data) = self.get_latest_scheduled_scan_all_metrics_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_latest_scheduled_scan_all_metrics_with_http_info(
+                **kwargs
+            )  # noqa: E501
             return data
 
     def get_latest_scheduled_scan_all_metrics_with_http_info(self, **kwargs):  # noqa: E501
         """Get the metrics of the latest scheduled scan all process  # noqa: E501
 
         Get the metrics of the latest scheduled scan all process  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -271,73 +290,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Stats
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_latest_scheduled_scan_all_metrics" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_latest_scheduled_scan_all_metrics`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_latest_scheduled_scan_all_metrics`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scans/schedule/metrics', 'GET',
+            "/scans/schedule/metrics",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Stats',  # noqa: E501
+            response_type="Stats",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scan_all_schedule(self, **kwargs):  # noqa: E501
         """Get scan all's schedule.  # noqa: E501
 
         This endpoint is for getting a schedule for the scan all job, which scans all of images in Harbor.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -346,16 +372,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Schedule
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_scan_all_schedule_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_scan_all_schedule_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_scan_all_schedule_with_http_info(self, **kwargs):  # noqa: E501
         """Get scan all's schedule.  # noqa: E501
@@ -369,73 +395,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Schedule
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scan_all_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scan_all_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scan_all_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/scanAll/schedule', 'GET',
+            "/system/scanAll/schedule",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Schedule',  # noqa: E501
+            response_type="Schedule",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_scan_all(self, **kwargs):  # noqa: E501
         """Stop scanAll job execution  # noqa: E501
 
         Stop scanAll job execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -444,16 +477,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_scan_all_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.stop_scan_all_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def stop_scan_all_with_http_info(self, **kwargs):  # noqa: E501
         """Stop scanAll job execution  # noqa: E501
@@ -467,73 +500,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_scan_all" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_scan_all" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_scan_all`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_scan_all`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/scanAll/stop', 'POST',
+            "/system/scanAll/stop",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_scan_all_schedule(self, schedule, **kwargs):  # noqa: E501
         """Update scan all's schedule.  # noqa: E501
 
         This endpoint is for updating the schedule of scan all job, which scans all of images in Harbor.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -543,16 +582,16 @@
         :param async_req bool
         :param Schedule schedule: Updates the schedule of scan all job, which scans all of images in Harbor. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_scan_all_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.update_scan_all_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def update_scan_all_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Update scan all's schedule.  # noqa: E501
@@ -567,72 +606,82 @@
         :param Schedule schedule: Updates the schedule of scan all job, which scans all of images in Harbor. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_scan_all_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `update_scan_all_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_scan_all_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `update_scan_all_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_scan_all_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/scanAll/schedule', 'PUT',
+            "/system/scanAll/schedule",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/scan_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/scan_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -29,15 +29,17 @@
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def get_report_log(self, project_name, repository_name, reference, report_id, **kwargs):  # noqa: E501
+    def get_report_log(
+        self, project_name, repository_name, reference, report_id, **kwargs
+    ):  # noqa: E501
         """Get the log of the scan report  # noqa: E501
 
         Get the log of the scan report  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_report_log(project_name, repository_name, reference, report_id, async_req=True)
         >>> result = thread.get()
@@ -48,22 +50,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str report_id: The report id to get the log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_report_log_with_http_info(project_name, repository_name, reference, report_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_report_log_with_http_info(
+                project_name, repository_name, reference, report_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_report_log_with_http_info(project_name, repository_name, reference, report_id, **kwargs)  # noqa: E501
+            (data) = self.get_report_log_with_http_info(
+                project_name, repository_name, reference, report_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_report_log_with_http_info(self, project_name, repository_name, reference, report_id, **kwargs):  # noqa: E501
+    def get_report_log_with_http_info(
+        self, project_name, repository_name, reference, report_id, **kwargs
+    ):  # noqa: E501
         """Get the log of the scan report  # noqa: E501
 
         Get the log of the scan report  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_report_log_with_http_info(project_name, repository_name, reference, report_id, async_req=True)
         >>> result = thread.get()
@@ -75,97 +83,119 @@
         :param str report_id: The report id to get the log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'report_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "report_id",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_report_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_report_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_report_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_report_log`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_report_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_report_log`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `get_report_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `get_report_log`"
+            )  # noqa: E501
         # verify the required parameter 'report_id' is set
-        if self.api_client.client_side_validation and ('report_id' not in params or
-                                                       params['report_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `report_id` when calling `get_report_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_report_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "report_id" not in params or params["report_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `report_id` when calling `get_report_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_report_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
-        if 'report_id' in params:
-            path_params['report_id'] = params['report_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
+        if "report_id" in params:
+            path_params["report_id"] = params["report_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/{report_id}/log', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/{report_id}/log",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def scan_artifact(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """Scan the artifact  # noqa: E501
 
         Scan the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -177,22 +207,28 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.scan_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.scan_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.scan_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.scan_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def scan_artifact_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def scan_artifact_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Scan the artifact  # noqa: E501
 
         Scan the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.scan_artifact_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -203,91 +239,106 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "reference", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method scan_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method scan_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `scan_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `scan_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `scan_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `scan_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `scan_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `scan_artifact`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `scan_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `scan_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_scan_artifact(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """Cancelling a scan job for a particular artifact  # noqa: E501
 
         Cancelling a scan job for a particular artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -299,22 +350,28 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.stop_scan_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.stop_scan_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.stop_scan_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.stop_scan_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def stop_scan_artifact_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def stop_scan_artifact_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Cancelling a scan job for a particular artifact  # noqa: E501
 
         Cancelling a scan job for a particular artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.stop_scan_artifact_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -325,84 +382,99 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "reference", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_scan_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_scan_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `stop_scan_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `stop_scan_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `stop_scan_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `stop_scan_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `stop_scan_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_scan_artifact`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `stop_scan_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_scan_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/stop', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/stop",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/scan_data_export_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/scan_data_export_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -46,16 +46,16 @@
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :param str format: The format of the data to be exported. e.g. CSV or PDF
         :return: file
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.download_scan_data_with_http_info(execution_id, **kwargs)  # noqa: E501
         else:
             (data) = self.download_scan_data_with_http_info(execution_id, **kwargs)  # noqa: E501
             return data
 
     def download_scan_data_with_http_info(self, execution_id, **kwargs):  # noqa: E501
         """Download the scan data export file  # noqa: E501
@@ -71,81 +71,88 @@
         :param str x_request_id: An unique ID for the request
         :param str format: The format of the data to be exported. e.g. CSV or PDF
         :return: file
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['execution_id', 'x_request_id', 'format']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["execution_id", "x_request_id", "format"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method download_scan_data" % key
+                    "Got an unexpected keyword argument '%s'" " to method download_scan_data" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `download_scan_data`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `download_scan_data`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `download_scan_data`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `download_scan_data`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
-        if 'format' in params:
-            query_params.append(('format', params['format']))  # noqa: E501
+        if "format" in params:
+            query_params.append(("format", params["format"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/csv'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/csv"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/export/cve/download/{execution_id}', 'GET',
+            "/export/cve/download/{execution_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='file',  # noqa: E501
+            response_type="file",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def export_scan_data(self, x_scan_data_type, criteria, **kwargs):  # noqa: E501
         """Export scan data for selected projects  # noqa: E501
 
         Export scan data for selected projects  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -156,19 +163,23 @@
         :param str x_scan_data_type: The type of scan data to export (required)
         :param ScanDataExportRequest criteria: The criteria for the export (required)
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportJob
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.export_scan_data_with_http_info(x_scan_data_type, criteria, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.export_scan_data_with_http_info(
+                x_scan_data_type, criteria, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.export_scan_data_with_http_info(x_scan_data_type, criteria, **kwargs)  # noqa: E501
+            (data) = self.export_scan_data_with_http_info(
+                x_scan_data_type, criteria, **kwargs
+            )  # noqa: E501
             return data
 
     def export_scan_data_with_http_info(self, x_scan_data_type, criteria, **kwargs):  # noqa: E501
         """Export scan data for selected projects  # noqa: E501
 
         Export scan data for selected projects  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -181,85 +192,97 @@
         :param ScanDataExportRequest criteria: The criteria for the export (required)
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportJob
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_scan_data_type', 'criteria', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_scan_data_type", "criteria", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method export_scan_data" % key
+                    "Got an unexpected keyword argument '%s'" " to method export_scan_data" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'x_scan_data_type' is set
-        if self.api_client.client_side_validation and ('x_scan_data_type' not in params or
-                                                       params['x_scan_data_type'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `x_scan_data_type` when calling `export_scan_data`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_scan_data_type" not in params or params["x_scan_data_type"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `x_scan_data_type` when calling `export_scan_data`"
+            )  # noqa: E501
         # verify the required parameter 'criteria' is set
-        if self.api_client.client_side_validation and ('criteria' not in params or
-                                                       params['criteria'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `criteria` when calling `export_scan_data`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `export_scan_data`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "criteria" not in params or params["criteria"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `criteria` when calling `export_scan_data`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `export_scan_data`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_scan_data_type' in params:
-            header_params['X-Scan-Data-Type'] = params['x_scan_data_type']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_scan_data_type" in params:
+            header_params["X-Scan-Data-Type"] = params["x_scan_data_type"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'criteria' in params:
-            body_params = params['criteria']
+        if "criteria" in params:
+            body_params = params["criteria"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/export/cve', 'POST',
+            "/export/cve",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScanDataExportJob',  # noqa: E501
+            response_type="ScanDataExportJob",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scan_data_export_execution(self, execution_id, **kwargs):  # noqa: E501
         """Get the specific scan data export execution  # noqa: E501
 
         Get the scan data export execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -269,19 +292,23 @@
         :param async_req bool
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportExecution
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_scan_data_export_execution_with_http_info(execution_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_scan_data_export_execution_with_http_info(
+                execution_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_scan_data_export_execution_with_http_info(execution_id, **kwargs)  # noqa: E501
+            (data) = self.get_scan_data_export_execution_with_http_info(
+                execution_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_scan_data_export_execution_with_http_info(self, execution_id, **kwargs):  # noqa: E501
         """Get the specific scan data export execution  # noqa: E501
 
         Get the scan data export execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -293,79 +320,89 @@
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportExecution
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['execution_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["execution_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scan_data_export_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `get_scan_data_export_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scan_data_export_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `get_scan_data_export_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scan_data_export_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/export/cve/execution/{execution_id}', 'GET',
+            "/export/cve/execution/{execution_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScanDataExportExecution',  # noqa: E501
+            response_type="ScanDataExportExecution",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scan_data_export_execution_list(self, **kwargs):  # noqa: E501
         """Get a list of specific scan data export execution jobs for a specified user  # noqa: E501
 
         Get a list of specific scan data export execution jobs for a specified user  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -374,16 +411,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportExecutionList
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_scan_data_export_execution_list_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_scan_data_export_execution_list_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_scan_data_export_execution_list_with_http_info(self, **kwargs):  # noqa: E501
         """Get a list of specific scan data export execution jobs for a specified user  # noqa: E501
@@ -397,66 +434,73 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportExecutionList
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scan_data_export_execution_list" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scan_data_export_execution_list`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scan_data_export_execution_list`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/export/cve/executions', 'GET',
+            "/export/cve/executions",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScanDataExportExecutionList',  # noqa: E501
+            response_type="ScanDataExportExecutionList",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/scanner_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/scanner_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param ScannerRegistrationReq registration: A scanner registration to be created. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_scanner_with_http_info(registration, **kwargs)  # noqa: E501
         else:
             (data) = self.create_scanner_with_http_info(registration, **kwargs)  # noqa: E501
             return data
 
     def create_scanner_with_http_info(self, registration, **kwargs):  # noqa: E501
         """Create a scanner registration  # noqa: E501
@@ -69,79 +69,88 @@
         :param ScannerRegistrationReq registration: A scanner registration to be created. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration' is set
-        if self.api_client.client_side_validation and ('registration' not in params or
-                                                       params['registration'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration` when calling `create_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration" not in params or params["registration"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration` when calling `create_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registration' in params:
-            body_params = params['registration']
+        if "registration" in params:
+            body_params = params["registration"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners', 'POST',
+            "/scanners",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_scanner(self, registration_id, **kwargs):  # noqa: E501
         """Delete a scanner registration  # noqa: E501
 
         Deletes the specified scanner registration.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param str registration_id: The scanner registration identifier. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_scanner_with_http_info(registration_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_scanner_with_http_info(registration_id, **kwargs)  # noqa: E501
             return data
 
     def delete_scanner_with_http_info(self, registration_id, **kwargs):  # noqa: E501
         """Delete a scanner registration  # noqa: E501
@@ -175,79 +184,88 @@
         :param str registration_id: The scanner registration identifier. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `delete_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `delete_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}', 'DELETE',
+            "/scanners/{registration_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScannerRegistration',  # noqa: E501
+            response_type="ScannerRegistration",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scanner(self, registration_id, **kwargs):  # noqa: E501
         """Get a scanner registration details  # noqa: E501
 
         Retruns the details of the specified scanner registration.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +275,16 @@
         :param async_req bool
         :param str registration_id: The scanner registration identifer. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_scanner_with_http_info(registration_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_scanner_with_http_info(registration_id, **kwargs)  # noqa: E501
             return data
 
     def get_scanner_with_http_info(self, registration_id, **kwargs):  # noqa: E501
         """Get a scanner registration details  # noqa: E501
@@ -281,79 +299,88 @@
         :param str registration_id: The scanner registration identifer. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `get_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `get_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}', 'GET',
+            "/scanners/{registration_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScannerRegistration',  # noqa: E501
+            response_type="ScannerRegistration",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scanner_metadata(self, registration_id, **kwargs):  # noqa: E501
         """Get the metadata of the specified scanner registration  # noqa: E501
 
         Get the metadata of the specified scanner registration, including the capabilities and customized properties.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -363,19 +390,21 @@
         :param async_req bool
         :param str registration_id: The scanner registration identifier. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerAdapterMetadata
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_scanner_metadata_with_http_info(registration_id, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_scanner_metadata_with_http_info(registration_id, **kwargs)  # noqa: E501
+            (data) = self.get_scanner_metadata_with_http_info(
+                registration_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_scanner_metadata_with_http_info(self, registration_id, **kwargs):  # noqa: E501
         """Get the metadata of the specified scanner registration  # noqa: E501
 
         Get the metadata of the specified scanner registration, including the capabilities and customized properties.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -387,79 +416,89 @@
         :param str registration_id: The scanner registration identifier. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerAdapterMetadata
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scanner_metadata" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `get_scanner_metadata`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scanner_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `get_scanner_metadata`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scanner_metadata`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}/metadata', 'GET',
+            "/scanners/{registration_id}/metadata",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScannerAdapterMetadata',  # noqa: E501
+            response_type="ScannerAdapterMetadata",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_scanners(self, **kwargs):  # noqa: E501
         """List scanner registrations  # noqa: E501
 
         Returns a list of currently configured scanner registrations.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -472,16 +511,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScannerRegistration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_scanners_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_scanners_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_scanners_with_http_info(self, **kwargs):  # noqa: E501
         """List scanner registrations  # noqa: E501
@@ -499,83 +538,93 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScannerRegistration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_scanners" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_scanners" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_scanners`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_scanners`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_scanners`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_scanners`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners', 'GET',
+            "/scanners",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ScannerRegistration]',  # noqa: E501
+            response_type="list[ScannerRegistration]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def ping_scanner(self, settings, **kwargs):  # noqa: E501
         """Tests scanner registration settings  # noqa: E501
 
         Pings scanner adapter to test endpoint URL and authorization settings.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -585,16 +634,16 @@
         :param async_req bool
         :param ScannerRegistrationSettings settings: A scanner registration settings to be tested. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_scanner_with_http_info(settings, **kwargs)  # noqa: E501
         else:
             (data) = self.ping_scanner_with_http_info(settings, **kwargs)  # noqa: E501
             return data
 
     def ping_scanner_with_http_info(self, settings, **kwargs):  # noqa: E501
         """Tests scanner registration settings  # noqa: E501
@@ -609,79 +658,88 @@
         :param ScannerRegistrationSettings settings: A scanner registration settings to be tested. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['settings', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["settings", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'settings' is set
-        if self.api_client.client_side_validation and ('settings' not in params or
-                                                       params['settings'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `settings` when calling `ping_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "settings" not in params or params["settings"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `settings` when calling `ping_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'settings' in params:
-            body_params = params['settings']
+        if "settings" in params:
+            body_params = params["settings"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/ping', 'POST',
+            "/scanners/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def set_scanner_as_default(self, registration_id, payload, **kwargs):  # noqa: E501
         """Set system default scanner registration  # noqa: E501
 
         Set the specified scanner registration as the system default one.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -692,22 +750,28 @@
         :param str registration_id: The scanner registration identifier. (required)
         :param IsDefault payload: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.set_scanner_as_default_with_http_info(registration_id, payload, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.set_scanner_as_default_with_http_info(
+                registration_id, payload, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.set_scanner_as_default_with_http_info(registration_id, payload, **kwargs)  # noqa: E501
+            (data) = self.set_scanner_as_default_with_http_info(
+                registration_id, payload, **kwargs
+            )  # noqa: E501
             return data
 
-    def set_scanner_as_default_with_http_info(self, registration_id, payload, **kwargs):  # noqa: E501
+    def set_scanner_as_default_with_http_info(
+        self, registration_id, payload, **kwargs
+    ):  # noqa: E501
         """Set system default scanner registration  # noqa: E501
 
         Set the specified scanner registration as the system default one.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.set_scanner_as_default_with_http_info(registration_id, payload, async_req=True)
         >>> result = thread.get()
@@ -717,85 +781,98 @@
         :param IsDefault payload: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'payload', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "payload", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method set_scanner_as_default" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `set_scanner_as_default`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `set_scanner_as_default`"
+            )  # noqa: E501
         # verify the required parameter 'payload' is set
-        if self.api_client.client_side_validation and ('payload' not in params or
-                                                       params['payload'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `payload` when calling `set_scanner_as_default`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `set_scanner_as_default`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "payload" not in params or params["payload"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `payload` when calling `set_scanner_as_default`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `set_scanner_as_default`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'payload' in params:
-            body_params = params['payload']
+        if "payload" in params:
+            body_params = params["payload"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}', 'PATCH',
+            "/scanners/{registration_id}",
+            "PATCH",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_scanner(self, registration_id, registration, **kwargs):  # noqa: E501
         """Update a scanner registration  # noqa: E501
 
         Updates the specified scanner registration.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -806,19 +883,23 @@
         :param str registration_id: The scanner registration identifier. (required)
         :param ScannerRegistrationReq registration: A scanner registraiton to be updated. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_scanner_with_http_info(registration_id, registration, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_scanner_with_http_info(
+                registration_id, registration, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_scanner_with_http_info(registration_id, registration, **kwargs)  # noqa: E501
+            (data) = self.update_scanner_with_http_info(
+                registration_id, registration, **kwargs
+            )  # noqa: E501
             return data
 
     def update_scanner_with_http_info(self, registration_id, registration, **kwargs):  # noqa: E501
         """Update a scanner registration  # noqa: E501
 
         Updates the specified scanner registration.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -831,78 +912,90 @@
         :param ScannerRegistrationReq registration: A scanner registraiton to be updated. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'registration', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "registration", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `update_scanner`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `update_scanner`"
+            )  # noqa: E501
         # verify the required parameter 'registration' is set
-        if self.api_client.client_side_validation and ('registration' not in params or
-                                                       params['registration'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration` when calling `update_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration" not in params or params["registration"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration` when calling `update_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registration' in params:
-            body_params = params['registration']
+        if "registration" in params:
+            body_params = params["registration"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}', 'PUT',
+            "/scanners/{registration_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/schedule_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/schedule_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param str job_type: The type of the job. 'all' stands for all job types, current only support query with all (required)
         :param str x_request_id: An unique ID for the request
         :return: SchedulerStatus
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_schedule_paused_with_http_info(job_type, **kwargs)  # noqa: E501
         else:
             (data) = self.get_schedule_paused_with_http_info(job_type, **kwargs)  # noqa: E501
             return data
 
     def get_schedule_paused_with_http_info(self, job_type, **kwargs):  # noqa: E501
         """get_schedule_paused  # noqa: E501
@@ -69,79 +69,88 @@
         :param str job_type: The type of the job. 'all' stands for all job types, current only support query with all (required)
         :param str x_request_id: An unique ID for the request
         :return: SchedulerStatus
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['job_type', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["job_type", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_schedule_paused" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_schedule_paused" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'job_type' is set
-        if self.api_client.client_side_validation and ('job_type' not in params or
-                                                       params['job_type'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `job_type` when calling `get_schedule_paused`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_schedule_paused`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "job_type" not in params or params["job_type"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `job_type` when calling `get_schedule_paused`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_schedule_paused`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'job_type' in params:
-            path_params['job_type'] = params['job_type']  # noqa: E501
+        if "job_type" in params:
+            path_params["job_type"] = params["job_type"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/schedules/{job_type}/paused', 'GET',
+            "/schedules/{job_type}/paused",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SchedulerStatus',  # noqa: E501
+            response_type="SchedulerStatus",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_schedules(self, **kwargs):  # noqa: E501
         """list_schedules  # noqa: E501
 
         List schedules  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -152,16 +161,16 @@
         :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScheduleTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_schedules_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_schedules_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_schedules_with_http_info(self, **kwargs):  # noqa: E501
         """list_schedules  # noqa: E501
@@ -177,72 +186,82 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScheduleTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_schedules" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_schedules" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_schedules`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_schedules`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_schedules`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_schedules`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/schedules', 'GET',
+            "/schedules",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ScheduleTask]',  # noqa: E501
+            response_type="list[ScheduleTask]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/search_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/search_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param str q: Search parameter for project and repository name. (required)
         :param str x_request_id: An unique ID for the request
         :return: Search
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.search_with_http_info(q, **kwargs)  # noqa: E501
         else:
             (data) = self.search_with_http_info(q, **kwargs)  # noqa: E501
             return data
 
     def search_with_http_info(self, q, **kwargs):  # noqa: E501
         """Search for projects, repositories and helm charts  # noqa: E501
@@ -69,72 +69,79 @@
         :param str q: Search parameter for project and repository name. (required)
         :param str x_request_id: An unique ID for the request
         :return: Search
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['q', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["q", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
-                )
+                raise TypeError("Got an unexpected keyword argument '%s'" " to method search" % key)
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'q' is set
-        if self.api_client.client_side_validation and ('q' not in params or
-                                                       params['q'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `q` when calling `search`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "q" not in params or params["q"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `q` when calling `search`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/search', 'GET',
+            "/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Search',  # noqa: E501
+            response_type="Search",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/statistic_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/statistic_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Statistic
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_statistic_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_statistic_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_statistic_with_http_info(self, **kwargs):  # noqa: E501
         """Get the statistic information about the projects and repositories  # noqa: E501
@@ -67,66 +67,72 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Statistic
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_statistic" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_statistic" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_statistic`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_statistic`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/statistics', 'GET',
+            "/statistics",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Statistic',  # noqa: E501
+            response_type="Statistic",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/system_cve_allowlist_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/system_cve_allowlist_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: CVEAllowlist
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_system_cve_allowlist_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_system_cve_allowlist_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_system_cve_allowlist_with_http_info(self, **kwargs):  # noqa: E501
         """Get the system level allowlist of CVE.  # noqa: E501
@@ -67,73 +67,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: CVEAllowlist
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_system_cve_allowlist" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_system_cve_allowlist`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_system_cve_allowlist`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/CVEAllowlist', 'GET',
+            "/system/CVEAllowlist",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CVEAllowlist',  # noqa: E501
+            response_type="CVEAllowlist",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def put_system_cve_allowlist(self, **kwargs):  # noqa: E501
         """Update the system level allowlist of CVE.  # noqa: E501
 
         This API overwrites the system level allowlist of CVE with the list in request body.  Only system Admin has permission to call this API.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -143,16 +150,16 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param CVEAllowlist allowlist: The allowlist with new content
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.put_system_cve_allowlist_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.put_system_cve_allowlist_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def put_system_cve_allowlist_with_http_info(self, **kwargs):  # noqa: E501
         """Update the system level allowlist of CVE.  # noqa: E501
@@ -167,68 +174,75 @@
         :param str x_request_id: An unique ID for the request
         :param CVEAllowlist allowlist: The allowlist with new content
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'allowlist']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "allowlist"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method put_system_cve_allowlist" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `put_system_cve_allowlist`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `put_system_cve_allowlist`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'allowlist' in params:
-            body_params = params['allowlist']
+        if "allowlist" in params:
+            body_params = params["allowlist"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/CVEAllowlist', 'PUT',
+            "/system/CVEAllowlist",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/systeminfo_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/systeminfo_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: file
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_cert_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_cert_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_cert_with_http_info(self, **kwargs):  # noqa: E501
         """Get default root certificate.  # noqa: E501
@@ -67,73 +67,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: file
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_cert" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_cert" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_cert`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_cert`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/octet-stream'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/octet-stream"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/systeminfo/getcert', 'GET',
+            "/systeminfo/getcert",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='file',  # noqa: E501
+            response_type="file",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_system_info(self, **kwargs):  # noqa: E501
         """Get general system info  # noqa: E501
 
         This API is for retrieving general system info, this can be called by anonymous request.  Some attributes will be omitted in the response when this API is called by anonymous request.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -142,16 +148,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: GeneralInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_system_info_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_system_info_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_system_info_with_http_info(self, **kwargs):  # noqa: E501
         """Get general system info  # noqa: E501
@@ -165,73 +171,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: GeneralInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_system_info" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_system_info" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_system_info`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_system_info`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/systeminfo', 'GET',
+            "/systeminfo",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GeneralInfo',  # noqa: E501
+            response_type="GeneralInfo",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_volumes(self, **kwargs):  # noqa: E501
         """Get system volume info (total/free size).  # noqa: E501
 
         This endpoint is for retrieving system volume info that only provides for admin user.  Note that the response only reflects the storage status of local disk.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -240,16 +252,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: SystemInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_volumes_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_volumes_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_volumes_with_http_info(self, **kwargs):  # noqa: E501
         """Get system volume info (total/free size).  # noqa: E501
@@ -263,66 +275,72 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: SystemInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_volumes" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_volumes" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_volumes`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_volumes`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/systeminfo/volumes', 'GET',
+            "/systeminfo/volumes",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SystemInfo',  # noqa: E501
+            response_type="SystemInfo",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/user_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/user_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param UserCreationReq user_req: The new user (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_user_with_http_info(user_req, **kwargs)  # noqa: E501
         else:
             (data) = self.create_user_with_http_info(user_req, **kwargs)  # noqa: E501
             return data
 
     def create_user_with_http_info(self, user_req, **kwargs):  # noqa: E501
         """Create a local user.  # noqa: E501
@@ -69,79 +69,88 @@
         :param UserCreationReq user_req: The new user (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_req', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_req", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_user" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_user" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'user_req' is set
-        if self.api_client.client_side_validation and ('user_req' not in params or
-                                                       params['user_req'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_req` when calling `create_user`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_user`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "user_req" not in params or params["user_req"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_req` when calling `create_user`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'user_req' in params:
-            body_params = params['user_req']
+        if "user_req" in params:
+            body_params = params["user_req"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users', 'POST',
+            "/users",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_user(self, user_id, **kwargs):  # noqa: E501
         """Mark a registered user as be removed.  # noqa: E501
 
         This endpoint let administrator of Harbor mark a registered user as removed.It actually won't be deleted from DB.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int user_id: User ID for marking as to be removed. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_user_with_http_info(user_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_user_with_http_info(user_id, **kwargs)  # noqa: E501
             return data
 
     def delete_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
         """Mark a registered user as be removed.  # noqa: E501
@@ -175,79 +184,88 @@
         :param int user_id: User ID for marking as to be removed. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_user" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_user" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `delete_user`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_user`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `delete_user`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}', 'DELETE',
+            "/users/{user_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_current_user_info(self, **kwargs):  # noqa: E501
         """Get current user info.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_current_user_info(async_req=True)
@@ -255,16 +273,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: UserResp
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_current_user_info_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_current_user_info_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_current_user_info_with_http_info(self, **kwargs):  # noqa: E501
         """Get current user info.  # noqa: E501
@@ -277,92 +295,99 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: UserResp
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_current_user_info" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_current_user_info`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_current_user_info`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/current', 'GET',
+            "/users/current",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserResp',  # noqa: E501
+            response_type="UserResp",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_current_user_permissions(self, **kwargs):  # noqa: E501
         """Get current user permissions.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_current_user_permissions(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param str scope: The scope for the permission
-        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'. 
+        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'.
         :return: list[Permission]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_current_user_permissions_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_current_user_permissions_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_current_user_permissions_with_http_info(self, **kwargs):  # noqa: E501
         """Get current user permissions.  # noqa: E501
@@ -371,83 +396,90 @@
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_current_user_permissions_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param str scope: The scope for the permission
-        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'. 
+        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'.
         :return: list[Permission]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'scope', 'relative']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "scope", "relative"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_current_user_permissions" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_current_user_permissions`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_current_user_permissions`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'scope' in params:
-            query_params.append(('scope', params['scope']))  # noqa: E501
-        if 'relative' in params:
-            query_params.append(('relative', params['relative']))  # noqa: E501
+        if "scope" in params:
+            query_params.append(("scope", params["scope"]))  # noqa: E501
+        if "relative" in params:
+            query_params.append(("relative", params["relative"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/current/permissions', 'GET',
+            "/users/current/permissions",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Permission]',  # noqa: E501
+            response_type="list[Permission]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_user(self, user_id, **kwargs):  # noqa: E501
         """Get a user's profile.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_user(user_id, async_req=True)
@@ -456,16 +488,16 @@
         :param async_req bool
         :param int user_id: (required)
         :param str x_request_id: An unique ID for the request
         :return: UserResp
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
             return data
 
     def get_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
         """Get a user's profile.  # noqa: E501
@@ -479,79 +511,88 @@
         :param int user_id: (required)
         :param str x_request_id: An unique ID for the request
         :return: UserResp
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_user" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_user" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `get_user`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_user`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `get_user`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}', 'GET',
+            "/users/{user_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserResp',  # noqa: E501
+            response_type="UserResp",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_users(self, **kwargs):  # noqa: E501
         """List users  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_users(async_req=True)
@@ -563,16 +604,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[UserResp]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_users_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_users_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_users_with_http_info(self, **kwargs):  # noqa: E501
         """List users  # noqa: E501
@@ -589,83 +630,93 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[UserResp]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_users" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_users" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_users`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_users`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_users`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_users`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users', 'GET',
+            "/users",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[UserResp]',  # noqa: E501
+            response_type="list[UserResp]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def search_users(self, username, **kwargs):  # noqa: E501
         """Search users by username  # noqa: E501
 
         This endpoint is to search the users by username.  It's open for all authenticated requests.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -677,16 +728,16 @@
         :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[UserSearchRespItem]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.search_users_with_http_info(username, **kwargs)  # noqa: E501
         else:
             (data) = self.search_users_with_http_info(username, **kwargs)  # noqa: E501
             return data
 
     def search_users_with_http_info(self, username, **kwargs):  # noqa: E501
         """Search users by username  # noqa: E501
@@ -703,85 +754,98 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[UserSearchRespItem]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['username', 'x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["username", "x_request_id", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search_users" % key
+                    "Got an unexpected keyword argument '%s'" " to method search_users" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'username' is set
-        if self.api_client.client_side_validation and ('username' not in params or
-                                                       params['username'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `username` when calling `search_users`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search_users`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `search_users`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "username" not in params or params["username"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `username` when calling `search_users`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search_users`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `search_users`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'username' in params:
-            query_params.append(('username', params['username']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "username" in params:
+            query_params.append(("username", params["username"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/search', 'GET',
+            "/users/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[UserSearchRespItem]',  # noqa: E501
+            response_type="list[UserSearchRespItem]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def set_cli_secret(self, user_id, secret, **kwargs):  # noqa: E501
         """Set CLI secret for a user.  # noqa: E501
 
         This endpoint let user generate a new CLI secret for himself.  This API only works when auth mode is set to 'OIDC'. Once this API returns with successful status, the old secret will be invalid, as there will be only one CLI secret for a user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -792,16 +856,16 @@
         :param int user_id: User ID (required)
         :param OIDCCliSecretReq secret: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.set_cli_secret_with_http_info(user_id, secret, **kwargs)  # noqa: E501
         else:
             (data) = self.set_cli_secret_with_http_info(user_id, secret, **kwargs)  # noqa: E501
             return data
 
     def set_cli_secret_with_http_info(self, user_id, secret, **kwargs):  # noqa: E501
         """Set CLI secret for a user.  # noqa: E501
@@ -817,85 +881,97 @@
         :param OIDCCliSecretReq secret: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'secret', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "secret", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method set_cli_secret" % key
+                    "Got an unexpected keyword argument '%s'" " to method set_cli_secret" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `set_cli_secret`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `set_cli_secret`"
+            )  # noqa: E501
         # verify the required parameter 'secret' is set
-        if self.api_client.client_side_validation and ('secret' not in params or
-                                                       params['secret'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `secret` when calling `set_cli_secret`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `set_cli_secret`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "secret" not in params or params["secret"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `secret` when calling `set_cli_secret`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `set_cli_secret`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'secret' in params:
-            body_params = params['secret']
+        if "secret" in params:
+            body_params = params["secret"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}/cli_secret', 'PUT',
+            "/users/{user_id}/cli_secret",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def set_user_sys_admin(self, user_id, sysadmin_flag, **kwargs):  # noqa: E501
         """Update a registered user to change to be an administrator of Harbor.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.set_user_sys_admin(user_id, sysadmin_flag, async_req=True)
@@ -905,19 +981,23 @@
         :param int user_id: (required)
         :param UserSysAdminFlag sysadmin_flag: Toggle a user to admin or not. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.set_user_sys_admin_with_http_info(user_id, sysadmin_flag, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.set_user_sys_admin_with_http_info(
+                user_id, sysadmin_flag, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.set_user_sys_admin_with_http_info(user_id, sysadmin_flag, **kwargs)  # noqa: E501
+            (data) = self.set_user_sys_admin_with_http_info(
+                user_id, sysadmin_flag, **kwargs
+            )  # noqa: E501
             return data
 
     def set_user_sys_admin_with_http_info(self, user_id, sysadmin_flag, **kwargs):  # noqa: E501
         """Update a registered user to change to be an administrator of Harbor.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -929,85 +1009,97 @@
         :param UserSysAdminFlag sysadmin_flag: Toggle a user to admin or not. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'sysadmin_flag', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "sysadmin_flag", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method set_user_sys_admin" % key
+                    "Got an unexpected keyword argument '%s'" " to method set_user_sys_admin" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `set_user_sys_admin`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `set_user_sys_admin`"
+            )  # noqa: E501
         # verify the required parameter 'sysadmin_flag' is set
-        if self.api_client.client_side_validation and ('sysadmin_flag' not in params or
-                                                       params['sysadmin_flag'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `sysadmin_flag` when calling `set_user_sys_admin`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `set_user_sys_admin`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "sysadmin_flag" not in params or params["sysadmin_flag"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `sysadmin_flag` when calling `set_user_sys_admin`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `set_user_sys_admin`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'sysadmin_flag' in params:
-            body_params = params['sysadmin_flag']
+        if "sysadmin_flag" in params:
+            body_params = params["sysadmin_flag"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}/sysadmin', 'PUT',
+            "/users/{user_id}/sysadmin",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_user_password(self, user_id, password, **kwargs):  # noqa: E501
         """Change the password on a user that already exists.  # noqa: E501
 
         This endpoint is for user to update password. Users with the admin role can change any user's password. Regular users can change only their own password.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1018,19 +1110,23 @@
         :param int user_id: (required)
         :param PasswordReq password: Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_user_password_with_http_info(user_id, password, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_user_password_with_http_info(
+                user_id, password, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_user_password_with_http_info(user_id, password, **kwargs)  # noqa: E501
+            (data) = self.update_user_password_with_http_info(
+                user_id, password, **kwargs
+            )  # noqa: E501
             return data
 
     def update_user_password_with_http_info(self, user_id, password, **kwargs):  # noqa: E501
         """Change the password on a user that already exists.  # noqa: E501
 
         This endpoint is for user to update password. Users with the admin role can change any user's password. Regular users can change only their own password.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -1043,85 +1139,98 @@
         :param PasswordReq password: Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'password', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "password", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_user_password" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `update_user_password`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `update_user_password`"
+            )  # noqa: E501
         # verify the required parameter 'password' is set
-        if self.api_client.client_side_validation and ('password' not in params or
-                                                       params['password'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `password` when calling `update_user_password`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_user_password`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "password" not in params or params["password"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `password` when calling `update_user_password`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_user_password`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'password' in params:
-            body_params = params['password']
+        if "password" in params:
+            body_params = params["password"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}/password', 'PUT',
+            "/users/{user_id}/password",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_user_profile(self, user_id, profile, **kwargs):  # noqa: E501
         """Update user's profile.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_user_profile(user_id, profile, async_req=True)
@@ -1131,19 +1240,21 @@
         :param int user_id: Registered user ID (required)
         :param UserProfile profile: Only email, realname and comment can be modified. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_user_profile_with_http_info(user_id, profile, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_user_profile_with_http_info(user_id, profile, **kwargs)  # noqa: E501
+            (data) = self.update_user_profile_with_http_info(
+                user_id, profile, **kwargs
+            )  # noqa: E501
             return data
 
     def update_user_profile_with_http_info(self, user_id, profile, **kwargs):  # noqa: E501
         """Update user's profile.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1155,78 +1266,90 @@
         :param UserProfile profile: Only email, realname and comment can be modified. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'profile', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["user_id", "profile", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_user_profile" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_user_profile" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `update_user_profile`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "user_id" not in params or params["user_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `user_id` when calling `update_user_profile`"
+            )  # noqa: E501
         # verify the required parameter 'profile' is set
-        if self.api_client.client_side_validation and ('profile' not in params or
-                                                       params['profile'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `profile` when calling `update_user_profile`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_user_profile`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "profile" not in params or params["profile"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `profile` when calling `update_user_profile`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_user_profile`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "user_id" in params:
+            path_params["user_id"] = params["user_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'profile' in params:
-            body_params = params['profile']
+        if "profile" in params:
+            body_params = params["profile"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}', 'PUT',
+            "/users/{user_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/usergroup_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/usergroup_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param UserGroup usergroup:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_user_group_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.create_user_group_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def create_user_group_with_http_info(self, **kwargs):  # noqa: E501
         """Create user group  # noqa: E501
@@ -69,75 +69,81 @@
         :param str x_request_id: An unique ID for the request
         :param UserGroup usergroup:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'usergroup']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "usergroup"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_user_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_user_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_user_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_user_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'usergroup' in params:
-            body_params = params['usergroup']
+        if "usergroup" in params:
+            body_params = params["usergroup"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups', 'POST',
+            "/usergroups",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_user_group(self, group_id, **kwargs):  # noqa: E501
         """Delete user group  # noqa: E501
 
         Delete user group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -147,16 +153,16 @@
         :param async_req bool
         :param int group_id: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
             return data
 
     def delete_user_group_with_http_info(self, group_id, **kwargs):  # noqa: E501
         """Delete user group  # noqa: E501
@@ -171,79 +177,88 @@
         :param int group_id: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['group_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["group_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_user_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_user_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'group_id' is set
-        if self.api_client.client_side_validation and ('group_id' not in params or
-                                                       params['group_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `group_id` when calling `delete_user_group`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_user_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "group_id" not in params or params["group_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `group_id` when calling `delete_user_group`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_user_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'group_id' in params:
-            path_params['group_id'] = params['group_id']  # noqa: E501
+        if "group_id" in params:
+            path_params["group_id"] = params["group_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups/{group_id}', 'DELETE',
+            "/usergroups/{group_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_user_group(self, group_id, **kwargs):  # noqa: E501
         """Get user group information  # noqa: E501
 
         Get user group information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -253,16 +268,16 @@
         :param async_req bool
         :param int group_id: Group ID (required)
         :param str x_request_id: An unique ID for the request
         :return: UserGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
             return data
 
     def get_user_group_with_http_info(self, group_id, **kwargs):  # noqa: E501
         """Get user group information  # noqa: E501
@@ -277,79 +292,88 @@
         :param int group_id: Group ID (required)
         :param str x_request_id: An unique ID for the request
         :return: UserGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['group_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["group_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_user_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_user_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'group_id' is set
-        if self.api_client.client_side_validation and ('group_id' not in params or
-                                                       params['group_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `group_id` when calling `get_user_group`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_user_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "group_id" not in params or params["group_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `group_id` when calling `get_user_group`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_user_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'group_id' in params:
-            path_params['group_id'] = params['group_id']  # noqa: E501
+        if "group_id" in params:
+            path_params["group_id"] = params["group_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups/{group_id}', 'GET',
+            "/usergroups/{group_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserGroup',  # noqa: E501
+            response_type="UserGroup",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_user_groups(self, **kwargs):  # noqa: E501
         """Get all user groups information  # noqa: E501
 
         Get all user groups information, it is open for system admin  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -362,16 +386,16 @@
         :param int page_size: The size of per page
         :param str ldap_group_dn: search with ldap group DN
         :param str group_name: group name need to search, fuzzy matches
         :return: list[UserGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_user_groups_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_user_groups_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_user_groups_with_http_info(self, **kwargs):  # noqa: E501
         """Get all user groups information  # noqa: E501
@@ -389,83 +413,99 @@
         :param str ldap_group_dn: search with ldap group DN
         :param str group_name: group name need to search, fuzzy matches
         :return: list[UserGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'page', 'page_size', 'ldap_group_dn', 'group_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "page",
+            "page_size",
+            "ldap_group_dn",
+            "group_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_user_groups" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_user_groups" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_user_groups`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_user_groups`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_user_groups`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_user_groups`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'ldap_group_dn' in params:
-            query_params.append(('ldap_group_dn', params['ldap_group_dn']))  # noqa: E501
-        if 'group_name' in params:
-            query_params.append(('group_name', params['group_name']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "ldap_group_dn" in params:
+            query_params.append(("ldap_group_dn", params["ldap_group_dn"]))  # noqa: E501
+        if "group_name" in params:
+            query_params.append(("group_name", params["group_name"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups', 'GET',
+            "/usergroups",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[UserGroup]',  # noqa: E501
+            response_type="list[UserGroup]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def search_user_groups(self, groupname, **kwargs):  # noqa: E501
         """Search groups by groupname  # noqa: E501
 
         This endpoint is to search groups by group name.  It's open for all authenticated requests.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -477,16 +517,16 @@
         :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[UserGroupSearchItem]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.search_user_groups_with_http_info(groupname, **kwargs)  # noqa: E501
         else:
             (data) = self.search_user_groups_with_http_info(groupname, **kwargs)  # noqa: E501
             return data
 
     def search_user_groups_with_http_info(self, groupname, **kwargs):  # noqa: E501
         """Search groups by groupname  # noqa: E501
@@ -503,85 +543,98 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[UserGroupSearchItem]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['groupname', 'x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["groupname", "x_request_id", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search_user_groups" % key
+                    "Got an unexpected keyword argument '%s'" " to method search_user_groups" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'groupname' is set
-        if self.api_client.client_side_validation and ('groupname' not in params or
-                                                       params['groupname'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `groupname` when calling `search_user_groups`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search_user_groups`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `search_user_groups`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "groupname" not in params or params["groupname"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `groupname` when calling `search_user_groups`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search_user_groups`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `search_user_groups`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'groupname' in params:
-            query_params.append(('groupname', params['groupname']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "groupname" in params:
+            query_params.append(("groupname", params["groupname"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups/search', 'GET',
+            "/usergroups/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[UserGroupSearchItem]',  # noqa: E501
+            response_type="list[UserGroupSearchItem]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_user_group(self, group_id, **kwargs):  # noqa: E501
         """Update group information  # noqa: E501
 
         Update user group information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -592,16 +645,16 @@
         :param int group_id: Group ID (required)
         :param str x_request_id: An unique ID for the request
         :param UserGroup usergroup:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
         else:
             (data) = self.update_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
             return data
 
     def update_user_group_with_http_info(self, group_id, **kwargs):  # noqa: E501
         """Update group information  # noqa: E501
@@ -617,74 +670,83 @@
         :param str x_request_id: An unique ID for the request
         :param UserGroup usergroup:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['group_id', 'x_request_id', 'usergroup']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["group_id", "x_request_id", "usergroup"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_user_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_user_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'group_id' is set
-        if self.api_client.client_side_validation and ('group_id' not in params or
-                                                       params['group_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `group_id` when calling `update_user_group`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_user_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "group_id" not in params or params["group_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `group_id` when calling `update_user_group`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_user_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'group_id' in params:
-            path_params['group_id'] = params['group_id']  # noqa: E501
+        if "group_id" in params:
+            path_params["group_id"] = params["group_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'usergroup' in params:
-            body_params = params['usergroup']
+        if "usergroup" in params:
+            body_params = params["usergroup"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups/{group_id}', 'PUT',
+            "/usergroups/{group_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/webhook_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/webhook_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -47,22 +47,28 @@
         :param WebhookPolicy policy: Properties \"targets\" and \"event_types\" needed. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_webhook_policy_of_project_with_http_info(project_name_or_id, policy, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_webhook_policy_of_project_with_http_info(
+                project_name_or_id, policy, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_webhook_policy_of_project_with_http_info(project_name_or_id, policy, **kwargs)  # noqa: E501
+            (data) = self.create_webhook_policy_of_project_with_http_info(
+                project_name_or_id, policy, **kwargs
+            )  # noqa: E501
             return data
 
-    def create_webhook_policy_of_project_with_http_info(self, project_name_or_id, policy, **kwargs):  # noqa: E501
+    def create_webhook_policy_of_project_with_http_info(
+        self, project_name_or_id, policy, **kwargs
+    ):  # noqa: E501
         """Create project webhook policy.  # noqa: E501
 
         This endpoint create a webhook policy if the project does not have one.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_webhook_policy_of_project_with_http_info(project_name_or_id, policy, async_req=True)
         >>> result = thread.get()
@@ -73,89 +79,109 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'policy', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "policy",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_webhook_policy_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `create_webhook_policy_of_project`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `create_webhook_policy_of_project`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `create_webhook_policy_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_webhook_policy_of_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `create_webhook_policy_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_webhook_policy_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/webhook/policies', 'POST',
+            "/projects/{project_name_or_id}/webhook/policies",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_webhook_policy_of_project(self, project_name_or_id, webhook_policy_id, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def delete_webhook_policy_of_project(
+        self, project_name_or_id, webhook_policy_id, **kwargs
+    ):  # noqa: E501
         """Delete webhook policy of a project  # noqa: E501
 
         This endpoint is aimed to delete webhookpolicy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_webhook_policy_of_project(project_name_or_id, webhook_policy_id, async_req=True)
         >>> result = thread.get()
@@ -165,22 +191,28 @@
         :param int webhook_policy_id: The ID of the webhook policy (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, **kwargs)  # noqa: E501
+            (data) = self.delete_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_webhook_policy_of_project_with_http_info(self, project_name_or_id, webhook_policy_id, **kwargs):  # noqa: E501
+    def delete_webhook_policy_of_project_with_http_info(
+        self, project_name_or_id, webhook_policy_id, **kwargs
+    ):  # noqa: E501
         """Delete webhook policy of a project  # noqa: E501
 
         This endpoint is aimed to delete webhookpolicy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, async_req=True)
         >>> result = thread.get()
@@ -191,87 +223,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'webhook_policy_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "webhook_policy_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_webhook_policy_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_webhook_policy_of_project`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_webhook_policy_of_project`"
+            )  # noqa: E501
         # verify the required parameter 'webhook_policy_id' is set
-        if self.api_client.client_side_validation and ('webhook_policy_id' not in params or
-                                                       params['webhook_policy_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `webhook_policy_id` when calling `delete_webhook_policy_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_webhook_policy_of_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "webhook_policy_id" not in params or params["webhook_policy_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `webhook_policy_id` when calling `delete_webhook_policy_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_webhook_policy_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'webhook_policy_id' in params:
-            path_params['webhook_policy_id'] = params['webhook_policy_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "webhook_policy_id" in params:
+            path_params["webhook_policy_id"] = params["webhook_policy_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}', 'DELETE',
+            "/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_supported_event_types(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get supported event types and notify types.  # noqa: E501
 
         Get supportted event types and notify types.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -282,19 +332,23 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: SupportedWebhookEventTypes
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_supported_event_types_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_supported_event_types_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_supported_event_types_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.get_supported_event_types_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_supported_event_types_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get supported event types and notify types.  # noqa: E501
 
         Get supportted event types and notify types.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -307,83 +361,95 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: SupportedWebhookEventTypes
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_supported_event_types" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_supported_event_types`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_supported_event_types`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_supported_event_types`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_supported_event_types`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/webhook/events', 'GET',
+            "/projects/{project_name_or_id}/webhook/events",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SupportedWebhookEventTypes',  # noqa: E501
+            response_type="SupportedWebhookEventTypes",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_webhook_policy_of_project(self, project_name_or_id, webhook_policy_id, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def get_webhook_policy_of_project(
+        self, project_name_or_id, webhook_policy_id, **kwargs
+    ):  # noqa: E501
         """Get project webhook policy  # noqa: E501
 
         This endpoint returns specified webhook policy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_webhook_policy_of_project(project_name_or_id, webhook_policy_id, async_req=True)
         >>> result = thread.get()
@@ -393,22 +459,28 @@
         :param int webhook_policy_id: The ID of the webhook policy (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: WebhookPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, **kwargs)  # noqa: E501
+            (data) = self.get_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_webhook_policy_of_project_with_http_info(self, project_name_or_id, webhook_policy_id, **kwargs):  # noqa: E501
+    def get_webhook_policy_of_project_with_http_info(
+        self, project_name_or_id, webhook_policy_id, **kwargs
+    ):  # noqa: E501
         """Get project webhook policy  # noqa: E501
 
         This endpoint returns specified webhook policy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, async_req=True)
         >>> result = thread.get()
@@ -419,87 +491,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: WebhookPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'webhook_policy_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "webhook_policy_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_webhook_policy_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_webhook_policy_of_project`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_webhook_policy_of_project`"
+            )  # noqa: E501
         # verify the required parameter 'webhook_policy_id' is set
-        if self.api_client.client_side_validation and ('webhook_policy_id' not in params or
-                                                       params['webhook_policy_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `webhook_policy_id` when calling `get_webhook_policy_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_webhook_policy_of_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "webhook_policy_id" not in params or params["webhook_policy_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `webhook_policy_id` when calling `get_webhook_policy_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_webhook_policy_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'webhook_policy_id' in params:
-            path_params['webhook_policy_id'] = params['webhook_policy_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "webhook_policy_id" in params:
+            path_params["webhook_policy_id"] = params["webhook_policy_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}', 'GET',
+            "/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='WebhookPolicy',  # noqa: E501
+            response_type="WebhookPolicy",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def last_trigger(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get project webhook policy last trigger info  # noqa: E501
 
         This endpoint returns last trigger information of project webhook policy.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -510,16 +600,16 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: list[WebhookLastTrigger]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.last_trigger_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
             (data) = self.last_trigger_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
     def last_trigger_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get project webhook policy last trigger info  # noqa: E501
@@ -535,81 +625,90 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: list[WebhookLastTrigger]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method last_trigger" % key
+                    "Got an unexpected keyword argument '%s'" " to method last_trigger" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `last_trigger`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `last_trigger`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `last_trigger`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `last_trigger`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/webhook/lasttrigger', 'GET',
+            "/projects/{project_name_or_id}/webhook/lasttrigger",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[WebhookLastTrigger]',  # noqa: E501
+            response_type="list[WebhookLastTrigger]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_webhook_policies_of_project(self, project_name_or_id, **kwargs):  # noqa: E501
         """List project webhook policies.  # noqa: E501
 
         This endpoint returns webhook policies of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -624,22 +723,28 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[WebhookPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_webhook_policies_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_webhook_policies_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_webhook_policies_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.list_webhook_policies_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_webhook_policies_of_project_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
+    def list_webhook_policies_of_project_with_http_info(
+        self, project_name_or_id, **kwargs
+    ):  # noqa: E501
         """List project webhook policies.  # noqa: E501
 
         This endpoint returns webhook policies of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_webhook_policies_of_project_with_http_info(project_name_or_id, async_req=True)
         >>> result = thread.get()
@@ -653,93 +758,117 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[WebhookPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'sort', 'q', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "sort",
+            "q",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_webhook_policies_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_webhook_policies_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_webhook_policies_of_project`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_webhook_policies_of_project`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_webhook_policies_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_webhook_policies_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_webhook_policies_of_project`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/webhook/policies', 'GET',
+            "/projects/{project_name_or_id}/webhook/policies",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[WebhookPolicy]',  # noqa: E501
+            response_type="list[WebhookPolicy]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_webhook_policy_of_project(self, project_name_or_id, webhook_policy_id, policy, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def update_webhook_policy_of_project(
+        self, project_name_or_id, webhook_policy_id, policy, **kwargs
+    ):  # noqa: E501
         """Update webhook policy of a project.  # noqa: E501
 
         This endpoint is aimed to update the webhook policy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_webhook_policy_of_project(project_name_or_id, webhook_policy_id, policy, async_req=True)
         >>> result = thread.get()
@@ -750,22 +879,28 @@
         :param WebhookPolicy policy: All properties needed except \"id\", \"project_id\", \"creation_time\", \"update_time\". (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, policy, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, policy, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, policy, **kwargs)  # noqa: E501
+            (data) = self.update_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, policy, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_webhook_policy_of_project_with_http_info(self, project_name_or_id, webhook_policy_id, policy, **kwargs):  # noqa: E501
+    def update_webhook_policy_of_project_with_http_info(
+        self, project_name_or_id, webhook_policy_id, policy, **kwargs
+    ):  # noqa: E501
         """Update webhook policy of a project.  # noqa: E501
 
         This endpoint is aimed to update the webhook policy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, policy, async_req=True)
         >>> result = thread.get()
@@ -777,86 +912,108 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'webhook_policy_id', 'policy', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "webhook_policy_id",
+            "policy",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_webhook_policy_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_webhook_policy_of_project`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_webhook_policy_of_project`"
+            )  # noqa: E501
         # verify the required parameter 'webhook_policy_id' is set
-        if self.api_client.client_side_validation and ('webhook_policy_id' not in params or
-                                                       params['webhook_policy_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `webhook_policy_id` when calling `update_webhook_policy_of_project`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "webhook_policy_id" not in params or params["webhook_policy_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `webhook_policy_id` when calling `update_webhook_policy_of_project`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `update_webhook_policy_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_webhook_policy_of_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `update_webhook_policy_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_webhook_policy_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'webhook_policy_id' in params:
-            path_params['webhook_policy_id'] = params['webhook_policy_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "webhook_policy_id" in params:
+            path_params["webhook_policy_id"] = params["webhook_policy_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}', 'PUT',
+            "/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api/webhookjob_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/webhookjob_api.py`

 * *Files 11% similar despite different names*

```diff
@@ -52,22 +52,28 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :param list[str] status: The status of webhook job.
         :return: list[WebhookJob]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_webhook_jobs_with_http_info(project_name_or_id, policy_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_webhook_jobs_with_http_info(
+                project_name_or_id, policy_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_webhook_jobs_with_http_info(project_name_or_id, policy_id, **kwargs)  # noqa: E501
+            (data) = self.list_webhook_jobs_with_http_info(
+                project_name_or_id, policy_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_webhook_jobs_with_http_info(self, project_name_or_id, policy_id, **kwargs):  # noqa: E501
+    def list_webhook_jobs_with_http_info(
+        self, project_name_or_id, policy_id, **kwargs
+    ):  # noqa: E501
         """List project webhook jobs  # noqa: E501
 
         This endpoint returns webhook jobs of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_webhook_jobs_with_http_info(project_name_or_id, policy_id, async_req=True)
         >>> result = thread.get()
@@ -83,93 +89,119 @@
         :param int page_size: The size of per page
         :param list[str] status: The status of webhook job.
         :return: list[WebhookJob]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'policy_id', 'x_request_id', 'x_is_resource_name', 'q', 'sort', 'page', 'page_size', 'status']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "policy_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+            "status",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_webhook_jobs" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_webhook_jobs" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_webhook_jobs`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_webhook_jobs`"
+            )  # noqa: E501
         # verify the required parameter 'policy_id' is set
-        if self.api_client.client_side_validation and ('policy_id' not in params or
-                                                       params['policy_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy_id` when calling `list_webhook_jobs`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_webhook_jobs`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_webhook_jobs`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy_id" not in params or params["policy_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy_id` when calling `list_webhook_jobs`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_webhook_jobs`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_webhook_jobs`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'policy_id' in params:
-            query_params.append(('policy_id', params['policy_id']))  # noqa: E501
-        if 'status' in params:
-            query_params.append(('status', params['status']))  # noqa: E501
-            collection_formats['status'] = 'csv'  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "policy_id" in params:
+            query_params.append(("policy_id", params["policy_id"]))  # noqa: E501
+        if "status" in params:
+            query_params.append(("status", params["status"]))  # noqa: E501
+            collection_formats["status"] = "csv"  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/webhook/jobs', 'GET',
+            "/projects/{project_name_or_id}/webhook/jobs",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[WebhookJob]',  # noqa: E501
+            response_type="list[WebhookJob]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/api_client.py` & `harbor_api_client-2.7.6/src/harbor_client/api_client.py`

 * *Files 13% similar despite different names*

```diff
@@ -46,39 +46,38 @@
         the API.
     :param cookie: a cookie to include in the header when making calls
         to the API
     """
 
     PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
     NATIVE_TYPES_MAPPING = {
-        'int': int,
-        'long': int if six.PY3 else long,  # noqa: F821
-        'float': float,
-        'str': str,
-        'bool': bool,
-        'date': datetime.date,
-        'datetime': datetime.datetime,
-        'object': object,
+        "int": int,
+        "long": int if six.PY3 else long,  # noqa: F821
+        "float": float,
+        "str": str,
+        "bool": bool,
+        "date": datetime.date,
+        "datetime": datetime.datetime,
+        "object": object,
     }
 
-    def __init__(self, configuration=None, header_name=None, header_value=None,
-                 cookie=None):
+    def __init__(self, configuration=None, header_name=None, header_value=None, cookie=None):
         if configuration is None:
             configuration = Configuration()
         self.configuration = configuration
 
         # Use the pool property to lazily initialize the ThreadPool.
         self._pool = None
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = 'Swagger-Codegen/2.7.0/python'
+        self.user_agent = "Swagger-Codegen/2.7.0/python"
         self.client_side_validation = configuration.client_side_validation
 
     def __del__(self):
         if self._pool is not None:
             self._pool.close()
             self._pool.join()
 
@@ -87,99 +86,108 @@
         if self._pool is None:
             self._pool = ThreadPool()
         return self._pool
 
     @property
     def user_agent(self):
         """User agent for this API client"""
-        return self.default_headers['User-Agent']
+        return self.default_headers["User-Agent"]
 
     @user_agent.setter
     def user_agent(self, value):
-        self.default_headers['User-Agent'] = value
+        self.default_headers["User-Agent"] = value
 
     def set_default_header(self, header_name, header_value):
         self.default_headers[header_name] = header_value
 
     def __call_api(
-            self, resource_path, method, path_params=None,
-            query_params=None, header_params=None, body=None, post_params=None,
-            files=None, response_type=None, auth_settings=None,
-            _return_http_data_only=None, collection_formats=None,
-            _preload_content=True, _request_timeout=None):
-
+        self,
+        resource_path,
+        method,
+        path_params=None,
+        query_params=None,
+        header_params=None,
+        body=None,
+        post_params=None,
+        files=None,
+        response_type=None,
+        auth_settings=None,
+        _return_http_data_only=None,
+        collection_formats=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
         header_params.update(self.default_headers)
         if self.cookie:
-            header_params['Cookie'] = self.cookie
+            header_params["Cookie"] = self.cookie
         if header_params:
             header_params = self.sanitize_for_serialization(header_params)
-            header_params = dict(self.parameters_to_tuples(header_params,
-                                                           collection_formats))
+            header_params = dict(self.parameters_to_tuples(header_params, collection_formats))
 
         # path parameters
         if path_params:
             path_params = self.sanitize_for_serialization(path_params)
-            path_params = self.parameters_to_tuples(path_params,
-                                                    collection_formats)
+            path_params = self.parameters_to_tuples(path_params, collection_formats)
             for k, v in path_params:
                 # specified safe chars, encode everything
                 resource_path = resource_path.replace(
-                    '{%s}' % k,
-                    quote(str(v), safe=config.safe_chars_for_path_param)
+                    "{%s}" % k, quote(str(v), safe=config.safe_chars_for_path_param)
                 )
 
         # query parameters
         if query_params:
             query_params = self.sanitize_for_serialization(query_params)
-            query_params = self.parameters_to_tuples(query_params,
-                                                     collection_formats)
+            query_params = self.parameters_to_tuples(query_params, collection_formats)
 
         # post parameters
         if post_params or files:
             post_params = self.prepare_post_parameters(post_params, files)
             post_params = self.sanitize_for_serialization(post_params)
-            post_params = self.parameters_to_tuples(post_params,
-                                                    collection_formats)
+            post_params = self.parameters_to_tuples(post_params, collection_formats)
 
         # auth setting
         self.update_params_for_auth(header_params, query_params, auth_settings)
 
         # body
         if body:
             body = self.sanitize_for_serialization(body)
 
         # request url
         url = self.configuration.host + resource_path
 
         # perform request and return response
         response_data = self.request(
-            method, url, query_params=query_params, headers=header_params,
-            post_params=post_params, body=body,
+            method,
+            url,
+            query_params=query_params,
+            headers=header_params,
+            post_params=post_params,
+            body=body,
             _preload_content=_preload_content,
-            _request_timeout=_request_timeout)
+            _request_timeout=_request_timeout,
+        )
 
         self.last_response = response_data
 
         return_data = response_data
         if _preload_content:
             # deserialize response data
             if response_type:
                 return_data = self.deserialize(response_data, response_type)
             else:
                 return_data = None
 
         if _return_http_data_only:
-            return (return_data)
+            return return_data
         else:
-            return (return_data, response_data.status,
-                    response_data.getheaders())
+            return (return_data, response_data.status, response_data.getheaders())
 
     def sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
 
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
@@ -192,36 +200,35 @@
         :return: The serialized form of data.
         """
         if obj is None:
             return None
         elif isinstance(obj, self.PRIMITIVE_TYPES):
             return obj
         elif isinstance(obj, list):
-            return [self.sanitize_for_serialization(sub_obj)
-                    for sub_obj in obj]
+            return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]
         elif isinstance(obj, tuple):
-            return tuple(self.sanitize_for_serialization(sub_obj)
-                         for sub_obj in obj)
+            return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)
         elif isinstance(obj, (datetime.datetime, datetime.date)):
             return obj.isoformat()
 
         if isinstance(obj, dict):
             obj_dict = obj
         else:
             # Convert model obj to dict except
             # attributes `swagger_types`, `attribute_map`
             # and attributes which value is not None.
             # Convert attribute name to json key in
             # model definition for request.
-            obj_dict = {obj.attribute_map[attr]: getattr(obj, attr)
-                        for attr, _ in six.iteritems(obj.swagger_types)
-                        if getattr(obj, attr) is not None}
+            obj_dict = {
+                obj.attribute_map[attr]: getattr(obj, attr)
+                for attr, _ in six.iteritems(obj.swagger_types)
+                if getattr(obj, attr) is not None
+            }
 
-        return {key: self.sanitize_for_serialization(val)
-                for key, val in six.iteritems(obj_dict)}
+        return {key: self.sanitize_for_serialization(val) for key, val in six.iteritems(obj_dict)}
 
     def deserialize(self, response, response_type):
         """Deserializes response into an object.
 
         :param response: RESTResponse object to be deserialized.
         :param response_type: class literal for
             deserialized object, or string of class name.
@@ -249,23 +256,21 @@
 
         :return: object.
         """
         if data is None:
             return None
 
         if type(klass) == str:
-            if klass.startswith('list['):
-                sub_kls = re.match(r'list\[(.*)\]', klass).group(1)
-                return [self.__deserialize(sub_data, sub_kls)
-                        for sub_data in data]
-
-            if klass.startswith('dict('):
-                sub_kls = re.match(r'dict\(([^,]*), (.*)\)', klass).group(2)
-                return {k: self.__deserialize(v, sub_kls)
-                        for k, v in six.iteritems(data)}
+            if klass.startswith("list["):
+                sub_kls = re.match(r"list\[(.*)\]", klass).group(1)
+                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]
+
+            if klass.startswith("dict("):
+                sub_kls = re.match(r"dict\(([^,]*), (.*)\)", klass).group(2)
+                return {k: self.__deserialize(v, sub_kls) for k, v in six.iteritems(data)}
 
             # convert str to class
             if klass in self.NATIVE_TYPES_MAPPING:
                 klass = self.NATIVE_TYPES_MAPPING[klass]
             else:
                 klass = getattr(harbor_client.models, klass)
 
@@ -276,20 +281,32 @@
         elif klass == datetime.date:
             return self.__deserialize_date(data)
         elif klass == datetime.datetime:
             return self.__deserialize_datatime(data)
         else:
             return self.__deserialize_model(data, klass)
 
-    def call_api(self, resource_path, method,
-                 path_params=None, query_params=None, header_params=None,
-                 body=None, post_params=None, files=None,
-                 response_type=None, auth_settings=None, async_req=None,
-                 _return_http_data_only=None, collection_formats=None,
-                 _preload_content=True, _request_timeout=None):
+    def call_api(
+        self,
+        resource_path,
+        method,
+        path_params=None,
+        query_params=None,
+        header_params=None,
+        body=None,
+        post_params=None,
+        files=None,
+        response_type=None,
+        auth_settings=None,
+        async_req=None,
+        _return_http_data_only=None,
+        collection_formats=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
         """Makes the HTTP request (synchronous) and returns deserialized data.
 
         To make an async request, set the async_req parameter.
 
         :param resource_path: Path to method endpoint.
         :param method: Method to call.
         :param path_params: Path parameters in the url.
@@ -319,86 +336,129 @@
             If async_req parameter is True,
             the request will be called asynchronously.
             The method will return the request thread.
             If parameter async_req is False or missing,
             then the method will return the response directly.
         """
         if not async_req:
-            return self.__call_api(resource_path, method,
-                                   path_params, query_params, header_params,
-                                   body, post_params, files,
-                                   response_type, auth_settings,
-                                   _return_http_data_only, collection_formats,
-                                   _preload_content, _request_timeout)
+            return self.__call_api(
+                resource_path,
+                method,
+                path_params,
+                query_params,
+                header_params,
+                body,
+                post_params,
+                files,
+                response_type,
+                auth_settings,
+                _return_http_data_only,
+                collection_formats,
+                _preload_content,
+                _request_timeout,
+            )
         else:
-            thread = self.pool.apply_async(self.__call_api, (resource_path,
-                                           method, path_params, query_params,
-                                           header_params, body,
-                                           post_params, files,
-                                           response_type, auth_settings,
-                                           _return_http_data_only,
-                                           collection_formats,
-                                           _preload_content, _request_timeout))
+            thread = self.pool.apply_async(
+                self.__call_api,
+                (
+                    resource_path,
+                    method,
+                    path_params,
+                    query_params,
+                    header_params,
+                    body,
+                    post_params,
+                    files,
+                    response_type,
+                    auth_settings,
+                    _return_http_data_only,
+                    collection_formats,
+                    _preload_content,
+                    _request_timeout,
+                ),
+            )
         return thread
 
-    def request(self, method, url, query_params=None, headers=None,
-                post_params=None, body=None, _preload_content=True,
-                _request_timeout=None):
+    def request(
+        self,
+        method,
+        url,
+        query_params=None,
+        headers=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
         """Makes the HTTP request using RESTClient."""
         if method == "GET":
-            return self.rest_client.GET(url,
-                                        query_params=query_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        headers=headers)
+            return self.rest_client.GET(
+                url,
+                query_params=query_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                headers=headers,
+            )
         elif method == "HEAD":
-            return self.rest_client.HEAD(url,
-                                         query_params=query_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         headers=headers)
+            return self.rest_client.HEAD(
+                url,
+                query_params=query_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                headers=headers,
+            )
         elif method == "OPTIONS":
-            return self.rest_client.OPTIONS(url,
-                                            query_params=query_params,
-                                            headers=headers,
-                                            post_params=post_params,
-                                            _preload_content=_preload_content,
-                                            _request_timeout=_request_timeout,
-                                            body=body)
+            return self.rest_client.OPTIONS(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "POST":
-            return self.rest_client.POST(url,
-                                         query_params=query_params,
-                                         headers=headers,
-                                         post_params=post_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         body=body)
+            return self.rest_client.POST(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "PUT":
-            return self.rest_client.PUT(url,
-                                        query_params=query_params,
-                                        headers=headers,
-                                        post_params=post_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        body=body)
+            return self.rest_client.PUT(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "PATCH":
-            return self.rest_client.PATCH(url,
-                                          query_params=query_params,
-                                          headers=headers,
-                                          post_params=post_params,
-                                          _preload_content=_preload_content,
-                                          _request_timeout=_request_timeout,
-                                          body=body)
+            return self.rest_client.PATCH(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "DELETE":
-            return self.rest_client.DELETE(url,
-                                           query_params=query_params,
-                                           headers=headers,
-                                           _preload_content=_preload_content,
-                                           _request_timeout=_request_timeout,
-                                           body=body)
+            return self.rest_client.DELETE(
+                url,
+                query_params=query_params,
+                headers=headers,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         else:
             raise ValueError(
                 "http method must be `GET`, `HEAD`, `OPTIONS`,"
                 " `POST`, `PATCH`, `PUT` or `DELETE`."
             )
 
     def parameters_to_tuples(self, params, collection_formats):
@@ -410,27 +470,26 @@
         """
         new_params = []
         if collection_formats is None:
             collection_formats = {}
         for k, v in six.iteritems(params) if isinstance(params, dict) else params:  # noqa: E501
             if k in collection_formats:
                 collection_format = collection_formats[k]
-                if collection_format == 'multi':
+                if collection_format == "multi":
                     new_params.extend((k, value) for value in v)
                 else:
-                    if collection_format == 'ssv':
-                        delimiter = ' '
-                    elif collection_format == 'tsv':
-                        delimiter = '\t'
-                    elif collection_format == 'pipes':
-                        delimiter = '|'
+                    if collection_format == "ssv":
+                        delimiter = " "
+                    elif collection_format == "tsv":
+                        delimiter = "\t"
+                    elif collection_format == "pipes":
+                        delimiter = "|"
                     else:  # csv is the default
-                        delimiter = ','
-                    new_params.append(
-                        (k, delimiter.join(str(value) for value in v)))
+                        delimiter = ","
+                    new_params.append((k, delimiter.join(str(value) for value in v)))
             else:
                 new_params.append((k, v))
         return new_params
 
     def prepare_post_parameters(self, post_params=None, files=None):
         """Builds form parameters.
 
@@ -445,53 +504,51 @@
 
         if files:
             for k, v in six.iteritems(files):
                 if not v:
                     continue
                 file_names = v if type(v) is list else [v]
                 for n in file_names:
-                    with open(n, 'rb') as f:
+                    with open(n, "rb") as f:
                         filename = os.path.basename(f.name)
                         filedata = f.read()
-                        mimetype = (mimetypes.guess_type(filename)[0] or
-                                    'application/octet-stream')
-                        params.append(
-                            tuple([k, tuple([filename, filedata, mimetype])]))
+                        mimetype = mimetypes.guess_type(filename)[0] or "application/octet-stream"
+                        params.append(tuple([k, tuple([filename, filedata, mimetype])]))
 
         return params
 
     def select_header_accept(self, accepts):
         """Returns `Accept` based on an array of accepts provided.
 
         :param accepts: List of headers.
         :return: Accept (e.g. application/json).
         """
         if not accepts:
             return
 
         accepts = [x.lower() for x in accepts]
 
-        if 'application/json' in accepts:
-            return 'application/json'
+        if "application/json" in accepts:
+            return "application/json"
         else:
-            return ', '.join(accepts)
+            return ", ".join(accepts)
 
     def select_header_content_type(self, content_types):
         """Returns `Content-Type` based on an array of content_types provided.
 
         :param content_types: List of content-types.
         :return: Content-Type (e.g. application/json).
         """
         if not content_types:
-            return 'application/json'
+            return "application/json"
 
         content_types = [x.lower() for x in content_types]
 
-        if 'application/json' in content_types or '*/*' in content_types:
-            return 'application/json'
+        if "application/json" in content_types or "*/*" in content_types:
+            return "application/json"
         else:
             return content_types[0]
 
     def update_params_for_auth(self, headers, querys, auth_settings):
         """Updates header and query params based on authentication setting.
 
         :param headers: Header parameters dict to be updated.
@@ -500,24 +557,22 @@
         """
         if not auth_settings:
             return
 
         for auth in auth_settings:
             auth_setting = self.configuration.auth_settings().get(auth)
             if auth_setting:
-                if not auth_setting['value']:
+                if not auth_setting["value"]:
                     continue
-                elif auth_setting['in'] == 'header':
-                    headers[auth_setting['key']] = auth_setting['value']
-                elif auth_setting['in'] == 'query':
-                    querys.append((auth_setting['key'], auth_setting['value']))
+                elif auth_setting["in"] == "header":
+                    headers[auth_setting["key"]] = auth_setting["value"]
+                elif auth_setting["in"] == "query":
+                    querys.append((auth_setting["key"], auth_setting["value"]))
                 else:
-                    raise ValueError(
-                        'Authentication token must be in `query` or `header`'
-                    )
+                    raise ValueError("Authentication token must be in `query` or `header`")
 
     def __deserialize_file(self, response):
         """Deserializes body to file
 
         Saves response body into a file in a temporary folder,
         using the filename from the `Content-Disposition` header if provided.
 
@@ -526,16 +581,15 @@
         """
         fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
         os.close(fd)
         os.remove(path)
 
         content_disposition = response.getheader("Content-Disposition")
         if content_disposition:
-            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
-                                 content_disposition).group(1)
+            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?', content_disposition).group(1)
             path = os.path.join(os.path.dirname(path), filename)
 
         with open(path, "w") as f:
             f.write(response.data)
 
         return path
 
@@ -565,75 +619,75 @@
         """Deserializes string to date.
 
         :param string: str.
         :return: date.
         """
         try:
             from dateutil.parser import parse
+
             return parse(string).date()
         except ImportError:
             return string
         except ValueError:
             raise rest.ApiException(
-                status=0,
-                reason="Failed to parse `{0}` as date object".format(string)
+                status=0, reason="Failed to parse `{0}` as date object".format(string)
             )
 
     def __deserialize_datatime(self, string):
         """Deserializes string to datetime.
 
         The string should be in iso8601 datetime format.
 
         :param string: str.
         :return: datetime.
         """
         try:
             from dateutil.parser import parse
+
             return parse(string)
         except ImportError:
             return string
         except ValueError:
             raise rest.ApiException(
-                status=0,
-                reason=(
-                    "Failed to parse `{0}` as datetime object"
-                    .format(string)
-                )
+                status=0, reason=("Failed to parse `{0}` as datetime object".format(string))
             )
 
     def __hasattr(self, object, name):
         return name in object.__class__.__dict__
 
     def __deserialize_model(self, data, klass):
         """Deserializes list or dict to model.
 
         :param data: dict, list.
         :param klass: class literal.
         :return: model object.
         """
 
-        if (not klass.swagger_types and
-                not self.__hasattr(klass, 'get_real_child_model')):
+        if not klass.swagger_types and not self.__hasattr(klass, "get_real_child_model"):
             return data
 
         kwargs = {}
         if klass.swagger_types is not None:
             for attr, attr_type in six.iteritems(klass.swagger_types):
-                if (data is not None and
-                        klass.attribute_map[attr] in data and
-                        isinstance(data, (list, dict))):
+                if (
+                    data is not None
+                    and klass.attribute_map[attr] in data
+                    and isinstance(data, (list, dict))
+                ):
                     value = data[klass.attribute_map[attr]]
                     kwargs[attr] = self.__deserialize(value, attr_type)
 
         instance = klass(**kwargs)
 
-        if (isinstance(instance, dict) and
-                klass.swagger_types is not None and
-                isinstance(data, dict)):
+        if (
+            isinstance(instance, dict)
+            and klass.swagger_types is not None
+            and isinstance(data, dict)
+        ):
             for key, value in data.items():
                 if key not in klass.swagger_types:
                     instance[key] = value
-        if self.__hasattr(instance, 'get_real_child_model'):
+        if self.__hasattr(instance, "get_real_child_model"):
             klass_name = instance.get_real_child_model(data)
             if klass_name:
                 instance = self.__deserialize(data, klass_name)
         return instance
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/configuration.py` & `harbor_api_client-2.7.6/src/harbor_client/configuration.py`

 * *Files 3% similar despite different names*

```diff
@@ -57,15 +57,15 @@
         self.password = ""
 
         # Logging Settings
         self.logger = {}
         self.logger["package_logger"] = logging.getLogger("harbor_client")
         self.logger["urllib3_logger"] = logging.getLogger("urllib3")
         # Log format
-        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
+        self.logger_format = "%(asctime)s %(levelname)s %(message)s"
         # Log stream handler
         self.logger_stream_handler = None
         # Log file handler
         self.logger_file_handler = None
         # Debug file location
         self.logger_file = None
         # Debug switch
@@ -90,15 +90,15 @@
         # requests to the same host, which is often the case here.
         # cpu_count * 5 is used as default value to increase performance.
         self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
 
         # Proxy URL
         self.proxy = None
         # Safe chars for path_param
-        self.safe_chars_for_path_param = ''
+        self.safe_chars_for_path_param = ""
 
         # Disable client side validation
         self.client_side_validation = True
 
     @classmethod
     def set_default(cls, default):
         cls._default = default
@@ -218,38 +218,37 @@
                 return key
 
     def get_basic_auth_token(self):
         """Gets HTTP basic authentication header (string).
 
         :return: The token for basic HTTP authentication.
         """
-        return urllib3.util.make_headers(
-            basic_auth=self.username + ':' + self.password
-        ).get('authorization')
+        return urllib3.util.make_headers(basic_auth=self.username + ":" + self.password).get(
+            "authorization"
+        )
 
     def auth_settings(self):
         """Gets Auth Settings dict for api client.
 
         :return: The Auth Settings information dict.
         """
         return {
-            'basic':
-                {
-                    'type': 'basic',
-                    'in': 'header',
-                    'key': 'Authorization',
-                    'value': self.get_basic_auth_token()
-                },
-
+            "basic": {
+                "type": "basic",
+                "in": "header",
+                "key": "Authorization",
+                "value": self.get_basic_auth_token(),
+            },
         }
 
     def to_debug_report(self):
         """Gets the essential information for debugging.
 
         :return: The report for debugging.
         """
-        return "Python SDK Debug Report:\n"\
-               "OS: {env}\n"\
-               "Python Version: {pyversion}\n"\
-               "Version of the API: 2.0\n"\
-               "SDK Package Version: 2.7.0".\
-               format(env=sys.platform, pyversion=sys.version)
+        return (
+            "Python SDK Debug Report:\n"
+            "OS: {env}\n"
+            "Python Version: {pyversion}\n"
+            "Version of the API: 2.0\n"
+            "SDK Package Version: 2.7.0".format(env=sys.platform, pyversion=sys.version)
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/__init__.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/__init__.py`

 * *Files identical despite different names*

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/artifact_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/artifact_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -48,22 +48,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param Label label: The label that added to the artifact. Only the ID property is needed. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.add_label_with_http_info(project_name, repository_name, reference, label, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.add_label_with_http_info(
+                project_name, repository_name, reference, label, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.add_label_with_http_info(project_name, repository_name, reference, label, **kwargs)  # noqa: E501
+            (data) = self.add_label_with_http_info(
+                project_name, repository_name, reference, label, **kwargs
+            )  # noqa: E501
             return data
 
-    def add_label_with_http_info(self, project_name, repository_name, reference, label, **kwargs):  # noqa: E501
+    def add_label_with_http_info(
+        self, project_name, repository_name, reference, label, **kwargs
+    ):  # noqa: E501
         """Add label to artifact  # noqa: E501
 
         Add label to the specified artiact.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_label_with_http_info(project_name, repository_name, reference, label, async_req=True)
         >>> result = thread.get()
@@ -75,97 +81,121 @@
         :param Label label: The label that added to the artifact. Only the ID property is needed. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'label', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "label",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method add_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method add_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `add_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `add_label`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `add_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `add_label`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `add_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `add_label`"
+            )  # noqa: E501
         # verify the required parameter 'label' is set
-        if self.api_client.client_side_validation and ('label' not in params or
-                                                       params['label'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label` when calling `add_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `add_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label" not in params or params["label"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label` when calling `add_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `add_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'label' in params:
-            body_params = params['label']
+        if "label" in params:
+            body_params = params["label"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def copy_artifact(self, project_name, repository_name, _from, **kwargs):  # noqa: E501
         """Copy artifact  # noqa: E501
 
         Copy the artifact specified in the \"from\" parameter to the repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -177,22 +207,28 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str _from: The artifact from which the new artifact is copied from, the format should be \"project/repository:tag\" or \"project/repository@digest\". (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.copy_artifact_with_http_info(project_name, repository_name, _from, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.copy_artifact_with_http_info(
+                project_name, repository_name, _from, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.copy_artifact_with_http_info(project_name, repository_name, _from, **kwargs)  # noqa: E501
+            (data) = self.copy_artifact_with_http_info(
+                project_name, repository_name, _from, **kwargs
+            )  # noqa: E501
             return data
 
-    def copy_artifact_with_http_info(self, project_name, repository_name, _from, **kwargs):  # noqa: E501
+    def copy_artifact_with_http_info(
+        self, project_name, repository_name, _from, **kwargs
+    ):  # noqa: E501
         """Copy artifact  # noqa: E501
 
         Copy the artifact specified in the \"from\" parameter to the repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.copy_artifact_with_http_info(project_name, repository_name, _from, async_req=True)
         >>> result = thread.get()
@@ -203,91 +239,106 @@
         :param str _from: The artifact from which the new artifact is copied from, the format should be \"project/repository:tag\" or \"project/repository@digest\". (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', '_from', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "_from", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method copy_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method copy_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `copy_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `copy_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `copy_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `copy_artifact`"
+            )  # noqa: E501
         # verify the required parameter '_from' is set
-        if self.api_client.client_side_validation and ('_from' not in params or
-                                                       params['_from'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `_from` when calling `copy_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `copy_artifact`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "_from" not in params or params["_from"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `_from` when calling `copy_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `copy_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
-        if '_from' in params:
-            query_params.append(('from', params['_from']))  # noqa: E501
+        if "_from" in params:
+            query_params.append(("from", params["_from"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def create_tag(self, project_name, repository_name, reference, tag, **kwargs):  # noqa: E501
         """Create tag  # noqa: E501
 
         Create a tag for the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -300,22 +351,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param Tag tag: The JSON object of tag. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_tag_with_http_info(project_name, repository_name, reference, tag, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_tag_with_http_info(
+                project_name, repository_name, reference, tag, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_tag_with_http_info(project_name, repository_name, reference, tag, **kwargs)  # noqa: E501
+            (data) = self.create_tag_with_http_info(
+                project_name, repository_name, reference, tag, **kwargs
+            )  # noqa: E501
             return data
 
-    def create_tag_with_http_info(self, project_name, repository_name, reference, tag, **kwargs):  # noqa: E501
+    def create_tag_with_http_info(
+        self, project_name, repository_name, reference, tag, **kwargs
+    ):  # noqa: E501
         """Create tag  # noqa: E501
 
         Create a tag for the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_tag_with_http_info(project_name, repository_name, reference, tag, async_req=True)
         >>> result = thread.get()
@@ -327,97 +384,121 @@
         :param Tag tag: The JSON object of tag. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'tag', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "tag",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_tag" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_tag" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `create_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `create_tag`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `create_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `create_tag`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `create_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `create_tag`"
+            )  # noqa: E501
         # verify the required parameter 'tag' is set
-        if self.api_client.client_side_validation and ('tag' not in params or
-                                                       params['tag'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `tag` when calling `create_tag`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_tag`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "tag" not in params or params["tag"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `tag` when calling `create_tag`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_tag`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'tag' in params:
-            body_params = params['tag']
+        if "tag" in params:
+            body_params = params["tag"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_artifact(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """Delete the specific artifact  # noqa: E501
 
         Delete the artifact specified by the reference under the project and repository. The reference can be digest or tag  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -429,22 +510,28 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.delete_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_artifact_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def delete_artifact_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Delete the specific artifact  # noqa: E501
 
         Delete the artifact specified by the reference under the project and repository. The reference can be digest or tag  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_artifact_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -455,93 +542,110 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "reference", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `delete_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `delete_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `delete_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `delete_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `delete_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_artifact`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `delete_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}', 'DELETE',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_tag(self, project_name, repository_name, reference, tag_name, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def delete_tag(
+        self, project_name, repository_name, reference, tag_name, **kwargs
+    ):  # noqa: E501
         """Delete tag  # noqa: E501
 
         Delete the tag of the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_tag(project_name, repository_name, reference, tag_name, async_req=True)
         >>> result = thread.get()
@@ -552,22 +656,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str tag_name: The name of the tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_tag_with_http_info(project_name, repository_name, reference, tag_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_tag_with_http_info(
+                project_name, repository_name, reference, tag_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_tag_with_http_info(project_name, repository_name, reference, tag_name, **kwargs)  # noqa: E501
+            (data) = self.delete_tag_with_http_info(
+                project_name, repository_name, reference, tag_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_tag_with_http_info(self, project_name, repository_name, reference, tag_name, **kwargs):  # noqa: E501
+    def delete_tag_with_http_info(
+        self, project_name, repository_name, reference, tag_name, **kwargs
+    ):  # noqa: E501
         """Delete tag  # noqa: E501
 
         Delete the tag of the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_tag_with_http_info(project_name, repository_name, reference, tag_name, async_req=True)
         >>> result = thread.get()
@@ -579,99 +689,125 @@
         :param str tag_name: The name of the tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'tag_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "tag_name",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_tag" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_tag" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `delete_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `delete_tag`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `delete_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `delete_tag`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `delete_tag`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `delete_tag`"
+            )  # noqa: E501
         # verify the required parameter 'tag_name' is set
-        if self.api_client.client_side_validation and ('tag_name' not in params or
-                                                       params['tag_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `tag_name` when calling `delete_tag`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_tag`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "tag_name" not in params or params["tag_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `tag_name` when calling `delete_tag`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_tag`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
-        if 'tag_name' in params:
-            path_params['tag_name'] = params['tag_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
+        if "tag_name" in params:
+            path_params["tag_name"] = params["tag_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags/{tag_name}', 'DELETE',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags/{tag_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_addition(self, project_name, repository_name, reference, addition, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def get_addition(
+        self, project_name, repository_name, reference, addition, **kwargs
+    ):  # noqa: E501
         """Get the addition of the specific artifact  # noqa: E501
 
         Get the addition of the artifact specified by the reference under the project and repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_addition(project_name, repository_name, reference, addition, async_req=True)
         >>> result = thread.get()
@@ -682,22 +818,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str addition: The type of addition. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_addition_with_http_info(project_name, repository_name, reference, addition, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_addition_with_http_info(
+                project_name, repository_name, reference, addition, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_addition_with_http_info(project_name, repository_name, reference, addition, **kwargs)  # noqa: E501
+            (data) = self.get_addition_with_http_info(
+                project_name, repository_name, reference, addition, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_addition_with_http_info(self, project_name, repository_name, reference, addition, **kwargs):  # noqa: E501
+    def get_addition_with_http_info(
+        self, project_name, repository_name, reference, addition, **kwargs
+    ):  # noqa: E501
         """Get the addition of the specific artifact  # noqa: E501
 
         Get the addition of the artifact specified by the reference under the project and repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_addition_with_http_info(project_name, repository_name, reference, addition, async_req=True)
         >>> result = thread.get()
@@ -709,97 +851,121 @@
         :param str addition: The type of addition. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'addition', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "addition",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_addition" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_addition" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_addition`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_addition`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `get_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `get_addition`"
+            )  # noqa: E501
         # verify the required parameter 'addition' is set
-        if self.api_client.client_side_validation and ('addition' not in params or
-                                                       params['addition'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `addition` when calling `get_addition`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_addition`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "addition" not in params or params["addition"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `addition` when calling `get_addition`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_addition`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
-        if 'addition' in params:
-            path_params['addition'] = params['addition']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
+        if "addition" in params:
+            path_params["addition"] = params["addition"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/{addition}', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/{addition}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_artifact(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """Get the specific artifact  # noqa: E501
 
         Get the artifact specified by the reference under the project and repository. The reference can be digest or tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -820,22 +986,28 @@
         :param bool with_accessory: Specify whether the accessories are included of the returning artifacts.
         :param bool with_signature: Specify whether the signature is inclued inside the returning artifacts
         :param bool with_immutable_status: Specify whether the immutable status is inclued inside the tags of the returning artifacts.
         :return: Artifact
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.get_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_artifact_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def get_artifact_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Get the specific artifact  # noqa: E501
 
         Get the artifact specified by the reference under the project and repository. The reference can be digest or tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_artifact_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -855,113 +1027,152 @@
         :param bool with_signature: Specify whether the signature is inclued inside the returning artifacts
         :param bool with_immutable_status: Specify whether the immutable status is inclued inside the tags of the returning artifacts.
         :return: Artifact
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id', 'page', 'page_size', 'x_accept_vulnerabilities', 'with_tag', 'with_label', 'with_scan_overview', 'with_accessory', 'with_signature', 'with_immutable_status']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "x_request_id",
+            "page",
+            "page_size",
+            "x_accept_vulnerabilities",
+            "with_tag",
+            "with_label",
+            "with_scan_overview",
+            "with_accessory",
+            "with_signature",
+            "with_immutable_status",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `get_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_artifact`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `get_artifact`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `get_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `get_artifact`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'with_tag' in params:
-            query_params.append(('with_tag', params['with_tag']))  # noqa: E501
-        if 'with_label' in params:
-            query_params.append(('with_label', params['with_label']))  # noqa: E501
-        if 'with_scan_overview' in params:
-            query_params.append(('with_scan_overview', params['with_scan_overview']))  # noqa: E501
-        if 'with_accessory' in params:
-            query_params.append(('with_accessory', params['with_accessory']))  # noqa: E501
-        if 'with_signature' in params:
-            query_params.append(('with_signature', params['with_signature']))  # noqa: E501
-        if 'with_immutable_status' in params:
-            query_params.append(('with_immutable_status', params['with_immutable_status']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "with_tag" in params:
+            query_params.append(("with_tag", params["with_tag"]))  # noqa: E501
+        if "with_label" in params:
+            query_params.append(("with_label", params["with_label"]))  # noqa: E501
+        if "with_scan_overview" in params:
+            query_params.append(("with_scan_overview", params["with_scan_overview"]))  # noqa: E501
+        if "with_accessory" in params:
+            query_params.append(("with_accessory", params["with_accessory"]))  # noqa: E501
+        if "with_signature" in params:
+            query_params.append(("with_signature", params["with_signature"]))  # noqa: E501
+        if "with_immutable_status" in params:
+            query_params.append(
+                ("with_immutable_status", params["with_immutable_status"])
+            )  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_accept_vulnerabilities' in params:
-            header_params['X-Accept-Vulnerabilities'] = params['x_accept_vulnerabilities']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_accept_vulnerabilities" in params:
+            header_params["X-Accept-Vulnerabilities"] = params[
+                "x_accept_vulnerabilities"
+            ]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Artifact',  # noqa: E501
+            response_type="Artifact",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_vulnerabilities_addition(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def get_vulnerabilities_addition(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Get the vulnerabilities addition of the specific artifact  # noqa: E501
 
         Get the vulnerabilities addition of the artifact specified by the reference under the project and repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_vulnerabilities_addition(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -972,22 +1183,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :param str x_accept_vulnerabilities: A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it. Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_vulnerabilities_addition_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_vulnerabilities_addition_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_vulnerabilities_addition_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.get_vulnerabilities_addition_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_vulnerabilities_addition_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def get_vulnerabilities_addition_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Get the vulnerabilities addition of the specific artifact  # noqa: E501
 
         Get the vulnerabilities addition of the artifact specified by the reference under the project and repository.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_vulnerabilities_addition_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -999,93 +1216,117 @@
         :param str x_request_id: An unique ID for the request
         :param str x_accept_vulnerabilities: A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it. Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id', 'x_accept_vulnerabilities']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "x_request_id",
+            "x_accept_vulnerabilities",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_vulnerabilities_addition" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_vulnerabilities_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_vulnerabilities_addition`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_vulnerabilities_addition`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_vulnerabilities_addition`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `get_vulnerabilities_addition`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_vulnerabilities_addition`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `get_vulnerabilities_addition`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_vulnerabilities_addition`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_accept_vulnerabilities' in params:
-            header_params['X-Accept-Vulnerabilities'] = params['x_accept_vulnerabilities']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_accept_vulnerabilities" in params:
+            header_params["X-Accept-Vulnerabilities"] = params[
+                "x_accept_vulnerabilities"
+            ]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/vulnerabilities', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/vulnerabilities",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_accessories(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """List accessories  # noqa: E501
 
         List accessories of the specific artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1101,22 +1342,28 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Accessory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_accessories_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_accessories_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_accessories_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.list_accessories_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_accessories_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def list_accessories_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """List accessories  # noqa: E501
 
         List accessories of the specific artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_accessories_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -1131,101 +1378,129 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Accessory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_accessories" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_accessories" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_accessories`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_accessories`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `list_accessories`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `list_accessories`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `list_accessories`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_accessories`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_accessories`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `list_accessories`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_accessories`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_accessories`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/accessories', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/accessories",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Accessory]',  # noqa: E501
+            response_type="list[Accessory]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_artifacts(self, project_name, repository_name, **kwargs):  # noqa: E501
         """List artifacts  # noqa: E501
 
         List artifacts under the specific project and repository. Except the basic properties, the other supported queries in \"q\" includes \"tags=*\" to list only tagged artifacts, \"tags=nil\" to list only untagged artifacts, \"tags=~v\" to list artifacts whose tag fuzzy matches \"v\", \"tags=v\" to list artifact whose tag exactly matches \"v\", \"labels=(id1, id2)\" to list artifacts that both labels with id1 and id2 are added to  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1247,19 +1522,23 @@
         :param bool with_signature: Specify whether the signature is included inside the tags of the returning artifacts. Only works when setting \"with_tag=true\"
         :param bool with_immutable_status: Specify whether the immutable status is included inside the tags of the returning artifacts. Only works when setting \"with_immutable_status=true\"
         :param bool with_accessory: Specify whether the accessories are included of the returning artifacts. Only works when setting \"with_accessory=true\"
         :return: list[Artifact]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_artifacts_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_artifacts_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_artifacts_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+            (data) = self.list_artifacts_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
             return data
 
     def list_artifacts_with_http_info(self, project_name, repository_name, **kwargs):  # noqa: E501
         """List artifacts  # noqa: E501
 
         List artifacts under the specific project and repository. Except the basic properties, the other supported queries in \"q\" includes \"tags=*\" to list only tagged artifacts, \"tags=nil\" to list only untagged artifacts, \"tags=~v\" to list artifacts whose tag fuzzy matches \"v\", \"tags=v\" to list artifact whose tag exactly matches \"v\", \"labels=(id1, id2)\" to list artifacts that both labels with id1 and id2 are added to  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -1283,109 +1562,144 @@
         :param bool with_immutable_status: Specify whether the immutable status is included inside the tags of the returning artifacts. Only works when setting \"with_immutable_status=true\"
         :param bool with_accessory: Specify whether the accessories are included of the returning artifacts. Only works when setting \"with_accessory=true\"
         :return: list[Artifact]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'x_request_id', 'q', 'sort', 'page', 'page_size', 'x_accept_vulnerabilities', 'with_tag', 'with_label', 'with_scan_overview', 'with_signature', 'with_immutable_status', 'with_accessory']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+            "x_accept_vulnerabilities",
+            "with_tag",
+            "with_label",
+            "with_scan_overview",
+            "with_signature",
+            "with_immutable_status",
+            "with_accessory",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_artifacts" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_artifacts" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_artifacts`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_artifacts`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `list_artifacts`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_artifacts`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_artifacts`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `list_artifacts`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_artifacts`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_artifacts`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'with_tag' in params:
-            query_params.append(('with_tag', params['with_tag']))  # noqa: E501
-        if 'with_label' in params:
-            query_params.append(('with_label', params['with_label']))  # noqa: E501
-        if 'with_scan_overview' in params:
-            query_params.append(('with_scan_overview', params['with_scan_overview']))  # noqa: E501
-        if 'with_signature' in params:
-            query_params.append(('with_signature', params['with_signature']))  # noqa: E501
-        if 'with_immutable_status' in params:
-            query_params.append(('with_immutable_status', params['with_immutable_status']))  # noqa: E501
-        if 'with_accessory' in params:
-            query_params.append(('with_accessory', params['with_accessory']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "with_tag" in params:
+            query_params.append(("with_tag", params["with_tag"]))  # noqa: E501
+        if "with_label" in params:
+            query_params.append(("with_label", params["with_label"]))  # noqa: E501
+        if "with_scan_overview" in params:
+            query_params.append(("with_scan_overview", params["with_scan_overview"]))  # noqa: E501
+        if "with_signature" in params:
+            query_params.append(("with_signature", params["with_signature"]))  # noqa: E501
+        if "with_immutable_status" in params:
+            query_params.append(
+                ("with_immutable_status", params["with_immutable_status"])
+            )  # noqa: E501
+        if "with_accessory" in params:
+            query_params.append(("with_accessory", params["with_accessory"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_accept_vulnerabilities' in params:
-            header_params['X-Accept-Vulnerabilities'] = params['x_accept_vulnerabilities']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_accept_vulnerabilities" in params:
+            header_params["X-Accept-Vulnerabilities"] = params[
+                "x_accept_vulnerabilities"
+            ]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Artifact]',  # noqa: E501
+            response_type="list[Artifact]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_tags(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """List tags  # noqa: E501
 
         List tags of the specific artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1403,22 +1717,28 @@
         :param int page_size: The size of per page
         :param bool with_signature: Specify whether the signature is included inside the returning tags
         :param bool with_immutable_status: Specify whether the immutable status is included inside the returning tags
         :return: list[Tag]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_tags_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_tags_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_tags_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.list_tags_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_tags_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def list_tags_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """List tags  # noqa: E501
 
         List tags of the specific artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_tags_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -1435,107 +1755,141 @@
         :param bool with_signature: Specify whether the signature is included inside the returning tags
         :param bool with_immutable_status: Specify whether the immutable status is included inside the returning tags
         :return: list[Tag]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id', 'q', 'sort', 'page', 'page_size', 'with_signature', 'with_immutable_status']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+            "with_signature",
+            "with_immutable_status",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_tags" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_tags" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_tags`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_tags`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `list_tags`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `list_tags`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `list_tags`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_tags`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_tags`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `list_tags`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_tags`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_tags`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'with_signature' in params:
-            query_params.append(('with_signature', params['with_signature']))  # noqa: E501
-        if 'with_immutable_status' in params:
-            query_params.append(('with_immutable_status', params['with_immutable_status']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "with_signature" in params:
+            query_params.append(("with_signature", params["with_signature"]))  # noqa: E501
+        if "with_immutable_status" in params:
+            query_params.append(
+                ("with_immutable_status", params["with_immutable_status"])
+            )  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Tag]',  # noqa: E501
+            response_type="list[Tag]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def remove_label(self, project_name, repository_name, reference, label_id, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def remove_label(
+        self, project_name, repository_name, reference, label_id, **kwargs
+    ):  # noqa: E501
         """Remove label from artifact  # noqa: E501
 
         Remove the label from the specified artiact.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_label(project_name, repository_name, reference, label_id, async_req=True)
         >>> result = thread.get()
@@ -1546,22 +1900,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param int label_id: The ID of the label that removed from the artifact. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.remove_label_with_http_info(project_name, repository_name, reference, label_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.remove_label_with_http_info(
+                project_name, repository_name, reference, label_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.remove_label_with_http_info(project_name, repository_name, reference, label_id, **kwargs)  # noqa: E501
+            (data) = self.remove_label_with_http_info(
+                project_name, repository_name, reference, label_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def remove_label_with_http_info(self, project_name, repository_name, reference, label_id, **kwargs):  # noqa: E501
+    def remove_label_with_http_info(
+        self, project_name, repository_name, reference, label_id, **kwargs
+    ):  # noqa: E501
         """Remove label from artifact  # noqa: E501
 
         Remove the label from the specified artiact.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_label_with_http_info(project_name, repository_name, reference, label_id, async_req=True)
         >>> result = thread.get()
@@ -1573,90 +1933,114 @@
         :param int label_id: The ID of the label that removed from the artifact. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'label_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "label_id",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method remove_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method remove_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `remove_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `remove_label`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `remove_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `remove_label`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `remove_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `remove_label`"
+            )  # noqa: E501
         # verify the required parameter 'label_id' is set
-        if self.api_client.client_side_validation and ('label_id' not in params or
-                                                       params['label_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label_id` when calling `remove_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `remove_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label_id" not in params or params["label_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label_id` when calling `remove_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `remove_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
-        if 'label_id' in params:
-            path_params['label_id'] = params['label_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
+        if "label_id" in params:
+            path_params["label_id"] = params["label_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels/{label_id}', 'DELETE',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels/{label_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/auditlog_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/auditlog_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -48,16 +48,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[AuditLog]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_audit_logs_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_audit_logs_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_audit_logs_with_http_info(self, **kwargs):  # noqa: E501
         """Get recent logs of the projects which the user is a member of  # noqa: E501
@@ -75,76 +75,86 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[AuditLog]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_audit_logs" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_audit_logs" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_audit_logs`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_audit_logs`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_audit_logs`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_audit_logs`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/audit-logs', 'GET',
+            "/audit-logs",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[AuditLog]',  # noqa: E501
+            response_type="list[AuditLog]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/configure_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/configure_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ConfigurationsResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_configurations_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_configurations_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_configurations_with_http_info(self, **kwargs):  # noqa: E501
         """Get system configurations.  # noqa: E501
@@ -67,73 +67,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ConfigurationsResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_configurations" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_configurations" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_configurations`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_configurations`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/configurations', 'GET',
+            "/configurations",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ConfigurationsResponse',  # noqa: E501
+            response_type="ConfigurationsResponse",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_internalconfig(self, **kwargs):  # noqa: E501
         """Get internal configurations.  # noqa: E501
 
         This endpoint is for retrieving system configurations that only provides for internal api call.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -142,16 +148,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: InternalConfigurationsResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_internalconfig_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_internalconfig_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_internalconfig_with_http_info(self, **kwargs):  # noqa: E501
         """Get internal configurations.  # noqa: E501
@@ -165,73 +171,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: InternalConfigurationsResponse
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_internalconfig" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_internalconfig" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_internalconfig`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_internalconfig`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/internalconfig', 'GET',
+            "/internalconfig",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='InternalConfigurationsResponse',  # noqa: E501
+            response_type="InternalConfigurationsResponse",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_configurations(self, configurations, **kwargs):  # noqa: E501
         """Modify system configurations.  # noqa: E501
 
         This endpoint is for modifying system configurations that only provides for admin user.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -241,19 +253,21 @@
         :param async_req bool
         :param Configurations configurations: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_configurations_with_http_info(configurations, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_configurations_with_http_info(configurations, **kwargs)  # noqa: E501
+            (data) = self.update_configurations_with_http_info(
+                configurations, **kwargs
+            )  # noqa: E501
             return data
 
     def update_configurations_with_http_info(self, configurations, **kwargs):  # noqa: E501
         """Modify system configurations.  # noqa: E501
 
         This endpoint is for modifying system configurations that only provides for admin user.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -265,72 +279,82 @@
         :param Configurations configurations: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['configurations', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["configurations", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_configurations" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'configurations' is set
-        if self.api_client.client_side_validation and ('configurations' not in params or
-                                                       params['configurations'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `configurations` when calling `update_configurations`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_configurations`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "configurations" not in params or params["configurations"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `configurations` when calling `update_configurations`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_configurations`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'configurations' in params:
-            body_params = params['configurations']
+        if "configurations" in params:
+            body_params = params["configurations"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/configurations', 'PUT',
+            "/configurations",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/gc_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/gc_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Schedule schedule: Updates of gc's schedule. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_gc_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.create_gc_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def create_gc_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Create a gc schedule.  # noqa: E501
@@ -69,79 +69,88 @@
         :param Schedule schedule: Updates of gc's schedule. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_gc_schedule" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_gc_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `create_gc_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_gc_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `create_gc_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_gc_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/schedule', 'POST',
+            "/system/gc/schedule",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_gc(self, gc_id, **kwargs):  # noqa: E501
         """Get gc status.  # noqa: E501
 
         This endpoint let user get gc status filtered by specific ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: GCHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_gc_with_http_info(gc_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_gc_with_http_info(gc_id, **kwargs)  # noqa: E501
             return data
 
     def get_gc_with_http_info(self, gc_id, **kwargs):  # noqa: E501
         """Get gc status.  # noqa: E501
@@ -175,79 +184,86 @@
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: GCHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['gc_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["gc_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_gc" % key
-                )
+                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_gc" % key)
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'gc_id' is set
-        if self.api_client.client_side_validation and ('gc_id' not in params or
-                                                       params['gc_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `gc_id` when calling `get_gc`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_gc`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "gc_id" not in params or params["gc_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `gc_id` when calling `get_gc`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_gc`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'gc_id' in params:
-            path_params['gc_id'] = params['gc_id']  # noqa: E501
+        if "gc_id" in params:
+            path_params["gc_id"] = params["gc_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/{gc_id}', 'GET',
+            "/system/gc/{gc_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GCHistory',  # noqa: E501
+            response_type="GCHistory",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_gc_history(self, **kwargs):  # noqa: E501
         """Get gc results.  # noqa: E501
 
         This endpoint let user get gc execution history.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -260,16 +276,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[GCHistory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_gc_history_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_gc_history_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_gc_history_with_http_info(self, **kwargs):  # noqa: E501
         """Get gc results.  # noqa: E501
@@ -287,83 +303,93 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[GCHistory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_gc_history" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_gc_history" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_gc_history`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `get_gc_history`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_gc_history`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `get_gc_history`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc', 'GET',
+            "/system/gc",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[GCHistory]',  # noqa: E501
+            response_type="list[GCHistory]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_gc_log(self, gc_id, **kwargs):  # noqa: E501
         """Get gc job log.  # noqa: E501
 
         This endpoint let user get gc job logs filtered by specific ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -373,16 +399,16 @@
         :param async_req bool
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_gc_log_with_http_info(gc_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_gc_log_with_http_info(gc_id, **kwargs)  # noqa: E501
             return data
 
     def get_gc_log_with_http_info(self, gc_id, **kwargs):  # noqa: E501
         """Get gc job log.  # noqa: E501
@@ -397,79 +423,86 @@
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['gc_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["gc_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_gc_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_gc_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'gc_id' is set
-        if self.api_client.client_side_validation and ('gc_id' not in params or
-                                                       params['gc_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `gc_id` when calling `get_gc_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_gc_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "gc_id" not in params or params["gc_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `gc_id` when calling `get_gc_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_gc_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'gc_id' in params:
-            path_params['gc_id'] = params['gc_id']  # noqa: E501
+        if "gc_id" in params:
+            path_params["gc_id"] = params["gc_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/{gc_id}/log', 'GET',
+            "/system/gc/{gc_id}/log",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_gc_schedule(self, **kwargs):  # noqa: E501
         """Get gc's schedule.  # noqa: E501
 
         This endpoint is for get schedule of gc job.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -478,16 +511,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: GCHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_gc_schedule_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_gc_schedule_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_gc_schedule_with_http_info(self, **kwargs):  # noqa: E501
         """Get gc's schedule.  # noqa: E501
@@ -501,73 +534,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: GCHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_gc_schedule" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_gc_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_gc_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_gc_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/schedule', 'GET',
+            "/system/gc/schedule",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GCHistory',  # noqa: E501
+            response_type="GCHistory",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_gc(self, gc_id, **kwargs):  # noqa: E501
         """Stop the specific GC execution  # noqa: E501
 
         Stop the GC execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -577,16 +616,16 @@
         :param async_req bool
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_gc_with_http_info(gc_id, **kwargs)  # noqa: E501
         else:
             (data) = self.stop_gc_with_http_info(gc_id, **kwargs)  # noqa: E501
             return data
 
     def stop_gc_with_http_info(self, gc_id, **kwargs):  # noqa: E501
         """Stop the specific GC execution  # noqa: E501
@@ -601,79 +640,88 @@
         :param int gc_id: The ID of the gc log (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['gc_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["gc_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_gc" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_gc" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'gc_id' is set
-        if self.api_client.client_side_validation and ('gc_id' not in params or
-                                                       params['gc_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `gc_id` when calling `stop_gc`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_gc`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "gc_id" not in params or params["gc_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `gc_id` when calling `stop_gc`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_gc`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'gc_id' in params:
-            path_params['gc_id'] = params['gc_id']  # noqa: E501
+        if "gc_id" in params:
+            path_params["gc_id"] = params["gc_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/{gc_id}', 'PUT',
+            "/system/gc/{gc_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_gc_schedule(self, schedule, **kwargs):  # noqa: E501
         """Update gc's schedule.  # noqa: E501
 
         This endpoint is for update gc schedule.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -683,16 +731,16 @@
         :param async_req bool
         :param Schedule schedule: Updates of gc's schedule. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_gc_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.update_gc_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def update_gc_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Update gc's schedule.  # noqa: E501
@@ -707,72 +755,81 @@
         :param Schedule schedule: Updates of gc's schedule. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_gc_schedule" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_gc_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `update_gc_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_gc_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `update_gc_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_gc_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/gc/schedule', 'PUT',
+            "/system/gc/schedule",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/health_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/health_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: OverallHealthStatus
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_health_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_health_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_health_with_http_info(self, **kwargs):  # noqa: E501
         """Check the status of Harbor components  # noqa: E501
@@ -67,66 +67,72 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: OverallHealthStatus
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_health" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_health" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_health`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_health`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/health', 'GET',
+            "/health",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='OverallHealthStatus',  # noqa: E501
+            response_type="OverallHealthStatus",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/icon_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/icon_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param str digest: The digest of the resource (required)
         :param str x_request_id: An unique ID for the request
         :return: Icon
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_icon_with_http_info(digest, **kwargs)  # noqa: E501
         else:
             (data) = self.get_icon_with_http_info(digest, **kwargs)  # noqa: E501
             return data
 
     def get_icon_with_http_info(self, digest, **kwargs):  # noqa: E501
         """Get artifact icon  # noqa: E501
@@ -69,72 +69,81 @@
         :param str digest: The digest of the resource (required)
         :param str x_request_id: An unique ID for the request
         :return: Icon
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['digest', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["digest", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_icon" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_icon" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'digest' is set
-        if self.api_client.client_side_validation and ('digest' not in params or
-                                                       params['digest'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `digest` when calling `get_icon`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_icon`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "digest" not in params or params["digest"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `digest` when calling `get_icon`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_icon`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'digest' in params:
-            path_params['digest'] = params['digest']  # noqa: E501
+        if "digest" in params:
+            path_params["digest"] = params["digest"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/icons/{digest}', 'GET',
+            "/icons/{digest}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Icon',  # noqa: E501
+            response_type="Icon",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/immutable_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/immutable_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -47,22 +47,28 @@
         :param ImmutableRule immutable_rule: (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_immu_rule_with_http_info(project_name_or_id, immutable_rule, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_immu_rule_with_http_info(project_name_or_id, immutable_rule, **kwargs)  # noqa: E501
+            (data) = self.create_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule, **kwargs
+            )  # noqa: E501
             return data
 
-    def create_immu_rule_with_http_info(self, project_name_or_id, immutable_rule, **kwargs):  # noqa: E501
+    def create_immu_rule_with_http_info(
+        self, project_name_or_id, immutable_rule, **kwargs
+    ):  # noqa: E501
         """Add an immutable tag rule to current project  # noqa: E501
 
         This endpoint add an immutable tag rule to the project   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_immu_rule_with_http_info(project_name_or_id, immutable_rule, async_req=True)
         >>> result = thread.get()
@@ -73,87 +79,104 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'immutable_rule', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "immutable_rule",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_immu_rule" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_immu_rule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `create_immu_rule`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `create_immu_rule`"
+            )  # noqa: E501
         # verify the required parameter 'immutable_rule' is set
-        if self.api_client.client_side_validation and ('immutable_rule' not in params or
-                                                       params['immutable_rule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `immutable_rule` when calling `create_immu_rule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_immu_rule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "immutable_rule" not in params or params["immutable_rule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `immutable_rule` when calling `create_immu_rule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_immu_rule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'immutable_rule' in params:
-            body_params = params['immutable_rule']
+        if "immutable_rule" in params:
+            body_params = params["immutable_rule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/immutabletagrules', 'POST',
+            "/projects/{project_name_or_id}/immutabletagrules",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_immu_rule(self, project_name_or_id, immutable_rule_id, **kwargs):  # noqa: E501
         """Delete the immutable tag rule.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_immu_rule(project_name_or_id, immutable_rule_id, async_req=True)
@@ -164,22 +187,28 @@
         :param int immutable_rule_id: The ID of the immutable rule (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, **kwargs)  # noqa: E501
+            (data) = self.delete_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_immu_rule_with_http_info(self, project_name_or_id, immutable_rule_id, **kwargs):  # noqa: E501
+    def delete_immu_rule_with_http_info(
+        self, project_name_or_id, immutable_rule_id, **kwargs
+    ):  # noqa: E501
         """Delete the immutable tag rule.  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, async_req=True)
         >>> result = thread.get()
 
@@ -189,87 +218,104 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'immutable_rule_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "immutable_rule_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_immu_rule" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_immu_rule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_immu_rule`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_immu_rule`"
+            )  # noqa: E501
         # verify the required parameter 'immutable_rule_id' is set
-        if self.api_client.client_side_validation and ('immutable_rule_id' not in params or
-                                                       params['immutable_rule_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `immutable_rule_id` when calling `delete_immu_rule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_immu_rule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "immutable_rule_id" not in params or params["immutable_rule_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `immutable_rule_id` when calling `delete_immu_rule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_immu_rule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'immutable_rule_id' in params:
-            path_params['immutable_rule_id'] = params['immutable_rule_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "immutable_rule_id" in params:
+            path_params["immutable_rule_id"] = params["immutable_rule_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}', 'DELETE',
+            "/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_immu_rules(self, project_name_or_id, **kwargs):  # noqa: E501
         """List all immutable tag rules of current project  # noqa: E501
 
         This endpoint returns the immutable tag rules of a project   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -284,16 +330,16 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[ImmutableRule]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_immu_rules_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
             (data) = self.list_immu_rules_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
     def list_immu_rules_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """List all immutable tag rules of current project  # noqa: E501
@@ -313,93 +359,116 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[ImmutableRule]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_immu_rules" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_immu_rules" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_immu_rules`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_immu_rules`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_immu_rules`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_immu_rules`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_immu_rules`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_immu_rules`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/immutabletagrules', 'GET',
+            "/projects/{project_name_or_id}/immutabletagrules",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ImmutableRule]',  # noqa: E501
+            response_type="list[ImmutableRule]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_immu_rule(self, project_name_or_id, immutable_rule_id, immutable_rule, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def update_immu_rule(
+        self, project_name_or_id, immutable_rule_id, immutable_rule, **kwargs
+    ):  # noqa: E501
         """Update the immutable tag rule or enable or disable the rule  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_immu_rule(project_name_or_id, immutable_rule_id, immutable_rule, async_req=True)
         >>> result = thread.get()
 
@@ -409,22 +478,28 @@
         :param ImmutableRule immutable_rule: (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, immutable_rule, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule_id, immutable_rule, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, immutable_rule, **kwargs)  # noqa: E501
+            (data) = self.update_immu_rule_with_http_info(
+                project_name_or_id, immutable_rule_id, immutable_rule, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_immu_rule_with_http_info(self, project_name_or_id, immutable_rule_id, immutable_rule, **kwargs):  # noqa: E501
+    def update_immu_rule_with_http_info(
+        self, project_name_or_id, immutable_rule_id, immutable_rule, **kwargs
+    ):  # noqa: E501
         """Update the immutable tag rule or enable or disable the rule  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_immu_rule_with_http_info(project_name_or_id, immutable_rule_id, immutable_rule, async_req=True)
         >>> result = thread.get()
 
@@ -435,86 +510,107 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'immutable_rule_id', 'immutable_rule', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "immutable_rule_id",
+            "immutable_rule",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_immu_rule" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_immu_rule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_immu_rule`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_immu_rule`"
+            )  # noqa: E501
         # verify the required parameter 'immutable_rule_id' is set
-        if self.api_client.client_side_validation and ('immutable_rule_id' not in params or
-                                                       params['immutable_rule_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `immutable_rule_id` when calling `update_immu_rule`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "immutable_rule_id" not in params or params["immutable_rule_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `immutable_rule_id` when calling `update_immu_rule`"
+            )  # noqa: E501
         # verify the required parameter 'immutable_rule' is set
-        if self.api_client.client_side_validation and ('immutable_rule' not in params or
-                                                       params['immutable_rule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `immutable_rule` when calling `update_immu_rule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_immu_rule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "immutable_rule" not in params or params["immutable_rule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `immutable_rule` when calling `update_immu_rule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_immu_rule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'immutable_rule_id' in params:
-            path_params['immutable_rule_id'] = params['immutable_rule_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "immutable_rule_id" in params:
+            path_params["immutable_rule_id"] = params["immutable_rule_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'immutable_rule' in params:
-            body_params = params['immutable_rule']
+        if "immutable_rule" in params:
+            body_params = params["immutable_rule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}', 'PUT',
+            "/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/jobservice_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/jobservice_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -46,19 +46,23 @@
         :param str job_type: The type of the job. 'all' stands for all job types (required)
         :param ActionRequest action_request: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.action_pending_jobs_with_http_info(job_type, action_request, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.action_pending_jobs_with_http_info(
+                job_type, action_request, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.action_pending_jobs_with_http_info(job_type, action_request, **kwargs)  # noqa: E501
+            (data) = self.action_pending_jobs_with_http_info(
+                job_type, action_request, **kwargs
+            )  # noqa: E501
             return data
 
     def action_pending_jobs_with_http_info(self, job_type, action_request, **kwargs):  # noqa: E501
         """stop and clean, pause, resume pending jobs in the queue  # noqa: E501
 
         stop and clean, pause, resume pending jobs in the queue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -71,85 +75,97 @@
         :param ActionRequest action_request: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['job_type', 'action_request', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["job_type", "action_request", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method action_pending_jobs" % key
+                    "Got an unexpected keyword argument '%s'" " to method action_pending_jobs" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'job_type' is set
-        if self.api_client.client_side_validation and ('job_type' not in params or
-                                                       params['job_type'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `job_type` when calling `action_pending_jobs`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "job_type" not in params or params["job_type"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `job_type` when calling `action_pending_jobs`"
+            )  # noqa: E501
         # verify the required parameter 'action_request' is set
-        if self.api_client.client_side_validation and ('action_request' not in params or
-                                                       params['action_request'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `action_request` when calling `action_pending_jobs`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `action_pending_jobs`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "action_request" not in params or params["action_request"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `action_request` when calling `action_pending_jobs`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `action_pending_jobs`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'job_type' in params:
-            path_params['job_type'] = params['job_type']  # noqa: E501
+        if "job_type" in params:
+            path_params["job_type"] = params["job_type"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'action_request' in params:
-            body_params = params['action_request']
+        if "action_request" in params:
+            body_params = params["action_request"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/queues/{job_type}', 'PUT',
+            "/jobservice/queues/{job_type}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_worker_pools(self, **kwargs):  # noqa: E501
         """Get worker pools  # noqa: E501
 
         Get worker pools  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -158,16 +174,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[WorkerPool]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_worker_pools_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_worker_pools_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_worker_pools_with_http_info(self, **kwargs):  # noqa: E501
         """Get worker pools  # noqa: E501
@@ -181,73 +197,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[WorkerPool]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_worker_pools" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_worker_pools" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_worker_pools`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_worker_pools`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/pools', 'GET',
+            "/jobservice/pools",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[WorkerPool]',  # noqa: E501
+            response_type="list[WorkerPool]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_workers(self, pool_id, **kwargs):  # noqa: E501
         """Get workers  # noqa: E501
 
         Get workers in current pool  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +279,16 @@
         :param async_req bool
         :param str pool_id: The name of the pool. 'all' stands for all pools (required)
         :param str x_request_id: An unique ID for the request
         :return: list[Worker]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_workers_with_http_info(pool_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_workers_with_http_info(pool_id, **kwargs)  # noqa: E501
             return data
 
     def get_workers_with_http_info(self, pool_id, **kwargs):  # noqa: E501
         """Get workers  # noqa: E501
@@ -281,79 +303,88 @@
         :param str pool_id: The name of the pool. 'all' stands for all pools (required)
         :param str x_request_id: An unique ID for the request
         :return: list[Worker]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['pool_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["pool_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_workers" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_workers" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'pool_id' is set
-        if self.api_client.client_side_validation and ('pool_id' not in params or
-                                                       params['pool_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `pool_id` when calling `get_workers`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_workers`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "pool_id" not in params or params["pool_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `pool_id` when calling `get_workers`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_workers`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'pool_id' in params:
-            path_params['pool_id'] = params['pool_id']  # noqa: E501
+        if "pool_id" in params:
+            path_params["pool_id"] = params["pool_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/pools/{pool_id}/workers', 'GET',
+            "/jobservice/pools/{pool_id}/workers",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Worker]',  # noqa: E501
+            response_type="list[Worker]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_job_queues(self, **kwargs):  # noqa: E501
         """list job queues  # noqa: E501
 
         list job queue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -362,16 +393,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[JobQueue]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_job_queues_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_job_queues_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_job_queues_with_http_info(self, **kwargs):  # noqa: E501
         """list job queues  # noqa: E501
@@ -385,73 +416,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[JobQueue]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_job_queues" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_job_queues" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_job_queues`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_job_queues`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/queues', 'GET',
+            "/jobservice/queues",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[JobQueue]',  # noqa: E501
+            response_type="list[JobQueue]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_running_job(self, job_id, **kwargs):  # noqa: E501
         """Stop running job  # noqa: E501
 
         Stop running job  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -461,16 +498,16 @@
         :param async_req bool
         :param str job_id: The id of the job. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_running_job_with_http_info(job_id, **kwargs)  # noqa: E501
         else:
             (data) = self.stop_running_job_with_http_info(job_id, **kwargs)  # noqa: E501
             return data
 
     def stop_running_job_with_http_info(self, job_id, **kwargs):  # noqa: E501
         """Stop running job  # noqa: E501
@@ -485,72 +522,81 @@
         :param str job_id: The id of the job. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['job_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["job_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_running_job" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_running_job" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'job_id' is set
-        if self.api_client.client_side_validation and ('job_id' not in params or
-                                                       params['job_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `job_id` when calling `stop_running_job`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_running_job`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "job_id" not in params or params["job_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `job_id` when calling `stop_running_job`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_running_job`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'job_id' in params:
-            path_params['job_id'] = params['job_id']  # noqa: E501
+        if "job_id" in params:
+            path_params["job_id"] = params["job_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/jobservice/jobs/{job_id}', 'PUT',
+            "/jobservice/jobs/{job_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/label_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/label_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Label label: The json object of label. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_label_with_http_info(label, **kwargs)  # noqa: E501
         else:
             (data) = self.create_label_with_http_info(label, **kwargs)  # noqa: E501
             return data
 
     def create_label_with_http_info(self, label, **kwargs):  # noqa: E501
         """Post creates a label  # noqa: E501
@@ -69,79 +69,88 @@
         :param Label label: The json object of label. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['label', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["label", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'label' is set
-        if self.api_client.client_side_validation and ('label' not in params or
-                                                       params['label'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label` when calling `create_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label" not in params or params["label"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label` when calling `create_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'label' in params:
-            body_params = params['label']
+        if "label" in params:
+            body_params = params["label"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels', 'POST',
+            "/labels",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_label(self, label_id, **kwargs):  # noqa: E501
         """Delete the label specified by ID.  # noqa: E501
 
         Delete the label specified by ID.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int label_id: Label ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_label_with_http_info(label_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_label_with_http_info(label_id, **kwargs)  # noqa: E501
             return data
 
     def delete_label_with_http_info(self, label_id, **kwargs):  # noqa: E501
         """Delete the label specified by ID.  # noqa: E501
@@ -175,79 +184,88 @@
         :param int label_id: Label ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['label_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["label_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'label_id' is set
-        if self.api_client.client_side_validation and ('label_id' not in params or
-                                                       params['label_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label_id` when calling `delete_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label_id" not in params or params["label_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label_id` when calling `delete_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'label_id' in params:
-            path_params['label_id'] = params['label_id']  # noqa: E501
+        if "label_id" in params:
+            path_params["label_id"] = params["label_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels/{label_id}', 'DELETE',
+            "/labels/{label_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_label_by_id(self, label_id, **kwargs):  # noqa: E501
         """Get the label specified by ID.  # noqa: E501
 
         This endpoint let user get the label by specific ID.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +275,16 @@
         :param async_req bool
         :param int label_id: Label ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Label
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_label_by_id_with_http_info(label_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_label_by_id_with_http_info(label_id, **kwargs)  # noqa: E501
             return data
 
     def get_label_by_id_with_http_info(self, label_id, **kwargs):  # noqa: E501
         """Get the label specified by ID.  # noqa: E501
@@ -281,79 +299,88 @@
         :param int label_id: Label ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Label
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['label_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["label_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_label_by_id" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_label_by_id" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'label_id' is set
-        if self.api_client.client_side_validation and ('label_id' not in params or
-                                                       params['label_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label_id` when calling `get_label_by_id`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_label_by_id`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label_id" not in params or params["label_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label_id` when calling `get_label_by_id`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_label_by_id`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'label_id' in params:
-            path_params['label_id'] = params['label_id']  # noqa: E501
+        if "label_id" in params:
+            path_params["label_id"] = params["label_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels/{label_id}', 'GET',
+            "/labels/{label_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Label',  # noqa: E501
+            response_type="Label",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_labels(self, **kwargs):  # noqa: E501
         """List labels according to the query strings.  # noqa: E501
 
         This endpoint let user list labels by name, scope and project_id   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -369,16 +396,16 @@
         :param str name: The label name.
         :param str scope: The label scope. Valid values are g and p. g for global labels and p for project labels.
         :param int project_id: Relevant project ID, required when scope is p.
         :return: list[Label]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_labels_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_labels_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_labels_with_http_info(self, **kwargs):  # noqa: E501
         """List labels according to the query strings.  # noqa: E501
@@ -399,89 +426,108 @@
         :param str scope: The label scope. Valid values are g and p. g for global labels and p for project labels.
         :param int project_id: Relevant project ID, required when scope is p.
         :return: list[Label]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size', 'name', 'scope', 'project_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+            "name",
+            "scope",
+            "project_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_labels" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_labels" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_labels`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_labels`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_labels`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_labels`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'name' in params:
-            query_params.append(('name', params['name']))  # noqa: E501
-        if 'scope' in params:
-            query_params.append(('scope', params['scope']))  # noqa: E501
-        if 'project_id' in params:
-            query_params.append(('project_id', params['project_id']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "name" in params:
+            query_params.append(("name", params["name"]))  # noqa: E501
+        if "scope" in params:
+            query_params.append(("scope", params["scope"]))  # noqa: E501
+        if "project_id" in params:
+            query_params.append(("project_id", params["project_id"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels', 'GET',
+            "/labels",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Label]',  # noqa: E501
+            response_type="list[Label]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_label(self, label_id, label, **kwargs):  # noqa: E501
         """Update the label properties.  # noqa: E501
 
         This endpoint let user update label properties.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -492,16 +538,16 @@
         :param int label_id: Label ID (required)
         :param Label label: The updated label json object. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_label_with_http_info(label_id, label, **kwargs)  # noqa: E501
         else:
             (data) = self.update_label_with_http_info(label_id, label, **kwargs)  # noqa: E501
             return data
 
     def update_label_with_http_info(self, label_id, label, **kwargs):  # noqa: E501
         """Update the label properties.  # noqa: E501
@@ -517,78 +563,90 @@
         :param Label label: The updated label json object. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['label_id', 'label', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["label_id", "label", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_label" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_label" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'label_id' is set
-        if self.api_client.client_side_validation and ('label_id' not in params or
-                                                       params['label_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label_id` when calling `update_label`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label_id" not in params or params["label_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label_id` when calling `update_label`"
+            )  # noqa: E501
         # verify the required parameter 'label' is set
-        if self.api_client.client_side_validation and ('label' not in params or
-                                                       params['label'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `label` when calling `update_label`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_label`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "label" not in params or params["label"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `label` when calling `update_label`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_label`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'label_id' in params:
-            path_params['label_id'] = params['label_id']  # noqa: E501
+        if "label_id" in params:
+            path_params["label_id"] = params["label_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'label' in params:
-            body_params = params['label']
+        if "label" in params:
+            body_params = params["label"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/labels/{label_id}', 'PUT',
+            "/labels/{label_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/ldap_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/ldap_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param LdapImportUsers uid_list: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.import_ldap_user_with_http_info(uid_list, **kwargs)  # noqa: E501
         else:
             (data) = self.import_ldap_user_with_http_info(uid_list, **kwargs)  # noqa: E501
             return data
 
     def import_ldap_user_with_http_info(self, uid_list, **kwargs):  # noqa: E501
         """Import selected available ldap users.  # noqa: E501
@@ -69,79 +69,88 @@
         :param LdapImportUsers uid_list: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['uid_list', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["uid_list", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method import_ldap_user" % key
+                    "Got an unexpected keyword argument '%s'" " to method import_ldap_user" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'uid_list' is set
-        if self.api_client.client_side_validation and ('uid_list' not in params or
-                                                       params['uid_list'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `uid_list` when calling `import_ldap_user`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `import_ldap_user`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "uid_list" not in params or params["uid_list"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `uid_list` when calling `import_ldap_user`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `import_ldap_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'uid_list' in params:
-            body_params = params['uid_list']
+        if "uid_list" in params:
+            body_params = params["uid_list"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ldap/users/import', 'POST',
+            "/ldap/users/import",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def ping_ldap(self, **kwargs):  # noqa: E501
         """Ping available ldap service.  # noqa: E501
 
         This endpoint ping the available ldap service for test related configuration parameters.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param LdapConf ldapconf: ldap configuration. support input ldap service configuration. If it is a empty request, will load current configuration from the system.
         :return: LdapPingResult
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_ldap_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.ping_ldap_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def ping_ldap_with_http_info(self, **kwargs):  # noqa: E501
         """Ping available ldap service.  # noqa: E501
@@ -175,75 +184,81 @@
         :param str x_request_id: An unique ID for the request
         :param LdapConf ldapconf: ldap configuration. support input ldap service configuration. If it is a empty request, will load current configuration from the system.
         :return: LdapPingResult
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'ldapconf']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "ldapconf"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_ldap" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_ldap" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_ldap`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_ldap`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'ldapconf' in params:
-            body_params = params['ldapconf']
+        if "ldapconf" in params:
+            body_params = params["ldapconf"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ldap/ping', 'POST',
+            "/ldap/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='LdapPingResult',  # noqa: E501
+            response_type="LdapPingResult",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def search_ldap_group(self, **kwargs):  # noqa: E501
         """Search available ldap groups.  # noqa: E501
 
         This endpoint searches the available ldap groups based on related configuration parameters. support to search by groupname or groupdn.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -254,16 +269,16 @@
         :param str x_request_id: An unique ID for the request
         :param str groupname: Ldap group name
         :param str groupdn: The LDAP group DN
         :return: list[UserGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.search_ldap_group_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.search_ldap_group_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def search_ldap_group_with_http_info(self, **kwargs):  # noqa: E501
         """Search available ldap groups.  # noqa: E501
@@ -279,77 +294,83 @@
         :param str groupname: Ldap group name
         :param str groupdn: The LDAP group DN
         :return: list[UserGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'groupname', 'groupdn']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "groupname", "groupdn"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search_ldap_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method search_ldap_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search_ldap_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search_ldap_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'groupname' in params:
-            query_params.append(('groupname', params['groupname']))  # noqa: E501
-        if 'groupdn' in params:
-            query_params.append(('groupdn', params['groupdn']))  # noqa: E501
+        if "groupname" in params:
+            query_params.append(("groupname", params["groupname"]))  # noqa: E501
+        if "groupdn" in params:
+            query_params.append(("groupdn", params["groupdn"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ldap/groups/search', 'GET',
+            "/ldap/groups/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[UserGroup]',  # noqa: E501
+            response_type="list[UserGroup]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def search_ldap_user(self, **kwargs):  # noqa: E501
         """Search available ldap users.  # noqa: E501
 
         This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -359,16 +380,16 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param str username: Registered user ID
         :return: list[LdapUser]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.search_ldap_user_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.search_ldap_user_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def search_ldap_user_with_http_info(self, **kwargs):  # noqa: E501
         """Search available ldap users.  # noqa: E501
@@ -383,68 +404,74 @@
         :param str x_request_id: An unique ID for the request
         :param str username: Registered user ID
         :return: list[LdapUser]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'username']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "username"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search_ldap_user" % key
+                    "Got an unexpected keyword argument '%s'" " to method search_ldap_user" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search_ldap_user`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search_ldap_user`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'username' in params:
-            query_params.append(('username', params['username']))  # noqa: E501
+        if "username" in params:
+            query_params.append(("username", params["username"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ldap/users/search', 'GET',
+            "/ldap/users/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[LdapUser]',  # noqa: E501
+            response_type="list[LdapUser]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/member_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/member_api.py`

 * *Files 15% similar despite different names*

```diff
@@ -47,19 +47,23 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param ProjectMember project_member:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_project_member_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_project_member_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_project_member_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.create_project_member_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def create_project_member_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Create project member  # noqa: E501
 
         Create project member relationship, the member can be one of the user_member and group_member,  The user_member need to specify user_id or username. If the user already exist in harbor DB, specify the user_id,  If does not exist in harbor DB, it will SearchAndOnBoard the user. The group_member need to specify id or ldap_group_dn. If the group already exist in harbor DB. specify the user group's id,  If does not exist, it will SearchAndOnBoard the group.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -73,83 +77,98 @@
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param ProjectMember project_member:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'project_member']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "project_member",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_project_member" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `create_project_member`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_project_member`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `create_project_member`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_project_member`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'project_member' in params:
-            body_params = params['project_member']
+        if "project_member" in params:
+            body_params = params["project_member"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members', 'POST',
+            "/projects/{project_name_or_id}/members",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_project_member(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Delete project member  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_project_member(project_name_or_id, mid, async_req=True)
@@ -160,19 +179,23 @@
         :param int mid: Member ID. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+            (data) = self.delete_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
             return data
 
     def delete_project_member_with_http_info(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Delete project member  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -185,87 +208,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'mid', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "mid",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_project_member" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_project_member`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_project_member`"
+            )  # noqa: E501
         # verify the required parameter 'mid' is set
-        if self.api_client.client_side_validation and ('mid' not in params or
-                                                       params['mid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `mid` when calling `delete_project_member`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_project_member`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "mid" not in params or params["mid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `mid` when calling `delete_project_member`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_project_member`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'mid' in params:
-            path_params['mid'] = params['mid']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "mid" in params:
+            path_params["mid"] = params["mid"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members/{mid}', 'DELETE',
+            "/projects/{project_name_or_id}/members/{mid}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project_member(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Get the project member information  # noqa: E501
 
         Get the project member information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -277,19 +318,23 @@
         :param int mid: The member ID (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectMemberEntity
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+            (data) = self.get_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
             return data
 
     def get_project_member_with_http_info(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Get the project member information  # noqa: E501
 
         Get the project member information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -303,87 +348,104 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectMemberEntity
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'mid', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "mid",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_project_member" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_project_member" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project_member`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project_member`"
+            )  # noqa: E501
         # verify the required parameter 'mid' is set
-        if self.api_client.client_side_validation and ('mid' not in params or
-                                                       params['mid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `mid` when calling `get_project_member`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project_member`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "mid" not in params or params["mid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `mid` when calling `get_project_member`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project_member`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'mid' in params:
-            path_params['mid'] = params['mid']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "mid" in params:
+            path_params["mid"] = params["mid"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members/{mid}', 'GET',
+            "/projects/{project_name_or_id}/members/{mid}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectMemberEntity',  # noqa: E501
+            response_type="ProjectMemberEntity",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_project_members(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get all project member information  # noqa: E501
 
         Get all project member information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -397,19 +459,23 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :param str entityname: The entity name to search.
         :return: list[ProjectMemberEntity]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_project_members_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_project_members_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_project_members_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.list_project_members_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def list_project_members_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get all project member information  # noqa: E501
 
         Get all project member information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -425,89 +491,110 @@
         :param int page_size: The size of per page
         :param str entityname: The entity name to search.
         :return: list[ProjectMemberEntity]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'page', 'page_size', 'entityname']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "page",
+            "page_size",
+            "entityname",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_project_members" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_project_members`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_project_members`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_project_members`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_project_members`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_project_members`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_project_members`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'entityname' in params:
-            query_params.append(('entityname', params['entityname']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "entityname" in params:
+            query_params.append(("entityname", params["entityname"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members', 'GET',
+            "/projects/{project_name_or_id}/members",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ProjectMemberEntity]',  # noqa: E501
+            response_type="list[ProjectMemberEntity]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_project_member(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Update project member  # noqa: E501
 
         Update project member relationship  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -520,19 +607,23 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param RoleRequest role:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_project_member_with_http_info(project_name_or_id, mid, **kwargs)  # noqa: E501
+            (data) = self.update_project_member_with_http_info(
+                project_name_or_id, mid, **kwargs
+            )  # noqa: E501
             return data
 
     def update_project_member_with_http_info(self, project_name_or_id, mid, **kwargs):  # noqa: E501
         """Update project member  # noqa: E501
 
         Update project member relationship  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -547,82 +638,101 @@
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param RoleRequest role:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'mid', 'x_request_id', 'x_is_resource_name', 'role']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "mid",
+            "x_request_id",
+            "x_is_resource_name",
+            "role",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_project_member" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_project_member`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_project_member`"
+            )  # noqa: E501
         # verify the required parameter 'mid' is set
-        if self.api_client.client_side_validation and ('mid' not in params or
-                                                       params['mid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `mid` when calling `update_project_member`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_project_member`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "mid" not in params or params["mid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `mid` when calling `update_project_member`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_project_member`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'mid' in params:
-            path_params['mid'] = params['mid']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "mid" in params:
+            path_params["mid"] = params["mid"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'role' in params:
-            body_params = params['role']
+        if "role" in params:
+            body_params = params["role"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/members/{mid}', 'PUT',
+            "/projects/{project_name_or_id}/members/{mid}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/oidc_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/oidc_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Endpoint endpoint: Request body for OIDC endpoint to be tested. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_oidc_with_http_info(endpoint, **kwargs)  # noqa: E501
         else:
             (data) = self.ping_oidc_with_http_info(endpoint, **kwargs)  # noqa: E501
             return data
 
     def ping_oidc_with_http_info(self, endpoint, **kwargs):  # noqa: E501
         """Test the OIDC endpoint.  # noqa: E501
@@ -69,72 +69,81 @@
         :param Endpoint endpoint: Request body for OIDC endpoint to be tested. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['endpoint', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["endpoint", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_oidc" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_oidc" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'endpoint' is set
-        if self.api_client.client_side_validation and ('endpoint' not in params or
-                                                       params['endpoint'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `endpoint` when calling `ping_oidc`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_oidc`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "endpoint" not in params or params["endpoint"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `endpoint` when calling `ping_oidc`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_oidc`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'endpoint' in params:
-            body_params = params['endpoint']
+        if "endpoint" in params:
+            body_params = params["endpoint"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/oidc/ping', 'POST',
+            "/system/oidc/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/ping_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/ping_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_ping_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_ping_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_ping_with_http_info(self, **kwargs):  # noqa: E501
         """Ping Harbor to check if it's alive.  # noqa: E501
@@ -67,66 +67,70 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_ping" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_ping" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_ping`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_ping`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/ping', 'GET',
+            "/ping",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/preheat_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/preheat_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Instance instance: The JSON object of instance. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_instance_with_http_info(instance, **kwargs)  # noqa: E501
         else:
             (data) = self.create_instance_with_http_info(instance, **kwargs)  # noqa: E501
             return data
 
     def create_instance_with_http_info(self, instance, **kwargs):  # noqa: E501
         """Create p2p provider instances  # noqa: E501
@@ -69,79 +69,88 @@
         :param Instance instance: The JSON object of instance. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['instance', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["instance", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_instance" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_instance" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'instance' is set
-        if self.api_client.client_side_validation and ('instance' not in params or
-                                                       params['instance'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `instance` when calling `create_instance`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_instance`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "instance" not in params or params["instance"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `instance` when calling `create_instance`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_instance`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'instance' in params:
-            body_params = params['instance']
+        if "instance" in params:
+            body_params = params["instance"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances', 'POST',
+            "/p2p/preheat/instances",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def create_policy(self, project_name, policy, **kwargs):  # noqa: E501
         """Create a preheat policy under a project  # noqa: E501
 
         Create a preheat policy under a project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -152,16 +161,16 @@
         :param str project_name: The name of the project (required)
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_policy_with_http_info(project_name, policy, **kwargs)  # noqa: E501
         else:
             (data) = self.create_policy_with_http_info(project_name, policy, **kwargs)  # noqa: E501
             return data
 
     def create_policy_with_http_info(self, project_name, policy, **kwargs):  # noqa: E501
         """Create a preheat policy under a project  # noqa: E501
@@ -177,85 +186,97 @@
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_policy" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `create_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `create_policy`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `create_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `create_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies', 'POST',
+            "/projects/{project_name}/preheat/policies",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_instance(self, preheat_instance_name, **kwargs):  # noqa: E501
         """Delete the specified P2P provider instance  # noqa: E501
 
         Delete the specified P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -265,19 +286,23 @@
         :param async_req bool
         :param str preheat_instance_name: Instance Name (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_instance_with_http_info(preheat_instance_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_instance_with_http_info(
+                preheat_instance_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_instance_with_http_info(preheat_instance_name, **kwargs)  # noqa: E501
+            (data) = self.delete_instance_with_http_info(
+                preheat_instance_name, **kwargs
+            )  # noqa: E501
             return data
 
     def delete_instance_with_http_info(self, preheat_instance_name, **kwargs):  # noqa: E501
         """Delete the specified P2P provider instance  # noqa: E501
 
         Delete the specified P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -289,79 +314,88 @@
         :param str preheat_instance_name: Instance Name (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['preheat_instance_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["preheat_instance_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_instance" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_instance" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'preheat_instance_name' is set
-        if self.api_client.client_side_validation and ('preheat_instance_name' not in params or
-                                                       params['preheat_instance_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_instance_name` when calling `delete_instance`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_instance`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_instance_name" not in params or params["preheat_instance_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_instance_name` when calling `delete_instance`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_instance`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'preheat_instance_name' in params:
-            path_params['preheat_instance_name'] = params['preheat_instance_name']  # noqa: E501
+        if "preheat_instance_name" in params:
+            path_params["preheat_instance_name"] = params["preheat_instance_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances/{preheat_instance_name}', 'DELETE',
+            "/p2p/preheat/instances/{preheat_instance_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_policy(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
         """Delete a preheat policy  # noqa: E501
 
         Delete a preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -372,22 +406,28 @@
         :param str project_name: The name of the project (required)
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_policy_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_policy_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_policy_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+            (data) = self.delete_policy_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_policy_with_http_info(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
+    def delete_policy_with_http_info(
+        self, project_name, preheat_policy_name, **kwargs
+    ):  # noqa: E501
         """Delete a preheat policy  # noqa: E501
 
         Delete a preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_policy_with_http_info(project_name, preheat_policy_name, async_req=True)
         >>> result = thread.get()
@@ -397,87 +437,101 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "preheat_policy_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_policy" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `delete_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `delete_policy`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `delete_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `delete_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}', 'DELETE',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_execution(self, project_name, preheat_policy_name, execution_id, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def get_execution(
+        self, project_name, preheat_policy_name, execution_id, **kwargs
+    ):  # noqa: E501
         """Get a execution detail by id  # noqa: E501
 
         Get a execution detail by id  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_execution(project_name, preheat_policy_name, execution_id, async_req=True)
         >>> result = thread.get()
@@ -487,22 +541,28 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Execution
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_execution_with_http_info(project_name, preheat_policy_name, execution_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_execution_with_http_info(
+                project_name, preheat_policy_name, execution_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_execution_with_http_info(project_name, preheat_policy_name, execution_id, **kwargs)  # noqa: E501
+            (data) = self.get_execution_with_http_info(
+                project_name, preheat_policy_name, execution_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_execution_with_http_info(self, project_name, preheat_policy_name, execution_id, **kwargs):  # noqa: E501
+    def get_execution_with_http_info(
+        self, project_name, preheat_policy_name, execution_id, **kwargs
+    ):  # noqa: E501
         """Get a execution detail by id  # noqa: E501
 
         Get a execution detail by id  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_execution_with_http_info(project_name, preheat_policy_name, execution_id, async_req=True)
         >>> result = thread.get()
@@ -513,91 +573,111 @@
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Execution
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'execution_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "execution_id",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_execution" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_execution`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `get_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `get_execution`"
+            )  # noqa: E501
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `get_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `get_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Execution',  # noqa: E501
+            response_type="Execution",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_instance(self, preheat_instance_name, **kwargs):  # noqa: E501
         """Get a P2P provider instance  # noqa: E501
 
         Get a P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -607,16 +687,16 @@
         :param async_req bool
         :param str preheat_instance_name: Instance Name (required)
         :param str x_request_id: An unique ID for the request
         :return: Instance
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_instance_with_http_info(preheat_instance_name, **kwargs)  # noqa: E501
         else:
             (data) = self.get_instance_with_http_info(preheat_instance_name, **kwargs)  # noqa: E501
             return data
 
     def get_instance_with_http_info(self, preheat_instance_name, **kwargs):  # noqa: E501
         """Get a P2P provider instance  # noqa: E501
@@ -631,79 +711,88 @@
         :param str preheat_instance_name: Instance Name (required)
         :param str x_request_id: An unique ID for the request
         :return: Instance
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['preheat_instance_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["preheat_instance_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_instance" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_instance" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'preheat_instance_name' is set
-        if self.api_client.client_side_validation and ('preheat_instance_name' not in params or
-                                                       params['preheat_instance_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_instance_name` when calling `get_instance`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_instance`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_instance_name" not in params or params["preheat_instance_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_instance_name` when calling `get_instance`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_instance`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'preheat_instance_name' in params:
-            path_params['preheat_instance_name'] = params['preheat_instance_name']  # noqa: E501
+        if "preheat_instance_name" in params:
+            path_params["preheat_instance_name"] = params["preheat_instance_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances/{preheat_instance_name}', 'GET',
+            "/p2p/preheat/instances/{preheat_instance_name}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Instance',  # noqa: E501
+            response_type="Instance",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_policy(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
         """Get a preheat policy  # noqa: E501
 
         Get a preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -714,19 +803,23 @@
         :param str project_name: The name of the project (required)
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param str x_request_id: An unique ID for the request
         :return: PreheatPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_policy_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_policy_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_policy_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+            (data) = self.get_policy_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
             return data
 
     def get_policy_with_http_info(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
         """Get a preheat policy  # noqa: E501
 
         Get a preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -739,87 +832,101 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param str x_request_id: An unique ID for the request
         :return: PreheatPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "preheat_policy_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_policy" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_policy`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `get_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `get_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PreheatPolicy',  # noqa: E501
+            response_type="PreheatPolicy",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_preheat_log(self, project_name, preheat_policy_name, execution_id, task_id, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def get_preheat_log(
+        self, project_name, preheat_policy_name, execution_id, task_id, **kwargs
+    ):  # noqa: E501
         """Get the log text stream of the specified task for the given execution  # noqa: E501
 
         Get the log text stream of the specified task for the given execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_preheat_log(project_name, preheat_policy_name, execution_id, task_id, async_req=True)
         >>> result = thread.get()
@@ -830,22 +937,28 @@
         :param int execution_id: Execution ID (required)
         :param int task_id: Task ID (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_preheat_log_with_http_info(project_name, preheat_policy_name, execution_id, task_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_preheat_log_with_http_info(
+                project_name, preheat_policy_name, execution_id, task_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_preheat_log_with_http_info(project_name, preheat_policy_name, execution_id, task_id, **kwargs)  # noqa: E501
+            (data) = self.get_preheat_log_with_http_info(
+                project_name, preheat_policy_name, execution_id, task_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_preheat_log_with_http_info(self, project_name, preheat_policy_name, execution_id, task_id, **kwargs):  # noqa: E501
+    def get_preheat_log_with_http_info(
+        self, project_name, preheat_policy_name, execution_id, task_id, **kwargs
+    ):  # noqa: E501
         """Get the log text stream of the specified task for the given execution  # noqa: E501
 
         Get the log text stream of the specified task for the given execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_preheat_log_with_http_info(project_name, preheat_policy_name, execution_id, task_id, async_req=True)
         >>> result = thread.get()
@@ -857,97 +970,119 @@
         :param int task_id: Task ID (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'execution_id', 'task_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "execution_id",
+            "task_id",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_preheat_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_preheat_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_preheat_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_preheat_log`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `get_preheat_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `get_preheat_log`"
+            )  # noqa: E501
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `get_preheat_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `get_preheat_log`"
+            )  # noqa: E501
         # verify the required parameter 'task_id' is set
-        if self.api_client.client_side_validation and ('task_id' not in params or
-                                                       params['task_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `task_id` when calling `get_preheat_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_preheat_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "task_id" not in params or params["task_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `task_id` when calling `get_preheat_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_preheat_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
-        if 'task_id' in params:
-            path_params['task_id'] = params['task_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
+        if "task_id" in params:
+            path_params["task_id"] = params["task_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks/{task_id}/logs', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks/{task_id}/logs",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_executions(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
         """List executions for the given policy  # noqa: E501
 
         List executions for the given policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -962,22 +1097,28 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Execution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_executions_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_executions_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_executions_with_http_info(project_name, preheat_policy_name, **kwargs)  # noqa: E501
+            (data) = self.list_executions_with_http_info(
+                project_name, preheat_policy_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_executions_with_http_info(self, project_name, preheat_policy_name, **kwargs):  # noqa: E501
+    def list_executions_with_http_info(
+        self, project_name, preheat_policy_name, **kwargs
+    ):  # noqa: E501
         """List executions for the given policy  # noqa: E501
 
         List executions for the given policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_executions_with_http_info(project_name, preheat_policy_name, async_req=True)
         >>> result = thread.get()
@@ -991,95 +1132,119 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Execution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'x_request_id', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "x_request_id",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_executions" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_executions" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_executions`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_executions`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `list_executions`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_executions`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_executions`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `list_executions`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_executions`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_executions`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Execution]',  # noqa: E501
+            response_type="list[Execution]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_instances(self, **kwargs):  # noqa: E501
         """List P2P provider instances  # noqa: E501
 
         List P2P provider instances  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1092,16 +1257,16 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Instance]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_instances_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_instances_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_instances_with_http_info(self, **kwargs):  # noqa: E501
         """List P2P provider instances  # noqa: E501
@@ -1119,83 +1284,93 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Instance]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "page", "page_size", "q", "sort"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_instances" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_instances" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_instances`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_instances`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_instances`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_instances`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances', 'GET',
+            "/p2p/preheat/instances",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Instance]',  # noqa: E501
+            response_type="list[Instance]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_policies(self, project_name, **kwargs):  # noqa: E501
         """List preheat policies  # noqa: E501
 
         List preheat policies  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1209,16 +1384,16 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[PreheatPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_policies_with_http_info(project_name, **kwargs)  # noqa: E501
         else:
             (data) = self.list_policies_with_http_info(project_name, **kwargs)  # noqa: E501
             return data
 
     def list_policies_with_http_info(self, project_name, **kwargs):  # noqa: E501
         """List preheat policies  # noqa: E501
@@ -1237,89 +1412,109 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[PreheatPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "x_request_id",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_policies" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_policies" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_policies`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_policies`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_policies`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_policies`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_policies`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_policies`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies', 'GET',
+            "/projects/{project_name}/preheat/policies",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[PreheatPolicy]',  # noqa: E501
+            response_type="list[PreheatPolicy]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_providers(self, **kwargs):  # noqa: E501
         """List P2P providers  # noqa: E501
 
         List P2P providers  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1328,16 +1523,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[Metadata]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_providers_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_providers_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_providers_with_http_info(self, **kwargs):  # noqa: E501
         """List P2P providers  # noqa: E501
@@ -1351,73 +1546,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[Metadata]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_providers" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_providers" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_providers`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_providers`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/providers', 'GET',
+            "/p2p/preheat/providers",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Metadata]',  # noqa: E501
+            response_type="list[Metadata]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_providers_under_project(self, project_name, **kwargs):  # noqa: E501
         """Get all providers at project level  # noqa: E501
 
         Get all providers at project level  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1427,19 +1628,23 @@
         :param async_req bool
         :param str project_name: The name of the project (required)
         :param str x_request_id: An unique ID for the request
         :return: list[ProviderUnderProject]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_providers_under_project_with_http_info(project_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_providers_under_project_with_http_info(
+                project_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_providers_under_project_with_http_info(project_name, **kwargs)  # noqa: E501
+            (data) = self.list_providers_under_project_with_http_info(
+                project_name, **kwargs
+            )  # noqa: E501
             return data
 
     def list_providers_under_project_with_http_info(self, project_name, **kwargs):  # noqa: E501
         """Get all providers at project level  # noqa: E501
 
         Get all providers at project level  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -1451,79 +1656,89 @@
         :param str project_name: The name of the project (required)
         :param str x_request_id: An unique ID for the request
         :return: list[ProviderUnderProject]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_providers_under_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_providers_under_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_providers_under_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_providers_under_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_providers_under_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/providers', 'GET',
+            "/projects/{project_name}/preheat/providers",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ProviderUnderProject]',  # noqa: E501
+            response_type="list[ProviderUnderProject]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_tasks(self, project_name, preheat_policy_name, execution_id, **kwargs):  # noqa: E501
         """List all the related tasks for the given execution  # noqa: E501
 
         List all the related tasks for the given execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1539,22 +1754,28 @@
         :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Task]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_tasks_with_http_info(project_name, preheat_policy_name, execution_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_tasks_with_http_info(
+                project_name, preheat_policy_name, execution_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_tasks_with_http_info(project_name, preheat_policy_name, execution_id, **kwargs)  # noqa: E501
+            (data) = self.list_tasks_with_http_info(
+                project_name, preheat_policy_name, execution_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_tasks_with_http_info(self, project_name, preheat_policy_name, execution_id, **kwargs):  # noqa: E501
+    def list_tasks_with_http_info(
+        self, project_name, preheat_policy_name, execution_id, **kwargs
+    ):  # noqa: E501
         """List all the related tasks for the given execution  # noqa: E501
 
         List all the related tasks for the given execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_tasks_with_http_info(project_name, preheat_policy_name, execution_id, async_req=True)
         >>> result = thread.get()
@@ -1569,101 +1790,129 @@
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :return: list[Task]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'execution_id', 'x_request_id', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "execution_id",
+            "x_request_id",
+            "page",
+            "page_size",
+            "q",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_tasks" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_tasks" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_tasks`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_tasks`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `list_tasks`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `list_tasks`"
+            )  # noqa: E501
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `list_tasks`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_tasks`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_tasks`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `list_tasks`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_tasks`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_tasks`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks', 'GET',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Task]',  # noqa: E501
+            response_type="list[Task]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def manual_preheat(self, project_name, preheat_policy_name, policy, **kwargs):  # noqa: E501
         """Manual preheat  # noqa: E501
 
         Manual preheat  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1675,22 +1924,28 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.manual_preheat_with_http_info(project_name, preheat_policy_name, policy, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.manual_preheat_with_http_info(
+                project_name, preheat_policy_name, policy, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.manual_preheat_with_http_info(project_name, preheat_policy_name, policy, **kwargs)  # noqa: E501
+            (data) = self.manual_preheat_with_http_info(
+                project_name, preheat_policy_name, policy, **kwargs
+            )  # noqa: E501
             return data
 
-    def manual_preheat_with_http_info(self, project_name, preheat_policy_name, policy, **kwargs):  # noqa: E501
+    def manual_preheat_with_http_info(
+        self, project_name, preheat_policy_name, policy, **kwargs
+    ):  # noqa: E501
         """Manual preheat  # noqa: E501
 
         Manual preheat  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.manual_preheat_with_http_info(project_name, preheat_policy_name, policy, async_req=True)
         >>> result = thread.get()
@@ -1701,91 +1956,106 @@
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "preheat_policy_name", "policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method manual_preheat" % key
+                    "Got an unexpected keyword argument '%s'" " to method manual_preheat" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `manual_preheat`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `manual_preheat`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `manual_preheat`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `manual_preheat`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `manual_preheat`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `manual_preheat`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `manual_preheat`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `manual_preheat`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}', 'POST',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def ping_instances(self, instance, **kwargs):  # noqa: E501
         """Ping status of a instance.  # noqa: E501
 
         This endpoint checks status of a instance, the instance can be given by ID or Endpoint URL (together with credential)   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1795,16 +2065,16 @@
         :param async_req bool
         :param Instance instance: The JSON object of instance. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_instances_with_http_info(instance, **kwargs)  # noqa: E501
         else:
             (data) = self.ping_instances_with_http_info(instance, **kwargs)  # noqa: E501
             return data
 
     def ping_instances_with_http_info(self, instance, **kwargs):  # noqa: E501
         """Ping status of a instance.  # noqa: E501
@@ -1819,81 +2089,92 @@
         :param Instance instance: The JSON object of instance. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['instance', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["instance", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_instances" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_instances" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'instance' is set
-        if self.api_client.client_side_validation and ('instance' not in params or
-                                                       params['instance'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `instance` when calling `ping_instances`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_instances`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "instance" not in params or params["instance"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `instance` when calling `ping_instances`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_instances`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'instance' in params:
-            body_params = params['instance']
+        if "instance" in params:
+            body_params = params["instance"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances/ping', 'POST',
+            "/p2p/preheat/instances/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def stop_execution(self, project_name, preheat_policy_name, execution_id, execution, **kwargs):  # noqa: E501
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
+
+    def stop_execution(
+        self, project_name, preheat_policy_name, execution_id, execution, **kwargs
+    ):  # noqa: E501
         """Stop a execution  # noqa: E501
 
         Stop a execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.stop_execution(project_name, preheat_policy_name, execution_id, execution, async_req=True)
         >>> result = thread.get()
@@ -1904,22 +2185,28 @@
         :param int execution_id: Execution ID (required)
         :param Execution execution: The data of execution (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.stop_execution_with_http_info(project_name, preheat_policy_name, execution_id, execution, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.stop_execution_with_http_info(
+                project_name, preheat_policy_name, execution_id, execution, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.stop_execution_with_http_info(project_name, preheat_policy_name, execution_id, execution, **kwargs)  # noqa: E501
+            (data) = self.stop_execution_with_http_info(
+                project_name, preheat_policy_name, execution_id, execution, **kwargs
+            )  # noqa: E501
             return data
 
-    def stop_execution_with_http_info(self, project_name, preheat_policy_name, execution_id, execution, **kwargs):  # noqa: E501
+    def stop_execution_with_http_info(
+        self, project_name, preheat_policy_name, execution_id, execution, **kwargs
+    ):  # noqa: E501
         """Stop a execution  # noqa: E501
 
         Stop a execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.stop_execution_with_http_info(project_name, preheat_policy_name, execution_id, execution, async_req=True)
         >>> result = thread.get()
@@ -1931,97 +2218,121 @@
         :param Execution execution: The data of execution (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'execution_id', 'execution', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "preheat_policy_name",
+            "execution_id",
+            "execution",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_execution" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `stop_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `stop_execution`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `stop_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `stop_execution`"
+            )  # noqa: E501
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `stop_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `stop_execution`"
+            )  # noqa: E501
         # verify the required parameter 'execution' is set
-        if self.api_client.client_side_validation and ('execution' not in params or
-                                                       params['execution'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution` when calling `stop_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution" not in params or params["execution"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution` when calling `stop_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'execution' in params:
-            body_params = params['execution']
+        if "execution" in params:
+            body_params = params["execution"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}', 'PATCH',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}",
+            "PATCH",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_instance(self, preheat_instance_name, instance, **kwargs):  # noqa: E501
         """Update the specified P2P provider instance  # noqa: E501
 
         Update the specified P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -2032,22 +2343,28 @@
         :param str preheat_instance_name: Instance Name (required)
         :param Instance instance: The instance to update (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_instance_with_http_info(preheat_instance_name, instance, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_instance_with_http_info(
+                preheat_instance_name, instance, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_instance_with_http_info(preheat_instance_name, instance, **kwargs)  # noqa: E501
+            (data) = self.update_instance_with_http_info(
+                preheat_instance_name, instance, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_instance_with_http_info(self, preheat_instance_name, instance, **kwargs):  # noqa: E501
+    def update_instance_with_http_info(
+        self, preheat_instance_name, instance, **kwargs
+    ):  # noqa: E501
         """Update the specified P2P provider instance  # noqa: E501
 
         Update the specified P2P provider instance  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_instance_with_http_info(preheat_instance_name, instance, async_req=True)
         >>> result = thread.get()
@@ -2057,85 +2374,97 @@
         :param Instance instance: The instance to update (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['preheat_instance_name', 'instance', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["preheat_instance_name", "instance", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_instance" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_instance" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'preheat_instance_name' is set
-        if self.api_client.client_side_validation and ('preheat_instance_name' not in params or
-                                                       params['preheat_instance_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_instance_name` when calling `update_instance`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_instance_name" not in params or params["preheat_instance_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_instance_name` when calling `update_instance`"
+            )  # noqa: E501
         # verify the required parameter 'instance' is set
-        if self.api_client.client_side_validation and ('instance' not in params or
-                                                       params['instance'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `instance` when calling `update_instance`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_instance`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "instance" not in params or params["instance"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `instance` when calling `update_instance`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_instance`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'preheat_instance_name' in params:
-            path_params['preheat_instance_name'] = params['preheat_instance_name']  # noqa: E501
+        if "preheat_instance_name" in params:
+            path_params["preheat_instance_name"] = params["preheat_instance_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'instance' in params:
-            body_params = params['instance']
+        if "instance" in params:
+            body_params = params["instance"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/p2p/preheat/instances/{preheat_instance_name}', 'PUT',
+            "/p2p/preheat/instances/{preheat_instance_name}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_policy(self, project_name, preheat_policy_name, policy, **kwargs):  # noqa: E501
         """Update preheat policy  # noqa: E501
 
         Update preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -2147,22 +2476,28 @@
         :param str preheat_policy_name: Preheat Policy Name (required)
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_policy_with_http_info(project_name, preheat_policy_name, policy, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_policy_with_http_info(
+                project_name, preheat_policy_name, policy, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_policy_with_http_info(project_name, preheat_policy_name, policy, **kwargs)  # noqa: E501
+            (data) = self.update_policy_with_http_info(
+                project_name, preheat_policy_name, policy, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_policy_with_http_info(self, project_name, preheat_policy_name, policy, **kwargs):  # noqa: E501
+    def update_policy_with_http_info(
+        self, project_name, preheat_policy_name, policy, **kwargs
+    ):  # noqa: E501
         """Update preheat policy  # noqa: E501
 
         Update preheat policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_policy_with_http_info(project_name, preheat_policy_name, policy, async_req=True)
         >>> result = thread.get()
@@ -2173,84 +2508,99 @@
         :param PreheatPolicy policy: The policy schema info (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'preheat_policy_name', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "preheat_policy_name", "policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_policy" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `update_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `update_policy`"
+            )  # noqa: E501
         # verify the required parameter 'preheat_policy_name' is set
-        if self.api_client.client_side_validation and ('preheat_policy_name' not in params or
-                                                       params['preheat_policy_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `preheat_policy_name` when calling `update_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "preheat_policy_name" not in params or params["preheat_policy_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `preheat_policy_name` when calling `update_policy`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `update_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `update_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'preheat_policy_name' in params:
-            path_params['preheat_policy_name'] = params['preheat_policy_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "preheat_policy_name" in params:
+            path_params["preheat_policy_name"] = params["preheat_policy_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/preheat/policies/{preheat_policy_name}', 'PUT',
+            "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/project_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/project_api.py`

 * *Files 17% similar despite different names*

```diff
@@ -46,16 +46,16 @@
         :param ProjectReq project: New created project. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_resource_name_in_location: The flag to indicate whether to return the name of the resource in Location. When X-Resource-Name-In-Location is true, the Location will return the name of the resource.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_project_with_http_info(project, **kwargs)  # noqa: E501
         else:
             (data) = self.create_project_with_http_info(project, **kwargs)  # noqa: E501
             return data
 
     def create_project_with_http_info(self, project, **kwargs):  # noqa: E501
         """Create a new project.  # noqa: E501
@@ -71,81 +71,92 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_resource_name_in_location: The flag to indicate whether to return the name of the resource in Location. When X-Resource-Name-In-Location is true, the Location will return the name of the resource.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project', 'x_request_id', 'x_resource_name_in_location']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project", "x_request_id", "x_resource_name_in_location"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project' is set
-        if self.api_client.client_side_validation and ('project' not in params or
-                                                       params['project'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project` when calling `create_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project" not in params or params["project"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project` when calling `create_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_resource_name_in_location' in params:
-            header_params['X-Resource-Name-In-Location'] = params['x_resource_name_in_location']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_resource_name_in_location" in params:
+            header_params["X-Resource-Name-In-Location"] = params[
+                "x_resource_name_in_location"
+            ]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'project' in params:
-            body_params = params['project']
+        if "project" in params:
+            body_params = params["project"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects', 'POST',
+            "/projects",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_project(self, project_name_or_id, **kwargs):  # noqa: E501
         """Delete project by projectID  # noqa: E501
 
         This endpoint is aimed to delete project by project ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -156,16 +167,16 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
     def delete_project_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Delete project by projectID  # noqa: E501
@@ -181,81 +192,90 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}', 'DELETE',
+            "/projects/{project_name_or_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_logs(self, project_name, **kwargs):  # noqa: E501
         """Get recent logs of the projects  # noqa: E501
 
         Get recent logs of the projects  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -269,16 +289,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[AuditLog]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_logs_with_http_info(project_name, **kwargs)  # noqa: E501
         else:
             (data) = self.get_logs_with_http_info(project_name, **kwargs)  # noqa: E501
             return data
 
     def get_logs_with_http_info(self, project_name, **kwargs):  # noqa: E501
         """Get recent logs of the projects  # noqa: E501
@@ -297,89 +317,109 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[AuditLog]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_logs" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_logs" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_logs`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_logs`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `get_logs`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_logs`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_logs`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `get_logs`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/logs', 'GET',
+            "/projects/{project_name}/logs",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[AuditLog]',  # noqa: E501
+            response_type="list[AuditLog]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project(self, project_name_or_id, **kwargs):  # noqa: E501
         """Return specific project detail information  # noqa: E501
 
         This endpoint returns specific project information by project ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -390,16 +430,16 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: Project
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
     def get_project_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Return specific project detail information  # noqa: E501
@@ -415,81 +455,90 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: Project
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}', 'GET',
+            "/projects/{project_name_or_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Project',  # noqa: E501
+            response_type="Project",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project_deletable(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get the deletable status of the project  # noqa: E501
 
         Get the deletable status of the project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -500,19 +549,23 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectDeletable
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_project_deletable_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_project_deletable_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_project_deletable_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.get_project_deletable_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_project_deletable_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get the deletable status of the project  # noqa: E501
 
         Get the deletable status of the project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -525,81 +578,91 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectDeletable
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_project_deletable" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project_deletable`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project_deletable`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project_deletable`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project_deletable`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/_deletable', 'GET',
+            "/projects/{project_name_or_id}/_deletable",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectDeletable',  # noqa: E501
+            response_type="ProjectDeletable",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project_summary(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get summary of the project.  # noqa: E501
 
         Get summary of the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -610,19 +673,23 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectSummary
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_project_summary_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_project_summary_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_project_summary_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.get_project_summary_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_project_summary_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get summary of the project.  # noqa: E501
 
         Get summary of the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -635,81 +702,90 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ProjectSummary
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_project_summary" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_project_summary" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project_summary`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project_summary`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project_summary`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project_summary`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/summary', 'GET',
+            "/projects/{project_name_or_id}/summary",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectSummary',  # noqa: E501
+            response_type="ProjectSummary",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scanner_of_project(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get project level scanner  # noqa: E501
 
         Get the scanner registration of the specified project. If no scanner registration is configured for the specified project, the system default scanner registration will be returned.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -720,19 +796,23 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_scanner_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_scanner_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_scanner_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.get_scanner_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_scanner_of_project_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get project level scanner  # noqa: E501
 
         Get the scanner registration of the specified project. If no scanner registration is configured for the specified project, the system default scanner registration will be returned.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -745,81 +825,91 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scanner_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_scanner_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scanner_of_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_scanner_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scanner_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/scanner', 'GET',
+            "/projects/{project_name_or_id}/scanner",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScannerRegistration',  # noqa: E501
+            response_type="ScannerRegistration",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def head_project(self, project_name, **kwargs):  # noqa: E501
         """Check if the project name user provided already exists.  # noqa: E501
 
         This endpoint is used to check if the project name provided already exist.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -829,16 +919,16 @@
         :param async_req bool
         :param str project_name: Project name for checking exists. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.head_project_with_http_info(project_name, **kwargs)  # noqa: E501
         else:
             (data) = self.head_project_with_http_info(project_name, **kwargs)  # noqa: E501
             return data
 
     def head_project_with_http_info(self, project_name, **kwargs):  # noqa: E501
         """Check if the project name user provided already exists.  # noqa: E501
@@ -853,79 +943,88 @@
         :param str project_name: Project name for checking exists. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method head_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method head_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `head_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `head_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `head_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `head_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'project_name' in params:
-            query_params.append(('project_name', params['project_name']))  # noqa: E501
+        if "project_name" in params:
+            query_params.append(("project_name", params["project_name"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects', 'HEAD',
+            "/projects",
+            "HEAD",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_projects(self, **kwargs):  # noqa: E501
         """List projects  # noqa: E501
 
         This endpoint returns projects created by Harbor.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -942,16 +1041,16 @@
         :param bool public: The project is public or private.
         :param str owner: The name of project owner.
         :param bool with_detail: Bool value indicating whether return detailed information of the project
         :return: list[Project]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_projects_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_projects_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_projects_with_http_info(self, **kwargs):  # noqa: E501
         """List projects  # noqa: E501
@@ -973,91 +1072,111 @@
         :param str owner: The name of project owner.
         :param bool with_detail: Bool value indicating whether return detailed information of the project
         :return: list[Project]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'page', 'page_size', 'sort', 'name', 'public', 'owner', 'with_detail']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "q",
+            "page",
+            "page_size",
+            "sort",
+            "name",
+            "public",
+            "owner",
+            "with_detail",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_projects" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_projects" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_projects`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_projects`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_projects`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_projects`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'name' in params:
-            query_params.append(('name', params['name']))  # noqa: E501
-        if 'public' in params:
-            query_params.append(('public', params['public']))  # noqa: E501
-        if 'owner' in params:
-            query_params.append(('owner', params['owner']))  # noqa: E501
-        if 'with_detail' in params:
-            query_params.append(('with_detail', params['with_detail']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "name" in params:
+            query_params.append(("name", params["name"]))  # noqa: E501
+        if "public" in params:
+            query_params.append(("public", params["public"]))  # noqa: E501
+        if "owner" in params:
+            query_params.append(("owner", params["owner"]))  # noqa: E501
+        if "with_detail" in params:
+            query_params.append(("with_detail", params["with_detail"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects', 'GET',
+            "/projects",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Project]',  # noqa: E501
+            response_type="list[Project]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_scanner_candidates_of_project(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get scanner registration candidates for configurating project level scanner  # noqa: E501
 
         Retrieve the system configured scanner registrations as candidates of setting project level scanner.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1072,22 +1191,28 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScannerRegistration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_scanner_candidates_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_scanner_candidates_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_scanner_candidates_of_project_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.list_scanner_candidates_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_scanner_candidates_of_project_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
+    def list_scanner_candidates_of_project_with_http_info(
+        self, project_name_or_id, **kwargs
+    ):  # noqa: E501
         """Get scanner registration candidates for configurating project level scanner  # noqa: E501
 
         Retrieve the system configured scanner registrations as candidates of setting project level scanner.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_scanner_candidates_of_project_with_http_info(project_name_or_id, async_req=True)
         >>> result = thread.get()
@@ -1101,91 +1226,113 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScannerRegistration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_scanner_candidates_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_scanner_candidates_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_scanner_candidates_of_project`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_scanner_candidates_of_project`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_scanner_candidates_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_scanner_candidates_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_scanner_candidates_of_project`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/scanner/candidates', 'GET',
+            "/projects/{project_name_or_id}/scanner/candidates",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ScannerRegistration]',  # noqa: E501
+            response_type="list[ScannerRegistration]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def set_scanner_of_project(self, project_name_or_id, payload, **kwargs):  # noqa: E501
         """Configure scanner for the specified project  # noqa: E501
 
         Set one of the system configured scanner registration as the indepndent scanner of the specified project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1197,22 +1344,28 @@
         :param ProjectScanner payload: (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.set_scanner_of_project_with_http_info(project_name_or_id, payload, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.set_scanner_of_project_with_http_info(
+                project_name_or_id, payload, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.set_scanner_of_project_with_http_info(project_name_or_id, payload, **kwargs)  # noqa: E501
+            (data) = self.set_scanner_of_project_with_http_info(
+                project_name_or_id, payload, **kwargs
+            )  # noqa: E501
             return data
 
-    def set_scanner_of_project_with_http_info(self, project_name_or_id, payload, **kwargs):  # noqa: E501
+    def set_scanner_of_project_with_http_info(
+        self, project_name_or_id, payload, **kwargs
+    ):  # noqa: E501
         """Configure scanner for the specified project  # noqa: E501
 
         Set one of the system configured scanner registration as the indepndent scanner of the specified project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.set_scanner_of_project_with_http_info(project_name_or_id, payload, async_req=True)
         >>> result = thread.get()
@@ -1223,87 +1376,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'payload', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "payload",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method set_scanner_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `set_scanner_of_project`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `set_scanner_of_project`"
+            )  # noqa: E501
         # verify the required parameter 'payload' is set
-        if self.api_client.client_side_validation and ('payload' not in params or
-                                                       params['payload'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `payload` when calling `set_scanner_of_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `set_scanner_of_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "payload" not in params or params["payload"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `payload` when calling `set_scanner_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `set_scanner_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'payload' in params:
-            body_params = params['payload']
+        if "payload" in params:
+            body_params = params["payload"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/scanner', 'PUT',
+            "/projects/{project_name_or_id}/scanner",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_project(self, project_name_or_id, project, **kwargs):  # noqa: E501
         """Update properties for a selected project.  # noqa: E501
 
         This endpoint is aimed to update the properties of a project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1315,19 +1486,23 @@
         :param ProjectReq project: Updates of project. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_project_with_http_info(project_name_or_id, project, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_project_with_http_info(
+                project_name_or_id, project, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_project_with_http_info(project_name_or_id, project, **kwargs)  # noqa: E501
+            (data) = self.update_project_with_http_info(
+                project_name_or_id, project, **kwargs
+            )  # noqa: E501
             return data
 
     def update_project_with_http_info(self, project_name_or_id, project, **kwargs):  # noqa: E501
         """Update properties for a selected project.  # noqa: E501
 
         This endpoint is aimed to update the properties of a project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -1341,80 +1516,97 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'project', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "project",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_project" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_project`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_project`"
+            )  # noqa: E501
         # verify the required parameter 'project' is set
-        if self.api_client.client_side_validation and ('project' not in params or
-                                                       params['project'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project` when calling `update_project`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_project`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project" not in params or params["project"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project` when calling `update_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'project' in params:
-            body_params = params['project']
+        if "project" in params:
+            body_params = params["project"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}', 'PUT',
+            "/projects/{project_name_or_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/project_metadata_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/project_metadata_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -47,19 +47,23 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param object metadata:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.add_project_metadatas_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.add_project_metadatas_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.add_project_metadatas_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.add_project_metadatas_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def add_project_metadatas_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Add metadata for the specific project  # noqa: E501
 
         Add metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -73,83 +77,98 @@
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param object metadata:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'metadata']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "metadata",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_project_metadatas" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `add_project_metadatas`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `add_project_metadatas`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `add_project_metadatas`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `add_project_metadatas`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'metadata' in params:
-            body_params = params['metadata']
+        if "metadata" in params:
+            body_params = params["metadata"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/', 'POST',
+            "/projects/{project_name_or_id}/metadatas/",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_project_metadata(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
         """Delete the specific metadata for the specific project  # noqa: E501
 
         Delete the specific metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -161,22 +180,28 @@
         :param str meta_name: The name of metadata. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+            (data) = self.delete_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_project_metadata_with_http_info(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
+    def delete_project_metadata_with_http_info(
+        self, project_name_or_id, meta_name, **kwargs
+    ):  # noqa: E501
         """Delete the specific metadata for the specific project  # noqa: E501
 
         Delete the specific metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_project_metadata_with_http_info(project_name_or_id, meta_name, async_req=True)
         >>> result = thread.get()
@@ -187,87 +212,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'meta_name', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "meta_name",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_project_metadata" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_project_metadata`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_project_metadata`"
+            )  # noqa: E501
         # verify the required parameter 'meta_name' is set
-        if self.api_client.client_side_validation and ('meta_name' not in params or
-                                                       params['meta_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `meta_name` when calling `delete_project_metadata`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_project_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "meta_name" not in params or params["meta_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `meta_name` when calling `delete_project_metadata`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_project_metadata`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'meta_name' in params:
-            path_params['meta_name'] = params['meta_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "meta_name" in params:
+            path_params["meta_name"] = params["meta_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/{meta_name}', 'DELETE',
+            "/projects/{project_name_or_id}/metadatas/{meta_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_project_metadata(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
         """Get the specific metadata of the specific project  # noqa: E501
 
         Get the specific metadata of the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -279,22 +322,28 @@
         :param str meta_name: The name of metadata. (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: dict(str, str)
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+            (data) = self.get_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_project_metadata_with_http_info(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
+    def get_project_metadata_with_http_info(
+        self, project_name_or_id, meta_name, **kwargs
+    ):  # noqa: E501
         """Get the specific metadata of the specific project  # noqa: E501
 
         Get the specific metadata of the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_metadata_with_http_info(project_name_or_id, meta_name, async_req=True)
         >>> result = thread.get()
@@ -305,87 +354,105 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: dict(str, str)
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'meta_name', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "meta_name",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_project_metadata" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_project_metadata`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_project_metadata`"
+            )  # noqa: E501
         # verify the required parameter 'meta_name' is set
-        if self.api_client.client_side_validation and ('meta_name' not in params or
-                                                       params['meta_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `meta_name` when calling `get_project_metadata`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_project_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "meta_name" not in params or params["meta_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `meta_name` when calling `get_project_metadata`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_project_metadata`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'meta_name' in params:
-            path_params['meta_name'] = params['meta_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "meta_name" in params:
+            path_params["meta_name"] = params["meta_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/{meta_name}', 'GET',
+            "/projects/{project_name_or_id}/metadatas/{meta_name}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='dict(str, str)',  # noqa: E501
+            response_type="dict(str, str)",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_project_metadatas(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get the metadata of the specific project  # noqa: E501
 
         Get the metadata of the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -396,19 +463,23 @@
         :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: dict(str, str)
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_project_metadatas_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_project_metadatas_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_project_metadatas_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.list_project_metadatas_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
     def list_project_metadatas_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
         """Get the metadata of the specific project  # noqa: E501
 
         Get the metadata of the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -421,81 +492,91 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: dict(str, str)
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_project_metadatas" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_project_metadatas`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_project_metadatas`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_project_metadatas`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_project_metadatas`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/', 'GET',
+            "/projects/{project_name_or_id}/metadatas/",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='dict(str, str)',  # noqa: E501
+            response_type="dict(str, str)",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_project_metadata(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
         """Update the specific metadata for the specific project  # noqa: E501
 
         Update the specific metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -508,22 +589,28 @@
         :param str x_request_id: An unique ID for the request
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param object metadata:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_project_metadata_with_http_info(project_name_or_id, meta_name, **kwargs)  # noqa: E501
+            (data) = self.update_project_metadata_with_http_info(
+                project_name_or_id, meta_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_project_metadata_with_http_info(self, project_name_or_id, meta_name, **kwargs):  # noqa: E501
+    def update_project_metadata_with_http_info(
+        self, project_name_or_id, meta_name, **kwargs
+    ):  # noqa: E501
         """Update the specific metadata for the specific project  # noqa: E501
 
         Update the specific metadata for the specific project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_project_metadata_with_http_info(project_name_or_id, meta_name, async_req=True)
         >>> result = thread.get()
@@ -535,82 +622,101 @@
         :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param object metadata:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'meta_name', 'x_request_id', 'x_is_resource_name', 'metadata']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "meta_name",
+            "x_request_id",
+            "x_is_resource_name",
+            "metadata",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_project_metadata" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_project_metadata`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_project_metadata`"
+            )  # noqa: E501
         # verify the required parameter 'meta_name' is set
-        if self.api_client.client_side_validation and ('meta_name' not in params or
-                                                       params['meta_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `meta_name` when calling `update_project_metadata`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_project_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "meta_name" not in params or params["meta_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `meta_name` when calling `update_project_metadata`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_project_metadata`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'meta_name' in params:
-            path_params['meta_name'] = params['meta_name']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "meta_name" in params:
+            path_params["meta_name"] = params["meta_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'metadata' in params:
-            body_params = params['metadata']
+        if "metadata" in params:
+            body_params = params["metadata"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/metadatas/{meta_name}', 'PUT',
+            "/projects/{project_name_or_id}/metadatas/{meta_name}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/purge_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/purge_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Schedule schedule: The purge job's schedule, it is a json object. ｜ The sample format is ｜ {\"parameters\":{\"audit_retention_hour\":168,\"dry_run\":true, \"include_operations\":\"create,delete,pull\"},\"schedule\":{\"type\":\"Hourly\",\"cron\":\"0 0 * * * *\"}} ｜ the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.  (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_purge_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.create_purge_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def create_purge_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Create a purge job schedule.  # noqa: E501
@@ -69,79 +69,89 @@
         :param Schedule schedule: The purge job's schedule, it is a json object. ｜ The sample format is ｜ {\"parameters\":{\"audit_retention_hour\":168,\"dry_run\":true, \"include_operations\":\"create,delete,pull\"},\"schedule\":{\"type\":\"Hourly\",\"cron\":\"0 0 * * * *\"}} ｜ the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.  (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_purge_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `create_purge_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_purge_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `create_purge_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_purge_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/schedule', 'POST',
+            "/system/purgeaudit/schedule",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_purge_history(self, **kwargs):  # noqa: E501
         """Get purge job results.  # noqa: E501
 
         get purge job execution history.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -154,16 +164,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ExecHistory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_purge_history_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_purge_history_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_purge_history_with_http_info(self, **kwargs):  # noqa: E501
         """Get purge job results.  # noqa: E501
@@ -181,83 +191,93 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ExecHistory]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_purge_history" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_purge_history" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_purge_history`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `get_purge_history`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_purge_history`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `get_purge_history`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit', 'GET',
+            "/system/purgeaudit",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ExecHistory]',  # noqa: E501
+            response_type="list[ExecHistory]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_purge_job(self, purge_id, **kwargs):  # noqa: E501
         """Get purge job status.  # noqa: E501
 
         This endpoint let user get purge job status filtered by specific ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -267,16 +287,16 @@
         :param async_req bool
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: ExecHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_purge_job_with_http_info(purge_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_purge_job_with_http_info(purge_id, **kwargs)  # noqa: E501
             return data
 
     def get_purge_job_with_http_info(self, purge_id, **kwargs):  # noqa: E501
         """Get purge job status.  # noqa: E501
@@ -291,79 +311,88 @@
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: ExecHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['purge_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["purge_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_purge_job" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_purge_job" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'purge_id' is set
-        if self.api_client.client_side_validation and ('purge_id' not in params or
-                                                       params['purge_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `purge_id` when calling `get_purge_job`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_purge_job`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "purge_id" not in params or params["purge_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `purge_id` when calling `get_purge_job`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_purge_job`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'purge_id' in params:
-            path_params['purge_id'] = params['purge_id']  # noqa: E501
+        if "purge_id" in params:
+            path_params["purge_id"] = params["purge_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/{purge_id}', 'GET',
+            "/system/purgeaudit/{purge_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ExecHistory',  # noqa: E501
+            response_type="ExecHistory",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_purge_job_log(self, purge_id, **kwargs):  # noqa: E501
         """Get purge job log.  # noqa: E501
 
         This endpoint let user get purge job logs filtered by specific ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -373,16 +402,16 @@
         :param async_req bool
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_purge_job_log_with_http_info(purge_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_purge_job_log_with_http_info(purge_id, **kwargs)  # noqa: E501
             return data
 
     def get_purge_job_log_with_http_info(self, purge_id, **kwargs):  # noqa: E501
         """Get purge job log.  # noqa: E501
@@ -397,79 +426,86 @@
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['purge_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["purge_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_purge_job_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_purge_job_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'purge_id' is set
-        if self.api_client.client_side_validation and ('purge_id' not in params or
-                                                       params['purge_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `purge_id` when calling `get_purge_job_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_purge_job_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "purge_id" not in params or params["purge_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `purge_id` when calling `get_purge_job_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_purge_job_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'purge_id' in params:
-            path_params['purge_id'] = params['purge_id']  # noqa: E501
+        if "purge_id" in params:
+            path_params["purge_id"] = params["purge_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/{purge_id}/log', 'GET',
+            "/system/purgeaudit/{purge_id}/log",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_purge_schedule(self, **kwargs):  # noqa: E501
         """Get purge's schedule.  # noqa: E501
 
         This endpoint is for get schedule of purge job.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -478,16 +514,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ExecHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_purge_schedule_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_purge_schedule_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_purge_schedule_with_http_info(self, **kwargs):  # noqa: E501
         """Get purge's schedule.  # noqa: E501
@@ -501,73 +537,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ExecHistory
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_purge_schedule" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_purge_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_purge_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_purge_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/schedule', 'GET',
+            "/system/purgeaudit/schedule",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ExecHistory',  # noqa: E501
+            response_type="ExecHistory",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_purge(self, purge_id, **kwargs):  # noqa: E501
         """Stop the specific purge audit log execution  # noqa: E501
 
         Stop the purge audit log execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -577,16 +619,16 @@
         :param async_req bool
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_purge_with_http_info(purge_id, **kwargs)  # noqa: E501
         else:
             (data) = self.stop_purge_with_http_info(purge_id, **kwargs)  # noqa: E501
             return data
 
     def stop_purge_with_http_info(self, purge_id, **kwargs):  # noqa: E501
         """Stop the specific purge audit log execution  # noqa: E501
@@ -601,79 +643,88 @@
         :param int purge_id: The ID of the purge log (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['purge_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["purge_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_purge" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_purge" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'purge_id' is set
-        if self.api_client.client_side_validation and ('purge_id' not in params or
-                                                       params['purge_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `purge_id` when calling `stop_purge`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_purge`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "purge_id" not in params or params["purge_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `purge_id` when calling `stop_purge`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_purge`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'purge_id' in params:
-            path_params['purge_id'] = params['purge_id']  # noqa: E501
+        if "purge_id" in params:
+            path_params["purge_id"] = params["purge_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/{purge_id}', 'PUT',
+            "/system/purgeaudit/{purge_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_purge_schedule(self, schedule, **kwargs):  # noqa: E501
         """Update purge job's schedule.  # noqa: E501
 
         This endpoint is for update purge job schedule.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -683,16 +734,16 @@
         :param async_req bool
         :param Schedule schedule: The purge job's schedule, it is a json object. ｜ The sample format is ｜ {\"parameters\":{\"audit_retention_hour\":168,\"dry_run\":true, \"include_operations\":\"create,delete,pull\"},\"schedule\":{\"type\":\"Hourly\",\"cron\":\"0 0 * * * *\"}} ｜ the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.  (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_purge_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.update_purge_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def update_purge_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Update purge job's schedule.  # noqa: E501
@@ -707,72 +758,82 @@
         :param Schedule schedule: The purge job's schedule, it is a json object. ｜ The sample format is ｜ {\"parameters\":{\"audit_retention_hour\":168,\"dry_run\":true, \"include_operations\":\"create,delete,pull\"},\"schedule\":{\"type\":\"Hourly\",\"cron\":\"0 0 * * * *\"}} ｜ the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.  (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_purge_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `update_purge_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_purge_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `update_purge_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_purge_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/purgeaudit/schedule', 'PUT',
+            "/system/purgeaudit/schedule",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/quota_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/quota_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param int id: Quota ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Quota
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_quota_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_quota_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_quota_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the specified quota  # noqa: E501
@@ -69,79 +69,88 @@
         :param int id: Quota ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Quota
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_quota" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_quota" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_quota`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_quota`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_quota`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_quota`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/quotas/{id}', 'GET',
+            "/quotas/{id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Quota',  # noqa: E501
+            response_type="Quota",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_quotas(self, **kwargs):  # noqa: E501
         """List quotas  # noqa: E501
 
         List quotas  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -150,21 +159,21 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
         :param str reference: The reference type of quota.
         :param str reference_id: The reference id of quota.
-        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota. 
+        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota.
         :return: list[Quota]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_quotas_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_quotas_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_quotas_with_http_info(self, **kwargs):  # noqa: E501
         """List quotas  # noqa: E501
@@ -177,91 +186,108 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
         :param str reference: The reference type of quota.
         :param str reference_id: The reference id of quota.
-        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota. 
+        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota.
         :return: list[Quota]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'page', 'page_size', 'reference', 'reference_id', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "page",
+            "page_size",
+            "reference",
+            "reference_id",
+            "sort",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_quotas" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_quotas" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_quotas`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_quotas`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_quotas`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_quotas`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'reference' in params:
-            query_params.append(('reference', params['reference']))  # noqa: E501
-        if 'reference_id' in params:
-            query_params.append(('reference_id', params['reference_id']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "reference" in params:
+            query_params.append(("reference", params["reference"]))  # noqa: E501
+        if "reference_id" in params:
+            query_params.append(("reference_id", params["reference_id"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/quotas', 'GET',
+            "/quotas",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Quota]',  # noqa: E501
+            response_type="list[Quota]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_quota(self, id, hard, **kwargs):  # noqa: E501
         """Update the specified quota  # noqa: E501
 
         Update hard limits of the specified quota  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -272,16 +298,16 @@
         :param int id: Quota ID (required)
         :param QuotaUpdateReq hard: The new hard limits for the quota (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_quota_with_http_info(id, hard, **kwargs)  # noqa: E501
         else:
             (data) = self.update_quota_with_http_info(id, hard, **kwargs)  # noqa: E501
             return data
 
     def update_quota_with_http_info(self, id, hard, **kwargs):  # noqa: E501
         """Update the specified quota  # noqa: E501
@@ -297,78 +323,90 @@
         :param QuotaUpdateReq hard: The new hard limits for the quota (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'hard', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "hard", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_quota" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_quota" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `update_quota`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `update_quota`"
+            )  # noqa: E501
         # verify the required parameter 'hard' is set
-        if self.api_client.client_side_validation and ('hard' not in params or
-                                                       params['hard'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `hard` when calling `update_quota`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_quota`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "hard" not in params or params["hard"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `hard` when calling `update_quota`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_quota`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'hard' in params:
-            body_params = params['hard']
+        if "hard" in params:
+            body_params = params["hard"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/quotas/{id}', 'PUT',
+            "/quotas/{id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/registry_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/registry_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Registry registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_registry_with_http_info(registry, **kwargs)  # noqa: E501
         else:
             (data) = self.create_registry_with_http_info(registry, **kwargs)  # noqa: E501
             return data
 
     def create_registry_with_http_info(self, registry, **kwargs):  # noqa: E501
         """Create a registry  # noqa: E501
@@ -69,79 +69,88 @@
         :param Registry registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registry', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registry", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registry' is set
-        if self.api_client.client_side_validation and ('registry' not in params or
-                                                       params['registry'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registry` when calling `create_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registry" not in params or params["registry"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registry` when calling `create_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registry' in params:
-            body_params = params['registry']
+        if "registry" in params:
+            body_params = params["registry"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries', 'POST',
+            "/registries",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_registry(self, id, **kwargs):  # noqa: E501
         """Delete the specific registry  # noqa: E501
 
         Delete the specific registry  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_registry_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_registry_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def delete_registry_with_http_info(self, id, **kwargs):  # noqa: E501
         """Delete the specific registry  # noqa: E501
@@ -175,79 +184,88 @@
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `delete_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `delete_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/{id}', 'DELETE',
+            "/registries/{id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_registry(self, id, **kwargs):  # noqa: E501
         """Get the specific registry  # noqa: E501
 
         Get the specific registry  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +275,16 @@
         :param async_req bool
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Registry
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_registry_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_registry_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_registry_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the specific registry  # noqa: E501
@@ -281,79 +299,88 @@
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Registry
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/{id}', 'GET',
+            "/registries/{id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Registry',  # noqa: E501
+            response_type="Registry",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_registry_info(self, id, **kwargs):  # noqa: E501
         """Get the registry info  # noqa: E501
 
         Get the registry info  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -363,16 +390,16 @@
         :param async_req bool
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: RegistryInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_registry_info_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_registry_info_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_registry_info_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the registry info  # noqa: E501
@@ -387,79 +414,88 @@
         :param int id: Registry ID (required)
         :param str x_request_id: An unique ID for the request
         :return: RegistryInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_registry_info" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_registry_info" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_registry_info`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_registry_info`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_registry_info`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_registry_info`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/{id}/info', 'GET',
+            "/registries/{id}/info",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RegistryInfo',  # noqa: E501
+            response_type="RegistryInfo",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_registries(self, **kwargs):  # noqa: E501
         """List the registries  # noqa: E501
 
         List the registries  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -473,16 +509,16 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :param str name: Deprecated, use `q` instead.
         :return: list[Registry]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_registries_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_registries_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_registries_with_http_info(self, **kwargs):  # noqa: E501
         """List the registries  # noqa: E501
@@ -501,85 +537,95 @@
         :param int page_size: The size of per page
         :param str name: Deprecated, use `q` instead.
         :return: list[Registry]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size', 'name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size", "name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_registries" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_registries" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_registries`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_registries`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_registries`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_registries`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'name' in params:
-            query_params.append(('name', params['name']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "name" in params:
+            query_params.append(("name", params["name"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries', 'GET',
+            "/registries",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Registry]',  # noqa: E501
+            response_type="list[Registry]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_registry_provider_infos(self, **kwargs):  # noqa: E501
         """List all registered registry provider information  # noqa: E501
 
         List all registered registry provider information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -588,16 +634,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: dict(str, RegistryProviderInfo)
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_registry_provider_infos_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_registry_provider_infos_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_registry_provider_infos_with_http_info(self, **kwargs):  # noqa: E501
         """List all registered registry provider information  # noqa: E501
@@ -611,73 +657,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: dict(str, RegistryProviderInfo)
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_registry_provider_infos" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_registry_provider_infos`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_registry_provider_infos`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/adapterinfos', 'GET',
+            "/replication/adapterinfos",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='dict(str, RegistryProviderInfo)',  # noqa: E501
+            response_type="dict(str, RegistryProviderInfo)",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_registry_provider_types(self, **kwargs):  # noqa: E501
         """List registry adapters  # noqa: E501
 
         List registry adapters  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -686,16 +739,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[str]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_registry_provider_types_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_registry_provider_types_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_registry_provider_types_with_http_info(self, **kwargs):  # noqa: E501
         """List registry adapters  # noqa: E501
@@ -709,73 +762,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: list[str]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_registry_provider_types" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_registry_provider_types`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_registry_provider_types`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/adapters', 'GET',
+            "/replication/adapters",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[str]',  # noqa: E501
+            response_type="list[str]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def ping_registry(self, registry, **kwargs):  # noqa: E501
         """Check status of a registry  # noqa: E501
 
         Check status of a registry  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -785,16 +845,16 @@
         :param async_req bool
         :param RegistryPing registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_registry_with_http_info(registry, **kwargs)  # noqa: E501
         else:
             (data) = self.ping_registry_with_http_info(registry, **kwargs)  # noqa: E501
             return data
 
     def ping_registry_with_http_info(self, registry, **kwargs):  # noqa: E501
         """Check status of a registry  # noqa: E501
@@ -809,79 +869,88 @@
         :param RegistryPing registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registry', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registry", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registry' is set
-        if self.api_client.client_side_validation and ('registry' not in params or
-                                                       params['registry'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registry` when calling `ping_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registry" not in params or params["registry"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registry` when calling `ping_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registry' in params:
-            body_params = params['registry']
+        if "registry" in params:
+            body_params = params["registry"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/ping', 'POST',
+            "/registries/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_registry(self, id, registry, **kwargs):  # noqa: E501
         """Update the registry  # noqa: E501
 
         Update the registry  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -892,16 +961,16 @@
         :param int id: The registry ID (required)
         :param RegistryUpdate registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_registry_with_http_info(id, registry, **kwargs)  # noqa: E501
         else:
             (data) = self.update_registry_with_http_info(id, registry, **kwargs)  # noqa: E501
             return data
 
     def update_registry_with_http_info(self, id, registry, **kwargs):  # noqa: E501
         """Update the registry  # noqa: E501
@@ -917,78 +986,90 @@
         :param RegistryUpdate registry: The registry (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'registry', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "registry", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_registry" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_registry" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `update_registry`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `update_registry`"
+            )  # noqa: E501
         # verify the required parameter 'registry' is set
-        if self.api_client.client_side_validation and ('registry' not in params or
-                                                       params['registry'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registry` when calling `update_registry`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_registry`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registry" not in params or params["registry"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registry` when calling `update_registry`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_registry`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registry' in params:
-            body_params = params['registry']
+        if "registry" in params:
+            body_params = params["registry"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/registries/{id}', 'PUT',
+            "/registries/{id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/replication_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/replication_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param ReplicationPolicy policy: The replication policy (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_replication_policy_with_http_info(policy, **kwargs)  # noqa: E501
         else:
             (data) = self.create_replication_policy_with_http_info(policy, **kwargs)  # noqa: E501
             return data
 
     def create_replication_policy_with_http_info(self, policy, **kwargs):  # noqa: E501
         """Create a replication policy  # noqa: E501
@@ -69,79 +69,89 @@
         :param ReplicationPolicy policy: The replication policy (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_replication_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `create_replication_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_replication_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `create_replication_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_replication_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies', 'POST',
+            "/replication/policies",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_replication_policy(self, id, **kwargs):  # noqa: E501
         """Delete the specific replication policy  # noqa: E501
 
         Delete the specific replication policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +161,16 @@
         :param async_req bool
         :param int id: Replication policy ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_replication_policy_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_replication_policy_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def delete_replication_policy_with_http_info(self, id, **kwargs):  # noqa: E501
         """Delete the specific replication policy  # noqa: E501
@@ -175,79 +185,89 @@
         :param int id: Replication policy ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_replication_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `delete_replication_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_replication_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `delete_replication_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_replication_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies/{id}', 'DELETE',
+            "/replication/policies/{id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_replication_execution(self, id, **kwargs):  # noqa: E501
         """Get the specific replication execution  # noqa: E501
 
         Get the replication execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +277,16 @@
         :param async_req bool
         :param int id: The ID of the execution. (required)
         :param str x_request_id: An unique ID for the request
         :return: ReplicationExecution
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_replication_execution_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_replication_execution_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_replication_execution_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the specific replication execution  # noqa: E501
@@ -281,79 +301,89 @@
         :param int id: The ID of the execution. (required)
         :param str x_request_id: An unique ID for the request
         :return: ReplicationExecution
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_replication_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_replication_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_replication_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_replication_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_replication_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions/{id}', 'GET',
+            "/replication/executions/{id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ReplicationExecution',  # noqa: E501
+            response_type="ReplicationExecution",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_replication_log(self, id, task_id, **kwargs):  # noqa: E501
         """Get the log of the specific replication task  # noqa: E501
 
         Get the log of the specific replication task  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -364,16 +394,16 @@
         :param int id: The ID of the execution that the tasks belongs to. (required)
         :param int task_id: The ID of the task. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_replication_log_with_http_info(id, task_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_replication_log_with_http_info(id, task_id, **kwargs)  # noqa: E501
             return data
 
     def get_replication_log_with_http_info(self, id, task_id, **kwargs):  # noqa: E501
         """Get the log of the specific replication task  # noqa: E501
@@ -389,85 +419,95 @@
         :param int task_id: The ID of the task. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'task_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "task_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_replication_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_replication_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_replication_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_replication_log`"
+            )  # noqa: E501
         # verify the required parameter 'task_id' is set
-        if self.api_client.client_side_validation and ('task_id' not in params or
-                                                       params['task_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `task_id` when calling `get_replication_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_replication_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "task_id" not in params or params["task_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `task_id` when calling `get_replication_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_replication_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
-        if 'task_id' in params:
-            path_params['task_id'] = params['task_id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
+        if "task_id" in params:
+            path_params["task_id"] = params["task_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions/{id}/tasks/{task_id}/log', 'GET',
+            "/replication/executions/{id}/tasks/{task_id}/log",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_replication_policy(self, id, **kwargs):  # noqa: E501
         """Get the specific replication policy  # noqa: E501
 
         Get the specific replication policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -477,16 +517,16 @@
         :param async_req bool
         :param int id: Policy ID (required)
         :param str x_request_id: An unique ID for the request
         :return: ReplicationPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_replication_policy_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_replication_policy_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_replication_policy_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get the specific replication policy  # noqa: E501
@@ -501,79 +541,89 @@
         :param int id: Policy ID (required)
         :param str x_request_id: An unique ID for the request
         :return: ReplicationPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_replication_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_replication_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_replication_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_replication_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_replication_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies/{id}', 'GET',
+            "/replication/policies/{id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ReplicationPolicy',  # noqa: E501
+            response_type="ReplicationPolicy",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_replication_executions(self, **kwargs):  # noqa: E501
         """List replication executions  # noqa: E501
 
         List replication executions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -588,16 +638,16 @@
         :param int policy_id: The ID of the policy that the executions belong to.
         :param str status: The execution status.
         :param str trigger: The trigger mode.
         :return: list[ReplicationExecution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_replication_executions_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_replication_executions_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_replication_executions_with_http_info(self, **kwargs):  # noqa: E501
         """List replication executions  # noqa: E501
@@ -617,87 +667,106 @@
         :param str status: The execution status.
         :param str trigger: The trigger mode.
         :return: list[ReplicationExecution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'sort', 'page', 'page_size', 'policy_id', 'status', 'trigger']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "sort",
+            "page",
+            "page_size",
+            "policy_id",
+            "status",
+            "trigger",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_replication_executions" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_replication_executions`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_replication_executions`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_replication_executions`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_replication_executions`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'policy_id' in params:
-            query_params.append(('policy_id', params['policy_id']))  # noqa: E501
-        if 'status' in params:
-            query_params.append(('status', params['status']))  # noqa: E501
-        if 'trigger' in params:
-            query_params.append(('trigger', params['trigger']))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "policy_id" in params:
+            query_params.append(("policy_id", params["policy_id"]))  # noqa: E501
+        if "status" in params:
+            query_params.append(("status", params["status"]))  # noqa: E501
+        if "trigger" in params:
+            query_params.append(("trigger", params["trigger"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions', 'GET',
+            "/replication/executions",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ReplicationExecution]',  # noqa: E501
+            response_type="list[ReplicationExecution]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_replication_policies(self, **kwargs):  # noqa: E501
         """List replication policies  # noqa: E501
 
         List replication policies  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -711,16 +780,16 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :param str name: Deprecated, use \"query\" instead. The policy name.
         :return: list[ReplicationPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_replication_policies_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_replication_policies_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_replication_policies_with_http_info(self, **kwargs):  # noqa: E501
         """List replication policies  # noqa: E501
@@ -739,85 +808,96 @@
         :param int page_size: The size of per page
         :param str name: Deprecated, use \"query\" instead. The policy name.
         :return: list[ReplicationPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size', 'name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size", "name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_replication_policies" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_replication_policies`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_replication_policies`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_replication_policies`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_replication_policies`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'name' in params:
-            query_params.append(('name', params['name']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "name" in params:
+            query_params.append(("name", params["name"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies', 'GET',
+            "/replication/policies",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ReplicationPolicy]',  # noqa: E501
+            response_type="list[ReplicationPolicy]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_replication_tasks(self, id, **kwargs):  # noqa: E501
         """List replication tasks for a specific execution  # noqa: E501
 
         List replication tasks for a specific execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -832,16 +912,16 @@
         :param int page_size: The size of per page
         :param str status: The task status.
         :param str resource_type: The resource type.
         :return: list[ReplicationTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_replication_tasks_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.list_replication_tasks_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def list_replication_tasks_with_http_info(self, id, **kwargs):  # noqa: E501
         """List replication tasks for a specific execution  # noqa: E501
@@ -861,91 +941,113 @@
         :param str status: The task status.
         :param str resource_type: The resource type.
         :return: list[ReplicationTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id', 'sort', 'page', 'page_size', 'status', 'resource_type']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "id",
+            "x_request_id",
+            "sort",
+            "page",
+            "page_size",
+            "status",
+            "resource_type",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_replication_tasks" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `list_replication_tasks`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_replication_tasks`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_replication_tasks`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `list_replication_tasks`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_replication_tasks`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_replication_tasks`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'status' in params:
-            query_params.append(('status', params['status']))  # noqa: E501
-        if 'resource_type' in params:
-            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "status" in params:
+            query_params.append(("status", params["status"]))  # noqa: E501
+        if "resource_type" in params:
+            query_params.append(("resource_type", params["resource_type"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions/{id}/tasks', 'GET',
+            "/replication/executions/{id}/tasks",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ReplicationTask]',  # noqa: E501
+            response_type="list[ReplicationTask]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def start_replication(self, execution, **kwargs):  # noqa: E501
         """Start one replication execution  # noqa: E501
 
         Start one replication execution according to the policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -955,16 +1057,16 @@
         :param async_req bool
         :param StartReplicationExecution execution: The ID of policy that the execution belongs to (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.start_replication_with_http_info(execution, **kwargs)  # noqa: E501
         else:
             (data) = self.start_replication_with_http_info(execution, **kwargs)  # noqa: E501
             return data
 
     def start_replication_with_http_info(self, execution, **kwargs):  # noqa: E501
         """Start one replication execution  # noqa: E501
@@ -979,79 +1081,88 @@
         :param StartReplicationExecution execution: The ID of policy that the execution belongs to (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['execution', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["execution", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method start_replication" % key
+                    "Got an unexpected keyword argument '%s'" " to method start_replication" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'execution' is set
-        if self.api_client.client_side_validation and ('execution' not in params or
-                                                       params['execution'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution` when calling `start_replication`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `start_replication`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution" not in params or params["execution"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution` when calling `start_replication`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `start_replication`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'execution' in params:
-            body_params = params['execution']
+        if "execution" in params:
+            body_params = params["execution"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions', 'POST',
+            "/replication/executions",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_replication(self, id, **kwargs):  # noqa: E501
         """Stop the specific replication execution  # noqa: E501
 
         Stop the replication execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1061,16 +1172,16 @@
         :param async_req bool
         :param int id: The ID of the execution. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_replication_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.stop_replication_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def stop_replication_with_http_info(self, id, **kwargs):  # noqa: E501
         """Stop the specific replication execution  # noqa: E501
@@ -1085,79 +1196,88 @@
         :param int id: The ID of the execution. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_replication" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_replication" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `stop_replication`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_replication`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `stop_replication`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_replication`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/executions/{id}', 'PUT',
+            "/replication/executions/{id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_replication_policy(self, id, policy, **kwargs):  # noqa: E501
         """Update the replication policy  # noqa: E501
 
         Update the replication policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1168,19 +1288,21 @@
         :param int id: The policy ID (required)
         :param ReplicationPolicy policy: The replication policy (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_replication_policy_with_http_info(id, policy, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_replication_policy_with_http_info(id, policy, **kwargs)  # noqa: E501
+            (data) = self.update_replication_policy_with_http_info(
+                id, policy, **kwargs
+            )  # noqa: E501
             return data
 
     def update_replication_policy_with_http_info(self, id, policy, **kwargs):  # noqa: E501
         """Update the replication policy  # noqa: E501
 
         Update the replication policy  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -1193,78 +1315,91 @@
         :param ReplicationPolicy policy: The replication policy (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_replication_policy" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `update_replication_policy`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `update_replication_policy`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `update_replication_policy`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_replication_policy`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `update_replication_policy`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_replication_policy`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/replication/policies/{id}', 'PUT',
+            "/replication/policies/{id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/repository_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/repository_api.py`

 * *Files 16% similar despite different names*

```diff
@@ -46,22 +46,28 @@
         :param str project_name: The name of the project (required)
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_repository_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_repository_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_repository_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+            (data) = self.delete_repository_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_repository_with_http_info(self, project_name, repository_name, **kwargs):  # noqa: E501
+    def delete_repository_with_http_info(
+        self, project_name, repository_name, **kwargs
+    ):  # noqa: E501
         """Delete repository  # noqa: E501
 
         Delete the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_repository_with_http_info(project_name, repository_name, async_req=True)
         >>> result = thread.get()
@@ -71,85 +77,97 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_repository" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_repository" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `delete_repository`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `delete_repository`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `delete_repository`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_repository`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `delete_repository`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_repository`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}', 'DELETE',
+            "/projects/{project_name}/repositories/{repository_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_repository(self, project_name, repository_name, **kwargs):  # noqa: E501
         """Get repository  # noqa: E501
 
         Get the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -160,19 +178,23 @@
         :param str project_name: The name of the project (required)
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str x_request_id: An unique ID for the request
         :return: Repository
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_repository_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_repository_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_repository_with_http_info(project_name, repository_name, **kwargs)  # noqa: E501
+            (data) = self.get_repository_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
             return data
 
     def get_repository_with_http_info(self, project_name, repository_name, **kwargs):  # noqa: E501
         """Get repository  # noqa: E501
 
         Get the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -185,85 +207,97 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str x_request_id: An unique ID for the request
         :return: Repository
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_repository" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_repository" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_repository`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_repository`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_repository`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_repository`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_repository`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_repository`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Repository',  # noqa: E501
+            response_type="Repository",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_all_repositories(self, **kwargs):  # noqa: E501
         """List all authorized repositories  # noqa: E501
 
         List all authorized repositories  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -276,16 +310,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Repository]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_all_repositories_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_all_repositories_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_all_repositories_with_http_info(self, **kwargs):  # noqa: E501
         """List all authorized repositories  # noqa: E501
@@ -303,83 +337,94 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Repository]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_all_repositories" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_all_repositories`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_all_repositories`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_all_repositories`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_all_repositories`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/repositories', 'GET',
+            "/repositories",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Repository]',  # noqa: E501
+            response_type="list[Repository]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_repositories(self, project_name, **kwargs):  # noqa: E501
         """List repositories  # noqa: E501
 
         List repositories of the specified project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -393,16 +438,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Repository]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_repositories_with_http_info(project_name, **kwargs)  # noqa: E501
         else:
             (data) = self.list_repositories_with_http_info(project_name, **kwargs)  # noqa: E501
             return data
 
     def list_repositories_with_http_info(self, project_name, **kwargs):  # noqa: E501
         """List repositories  # noqa: E501
@@ -421,89 +466,109 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Repository]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_repositories" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_repositories" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `list_repositories`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_repositories`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_repositories`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_repositories`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_repositories`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_repositories`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories', 'GET',
+            "/projects/{project_name}/repositories",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Repository]',  # noqa: E501
+            response_type="list[Repository]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_repository(self, project_name, repository_name, repository, **kwargs):  # noqa: E501
         """Update repository  # noqa: E501
 
         Update the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -515,22 +580,28 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param Repository repository: The JSON object of repository. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_repository_with_http_info(project_name, repository_name, repository, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_repository_with_http_info(
+                project_name, repository_name, repository, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_repository_with_http_info(project_name, repository_name, repository, **kwargs)  # noqa: E501
+            (data) = self.update_repository_with_http_info(
+                project_name, repository_name, repository, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_repository_with_http_info(self, project_name, repository_name, repository, **kwargs):  # noqa: E501
+    def update_repository_with_http_info(
+        self, project_name, repository_name, repository, **kwargs
+    ):  # noqa: E501
         """Update repository  # noqa: E501
 
         Update the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_repository_with_http_info(project_name, repository_name, repository, async_req=True)
         >>> result = thread.get()
@@ -541,84 +612,99 @@
         :param Repository repository: The JSON object of repository. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'repository', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "repository", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_repository" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_repository" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `update_repository`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `update_repository`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `update_repository`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `update_repository`"
+            )  # noqa: E501
         # verify the required parameter 'repository' is set
-        if self.api_client.client_side_validation and ('repository' not in params or
-                                                       params['repository'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository` when calling `update_repository`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_repository`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository" not in params or params["repository"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository` when calling `update_repository`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_repository`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'repository' in params:
-            body_params = params['repository']
+        if "repository" in params:
+            body_params = params["repository"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}', 'PUT',
+            "/projects/{project_name}/repositories/{repository_name}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/retention_api.py` & `harbor_api_client-2.7.6/src/harbor_client/api/retention_api.py`

 * *Files 17% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param RetentionPolicy policy: Create Retention Policy successfully. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_retention_with_http_info(policy, **kwargs)  # noqa: E501
         else:
             (data) = self.create_retention_with_http_info(policy, **kwargs)  # noqa: E501
             return data
 
     def create_retention_with_http_info(self, policy, **kwargs):  # noqa: E501
         """Create Retention Policy  # noqa: E501
@@ -69,79 +69,88 @@
         :param RetentionPolicy policy: Create Retention Policy successfully. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_retention" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_retention" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `create_retention`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_retention`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `create_retention`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_retention`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions', 'POST',
+            "/retentions",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_retention(self, id, **kwargs):  # noqa: E501
         """Delete Retention Policy  # noqa: E501
 
         Delete Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int id: Retention ID. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_retention_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_retention_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def delete_retention_with_http_info(self, id, **kwargs):  # noqa: E501
         """Delete Retention Policy  # noqa: E501
@@ -175,79 +184,88 @@
         :param int id: Retention ID. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_retention" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_retention" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `delete_retention`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_retention`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `delete_retention`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_retention`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}', 'DELETE',
+            "/retentions/{id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_rentenition_metadata(self, **kwargs):  # noqa: E501
         """Get Retention Metadatas  # noqa: E501
 
         Get Retention Metadatas.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -256,16 +274,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: RetentionMetadata
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_rentenition_metadata_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_rentenition_metadata_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_rentenition_metadata_with_http_info(self, **kwargs):  # noqa: E501
         """Get Retention Metadatas  # noqa: E501
@@ -279,73 +297,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: RetentionMetadata
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_rentenition_metadata" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_rentenition_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_rentenition_metadata`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/metadatas', 'GET',
+            "/retentions/metadatas",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RetentionMetadata',  # noqa: E501
+            response_type="RetentionMetadata",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_retention(self, id, **kwargs):  # noqa: E501
         """Get Retention Policy  # noqa: E501
 
         Get Retention Policy.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -355,16 +380,16 @@
         :param async_req bool
         :param int id: Retention ID. (required)
         :param str x_request_id: An unique ID for the request
         :return: RetentionPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_retention_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_retention_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def get_retention_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get Retention Policy  # noqa: E501
@@ -379,79 +404,88 @@
         :param int id: Retention ID. (required)
         :param str x_request_id: An unique ID for the request
         :return: RetentionPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_retention" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_retention" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_retention`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_retention`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_retention`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_retention`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}', 'GET',
+            "/retentions/{id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RetentionPolicy',  # noqa: E501
+            response_type="RetentionPolicy",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_retention_task_log(self, id, eid, tid, **kwargs):  # noqa: E501
         """Get Retention job task log  # noqa: E501
 
         Get Retention job task log, tags ratain or deletion detail will be shown in a table.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -463,19 +497,21 @@
         :param int eid: Retention execution ID. (required)
         :param int tid: Retention execution ID. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_retention_task_log_with_http_info(id, eid, tid, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_retention_task_log_with_http_info(id, eid, tid, **kwargs)  # noqa: E501
+            (data) = self.get_retention_task_log_with_http_info(
+                id, eid, tid, **kwargs
+            )  # noqa: E501
             return data
 
     def get_retention_task_log_with_http_info(self, id, eid, tid, **kwargs):  # noqa: E501
         """Get Retention job task log  # noqa: E501
 
         Get Retention job task log, tags ratain or deletion detail will be shown in a table.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -489,91 +525,105 @@
         :param int tid: Retention execution ID. (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'eid', 'tid', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "eid", "tid", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_retention_task_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `get_retention_task_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `get_retention_task_log`"
+            )  # noqa: E501
         # verify the required parameter 'eid' is set
-        if self.api_client.client_side_validation and ('eid' not in params or
-                                                       params['eid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `eid` when calling `get_retention_task_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "eid" not in params or params["eid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `eid` when calling `get_retention_task_log`"
+            )  # noqa: E501
         # verify the required parameter 'tid' is set
-        if self.api_client.client_side_validation and ('tid' not in params or
-                                                       params['tid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `tid` when calling `get_retention_task_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_retention_task_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "tid" not in params or params["tid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `tid` when calling `get_retention_task_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_retention_task_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
-        if 'eid' in params:
-            path_params['eid'] = params['eid']  # noqa: E501
-        if 'tid' in params:
-            path_params['tid'] = params['tid']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
+        if "eid" in params:
+            path_params["eid"] = params["eid"]  # noqa: E501
+        if "tid" in params:
+            path_params["tid"] = params["tid"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions/{eid}/tasks/{tid}', 'GET',
+            "/retentions/{id}/executions/{eid}/tasks/{tid}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_retention_executions(self, id, **kwargs):  # noqa: E501
         """Get Retention executions  # noqa: E501
 
         Get Retention executions, execution status may be delayed before job service schedule it up.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -585,16 +635,16 @@
         :param str x_request_id: An unique ID for the request
         :param int page: The page number.
         :param int page_size: The size of per page.
         :return: list[RetentionExecution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_retention_executions_with_http_info(id, **kwargs)  # noqa: E501
         else:
             (data) = self.list_retention_executions_with_http_info(id, **kwargs)  # noqa: E501
             return data
 
     def list_retention_executions_with_http_info(self, id, **kwargs):  # noqa: E501
         """Get Retention executions  # noqa: E501
@@ -611,83 +661,93 @@
         :param int page: The page number.
         :param int page_size: The size of per page.
         :return: list[RetentionExecution]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "x_request_id", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_retention_executions" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `list_retention_executions`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_retention_executions`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `list_retention_executions`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_retention_executions`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions', 'GET',
+            "/retentions/{id}/executions",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[RetentionExecution]',  # noqa: E501
+            response_type="list[RetentionExecution]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_retention_tasks(self, id, eid, **kwargs):  # noqa: E501
         """Get Retention tasks  # noqa: E501
 
         Get Retention tasks, each repository as a task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -700,16 +760,16 @@
         :param str x_request_id: An unique ID for the request
         :param int page: The page number.
         :param int page_size: The size of per page.
         :return: list[RetentionExecutionTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_retention_tasks_with_http_info(id, eid, **kwargs)  # noqa: E501
         else:
             (data) = self.list_retention_tasks_with_http_info(id, eid, **kwargs)  # noqa: E501
             return data
 
     def list_retention_tasks_with_http_info(self, id, eid, **kwargs):  # noqa: E501
         """Get Retention tasks  # noqa: E501
@@ -727,89 +787,102 @@
         :param int page: The page number.
         :param int page_size: The size of per page.
         :return: list[RetentionExecutionTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'eid', 'x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "eid", "x_request_id", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_retention_tasks" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `list_retention_tasks`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `list_retention_tasks`"
+            )  # noqa: E501
         # verify the required parameter 'eid' is set
-        if self.api_client.client_side_validation and ('eid' not in params or
-                                                       params['eid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `eid` when calling `list_retention_tasks`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_retention_tasks`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "eid" not in params or params["eid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `eid` when calling `list_retention_tasks`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_retention_tasks`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
-        if 'eid' in params:
-            path_params['eid'] = params['eid']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
+        if "eid" in params:
+            path_params["eid"] = params["eid"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions/{eid}/tasks', 'GET',
+            "/retentions/{id}/executions/{eid}/tasks",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[RetentionExecutionTask]',  # noqa: E501
+            response_type="list[RetentionExecutionTask]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def operate_retention_execution(self, id, eid, body, **kwargs):  # noqa: E501
         """Stop a Retention execution  # noqa: E501
 
         Stop a Retention execution, only support \"stop\" action now.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -821,19 +894,23 @@
         :param int eid: Retention execution ID. (required)
         :param Body1 body: The action, only support \"stop\" now. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.operate_retention_execution_with_http_info(id, eid, body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.operate_retention_execution_with_http_info(
+                id, eid, body, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.operate_retention_execution_with_http_info(id, eid, body, **kwargs)  # noqa: E501
+            (data) = self.operate_retention_execution_with_http_info(
+                id, eid, body, **kwargs
+            )  # noqa: E501
             return data
 
     def operate_retention_execution_with_http_info(self, id, eid, body, **kwargs):  # noqa: E501
         """Stop a Retention execution  # noqa: E501
 
         Stop a Retention execution, only support \"stop\" action now.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -847,91 +924,107 @@
         :param Body1 body: The action, only support \"stop\" now. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'eid', 'body', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "eid", "body", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method operate_retention_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `operate_retention_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `operate_retention_execution`"
+            )  # noqa: E501
         # verify the required parameter 'eid' is set
-        if self.api_client.client_side_validation and ('eid' not in params or
-                                                       params['eid'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `eid` when calling `operate_retention_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "eid" not in params or params["eid"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `eid` when calling `operate_retention_execution`"
+            )  # noqa: E501
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and ('body' not in params or
-                                                       params['body'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `body` when calling `operate_retention_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `operate_retention_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "body" not in params or params["body"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `body` when calling `operate_retention_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `operate_retention_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
-        if 'eid' in params:
-            path_params['eid'] = params['eid']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
+        if "eid" in params:
+            path_params["eid"] = params["eid"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        if "body" in params:
+            body_params = params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions/{eid}', 'PATCH',
+            "/retentions/{id}/executions/{eid}",
+            "PATCH",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def trigger_retention_execution(self, id, body, **kwargs):  # noqa: E501
         """Trigger a Retention Execution  # noqa: E501
 
         Trigger a Retention Execution, if dry_run is True, nothing would be deleted actually.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -942,19 +1035,21 @@
         :param int id: Retention ID. (required)
         :param Body body: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.trigger_retention_execution_with_http_info(id, body, **kwargs)  # noqa: E501
         else:
-            (data) = self.trigger_retention_execution_with_http_info(id, body, **kwargs)  # noqa: E501
+            (data) = self.trigger_retention_execution_with_http_info(
+                id, body, **kwargs
+            )  # noqa: E501
             return data
 
     def trigger_retention_execution_with_http_info(self, id, body, **kwargs):  # noqa: E501
         """Trigger a Retention Execution  # noqa: E501
 
         Trigger a Retention Execution, if dry_run is True, nothing would be deleted actually.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -967,85 +1062,96 @@
         :param Body body: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'body', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "body", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method trigger_retention_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `trigger_retention_execution`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `trigger_retention_execution`"
+            )  # noqa: E501
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and ('body' not in params or
-                                                       params['body'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `body` when calling `trigger_retention_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `trigger_retention_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "body" not in params or params["body"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `body` when calling `trigger_retention_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `trigger_retention_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        if "body" in params:
+            body_params = params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}/executions', 'POST',
+            "/retentions/{id}/executions",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_retention(self, id, policy, **kwargs):  # noqa: E501
         """Update Retention Policy  # noqa: E501
 
         Update Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -1056,16 +1162,16 @@
         :param int id: Retention ID. (required)
         :param RetentionPolicy policy: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_retention_with_http_info(id, policy, **kwargs)  # noqa: E501
         else:
             (data) = self.update_retention_with_http_info(id, policy, **kwargs)  # noqa: E501
             return data
 
     def update_retention_with_http_info(self, id, policy, **kwargs):  # noqa: E501
         """Update Retention Policy  # noqa: E501
@@ -1081,78 +1187,90 @@
         :param RetentionPolicy policy: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['id', 'policy', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["id", "policy", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_retention" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_retention" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and ('id' not in params or
-                                                       params['id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `id` when calling `update_retention`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "id" not in params or params["id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `id` when calling `update_retention`"
+            )  # noqa: E501
         # verify the required parameter 'policy' is set
-        if self.api_client.client_side_validation and ('policy' not in params or
-                                                       params['policy'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy` when calling `update_retention`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_retention`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `update_retention`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_retention`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'id' in params:
-            path_params['id'] = params['id']  # noqa: E501
+        if "id" in params:
+            path_params["id"] = params["id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'policy' in params:
-            body_params = params['policy']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/retentions/{id}', 'PUT',
+            "/retentions/{id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/robot_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/robot_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param RobotCreate robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: RobotCreated
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_robot_with_http_info(robot, **kwargs)  # noqa: E501
         else:
             (data) = self.create_robot_with_http_info(robot, **kwargs)  # noqa: E501
             return data
 
     def create_robot_with_http_info(self, robot, **kwargs):  # noqa: E501
         """Create a robot account  # noqa: E501
@@ -69,79 +69,88 @@
         :param RobotCreate robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: RobotCreated
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_robot" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_robot" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot' is set
-        if self.api_client.client_side_validation and ('robot' not in params or
-                                                       params['robot'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot` when calling `create_robot`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_robot`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot" not in params or params["robot"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot` when calling `create_robot`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_robot`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot' in params:
-            body_params = params['robot']
+        if "robot" in params:
+            body_params = params["robot"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots', 'POST',
+            "/robots",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RobotCreated',  # noqa: E501
+            response_type="RobotCreated",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_robot(self, robot_id, **kwargs):  # noqa: E501
         """Delete a robot account  # noqa: E501
 
         This endpoint deletes specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_robot_with_http_info(robot_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_robot_with_http_info(robot_id, **kwargs)  # noqa: E501
             return data
 
     def delete_robot_with_http_info(self, robot_id, **kwargs):  # noqa: E501
         """Delete a robot account  # noqa: E501
@@ -175,79 +184,88 @@
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_robot" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_robot" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `delete_robot`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_robot`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `delete_robot`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_robot`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots/{robot_id}', 'DELETE',
+            "/robots/{robot_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_robot_by_id(self, robot_id, **kwargs):  # noqa: E501
         """Get a robot account  # noqa: E501
 
         This endpoint returns specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +275,16 @@
         :param async_req bool
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Robot
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_robot_by_id_with_http_info(robot_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_robot_by_id_with_http_info(robot_id, **kwargs)  # noqa: E501
             return data
 
     def get_robot_by_id_with_http_info(self, robot_id, **kwargs):  # noqa: E501
         """Get a robot account  # noqa: E501
@@ -281,79 +299,88 @@
         :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
         :return: Robot
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_robot_by_id" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_robot_by_id" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `get_robot_by_id`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_robot_by_id`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `get_robot_by_id`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_robot_by_id`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots/{robot_id}', 'GET',
+            "/robots/{robot_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Robot',  # noqa: E501
+            response_type="Robot",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_robot(self, **kwargs):  # noqa: E501
         """Get robot account  # noqa: E501
 
         List the robot accounts with the specified level and project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -366,16 +393,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Robot]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_robot_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_robot_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_robot_with_http_info(self, **kwargs):  # noqa: E501
         """Get robot account  # noqa: E501
@@ -393,83 +420,93 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[Robot]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_robot" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_robot" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_robot`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_robot`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_robot`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_robot`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots', 'GET',
+            "/robots",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Robot]',  # noqa: E501
+            response_type="list[Robot]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def refresh_sec(self, robot_id, robot_sec, **kwargs):  # noqa: E501
         """Refresh the robot secret  # noqa: E501
 
         Refresh the robot secret  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -480,16 +517,16 @@
         :param int robot_id: Robot ID (required)
         :param RobotSec robot_sec: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: RobotSec
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.refresh_sec_with_http_info(robot_id, robot_sec, **kwargs)  # noqa: E501
         else:
             (data) = self.refresh_sec_with_http_info(robot_id, robot_sec, **kwargs)  # noqa: E501
             return data
 
     def refresh_sec_with_http_info(self, robot_id, robot_sec, **kwargs):  # noqa: E501
         """Refresh the robot secret  # noqa: E501
@@ -505,85 +542,97 @@
         :param RobotSec robot_sec: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: RobotSec
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot_id', 'robot_sec', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot_id", "robot_sec", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method refresh_sec" % key
+                    "Got an unexpected keyword argument '%s'" " to method refresh_sec" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `refresh_sec`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `refresh_sec`"
+            )  # noqa: E501
         # verify the required parameter 'robot_sec' is set
-        if self.api_client.client_side_validation and ('robot_sec' not in params or
-                                                       params['robot_sec'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_sec` when calling `refresh_sec`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `refresh_sec`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_sec" not in params or params["robot_sec"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_sec` when calling `refresh_sec`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `refresh_sec`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot_sec' in params:
-            body_params = params['robot_sec']
+        if "robot_sec" in params:
+            body_params = params["robot_sec"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots/{robot_id}', 'PATCH',
+            "/robots/{robot_id}",
+            "PATCH",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RobotSec',  # noqa: E501
+            response_type="RobotSec",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_robot(self, robot_id, robot, **kwargs):  # noqa: E501
         """Update a robot account  # noqa: E501
 
         This endpoint updates specific robot account information by robot ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -594,16 +643,16 @@
         :param int robot_id: Robot ID (required)
         :param Robot robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_robot_with_http_info(robot_id, robot, **kwargs)  # noqa: E501
         else:
             (data) = self.update_robot_with_http_info(robot_id, robot, **kwargs)  # noqa: E501
             return data
 
     def update_robot_with_http_info(self, robot_id, robot, **kwargs):  # noqa: E501
         """Update a robot account  # noqa: E501
@@ -619,78 +668,90 @@
         :param Robot robot: The JSON object of a robot account. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['robot_id', 'robot', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["robot_id", "robot", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_robot" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_robot" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `update_robot`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot_id" not in params or params["robot_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot_id` when calling `update_robot`"
+            )  # noqa: E501
         # verify the required parameter 'robot' is set
-        if self.api_client.client_side_validation and ('robot' not in params or
-                                                       params['robot'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot` when calling `update_robot`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_robot`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "robot" not in params or params["robot"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `robot` when calling `update_robot`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_robot`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "robot_id" in params:
+            path_params["robot_id"] = params["robot_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot' in params:
-            body_params = params['robot']
+        if "robot" in params:
+            body_params = params["robot"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/robots/{robot_id}', 'PUT',
+            "/robots/{robot_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/robotv1_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/repository_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -17,626 +17,694 @@
 
 # python 2 and python 3 compatibility library
 import six
 
 from harbor_client.api_client import ApiClient
 
 
-class Robotv1Api(object):
+class RepositoryApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_robot_v1(self, project_name_or_id, robot, **kwargs):  # noqa: E501
-        """Create a robot account  # noqa: E501
+    def delete_repository(self, project_name, repository_name, **kwargs):  # noqa: E501
+        """Delete repository  # noqa: E501
 
-        Create a robot account  # noqa: E501
+        Delete the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_robot_v1(project_name_or_id, robot, async_req=True)
+        >>> thread = api.delete_repository(project_name, repository_name, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
-        :param RobotCreateV1 robot: The JSON object of a robot account. (required)
+        :param str project_name: The name of the project (required)
+        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
-        :return: RobotCreated
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_robot_v1_with_http_info(project_name_or_id, robot, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_repository_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_robot_v1_with_http_info(project_name_or_id, robot, **kwargs)  # noqa: E501
+            (data) = self.delete_repository_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def create_robot_v1_with_http_info(self, project_name_or_id, robot, **kwargs):  # noqa: E501
-        """Create a robot account  # noqa: E501
+    def delete_repository_with_http_info(
+        self, project_name, repository_name, **kwargs
+    ):  # noqa: E501
+        """Delete repository  # noqa: E501
 
-        Create a robot account  # noqa: E501
+        Delete the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_robot_v1_with_http_info(project_name_or_id, robot, async_req=True)
+        >>> thread = api.delete_repository_with_http_info(project_name, repository_name, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
-        :param RobotCreateV1 robot: The JSON object of a robot account. (required)
+        :param str project_name: The name of the project (required)
+        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
-        :return: RobotCreated
+        :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'robot', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_robot_v1" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_repository" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `create_robot_v1`")  # noqa: E501
-        # verify the required parameter 'robot' is set
-        if self.api_client.client_side_validation and ('robot' not in params or
-                                                       params['robot'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot` when calling `create_robot_v1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_robot_v1`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name' is set
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `delete_repository`"
+            )  # noqa: E501
+        # verify the required parameter 'repository_name' is set
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `delete_repository`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_repository`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot' in params:
-            body_params = params['robot']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='RobotCreated',  # noqa: E501
+            response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def delete_robot_v1(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
-        """Delete a robot account  # noqa: E501
+    def get_repository(self, project_name, repository_name, **kwargs):  # noqa: E501
+        """Get repository  # noqa: E501
 
-        This endpoint deletes specific robot account information by robot ID.  # noqa: E501
+        Get the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_robot_v1(project_name_or_id, robot_id, async_req=True)
+        >>> thread = api.get_repository(project_name, repository_name, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
-        :param int robot_id: Robot ID (required)
+        :param str project_name: The name of the project (required)
+        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
-        :return: None
+        :return: Repository
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_robot_v1_with_http_info(project_name_or_id, robot_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_repository_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_robot_v1_with_http_info(project_name_or_id, robot_id, **kwargs)  # noqa: E501
+            (data) = self.get_repository_with_http_info(
+                project_name, repository_name, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_robot_v1_with_http_info(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
-        """Delete a robot account  # noqa: E501
+    def get_repository_with_http_info(self, project_name, repository_name, **kwargs):  # noqa: E501
+        """Get repository  # noqa: E501
 
-        This endpoint deletes specific robot account information by robot ID.  # noqa: E501
+        Get the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_robot_v1_with_http_info(project_name_or_id, robot_id, async_req=True)
+        >>> thread = api.get_repository_with_http_info(project_name, repository_name, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
-        :param int robot_id: Robot ID (required)
+        :param str project_name: The name of the project (required)
+        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
-        :return: None
+        :return: Repository
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'robot_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_robot_v1" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_repository" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `delete_robot_v1`")  # noqa: E501
-        # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `delete_robot_v1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_robot_v1`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name' is set
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_repository`"
+            )  # noqa: E501
+        # verify the required parameter 'repository_name' is set
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_repository`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_repository`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots/{robot_id}', 'DELETE',
+            "/projects/{project_name}/repositories/{repository_name}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,  # noqa: E501
+            response_type="Repository",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def get_robot_by_idv1(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
-        """Get a robot account  # noqa: E501
+    def list_all_repositories(self, **kwargs):  # noqa: E501
+        """List all authorized repositories  # noqa: E501
 
-        This endpoint returns specific robot account information by robot ID.  # noqa: E501
+        List all authorized repositories  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_robot_by_idv1(project_name_or_id, robot_id, async_req=True)
+        >>> thread = api.list_all_repositories(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
-        :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
-        :return: Robot
+        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
+        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
+        :param int page: The page number
+        :param int page_size: The size of per page
+        :return: list[Repository]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_robot_by_idv1_with_http_info(project_name_or_id, robot_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_all_repositories_with_http_info(**kwargs)  # noqa: E501
         else:
-            (data) = self.get_robot_by_idv1_with_http_info(project_name_or_id, robot_id, **kwargs)  # noqa: E501
+            (data) = self.list_all_repositories_with_http_info(**kwargs)  # noqa: E501
             return data
 
-    def get_robot_by_idv1_with_http_info(self, project_name_or_id, robot_id, **kwargs):  # noqa: E501
-        """Get a robot account  # noqa: E501
+    def list_all_repositories_with_http_info(self, **kwargs):  # noqa: E501
+        """List all authorized repositories  # noqa: E501
 
-        This endpoint returns specific robot account information by robot ID.  # noqa: E501
+        List all authorized repositories  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_robot_by_idv1_with_http_info(project_name_or_id, robot_id, async_req=True)
+        >>> thread = api.list_all_repositories_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
-        :param int robot_id: Robot ID (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
-        :return: Robot
+        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
+        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
+        :param int page: The page number
+        :param int page_size: The size of per page
+        :return: list[Repository]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'robot_id', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_robot_by_idv1" % key
+                    " to method list_all_repositories" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `get_robot_by_idv1`")  # noqa: E501
-        # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `get_robot_by_idv1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_robot_by_idv1`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_all_repositories`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_all_repositories`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
 
         query_params = []
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots/{robot_id}', 'GET',
+            "/repositories",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Robot',  # noqa: E501
+            response_type="list[Repository]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def list_robot_v1(self, project_name_or_id, **kwargs):  # noqa: E501
-        """Get all robot accounts of specified project  # noqa: E501
+    def list_repositories(self, project_name, **kwargs):  # noqa: E501
+        """List repositories  # noqa: E501
 
-        Get all robot accounts of specified project  # noqa: E501
+        List repositories of the specified project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_robot_v1(project_name_or_id, async_req=True)
+        >>> thread = api.list_repositories(project_name, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
+        :param str project_name: The name of the project (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
-        :param int page: The page number
-        :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
-        :return: list[Robot]
+        :param int page: The page number
+        :param int page_size: The size of per page
+        :return: list[Repository]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_robot_v1_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_repositories_with_http_info(project_name, **kwargs)  # noqa: E501
         else:
-            (data) = self.list_robot_v1_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
+            (data) = self.list_repositories_with_http_info(project_name, **kwargs)  # noqa: E501
             return data
 
-    def list_robot_v1_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
-        """Get all robot accounts of specified project  # noqa: E501
+    def list_repositories_with_http_info(self, project_name, **kwargs):  # noqa: E501
+        """List repositories  # noqa: E501
 
-        Get all robot accounts of specified project  # noqa: E501
+        List repositories of the specified project  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_robot_v1_with_http_info(project_name_or_id, async_req=True)
+        >>> thread = api.list_repositories_with_http_info(project_name, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
+        :param str project_name: The name of the project (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
-        :param int page: The page number
-        :param int page_size: The size of per page
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
-        :return: list[Robot]
+        :param int page: The page number
+        :param int page_size: The size of per page
+        :return: list[Repository]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'x_request_id', 'x_is_resource_name', 'page', 'page_size', 'q', 'sort']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "x_request_id",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_robot_v1" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_repositories" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_robot_v1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_robot_v1`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_robot_v1`, must be a value less than or equal to `100`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name' is set
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `list_repositories`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_repositories`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_repositories`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots', 'GET',
+            "/projects/{project_name}/repositories",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Robot]',  # noqa: E501
+            response_type="list[Repository]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def update_robot_v1(self, project_name_or_id, robot_id, robot, **kwargs):  # noqa: E501
-        """Update status of robot account.  # noqa: E501
+    def update_repository(self, project_name, repository_name, repository, **kwargs):  # noqa: E501
+        """Update repository  # noqa: E501
 
-        Used to disable/enable a specified robot account.  # noqa: E501
+        Update the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_robot_v1(project_name_or_id, robot_id, robot, async_req=True)
+        >>> thread = api.update_repository(project_name, repository_name, repository, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
-        :param int robot_id: Robot ID (required)
-        :param Robot robot: The JSON object of a robot account. (required)
+        :param str project_name: The name of the project (required)
+        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
+        :param Repository repository: The JSON object of repository. (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_robot_v1_with_http_info(project_name_or_id, robot_id, robot, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_repository_with_http_info(
+                project_name, repository_name, repository, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_robot_v1_with_http_info(project_name_or_id, robot_id, robot, **kwargs)  # noqa: E501
+            (data) = self.update_repository_with_http_info(
+                project_name, repository_name, repository, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_robot_v1_with_http_info(self, project_name_or_id, robot_id, robot, **kwargs):  # noqa: E501
-        """Update status of robot account.  # noqa: E501
+    def update_repository_with_http_info(
+        self, project_name, repository_name, repository, **kwargs
+    ):  # noqa: E501
+        """Update repository  # noqa: E501
 
-        Used to disable/enable a specified robot account.  # noqa: E501
+        Update the repository specified by name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_robot_v1_with_http_info(project_name_or_id, robot_id, robot, async_req=True)
+        >>> thread = api.update_repository_with_http_info(project_name, repository_name, repository, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str project_name_or_id: The name or id of the project (required)
-        :param int robot_id: Robot ID (required)
-        :param Robot robot: The JSON object of a robot account. (required)
+        :param str project_name: The name of the project (required)
+        :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
+        :param Repository repository: The JSON object of repository. (required)
         :param str x_request_id: An unique ID for the request
-        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'robot_id', 'robot', 'x_request_id', 'x_is_resource_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "repository", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_robot_v1" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_repository" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `update_robot_v1`")  # noqa: E501
-        # verify the required parameter 'robot_id' is set
-        if self.api_client.client_side_validation and ('robot_id' not in params or
-                                                       params['robot_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot_id` when calling `update_robot_v1`")  # noqa: E501
-        # verify the required parameter 'robot' is set
-        if self.api_client.client_side_validation and ('robot' not in params or
-                                                       params['robot'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `robot` when calling `update_robot_v1`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_robot_v1`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name' is set
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `update_repository`"
+            )  # noqa: E501
+        # verify the required parameter 'repository_name' is set
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `update_repository`"
+            )  # noqa: E501
+        # verify the required parameter 'repository' is set
+        if self.api_client.client_side_validation and (
+            "repository" not in params or params["repository"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository` when calling `update_repository`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_repository`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
-        if 'robot_id' in params:
-            path_params['robot_id'] = params['robot_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'robot' in params:
-            body_params = params['robot']
+        if "repository" in params:
+            body_params = params["repository"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/robots/{robot_id}', 'PUT',
+            "/projects/{project_name}/repositories/{repository_name}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/scan_all_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/scan_all_api.py`

 * *Files 11% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param Schedule schedule: Create a schedule or a manual trigger for the scan all job. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_scan_all_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.create_scan_all_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def create_scan_all_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Create a schedule or a manual trigger for the scan all job.  # noqa: E501
@@ -69,79 +69,89 @@
         :param Schedule schedule: Create a schedule or a manual trigger for the scan all job. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_scan_all_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `create_scan_all_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_scan_all_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `create_scan_all_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_scan_all_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/scanAll/schedule', 'POST',
+            "/system/scanAll/schedule",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_latest_scan_all_metrics(self, **kwargs):  # noqa: E501
         """Get the metrics of the latest scan all process  # noqa: E501
 
         Get the metrics of the latest scan all process  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -150,16 +160,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Stats
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_latest_scan_all_metrics_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_latest_scan_all_metrics_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_latest_scan_all_metrics_with_http_info(self, **kwargs):  # noqa: E501
         """Get the metrics of the latest scan all process  # noqa: E501
@@ -173,73 +183,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Stats
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_latest_scan_all_metrics" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_latest_scan_all_metrics`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_latest_scan_all_metrics`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scans/all/metrics', 'GET',
+            "/scans/all/metrics",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Stats',  # noqa: E501
+            response_type="Stats",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_latest_scheduled_scan_all_metrics(self, **kwargs):  # noqa: E501
         """Get the metrics of the latest scheduled scan all process  # noqa: E501
 
         Get the metrics of the latest scheduled scan all process  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -248,19 +265,21 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Stats
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_latest_scheduled_scan_all_metrics_with_http_info(**kwargs)  # noqa: E501
         else:
-            (data) = self.get_latest_scheduled_scan_all_metrics_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_latest_scheduled_scan_all_metrics_with_http_info(
+                **kwargs
+            )  # noqa: E501
             return data
 
     def get_latest_scheduled_scan_all_metrics_with_http_info(self, **kwargs):  # noqa: E501
         """Get the metrics of the latest scheduled scan all process  # noqa: E501
 
         Get the metrics of the latest scheduled scan all process  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -271,73 +290,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Stats
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_latest_scheduled_scan_all_metrics" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_latest_scheduled_scan_all_metrics`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_latest_scheduled_scan_all_metrics`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scans/schedule/metrics', 'GET',
+            "/scans/schedule/metrics",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Stats',  # noqa: E501
+            response_type="Stats",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scan_all_schedule(self, **kwargs):  # noqa: E501
         """Get scan all's schedule.  # noqa: E501
 
         This endpoint is for getting a schedule for the scan all job, which scans all of images in Harbor.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -346,16 +372,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Schedule
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_scan_all_schedule_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_scan_all_schedule_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_scan_all_schedule_with_http_info(self, **kwargs):  # noqa: E501
         """Get scan all's schedule.  # noqa: E501
@@ -369,73 +395,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Schedule
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scan_all_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scan_all_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scan_all_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/scanAll/schedule', 'GET',
+            "/system/scanAll/schedule",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Schedule',  # noqa: E501
+            response_type="Schedule",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_scan_all(self, **kwargs):  # noqa: E501
         """Stop scanAll job execution  # noqa: E501
 
         Stop scanAll job execution  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -444,16 +477,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.stop_scan_all_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.stop_scan_all_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def stop_scan_all_with_http_info(self, **kwargs):  # noqa: E501
         """Stop scanAll job execution  # noqa: E501
@@ -467,73 +500,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_scan_all" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_scan_all" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_scan_all`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_scan_all`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/scanAll/stop', 'POST',
+            "/system/scanAll/stop",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_scan_all_schedule(self, schedule, **kwargs):  # noqa: E501
         """Update scan all's schedule.  # noqa: E501
 
         This endpoint is for updating the schedule of scan all job, which scans all of images in Harbor.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -543,16 +582,16 @@
         :param async_req bool
         :param Schedule schedule: Updates the schedule of scan all job, which scans all of images in Harbor. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_scan_all_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
         else:
             (data) = self.update_scan_all_schedule_with_http_info(schedule, **kwargs)  # noqa: E501
             return data
 
     def update_scan_all_schedule_with_http_info(self, schedule, **kwargs):  # noqa: E501
         """Update scan all's schedule.  # noqa: E501
@@ -567,72 +606,82 @@
         :param Schedule schedule: Updates the schedule of scan all job, which scans all of images in Harbor. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['schedule', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["schedule", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_scan_all_schedule" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'schedule' is set
-        if self.api_client.client_side_validation and ('schedule' not in params or
-                                                       params['schedule'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `schedule` when calling `update_scan_all_schedule`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_scan_all_schedule`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "schedule" not in params or params["schedule"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `schedule` when calling `update_scan_all_schedule`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_scan_all_schedule`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'schedule' in params:
-            body_params = params['schedule']
+        if "schedule" in params:
+            body_params = params["schedule"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/scanAll/schedule', 'PUT',
+            "/system/scanAll/schedule",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/scan_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/scan_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -29,15 +29,17 @@
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def get_report_log(self, project_name, repository_name, reference, report_id, **kwargs):  # noqa: E501
+    def get_report_log(
+        self, project_name, repository_name, reference, report_id, **kwargs
+    ):  # noqa: E501
         """Get the log of the scan report  # noqa: E501
 
         Get the log of the scan report  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_report_log(project_name, repository_name, reference, report_id, async_req=True)
         >>> result = thread.get()
@@ -48,22 +50,28 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str report_id: The report id to get the log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_report_log_with_http_info(project_name, repository_name, reference, report_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_report_log_with_http_info(
+                project_name, repository_name, reference, report_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_report_log_with_http_info(project_name, repository_name, reference, report_id, **kwargs)  # noqa: E501
+            (data) = self.get_report_log_with_http_info(
+                project_name, repository_name, reference, report_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_report_log_with_http_info(self, project_name, repository_name, reference, report_id, **kwargs):  # noqa: E501
+    def get_report_log_with_http_info(
+        self, project_name, repository_name, reference, report_id, **kwargs
+    ):  # noqa: E501
         """Get the log of the scan report  # noqa: E501
 
         Get the log of the scan report  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_report_log_with_http_info(project_name, repository_name, reference, report_id, async_req=True)
         >>> result = thread.get()
@@ -75,97 +83,119 @@
         :param str report_id: The report id to get the log (required)
         :param str x_request_id: An unique ID for the request
         :return: str
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'report_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name",
+            "repository_name",
+            "reference",
+            "report_id",
+            "x_request_id",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_report_log" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_report_log" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `get_report_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `get_report_log`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `get_report_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `get_report_log`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `get_report_log`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `get_report_log`"
+            )  # noqa: E501
         # verify the required parameter 'report_id' is set
-        if self.api_client.client_side_validation and ('report_id' not in params or
-                                                       params['report_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `report_id` when calling `get_report_log`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_report_log`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "report_id" not in params or params["report_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `report_id` when calling `get_report_log`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_report_log`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
-        if 'report_id' in params:
-            path_params['report_id'] = params['report_id']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
+        if "report_id" in params:
+            path_params["report_id"] = params["report_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/plain"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/{report_id}/log', 'GET',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/{report_id}/log",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='str',  # noqa: E501
+            response_type="str",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def scan_artifact(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """Scan the artifact  # noqa: E501
 
         Scan the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -177,22 +207,28 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.scan_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.scan_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.scan_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.scan_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def scan_artifact_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def scan_artifact_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Scan the artifact  # noqa: E501
 
         Scan the specified artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.scan_artifact_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -203,91 +239,106 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "reference", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method scan_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method scan_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `scan_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `scan_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `scan_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `scan_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `scan_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `scan_artifact`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `scan_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `scan_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def stop_scan_artifact(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
         """Cancelling a scan job for a particular artifact  # noqa: E501
 
         Cancelling a scan job for a particular artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -299,22 +350,28 @@
         :param str repository_name: The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb (required)
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.stop_scan_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.stop_scan_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.stop_scan_artifact_with_http_info(project_name, repository_name, reference, **kwargs)  # noqa: E501
+            (data) = self.stop_scan_artifact_with_http_info(
+                project_name, repository_name, reference, **kwargs
+            )  # noqa: E501
             return data
 
-    def stop_scan_artifact_with_http_info(self, project_name, repository_name, reference, **kwargs):  # noqa: E501
+    def stop_scan_artifact_with_http_info(
+        self, project_name, repository_name, reference, **kwargs
+    ):  # noqa: E501
         """Cancelling a scan job for a particular artifact  # noqa: E501
 
         Cancelling a scan job for a particular artifact  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.stop_scan_artifact_with_http_info(project_name, repository_name, reference, async_req=True)
         >>> result = thread.get()
@@ -325,84 +382,99 @@
         :param str reference: The reference of the artifact, can be digest or tag (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name', 'repository_name', 'reference', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name", "repository_name", "reference", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method stop_scan_artifact" % key
+                    "Got an unexpected keyword argument '%s'" " to method stop_scan_artifact" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name' is set
-        if self.api_client.client_side_validation and ('project_name' not in params or
-                                                       params['project_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name` when calling `stop_scan_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name" not in params or params["project_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name` when calling `stop_scan_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'repository_name' is set
-        if self.api_client.client_side_validation and ('repository_name' not in params or
-                                                       params['repository_name'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `repository_name` when calling `stop_scan_artifact`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "repository_name" not in params or params["repository_name"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `repository_name` when calling `stop_scan_artifact`"
+            )  # noqa: E501
         # verify the required parameter 'reference' is set
-        if self.api_client.client_side_validation and ('reference' not in params or
-                                                       params['reference'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `reference` when calling `stop_scan_artifact`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `stop_scan_artifact`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "reference" not in params or params["reference"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `reference` when calling `stop_scan_artifact`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `stop_scan_artifact`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name' in params:
-            path_params['project_name'] = params['project_name']  # noqa: E501
-        if 'repository_name' in params:
-            path_params['repository_name'] = params['repository_name']  # noqa: E501
-        if 'reference' in params:
-            path_params['reference'] = params['reference']  # noqa: E501
+        if "project_name" in params:
+            path_params["project_name"] = params["project_name"]  # noqa: E501
+        if "repository_name" in params:
+            path_params["repository_name"] = params["repository_name"]  # noqa: E501
+        if "reference" in params:
+            path_params["reference"] = params["reference"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/stop', 'POST',
+            "/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/stop",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/scan_data_export_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/scan_data_export_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -46,16 +46,16 @@
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :param str format: The format of the data to be exported. e.g. CSV or PDF
         :return: file
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.download_scan_data_with_http_info(execution_id, **kwargs)  # noqa: E501
         else:
             (data) = self.download_scan_data_with_http_info(execution_id, **kwargs)  # noqa: E501
             return data
 
     def download_scan_data_with_http_info(self, execution_id, **kwargs):  # noqa: E501
         """Download the scan data export file  # noqa: E501
@@ -71,81 +71,88 @@
         :param str x_request_id: An unique ID for the request
         :param str format: The format of the data to be exported. e.g. CSV or PDF
         :return: file
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['execution_id', 'x_request_id', 'format']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["execution_id", "x_request_id", "format"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method download_scan_data" % key
+                    "Got an unexpected keyword argument '%s'" " to method download_scan_data" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `download_scan_data`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `download_scan_data`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `download_scan_data`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `download_scan_data`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
-        if 'format' in params:
-            query_params.append(('format', params['format']))  # noqa: E501
+        if "format" in params:
+            query_params.append(("format", params["format"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/csv'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(["text/csv"])  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/export/cve/download/{execution_id}', 'GET',
+            "/export/cve/download/{execution_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='file',  # noqa: E501
+            response_type="file",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def export_scan_data(self, x_scan_data_type, criteria, **kwargs):  # noqa: E501
         """Export scan data for selected projects  # noqa: E501
 
         Export scan data for selected projects  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -156,19 +163,23 @@
         :param str x_scan_data_type: The type of scan data to export (required)
         :param ScanDataExportRequest criteria: The criteria for the export (required)
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportJob
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.export_scan_data_with_http_info(x_scan_data_type, criteria, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.export_scan_data_with_http_info(
+                x_scan_data_type, criteria, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.export_scan_data_with_http_info(x_scan_data_type, criteria, **kwargs)  # noqa: E501
+            (data) = self.export_scan_data_with_http_info(
+                x_scan_data_type, criteria, **kwargs
+            )  # noqa: E501
             return data
 
     def export_scan_data_with_http_info(self, x_scan_data_type, criteria, **kwargs):  # noqa: E501
         """Export scan data for selected projects  # noqa: E501
 
         Export scan data for selected projects  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -181,85 +192,97 @@
         :param ScanDataExportRequest criteria: The criteria for the export (required)
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportJob
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_scan_data_type', 'criteria', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_scan_data_type", "criteria", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method export_scan_data" % key
+                    "Got an unexpected keyword argument '%s'" " to method export_scan_data" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'x_scan_data_type' is set
-        if self.api_client.client_side_validation and ('x_scan_data_type' not in params or
-                                                       params['x_scan_data_type'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `x_scan_data_type` when calling `export_scan_data`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_scan_data_type" not in params or params["x_scan_data_type"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `x_scan_data_type` when calling `export_scan_data`"
+            )  # noqa: E501
         # verify the required parameter 'criteria' is set
-        if self.api_client.client_side_validation and ('criteria' not in params or
-                                                       params['criteria'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `criteria` when calling `export_scan_data`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `export_scan_data`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "criteria" not in params or params["criteria"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `criteria` when calling `export_scan_data`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `export_scan_data`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_scan_data_type' in params:
-            header_params['X-Scan-Data-Type'] = params['x_scan_data_type']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_scan_data_type" in params:
+            header_params["X-Scan-Data-Type"] = params["x_scan_data_type"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'criteria' in params:
-            body_params = params['criteria']
+        if "criteria" in params:
+            body_params = params["criteria"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/export/cve', 'POST',
+            "/export/cve",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScanDataExportJob',  # noqa: E501
+            response_type="ScanDataExportJob",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scan_data_export_execution(self, execution_id, **kwargs):  # noqa: E501
         """Get the specific scan data export execution  # noqa: E501
 
         Get the scan data export execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -269,19 +292,23 @@
         :param async_req bool
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportExecution
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_scan_data_export_execution_with_http_info(execution_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_scan_data_export_execution_with_http_info(
+                execution_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_scan_data_export_execution_with_http_info(execution_id, **kwargs)  # noqa: E501
+            (data) = self.get_scan_data_export_execution_with_http_info(
+                execution_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_scan_data_export_execution_with_http_info(self, execution_id, **kwargs):  # noqa: E501
         """Get the specific scan data export execution  # noqa: E501
 
         Get the scan data export execution specified by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -293,79 +320,89 @@
         :param int execution_id: Execution ID (required)
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportExecution
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['execution_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["execution_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scan_data_export_execution" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'execution_id' is set
-        if self.api_client.client_side_validation and ('execution_id' not in params or
-                                                       params['execution_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `execution_id` when calling `get_scan_data_export_execution`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scan_data_export_execution`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "execution_id" not in params or params["execution_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `execution_id` when calling `get_scan_data_export_execution`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scan_data_export_execution`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'execution_id' in params:
-            path_params['execution_id'] = params['execution_id']  # noqa: E501
+        if "execution_id" in params:
+            path_params["execution_id"] = params["execution_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/export/cve/execution/{execution_id}', 'GET',
+            "/export/cve/execution/{execution_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScanDataExportExecution',  # noqa: E501
+            response_type="ScanDataExportExecution",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scan_data_export_execution_list(self, **kwargs):  # noqa: E501
         """Get a list of specific scan data export execution jobs for a specified user  # noqa: E501
 
         Get a list of specific scan data export execution jobs for a specified user  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -374,16 +411,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportExecutionList
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_scan_data_export_execution_list_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_scan_data_export_execution_list_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_scan_data_export_execution_list_with_http_info(self, **kwargs):  # noqa: E501
         """Get a list of specific scan data export execution jobs for a specified user  # noqa: E501
@@ -397,66 +434,73 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: ScanDataExportExecutionList
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scan_data_export_execution_list" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scan_data_export_execution_list`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scan_data_export_execution_list`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/export/cve/executions', 'GET',
+            "/export/cve/executions",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScanDataExportExecutionList',  # noqa: E501
+            response_type="ScanDataExportExecutionList",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/scanner_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/scanner_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param ScannerRegistrationReq registration: A scanner registration to be created. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_scanner_with_http_info(registration, **kwargs)  # noqa: E501
         else:
             (data) = self.create_scanner_with_http_info(registration, **kwargs)  # noqa: E501
             return data
 
     def create_scanner_with_http_info(self, registration, **kwargs):  # noqa: E501
         """Create a scanner registration  # noqa: E501
@@ -69,79 +69,88 @@
         :param ScannerRegistrationReq registration: A scanner registration to be created. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration' is set
-        if self.api_client.client_side_validation and ('registration' not in params or
-                                                       params['registration'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration` when calling `create_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration" not in params or params["registration"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration` when calling `create_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registration' in params:
-            body_params = params['registration']
+        if "registration" in params:
+            body_params = params["registration"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners', 'POST',
+            "/scanners",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_scanner(self, registration_id, **kwargs):  # noqa: E501
         """Delete a scanner registration  # noqa: E501
 
         Deletes the specified scanner registration.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -151,16 +160,16 @@
         :param async_req bool
         :param str registration_id: The scanner registration identifier. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_scanner_with_http_info(registration_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_scanner_with_http_info(registration_id, **kwargs)  # noqa: E501
             return data
 
     def delete_scanner_with_http_info(self, registration_id, **kwargs):  # noqa: E501
         """Delete a scanner registration  # noqa: E501
@@ -175,79 +184,88 @@
         :param str registration_id: The scanner registration identifier. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `delete_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `delete_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}', 'DELETE',
+            "/scanners/{registration_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScannerRegistration',  # noqa: E501
+            response_type="ScannerRegistration",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scanner(self, registration_id, **kwargs):  # noqa: E501
         """Get a scanner registration details  # noqa: E501
 
         Retruns the details of the specified scanner registration.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -257,16 +275,16 @@
         :param async_req bool
         :param str registration_id: The scanner registration identifer. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_scanner_with_http_info(registration_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_scanner_with_http_info(registration_id, **kwargs)  # noqa: E501
             return data
 
     def get_scanner_with_http_info(self, registration_id, **kwargs):  # noqa: E501
         """Get a scanner registration details  # noqa: E501
@@ -281,79 +299,88 @@
         :param str registration_id: The scanner registration identifer. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerRegistration
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `get_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `get_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}', 'GET',
+            "/scanners/{registration_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScannerRegistration',  # noqa: E501
+            response_type="ScannerRegistration",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_scanner_metadata(self, registration_id, **kwargs):  # noqa: E501
         """Get the metadata of the specified scanner registration  # noqa: E501
 
         Get the metadata of the specified scanner registration, including the capabilities and customized properties.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -363,19 +390,21 @@
         :param async_req bool
         :param str registration_id: The scanner registration identifier. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerAdapterMetadata
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_scanner_metadata_with_http_info(registration_id, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_scanner_metadata_with_http_info(registration_id, **kwargs)  # noqa: E501
+            (data) = self.get_scanner_metadata_with_http_info(
+                registration_id, **kwargs
+            )  # noqa: E501
             return data
 
     def get_scanner_metadata_with_http_info(self, registration_id, **kwargs):  # noqa: E501
         """Get the metadata of the specified scanner registration  # noqa: E501
 
         Get the metadata of the specified scanner registration, including the capabilities and customized properties.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -387,79 +416,89 @@
         :param str registration_id: The scanner registration identifier. (required)
         :param str x_request_id: An unique ID for the request
         :return: ScannerAdapterMetadata
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_scanner_metadata" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `get_scanner_metadata`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_scanner_metadata`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `get_scanner_metadata`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_scanner_metadata`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}/metadata', 'GET',
+            "/scanners/{registration_id}/metadata",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ScannerAdapterMetadata',  # noqa: E501
+            response_type="ScannerAdapterMetadata",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_scanners(self, **kwargs):  # noqa: E501
         """List scanner registrations  # noqa: E501
 
         Returns a list of currently configured scanner registrations.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -472,16 +511,16 @@
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScannerRegistration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_scanners_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_scanners_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_scanners_with_http_info(self, **kwargs):  # noqa: E501
         """List scanner registrations  # noqa: E501
@@ -499,83 +538,93 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScannerRegistration]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "q", "sort", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_scanners" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_scanners" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_scanners`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_scanners`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_scanners`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_scanners`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners', 'GET',
+            "/scanners",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ScannerRegistration]',  # noqa: E501
+            response_type="list[ScannerRegistration]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def ping_scanner(self, settings, **kwargs):  # noqa: E501
         """Tests scanner registration settings  # noqa: E501
 
         Pings scanner adapter to test endpoint URL and authorization settings.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -585,16 +634,16 @@
         :param async_req bool
         :param ScannerRegistrationSettings settings: A scanner registration settings to be tested. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.ping_scanner_with_http_info(settings, **kwargs)  # noqa: E501
         else:
             (data) = self.ping_scanner_with_http_info(settings, **kwargs)  # noqa: E501
             return data
 
     def ping_scanner_with_http_info(self, settings, **kwargs):  # noqa: E501
         """Tests scanner registration settings  # noqa: E501
@@ -609,79 +658,88 @@
         :param ScannerRegistrationSettings settings: A scanner registration settings to be tested. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['settings', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["settings", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method ping_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method ping_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'settings' is set
-        if self.api_client.client_side_validation and ('settings' not in params or
-                                                       params['settings'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `settings` when calling `ping_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `ping_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "settings" not in params or params["settings"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `settings` when calling `ping_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `ping_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'settings' in params:
-            body_params = params['settings']
+        if "settings" in params:
+            body_params = params["settings"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/ping', 'POST',
+            "/scanners/ping",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def set_scanner_as_default(self, registration_id, payload, **kwargs):  # noqa: E501
         """Set system default scanner registration  # noqa: E501
 
         Set the specified scanner registration as the system default one.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -692,22 +750,28 @@
         :param str registration_id: The scanner registration identifier. (required)
         :param IsDefault payload: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.set_scanner_as_default_with_http_info(registration_id, payload, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.set_scanner_as_default_with_http_info(
+                registration_id, payload, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.set_scanner_as_default_with_http_info(registration_id, payload, **kwargs)  # noqa: E501
+            (data) = self.set_scanner_as_default_with_http_info(
+                registration_id, payload, **kwargs
+            )  # noqa: E501
             return data
 
-    def set_scanner_as_default_with_http_info(self, registration_id, payload, **kwargs):  # noqa: E501
+    def set_scanner_as_default_with_http_info(
+        self, registration_id, payload, **kwargs
+    ):  # noqa: E501
         """Set system default scanner registration  # noqa: E501
 
         Set the specified scanner registration as the system default one.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.set_scanner_as_default_with_http_info(registration_id, payload, async_req=True)
         >>> result = thread.get()
@@ -717,85 +781,98 @@
         :param IsDefault payload: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'payload', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "payload", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method set_scanner_as_default" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `set_scanner_as_default`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `set_scanner_as_default`"
+            )  # noqa: E501
         # verify the required parameter 'payload' is set
-        if self.api_client.client_side_validation and ('payload' not in params or
-                                                       params['payload'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `payload` when calling `set_scanner_as_default`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `set_scanner_as_default`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "payload" not in params or params["payload"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `payload` when calling `set_scanner_as_default`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `set_scanner_as_default`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'payload' in params:
-            body_params = params['payload']
+        if "payload" in params:
+            body_params = params["payload"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}', 'PATCH',
+            "/scanners/{registration_id}",
+            "PATCH",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_scanner(self, registration_id, registration, **kwargs):  # noqa: E501
         """Update a scanner registration  # noqa: E501
 
         Updates the specified scanner registration.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -806,19 +883,23 @@
         :param str registration_id: The scanner registration identifier. (required)
         :param ScannerRegistrationReq registration: A scanner registraiton to be updated. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_scanner_with_http_info(registration_id, registration, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_scanner_with_http_info(
+                registration_id, registration, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_scanner_with_http_info(registration_id, registration, **kwargs)  # noqa: E501
+            (data) = self.update_scanner_with_http_info(
+                registration_id, registration, **kwargs
+            )  # noqa: E501
             return data
 
     def update_scanner_with_http_info(self, registration_id, registration, **kwargs):  # noqa: E501
         """Update a scanner registration  # noqa: E501
 
         Updates the specified scanner registration.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
@@ -831,78 +912,90 @@
         :param ScannerRegistrationReq registration: A scanner registraiton to be updated. (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['registration_id', 'registration', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["registration_id", "registration", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_scanner" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_scanner" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'registration_id' is set
-        if self.api_client.client_side_validation and ('registration_id' not in params or
-                                                       params['registration_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration_id` when calling `update_scanner`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration_id" not in params or params["registration_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration_id` when calling `update_scanner`"
+            )  # noqa: E501
         # verify the required parameter 'registration' is set
-        if self.api_client.client_side_validation and ('registration' not in params or
-                                                       params['registration'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `registration` when calling `update_scanner`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_scanner`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "registration" not in params or params["registration"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `registration` when calling `update_scanner`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_scanner`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'registration_id' in params:
-            path_params['registration_id'] = params['registration_id']  # noqa: E501
+        if "registration_id" in params:
+            path_params["registration_id"] = params["registration_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'registration' in params:
-            body_params = params['registration']
+        if "registration" in params:
+            body_params = params["registration"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/scanners/{registration_id}', 'PUT',
+            "/scanners/{registration_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/schedule_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/schedule_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param str job_type: The type of the job. 'all' stands for all job types, current only support query with all (required)
         :param str x_request_id: An unique ID for the request
         :return: SchedulerStatus
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_schedule_paused_with_http_info(job_type, **kwargs)  # noqa: E501
         else:
             (data) = self.get_schedule_paused_with_http_info(job_type, **kwargs)  # noqa: E501
             return data
 
     def get_schedule_paused_with_http_info(self, job_type, **kwargs):  # noqa: E501
         """get_schedule_paused  # noqa: E501
@@ -69,79 +69,88 @@
         :param str job_type: The type of the job. 'all' stands for all job types, current only support query with all (required)
         :param str x_request_id: An unique ID for the request
         :return: SchedulerStatus
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['job_type', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["job_type", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_schedule_paused" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_schedule_paused" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'job_type' is set
-        if self.api_client.client_side_validation and ('job_type' not in params or
-                                                       params['job_type'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `job_type` when calling `get_schedule_paused`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_schedule_paused`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "job_type" not in params or params["job_type"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `job_type` when calling `get_schedule_paused`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_schedule_paused`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'job_type' in params:
-            path_params['job_type'] = params['job_type']  # noqa: E501
+        if "job_type" in params:
+            path_params["job_type"] = params["job_type"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/schedules/{job_type}/paused', 'GET',
+            "/schedules/{job_type}/paused",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SchedulerStatus',  # noqa: E501
+            response_type="SchedulerStatus",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_schedules(self, **kwargs):  # noqa: E501
         """list_schedules  # noqa: E501
 
         List schedules  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -152,16 +161,16 @@
         :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScheduleTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_schedules_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_schedules_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_schedules_with_http_info(self, **kwargs):  # noqa: E501
         """list_schedules  # noqa: E501
@@ -177,72 +186,82 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[ScheduleTask]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_schedules" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_schedules" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_schedules`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_schedules`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_schedules`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_schedules`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/schedules', 'GET',
+            "/schedules",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[ScheduleTask]',  # noqa: E501
+            response_type="list[ScheduleTask]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/search_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/search_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param str q: Search parameter for project and repository name. (required)
         :param str x_request_id: An unique ID for the request
         :return: Search
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.search_with_http_info(q, **kwargs)  # noqa: E501
         else:
             (data) = self.search_with_http_info(q, **kwargs)  # noqa: E501
             return data
 
     def search_with_http_info(self, q, **kwargs):  # noqa: E501
         """Search for projects, repositories and helm charts  # noqa: E501
@@ -69,72 +69,79 @@
         :param str q: Search parameter for project and repository name. (required)
         :param str x_request_id: An unique ID for the request
         :return: Search
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['q', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["q", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search" % key
-                )
+                raise TypeError("Got an unexpected keyword argument '%s'" " to method search" % key)
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'q' is set
-        if self.api_client.client_side_validation and ('q' not in params or
-                                                       params['q'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `q` when calling `search`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "q" not in params or params["q"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `q` when calling `search`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/search', 'GET',
+            "/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Search',  # noqa: E501
+            response_type="Search",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/statistic_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/statistic_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Statistic
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_statistic_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_statistic_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_statistic_with_http_info(self, **kwargs):  # noqa: E501
         """Get the statistic information about the projects and repositories  # noqa: E501
@@ -67,66 +67,72 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: Statistic
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_statistic" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_statistic" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_statistic`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_statistic`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/statistics', 'GET',
+            "/statistics",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='Statistic',  # noqa: E501
+            response_type="Statistic",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/system_cve_allowlist_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/system_cve_allowlist_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: CVEAllowlist
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_system_cve_allowlist_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_system_cve_allowlist_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_system_cve_allowlist_with_http_info(self, **kwargs):  # noqa: E501
         """Get the system level allowlist of CVE.  # noqa: E501
@@ -67,73 +67,80 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: CVEAllowlist
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_system_cve_allowlist" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_system_cve_allowlist`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_system_cve_allowlist`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/CVEAllowlist', 'GET',
+            "/system/CVEAllowlist",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CVEAllowlist',  # noqa: E501
+            response_type="CVEAllowlist",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def put_system_cve_allowlist(self, **kwargs):  # noqa: E501
         """Update the system level allowlist of CVE.  # noqa: E501
 
         This API overwrites the system level allowlist of CVE with the list in request body.  Only system Admin has permission to call this API.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -143,16 +150,16 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param CVEAllowlist allowlist: The allowlist with new content
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.put_system_cve_allowlist_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.put_system_cve_allowlist_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def put_system_cve_allowlist_with_http_info(self, **kwargs):  # noqa: E501
         """Update the system level allowlist of CVE.  # noqa: E501
@@ -167,68 +174,75 @@
         :param str x_request_id: An unique ID for the request
         :param CVEAllowlist allowlist: The allowlist with new content
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'allowlist']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "allowlist"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method put_system_cve_allowlist" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `put_system_cve_allowlist`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `put_system_cve_allowlist`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'allowlist' in params:
-            body_params = params['allowlist']
+        if "allowlist" in params:
+            body_params = params["allowlist"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/system/CVEAllowlist', 'PUT',
+            "/system/CVEAllowlist",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/systeminfo_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/systeminfo_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: file
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_cert_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_cert_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_cert_with_http_info(self, **kwargs):  # noqa: E501
         """Get default root certificate.  # noqa: E501
@@ -67,73 +67,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: file
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_cert" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_cert" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_cert`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_cert`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/octet-stream'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/octet-stream"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/systeminfo/getcert', 'GET',
+            "/systeminfo/getcert",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='file',  # noqa: E501
+            response_type="file",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_system_info(self, **kwargs):  # noqa: E501
         """Get general system info  # noqa: E501
 
         This API is for retrieving general system info, this can be called by anonymous request.  Some attributes will be omitted in the response when this API is called by anonymous request.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -142,16 +148,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: GeneralInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_system_info_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_system_info_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_system_info_with_http_info(self, **kwargs):  # noqa: E501
         """Get general system info  # noqa: E501
@@ -165,73 +171,79 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: GeneralInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_system_info" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_system_info" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_system_info`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_system_info`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/systeminfo', 'GET',
+            "/systeminfo",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GeneralInfo',  # noqa: E501
+            response_type="GeneralInfo",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_volumes(self, **kwargs):  # noqa: E501
         """Get system volume info (total/free size).  # noqa: E501
 
         This endpoint is for retrieving system volume info that only provides for admin user.  Note that the response only reflects the storage status of local disk.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -240,16 +252,16 @@
 
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: SystemInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_volumes_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.get_volumes_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def get_volumes_with_http_info(self, **kwargs):  # noqa: E501
         """Get system volume info (total/free size).  # noqa: E501
@@ -263,66 +275,72 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :return: SystemInfo
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_volumes" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_volumes" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_volumes`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_volumes`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/systeminfo/volumes', 'GET',
+            "/systeminfo/volumes",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SystemInfo',  # noqa: E501
+            response_type="SystemInfo",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/user_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/webhook_api.py`

 * *Files 24% similar despite different names*

```diff
@@ -17,1216 +17,1003 @@
 
 # python 2 and python 3 compatibility library
 import six
 
 from harbor_client.api_client import ApiClient
 
 
-class UserApi(object):
+class WebhookApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_user(self, user_req, **kwargs):  # noqa: E501
-        """Create a local user.  # noqa: E501
+    def create_webhook_policy_of_project(self, project_name_or_id, policy, **kwargs):  # noqa: E501
+        """Create project webhook policy.  # noqa: E501
 
-        This API can be used only when the authentication mode is for local DB.  When self registration is disabled.  # noqa: E501
+        This endpoint create a webhook policy if the project does not have one.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_user(user_req, async_req=True)
+        >>> thread = api.create_webhook_policy_of_project(project_name_or_id, policy, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param UserCreationReq user_req: The new user (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param WebhookPolicy policy: Properties \"targets\" and \"event_types\" needed. (required)
         :param str x_request_id: An unique ID for the request
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_user_with_http_info(user_req, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.create_webhook_policy_of_project_with_http_info(
+                project_name_or_id, policy, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.create_user_with_http_info(user_req, **kwargs)  # noqa: E501
+            (data) = self.create_webhook_policy_of_project_with_http_info(
+                project_name_or_id, policy, **kwargs
+            )  # noqa: E501
             return data
 
-    def create_user_with_http_info(self, user_req, **kwargs):  # noqa: E501
-        """Create a local user.  # noqa: E501
+    def create_webhook_policy_of_project_with_http_info(
+        self, project_name_or_id, policy, **kwargs
+    ):  # noqa: E501
+        """Create project webhook policy.  # noqa: E501
 
-        This API can be used only when the authentication mode is for local DB.  When self registration is disabled.  # noqa: E501
+        This endpoint create a webhook policy if the project does not have one.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_user_with_http_info(user_req, async_req=True)
+        >>> thread = api.create_webhook_policy_of_project_with_http_info(project_name_or_id, policy, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param UserCreationReq user_req: The new user (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param WebhookPolicy policy: Properties \"targets\" and \"event_types\" needed. (required)
         :param str x_request_id: An unique ID for the request
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_req', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "policy",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create_user" % key
+                    " to method create_webhook_policy_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'user_req' is set
-        if self.api_client.client_side_validation and ('user_req' not in params or
-                                                       params['user_req'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_req` when calling `create_user`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_user`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `create_webhook_policy_of_project`"
+            )  # noqa: E501
+        # verify the required parameter 'policy' is set
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `create_webhook_policy_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_webhook_policy_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'user_req' in params:
-            body_params = params['user_req']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users', 'POST',
+            "/projects/{project_name_or_id}/webhook/policies",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def delete_user(self, user_id, **kwargs):  # noqa: E501
-        """Mark a registered user as be removed.  # noqa: E501
+    def delete_webhook_policy_of_project(
+        self, project_name_or_id, webhook_policy_id, **kwargs
+    ):  # noqa: E501
+        """Delete webhook policy of a project  # noqa: E501
 
-        This endpoint let administrator of Harbor mark a registered user as removed.It actually won't be deleted from DB.   # noqa: E501
+        This endpoint is aimed to delete webhookpolicy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_user(user_id, async_req=True)
+        >>> thread = api.delete_webhook_policy_of_project(project_name_or_id, webhook_policy_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int user_id: User ID for marking as to be removed. (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int webhook_policy_id: The ID of the webhook policy (required)
         :param str x_request_id: An unique ID for the request
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_user_with_http_info(user_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.delete_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.delete_user_with_http_info(user_id, **kwargs)  # noqa: E501
+            (data) = self.delete_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def delete_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
-        """Mark a registered user as be removed.  # noqa: E501
+    def delete_webhook_policy_of_project_with_http_info(
+        self, project_name_or_id, webhook_policy_id, **kwargs
+    ):  # noqa: E501
+        """Delete webhook policy of a project  # noqa: E501
 
-        This endpoint let administrator of Harbor mark a registered user as removed.It actually won't be deleted from DB.   # noqa: E501
+        This endpoint is aimed to delete webhookpolicy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_user_with_http_info(user_id, async_req=True)
+        >>> thread = api.delete_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int user_id: User ID for marking as to be removed. (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int webhook_policy_id: The ID of the webhook policy (required)
         :param str x_request_id: An unique ID for the request
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "webhook_policy_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method delete_user" % key
+                    " to method delete_webhook_policy_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `delete_user`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_user`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `delete_webhook_policy_of_project`"
+            )  # noqa: E501
+        # verify the required parameter 'webhook_policy_id' is set
+        if self.api_client.client_side_validation and (
+            "webhook_policy_id" not in params or params["webhook_policy_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `webhook_policy_id` when calling `delete_webhook_policy_of_project`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_webhook_policy_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "webhook_policy_id" in params:
+            path_params["webhook_policy_id"] = params["webhook_policy_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}', 'DELETE',
+            "/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def get_current_user_info(self, **kwargs):  # noqa: E501
-        """Get current user info.  # noqa: E501
+    def get_supported_event_types(self, project_name_or_id, **kwargs):  # noqa: E501
+        """Get supported event types and notify types.  # noqa: E501
 
+        Get supportted event types and notify types.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_current_user_info(async_req=True)
+        >>> thread = api.get_supported_event_types(project_name_or_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
-        :return: UserResp
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: SupportedWebhookEventTypes
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_current_user_info_with_http_info(**kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_supported_event_types_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_current_user_info_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_supported_event_types_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_current_user_info_with_http_info(self, **kwargs):  # noqa: E501
-        """Get current user info.  # noqa: E501
+    def get_supported_event_types_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
+        """Get supported event types and notify types.  # noqa: E501
 
+        Get supportted event types and notify types.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_current_user_info_with_http_info(async_req=True)
+        >>> thread = api.get_supported_event_types_with_http_info(project_name_or_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
-        :return: UserResp
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: SupportedWebhookEventTypes
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_current_user_info" % key
+                    " to method get_supported_event_types" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_supported_event_types`"
+            )  # noqa: E501
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_current_user_info`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_supported_event_types`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/current', 'GET',
+            "/projects/{project_name_or_id}/webhook/events",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserResp',  # noqa: E501
+            response_type="SupportedWebhookEventTypes",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def get_current_user_permissions(self, **kwargs):  # noqa: E501
-        """Get current user permissions.  # noqa: E501
+    def get_webhook_policy_of_project(
+        self, project_name_or_id, webhook_policy_id, **kwargs
+    ):  # noqa: E501
+        """Get project webhook policy  # noqa: E501
 
+        This endpoint returns specified webhook policy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_current_user_permissions(async_req=True)
+        >>> thread = api.get_webhook_policy_of_project(project_name_or_id, webhook_policy_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int webhook_policy_id: The ID of the webhook policy (required)
         :param str x_request_id: An unique ID for the request
-        :param str scope: The scope for the permission
-        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'. 
-        :return: list[Permission]
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: WebhookPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_current_user_permissions_with_http_info(**kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.get_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.get_current_user_permissions_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def get_current_user_permissions_with_http_info(self, **kwargs):  # noqa: E501
-        """Get current user permissions.  # noqa: E501
+    def get_webhook_policy_of_project_with_http_info(
+        self, project_name_or_id, webhook_policy_id, **kwargs
+    ):  # noqa: E501
+        """Get project webhook policy  # noqa: E501
 
+        This endpoint returns specified webhook policy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_current_user_permissions_with_http_info(async_req=True)
+        >>> thread = api.get_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int webhook_policy_id: The ID of the webhook policy (required)
         :param str x_request_id: An unique ID for the request
-        :param str scope: The scope for the permission
-        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'. 
-        :return: list[Permission]
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: WebhookPolicy
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'scope', 'relative']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "webhook_policy_id",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_current_user_permissions" % key
+                    " to method get_webhook_policy_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `get_webhook_policy_of_project`"
+            )  # noqa: E501
+        # verify the required parameter 'webhook_policy_id' is set
+        if self.api_client.client_side_validation and (
+            "webhook_policy_id" not in params or params["webhook_policy_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `webhook_policy_id` when calling `get_webhook_policy_of_project`"
+            )  # noqa: E501
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_current_user_permissions`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_webhook_policy_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "webhook_policy_id" in params:
+            path_params["webhook_policy_id"] = params["webhook_policy_id"]  # noqa: E501
 
         query_params = []
-        if 'scope' in params:
-            query_params.append(('scope', params['scope']))  # noqa: E501
-        if 'relative' in params:
-            query_params.append(('relative', params['relative']))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/current/permissions', 'GET',
+            "/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[Permission]',  # noqa: E501
+            response_type="WebhookPolicy",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def get_user(self, user_id, **kwargs):  # noqa: E501
-        """Get a user's profile.  # noqa: E501
+    def last_trigger(self, project_name_or_id, **kwargs):  # noqa: E501
+        """Get project webhook policy last trigger info  # noqa: E501
 
+        This endpoint returns last trigger information of project webhook policy.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_user(user_id, async_req=True)
+        >>> thread = api.last_trigger(project_name_or_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int user_id: (required)
+        :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
-        :return: UserResp
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: list[WebhookLastTrigger]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.last_trigger_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
+            (data) = self.last_trigger_with_http_info(project_name_or_id, **kwargs)  # noqa: E501
             return data
 
-    def get_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
-        """Get a user's profile.  # noqa: E501
+    def last_trigger_with_http_info(self, project_name_or_id, **kwargs):  # noqa: E501
+        """Get project webhook policy last trigger info  # noqa: E501
 
+        This endpoint returns last trigger information of project webhook policy.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_user_with_http_info(user_id, async_req=True)
+        >>> thread = api.last_trigger_with_http_info(project_name_or_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int user_id: (required)
+        :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
-        :return: UserResp
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :return: list[WebhookLastTrigger]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["project_name_or_id", "x_request_id", "x_is_resource_name"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_user" % key
+                    "Got an unexpected keyword argument '%s'" " to method last_trigger" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `get_user`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_user`, length must be greater than or equal to `1`")  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `last_trigger`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `last_trigger`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}', 'GET',
+            "/projects/{project_name_or_id}/webhook/lasttrigger",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserResp',  # noqa: E501
+            response_type="list[WebhookLastTrigger]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def list_users(self, **kwargs):  # noqa: E501
-        """List users  # noqa: E501
+    def list_webhook_policies_of_project(self, project_name_or_id, **kwargs):  # noqa: E501
+        """List project webhook policies.  # noqa: E501
 
+        This endpoint returns webhook policies of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_users(async_req=True)
+        >>> thread = api.list_webhook_policies_of_project(project_name_or_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
+        :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
-        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
-        :param int page: The page number
-        :param int page_size: The size of per page
-        :return: list[UserResp]
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_users_with_http_info(**kwargs)  # noqa: E501
-        else:
-            (data) = self.list_users_with_http_info(**kwargs)  # noqa: E501
-            return data
-
-    def list_users_with_http_info(self, **kwargs):  # noqa: E501
-        """List users  # noqa: E501
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_users_with_http_info(async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str x_request_id: An unique ID for the request
         :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
-        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
-        :param int page: The page number
-        :param int page_size: The size of per page
-        :return: list[UserResp]
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['x_request_id', 'q', 'sort', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_users" % key
-                )
-            params[key] = val
-        del params['kwargs']
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_users`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_users`, must be a value less than or equal to `100`")  # noqa: E501
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-
-        header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/users', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='list[UserResp]',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def search_users(self, username, **kwargs):  # noqa: E501
-        """Search users by username  # noqa: E501
-
-        This endpoint is to search the users by username.  It's open for all authenticated requests.   # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.search_users(username, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str username: Username for filtering results. (required)
-        :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
-        :return: list[UserSearchRespItem]
+        :return: list[WebhookPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.search_users_with_http_info(username, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_webhook_policies_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.search_users_with_http_info(username, **kwargs)  # noqa: E501
+            (data) = self.list_webhook_policies_of_project_with_http_info(
+                project_name_or_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def search_users_with_http_info(self, username, **kwargs):  # noqa: E501
-        """Search users by username  # noqa: E501
+    def list_webhook_policies_of_project_with_http_info(
+        self, project_name_or_id, **kwargs
+    ):  # noqa: E501
+        """List project webhook policies.  # noqa: E501
 
-        This endpoint is to search the users by username.  It's open for all authenticated requests.   # noqa: E501
+        This endpoint returns webhook policies of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.search_users_with_http_info(username, async_req=True)
+        >>> thread = api.list_webhook_policies_of_project_with_http_info(project_name_or_id, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str username: Username for filtering results. (required)
+        :param str project_name_or_id: The name or id of the project (required)
         :param str x_request_id: An unique ID for the request
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
+        :param str sort: Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \"sort=field1,-field2\"
+        :param str q: Query string to query resources. Supported query patterns are \"exact match(k=v)\", \"fuzzy match(k=~v)\", \"range(k=[min~max])\", \"list with union releationship(k={v1 v2 v3})\" and \"list with intersetion relationship(k=(v1 v2 v3))\". The value of range and list can be string(enclosed by \" or '), integer or time(in format \"2020-04-09 02:36:00\"). All of these query patterns should be put in the query string \"q=xxx\" and splitted by \",\". e.g. q=k1=v1,k2=~v2,k3=[min~max]
         :param int page: The page number
         :param int page_size: The size of per page
-        :return: list[UserSearchRespItem]
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['username', 'x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search_users" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'username' is set
-        if self.api_client.client_side_validation and ('username' not in params or
-                                                       params['username'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `username` when calling `search_users`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search_users`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `search_users`, must be a value less than or equal to `100`")  # noqa: E501
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'username' in params:
-            query_params.append(('username', params['username']))  # noqa: E501
-
-        header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/users/search', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='list[UserSearchRespItem]',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def set_cli_secret(self, user_id, secret, **kwargs):  # noqa: E501
-        """Set CLI secret for a user.  # noqa: E501
-
-        This endpoint let user generate a new CLI secret for himself.  This API only works when auth mode is set to 'OIDC'. Once this API returns with successful status, the old secret will be invalid, as there will be only one CLI secret for a user.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.set_cli_secret(user_id, secret, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param int user_id: User ID (required)
-        :param OIDCCliSecretReq secret: (required)
-        :param str x_request_id: An unique ID for the request
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.set_cli_secret_with_http_info(user_id, secret, **kwargs)  # noqa: E501
-        else:
-            (data) = self.set_cli_secret_with_http_info(user_id, secret, **kwargs)  # noqa: E501
-            return data
-
-    def set_cli_secret_with_http_info(self, user_id, secret, **kwargs):  # noqa: E501
-        """Set CLI secret for a user.  # noqa: E501
-
-        This endpoint let user generate a new CLI secret for himself.  This API only works when auth mode is set to 'OIDC'. Once this API returns with successful status, the old secret will be invalid, as there will be only one CLI secret for a user.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.set_cli_secret_with_http_info(user_id, secret, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param int user_id: User ID (required)
-        :param OIDCCliSecretReq secret: (required)
-        :param str x_request_id: An unique ID for the request
-        :return: None
+        :return: list[WebhookPolicy]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'secret', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "sort",
+            "q",
+            "page",
+            "page_size",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method set_cli_secret" % key
+                    " to method list_webhook_policies_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `set_cli_secret`")  # noqa: E501
-        # verify the required parameter 'secret' is set
-        if self.api_client.client_side_validation and ('secret' not in params or
-                                                       params['secret'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `secret` when calling `set_cli_secret`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `set_cli_secret`, length must be greater than or equal to `1`")  # noqa: E501
-        collection_formats = {}
-
-        path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
-
-        query_params = []
-
-        header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'secret' in params:
-            body_params = params['secret']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/users/{user_id}/cli_secret', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type=None,  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_webhook_policies_of_project`"
+            )  # noqa: E501
 
-    def set_user_sys_admin(self, user_id, sysadmin_flag, **kwargs):  # noqa: E501
-        """Update a registered user to change to be an administrator of Harbor.  # noqa: E501
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.set_user_sys_admin(user_id, sysadmin_flag, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param int user_id: (required)
-        :param UserSysAdminFlag sysadmin_flag: Toggle a user to admin or not. (required)
-        :param str x_request_id: An unique ID for the request
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.set_user_sys_admin_with_http_info(user_id, sysadmin_flag, **kwargs)  # noqa: E501
-        else:
-            (data) = self.set_user_sys_admin_with_http_info(user_id, sysadmin_flag, **kwargs)  # noqa: E501
-            return data
-
-    def set_user_sys_admin_with_http_info(self, user_id, sysadmin_flag, **kwargs):  # noqa: E501
-        """Update a registered user to change to be an administrator of Harbor.  # noqa: E501
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.set_user_sys_admin_with_http_info(user_id, sysadmin_flag, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param int user_id: (required)
-        :param UserSysAdminFlag sysadmin_flag: Toggle a user to admin or not. (required)
-        :param str x_request_id: An unique ID for the request
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['user_id', 'sysadmin_flag', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method set_user_sys_admin" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `set_user_sys_admin`")  # noqa: E501
-        # verify the required parameter 'sysadmin_flag' is set
-        if self.api_client.client_side_validation and ('sysadmin_flag' not in params or
-                                                       params['sysadmin_flag'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `sysadmin_flag` when calling `set_user_sys_admin`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `set_user_sys_admin`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_webhook_policies_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_webhook_policies_of_project`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'sysadmin_flag' in params:
-            body_params = params['sysadmin_flag']
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}/sysadmin', 'PUT',
+            "/projects/{project_name_or_id}/webhook/policies",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type=None,  # noqa: E501
+            response_type="list[WebhookPolicy]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
-    def update_user_password(self, user_id, password, **kwargs):  # noqa: E501
-        """Change the password on a user that already exists.  # noqa: E501
+    def update_webhook_policy_of_project(
+        self, project_name_or_id, webhook_policy_id, policy, **kwargs
+    ):  # noqa: E501
+        """Update webhook policy of a project.  # noqa: E501
 
-        This endpoint is for user to update password. Users with the admin role can change any user's password. Regular users can change only their own password.   # noqa: E501
+        This endpoint is aimed to update the webhook policy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_user_password(user_id, password, async_req=True)
+        >>> thread = api.update_webhook_policy_of_project(project_name_or_id, webhook_policy_id, policy, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int user_id: (required)
-        :param PasswordReq password: Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator. (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int webhook_policy_id: The ID of the webhook policy (required)
+        :param WebhookPolicy policy: All properties needed except \"id\", \"project_id\", \"creation_time\", \"update_time\". (required)
         :param str x_request_id: An unique ID for the request
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_user_password_with_http_info(user_id, password, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.update_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, policy, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.update_user_password_with_http_info(user_id, password, **kwargs)  # noqa: E501
+            (data) = self.update_webhook_policy_of_project_with_http_info(
+                project_name_or_id, webhook_policy_id, policy, **kwargs
+            )  # noqa: E501
             return data
 
-    def update_user_password_with_http_info(self, user_id, password, **kwargs):  # noqa: E501
-        """Change the password on a user that already exists.  # noqa: E501
+    def update_webhook_policy_of_project_with_http_info(
+        self, project_name_or_id, webhook_policy_id, policy, **kwargs
+    ):  # noqa: E501
+        """Update webhook policy of a project.  # noqa: E501
 
-        This endpoint is for user to update password. Users with the admin role can change any user's password. Regular users can change only their own password.   # noqa: E501
+        This endpoint is aimed to update the webhook policy of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_user_password_with_http_info(user_id, password, async_req=True)
+        >>> thread = api.update_webhook_policy_of_project_with_http_info(project_name_or_id, webhook_policy_id, policy, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int user_id: (required)
-        :param PasswordReq password: Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator. (required)
+        :param str project_name_or_id: The name or id of the project (required)
+        :param int webhook_policy_id: The ID of the webhook policy (required)
+        :param WebhookPolicy policy: All properties needed except \"id\", \"project_id\", \"creation_time\", \"update_time\". (required)
         :param str x_request_id: An unique ID for the request
+        :param bool x_is_resource_name: The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['user_id', 'password', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "webhook_policy_id",
+            "policy",
+            "x_request_id",
+            "x_is_resource_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_user_password" % key
+                    " to method update_webhook_policy_of_project" % key
                 )
             params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `update_user_password`")  # noqa: E501
-        # verify the required parameter 'password' is set
-        if self.api_client.client_side_validation and ('password' not in params or
-                                                       params['password'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `password` when calling `update_user_password`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_user_password`, length must be greater than or equal to `1`")  # noqa: E501
-        collection_formats = {}
-
-        path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
-
-        query_params = []
-
-        header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'password' in params:
-            body_params = params['password']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        del params["kwargs"]
+        # verify the required parameter 'project_name_or_id' is set
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `update_webhook_policy_of_project`"
+            )  # noqa: E501
+        # verify the required parameter 'webhook_policy_id' is set
+        if self.api_client.client_side_validation and (
+            "webhook_policy_id" not in params or params["webhook_policy_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `webhook_policy_id` when calling `update_webhook_policy_of_project`"
+            )  # noqa: E501
+        # verify the required parameter 'policy' is set
+        if self.api_client.client_side_validation and (
+            "policy" not in params or params["policy"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy` when calling `update_webhook_policy_of_project`"
+            )  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/users/{user_id}/password', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type=None,  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_user_profile(self, user_id, profile, **kwargs):  # noqa: E501
-        """Update user's profile.  # noqa: E501
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_user_profile(user_id, profile, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param int user_id: Registered user ID (required)
-        :param UserProfile profile: Only email, realname and comment can be modified. (required)
-        :param str x_request_id: An unique ID for the request
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_user_profile_with_http_info(user_id, profile, **kwargs)  # noqa: E501
-        else:
-            (data) = self.update_user_profile_with_http_info(user_id, profile, **kwargs)  # noqa: E501
-            return data
-
-    def update_user_profile_with_http_info(self, user_id, profile, **kwargs):  # noqa: E501
-        """Update user's profile.  # noqa: E501
-
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_user_profile_with_http_info(user_id, profile, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param int user_id: Registered user ID (required)
-        :param UserProfile profile: Only email, realname and comment can be modified. (required)
-        :param str x_request_id: An unique ID for the request
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['user_id', 'profile', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_user_profile" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'user_id' is set
-        if self.api_client.client_side_validation and ('user_id' not in params or
-                                                       params['user_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `user_id` when calling `update_user_profile`")  # noqa: E501
-        # verify the required parameter 'profile' is set
-        if self.api_client.client_side_validation and ('profile' not in params or
-                                                       params['profile'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `profile` when calling `update_user_profile`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_user_profile`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_webhook_policy_of_project`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'user_id' in params:
-            path_params['user_id'] = params['user_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
+        if "webhook_policy_id" in params:
+            path_params["webhook_policy_id"] = params["webhook_policy_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'profile' in params:
-            body_params = params['profile']
+        if "policy" in params:
+            body_params = params["policy"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/users/{user_id}', 'PUT',
+            "/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/usergroup_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/usergroup_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -45,16 +45,16 @@
         :param async_req bool
         :param str x_request_id: An unique ID for the request
         :param UserGroup usergroup:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.create_user_group_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.create_user_group_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def create_user_group_with_http_info(self, **kwargs):  # noqa: E501
         """Create user group  # noqa: E501
@@ -69,75 +69,81 @@
         :param str x_request_id: An unique ID for the request
         :param UserGroup usergroup:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'usergroup']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["x_request_id", "usergroup"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_user_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method create_user_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `create_user_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `create_user_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'usergroup' in params:
-            body_params = params['usergroup']
+        if "usergroup" in params:
+            body_params = params["usergroup"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups', 'POST',
+            "/usergroups",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def delete_user_group(self, group_id, **kwargs):  # noqa: E501
         """Delete user group  # noqa: E501
 
         Delete user group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -147,16 +153,16 @@
         :param async_req bool
         :param int group_id: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.delete_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
             return data
 
     def delete_user_group_with_http_info(self, group_id, **kwargs):  # noqa: E501
         """Delete user group  # noqa: E501
@@ -171,79 +177,88 @@
         :param int group_id: (required)
         :param str x_request_id: An unique ID for the request
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['group_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["group_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_user_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method delete_user_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'group_id' is set
-        if self.api_client.client_side_validation and ('group_id' not in params or
-                                                       params['group_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `group_id` when calling `delete_user_group`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `delete_user_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "group_id" not in params or params["group_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `group_id` when calling `delete_user_group`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `delete_user_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'group_id' in params:
-            path_params['group_id'] = params['group_id']  # noqa: E501
+        if "group_id" in params:
+            path_params["group_id"] = params["group_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups/{group_id}', 'DELETE',
+            "/usergroups/{group_id}",
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def get_user_group(self, group_id, **kwargs):  # noqa: E501
         """Get user group information  # noqa: E501
 
         Get user group information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -253,16 +268,16 @@
         :param async_req bool
         :param int group_id: Group ID (required)
         :param str x_request_id: An unique ID for the request
         :return: UserGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.get_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
         else:
             (data) = self.get_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
             return data
 
     def get_user_group_with_http_info(self, group_id, **kwargs):  # noqa: E501
         """Get user group information  # noqa: E501
@@ -277,79 +292,88 @@
         :param int group_id: Group ID (required)
         :param str x_request_id: An unique ID for the request
         :return: UserGroup
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['group_id', 'x_request_id']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["group_id", "x_request_id"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_user_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method get_user_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'group_id' is set
-        if self.api_client.client_side_validation and ('group_id' not in params or
-                                                       params['group_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `group_id` when calling `get_user_group`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `get_user_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "group_id" not in params or params["group_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `group_id` when calling `get_user_group`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `get_user_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'group_id' in params:
-            path_params['group_id'] = params['group_id']  # noqa: E501
+        if "group_id" in params:
+            path_params["group_id"] = params["group_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups/{group_id}', 'GET',
+            "/usergroups/{group_id}",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserGroup',  # noqa: E501
+            response_type="UserGroup",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def list_user_groups(self, **kwargs):  # noqa: E501
         """Get all user groups information  # noqa: E501
 
         Get all user groups information, it is open for system admin  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -362,16 +386,16 @@
         :param int page_size: The size of per page
         :param str ldap_group_dn: search with ldap group DN
         :param str group_name: group name need to search, fuzzy matches
         :return: list[UserGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.list_user_groups_with_http_info(**kwargs)  # noqa: E501
         else:
             (data) = self.list_user_groups_with_http_info(**kwargs)  # noqa: E501
             return data
 
     def list_user_groups_with_http_info(self, **kwargs):  # noqa: E501
         """Get all user groups information  # noqa: E501
@@ -389,83 +413,99 @@
         :param str ldap_group_dn: search with ldap group DN
         :param str group_name: group name need to search, fuzzy matches
         :return: list[UserGroup]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['x_request_id', 'page', 'page_size', 'ldap_group_dn', 'group_name']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "x_request_id",
+            "page",
+            "page_size",
+            "ldap_group_dn",
+            "group_name",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_user_groups" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_user_groups" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
 
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_user_groups`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_user_groups`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_user_groups`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_user_groups`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'ldap_group_dn' in params:
-            query_params.append(('ldap_group_dn', params['ldap_group_dn']))  # noqa: E501
-        if 'group_name' in params:
-            query_params.append(('group_name', params['group_name']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "ldap_group_dn" in params:
+            query_params.append(("ldap_group_dn", params["ldap_group_dn"]))  # noqa: E501
+        if "group_name" in params:
+            query_params.append(("group_name", params["group_name"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups', 'GET',
+            "/usergroups",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[UserGroup]',  # noqa: E501
+            response_type="list[UserGroup]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def search_user_groups(self, groupname, **kwargs):  # noqa: E501
         """Search groups by groupname  # noqa: E501
 
         This endpoint is to search groups by group name.  It's open for all authenticated requests.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -477,16 +517,16 @@
         :param str x_request_id: An unique ID for the request
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[UserGroupSearchItem]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.search_user_groups_with_http_info(groupname, **kwargs)  # noqa: E501
         else:
             (data) = self.search_user_groups_with_http_info(groupname, **kwargs)  # noqa: E501
             return data
 
     def search_user_groups_with_http_info(self, groupname, **kwargs):  # noqa: E501
         """Search groups by groupname  # noqa: E501
@@ -503,85 +543,98 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :return: list[UserGroupSearchItem]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['groupname', 'x_request_id', 'page', 'page_size']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["groupname", "x_request_id", "page", "page_size"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method search_user_groups" % key
+                    "Got an unexpected keyword argument '%s'" " to method search_user_groups" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'groupname' is set
-        if self.api_client.client_side_validation and ('groupname' not in params or
-                                                       params['groupname'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `groupname` when calling `search_user_groups`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `search_user_groups`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `search_user_groups`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "groupname" not in params or params["groupname"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `groupname` when calling `search_user_groups`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `search_user_groups`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `search_user_groups`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'groupname' in params:
-            query_params.append(('groupname', params['groupname']))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "groupname" in params:
+            query_params.append(("groupname", params["groupname"]))  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups/search', 'GET',
+            "/usergroups/search",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[UserGroupSearchItem]',  # noqa: E501
+            response_type="list[UserGroupSearchItem]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
 
     def update_user_group(self, group_id, **kwargs):  # noqa: E501
         """Update group information  # noqa: E501
 
         Update user group information  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -592,16 +645,16 @@
         :param int group_id: Group ID (required)
         :param str x_request_id: An unique ID for the request
         :param UserGroup usergroup:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
             return self.update_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
         else:
             (data) = self.update_user_group_with_http_info(group_id, **kwargs)  # noqa: E501
             return data
 
     def update_user_group_with_http_info(self, group_id, **kwargs):  # noqa: E501
         """Update group information  # noqa: E501
@@ -617,74 +670,83 @@
         :param str x_request_id: An unique ID for the request
         :param UserGroup usergroup:
         :return: None
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['group_id', 'x_request_id', 'usergroup']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = ["group_id", "x_request_id", "usergroup"]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_user_group" % key
+                    "Got an unexpected keyword argument '%s'" " to method update_user_group" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'group_id' is set
-        if self.api_client.client_side_validation and ('group_id' not in params or
-                                                       params['group_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `group_id` when calling `update_user_group`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `update_user_group`, length must be greater than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "group_id" not in params or params["group_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `group_id` when calling `update_user_group`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `update_user_group`, length must be greater than or equal to `1`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'group_id' in params:
-            path_params['group_id'] = params['group_id']  # noqa: E501
+        if "group_id" in params:
+            path_params["group_id"] = params["group_id"]  # noqa: E501
 
         query_params = []
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'usergroup' in params:
-            body_params = params['usergroup']
+        if "usergroup" in params:
+            body_params = params["usergroup"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/usergroups/{group_id}', 'PUT',
+            "/usergroups/{group_id}",
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_type=None,  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/harbor_client/webhookjob_api.py` & `harbor_api_client-2.7.6/src/harbor_client/harbor_client/webhookjob_api.py`

 * *Files 11% similar despite different names*

```diff
@@ -52,22 +52,28 @@
         :param int page: The page number
         :param int page_size: The size of per page
         :param list[str] status: The status of webhook job.
         :return: list[WebhookJob]
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.list_webhook_jobs_with_http_info(project_name_or_id, policy_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        if kwargs.get("async_req"):
+            return self.list_webhook_jobs_with_http_info(
+                project_name_or_id, policy_id, **kwargs
+            )  # noqa: E501
         else:
-            (data) = self.list_webhook_jobs_with_http_info(project_name_or_id, policy_id, **kwargs)  # noqa: E501
+            (data) = self.list_webhook_jobs_with_http_info(
+                project_name_or_id, policy_id, **kwargs
+            )  # noqa: E501
             return data
 
-    def list_webhook_jobs_with_http_info(self, project_name_or_id, policy_id, **kwargs):  # noqa: E501
+    def list_webhook_jobs_with_http_info(
+        self, project_name_or_id, policy_id, **kwargs
+    ):  # noqa: E501
         """List project webhook jobs  # noqa: E501
 
         This endpoint returns webhook jobs of a project.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.list_webhook_jobs_with_http_info(project_name_or_id, policy_id, async_req=True)
         >>> result = thread.get()
@@ -83,93 +89,119 @@
         :param int page_size: The size of per page
         :param list[str] status: The status of webhook job.
         :return: list[WebhookJob]
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
-        all_params = ['project_name_or_id', 'policy_id', 'x_request_id', 'x_is_resource_name', 'q', 'sort', 'page', 'page_size', 'status']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
+        all_params = [
+            "project_name_or_id",
+            "policy_id",
+            "x_request_id",
+            "x_is_resource_name",
+            "q",
+            "sort",
+            "page",
+            "page_size",
+            "status",
+        ]  # noqa: E501
+        all_params.append("async_req")
+        all_params.append("_return_http_data_only")
+        all_params.append("_preload_content")
+        all_params.append("_request_timeout")
 
         params = locals()
-        for key, val in six.iteritems(params['kwargs']):
+        for key, val in six.iteritems(params["kwargs"]):
             if key not in all_params:
                 raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_webhook_jobs" % key
+                    "Got an unexpected keyword argument '%s'" " to method list_webhook_jobs" % key
                 )
             params[key] = val
-        del params['kwargs']
+        del params["kwargs"]
         # verify the required parameter 'project_name_or_id' is set
-        if self.api_client.client_side_validation and ('project_name_or_id' not in params or
-                                                       params['project_name_or_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `project_name_or_id` when calling `list_webhook_jobs`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "project_name_or_id" not in params or params["project_name_or_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `project_name_or_id` when calling `list_webhook_jobs`"
+            )  # noqa: E501
         # verify the required parameter 'policy_id' is set
-        if self.api_client.client_side_validation and ('policy_id' not in params or
-                                                       params['policy_id'] is None):  # noqa: E501
-            raise ValueError("Missing the required parameter `policy_id` when calling `list_webhook_jobs`")  # noqa: E501
-
-        if self.api_client.client_side_validation and ('x_request_id' in params and
-                                                       len(params['x_request_id']) < 1):
-            raise ValueError("Invalid value for parameter `x_request_id` when calling `list_webhook_jobs`, length must be greater than or equal to `1`")  # noqa: E501
-        if self.api_client.client_side_validation and ('page_size' in params and params['page_size'] > 100):  # noqa: E501
-            raise ValueError("Invalid value for parameter `page_size` when calling `list_webhook_jobs`, must be a value less than or equal to `100`")  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "policy_id" not in params or params["policy_id"] is None
+        ):  # noqa: E501
+            raise ValueError(
+                "Missing the required parameter `policy_id` when calling `list_webhook_jobs`"
+            )  # noqa: E501
+
+        if self.api_client.client_side_validation and (
+            "x_request_id" in params and len(params["x_request_id"]) < 1
+        ):
+            raise ValueError(
+                "Invalid value for parameter `x_request_id` when calling `list_webhook_jobs`, length must be greater than or equal to `1`"
+            )  # noqa: E501
+        if self.api_client.client_side_validation and (
+            "page_size" in params and params["page_size"] > 100
+        ):  # noqa: E501
+            raise ValueError(
+                "Invalid value for parameter `page_size` when calling `list_webhook_jobs`, must be a value less than or equal to `100`"
+            )  # noqa: E501
         collection_formats = {}
 
         path_params = {}
-        if 'project_name_or_id' in params:
-            path_params['project_name_or_id'] = params['project_name_or_id']  # noqa: E501
+        if "project_name_or_id" in params:
+            path_params["project_name_or_id"] = params["project_name_or_id"]  # noqa: E501
 
         query_params = []
-        if 'q' in params:
-            query_params.append(('q', params['q']))  # noqa: E501
-        if 'sort' in params:
-            query_params.append(('sort', params['sort']))  # noqa: E501
-        if 'page' in params:
-            query_params.append(('page', params['page']))  # noqa: E501
-        if 'page_size' in params:
-            query_params.append(('page_size', params['page_size']))  # noqa: E501
-        if 'policy_id' in params:
-            query_params.append(('policy_id', params['policy_id']))  # noqa: E501
-        if 'status' in params:
-            query_params.append(('status', params['status']))  # noqa: E501
-            collection_formats['status'] = 'csv'  # noqa: E501
+        if "q" in params:
+            query_params.append(("q", params["q"]))  # noqa: E501
+        if "sort" in params:
+            query_params.append(("sort", params["sort"]))  # noqa: E501
+        if "page" in params:
+            query_params.append(("page", params["page"]))  # noqa: E501
+        if "page_size" in params:
+            query_params.append(("page_size", params["page_size"]))  # noqa: E501
+        if "policy_id" in params:
+            query_params.append(("policy_id", params["policy_id"]))  # noqa: E501
+        if "status" in params:
+            query_params.append(("status", params["status"]))  # noqa: E501
+            collection_formats["status"] = "csv"  # noqa: E501
 
         header_params = {}
-        if 'x_request_id' in params:
-            header_params['X-Request-Id'] = params['x_request_id']  # noqa: E501
-        if 'x_is_resource_name' in params:
-            header_params['X-Is-Resource-Name'] = params['x_is_resource_name']  # noqa: E501
+        if "x_request_id" in params:
+            header_params["X-Request-Id"] = params["x_request_id"]  # noqa: E501
+        if "x_is_resource_name" in params:
+            header_params["X-Is-Resource-Name"] = params["x_is_resource_name"]  # noqa: E501
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )  # noqa: E501
 
         # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json'])  # noqa: E501
+        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
+            ["application/json"]
+        )  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['basic']  # noqa: E501
+        auth_settings = ["basic"]  # noqa: E501
 
         return self.api_client.call_api(
-            '/projects/{project_name_or_id}/webhook/jobs', 'GET',
+            "/projects/{project_name_or_id}/webhook/jobs",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='list[WebhookJob]',  # noqa: E501
+            response_type="list[WebhookJob]",  # noqa: E501
             auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+            async_req=params.get("async_req"),
+            _return_http_data_only=params.get("_return_http_data_only"),
+            _preload_content=params.get("_preload_content", True),
+            _request_timeout=params.get("_request_timeout"),
+            collection_formats=collection_formats,
+        )
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/__init__.py` & `harbor_api_client-2.7.6/src/harbor_client/models/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -30,16 +30,20 @@
 from harbor_client.models.cve_allowlist import CVEAllowlist
 from harbor_client.models.cve_allowlist_item import CVEAllowlistItem
 from harbor_client.models.chart_metadata import ChartMetadata
 from harbor_client.models.chart_version import ChartVersion
 from harbor_client.models.component_health_status import ComponentHealthStatus
 from harbor_client.models.configurations import Configurations
 from harbor_client.models.configurations_response import ConfigurationsResponse
-from harbor_client.models.configurations_response_scan_all_policy import ConfigurationsResponseScanAllPolicy
-from harbor_client.models.configurations_response_scan_all_policy_parameter import ConfigurationsResponseScanAllPolicyParameter
+from harbor_client.models.configurations_response_scan_all_policy import (
+    ConfigurationsResponseScanAllPolicy,
+)
+from harbor_client.models.configurations_response_scan_all_policy_parameter import (
+    ConfigurationsResponseScanAllPolicyParameter,
+)
 from harbor_client.models.endpoint import Endpoint
 from harbor_client.models.error import Error
 from harbor_client.models.errors import Errors
 from harbor_client.models.event_type import EventType
 from harbor_client.models.exec_history import ExecHistory
 from harbor_client.models.execution import Execution
 from harbor_client.models.extra_attrs import ExtraAttrs
@@ -87,15 +91,17 @@
 from harbor_client.models.quota_update_req import QuotaUpdateReq
 from harbor_client.models.reference import Reference
 from harbor_client.models.registry import Registry
 from harbor_client.models.registry_credential import RegistryCredential
 from harbor_client.models.registry_endpoint import RegistryEndpoint
 from harbor_client.models.registry_info import RegistryInfo
 from harbor_client.models.registry_ping import RegistryPing
-from harbor_client.models.registry_provider_credential_pattern import RegistryProviderCredentialPattern
+from harbor_client.models.registry_provider_credential_pattern import (
+    RegistryProviderCredentialPattern,
+)
 from harbor_client.models.registry_provider_endpoint_pattern import RegistryProviderEndpointPattern
 from harbor_client.models.registry_provider_info import RegistryProviderInfo
 from harbor_client.models.registry_update import RegistryUpdate
 from harbor_client.models.replication_execution import ReplicationExecution
 from harbor_client.models.replication_filter import ReplicationFilter
 from harbor_client.models.replication_policy import ReplicationPolicy
 from harbor_client.models.replication_task import ReplicationTask
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/access.py` & `harbor_api_client-2.7.6/src/harbor_client/models/access.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'resource': 'str',
-        'action': 'str',
-        'effect': 'str'
-    }
-
-    attribute_map = {
-        'resource': 'resource',
-        'action': 'action',
-        'effect': 'effect'
-    }
+    swagger_types = {"resource": "str", "action": "str", "effect": "str"}
+
+    attribute_map = {"resource": "resource", "action": "action", "effect": "effect"}
 
     def __init__(self, resource=None, action=None, effect=None, _configuration=None):  # noqa: E501
         """Access - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -134,26 +126,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Access, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/accessory.py` & `harbor_api_client-2.7.6/src/harbor_client/models/accessory.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,36 +29,47 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'artifact_id': 'int',
-        'subject_artifact_id': 'int',
-        'size': 'int',
-        'digest': 'str',
-        'type': 'str',
-        'icon': 'str',
-        'creation_time': 'datetime'
+        "id": "int",
+        "artifact_id": "int",
+        "subject_artifact_id": "int",
+        "size": "int",
+        "digest": "str",
+        "type": "str",
+        "icon": "str",
+        "creation_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'artifact_id': 'artifact_id',
-        'subject_artifact_id': 'subject_artifact_id',
-        'size': 'size',
-        'digest': 'digest',
-        'type': 'type',
-        'icon': 'icon',
-        'creation_time': 'creation_time'
+        "id": "id",
+        "artifact_id": "artifact_id",
+        "subject_artifact_id": "subject_artifact_id",
+        "size": "size",
+        "digest": "digest",
+        "type": "type",
+        "icon": "icon",
+        "creation_time": "creation_time",
     }
 
-    def __init__(self, id=None, artifact_id=None, subject_artifact_id=None, size=None, digest=None, type=None, icon=None, creation_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        artifact_id=None,
+        subject_artifact_id=None,
+        size=None,
+        digest=None,
+        type=None,
+        icon=None,
+        creation_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Accessory - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._artifact_id = None
@@ -274,26 +285,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Accessory, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/action_request.py` & `harbor_api_client-2.7.6/src/harbor_client/models/action_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'action': 'str'
-    }
-
-    attribute_map = {
-        'action': 'action'
-    }
+    swagger_types = {"action": "str"}
+
+    attribute_map = {"action": "action"}
 
     def __init__(self, action=None, _configuration=None):  # noqa: E501
         """ActionRequest - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -69,42 +65,44 @@
 
         The action of the request, should be stop, pause or resume  # noqa: E501
 
         :param action: The action of this ActionRequest.  # noqa: E501
         :type: str
         """
         allowed_values = ["stop", "pause", "resume"]  # noqa: E501
-        if (self._configuration.client_side_validation and
-                action not in allowed_values):
+        if self._configuration.client_side_validation and action not in allowed_values:
             raise ValueError(
-                "Invalid value for `action` ({0}), must be one of {1}"  # noqa: E501
-                .format(action, allowed_values)
+                "Invalid value for `action` ({0}), must be one of {1}".format(  # noqa: E501
+                    action, allowed_values
+                )
             )
 
         self._action = action
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ActionRequest, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/addition_link.py` & `harbor_api_client-2.7.6/src/harbor_client/models/addition_link.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'href': 'str',
-        'absolute': 'bool'
-    }
-
-    attribute_map = {
-        'href': 'href',
-        'absolute': 'absolute'
-    }
+    swagger_types = {"href": "str", "absolute": "bool"}
+
+    attribute_map = {"href": "href", "absolute": "absolute"}
 
     def __init__(self, href=None, absolute=None, _configuration=None):  # noqa: E501
         """AdditionLink - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(AdditionLink, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/addition_links.py` & `harbor_api_client-2.7.6/src/harbor_client/models/addition_links.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,19 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-    }
+    swagger_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
     def __init__(self, _configuration=None):  # noqa: E501
         """AdditionLinks - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
         self.discriminator = None
@@ -48,26 +46,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(AdditionLinks, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/annotations.py` & `harbor_api_client-2.7.6/src/harbor_client/models/annotations.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,19 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-    }
+    swagger_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
     def __init__(self, _configuration=None):  # noqa: E501
         """Annotations - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
         self.discriminator = None
@@ -48,26 +46,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Annotations, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/artifact.py` & `harbor_api_client-2.7.6/src/harbor_client/models/artifact.py`

 * *Files 14% similar despite different names*

```diff
@@ -29,58 +29,80 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'type': 'str',
-        'media_type': 'str',
-        'manifest_media_type': 'str',
-        'project_id': 'int',
-        'repository_id': 'int',
-        'digest': 'str',
-        'size': 'int',
-        'icon': 'str',
-        'push_time': 'datetime',
-        'pull_time': 'datetime',
-        'extra_attrs': 'ExtraAttrs',
-        'annotations': 'Annotations',
-        'references': 'list[Reference]',
-        'tags': 'list[Tag]',
-        'addition_links': 'AdditionLinks',
-        'labels': 'list[Label]',
-        'scan_overview': 'ScanOverview',
-        'accessories': 'list[Accessory]'
+        "id": "int",
+        "type": "str",
+        "media_type": "str",
+        "manifest_media_type": "str",
+        "project_id": "int",
+        "repository_id": "int",
+        "digest": "str",
+        "size": "int",
+        "icon": "str",
+        "push_time": "datetime",
+        "pull_time": "datetime",
+        "extra_attrs": "ExtraAttrs",
+        "annotations": "Annotations",
+        "references": "list[Reference]",
+        "tags": "list[Tag]",
+        "addition_links": "AdditionLinks",
+        "labels": "list[Label]",
+        "scan_overview": "ScanOverview",
+        "accessories": "list[Accessory]",
     }
 
     attribute_map = {
-        'id': 'id',
-        'type': 'type',
-        'media_type': 'media_type',
-        'manifest_media_type': 'manifest_media_type',
-        'project_id': 'project_id',
-        'repository_id': 'repository_id',
-        'digest': 'digest',
-        'size': 'size',
-        'icon': 'icon',
-        'push_time': 'push_time',
-        'pull_time': 'pull_time',
-        'extra_attrs': 'extra_attrs',
-        'annotations': 'annotations',
-        'references': 'references',
-        'tags': 'tags',
-        'addition_links': 'addition_links',
-        'labels': 'labels',
-        'scan_overview': 'scan_overview',
-        'accessories': 'accessories'
+        "id": "id",
+        "type": "type",
+        "media_type": "media_type",
+        "manifest_media_type": "manifest_media_type",
+        "project_id": "project_id",
+        "repository_id": "repository_id",
+        "digest": "digest",
+        "size": "size",
+        "icon": "icon",
+        "push_time": "push_time",
+        "pull_time": "pull_time",
+        "extra_attrs": "extra_attrs",
+        "annotations": "annotations",
+        "references": "references",
+        "tags": "tags",
+        "addition_links": "addition_links",
+        "labels": "labels",
+        "scan_overview": "scan_overview",
+        "accessories": "accessories",
     }
 
-    def __init__(self, id=None, type=None, media_type=None, manifest_media_type=None, project_id=None, repository_id=None, digest=None, size=None, icon=None, push_time=None, pull_time=None, extra_attrs=None, annotations=None, references=None, tags=None, addition_links=None, labels=None, scan_overview=None, accessories=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        type=None,
+        media_type=None,
+        manifest_media_type=None,
+        project_id=None,
+        repository_id=None,
+        digest=None,
+        size=None,
+        icon=None,
+        push_time=None,
+        pull_time=None,
+        extra_attrs=None,
+        annotations=None,
+        references=None,
+        tags=None,
+        addition_links=None,
+        labels=None,
+        scan_overview=None,
+        accessories=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Artifact - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._type = None
@@ -568,26 +590,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Artifact, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/audit_log.py` & `harbor_api_client-2.7.6/src/harbor_client/models/audit_log.py`

 * *Files 8% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'username': 'str',
-        'resource': 'str',
-        'resource_type': 'str',
-        'operation': 'str',
-        'op_time': 'datetime'
+        "id": "int",
+        "username": "str",
+        "resource": "str",
+        "resource_type": "str",
+        "operation": "str",
+        "op_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'username': 'username',
-        'resource': 'resource',
-        'resource_type': 'resource_type',
-        'operation': 'operation',
-        'op_time': 'op_time'
+        "id": "id",
+        "username": "username",
+        "resource": "resource",
+        "resource_type": "resource_type",
+        "operation": "operation",
+        "op_time": "op_time",
     }
 
-    def __init__(self, id=None, username=None, resource=None, resource_type=None, operation=None, op_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        username=None,
+        resource=None,
+        resource_type=None,
+        operation=None,
+        op_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """AuditLog - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._username = None
@@ -218,26 +227,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(AuditLog, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/authproxy_setting.py` & `harbor_api_client-2.7.6/src/harbor_client/models/authproxy_setting.py`

 * *Files 12% similar despite different names*

```diff
@@ -29,30 +29,38 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'endpoint': 'str',
-        'tokenreivew_endpoint': 'str',
-        'skip_search': 'bool',
-        'verify_cert': 'bool',
-        'server_certificate': 'str'
+        "endpoint": "str",
+        "tokenreivew_endpoint": "str",
+        "skip_search": "bool",
+        "verify_cert": "bool",
+        "server_certificate": "str",
     }
 
     attribute_map = {
-        'endpoint': 'endpoint',
-        'tokenreivew_endpoint': 'tokenreivew_endpoint',
-        'skip_search': 'skip_search',
-        'verify_cert': 'verify_cert',
-        'server_certificate': 'server_certificate'
+        "endpoint": "endpoint",
+        "tokenreivew_endpoint": "tokenreivew_endpoint",
+        "skip_search": "skip_search",
+        "verify_cert": "verify_cert",
+        "server_certificate": "server_certificate",
     }
 
-    def __init__(self, endpoint=None, tokenreivew_endpoint=None, skip_search=None, verify_cert=None, server_certificate=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        endpoint=None,
+        tokenreivew_endpoint=None,
+        skip_search=None,
+        verify_cert=None,
+        server_certificate=None,
+        _configuration=None,
+    ):  # noqa: E501
         """AuthproxySetting - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._endpoint = None
         self._tokenreivew_endpoint = None
@@ -190,26 +198,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(AuthproxySetting, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/body.py` & `harbor_api_client-2.7.6/src/harbor_client/models/notify_type.py`

 * *Files 12% similar despite different names*

```diff
@@ -15,90 +15,62 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class Body(object):
+class NotifyType(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'dry_run': 'bool'
-    }
-
-    attribute_map = {
-        'dry_run': 'dry_run'
-    }
+    swagger_types = {}
 
-    def __init__(self, dry_run=None, _configuration=None):  # noqa: E501
-        """Body - a model defined in Swagger"""  # noqa: E501
+    attribute_map = {}
+
+    def __init__(self, _configuration=None):  # noqa: E501
+        """NotifyType - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
-
-        self._dry_run = None
         self.discriminator = None
 
-        if dry_run is not None:
-            self.dry_run = dry_run
-
-    @property
-    def dry_run(self):
-        """Gets the dry_run of this Body.  # noqa: E501
-
-
-        :return: The dry_run of this Body.  # noqa: E501
-        :rtype: bool
-        """
-        return self._dry_run
-
-    @dry_run.setter
-    def dry_run(self, dry_run):
-        """Sets the dry_run of this Body.
-
-
-        :param dry_run: The dry_run of this Body.  # noqa: E501
-        :type: bool
-        """
-
-        self._dry_run = dry_run
-
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(Body, dict):
+        if issubclass(NotifyType, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -106,18 +78,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Body):
+        if not isinstance(other, NotifyType):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Body):
+        if not isinstance(other, NotifyType):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/body1.py` & `harbor_api_client-2.7.6/src/harbor_client/models/body1.py`

 * *Files 5% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'action': 'str'
-    }
-
-    attribute_map = {
-        'action': 'action'
-    }
+    swagger_types = {"action": "str"}
+
+    attribute_map = {"action": "action"}
 
     def __init__(self, action=None, _configuration=None):  # noqa: E501
         """Body1 - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -76,26 +72,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Body1, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/bool_config_item.py` & `harbor_api_client-2.7.6/src/harbor_client/models/bool_config_item.py`

 * *Files 10% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'value': 'bool',
-        'editable': 'bool'
-    }
-
-    attribute_map = {
-        'value': 'value',
-        'editable': 'editable'
-    }
+    swagger_types = {"value": "bool", "editable": "bool"}
+
+    attribute_map = {"value": "value", "editable": "editable"}
 
     def __init__(self, value=None, editable=None, _configuration=None):  # noqa: E501
         """BoolConfigItem - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(BoolConfigItem, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/chart_metadata.py` & `harbor_api_client-2.7.6/src/harbor_client/models/chart_metadata.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,42 +29,56 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'name': 'str',
-        'home': 'str',
-        'sources': 'list[str]',
-        'version': 'str',
-        'description': 'str',
-        'keywords': 'list[str]',
-        'engine': 'str',
-        'icon': 'str',
-        'api_version': 'str',
-        'app_version': 'str',
-        'deprecated': 'bool'
+        "name": "str",
+        "home": "str",
+        "sources": "list[str]",
+        "version": "str",
+        "description": "str",
+        "keywords": "list[str]",
+        "engine": "str",
+        "icon": "str",
+        "api_version": "str",
+        "app_version": "str",
+        "deprecated": "bool",
     }
 
     attribute_map = {
-        'name': 'name',
-        'home': 'home',
-        'sources': 'sources',
-        'version': 'version',
-        'description': 'description',
-        'keywords': 'keywords',
-        'engine': 'engine',
-        'icon': 'icon',
-        'api_version': 'apiVersion',
-        'app_version': 'appVersion',
-        'deprecated': 'deprecated'
+        "name": "name",
+        "home": "home",
+        "sources": "sources",
+        "version": "version",
+        "description": "description",
+        "keywords": "keywords",
+        "engine": "engine",
+        "icon": "icon",
+        "api_version": "apiVersion",
+        "app_version": "appVersion",
+        "deprecated": "deprecated",
     }
 
-    def __init__(self, name=None, home=None, sources=None, version=None, description=None, keywords=None, engine=None, icon=None, api_version=None, app_version=None, deprecated=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        name=None,
+        home=None,
+        sources=None,
+        version=None,
+        description=None,
+        keywords=None,
+        engine=None,
+        icon=None,
+        api_version=None,
+        app_version=None,
+        deprecated=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ChartMetadata - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._name = None
         self._home = None
@@ -364,26 +378,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ChartMetadata, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/chart_version.py` & `harbor_api_client-2.7.6/src/harbor_client/models/chart_version.py`

 * *Files 12% similar despite different names*

```diff
@@ -29,30 +29,32 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'labels': 'list[Label]',
-        'created': 'str',
-        'removed': 'bool',
-        'digest': 'str',
-        'urls': 'list[str]'
+        "labels": "list[Label]",
+        "created": "str",
+        "removed": "bool",
+        "digest": "str",
+        "urls": "list[str]",
     }
 
     attribute_map = {
-        'labels': 'labels',
-        'created': 'created',
-        'removed': 'removed',
-        'digest': 'digest',
-        'urls': 'urls'
+        "labels": "labels",
+        "created": "created",
+        "removed": "removed",
+        "digest": "digest",
+        "urls": "urls",
     }
 
-    def __init__(self, labels=None, created=None, removed=None, digest=None, urls=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, labels=None, created=None, removed=None, digest=None, urls=None, _configuration=None
+    ):  # noqa: E501
         """ChartVersion - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._labels = None
         self._created = None
@@ -190,26 +192,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ChartVersion, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/component_health_status.py` & `harbor_api_client-2.7.6/src/harbor_client/models/component_health_status.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'name': 'str',
-        'status': 'str',
-        'error': 'str'
-    }
-
-    attribute_map = {
-        'name': 'name',
-        'status': 'status',
-        'error': 'error'
-    }
+    swagger_types = {"name": "str", "status": "str", "error": "str"}
+
+    attribute_map = {"name": "name", "status": "status", "error": "error"}
 
     def __init__(self, name=None, status=None, error=None, _configuration=None):  # noqa: E501
         """ComponentHealthStatus - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -134,26 +126,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ComponentHealthStatus, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/configurations.py` & `harbor_api_client-2.7.6/src/harbor_client/models/configurations.py`

 * *Files 9% similar despite different names*

```diff
@@ -29,122 +29,176 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'auth_mode': 'str',
-        'ldap_base_dn': 'str',
-        'ldap_filter': 'str',
-        'ldap_group_base_dn': 'str',
-        'ldap_group_admin_dn': 'str',
-        'ldap_group_attribute_name': 'str',
-        'ldap_group_search_filter': 'str',
-        'ldap_group_search_scope': 'int',
-        'ldap_scope': 'int',
-        'ldap_search_dn': 'str',
-        'ldap_search_password': 'str',
-        'ldap_timeout': 'int',
-        'ldap_uid': 'str',
-        'ldap_url': 'str',
-        'ldap_verify_cert': 'bool',
-        'ldap_group_membership_attribute': 'str',
-        'project_creation_restriction': 'str',
-        'read_only': 'bool',
-        'self_registration': 'bool',
-        'token_expiration': 'int',
-        'uaa_client_id': 'str',
-        'uaa_client_secret': 'str',
-        'uaa_endpoint': 'str',
-        'uaa_verify_cert': 'bool',
-        'http_authproxy_endpoint': 'str',
-        'http_authproxy_tokenreview_endpoint': 'str',
-        'http_authproxy_admin_groups': 'str',
-        'http_authproxy_admin_usernames': 'str',
-        'http_authproxy_verify_cert': 'bool',
-        'http_authproxy_skip_search': 'bool',
-        'http_authproxy_server_certificate': 'str',
-        'oidc_name': 'str',
-        'oidc_endpoint': 'str',
-        'oidc_client_id': 'str',
-        'oidc_client_secret': 'str',
-        'oidc_groups_claim': 'str',
-        'oidc_admin_group': 'str',
-        'oidc_group_filter': 'str',
-        'oidc_scope': 'str',
-        'oidc_user_claim': 'str',
-        'oidc_verify_cert': 'bool',
-        'oidc_auto_onboard': 'bool',
-        'oidc_extra_redirect_parms': 'str',
-        'robot_token_duration': 'int',
-        'robot_name_prefix': 'str',
-        'notification_enable': 'bool',
-        'quota_per_project_enable': 'bool',
-        'storage_per_project': 'int',
-        'audit_log_forward_endpoint': 'str',
-        'skip_audit_log_database': 'bool',
-        'session_timeout': 'int'
+        "auth_mode": "str",
+        "ldap_base_dn": "str",
+        "ldap_filter": "str",
+        "ldap_group_base_dn": "str",
+        "ldap_group_admin_dn": "str",
+        "ldap_group_attribute_name": "str",
+        "ldap_group_search_filter": "str",
+        "ldap_group_search_scope": "int",
+        "ldap_scope": "int",
+        "ldap_search_dn": "str",
+        "ldap_search_password": "str",
+        "ldap_timeout": "int",
+        "ldap_uid": "str",
+        "ldap_url": "str",
+        "ldap_verify_cert": "bool",
+        "ldap_group_membership_attribute": "str",
+        "project_creation_restriction": "str",
+        "read_only": "bool",
+        "self_registration": "bool",
+        "token_expiration": "int",
+        "uaa_client_id": "str",
+        "uaa_client_secret": "str",
+        "uaa_endpoint": "str",
+        "uaa_verify_cert": "bool",
+        "http_authproxy_endpoint": "str",
+        "http_authproxy_tokenreview_endpoint": "str",
+        "http_authproxy_admin_groups": "str",
+        "http_authproxy_admin_usernames": "str",
+        "http_authproxy_verify_cert": "bool",
+        "http_authproxy_skip_search": "bool",
+        "http_authproxy_server_certificate": "str",
+        "oidc_name": "str",
+        "oidc_endpoint": "str",
+        "oidc_client_id": "str",
+        "oidc_client_secret": "str",
+        "oidc_groups_claim": "str",
+        "oidc_admin_group": "str",
+        "oidc_group_filter": "str",
+        "oidc_scope": "str",
+        "oidc_user_claim": "str",
+        "oidc_verify_cert": "bool",
+        "oidc_auto_onboard": "bool",
+        "oidc_extra_redirect_parms": "str",
+        "robot_token_duration": "int",
+        "robot_name_prefix": "str",
+        "notification_enable": "bool",
+        "quota_per_project_enable": "bool",
+        "storage_per_project": "int",
+        "audit_log_forward_endpoint": "str",
+        "skip_audit_log_database": "bool",
+        "session_timeout": "int",
     }
 
     attribute_map = {
-        'auth_mode': 'auth_mode',
-        'ldap_base_dn': 'ldap_base_dn',
-        'ldap_filter': 'ldap_filter',
-        'ldap_group_base_dn': 'ldap_group_base_dn',
-        'ldap_group_admin_dn': 'ldap_group_admin_dn',
-        'ldap_group_attribute_name': 'ldap_group_attribute_name',
-        'ldap_group_search_filter': 'ldap_group_search_filter',
-        'ldap_group_search_scope': 'ldap_group_search_scope',
-        'ldap_scope': 'ldap_scope',
-        'ldap_search_dn': 'ldap_search_dn',
-        'ldap_search_password': 'ldap_search_password',
-        'ldap_timeout': 'ldap_timeout',
-        'ldap_uid': 'ldap_uid',
-        'ldap_url': 'ldap_url',
-        'ldap_verify_cert': 'ldap_verify_cert',
-        'ldap_group_membership_attribute': 'ldap_group_membership_attribute',
-        'project_creation_restriction': 'project_creation_restriction',
-        'read_only': 'read_only',
-        'self_registration': 'self_registration',
-        'token_expiration': 'token_expiration',
-        'uaa_client_id': 'uaa_client_id',
-        'uaa_client_secret': 'uaa_client_secret',
-        'uaa_endpoint': 'uaa_endpoint',
-        'uaa_verify_cert': 'uaa_verify_cert',
-        'http_authproxy_endpoint': 'http_authproxy_endpoint',
-        'http_authproxy_tokenreview_endpoint': 'http_authproxy_tokenreview_endpoint',
-        'http_authproxy_admin_groups': 'http_authproxy_admin_groups',
-        'http_authproxy_admin_usernames': 'http_authproxy_admin_usernames',
-        'http_authproxy_verify_cert': 'http_authproxy_verify_cert',
-        'http_authproxy_skip_search': 'http_authproxy_skip_search',
-        'http_authproxy_server_certificate': 'http_authproxy_server_certificate',
-        'oidc_name': 'oidc_name',
-        'oidc_endpoint': 'oidc_endpoint',
-        'oidc_client_id': 'oidc_client_id',
-        'oidc_client_secret': 'oidc_client_secret',
-        'oidc_groups_claim': 'oidc_groups_claim',
-        'oidc_admin_group': 'oidc_admin_group',
-        'oidc_group_filter': 'oidc_group_filter',
-        'oidc_scope': 'oidc_scope',
-        'oidc_user_claim': 'oidc_user_claim',
-        'oidc_verify_cert': 'oidc_verify_cert',
-        'oidc_auto_onboard': 'oidc_auto_onboard',
-        'oidc_extra_redirect_parms': 'oidc_extra_redirect_parms',
-        'robot_token_duration': 'robot_token_duration',
-        'robot_name_prefix': 'robot_name_prefix',
-        'notification_enable': 'notification_enable',
-        'quota_per_project_enable': 'quota_per_project_enable',
-        'storage_per_project': 'storage_per_project',
-        'audit_log_forward_endpoint': 'audit_log_forward_endpoint',
-        'skip_audit_log_database': 'skip_audit_log_database',
-        'session_timeout': 'session_timeout'
+        "auth_mode": "auth_mode",
+        "ldap_base_dn": "ldap_base_dn",
+        "ldap_filter": "ldap_filter",
+        "ldap_group_base_dn": "ldap_group_base_dn",
+        "ldap_group_admin_dn": "ldap_group_admin_dn",
+        "ldap_group_attribute_name": "ldap_group_attribute_name",
+        "ldap_group_search_filter": "ldap_group_search_filter",
+        "ldap_group_search_scope": "ldap_group_search_scope",
+        "ldap_scope": "ldap_scope",
+        "ldap_search_dn": "ldap_search_dn",
+        "ldap_search_password": "ldap_search_password",
+        "ldap_timeout": "ldap_timeout",
+        "ldap_uid": "ldap_uid",
+        "ldap_url": "ldap_url",
+        "ldap_verify_cert": "ldap_verify_cert",
+        "ldap_group_membership_attribute": "ldap_group_membership_attribute",
+        "project_creation_restriction": "project_creation_restriction",
+        "read_only": "read_only",
+        "self_registration": "self_registration",
+        "token_expiration": "token_expiration",
+        "uaa_client_id": "uaa_client_id",
+        "uaa_client_secret": "uaa_client_secret",
+        "uaa_endpoint": "uaa_endpoint",
+        "uaa_verify_cert": "uaa_verify_cert",
+        "http_authproxy_endpoint": "http_authproxy_endpoint",
+        "http_authproxy_tokenreview_endpoint": "http_authproxy_tokenreview_endpoint",
+        "http_authproxy_admin_groups": "http_authproxy_admin_groups",
+        "http_authproxy_admin_usernames": "http_authproxy_admin_usernames",
+        "http_authproxy_verify_cert": "http_authproxy_verify_cert",
+        "http_authproxy_skip_search": "http_authproxy_skip_search",
+        "http_authproxy_server_certificate": "http_authproxy_server_certificate",
+        "oidc_name": "oidc_name",
+        "oidc_endpoint": "oidc_endpoint",
+        "oidc_client_id": "oidc_client_id",
+        "oidc_client_secret": "oidc_client_secret",
+        "oidc_groups_claim": "oidc_groups_claim",
+        "oidc_admin_group": "oidc_admin_group",
+        "oidc_group_filter": "oidc_group_filter",
+        "oidc_scope": "oidc_scope",
+        "oidc_user_claim": "oidc_user_claim",
+        "oidc_verify_cert": "oidc_verify_cert",
+        "oidc_auto_onboard": "oidc_auto_onboard",
+        "oidc_extra_redirect_parms": "oidc_extra_redirect_parms",
+        "robot_token_duration": "robot_token_duration",
+        "robot_name_prefix": "robot_name_prefix",
+        "notification_enable": "notification_enable",
+        "quota_per_project_enable": "quota_per_project_enable",
+        "storage_per_project": "storage_per_project",
+        "audit_log_forward_endpoint": "audit_log_forward_endpoint",
+        "skip_audit_log_database": "skip_audit_log_database",
+        "session_timeout": "session_timeout",
     }
 
-    def __init__(self, auth_mode=None, ldap_base_dn=None, ldap_filter=None, ldap_group_base_dn=None, ldap_group_admin_dn=None, ldap_group_attribute_name=None, ldap_group_search_filter=None, ldap_group_search_scope=None, ldap_scope=None, ldap_search_dn=None, ldap_search_password=None, ldap_timeout=None, ldap_uid=None, ldap_url=None, ldap_verify_cert=None, ldap_group_membership_attribute=None, project_creation_restriction=None, read_only=None, self_registration=None, token_expiration=None, uaa_client_id=None, uaa_client_secret=None, uaa_endpoint=None, uaa_verify_cert=None, http_authproxy_endpoint=None, http_authproxy_tokenreview_endpoint=None, http_authproxy_admin_groups=None, http_authproxy_admin_usernames=None, http_authproxy_verify_cert=None, http_authproxy_skip_search=None, http_authproxy_server_certificate=None, oidc_name=None, oidc_endpoint=None, oidc_client_id=None, oidc_client_secret=None, oidc_groups_claim=None, oidc_admin_group=None, oidc_group_filter=None, oidc_scope=None, oidc_user_claim=None, oidc_verify_cert=None, oidc_auto_onboard=None, oidc_extra_redirect_parms=None, robot_token_duration=None, robot_name_prefix=None, notification_enable=None, quota_per_project_enable=None, storage_per_project=None, audit_log_forward_endpoint=None, skip_audit_log_database=None, session_timeout=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        auth_mode=None,
+        ldap_base_dn=None,
+        ldap_filter=None,
+        ldap_group_base_dn=None,
+        ldap_group_admin_dn=None,
+        ldap_group_attribute_name=None,
+        ldap_group_search_filter=None,
+        ldap_group_search_scope=None,
+        ldap_scope=None,
+        ldap_search_dn=None,
+        ldap_search_password=None,
+        ldap_timeout=None,
+        ldap_uid=None,
+        ldap_url=None,
+        ldap_verify_cert=None,
+        ldap_group_membership_attribute=None,
+        project_creation_restriction=None,
+        read_only=None,
+        self_registration=None,
+        token_expiration=None,
+        uaa_client_id=None,
+        uaa_client_secret=None,
+        uaa_endpoint=None,
+        uaa_verify_cert=None,
+        http_authproxy_endpoint=None,
+        http_authproxy_tokenreview_endpoint=None,
+        http_authproxy_admin_groups=None,
+        http_authproxy_admin_usernames=None,
+        http_authproxy_verify_cert=None,
+        http_authproxy_skip_search=None,
+        http_authproxy_server_certificate=None,
+        oidc_name=None,
+        oidc_endpoint=None,
+        oidc_client_id=None,
+        oidc_client_secret=None,
+        oidc_groups_claim=None,
+        oidc_admin_group=None,
+        oidc_group_filter=None,
+        oidc_scope=None,
+        oidc_user_claim=None,
+        oidc_verify_cert=None,
+        oidc_auto_onboard=None,
+        oidc_extra_redirect_parms=None,
+        robot_token_duration=None,
+        robot_name_prefix=None,
+        notification_enable=None,
+        quota_per_project_enable=None,
+        storage_per_project=None,
+        audit_log_forward_endpoint=None,
+        skip_audit_log_database=None,
+        session_timeout=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Configurations - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._auth_mode = None
         self._ldap_base_dn = None
@@ -1478,26 +1532,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Configurations, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/configurations_response.py` & `harbor_api_client-2.7.6/src/harbor_client/models/configurations_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,120 +29,173 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'auth_mode': 'StringConfigItem',
-        'ldap_base_dn': 'StringConfigItem',
-        'ldap_filter': 'StringConfigItem',
-        'ldap_group_base_dn': 'StringConfigItem',
-        'ldap_group_admin_dn': 'StringConfigItem',
-        'ldap_group_attribute_name': 'StringConfigItem',
-        'ldap_group_search_filter': 'StringConfigItem',
-        'ldap_group_search_scope': 'IntegerConfigItem',
-        'ldap_scope': 'IntegerConfigItem',
-        'ldap_search_dn': 'StringConfigItem',
-        'ldap_timeout': 'IntegerConfigItem',
-        'ldap_uid': 'StringConfigItem',
-        'ldap_url': 'StringConfigItem',
-        'ldap_verify_cert': 'BoolConfigItem',
-        'ldap_group_membership_attribute': 'StringConfigItem',
-        'project_creation_restriction': 'StringConfigItem',
-        'read_only': 'BoolConfigItem',
-        'self_registration': 'BoolConfigItem',
-        'token_expiration': 'IntegerConfigItem',
-        'uaa_client_id': 'StringConfigItem',
-        'uaa_client_secret': 'StringConfigItem',
-        'uaa_endpoint': 'StringConfigItem',
-        'uaa_verify_cert': 'BoolConfigItem',
-        'http_authproxy_endpoint': 'StringConfigItem',
-        'http_authproxy_tokenreview_endpoint': 'StringConfigItem',
-        'http_authproxy_admin_groups': 'StringConfigItem',
-        'http_authproxy_admin_usernames': 'StringConfigItem',
-        'http_authproxy_verify_cert': 'BoolConfigItem',
-        'http_authproxy_skip_search': 'BoolConfigItem',
-        'http_authproxy_server_certificate': 'StringConfigItem',
-        'oidc_name': 'StringConfigItem',
-        'oidc_endpoint': 'StringConfigItem',
-        'oidc_client_id': 'StringConfigItem',
-        'oidc_groups_claim': 'StringConfigItem',
-        'oidc_admin_group': 'StringConfigItem',
-        'oidc_group_filter': 'StringConfigItem',
-        'oidc_scope': 'StringConfigItem',
-        'oidc_user_claim': 'StringConfigItem',
-        'oidc_verify_cert': 'BoolConfigItem',
-        'oidc_auto_onboard': 'BoolConfigItem',
-        'oidc_extra_redirect_parms': 'StringConfigItem',
-        'robot_token_duration': 'IntegerConfigItem',
-        'robot_name_prefix': 'StringConfigItem',
-        'notification_enable': 'BoolConfigItem',
-        'quota_per_project_enable': 'BoolConfigItem',
-        'storage_per_project': 'IntegerConfigItem',
-        'audit_log_forward_endpoint': 'StringConfigItem',
-        'skip_audit_log_database': 'BoolConfigItem',
-        'scan_all_policy': 'ConfigurationsResponseScanAllPolicy',
-        'session_timeout': 'IntegerConfigItem'
+        "auth_mode": "StringConfigItem",
+        "ldap_base_dn": "StringConfigItem",
+        "ldap_filter": "StringConfigItem",
+        "ldap_group_base_dn": "StringConfigItem",
+        "ldap_group_admin_dn": "StringConfigItem",
+        "ldap_group_attribute_name": "StringConfigItem",
+        "ldap_group_search_filter": "StringConfigItem",
+        "ldap_group_search_scope": "IntegerConfigItem",
+        "ldap_scope": "IntegerConfigItem",
+        "ldap_search_dn": "StringConfigItem",
+        "ldap_timeout": "IntegerConfigItem",
+        "ldap_uid": "StringConfigItem",
+        "ldap_url": "StringConfigItem",
+        "ldap_verify_cert": "BoolConfigItem",
+        "ldap_group_membership_attribute": "StringConfigItem",
+        "project_creation_restriction": "StringConfigItem",
+        "read_only": "BoolConfigItem",
+        "self_registration": "BoolConfigItem",
+        "token_expiration": "IntegerConfigItem",
+        "uaa_client_id": "StringConfigItem",
+        "uaa_client_secret": "StringConfigItem",
+        "uaa_endpoint": "StringConfigItem",
+        "uaa_verify_cert": "BoolConfigItem",
+        "http_authproxy_endpoint": "StringConfigItem",
+        "http_authproxy_tokenreview_endpoint": "StringConfigItem",
+        "http_authproxy_admin_groups": "StringConfigItem",
+        "http_authproxy_admin_usernames": "StringConfigItem",
+        "http_authproxy_verify_cert": "BoolConfigItem",
+        "http_authproxy_skip_search": "BoolConfigItem",
+        "http_authproxy_server_certificate": "StringConfigItem",
+        "oidc_name": "StringConfigItem",
+        "oidc_endpoint": "StringConfigItem",
+        "oidc_client_id": "StringConfigItem",
+        "oidc_groups_claim": "StringConfigItem",
+        "oidc_admin_group": "StringConfigItem",
+        "oidc_group_filter": "StringConfigItem",
+        "oidc_scope": "StringConfigItem",
+        "oidc_user_claim": "StringConfigItem",
+        "oidc_verify_cert": "BoolConfigItem",
+        "oidc_auto_onboard": "BoolConfigItem",
+        "oidc_extra_redirect_parms": "StringConfigItem",
+        "robot_token_duration": "IntegerConfigItem",
+        "robot_name_prefix": "StringConfigItem",
+        "notification_enable": "BoolConfigItem",
+        "quota_per_project_enable": "BoolConfigItem",
+        "storage_per_project": "IntegerConfigItem",
+        "audit_log_forward_endpoint": "StringConfigItem",
+        "skip_audit_log_database": "BoolConfigItem",
+        "scan_all_policy": "ConfigurationsResponseScanAllPolicy",
+        "session_timeout": "IntegerConfigItem",
     }
 
     attribute_map = {
-        'auth_mode': 'auth_mode',
-        'ldap_base_dn': 'ldap_base_dn',
-        'ldap_filter': 'ldap_filter',
-        'ldap_group_base_dn': 'ldap_group_base_dn',
-        'ldap_group_admin_dn': 'ldap_group_admin_dn',
-        'ldap_group_attribute_name': 'ldap_group_attribute_name',
-        'ldap_group_search_filter': 'ldap_group_search_filter',
-        'ldap_group_search_scope': 'ldap_group_search_scope',
-        'ldap_scope': 'ldap_scope',
-        'ldap_search_dn': 'ldap_search_dn',
-        'ldap_timeout': 'ldap_timeout',
-        'ldap_uid': 'ldap_uid',
-        'ldap_url': 'ldap_url',
-        'ldap_verify_cert': 'ldap_verify_cert',
-        'ldap_group_membership_attribute': 'ldap_group_membership_attribute',
-        'project_creation_restriction': 'project_creation_restriction',
-        'read_only': 'read_only',
-        'self_registration': 'self_registration',
-        'token_expiration': 'token_expiration',
-        'uaa_client_id': 'uaa_client_id',
-        'uaa_client_secret': 'uaa_client_secret',
-        'uaa_endpoint': 'uaa_endpoint',
-        'uaa_verify_cert': 'uaa_verify_cert',
-        'http_authproxy_endpoint': 'http_authproxy_endpoint',
-        'http_authproxy_tokenreview_endpoint': 'http_authproxy_tokenreview_endpoint',
-        'http_authproxy_admin_groups': 'http_authproxy_admin_groups',
-        'http_authproxy_admin_usernames': 'http_authproxy_admin_usernames',
-        'http_authproxy_verify_cert': 'http_authproxy_verify_cert',
-        'http_authproxy_skip_search': 'http_authproxy_skip_search',
-        'http_authproxy_server_certificate': 'http_authproxy_server_certificate',
-        'oidc_name': 'oidc_name',
-        'oidc_endpoint': 'oidc_endpoint',
-        'oidc_client_id': 'oidc_client_id',
-        'oidc_groups_claim': 'oidc_groups_claim',
-        'oidc_admin_group': 'oidc_admin_group',
-        'oidc_group_filter': 'oidc_group_filter',
-        'oidc_scope': 'oidc_scope',
-        'oidc_user_claim': 'oidc_user_claim',
-        'oidc_verify_cert': 'oidc_verify_cert',
-        'oidc_auto_onboard': 'oidc_auto_onboard',
-        'oidc_extra_redirect_parms': 'oidc_extra_redirect_parms',
-        'robot_token_duration': 'robot_token_duration',
-        'robot_name_prefix': 'robot_name_prefix',
-        'notification_enable': 'notification_enable',
-        'quota_per_project_enable': 'quota_per_project_enable',
-        'storage_per_project': 'storage_per_project',
-        'audit_log_forward_endpoint': 'audit_log_forward_endpoint',
-        'skip_audit_log_database': 'skip_audit_log_database',
-        'scan_all_policy': 'scan_all_policy',
-        'session_timeout': 'session_timeout'
+        "auth_mode": "auth_mode",
+        "ldap_base_dn": "ldap_base_dn",
+        "ldap_filter": "ldap_filter",
+        "ldap_group_base_dn": "ldap_group_base_dn",
+        "ldap_group_admin_dn": "ldap_group_admin_dn",
+        "ldap_group_attribute_name": "ldap_group_attribute_name",
+        "ldap_group_search_filter": "ldap_group_search_filter",
+        "ldap_group_search_scope": "ldap_group_search_scope",
+        "ldap_scope": "ldap_scope",
+        "ldap_search_dn": "ldap_search_dn",
+        "ldap_timeout": "ldap_timeout",
+        "ldap_uid": "ldap_uid",
+        "ldap_url": "ldap_url",
+        "ldap_verify_cert": "ldap_verify_cert",
+        "ldap_group_membership_attribute": "ldap_group_membership_attribute",
+        "project_creation_restriction": "project_creation_restriction",
+        "read_only": "read_only",
+        "self_registration": "self_registration",
+        "token_expiration": "token_expiration",
+        "uaa_client_id": "uaa_client_id",
+        "uaa_client_secret": "uaa_client_secret",
+        "uaa_endpoint": "uaa_endpoint",
+        "uaa_verify_cert": "uaa_verify_cert",
+        "http_authproxy_endpoint": "http_authproxy_endpoint",
+        "http_authproxy_tokenreview_endpoint": "http_authproxy_tokenreview_endpoint",
+        "http_authproxy_admin_groups": "http_authproxy_admin_groups",
+        "http_authproxy_admin_usernames": "http_authproxy_admin_usernames",
+        "http_authproxy_verify_cert": "http_authproxy_verify_cert",
+        "http_authproxy_skip_search": "http_authproxy_skip_search",
+        "http_authproxy_server_certificate": "http_authproxy_server_certificate",
+        "oidc_name": "oidc_name",
+        "oidc_endpoint": "oidc_endpoint",
+        "oidc_client_id": "oidc_client_id",
+        "oidc_groups_claim": "oidc_groups_claim",
+        "oidc_admin_group": "oidc_admin_group",
+        "oidc_group_filter": "oidc_group_filter",
+        "oidc_scope": "oidc_scope",
+        "oidc_user_claim": "oidc_user_claim",
+        "oidc_verify_cert": "oidc_verify_cert",
+        "oidc_auto_onboard": "oidc_auto_onboard",
+        "oidc_extra_redirect_parms": "oidc_extra_redirect_parms",
+        "robot_token_duration": "robot_token_duration",
+        "robot_name_prefix": "robot_name_prefix",
+        "notification_enable": "notification_enable",
+        "quota_per_project_enable": "quota_per_project_enable",
+        "storage_per_project": "storage_per_project",
+        "audit_log_forward_endpoint": "audit_log_forward_endpoint",
+        "skip_audit_log_database": "skip_audit_log_database",
+        "scan_all_policy": "scan_all_policy",
+        "session_timeout": "session_timeout",
     }
 
-    def __init__(self, auth_mode=None, ldap_base_dn=None, ldap_filter=None, ldap_group_base_dn=None, ldap_group_admin_dn=None, ldap_group_attribute_name=None, ldap_group_search_filter=None, ldap_group_search_scope=None, ldap_scope=None, ldap_search_dn=None, ldap_timeout=None, ldap_uid=None, ldap_url=None, ldap_verify_cert=None, ldap_group_membership_attribute=None, project_creation_restriction=None, read_only=None, self_registration=None, token_expiration=None, uaa_client_id=None, uaa_client_secret=None, uaa_endpoint=None, uaa_verify_cert=None, http_authproxy_endpoint=None, http_authproxy_tokenreview_endpoint=None, http_authproxy_admin_groups=None, http_authproxy_admin_usernames=None, http_authproxy_verify_cert=None, http_authproxy_skip_search=None, http_authproxy_server_certificate=None, oidc_name=None, oidc_endpoint=None, oidc_client_id=None, oidc_groups_claim=None, oidc_admin_group=None, oidc_group_filter=None, oidc_scope=None, oidc_user_claim=None, oidc_verify_cert=None, oidc_auto_onboard=None, oidc_extra_redirect_parms=None, robot_token_duration=None, robot_name_prefix=None, notification_enable=None, quota_per_project_enable=None, storage_per_project=None, audit_log_forward_endpoint=None, skip_audit_log_database=None, scan_all_policy=None, session_timeout=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        auth_mode=None,
+        ldap_base_dn=None,
+        ldap_filter=None,
+        ldap_group_base_dn=None,
+        ldap_group_admin_dn=None,
+        ldap_group_attribute_name=None,
+        ldap_group_search_filter=None,
+        ldap_group_search_scope=None,
+        ldap_scope=None,
+        ldap_search_dn=None,
+        ldap_timeout=None,
+        ldap_uid=None,
+        ldap_url=None,
+        ldap_verify_cert=None,
+        ldap_group_membership_attribute=None,
+        project_creation_restriction=None,
+        read_only=None,
+        self_registration=None,
+        token_expiration=None,
+        uaa_client_id=None,
+        uaa_client_secret=None,
+        uaa_endpoint=None,
+        uaa_verify_cert=None,
+        http_authproxy_endpoint=None,
+        http_authproxy_tokenreview_endpoint=None,
+        http_authproxy_admin_groups=None,
+        http_authproxy_admin_usernames=None,
+        http_authproxy_verify_cert=None,
+        http_authproxy_skip_search=None,
+        http_authproxy_server_certificate=None,
+        oidc_name=None,
+        oidc_endpoint=None,
+        oidc_client_id=None,
+        oidc_groups_claim=None,
+        oidc_admin_group=None,
+        oidc_group_filter=None,
+        oidc_scope=None,
+        oidc_user_claim=None,
+        oidc_verify_cert=None,
+        oidc_auto_onboard=None,
+        oidc_extra_redirect_parms=None,
+        robot_token_duration=None,
+        robot_name_prefix=None,
+        notification_enable=None,
+        quota_per_project_enable=None,
+        storage_per_project=None,
+        audit_log_forward_endpoint=None,
+        skip_audit_log_database=None,
+        scan_all_policy=None,
+        session_timeout=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ConfigurationsResponse - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._auth_mode = None
         self._ldap_base_dn = None
@@ -1448,26 +1501,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ConfigurationsResponse, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/configurations_response_scan_all_policy.py` & `harbor_api_client-2.7.6/src/harbor_client/models/configurations_response_scan_all_policy.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'type': 'str',
-        'parameter': 'ConfigurationsResponseScanAllPolicyParameter'
-    }
-
-    attribute_map = {
-        'type': 'type',
-        'parameter': 'parameter'
-    }
+    swagger_types = {"type": "str", "parameter": "ConfigurationsResponseScanAllPolicyParameter"}
+
+    attribute_map = {"type": "type", "parameter": "parameter"}
 
     def __init__(self, type=None, parameter=None, _configuration=None):  # noqa: E501
         """ConfigurationsResponseScanAllPolicy - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -104,26 +98,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ConfigurationsResponseScanAllPolicy, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/configurations_response_scan_all_policy_parameter.py` & `harbor_api_client-2.7.6/src/harbor_client/models/configurations_response_scan_all_policy_parameter.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'daily_time': 'int'
-    }
-
-    attribute_map = {
-        'daily_time': 'daily_time'
-    }
+    swagger_types = {"daily_time": "int"}
+
+    attribute_map = {"daily_time": "daily_time"}
 
     def __init__(self, daily_time=None, _configuration=None):  # noqa: E501
         """ConfigurationsResponseScanAllPolicyParameter - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ConfigurationsResponseScanAllPolicyParameter, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/cve_allowlist.py` & `harbor_api_client-2.7.6/src/harbor_client/models/cve_allowlist.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'project_id': 'int',
-        'expires_at': 'int',
-        'items': 'list[CVEAllowlistItem]',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "project_id": "int",
+        "expires_at": "int",
+        "items": "list[CVEAllowlistItem]",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'project_id': 'project_id',
-        'expires_at': 'expires_at',
-        'items': 'items',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "project_id": "project_id",
+        "expires_at": "expires_at",
+        "items": "items",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, project_id=None, expires_at=None, items=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        project_id=None,
+        expires_at=None,
+        items=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """CVEAllowlist - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._project_id = None
@@ -216,26 +225,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(CVEAllowlist, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/cve_allowlist_item.py` & `harbor_api_client-2.7.6/src/harbor_client/models/quota_update_req.py`

 * *Files 12% similar despite different names*

```diff
@@ -15,92 +15,90 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class CVEAllowlistItem(object):
+class QuotaUpdateReq(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'cve_id': 'str'
-    }
-
-    attribute_map = {
-        'cve_id': 'cve_id'
-    }
+    swagger_types = {"hard": "ResourceList"}
 
-    def __init__(self, cve_id=None, _configuration=None):  # noqa: E501
-        """CVEAllowlistItem - a model defined in Swagger"""  # noqa: E501
+    attribute_map = {"hard": "hard"}
+
+    def __init__(self, hard=None, _configuration=None):  # noqa: E501
+        """QuotaUpdateReq - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
-        self._cve_id = None
+        self._hard = None
         self.discriminator = None
 
-        if cve_id is not None:
-            self.cve_id = cve_id
+        if hard is not None:
+            self.hard = hard
 
     @property
-    def cve_id(self):
-        """Gets the cve_id of this CVEAllowlistItem.  # noqa: E501
+    def hard(self):
+        """Gets the hard of this QuotaUpdateReq.  # noqa: E501
 
-        The ID of the CVE, such as \"CVE-2019-10164\"  # noqa: E501
+        The new hard limits for the quota  # noqa: E501
 
-        :return: The cve_id of this CVEAllowlistItem.  # noqa: E501
-        :rtype: str
+        :return: The hard of this QuotaUpdateReq.  # noqa: E501
+        :rtype: ResourceList
         """
-        return self._cve_id
+        return self._hard
 
-    @cve_id.setter
-    def cve_id(self, cve_id):
-        """Sets the cve_id of this CVEAllowlistItem.
+    @hard.setter
+    def hard(self, hard):
+        """Sets the hard of this QuotaUpdateReq.
 
-        The ID of the CVE, such as \"CVE-2019-10164\"  # noqa: E501
+        The new hard limits for the quota  # noqa: E501
 
-        :param cve_id: The cve_id of this CVEAllowlistItem.  # noqa: E501
-        :type: str
+        :param hard: The hard of this QuotaUpdateReq.  # noqa: E501
+        :type: ResourceList
         """
 
-        self._cve_id = cve_id
+        self._hard = hard
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(CVEAllowlistItem, dict):
+        if issubclass(QuotaUpdateReq, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -108,18 +106,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, CVEAllowlistItem):
+        if not isinstance(other, QuotaUpdateReq):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, CVEAllowlistItem):
+        if not isinstance(other, QuotaUpdateReq):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/endpoint.py` & `harbor_api_client-2.7.6/src/harbor_client/models/endpoint.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'url': 'str',
-        'verify_cert': 'bool'
-    }
-
-    attribute_map = {
-        'url': 'url',
-        'verify_cert': 'verify_cert'
-    }
+    swagger_types = {"url": "str", "verify_cert": "bool"}
+
+    attribute_map = {"url": "url", "verify_cert": "verify_cert"}
 
     def __init__(self, url=None, verify_cert=None, _configuration=None):  # noqa: E501
         """Endpoint - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Endpoint, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/error.py` & `harbor_api_client-2.7.6/src/harbor_client/models/error.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'code': 'str',
-        'message': 'str'
-    }
-
-    attribute_map = {
-        'code': 'code',
-        'message': 'message'
-    }
+    swagger_types = {"code": "str", "message": "str"}
+
+    attribute_map = {"code": "code", "message": "message"}
 
     def __init__(self, code=None, message=None, _configuration=None):  # noqa: E501
         """Error - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Error, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/errors.py` & `harbor_api_client-2.7.6/src/harbor_client/models/errors.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'errors': 'list[Error]'
-    }
-
-    attribute_map = {
-        'errors': 'errors'
-    }
+    swagger_types = {"errors": "list[Error]"}
+
+    attribute_map = {"errors": "errors"}
 
     def __init__(self, errors=None, _configuration=None):  # noqa: E501
         """Errors - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -76,26 +72,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Errors, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/event_type.py` & `harbor_api_client-2.7.6/src/harbor_client/models/event_type.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,19 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-    }
+    swagger_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
     def __init__(self, _configuration=None):  # noqa: E501
         """EventType - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
         self.discriminator = None
@@ -48,26 +46,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(EventType, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/exec_history.py` & `harbor_api_client-2.7.6/src/harbor_client/models/exec_history.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,38 +29,50 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'job_name': 'str',
-        'job_kind': 'str',
-        'job_parameters': 'str',
-        'schedule': 'ScheduleObj',
-        'job_status': 'str',
-        'deleted': 'bool',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "job_name": "str",
+        "job_kind": "str",
+        "job_parameters": "str",
+        "schedule": "ScheduleObj",
+        "job_status": "str",
+        "deleted": "bool",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'job_name': 'job_name',
-        'job_kind': 'job_kind',
-        'job_parameters': 'job_parameters',
-        'schedule': 'schedule',
-        'job_status': 'job_status',
-        'deleted': 'deleted',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "job_name": "job_name",
+        "job_kind": "job_kind",
+        "job_parameters": "job_parameters",
+        "schedule": "schedule",
+        "job_status": "job_status",
+        "deleted": "deleted",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, job_name=None, job_kind=None, job_parameters=None, schedule=None, job_status=None, deleted=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        job_name=None,
+        job_kind=None,
+        job_parameters=None,
+        schedule=None,
+        job_status=None,
+        deleted=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ExecHistory - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._job_name = None
@@ -300,26 +312,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ExecHistory, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/execution.py` & `harbor_api_client-2.7.6/src/harbor_client/models/execution.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,40 +29,53 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'vendor_type': 'str',
-        'vendor_id': 'int',
-        'status': 'str',
-        'status_message': 'str',
-        'metrics': 'Metrics',
-        'trigger': 'str',
-        'extra_attrs': 'ExtraAttrs',
-        'start_time': 'str',
-        'end_time': 'str'
+        "id": "int",
+        "vendor_type": "str",
+        "vendor_id": "int",
+        "status": "str",
+        "status_message": "str",
+        "metrics": "Metrics",
+        "trigger": "str",
+        "extra_attrs": "ExtraAttrs",
+        "start_time": "str",
+        "end_time": "str",
     }
 
     attribute_map = {
-        'id': 'id',
-        'vendor_type': 'vendor_type',
-        'vendor_id': 'vendor_id',
-        'status': 'status',
-        'status_message': 'status_message',
-        'metrics': 'metrics',
-        'trigger': 'trigger',
-        'extra_attrs': 'extra_attrs',
-        'start_time': 'start_time',
-        'end_time': 'end_time'
+        "id": "id",
+        "vendor_type": "vendor_type",
+        "vendor_id": "vendor_id",
+        "status": "status",
+        "status_message": "status_message",
+        "metrics": "metrics",
+        "trigger": "trigger",
+        "extra_attrs": "extra_attrs",
+        "start_time": "start_time",
+        "end_time": "end_time",
     }
 
-    def __init__(self, id=None, vendor_type=None, vendor_id=None, status=None, status_message=None, metrics=None, trigger=None, extra_attrs=None, start_time=None, end_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        vendor_type=None,
+        vendor_id=None,
+        status=None,
+        status_message=None,
+        metrics=None,
+        trigger=None,
+        extra_attrs=None,
+        start_time=None,
+        end_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Execution - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._vendor_type = None
@@ -326,26 +339,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Execution, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/extra_attrs.py` & `harbor_api_client-2.7.6/src/harbor_client/models/extra_attrs.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,19 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-    }
+    swagger_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
     def __init__(self, _configuration=None):  # noqa: E501
         """ExtraAttrs - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
         self.discriminator = None
@@ -48,26 +46,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ExtraAttrs, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/filter_style.py` & `harbor_api_client-2.7.6/src/harbor_client/models/filter_style.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'type': 'str',
-        'style': 'str',
-        'values': 'list[str]'
-    }
-
-    attribute_map = {
-        'type': 'type',
-        'style': 'style',
-        'values': 'values'
-    }
+    swagger_types = {"type": "str", "style": "str", "values": "list[str]"}
+
+    attribute_map = {"type": "type", "style": "style", "values": "values"}
 
     def __init__(self, type=None, style=None, values=None, _configuration=None):  # noqa: E501
         """FilterStyle - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -134,26 +126,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(FilterStyle, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/gc_history.py` & `harbor_api_client-2.7.6/src/harbor_client/models/gc_history.py`

 * *Files 8% similar despite different names*

```diff
@@ -29,38 +29,50 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'job_name': 'str',
-        'job_kind': 'str',
-        'job_parameters': 'str',
-        'schedule': 'ScheduleObj',
-        'job_status': 'str',
-        'deleted': 'bool',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "job_name": "str",
+        "job_kind": "str",
+        "job_parameters": "str",
+        "schedule": "ScheduleObj",
+        "job_status": "str",
+        "deleted": "bool",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'job_name': 'job_name',
-        'job_kind': 'job_kind',
-        'job_parameters': 'job_parameters',
-        'schedule': 'schedule',
-        'job_status': 'job_status',
-        'deleted': 'deleted',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "job_name": "job_name",
+        "job_kind": "job_kind",
+        "job_parameters": "job_parameters",
+        "schedule": "schedule",
+        "job_status": "job_status",
+        "deleted": "deleted",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, job_name=None, job_kind=None, job_parameters=None, schedule=None, job_status=None, deleted=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        job_name=None,
+        job_kind=None,
+        job_parameters=None,
+        schedule=None,
+        job_status=None,
+        deleted=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """GCHistory - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._job_name = None
@@ -300,26 +312,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(GCHistory, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/general_info.py` & `harbor_api_client-2.7.6/src/harbor_client/models/general_info.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,48 +29,65 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'current_time': 'datetime',
-        'with_notary': 'bool',
-        'with_chartmuseum': 'bool',
-        'registry_url': 'str',
-        'external_url': 'str',
-        'auth_mode': 'str',
-        'project_creation_restriction': 'str',
-        'self_registration': 'bool',
-        'has_ca_root': 'bool',
-        'harbor_version': 'str',
-        'registry_storage_provider_name': 'str',
-        'read_only': 'bool',
-        'notification_enable': 'bool',
-        'authproxy_settings': 'AuthproxySetting'
+        "current_time": "datetime",
+        "with_notary": "bool",
+        "with_chartmuseum": "bool",
+        "registry_url": "str",
+        "external_url": "str",
+        "auth_mode": "str",
+        "project_creation_restriction": "str",
+        "self_registration": "bool",
+        "has_ca_root": "bool",
+        "harbor_version": "str",
+        "registry_storage_provider_name": "str",
+        "read_only": "bool",
+        "notification_enable": "bool",
+        "authproxy_settings": "AuthproxySetting",
     }
 
     attribute_map = {
-        'current_time': 'current_time',
-        'with_notary': 'with_notary',
-        'with_chartmuseum': 'with_chartmuseum',
-        'registry_url': 'registry_url',
-        'external_url': 'external_url',
-        'auth_mode': 'auth_mode',
-        'project_creation_restriction': 'project_creation_restriction',
-        'self_registration': 'self_registration',
-        'has_ca_root': 'has_ca_root',
-        'harbor_version': 'harbor_version',
-        'registry_storage_provider_name': 'registry_storage_provider_name',
-        'read_only': 'read_only',
-        'notification_enable': 'notification_enable',
-        'authproxy_settings': 'authproxy_settings'
+        "current_time": "current_time",
+        "with_notary": "with_notary",
+        "with_chartmuseum": "with_chartmuseum",
+        "registry_url": "registry_url",
+        "external_url": "external_url",
+        "auth_mode": "auth_mode",
+        "project_creation_restriction": "project_creation_restriction",
+        "self_registration": "self_registration",
+        "has_ca_root": "has_ca_root",
+        "harbor_version": "harbor_version",
+        "registry_storage_provider_name": "registry_storage_provider_name",
+        "read_only": "read_only",
+        "notification_enable": "notification_enable",
+        "authproxy_settings": "authproxy_settings",
     }
 
-    def __init__(self, current_time=None, with_notary=None, with_chartmuseum=None, registry_url=None, external_url=None, auth_mode=None, project_creation_restriction=None, self_registration=None, has_ca_root=None, harbor_version=None, registry_storage_provider_name=None, read_only=None, notification_enable=None, authproxy_settings=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        current_time=None,
+        with_notary=None,
+        with_chartmuseum=None,
+        registry_url=None,
+        external_url=None,
+        auth_mode=None,
+        project_creation_restriction=None,
+        self_registration=None,
+        has_ca_root=None,
+        harbor_version=None,
+        registry_storage_provider_name=None,
+        read_only=None,
+        notification_enable=None,
+        authproxy_settings=None,
+        _configuration=None,
+    ):  # noqa: E501
         """GeneralInfo - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._current_time = None
         self._with_notary = None
@@ -442,26 +459,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(GeneralInfo, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/icon.py` & `harbor_api_client-2.7.6/src/harbor_client/models/icon.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'content_type': 'str',
-        'content': 'str'
-    }
-
-    attribute_map = {
-        'content_type': 'content-type',
-        'content': 'content'
-    }
+    swagger_types = {"content_type": "str", "content": "str"}
+
+    attribute_map = {"content_type": "content-type", "content": "content"}
 
     def __init__(self, content_type=None, content=None, _configuration=None):  # noqa: E501
         """Icon - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Icon, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/immutable_rule.py` & `harbor_api_client-2.7.6/src/harbor_client/models/immutable_rule.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,36 +29,47 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'priority': 'int',
-        'disabled': 'bool',
-        'action': 'str',
-        'template': 'str',
-        'params': 'dict(str, object)',
-        'tag_selectors': 'list[ImmutableSelector]',
-        'scope_selectors': 'dict(str, list[ImmutableSelector])'
+        "id": "int",
+        "priority": "int",
+        "disabled": "bool",
+        "action": "str",
+        "template": "str",
+        "params": "dict(str, object)",
+        "tag_selectors": "list[ImmutableSelector]",
+        "scope_selectors": "dict(str, list[ImmutableSelector])",
     }
 
     attribute_map = {
-        'id': 'id',
-        'priority': 'priority',
-        'disabled': 'disabled',
-        'action': 'action',
-        'template': 'template',
-        'params': 'params',
-        'tag_selectors': 'tag_selectors',
-        'scope_selectors': 'scope_selectors'
+        "id": "id",
+        "priority": "priority",
+        "disabled": "disabled",
+        "action": "action",
+        "template": "template",
+        "params": "params",
+        "tag_selectors": "tag_selectors",
+        "scope_selectors": "scope_selectors",
     }
 
-    def __init__(self, id=None, priority=None, disabled=None, action=None, template=None, params=None, tag_selectors=None, scope_selectors=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        priority=None,
+        disabled=None,
+        action=None,
+        template=None,
+        params=None,
+        tag_selectors=None,
+        scope_selectors=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ImmutableRule - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._priority = None
@@ -258,26 +269,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ImmutableRule, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/immutable_selector.py` & `harbor_api_client-2.7.6/src/harbor_client/models/immutable_selector.py`

 * *Files 13% similar despite different names*

```diff
@@ -28,29 +28,26 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'kind': 'str',
-        'decoration': 'str',
-        'pattern': 'str',
-        'extras': 'str'
-    }
+    swagger_types = {"kind": "str", "decoration": "str", "pattern": "str", "extras": "str"}
 
     attribute_map = {
-        'kind': 'kind',
-        'decoration': 'decoration',
-        'pattern': 'pattern',
-        'extras': 'extras'
+        "kind": "kind",
+        "decoration": "decoration",
+        "pattern": "pattern",
+        "extras": "extras",
     }
 
-    def __init__(self, kind=None, decoration=None, pattern=None, extras=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, kind=None, decoration=None, pattern=None, extras=None, _configuration=None
+    ):  # noqa: E501
         """ImmutableSelector - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._kind = None
         self._decoration = None
@@ -154,26 +151,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ImmutableSelector, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/instance.py` & `harbor_api_client-2.7.6/src/harbor_client/models/instance.py`

 * *Files 5% similar despite different names*

```diff
@@ -29,44 +29,59 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'name': 'str',
-        'description': 'str',
-        'vendor': 'str',
-        'endpoint': 'str',
-        'auth_mode': 'str',
-        'auth_info': 'dict(str, str)',
-        'status': 'str',
-        'enabled': 'bool',
-        'default': 'bool',
-        'insecure': 'bool',
-        'setup_timestamp': 'int'
+        "id": "int",
+        "name": "str",
+        "description": "str",
+        "vendor": "str",
+        "endpoint": "str",
+        "auth_mode": "str",
+        "auth_info": "dict(str, str)",
+        "status": "str",
+        "enabled": "bool",
+        "default": "bool",
+        "insecure": "bool",
+        "setup_timestamp": "int",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'description': 'description',
-        'vendor': 'vendor',
-        'endpoint': 'endpoint',
-        'auth_mode': 'auth_mode',
-        'auth_info': 'auth_info',
-        'status': 'status',
-        'enabled': 'enabled',
-        'default': 'default',
-        'insecure': 'insecure',
-        'setup_timestamp': 'setup_timestamp'
+        "id": "id",
+        "name": "name",
+        "description": "description",
+        "vendor": "vendor",
+        "endpoint": "endpoint",
+        "auth_mode": "auth_mode",
+        "auth_info": "auth_info",
+        "status": "status",
+        "enabled": "enabled",
+        "default": "default",
+        "insecure": "insecure",
+        "setup_timestamp": "setup_timestamp",
     }
 
-    def __init__(self, id=None, name=None, description=None, vendor=None, endpoint=None, auth_mode=None, auth_info=None, status=None, enabled=None, default=None, insecure=None, setup_timestamp=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        description=None,
+        vendor=None,
+        endpoint=None,
+        auth_mode=None,
+        auth_info=None,
+        status=None,
+        enabled=None,
+        default=None,
+        insecure=None,
+        setup_timestamp=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Instance - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._name = None
@@ -386,26 +401,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Instance, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/integer_config_item.py` & `harbor_api_client-2.7.6/src/harbor_client/models/integer_config_item.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'value': 'int',
-        'editable': 'bool'
-    }
-
-    attribute_map = {
-        'value': 'value',
-        'editable': 'editable'
-    }
+    swagger_types = {"value": "int", "editable": "bool"}
+
+    attribute_map = {"value": "value", "editable": "editable"}
 
     def __init__(self, value=None, editable=None, _configuration=None):  # noqa: E501
         """IntegerConfigItem - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(IntegerConfigItem, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/internal_configuration_value.py` & `harbor_api_client-2.7.6/src/harbor_client/models/internal_configuration_value.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'value': 'object',
-        'editable': 'bool'
-    }
-
-    attribute_map = {
-        'value': 'value',
-        'editable': 'editable'
-    }
+    swagger_types = {"value": "object", "editable": "bool"}
+
+    attribute_map = {"value": "value", "editable": "editable"}
 
     def __init__(self, value=None, editable=None, _configuration=None):  # noqa: E501
         """InternalConfigurationValue - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(InternalConfigurationValue, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/internal_configurations_response.py` & `harbor_api_client-2.7.6/src/harbor_client/models/internal_configurations_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -28,19 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-    }
+    swagger_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
     def __init__(self, _configuration=None):  # noqa: E501
         """InternalConfigurationsResponse - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
         self.discriminator = None
@@ -48,26 +46,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(InternalConfigurationsResponse, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/is_default.py` & `harbor_api_client-2.7.6/src/harbor_client/models/is_default.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'is_default': 'bool'
-    }
-
-    attribute_map = {
-        'is_default': 'is_default'
-    }
+    swagger_types = {"is_default": "bool"}
+
+    attribute_map = {"is_default": "is_default"}
 
     def __init__(self, is_default=None, _configuration=None):  # noqa: E501
         """IsDefault - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(IsDefault, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/job_queue.py` & `harbor_api_client-2.7.6/src/harbor_client/models/job_queue.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,29 +28,26 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'job_type': 'str',
-        'count': 'int',
-        'latency': 'int',
-        'paused': 'bool'
-    }
+    swagger_types = {"job_type": "str", "count": "int", "latency": "int", "paused": "bool"}
 
     attribute_map = {
-        'job_type': 'job_type',
-        'count': 'count',
-        'latency': 'latency',
-        'paused': 'paused'
+        "job_type": "job_type",
+        "count": "count",
+        "latency": "latency",
+        "paused": "paused",
     }
 
-    def __init__(self, job_type=None, count=None, latency=None, paused=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, job_type=None, count=None, latency=None, paused=None, _configuration=None
+    ):  # noqa: E501
         """JobQueue - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._job_type = None
         self._count = None
@@ -162,26 +159,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(JobQueue, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/label.py` & `harbor_api_client-2.7.6/src/harbor_client/models/label.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,36 +29,47 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'name': 'str',
-        'description': 'str',
-        'color': 'str',
-        'scope': 'str',
-        'project_id': 'int',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "name": "str",
+        "description": "str",
+        "color": "str",
+        "scope": "str",
+        "project_id": "int",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'description': 'description',
-        'color': 'color',
-        'scope': 'scope',
-        'project_id': 'project_id',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "name": "name",
+        "description": "description",
+        "color": "color",
+        "scope": "scope",
+        "project_id": "project_id",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, name=None, description=None, color=None, scope=None, project_id=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        description=None,
+        color=None,
+        scope=None,
+        project_id=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Label - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._name = None
@@ -274,26 +285,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Label, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/ldap_conf.py` & `harbor_api_client-2.7.6/src/harbor_client/models/ldap_conf.py`

 * *Files 10% similar despite different names*

```diff
@@ -29,38 +29,50 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'ldap_url': 'str',
-        'ldap_search_dn': 'str',
-        'ldap_search_password': 'str',
-        'ldap_base_dn': 'str',
-        'ldap_filter': 'str',
-        'ldap_uid': 'str',
-        'ldap_scope': 'int',
-        'ldap_connection_timeout': 'int',
-        'ldap_verify_cert': 'bool'
+        "ldap_url": "str",
+        "ldap_search_dn": "str",
+        "ldap_search_password": "str",
+        "ldap_base_dn": "str",
+        "ldap_filter": "str",
+        "ldap_uid": "str",
+        "ldap_scope": "int",
+        "ldap_connection_timeout": "int",
+        "ldap_verify_cert": "bool",
     }
 
     attribute_map = {
-        'ldap_url': 'ldap_url',
-        'ldap_search_dn': 'ldap_search_dn',
-        'ldap_search_password': 'ldap_search_password',
-        'ldap_base_dn': 'ldap_base_dn',
-        'ldap_filter': 'ldap_filter',
-        'ldap_uid': 'ldap_uid',
-        'ldap_scope': 'ldap_scope',
-        'ldap_connection_timeout': 'ldap_connection_timeout',
-        'ldap_verify_cert': 'ldap_verify_cert'
+        "ldap_url": "ldap_url",
+        "ldap_search_dn": "ldap_search_dn",
+        "ldap_search_password": "ldap_search_password",
+        "ldap_base_dn": "ldap_base_dn",
+        "ldap_filter": "ldap_filter",
+        "ldap_uid": "ldap_uid",
+        "ldap_scope": "ldap_scope",
+        "ldap_connection_timeout": "ldap_connection_timeout",
+        "ldap_verify_cert": "ldap_verify_cert",
     }
 
-    def __init__(self, ldap_url=None, ldap_search_dn=None, ldap_search_password=None, ldap_base_dn=None, ldap_filter=None, ldap_uid=None, ldap_scope=None, ldap_connection_timeout=None, ldap_verify_cert=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        ldap_url=None,
+        ldap_search_dn=None,
+        ldap_search_password=None,
+        ldap_base_dn=None,
+        ldap_filter=None,
+        ldap_uid=None,
+        ldap_scope=None,
+        ldap_connection_timeout=None,
+        ldap_verify_cert=None,
+        _configuration=None,
+    ):  # noqa: E501
         """LdapConf - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._ldap_url = None
         self._ldap_search_dn = None
@@ -302,26 +314,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(LdapConf, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/ldap_failed_import_user.py` & `harbor_api_client-2.7.6/src/harbor_client/models/ldap_failed_import_user.py`

 * *Files 5% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'uid': 'str',
-        'error': 'str'
-    }
-
-    attribute_map = {
-        'uid': 'uid',
-        'error': 'error'
-    }
+    swagger_types = {"uid": "str", "error": "str"}
+
+    attribute_map = {"uid": "uid", "error": "error"}
 
     def __init__(self, uid=None, error=None, _configuration=None):  # noqa: E501
         """LdapFailedImportUser - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(LdapFailedImportUser, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/ldap_import_users.py` & `harbor_api_client-2.7.6/src/harbor_client/models/ldap_import_users.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'ldap_uid_list': 'list[str]'
-    }
-
-    attribute_map = {
-        'ldap_uid_list': 'ldap_uid_list'
-    }
+    swagger_types = {"ldap_uid_list": "list[str]"}
+
+    attribute_map = {"ldap_uid_list": "ldap_uid_list"}
 
     def __init__(self, ldap_uid_list=None, _configuration=None):  # noqa: E501
         """LdapImportUsers - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(LdapImportUsers, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/ldap_ping_result.py` & `harbor_api_client-2.7.6/src/harbor_client/models/ldap_ping_result.py`

 * *Files 15% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'success': 'bool',
-        'message': 'str'
-    }
-
-    attribute_map = {
-        'success': 'success',
-        'message': 'message'
-    }
+    swagger_types = {"success": "bool", "message": "str"}
+
+    attribute_map = {"success": "success", "message": "message"}
 
     def __init__(self, success=None, message=None, _configuration=None):  # noqa: E501
         """LdapPingResult - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(LdapPingResult, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/ldap_user.py` & `harbor_api_client-2.7.6/src/harbor_client/models/ldap_user.py`

 * *Files 10% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'username': 'str',
-        'realname': 'str',
-        'email': 'str'
-    }
-
-    attribute_map = {
-        'username': 'username',
-        'realname': 'realname',
-        'email': 'email'
-    }
+    swagger_types = {"username": "str", "realname": "str", "email": "str"}
+
+    attribute_map = {"username": "username", "realname": "realname", "email": "email"}
 
     def __init__(self, username=None, realname=None, email=None, _configuration=None):  # noqa: E501
         """LdapUser - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -134,26 +126,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(LdapUser, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/metadata.py` & `harbor_api_client-2.7.6/src/harbor_client/models/metadata.py`

 * *Files 16% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'str',
-        'name': 'str',
-        'icon': 'str',
-        'maintainers': 'list[str]',
-        'version': 'str',
-        'source': 'str'
+        "id": "str",
+        "name": "str",
+        "icon": "str",
+        "maintainers": "list[str]",
+        "version": "str",
+        "source": "str",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'icon': 'icon',
-        'maintainers': 'maintainers',
-        'version': 'version',
-        'source': 'source'
+        "id": "id",
+        "name": "name",
+        "icon": "icon",
+        "maintainers": "maintainers",
+        "version": "version",
+        "source": "source",
     }
 
-    def __init__(self, id=None, name=None, icon=None, maintainers=None, version=None, source=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        icon=None,
+        maintainers=None,
+        version=None,
+        source=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Metadata - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._name = None
@@ -218,26 +227,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Metadata, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/metrics.py` & `harbor_api_client-2.7.6/src/harbor_client/models/metrics.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,34 +29,44 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'task_count': 'int',
-        'success_task_count': 'int',
-        'error_task_count': 'int',
-        'pending_task_count': 'int',
-        'running_task_count': 'int',
-        'scheduled_task_count': 'int',
-        'stopped_task_count': 'int'
+        "task_count": "int",
+        "success_task_count": "int",
+        "error_task_count": "int",
+        "pending_task_count": "int",
+        "running_task_count": "int",
+        "scheduled_task_count": "int",
+        "stopped_task_count": "int",
     }
 
     attribute_map = {
-        'task_count': 'task_count',
-        'success_task_count': 'success_task_count',
-        'error_task_count': 'error_task_count',
-        'pending_task_count': 'pending_task_count',
-        'running_task_count': 'running_task_count',
-        'scheduled_task_count': 'scheduled_task_count',
-        'stopped_task_count': 'stopped_task_count'
+        "task_count": "task_count",
+        "success_task_count": "success_task_count",
+        "error_task_count": "error_task_count",
+        "pending_task_count": "pending_task_count",
+        "running_task_count": "running_task_count",
+        "scheduled_task_count": "scheduled_task_count",
+        "stopped_task_count": "stopped_task_count",
     }
 
-    def __init__(self, task_count=None, success_task_count=None, error_task_count=None, pending_task_count=None, running_task_count=None, scheduled_task_count=None, stopped_task_count=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        task_count=None,
+        success_task_count=None,
+        error_task_count=None,
+        pending_task_count=None,
+        running_task_count=None,
+        scheduled_task_count=None,
+        stopped_task_count=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Metrics - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._task_count = None
         self._success_task_count = None
@@ -246,26 +256,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Metrics, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/native_report_summary.py` & `harbor_api_client-2.7.6/src/harbor_client/models/native_report_summary.py`

 * *Files 12% similar despite different names*

```diff
@@ -29,38 +29,50 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'report_id': 'str',
-        'scan_status': 'str',
-        'severity': 'str',
-        'duration': 'int',
-        'summary': 'VulnerabilitySummary',
-        'start_time': 'datetime',
-        'end_time': 'datetime',
-        'complete_percent': 'int',
-        'scanner': 'Scanner'
+        "report_id": "str",
+        "scan_status": "str",
+        "severity": "str",
+        "duration": "int",
+        "summary": "VulnerabilitySummary",
+        "start_time": "datetime",
+        "end_time": "datetime",
+        "complete_percent": "int",
+        "scanner": "Scanner",
     }
 
     attribute_map = {
-        'report_id': 'report_id',
-        'scan_status': 'scan_status',
-        'severity': 'severity',
-        'duration': 'duration',
-        'summary': 'summary',
-        'start_time': 'start_time',
-        'end_time': 'end_time',
-        'complete_percent': 'complete_percent',
-        'scanner': 'scanner'
+        "report_id": "report_id",
+        "scan_status": "scan_status",
+        "severity": "severity",
+        "duration": "duration",
+        "summary": "summary",
+        "start_time": "start_time",
+        "end_time": "end_time",
+        "complete_percent": "complete_percent",
+        "scanner": "scanner",
     }
 
-    def __init__(self, report_id=None, scan_status=None, severity=None, duration=None, summary=None, start_time=None, end_time=None, complete_percent=None, scanner=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        report_id=None,
+        scan_status=None,
+        severity=None,
+        duration=None,
+        summary=None,
+        start_time=None,
+        end_time=None,
+        complete_percent=None,
+        scanner=None,
+        _configuration=None,
+    ):  # noqa: E501
         """NativeReportSummary - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._report_id = None
         self._scan_status = None
@@ -298,26 +310,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(NativeReportSummary, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/notify_type.py` & `harbor_api_client-2.7.6/src/harbor_client/models/quota_ref_object.py`

 * *Files 7% similar despite different names*

```diff
@@ -15,62 +15,62 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class NotifyType(object):
+class QuotaRefObject(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-    }
+    swagger_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
     def __init__(self, _configuration=None):  # noqa: E501
-        """NotifyType - a model defined in Swagger"""  # noqa: E501
+        """QuotaRefObject - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
         self.discriminator = None
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(NotifyType, dict):
+        if issubclass(QuotaRefObject, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -78,18 +78,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NotifyType):
+        if not isinstance(other, QuotaRefObject):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, NotifyType):
+        if not isinstance(other, QuotaRefObject):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/oidc_cli_secret_req.py` & `harbor_api_client-2.7.6/src/harbor_client/models/oidc_cli_secret_req.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'secret': 'str'
-    }
-
-    attribute_map = {
-        'secret': 'secret'
-    }
+    swagger_types = {"secret": "str"}
+
+    attribute_map = {"secret": "secret"}
 
     def __init__(self, secret=None, _configuration=None):  # noqa: E501
         """OIDCCliSecretReq - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(OIDCCliSecretReq, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/oidc_user_info.py` & `harbor_api_client-2.7.6/src/harbor_client/models/oidc_user_info.py`

 * *Files 15% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'user_id': 'int',
-        'subiss': 'str',
-        'secret': 'str',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "user_id": "int",
+        "subiss": "str",
+        "secret": "str",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'user_id': 'user_id',
-        'subiss': 'subiss',
-        'secret': 'secret',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "user_id": "user_id",
+        "subiss": "subiss",
+        "secret": "secret",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, user_id=None, subiss=None, secret=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        user_id=None,
+        subiss=None,
+        secret=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """OIDCUserInfo - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._user_id = None
@@ -218,26 +227,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(OIDCUserInfo, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/overall_health_status.py` & `harbor_api_client-2.7.6/src/harbor_client/models/overall_health_status.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'status': 'str',
-        'components': 'list[ComponentHealthStatus]'
-    }
-
-    attribute_map = {
-        'status': 'status',
-        'components': 'components'
-    }
+    swagger_types = {"status": "str", "components": "list[ComponentHealthStatus]"}
+
+    attribute_map = {"status": "status", "components": "components"}
 
     def __init__(self, status=None, components=None, _configuration=None):  # noqa: E501
         """OverallHealthStatus - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -104,26 +98,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(OverallHealthStatus, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/password_req.py` & `harbor_api_client-2.7.6/src/harbor_client/models/password_req.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'old_password': 'str',
-        'new_password': 'str'
-    }
-
-    attribute_map = {
-        'old_password': 'old_password',
-        'new_password': 'new_password'
-    }
+    swagger_types = {"old_password": "str", "new_password": "str"}
+
+    attribute_map = {"old_password": "old_password", "new_password": "new_password"}
 
     def __init__(self, old_password=None, new_password=None, _configuration=None):  # noqa: E501
         """PasswordReq - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(PasswordReq, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/permission.py` & `harbor_api_client-2.7.6/src/harbor_client/models/user_sys_admin_flag.py`

 * *Files 16% similar despite different names*

```diff
@@ -15,120 +15,90 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class Permission(object):
+class UserSysAdminFlag(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'resource': 'str',
-        'action': 'str'
-    }
-
-    attribute_map = {
-        'resource': 'resource',
-        'action': 'action'
-    }
+    swagger_types = {"sysadmin_flag": "bool"}
 
-    def __init__(self, resource=None, action=None, _configuration=None):  # noqa: E501
-        """Permission - a model defined in Swagger"""  # noqa: E501
+    attribute_map = {"sysadmin_flag": "sysadmin_flag"}
+
+    def __init__(self, sysadmin_flag=None, _configuration=None):  # noqa: E501
+        """UserSysAdminFlag - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
-        self._resource = None
-        self._action = None
+        self._sysadmin_flag = None
         self.discriminator = None
 
-        if resource is not None:
-            self.resource = resource
-        if action is not None:
-            self.action = action
-
-    @property
-    def resource(self):
-        """Gets the resource of this Permission.  # noqa: E501
-
-        The permission resoruce  # noqa: E501
-
-        :return: The resource of this Permission.  # noqa: E501
-        :rtype: str
-        """
-        return self._resource
-
-    @resource.setter
-    def resource(self, resource):
-        """Sets the resource of this Permission.
-
-        The permission resoruce  # noqa: E501
-
-        :param resource: The resource of this Permission.  # noqa: E501
-        :type: str
-        """
-
-        self._resource = resource
+        if sysadmin_flag is not None:
+            self.sysadmin_flag = sysadmin_flag
 
     @property
-    def action(self):
-        """Gets the action of this Permission.  # noqa: E501
+    def sysadmin_flag(self):
+        """Gets the sysadmin_flag of this UserSysAdminFlag.  # noqa: E501
 
-        The permission action  # noqa: E501
+        true-admin, false-not admin.  # noqa: E501
 
-        :return: The action of this Permission.  # noqa: E501
-        :rtype: str
+        :return: The sysadmin_flag of this UserSysAdminFlag.  # noqa: E501
+        :rtype: bool
         """
-        return self._action
+        return self._sysadmin_flag
 
-    @action.setter
-    def action(self, action):
-        """Sets the action of this Permission.
+    @sysadmin_flag.setter
+    def sysadmin_flag(self, sysadmin_flag):
+        """Sets the sysadmin_flag of this UserSysAdminFlag.
 
-        The permission action  # noqa: E501
+        true-admin, false-not admin.  # noqa: E501
 
-        :param action: The action of this Permission.  # noqa: E501
-        :type: str
+        :param sysadmin_flag: The sysadmin_flag of this UserSysAdminFlag.  # noqa: E501
+        :type: bool
         """
 
-        self._action = action
+        self._sysadmin_flag = sysadmin_flag
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(Permission, dict):
+        if issubclass(UserSysAdminFlag, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -136,18 +106,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Permission):
+        if not isinstance(other, UserSysAdminFlag):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Permission):
+        if not isinstance(other, UserSysAdminFlag):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/platform.py` & `harbor_api_client-2.7.6/src/harbor_client/models/platform.py`

 * *Files 5% similar despite different names*

```diff
@@ -29,30 +29,38 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'architecture': 'str',
-        'os': 'str',
-        'os_version': 'str',
-        'os_features': 'list[str]',
-        'variant': 'str'
+        "architecture": "str",
+        "os": "str",
+        "os_version": "str",
+        "os_features": "list[str]",
+        "variant": "str",
     }
 
     attribute_map = {
-        'architecture': 'architecture',
-        'os': 'os',
-        'os_version': '&#39;os.version&#39;',
-        'os_features': '&#39;os.features&#39;',
-        'variant': 'variant'
+        "architecture": "architecture",
+        "os": "os",
+        "os_version": "&#39;os.version&#39;",
+        "os_features": "&#39;os.features&#39;",
+        "variant": "variant",
     }
 
-    def __init__(self, architecture=None, os=None, os_version=None, os_features=None, variant=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        architecture=None,
+        os=None,
+        os_version=None,
+        os_features=None,
+        variant=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Platform - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._architecture = None
         self._os = None
@@ -190,26 +198,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Platform, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/preheat_policy.py` & `harbor_api_client-2.7.6/src/harbor_client/models/preheat_policy.py`

 * *Files 8% similar despite different names*

```diff
@@ -29,42 +29,56 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'name': 'str',
-        'description': 'str',
-        'project_id': 'int',
-        'provider_id': 'int',
-        'provider_name': 'str',
-        'filters': 'str',
-        'trigger': 'str',
-        'enabled': 'bool',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "name": "str",
+        "description": "str",
+        "project_id": "int",
+        "provider_id": "int",
+        "provider_name": "str",
+        "filters": "str",
+        "trigger": "str",
+        "enabled": "bool",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'description': 'description',
-        'project_id': 'project_id',
-        'provider_id': 'provider_id',
-        'provider_name': 'provider_name',
-        'filters': 'filters',
-        'trigger': 'trigger',
-        'enabled': 'enabled',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "name": "name",
+        "description": "description",
+        "project_id": "project_id",
+        "provider_id": "provider_id",
+        "provider_name": "provider_name",
+        "filters": "filters",
+        "trigger": "trigger",
+        "enabled": "enabled",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, name=None, description=None, project_id=None, provider_id=None, provider_name=None, filters=None, trigger=None, enabled=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        description=None,
+        project_id=None,
+        provider_id=None,
+        provider_name=None,
+        filters=None,
+        trigger=None,
+        enabled=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """PreheatPolicy - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._name = None
@@ -358,26 +372,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(PreheatPolicy, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/project.py` & `harbor_api_client-2.7.6/src/harbor_client/models/project.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,50 +29,68 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'project_id': 'int',
-        'owner_id': 'int',
-        'name': 'str',
-        'registry_id': 'int',
-        'creation_time': 'datetime',
-        'update_time': 'datetime',
-        'deleted': 'bool',
-        'owner_name': 'str',
-        'togglable': 'bool',
-        'current_user_role_id': 'int',
-        'current_user_role_ids': 'list[int]',
-        'repo_count': 'int',
-        'chart_count': 'int',
-        'metadata': 'ProjectMetadata',
-        'cve_allowlist': 'CVEAllowlist'
+        "project_id": "int",
+        "owner_id": "int",
+        "name": "str",
+        "registry_id": "int",
+        "creation_time": "datetime",
+        "update_time": "datetime",
+        "deleted": "bool",
+        "owner_name": "str",
+        "togglable": "bool",
+        "current_user_role_id": "int",
+        "current_user_role_ids": "list[int]",
+        "repo_count": "int",
+        "chart_count": "int",
+        "metadata": "ProjectMetadata",
+        "cve_allowlist": "CVEAllowlist",
     }
 
     attribute_map = {
-        'project_id': 'project_id',
-        'owner_id': 'owner_id',
-        'name': 'name',
-        'registry_id': 'registry_id',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time',
-        'deleted': 'deleted',
-        'owner_name': 'owner_name',
-        'togglable': 'togglable',
-        'current_user_role_id': 'current_user_role_id',
-        'current_user_role_ids': 'current_user_role_ids',
-        'repo_count': 'repo_count',
-        'chart_count': 'chart_count',
-        'metadata': 'metadata',
-        'cve_allowlist': 'cve_allowlist'
+        "project_id": "project_id",
+        "owner_id": "owner_id",
+        "name": "name",
+        "registry_id": "registry_id",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
+        "deleted": "deleted",
+        "owner_name": "owner_name",
+        "togglable": "togglable",
+        "current_user_role_id": "current_user_role_id",
+        "current_user_role_ids": "current_user_role_ids",
+        "repo_count": "repo_count",
+        "chart_count": "chart_count",
+        "metadata": "metadata",
+        "cve_allowlist": "cve_allowlist",
     }
 
-    def __init__(self, project_id=None, owner_id=None, name=None, registry_id=None, creation_time=None, update_time=None, deleted=None, owner_name=None, togglable=None, current_user_role_id=None, current_user_role_ids=None, repo_count=None, chart_count=None, metadata=None, cve_allowlist=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        project_id=None,
+        owner_id=None,
+        name=None,
+        registry_id=None,
+        creation_time=None,
+        update_time=None,
+        deleted=None,
+        owner_name=None,
+        togglable=None,
+        current_user_role_id=None,
+        current_user_role_ids=None,
+        repo_count=None,
+        chart_count=None,
+        metadata=None,
+        cve_allowlist=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Project - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._project_id = None
         self._owner_id = None
@@ -470,26 +488,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Project, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/project_deletable.py` & `harbor_api_client-2.7.6/src/harbor_client/models/project_deletable.py`

 * *Files 12% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'deletable': 'bool',
-        'message': 'str'
-    }
-
-    attribute_map = {
-        'deletable': 'deletable',
-        'message': 'message'
-    }
+    swagger_types = {"deletable": "bool", "message": "str"}
+
+    attribute_map = {"deletable": "deletable", "message": "message"}
 
     def __init__(self, deletable=None, message=None, _configuration=None):  # noqa: E501
         """ProjectDeletable - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ProjectDeletable, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/project_member.py` & `harbor_api_client-2.7.6/src/harbor_client/models/project_member.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,27 +28,25 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'role_id': 'int',
-        'member_user': 'UserEntity',
-        'member_group': 'UserGroup'
-    }
+    swagger_types = {"role_id": "int", "member_user": "UserEntity", "member_group": "UserGroup"}
 
     attribute_map = {
-        'role_id': 'role_id',
-        'member_user': 'member_user',
-        'member_group': 'member_group'
+        "role_id": "role_id",
+        "member_user": "member_user",
+        "member_group": "member_group",
     }
 
-    def __init__(self, role_id=None, member_user=None, member_group=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, role_id=None, member_user=None, member_group=None, _configuration=None
+    ):  # noqa: E501
         """ProjectMember - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._role_id = None
         self._member_user = None
@@ -130,26 +128,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ProjectMember, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/project_member_entity.py` & `harbor_api_client-2.7.6/src/harbor_client/models/project_member_entity.py`

 * *Files 10% similar despite different names*

```diff
@@ -29,34 +29,44 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'project_id': 'int',
-        'entity_name': 'str',
-        'role_name': 'str',
-        'role_id': 'int',
-        'entity_id': 'int',
-        'entity_type': 'str'
+        "id": "int",
+        "project_id": "int",
+        "entity_name": "str",
+        "role_name": "str",
+        "role_id": "int",
+        "entity_id": "int",
+        "entity_type": "str",
     }
 
     attribute_map = {
-        'id': 'id',
-        'project_id': 'project_id',
-        'entity_name': 'entity_name',
-        'role_name': 'role_name',
-        'role_id': 'role_id',
-        'entity_id': 'entity_id',
-        'entity_type': 'entity_type'
+        "id": "id",
+        "project_id": "project_id",
+        "entity_name": "entity_name",
+        "role_name": "role_name",
+        "role_id": "role_id",
+        "entity_id": "entity_id",
+        "entity_type": "entity_type",
     }
 
-    def __init__(self, id=None, project_id=None, entity_name=None, role_name=None, role_id=None, entity_id=None, entity_type=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        project_id=None,
+        entity_name=None,
+        role_name=None,
+        role_id=None,
+        entity_id=None,
+        entity_type=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ProjectMemberEntity - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._project_id = None
@@ -246,26 +256,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ProjectMemberEntity, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/project_metadata.py` & `harbor_api_client-2.7.6/src/harbor_client/models/project_metadata.py`

 * *Files 12% similar despite different names*

```diff
@@ -29,36 +29,47 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'public': 'str',
-        'enable_content_trust': 'str',
-        'enable_content_trust_cosign': 'str',
-        'prevent_vul': 'str',
-        'severity': 'str',
-        'auto_scan': 'str',
-        'reuse_sys_cve_allowlist': 'str',
-        'retention_id': 'str'
+        "public": "str",
+        "enable_content_trust": "str",
+        "enable_content_trust_cosign": "str",
+        "prevent_vul": "str",
+        "severity": "str",
+        "auto_scan": "str",
+        "reuse_sys_cve_allowlist": "str",
+        "retention_id": "str",
     }
 
     attribute_map = {
-        'public': 'public',
-        'enable_content_trust': 'enable_content_trust',
-        'enable_content_trust_cosign': 'enable_content_trust_cosign',
-        'prevent_vul': 'prevent_vul',
-        'severity': 'severity',
-        'auto_scan': 'auto_scan',
-        'reuse_sys_cve_allowlist': 'reuse_sys_cve_allowlist',
-        'retention_id': 'retention_id'
+        "public": "public",
+        "enable_content_trust": "enable_content_trust",
+        "enable_content_trust_cosign": "enable_content_trust_cosign",
+        "prevent_vul": "prevent_vul",
+        "severity": "severity",
+        "auto_scan": "auto_scan",
+        "reuse_sys_cve_allowlist": "reuse_sys_cve_allowlist",
+        "retention_id": "retention_id",
     }
 
-    def __init__(self, public=None, enable_content_trust=None, enable_content_trust_cosign=None, prevent_vul=None, severity=None, auto_scan=None, reuse_sys_cve_allowlist=None, retention_id=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        public=None,
+        enable_content_trust=None,
+        enable_content_trust_cosign=None,
+        prevent_vul=None,
+        severity=None,
+        auto_scan=None,
+        reuse_sys_cve_allowlist=None,
+        retention_id=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ProjectMetadata - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._public = None
         self._enable_content_trust = None
@@ -274,26 +285,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ProjectMetadata, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/project_req.py` & `harbor_api_client-2.7.6/src/harbor_client/models/project_req.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'project_name': 'str',
-        'public': 'bool',
-        'metadata': 'ProjectMetadata',
-        'cve_allowlist': 'CVEAllowlist',
-        'storage_limit': 'int',
-        'registry_id': 'int'
+        "project_name": "str",
+        "public": "bool",
+        "metadata": "ProjectMetadata",
+        "cve_allowlist": "CVEAllowlist",
+        "storage_limit": "int",
+        "registry_id": "int",
     }
 
     attribute_map = {
-        'project_name': 'project_name',
-        'public': 'public',
-        'metadata': 'metadata',
-        'cve_allowlist': 'cve_allowlist',
-        'storage_limit': 'storage_limit',
-        'registry_id': 'registry_id'
+        "project_name": "project_name",
+        "public": "public",
+        "metadata": "metadata",
+        "cve_allowlist": "cve_allowlist",
+        "storage_limit": "storage_limit",
+        "registry_id": "registry_id",
     }
 
-    def __init__(self, project_name=None, public=None, metadata=None, cve_allowlist=None, storage_limit=None, registry_id=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        project_name=None,
+        public=None,
+        metadata=None,
+        cve_allowlist=None,
+        storage_limit=None,
+        registry_id=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ProjectReq - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._project_name = None
         self._public = None
@@ -93,17 +102,22 @@
         """Sets the project_name of this ProjectReq.
 
         The name of the project.  # noqa: E501
 
         :param project_name: The project_name of this ProjectReq.  # noqa: E501
         :type: str
         """
-        if (self._configuration.client_side_validation and
-                project_name is not None and len(project_name) > 255):
-            raise ValueError("Invalid value for `project_name`, length must be less than or equal to `255`")  # noqa: E501
+        if (
+            self._configuration.client_side_validation
+            and project_name is not None
+            and len(project_name) > 255
+        ):
+            raise ValueError(
+                "Invalid value for `project_name`, length must be less than or equal to `255`"
+            )  # noqa: E501
 
         self._project_name = project_name
 
     @property
     def public(self):
         """Gets the public of this ProjectReq.  # noqa: E501
 
@@ -221,26 +235,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ProjectReq, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/project_scanner.py` & `harbor_api_client-2.7.6/src/harbor_client/models/project_scanner.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'uuid': 'str'
-    }
-
-    attribute_map = {
-        'uuid': 'uuid'
-    }
+    swagger_types = {"uuid": "str"}
+
+    attribute_map = {"uuid": "uuid"}
 
     def __init__(self, uuid=None, _configuration=None):  # noqa: E501
         """ProjectScanner - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -79,26 +75,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ProjectScanner, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/project_summary.py` & `harbor_api_client-2.7.6/src/harbor_client/models/project_summary.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,38 +29,50 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'repo_count': 'int',
-        'chart_count': 'int',
-        'project_admin_count': 'int',
-        'maintainer_count': 'int',
-        'developer_count': 'int',
-        'guest_count': 'int',
-        'limited_guest_count': 'int',
-        'quota': 'ProjectSummaryQuota',
-        'registry': 'Registry'
+        "repo_count": "int",
+        "chart_count": "int",
+        "project_admin_count": "int",
+        "maintainer_count": "int",
+        "developer_count": "int",
+        "guest_count": "int",
+        "limited_guest_count": "int",
+        "quota": "ProjectSummaryQuota",
+        "registry": "Registry",
     }
 
     attribute_map = {
-        'repo_count': 'repo_count',
-        'chart_count': 'chart_count',
-        'project_admin_count': 'project_admin_count',
-        'maintainer_count': 'maintainer_count',
-        'developer_count': 'developer_count',
-        'guest_count': 'guest_count',
-        'limited_guest_count': 'limited_guest_count',
-        'quota': 'quota',
-        'registry': 'registry'
+        "repo_count": "repo_count",
+        "chart_count": "chart_count",
+        "project_admin_count": "project_admin_count",
+        "maintainer_count": "maintainer_count",
+        "developer_count": "developer_count",
+        "guest_count": "guest_count",
+        "limited_guest_count": "limited_guest_count",
+        "quota": "quota",
+        "registry": "registry",
     }
 
-    def __init__(self, repo_count=None, chart_count=None, project_admin_count=None, maintainer_count=None, developer_count=None, guest_count=None, limited_guest_count=None, quota=None, registry=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        repo_count=None,
+        chart_count=None,
+        project_admin_count=None,
+        maintainer_count=None,
+        developer_count=None,
+        guest_count=None,
+        limited_guest_count=None,
+        quota=None,
+        registry=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ProjectSummary - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._repo_count = None
         self._chart_count = None
@@ -298,26 +310,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ProjectSummary, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/project_summary_quota.py` & `harbor_api_client-2.7.6/src/harbor_client/models/project_summary_quota.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'hard': 'ResourceList',
-        'used': 'ResourceList'
-    }
-
-    attribute_map = {
-        'hard': 'hard',
-        'used': 'used'
-    }
+    swagger_types = {"hard": "ResourceList", "used": "ResourceList"}
+
+    attribute_map = {"hard": "hard", "used": "used"}
 
     def __init__(self, hard=None, used=None, _configuration=None):  # noqa: E501
         """ProjectSummaryQuota - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ProjectSummaryQuota, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/provider_under_project.py` & `harbor_api_client-2.7.6/src/harbor_client/models/provider_under_project.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,29 +28,21 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'id': 'int',
-        'provider': 'str',
-        'enabled': 'bool',
-        'default': 'bool'
-    }
-
-    attribute_map = {
-        'id': 'id',
-        'provider': 'provider',
-        'enabled': 'enabled',
-        'default': 'default'
-    }
+    swagger_types = {"id": "int", "provider": "str", "enabled": "bool", "default": "bool"}
 
-    def __init__(self, id=None, provider=None, enabled=None, default=None, _configuration=None):  # noqa: E501
+    attribute_map = {"id": "id", "provider": "provider", "enabled": "enabled", "default": "default"}
+
+    def __init__(
+        self, id=None, provider=None, enabled=None, default=None, _configuration=None
+    ):  # noqa: E501
         """ProviderUnderProject - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._provider = None
@@ -154,26 +146,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ProviderUnderProject, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/quota.py` & `harbor_api_client-2.7.6/src/harbor_client/models/quota.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'ref': 'QuotaRefObject',
-        'hard': 'ResourceList',
-        'used': 'ResourceList',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "ref": "QuotaRefObject",
+        "hard": "ResourceList",
+        "used": "ResourceList",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'ref': 'ref',
-        'hard': 'hard',
-        'used': 'used',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "ref": "ref",
+        "hard": "hard",
+        "used": "used",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, ref=None, hard=None, used=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        ref=None,
+        hard=None,
+        used=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Quota - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._ref = None
@@ -218,26 +227,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Quota, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/quota_ref_object.py` & `harbor_api_client-2.7.6/src/harbor_client/models/robot_sec.py`

 * *Files 14% similar despite different names*

```diff
@@ -15,62 +15,90 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class QuotaRefObject(object):
+class RobotSec(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-    }
+    swagger_types = {"secret": "str"}
 
-    attribute_map = {
-    }
+    attribute_map = {"secret": "secret"}
 
-    def __init__(self, _configuration=None):  # noqa: E501
-        """QuotaRefObject - a model defined in Swagger"""  # noqa: E501
+    def __init__(self, secret=None, _configuration=None):  # noqa: E501
+        """RobotSec - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
+
+        self._secret = None
         self.discriminator = None
 
+        if secret is not None:
+            self.secret = secret
+
+    @property
+    def secret(self):
+        """Gets the secret of this RobotSec.  # noqa: E501
+
+        The secret of the robot  # noqa: E501
+
+        :return: The secret of this RobotSec.  # noqa: E501
+        :rtype: str
+        """
+        return self._secret
+
+    @secret.setter
+    def secret(self, secret):
+        """Sets the secret of this RobotSec.
+
+        The secret of the robot  # noqa: E501
+
+        :param secret: The secret of this RobotSec.  # noqa: E501
+        :type: str
+        """
+
+        self._secret = secret
+
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(QuotaRefObject, dict):
+        if issubclass(RobotSec, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -78,18 +106,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, QuotaRefObject):
+        if not isinstance(other, RobotSec):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, QuotaRefObject):
+        if not isinstance(other, RobotSec):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/quota_update_req.py` & `harbor_api_client-2.7.6/src/harbor_client/models/cve_allowlist_item.py`

 * *Files 13% similar despite different names*

```diff
@@ -15,92 +15,90 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class QuotaUpdateReq(object):
+class CVEAllowlistItem(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'hard': 'ResourceList'
-    }
-
-    attribute_map = {
-        'hard': 'hard'
-    }
+    swagger_types = {"cve_id": "str"}
 
-    def __init__(self, hard=None, _configuration=None):  # noqa: E501
-        """QuotaUpdateReq - a model defined in Swagger"""  # noqa: E501
+    attribute_map = {"cve_id": "cve_id"}
+
+    def __init__(self, cve_id=None, _configuration=None):  # noqa: E501
+        """CVEAllowlistItem - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
-        self._hard = None
+        self._cve_id = None
         self.discriminator = None
 
-        if hard is not None:
-            self.hard = hard
+        if cve_id is not None:
+            self.cve_id = cve_id
 
     @property
-    def hard(self):
-        """Gets the hard of this QuotaUpdateReq.  # noqa: E501
+    def cve_id(self):
+        """Gets the cve_id of this CVEAllowlistItem.  # noqa: E501
 
-        The new hard limits for the quota  # noqa: E501
+        The ID of the CVE, such as \"CVE-2019-10164\"  # noqa: E501
 
-        :return: The hard of this QuotaUpdateReq.  # noqa: E501
-        :rtype: ResourceList
+        :return: The cve_id of this CVEAllowlistItem.  # noqa: E501
+        :rtype: str
         """
-        return self._hard
+        return self._cve_id
 
-    @hard.setter
-    def hard(self, hard):
-        """Sets the hard of this QuotaUpdateReq.
+    @cve_id.setter
+    def cve_id(self, cve_id):
+        """Sets the cve_id of this CVEAllowlistItem.
 
-        The new hard limits for the quota  # noqa: E501
+        The ID of the CVE, such as \"CVE-2019-10164\"  # noqa: E501
 
-        :param hard: The hard of this QuotaUpdateReq.  # noqa: E501
-        :type: ResourceList
+        :param cve_id: The cve_id of this CVEAllowlistItem.  # noqa: E501
+        :type: str
         """
 
-        self._hard = hard
+        self._cve_id = cve_id
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(QuotaUpdateReq, dict):
+        if issubclass(CVEAllowlistItem, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -108,18 +106,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, QuotaUpdateReq):
+        if not isinstance(other, CVEAllowlistItem):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, QuotaUpdateReq):
+        if not isinstance(other, CVEAllowlistItem):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/reference.py` & `harbor_api_client-2.7.6/src/harbor_client/models/reference.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'parent_id': 'int',
-        'child_id': 'int',
-        'child_digest': 'str',
-        'platform': 'Platform',
-        'annotations': 'Annotations',
-        'urls': 'list[str]'
+        "parent_id": "int",
+        "child_id": "int",
+        "child_digest": "str",
+        "platform": "Platform",
+        "annotations": "Annotations",
+        "urls": "list[str]",
     }
 
     attribute_map = {
-        'parent_id': 'parent_id',
-        'child_id': 'child_id',
-        'child_digest': 'child_digest',
-        'platform': 'platform',
-        'annotations': 'annotations',
-        'urls': 'urls'
+        "parent_id": "parent_id",
+        "child_id": "child_id",
+        "child_digest": "child_digest",
+        "platform": "platform",
+        "annotations": "annotations",
+        "urls": "urls",
     }
 
-    def __init__(self, parent_id=None, child_id=None, child_digest=None, platform=None, annotations=None, urls=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        parent_id=None,
+        child_id=None,
+        child_digest=None,
+        platform=None,
+        annotations=None,
+        urls=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Reference - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._parent_id = None
         self._child_id = None
@@ -214,26 +223,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Reference, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/registry.py` & `harbor_api_client-2.7.6/src/harbor_client/models/registry.py`

 * *Files 10% similar despite different names*

```diff
@@ -29,40 +29,53 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'url': 'str',
-        'name': 'str',
-        'credential': 'RegistryCredential',
-        'type': 'str',
-        'insecure': 'bool',
-        'description': 'str',
-        'status': 'str',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "url": "str",
+        "name": "str",
+        "credential": "RegistryCredential",
+        "type": "str",
+        "insecure": "bool",
+        "description": "str",
+        "status": "str",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'url': 'url',
-        'name': 'name',
-        'credential': 'credential',
-        'type': 'type',
-        'insecure': 'insecure',
-        'description': 'description',
-        'status': 'status',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "url": "url",
+        "name": "name",
+        "credential": "credential",
+        "type": "type",
+        "insecure": "insecure",
+        "description": "description",
+        "status": "status",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, url=None, name=None, credential=None, type=None, insecure=None, description=None, status=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        url=None,
+        name=None,
+        credential=None,
+        type=None,
+        insecure=None,
+        description=None,
+        status=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Registry - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._url = None
@@ -328,26 +341,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Registry, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/registry_credential.py` & `harbor_api_client-2.7.6/src/harbor_client/models/registry_credential.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,27 +28,21 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'type': 'str',
-        'access_key': 'str',
-        'access_secret': 'str'
-    }
-
-    attribute_map = {
-        'type': 'type',
-        'access_key': 'access_key',
-        'access_secret': 'access_secret'
-    }
+    swagger_types = {"type": "str", "access_key": "str", "access_secret": "str"}
 
-    def __init__(self, type=None, access_key=None, access_secret=None, _configuration=None):  # noqa: E501
+    attribute_map = {"type": "type", "access_key": "access_key", "access_secret": "access_secret"}
+
+    def __init__(
+        self, type=None, access_key=None, access_secret=None, _configuration=None
+    ):  # noqa: E501
         """RegistryCredential - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._type = None
         self._access_key = None
@@ -134,26 +128,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RegistryCredential, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/registry_endpoint.py` & `harbor_api_client-2.7.6/src/harbor_client/models/registry_endpoint.py`

 * *Files 9% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'key': 'str',
-        'value': 'str'
-    }
-
-    attribute_map = {
-        'key': 'key',
-        'value': 'value'
-    }
+    swagger_types = {"key": "str", "value": "str"}
+
+    attribute_map = {"key": "key", "value": "value"}
 
     def __init__(self, key=None, value=None, _configuration=None):  # noqa: E501
         """RegistryEndpoint - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RegistryEndpoint, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/registry_info.py` & `harbor_api_client-2.7.6/src/harbor_client/models/registry_info.py`

 * *Files 9% similar despite different names*

```diff
@@ -29,30 +29,38 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'type': 'str',
-        'description': 'str',
-        'supported_resource_filters': 'list[FilterStyle]',
-        'supported_triggers': 'list[str]',
-        'supported_copy_by_chunk': 'bool'
+        "type": "str",
+        "description": "str",
+        "supported_resource_filters": "list[FilterStyle]",
+        "supported_triggers": "list[str]",
+        "supported_copy_by_chunk": "bool",
     }
 
     attribute_map = {
-        'type': 'type',
-        'description': 'description',
-        'supported_resource_filters': 'supported_resource_filters',
-        'supported_triggers': 'supported_triggers',
-        'supported_copy_by_chunk': 'supported_copy_by_chunk'
+        "type": "type",
+        "description": "description",
+        "supported_resource_filters": "supported_resource_filters",
+        "supported_triggers": "supported_triggers",
+        "supported_copy_by_chunk": "supported_copy_by_chunk",
     }
 
-    def __init__(self, type=None, description=None, supported_resource_filters=None, supported_triggers=None, supported_copy_by_chunk=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        type=None,
+        description=None,
+        supported_resource_filters=None,
+        supported_triggers=None,
+        supported_copy_by_chunk=None,
+        _configuration=None,
+    ):  # noqa: E501
         """RegistryInfo - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._type = None
         self._description = None
@@ -190,26 +198,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RegistryInfo, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/registry_ping.py` & `harbor_api_client-2.7.6/src/harbor_client/models/registry_ping.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,34 +29,44 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'type': 'str',
-        'url': 'str',
-        'credential_type': 'str',
-        'access_key': 'str',
-        'access_secret': 'str',
-        'insecure': 'bool'
+        "id": "int",
+        "type": "str",
+        "url": "str",
+        "credential_type": "str",
+        "access_key": "str",
+        "access_secret": "str",
+        "insecure": "bool",
     }
 
     attribute_map = {
-        'id': 'id',
-        'type': 'type',
-        'url': 'url',
-        'credential_type': 'credential_type',
-        'access_key': 'access_key',
-        'access_secret': 'access_secret',
-        'insecure': 'insecure'
+        "id": "id",
+        "type": "type",
+        "url": "url",
+        "credential_type": "credential_type",
+        "access_key": "access_key",
+        "access_secret": "access_secret",
+        "insecure": "insecure",
     }
 
-    def __init__(self, id=None, type=None, url=None, credential_type=None, access_key=None, access_secret=None, insecure=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        type=None,
+        url=None,
+        credential_type=None,
+        access_key=None,
+        access_secret=None,
+        insecure=None,
+        _configuration=None,
+    ):  # noqa: E501
         """RegistryPing - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._type = None
@@ -246,26 +256,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RegistryPing, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/registry_provider_credential_pattern.py` & `harbor_api_client-2.7.6/src/harbor_client/models/registry_provider_credential_pattern.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,28 +29,35 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'access_key_type': 'str',
-        'access_key_data': 'str',
-        'access_secret_type': 'str',
-        'access_secret_data': 'str'
+        "access_key_type": "str",
+        "access_key_data": "str",
+        "access_secret_type": "str",
+        "access_secret_data": "str",
     }
 
     attribute_map = {
-        'access_key_type': 'access_key_type',
-        'access_key_data': 'access_key_data',
-        'access_secret_type': 'access_secret_type',
-        'access_secret_data': 'access_secret_data'
+        "access_key_type": "access_key_type",
+        "access_key_data": "access_key_data",
+        "access_secret_type": "access_secret_type",
+        "access_secret_data": "access_secret_data",
     }
 
-    def __init__(self, access_key_type=None, access_key_data=None, access_secret_type=None, access_secret_data=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        access_key_type=None,
+        access_key_data=None,
+        access_secret_type=None,
+        access_secret_data=None,
+        _configuration=None,
+    ):  # noqa: E501
         """RegistryProviderCredentialPattern - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._access_key_type = None
         self._access_key_data = None
@@ -162,26 +169,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RegistryProviderCredentialPattern, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/registry_provider_endpoint_pattern.py` & `harbor_api_client-2.7.6/src/harbor_client/models/registry_provider_endpoint_pattern.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'endpoint_type': 'str',
-        'endpoints': 'list[RegistryEndpoint]'
-    }
-
-    attribute_map = {
-        'endpoint_type': 'endpoint_type',
-        'endpoints': 'endpoints'
-    }
+    swagger_types = {"endpoint_type": "str", "endpoints": "list[RegistryEndpoint]"}
+
+    attribute_map = {"endpoint_type": "endpoint_type", "endpoints": "endpoints"}
 
     def __init__(self, endpoint_type=None, endpoints=None, _configuration=None):  # noqa: E501
         """RegistryProviderEndpointPattern - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RegistryProviderEndpointPattern, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/registry_provider_info.py` & `harbor_api_client-2.7.6/src/harbor_client/models/registry_provider_info.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,24 +29,26 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'endpoint_pattern': 'RegistryProviderEndpointPattern',
-        'credential_pattern': 'RegistryProviderCredentialPattern'
+        "endpoint_pattern": "RegistryProviderEndpointPattern",
+        "credential_pattern": "RegistryProviderCredentialPattern",
     }
 
     attribute_map = {
-        'endpoint_pattern': 'endpoint_pattern',
-        'credential_pattern': 'credential_pattern'
+        "endpoint_pattern": "endpoint_pattern",
+        "credential_pattern": "credential_pattern",
     }
 
-    def __init__(self, endpoint_pattern=None, credential_pattern=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, endpoint_pattern=None, credential_pattern=None, _configuration=None
+    ):  # noqa: E501
         """RegistryProviderInfo - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._endpoint_pattern = None
         self._credential_pattern = None
@@ -106,26 +108,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RegistryProviderInfo, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/registry_update.py` & `harbor_api_client-2.7.6/src/harbor_client/models/registry_update.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,34 +29,44 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'name': 'str',
-        'description': 'str',
-        'url': 'str',
-        'credential_type': 'str',
-        'access_key': 'str',
-        'access_secret': 'str',
-        'insecure': 'bool'
+        "name": "str",
+        "description": "str",
+        "url": "str",
+        "credential_type": "str",
+        "access_key": "str",
+        "access_secret": "str",
+        "insecure": "bool",
     }
 
     attribute_map = {
-        'name': 'name',
-        'description': 'description',
-        'url': 'url',
-        'credential_type': 'credential_type',
-        'access_key': 'access_key',
-        'access_secret': 'access_secret',
-        'insecure': 'insecure'
+        "name": "name",
+        "description": "description",
+        "url": "url",
+        "credential_type": "credential_type",
+        "access_key": "access_key",
+        "access_secret": "access_secret",
+        "insecure": "insecure",
     }
 
-    def __init__(self, name=None, description=None, url=None, credential_type=None, access_key=None, access_secret=None, insecure=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        name=None,
+        description=None,
+        url=None,
+        credential_type=None,
+        access_key=None,
+        access_secret=None,
+        insecure=None,
+        _configuration=None,
+    ):  # noqa: E501
         """RegistryUpdate - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._name = None
         self._description = None
@@ -246,26 +256,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RegistryUpdate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/replication_execution.py` & `harbor_api_client-2.7.6/src/harbor_client/models/replication_execution.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,44 +29,59 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'policy_id': 'int',
-        'status': 'str',
-        'trigger': 'str',
-        'start_time': 'datetime',
-        'end_time': 'datetime',
-        'status_text': 'str',
-        'total': 'int',
-        'failed': 'int',
-        'succeed': 'int',
-        'in_progress': 'int',
-        'stopped': 'int'
+        "id": "int",
+        "policy_id": "int",
+        "status": "str",
+        "trigger": "str",
+        "start_time": "datetime",
+        "end_time": "datetime",
+        "status_text": "str",
+        "total": "int",
+        "failed": "int",
+        "succeed": "int",
+        "in_progress": "int",
+        "stopped": "int",
     }
 
     attribute_map = {
-        'id': 'id',
-        'policy_id': 'policy_id',
-        'status': 'status',
-        'trigger': 'trigger',
-        'start_time': 'start_time',
-        'end_time': 'end_time',
-        'status_text': 'status_text',
-        'total': 'total',
-        'failed': 'failed',
-        'succeed': 'succeed',
-        'in_progress': 'in_progress',
-        'stopped': 'stopped'
+        "id": "id",
+        "policy_id": "policy_id",
+        "status": "status",
+        "trigger": "trigger",
+        "start_time": "start_time",
+        "end_time": "end_time",
+        "status_text": "status_text",
+        "total": "total",
+        "failed": "failed",
+        "succeed": "succeed",
+        "in_progress": "in_progress",
+        "stopped": "stopped",
     }
 
-    def __init__(self, id=None, policy_id=None, status=None, trigger=None, start_time=None, end_time=None, status_text=None, total=None, failed=None, succeed=None, in_progress=None, stopped=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        policy_id=None,
+        status=None,
+        trigger=None,
+        start_time=None,
+        end_time=None,
+        status_text=None,
+        total=None,
+        failed=None,
+        succeed=None,
+        in_progress=None,
+        stopped=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ReplicationExecution - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._policy_id = None
@@ -386,26 +401,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ReplicationExecution, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/replication_filter.py` & `harbor_api_client-2.7.6/src/harbor_client/models/replication_filter.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'type': 'str',
-        'value': 'object',
-        'decoration': 'str'
-    }
-
-    attribute_map = {
-        'type': 'type',
-        'value': 'value',
-        'decoration': 'decoration'
-    }
+    swagger_types = {"type": "str", "value": "object", "decoration": "str"}
+
+    attribute_map = {"type": "type", "value": "value", "decoration": "decoration"}
 
     def __init__(self, type=None, value=None, decoration=None, _configuration=None):  # noqa: E501
         """ReplicationFilter - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -134,26 +126,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ReplicationFilter, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/replication_policy.py` & `harbor_api_client-2.7.6/src/harbor_client/models/replication_policy.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,54 +29,74 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'name': 'str',
-        'description': 'str',
-        'src_registry': 'Registry',
-        'dest_registry': 'Registry',
-        'dest_namespace': 'str',
-        'dest_namespace_replace_count': 'int',
-        'trigger': 'ReplicationTrigger',
-        'filters': 'list[ReplicationFilter]',
-        'replicate_deletion': 'bool',
-        'deletion': 'bool',
-        'override': 'bool',
-        'enabled': 'bool',
-        'creation_time': 'datetime',
-        'update_time': 'datetime',
-        'speed': 'int',
-        'copy_by_chunk': 'bool'
+        "id": "int",
+        "name": "str",
+        "description": "str",
+        "src_registry": "Registry",
+        "dest_registry": "Registry",
+        "dest_namespace": "str",
+        "dest_namespace_replace_count": "int",
+        "trigger": "ReplicationTrigger",
+        "filters": "list[ReplicationFilter]",
+        "replicate_deletion": "bool",
+        "deletion": "bool",
+        "override": "bool",
+        "enabled": "bool",
+        "creation_time": "datetime",
+        "update_time": "datetime",
+        "speed": "int",
+        "copy_by_chunk": "bool",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'description': 'description',
-        'src_registry': 'src_registry',
-        'dest_registry': 'dest_registry',
-        'dest_namespace': 'dest_namespace',
-        'dest_namespace_replace_count': 'dest_namespace_replace_count',
-        'trigger': 'trigger',
-        'filters': 'filters',
-        'replicate_deletion': 'replicate_deletion',
-        'deletion': 'deletion',
-        'override': 'override',
-        'enabled': 'enabled',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time',
-        'speed': 'speed',
-        'copy_by_chunk': 'copy_by_chunk'
+        "id": "id",
+        "name": "name",
+        "description": "description",
+        "src_registry": "src_registry",
+        "dest_registry": "dest_registry",
+        "dest_namespace": "dest_namespace",
+        "dest_namespace_replace_count": "dest_namespace_replace_count",
+        "trigger": "trigger",
+        "filters": "filters",
+        "replicate_deletion": "replicate_deletion",
+        "deletion": "deletion",
+        "override": "override",
+        "enabled": "enabled",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
+        "speed": "speed",
+        "copy_by_chunk": "copy_by_chunk",
     }
 
-    def __init__(self, id=None, name=None, description=None, src_registry=None, dest_registry=None, dest_namespace=None, dest_namespace_replace_count=None, trigger=None, filters=None, replicate_deletion=None, deletion=None, override=None, enabled=None, creation_time=None, update_time=None, speed=None, copy_by_chunk=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        description=None,
+        src_registry=None,
+        dest_registry=None,
+        dest_namespace=None,
+        dest_namespace_replace_count=None,
+        trigger=None,
+        filters=None,
+        replicate_deletion=None,
+        deletion=None,
+        override=None,
+        enabled=None,
+        creation_time=None,
+        update_time=None,
+        speed=None,
+        copy_by_chunk=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ReplicationPolicy - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._name = None
@@ -524,26 +544,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ReplicationPolicy, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/replication_task.py` & `harbor_api_client-2.7.6/src/harbor_client/models/replication_task.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,40 +29,53 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'execution_id': 'int',
-        'status': 'str',
-        'job_id': 'str',
-        'operation': 'str',
-        'resource_type': 'str',
-        'src_resource': 'str',
-        'dst_resource': 'str',
-        'start_time': 'datetime',
-        'end_time': 'datetime'
+        "id": "int",
+        "execution_id": "int",
+        "status": "str",
+        "job_id": "str",
+        "operation": "str",
+        "resource_type": "str",
+        "src_resource": "str",
+        "dst_resource": "str",
+        "start_time": "datetime",
+        "end_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'execution_id': 'execution_id',
-        'status': 'status',
-        'job_id': 'job_id',
-        'operation': 'operation',
-        'resource_type': 'resource_type',
-        'src_resource': 'src_resource',
-        'dst_resource': 'dst_resource',
-        'start_time': 'start_time',
-        'end_time': 'end_time'
+        "id": "id",
+        "execution_id": "execution_id",
+        "status": "status",
+        "job_id": "job_id",
+        "operation": "operation",
+        "resource_type": "resource_type",
+        "src_resource": "src_resource",
+        "dst_resource": "dst_resource",
+        "start_time": "start_time",
+        "end_time": "end_time",
     }
 
-    def __init__(self, id=None, execution_id=None, status=None, job_id=None, operation=None, resource_type=None, src_resource=None, dst_resource=None, start_time=None, end_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        execution_id=None,
+        status=None,
+        job_id=None,
+        operation=None,
+        resource_type=None,
+        src_resource=None,
+        dst_resource=None,
+        start_time=None,
+        end_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ReplicationTask - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._execution_id = None
@@ -330,26 +343,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ReplicationTask, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/replication_trigger.py` & `harbor_api_client-2.7.6/src/harbor_client/models/replication_trigger.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'type': 'str',
-        'trigger_settings': 'ReplicationTriggerSettings'
-    }
-
-    attribute_map = {
-        'type': 'type',
-        'trigger_settings': 'trigger_settings'
-    }
+    swagger_types = {"type": "str", "trigger_settings": "ReplicationTriggerSettings"}
+
+    attribute_map = {"type": "type", "trigger_settings": "trigger_settings"}
 
     def __init__(self, type=None, trigger_settings=None, _configuration=None):  # noqa: E501
         """ReplicationTrigger - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -104,26 +98,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ReplicationTrigger, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/replication_trigger_settings.py` & `harbor_api_client-2.7.6/src/harbor_client/models/replication_trigger_settings.py`

 * *Files 8% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'cron': 'str'
-    }
-
-    attribute_map = {
-        'cron': 'cron'
-    }
+    swagger_types = {"cron": "str"}
+
+    attribute_map = {"cron": "cron"}
 
     def __init__(self, cron=None, _configuration=None):  # noqa: E501
         """ReplicationTriggerSettings - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ReplicationTriggerSettings, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/repository.py` & `harbor_api_client-2.7.6/src/harbor_client/models/repository.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,36 +29,47 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'project_id': 'int',
-        'name': 'str',
-        'description': 'str',
-        'artifact_count': 'int',
-        'pull_count': 'int',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "project_id": "int",
+        "name": "str",
+        "description": "str",
+        "artifact_count": "int",
+        "pull_count": "int",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'project_id': 'project_id',
-        'name': 'name',
-        'description': 'description',
-        'artifact_count': 'artifact_count',
-        'pull_count': 'pull_count',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "project_id": "project_id",
+        "name": "name",
+        "description": "description",
+        "artifact_count": "artifact_count",
+        "pull_count": "pull_count",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, project_id=None, name=None, description=None, artifact_count=None, pull_count=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        project_id=None,
+        name=None,
+        description=None,
+        artifact_count=None,
+        pull_count=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Repository - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._project_id = None
@@ -274,26 +285,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Repository, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/resource_list.py` & `harbor_api_client-2.7.6/src/harbor_client/models/resource_list.py`

 * *Files 9% similar despite different names*

```diff
@@ -28,19 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-    }
+    swagger_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
     def __init__(self, _configuration=None):  # noqa: E501
         """ResourceList - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
         self.discriminator = None
@@ -48,26 +46,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ResourceList, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_execution.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_execution.py`

 * *Files 5% similar despite different names*

```diff
@@ -29,34 +29,44 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'policy_id': 'int',
-        'start_time': 'str',
-        'end_time': 'str',
-        'status': 'str',
-        'trigger': 'str',
-        'dry_run': 'bool'
+        "id": "int",
+        "policy_id": "int",
+        "start_time": "str",
+        "end_time": "str",
+        "status": "str",
+        "trigger": "str",
+        "dry_run": "bool",
     }
 
     attribute_map = {
-        'id': 'id',
-        'policy_id': 'policy_id',
-        'start_time': 'start_time',
-        'end_time': 'end_time',
-        'status': 'status',
-        'trigger': 'trigger',
-        'dry_run': 'dry_run'
+        "id": "id",
+        "policy_id": "policy_id",
+        "start_time": "start_time",
+        "end_time": "end_time",
+        "status": "status",
+        "trigger": "trigger",
+        "dry_run": "dry_run",
     }
 
-    def __init__(self, id=None, policy_id=None, start_time=None, end_time=None, status=None, trigger=None, dry_run=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        policy_id=None,
+        start_time=None,
+        end_time=None,
+        status=None,
+        trigger=None,
+        dry_run=None,
+        _configuration=None,
+    ):  # noqa: E501
         """RetentionExecution - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._policy_id = None
@@ -232,26 +242,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionExecution, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_execution_task.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_execution_task.py`

 * *Files 11% similar despite different names*

```diff
@@ -29,42 +29,56 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'execution_id': 'int',
-        'repository': 'str',
-        'job_id': 'str',
-        'status': 'str',
-        'status_code': 'int',
-        'status_revision': 'int',
-        'start_time': 'str',
-        'end_time': 'str',
-        'total': 'int',
-        'retained': 'int'
+        "id": "int",
+        "execution_id": "int",
+        "repository": "str",
+        "job_id": "str",
+        "status": "str",
+        "status_code": "int",
+        "status_revision": "int",
+        "start_time": "str",
+        "end_time": "str",
+        "total": "int",
+        "retained": "int",
     }
 
     attribute_map = {
-        'id': 'id',
-        'execution_id': 'execution_id',
-        'repository': 'repository',
-        'job_id': 'job_id',
-        'status': 'status',
-        'status_code': 'status_code',
-        'status_revision': 'status_revision',
-        'start_time': 'start_time',
-        'end_time': 'end_time',
-        'total': 'total',
-        'retained': 'retained'
+        "id": "id",
+        "execution_id": "execution_id",
+        "repository": "repository",
+        "job_id": "job_id",
+        "status": "status",
+        "status_code": "status_code",
+        "status_revision": "status_revision",
+        "start_time": "start_time",
+        "end_time": "end_time",
+        "total": "total",
+        "retained": "retained",
     }
 
-    def __init__(self, id=None, execution_id=None, repository=None, job_id=None, status=None, status_code=None, status_revision=None, start_time=None, end_time=None, total=None, retained=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        execution_id=None,
+        repository=None,
+        job_id=None,
+        status=None,
+        status_code=None,
+        status_revision=None,
+        start_time=None,
+        end_time=None,
+        total=None,
+        retained=None,
+        _configuration=None,
+    ):  # noqa: E501
         """RetentionExecutionTask - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._execution_id = None
@@ -336,26 +350,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionExecutionTask, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_metadata.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_metadata.py`

 * *Files 9% similar despite different names*

```diff
@@ -29,26 +29,28 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'templates': 'list[RetentionRuleMetadata]',
-        'scope_selectors': 'list[RetentionSelectorMetadata]',
-        'tag_selectors': 'list[RetentionSelectorMetadata]'
+        "templates": "list[RetentionRuleMetadata]",
+        "scope_selectors": "list[RetentionSelectorMetadata]",
+        "tag_selectors": "list[RetentionSelectorMetadata]",
     }
 
     attribute_map = {
-        'templates': 'templates',
-        'scope_selectors': 'scope_selectors',
-        'tag_selectors': 'tag_selectors'
+        "templates": "templates",
+        "scope_selectors": "scope_selectors",
+        "tag_selectors": "tag_selectors",
     }
 
-    def __init__(self, templates=None, scope_selectors=None, tag_selectors=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, templates=None, scope_selectors=None, tag_selectors=None, _configuration=None
+    ):  # noqa: E501
         """RetentionMetadata - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._templates = None
         self._scope_selectors = None
@@ -134,26 +136,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionMetadata, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_policy.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_policy.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,30 +29,32 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'algorithm': 'str',
-        'rules': 'list[RetentionRule]',
-        'trigger': 'RetentionRuleTrigger',
-        'scope': 'RetentionPolicyScope'
+        "id": "int",
+        "algorithm": "str",
+        "rules": "list[RetentionRule]",
+        "trigger": "RetentionRuleTrigger",
+        "scope": "RetentionPolicyScope",
     }
 
     attribute_map = {
-        'id': 'id',
-        'algorithm': 'algorithm',
-        'rules': 'rules',
-        'trigger': 'trigger',
-        'scope': 'scope'
+        "id": "id",
+        "algorithm": "algorithm",
+        "rules": "rules",
+        "trigger": "trigger",
+        "scope": "scope",
     }
 
-    def __init__(self, id=None, algorithm=None, rules=None, trigger=None, scope=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, id=None, algorithm=None, rules=None, trigger=None, scope=None, _configuration=None
+    ):  # noqa: E501
         """RetentionPolicy - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._algorithm = None
@@ -180,26 +182,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionPolicy, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_policy_scope.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_policy_scope.py`

 * *Files 10% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'level': 'str',
-        'ref': 'int'
-    }
-
-    attribute_map = {
-        'level': 'level',
-        'ref': 'ref'
-    }
+    swagger_types = {"level": "str", "ref": "int"}
+
+    attribute_map = {"level": "level", "ref": "ref"}
 
     def __init__(self, level=None, ref=None, _configuration=None):  # noqa: E501
         """RetentionPolicyScope - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -102,26 +96,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionPolicyScope, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_rule.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_rule.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,36 +29,47 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'priority': 'int',
-        'disabled': 'bool',
-        'action': 'str',
-        'template': 'str',
-        'params': 'dict(str, object)',
-        'tag_selectors': 'list[RetentionSelector]',
-        'scope_selectors': 'dict(str, list[RetentionSelector])'
+        "id": "int",
+        "priority": "int",
+        "disabled": "bool",
+        "action": "str",
+        "template": "str",
+        "params": "dict(str, object)",
+        "tag_selectors": "list[RetentionSelector]",
+        "scope_selectors": "dict(str, list[RetentionSelector])",
     }
 
     attribute_map = {
-        'id': 'id',
-        'priority': 'priority',
-        'disabled': 'disabled',
-        'action': 'action',
-        'template': 'template',
-        'params': 'params',
-        'tag_selectors': 'tag_selectors',
-        'scope_selectors': 'scope_selectors'
+        "id": "id",
+        "priority": "priority",
+        "disabled": "disabled",
+        "action": "action",
+        "template": "template",
+        "params": "params",
+        "tag_selectors": "tag_selectors",
+        "scope_selectors": "scope_selectors",
     }
 
-    def __init__(self, id=None, priority=None, disabled=None, action=None, template=None, params=None, tag_selectors=None, scope_selectors=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        priority=None,
+        disabled=None,
+        action=None,
+        template=None,
+        params=None,
+        tag_selectors=None,
+        scope_selectors=None,
+        _configuration=None,
+    ):  # noqa: E501
         """RetentionRule - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._priority = None
@@ -258,26 +269,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionRule, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_rule_metadata.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_rule_metadata.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,28 +29,30 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'rule_template': 'str',
-        'display_text': 'str',
-        'action': 'str',
-        'params': 'list[RetentionRuleParamMetadata]'
+        "rule_template": "str",
+        "display_text": "str",
+        "action": "str",
+        "params": "list[RetentionRuleParamMetadata]",
     }
 
     attribute_map = {
-        'rule_template': 'rule_template',
-        'display_text': 'display_text',
-        'action': 'action',
-        'params': 'params'
+        "rule_template": "rule_template",
+        "display_text": "display_text",
+        "action": "action",
+        "params": "params",
     }
 
-    def __init__(self, rule_template=None, display_text=None, action=None, params=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, rule_template=None, display_text=None, action=None, params=None, _configuration=None
+    ):  # noqa: E501
         """RetentionRuleMetadata - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._rule_template = None
         self._display_text = None
@@ -162,26 +164,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionRuleMetadata, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_rule_param_metadata.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_rule_param_metadata.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'type': 'str',
-        'unit': 'str',
-        'required': 'bool'
-    }
-
-    attribute_map = {
-        'type': 'type',
-        'unit': 'unit',
-        'required': 'required'
-    }
+    swagger_types = {"type": "str", "unit": "str", "required": "bool"}
+
+    attribute_map = {"type": "type", "unit": "unit", "required": "required"}
 
     def __init__(self, type=None, unit=None, required=None, _configuration=None):  # noqa: E501
         """RetentionRuleParamMetadata - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -128,26 +120,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionRuleParamMetadata, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_rule_trigger.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_rule_trigger.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,27 +28,21 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'kind': 'str',
-        'settings': 'object',
-        'references': 'object'
-    }
-
-    attribute_map = {
-        'kind': 'kind',
-        'settings': 'settings',
-        'references': 'references'
-    }
+    swagger_types = {"kind": "str", "settings": "object", "references": "object"}
 
-    def __init__(self, kind=None, settings=None, references=None, _configuration=None):  # noqa: E501
+    attribute_map = {"kind": "kind", "settings": "settings", "references": "references"}
+
+    def __init__(
+        self, kind=None, settings=None, references=None, _configuration=None
+    ):  # noqa: E501
         """RetentionRuleTrigger - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._kind = None
         self._settings = None
@@ -128,26 +122,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionRuleTrigger, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_selector.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_selector.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,29 +28,26 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'kind': 'str',
-        'decoration': 'str',
-        'pattern': 'str',
-        'extras': 'str'
-    }
+    swagger_types = {"kind": "str", "decoration": "str", "pattern": "str", "extras": "str"}
 
     attribute_map = {
-        'kind': 'kind',
-        'decoration': 'decoration',
-        'pattern': 'pattern',
-        'extras': 'extras'
+        "kind": "kind",
+        "decoration": "decoration",
+        "pattern": "pattern",
+        "extras": "extras",
     }
 
-    def __init__(self, kind=None, decoration=None, pattern=None, extras=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, kind=None, decoration=None, pattern=None, extras=None, _configuration=None
+    ):  # noqa: E501
         """RetentionSelector - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._kind = None
         self._decoration = None
@@ -154,26 +151,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionSelector, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/retention_selector_metadata.py` & `harbor_api_client-2.7.6/src/harbor_client/models/retention_selector_metadata.py`

 * *Files 9% similar despite different names*

```diff
@@ -28,27 +28,21 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'display_text': 'str',
-        'kind': 'str',
-        'decorations': 'list[str]'
-    }
-
-    attribute_map = {
-        'display_text': 'display_text',
-        'kind': 'kind',
-        'decorations': 'decorations'
-    }
+    swagger_types = {"display_text": "str", "kind": "str", "decorations": "list[str]"}
 
-    def __init__(self, display_text=None, kind=None, decorations=None, _configuration=None):  # noqa: E501
+    attribute_map = {"display_text": "display_text", "kind": "kind", "decorations": "decorations"}
+
+    def __init__(
+        self, display_text=None, kind=None, decorations=None, _configuration=None
+    ):  # noqa: E501
         """RetentionSelectorMetadata - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._display_text = None
         self._kind = None
@@ -128,26 +122,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RetentionSelectorMetadata, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/robot.py` & `harbor_api_client-2.7.6/src/harbor_client/models/robot.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,44 +29,59 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'name': 'str',
-        'description': 'str',
-        'secret': 'str',
-        'level': 'str',
-        'duration': 'int',
-        'editable': 'bool',
-        'disable': 'bool',
-        'expires_at': 'int',
-        'permissions': 'list[RobotPermission]',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "name": "str",
+        "description": "str",
+        "secret": "str",
+        "level": "str",
+        "duration": "int",
+        "editable": "bool",
+        "disable": "bool",
+        "expires_at": "int",
+        "permissions": "list[RobotPermission]",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'description': 'description',
-        'secret': 'secret',
-        'level': 'level',
-        'duration': 'duration',
-        'editable': 'editable',
-        'disable': 'disable',
-        'expires_at': 'expires_at',
-        'permissions': 'permissions',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "name": "name",
+        "description": "description",
+        "secret": "secret",
+        "level": "level",
+        "duration": "duration",
+        "editable": "editable",
+        "disable": "disable",
+        "expires_at": "expires_at",
+        "permissions": "permissions",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, name=None, description=None, secret=None, level=None, duration=None, editable=None, disable=None, expires_at=None, permissions=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        description=None,
+        secret=None,
+        level=None,
+        duration=None,
+        editable=None,
+        disable=None,
+        expires_at=None,
+        permissions=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Robot - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._name = None
@@ -384,26 +399,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Robot, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/robot_create.py` & `harbor_api_client-2.7.6/src/harbor_client/models/robot_create.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,34 +29,44 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'name': 'str',
-        'description': 'str',
-        'secret': 'str',
-        'level': 'str',
-        'disable': 'bool',
-        'duration': 'int',
-        'permissions': 'list[RobotPermission]'
+        "name": "str",
+        "description": "str",
+        "secret": "str",
+        "level": "str",
+        "disable": "bool",
+        "duration": "int",
+        "permissions": "list[RobotPermission]",
     }
 
     attribute_map = {
-        'name': 'name',
-        'description': 'description',
-        'secret': 'secret',
-        'level': 'level',
-        'disable': 'disable',
-        'duration': 'duration',
-        'permissions': 'permissions'
+        "name": "name",
+        "description": "description",
+        "secret": "secret",
+        "level": "level",
+        "disable": "disable",
+        "duration": "duration",
+        "permissions": "permissions",
     }
 
-    def __init__(self, name=None, description=None, secret=None, level=None, disable=None, duration=None, permissions=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        name=None,
+        description=None,
+        secret=None,
+        level=None,
+        disable=None,
+        duration=None,
+        permissions=None,
+        _configuration=None,
+    ):  # noqa: E501
         """RobotCreate - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._name = None
         self._description = None
@@ -244,26 +254,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RobotCreate, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/robot_create_v1.py` & `harbor_api_client-2.7.6/src/harbor_client/models/robot_create_v1.py`

 * *Files 5% similar despite different names*

```diff
@@ -29,28 +29,30 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'name': 'str',
-        'description': 'str',
-        'expires_at': 'int',
-        'access': 'list[Access]'
+        "name": "str",
+        "description": "str",
+        "expires_at": "int",
+        "access": "list[Access]",
     }
 
     attribute_map = {
-        'name': 'name',
-        'description': 'description',
-        'expires_at': 'expires_at',
-        'access': 'access'
+        "name": "name",
+        "description": "description",
+        "expires_at": "expires_at",
+        "access": "access",
     }
 
-    def __init__(self, name=None, description=None, expires_at=None, access=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, name=None, description=None, expires_at=None, access=None, _configuration=None
+    ):  # noqa: E501
         """RobotCreateV1 - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._name = None
         self._description = None
@@ -162,26 +164,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RobotCreateV1, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/robot_created.py` & `harbor_api_client-2.7.6/src/harbor_client/models/robot_created.py`

 * *Files 10% similar despite different names*

```diff
@@ -29,30 +29,38 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'name': 'str',
-        'secret': 'str',
-        'creation_time': 'datetime',
-        'expires_at': 'int'
+        "id": "int",
+        "name": "str",
+        "secret": "str",
+        "creation_time": "datetime",
+        "expires_at": "int",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'secret': 'secret',
-        'creation_time': 'creation_time',
-        'expires_at': 'expires_at'
+        "id": "id",
+        "name": "name",
+        "secret": "secret",
+        "creation_time": "creation_time",
+        "expires_at": "expires_at",
     }
 
-    def __init__(self, id=None, name=None, secret=None, creation_time=None, expires_at=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        secret=None,
+        creation_time=None,
+        expires_at=None,
+        _configuration=None,
+    ):  # noqa: E501
         """RobotCreated - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._name = None
@@ -190,26 +198,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RobotCreated, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/robot_permission.py` & `harbor_api_client-2.7.6/src/harbor_client/models/robot_permission.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'kind': 'str',
-        'namespace': 'str',
-        'access': 'list[Access]'
-    }
-
-    attribute_map = {
-        'kind': 'kind',
-        'namespace': 'namespace',
-        'access': 'access'
-    }
+    swagger_types = {"kind": "str", "namespace": "str", "access": "list[Access]"}
+
+    attribute_map = {"kind": "kind", "namespace": "namespace", "access": "access"}
 
     def __init__(self, kind=None, namespace=None, access=None, _configuration=None):  # noqa: E501
         """RobotPermission - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -132,26 +124,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(RobotPermission, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/robot_sec.py` & `harbor_api_client-2.7.6/src/harbor_client/models/role_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -15,92 +15,90 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class RobotSec(object):
+class RoleRequest(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'secret': 'str'
-    }
-
-    attribute_map = {
-        'secret': 'secret'
-    }
+    swagger_types = {"role_id": "int"}
 
-    def __init__(self, secret=None, _configuration=None):  # noqa: E501
-        """RobotSec - a model defined in Swagger"""  # noqa: E501
+    attribute_map = {"role_id": "role_id"}
+
+    def __init__(self, role_id=None, _configuration=None):  # noqa: E501
+        """RoleRequest - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
-        self._secret = None
+        self._role_id = None
         self.discriminator = None
 
-        if secret is not None:
-            self.secret = secret
+        if role_id is not None:
+            self.role_id = role_id
 
     @property
-    def secret(self):
-        """Gets the secret of this RobotSec.  # noqa: E501
+    def role_id(self):
+        """Gets the role_id of this RoleRequest.  # noqa: E501
 
-        The secret of the robot  # noqa: E501
+        The role id 1 for projectAdmin, 2 for developer, 3 for guest, 4 for maintainer  # noqa: E501
 
-        :return: The secret of this RobotSec.  # noqa: E501
-        :rtype: str
+        :return: The role_id of this RoleRequest.  # noqa: E501
+        :rtype: int
         """
-        return self._secret
+        return self._role_id
 
-    @secret.setter
-    def secret(self, secret):
-        """Sets the secret of this RobotSec.
+    @role_id.setter
+    def role_id(self, role_id):
+        """Sets the role_id of this RoleRequest.
 
-        The secret of the robot  # noqa: E501
+        The role id 1 for projectAdmin, 2 for developer, 3 for guest, 4 for maintainer  # noqa: E501
 
-        :param secret: The secret of this RobotSec.  # noqa: E501
-        :type: str
+        :param role_id: The role_id of this RoleRequest.  # noqa: E501
+        :type: int
         """
 
-        self._secret = secret
+        self._role_id = role_id
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(RobotSec, dict):
+        if issubclass(RoleRequest, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -108,18 +106,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RobotSec):
+        if not isinstance(other, RoleRequest):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, RobotSec):
+        if not isinstance(other, RoleRequest):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/role_request.py` & `harbor_api_client-2.7.6/src/harbor_client/models/storage.py`

 * *Files 21% similar despite different names*

```diff
@@ -15,92 +15,116 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class RoleRequest(object):
+class Storage(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'role_id': 'int'
-    }
-
-    attribute_map = {
-        'role_id': 'role_id'
-    }
+    swagger_types = {"total": "int", "free": "int"}
 
-    def __init__(self, role_id=None, _configuration=None):  # noqa: E501
-        """RoleRequest - a model defined in Swagger"""  # noqa: E501
+    attribute_map = {"total": "total", "free": "free"}
+
+    def __init__(self, total=None, free=None, _configuration=None):  # noqa: E501
+        """Storage - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
-        self._role_id = None
+        self._total = None
+        self._free = None
         self.discriminator = None
 
-        if role_id is not None:
-            self.role_id = role_id
+        if total is not None:
+            self.total = total
+        if free is not None:
+            self.free = free
+
+    @property
+    def total(self):
+        """Gets the total of this Storage.  # noqa: E501
+
+        Total volume size.  # noqa: E501
+
+        :return: The total of this Storage.  # noqa: E501
+        :rtype: int
+        """
+        return self._total
+
+    @total.setter
+    def total(self, total):
+        """Sets the total of this Storage.
+
+        Total volume size.  # noqa: E501
+
+        :param total: The total of this Storage.  # noqa: E501
+        :type: int
+        """
+
+        self._total = total
 
     @property
-    def role_id(self):
-        """Gets the role_id of this RoleRequest.  # noqa: E501
+    def free(self):
+        """Gets the free of this Storage.  # noqa: E501
 
-        The role id 1 for projectAdmin, 2 for developer, 3 for guest, 4 for maintainer  # noqa: E501
+        Free volume size.  # noqa: E501
 
-        :return: The role_id of this RoleRequest.  # noqa: E501
+        :return: The free of this Storage.  # noqa: E501
         :rtype: int
         """
-        return self._role_id
+        return self._free
 
-    @role_id.setter
-    def role_id(self, role_id):
-        """Sets the role_id of this RoleRequest.
+    @free.setter
+    def free(self, free):
+        """Sets the free of this Storage.
 
-        The role id 1 for projectAdmin, 2 for developer, 3 for guest, 4 for maintainer  # noqa: E501
+        Free volume size.  # noqa: E501
 
-        :param role_id: The role_id of this RoleRequest.  # noqa: E501
+        :param free: The free of this Storage.  # noqa: E501
         :type: int
         """
 
-        self._role_id = role_id
+        self._free = free
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(RoleRequest, dict):
+        if issubclass(Storage, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -108,18 +132,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, RoleRequest):
+        if not isinstance(other, Storage):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, RoleRequest):
+        if not isinstance(other, Storage):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scan_data_export_execution.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scan_data_export_execution.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,38 +29,50 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'user_id': 'int',
-        'status': 'str',
-        'trigger': 'str',
-        'start_time': 'datetime',
-        'end_time': 'datetime',
-        'status_text': 'str',
-        'user_name': 'str',
-        'file_present': 'bool'
+        "id": "int",
+        "user_id": "int",
+        "status": "str",
+        "trigger": "str",
+        "start_time": "datetime",
+        "end_time": "datetime",
+        "status_text": "str",
+        "user_name": "str",
+        "file_present": "bool",
     }
 
     attribute_map = {
-        'id': 'id',
-        'user_id': 'user_id',
-        'status': 'status',
-        'trigger': 'trigger',
-        'start_time': 'start_time',
-        'end_time': 'end_time',
-        'status_text': 'status_text',
-        'user_name': 'user_name',
-        'file_present': 'file_present'
+        "id": "id",
+        "user_id": "user_id",
+        "status": "status",
+        "trigger": "trigger",
+        "start_time": "start_time",
+        "end_time": "end_time",
+        "status_text": "status_text",
+        "user_name": "user_name",
+        "file_present": "file_present",
     }
 
-    def __init__(self, id=None, user_id=None, status=None, trigger=None, start_time=None, end_time=None, status_text=None, user_name=None, file_present=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        user_id=None,
+        status=None,
+        trigger=None,
+        start_time=None,
+        end_time=None,
+        status_text=None,
+        user_name=None,
+        file_present=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ScanDataExportExecution - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._user_id = None
@@ -302,26 +314,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScanDataExportExecution, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scan_data_export_execution_list.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scan_data_export_execution_list.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'items': 'list[ScanDataExportExecution]'
-    }
-
-    attribute_map = {
-        'items': 'items'
-    }
+    swagger_types = {"items": "list[ScanDataExportExecution]"}
+
+    attribute_map = {"items": "items"}
 
     def __init__(self, items=None, _configuration=None):  # noqa: E501
         """ScanDataExportExecutionList - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScanDataExportExecutionList, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scan_data_export_job.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scan_data_export_job.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'id': 'int'
-    }
-
-    attribute_map = {
-        'id': 'id'
-    }
+    swagger_types = {"id": "int"}
+
+    attribute_map = {"id": "id"}
 
     def __init__(self, id=None, _configuration=None):  # noqa: E501
         """ScanDataExportJob - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScanDataExportJob, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scan_data_export_request.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scan_data_export_request.py`

 * *Files 8% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'job_name': 'str',
-        'projects': 'list[int]',
-        'labels': 'list[int]',
-        'repositories': 'str',
-        'cve_ids': 'str',
-        'tags': 'str'
+        "job_name": "str",
+        "projects": "list[int]",
+        "labels": "list[int]",
+        "repositories": "str",
+        "cve_ids": "str",
+        "tags": "str",
     }
 
     attribute_map = {
-        'job_name': 'job_name',
-        'projects': 'projects',
-        'labels': 'labels',
-        'repositories': 'repositories',
-        'cve_ids': 'cveIds',
-        'tags': 'tags'
+        "job_name": "job_name",
+        "projects": "projects",
+        "labels": "labels",
+        "repositories": "repositories",
+        "cve_ids": "cveIds",
+        "tags": "tags",
     }
 
-    def __init__(self, job_name=None, projects=None, labels=None, repositories=None, cve_ids=None, tags=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        job_name=None,
+        projects=None,
+        labels=None,
+        repositories=None,
+        cve_ids=None,
+        tags=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ScanDataExportRequest - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._job_name = None
         self._projects = None
@@ -218,26 +227,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScanDataExportRequest, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scan_overview.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scan_overview.py`

 * *Files 16% similar despite different names*

```diff
@@ -28,19 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-    }
+    swagger_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
     def __init__(self, _configuration=None):  # noqa: E501
         """ScanOverview - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
         self.discriminator = None
@@ -48,26 +46,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScanOverview, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scanner.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scanner.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'name': 'str',
-        'vendor': 'str',
-        'version': 'str'
-    }
-
-    attribute_map = {
-        'name': 'name',
-        'vendor': 'vendor',
-        'version': 'version'
-    }
+    swagger_types = {"name": "str", "vendor": "str", "version": "str"}
+
+    attribute_map = {"name": "name", "vendor": "vendor", "version": "version"}
 
     def __init__(self, name=None, vendor=None, version=None, _configuration=None):  # noqa: E501
         """Scanner - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -134,26 +126,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Scanner, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scanner_adapter_metadata.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scanner_adapter_metadata.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,26 +29,28 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'scanner': 'Scanner',
-        'capabilities': 'list[ScannerCapability]',
-        'properties': 'dict(str, str)'
+        "scanner": "Scanner",
+        "capabilities": "list[ScannerCapability]",
+        "properties": "dict(str, str)",
     }
 
     attribute_map = {
-        'scanner': 'scanner',
-        'capabilities': 'capabilities',
-        'properties': 'properties'
+        "scanner": "scanner",
+        "capabilities": "capabilities",
+        "properties": "properties",
     }
 
-    def __init__(self, scanner=None, capabilities=None, properties=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, scanner=None, capabilities=None, properties=None, _configuration=None
+    ):  # noqa: E501
         """ScannerAdapterMetadata - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._scanner = None
         self._capabilities = None
@@ -128,26 +130,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScannerAdapterMetadata, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scanner_capability.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scanner_capability.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,25 +28,24 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'consumes_mime_types': 'list[str]',
-        'produces_mime_types': 'list[str]'
-    }
+    swagger_types = {"consumes_mime_types": "list[str]", "produces_mime_types": "list[str]"}
 
     attribute_map = {
-        'consumes_mime_types': 'consumes_mime_types',
-        'produces_mime_types': 'produces_mime_types'
+        "consumes_mime_types": "consumes_mime_types",
+        "produces_mime_types": "produces_mime_types",
     }
 
-    def __init__(self, consumes_mime_types=None, produces_mime_types=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, consumes_mime_types=None, produces_mime_types=None, _configuration=None
+    ):  # noqa: E501
         """ScannerCapability - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._consumes_mime_types = None
         self._produces_mime_types = None
@@ -102,26 +101,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScannerCapability, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scanner_registration.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scanner_registration.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,52 +29,71 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'uuid': 'str',
-        'name': 'str',
-        'description': 'str',
-        'url': 'str',
-        'disabled': 'bool',
-        'is_default': 'bool',
-        'auth': 'str',
-        'access_credential': 'str',
-        'skip_cert_verify': 'bool',
-        'use_internal_addr': 'bool',
-        'create_time': 'datetime',
-        'update_time': 'datetime',
-        'adapter': 'str',
-        'vendor': 'str',
-        'version': 'str',
-        'health': 'str'
+        "uuid": "str",
+        "name": "str",
+        "description": "str",
+        "url": "str",
+        "disabled": "bool",
+        "is_default": "bool",
+        "auth": "str",
+        "access_credential": "str",
+        "skip_cert_verify": "bool",
+        "use_internal_addr": "bool",
+        "create_time": "datetime",
+        "update_time": "datetime",
+        "adapter": "str",
+        "vendor": "str",
+        "version": "str",
+        "health": "str",
     }
 
     attribute_map = {
-        'uuid': 'uuid',
-        'name': 'name',
-        'description': 'description',
-        'url': 'url',
-        'disabled': 'disabled',
-        'is_default': 'is_default',
-        'auth': 'auth',
-        'access_credential': 'access_credential',
-        'skip_cert_verify': 'skip_certVerify',
-        'use_internal_addr': 'use_internal_addr',
-        'create_time': 'create_time',
-        'update_time': 'update_time',
-        'adapter': 'adapter',
-        'vendor': 'vendor',
-        'version': 'version',
-        'health': 'health'
+        "uuid": "uuid",
+        "name": "name",
+        "description": "description",
+        "url": "url",
+        "disabled": "disabled",
+        "is_default": "is_default",
+        "auth": "auth",
+        "access_credential": "access_credential",
+        "skip_cert_verify": "skip_certVerify",
+        "use_internal_addr": "use_internal_addr",
+        "create_time": "create_time",
+        "update_time": "update_time",
+        "adapter": "adapter",
+        "vendor": "vendor",
+        "version": "version",
+        "health": "health",
     }
 
-    def __init__(self, uuid=None, name=None, description=None, url=None, disabled=False, is_default=False, auth='', access_credential=None, skip_cert_verify=False, use_internal_addr=False, create_time=None, update_time=None, adapter=None, vendor=None, version=None, health='', _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        uuid=None,
+        name=None,
+        description=None,
+        url=None,
+        disabled=False,
+        is_default=False,
+        auth="",
+        access_credential=None,
+        skip_cert_verify=False,
+        use_internal_addr=False,
+        create_time=None,
+        update_time=None,
+        adapter=None,
+        vendor=None,
+        version=None,
+        health="",
+        _configuration=None,
+    ):  # noqa: E501
         """ScannerRegistration - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._uuid = None
         self._name = None
@@ -498,26 +517,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScannerRegistration, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scanner_registration_req.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scanner_registration_req.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,36 +29,47 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'name': 'str',
-        'description': 'str',
-        'url': 'str',
-        'auth': 'str',
-        'access_credential': 'str',
-        'skip_cert_verify': 'bool',
-        'use_internal_addr': 'bool',
-        'disabled': 'bool'
+        "name": "str",
+        "description": "str",
+        "url": "str",
+        "auth": "str",
+        "access_credential": "str",
+        "skip_cert_verify": "bool",
+        "use_internal_addr": "bool",
+        "disabled": "bool",
     }
 
     attribute_map = {
-        'name': 'name',
-        'description': 'description',
-        'url': 'url',
-        'auth': 'auth',
-        'access_credential': 'access_credential',
-        'skip_cert_verify': 'skip_certVerify',
-        'use_internal_addr': 'use_internal_addr',
-        'disabled': 'disabled'
+        "name": "name",
+        "description": "description",
+        "url": "url",
+        "auth": "auth",
+        "access_credential": "access_credential",
+        "skip_cert_verify": "skip_certVerify",
+        "use_internal_addr": "use_internal_addr",
+        "disabled": "disabled",
     }
 
-    def __init__(self, name=None, description=None, url=None, auth=None, access_credential=None, skip_cert_verify=False, use_internal_addr=False, disabled=False, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        name=None,
+        description=None,
+        url=None,
+        auth=None,
+        access_credential=None,
+        skip_cert_verify=False,
+        use_internal_addr=False,
+        disabled=False,
+        _configuration=None,
+    ):  # noqa: E501
         """ScannerRegistrationReq - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._name = None
         self._description = None
@@ -276,26 +287,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScannerRegistrationReq, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scanner_registration_settings.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scanner_registration_settings.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,29 +28,26 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'name': 'str',
-        'url': 'str',
-        'auth': 'str',
-        'access_credential': 'str'
-    }
+    swagger_types = {"name": "str", "url": "str", "auth": "str", "access_credential": "str"}
 
     attribute_map = {
-        'name': 'name',
-        'url': 'url',
-        'auth': 'auth',
-        'access_credential': 'access_credential'
+        "name": "name",
+        "url": "url",
+        "auth": "auth",
+        "access_credential": "access_credential",
     }
 
-    def __init__(self, name=None, url=None, auth='', access_credential=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, name=None, url=None, auth="", access_credential=None, _configuration=None
+    ):  # noqa: E501
         """ScannerRegistrationSettings - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._name = None
         self._url = None
@@ -164,26 +161,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScannerRegistrationSettings, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/schedule.py` & `harbor_api_client-2.7.6/src/harbor_client/models/schedule.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'status': 'str',
-        'creation_time': 'datetime',
-        'update_time': 'datetime',
-        'schedule': 'ScheduleObj',
-        'parameters': 'dict(str, object)'
+        "id": "int",
+        "status": "str",
+        "creation_time": "datetime",
+        "update_time": "datetime",
+        "schedule": "ScheduleObj",
+        "parameters": "dict(str, object)",
     }
 
     attribute_map = {
-        'id': 'id',
-        'status': 'status',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time',
-        'schedule': 'schedule',
-        'parameters': 'parameters'
+        "id": "id",
+        "status": "status",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
+        "schedule": "schedule",
+        "parameters": "parameters",
     }
 
-    def __init__(self, id=None, status=None, creation_time=None, update_time=None, schedule=None, parameters=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        status=None,
+        creation_time=None,
+        update_time=None,
+        schedule=None,
+        parameters=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Schedule - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._status = None
@@ -216,26 +225,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Schedule, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/schedule_obj.py` & `harbor_api_client-2.7.6/src/harbor_client/models/schedule_obj.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,27 +28,21 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'type': 'str',
-        'cron': 'str',
-        'next_scheduled_time': 'datetime'
-    }
-
-    attribute_map = {
-        'type': 'type',
-        'cron': 'cron',
-        'next_scheduled_time': 'next_scheduled_time'
-    }
+    swagger_types = {"type": "str", "cron": "str", "next_scheduled_time": "datetime"}
 
-    def __init__(self, type=None, cron=None, next_scheduled_time=None, _configuration=None):  # noqa: E501
+    attribute_map = {"type": "type", "cron": "cron", "next_scheduled_time": "next_scheduled_time"}
+
+    def __init__(
+        self, type=None, cron=None, next_scheduled_time=None, _configuration=None
+    ):  # noqa: E501
         """ScheduleObj - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._type = None
         self._cron = None
@@ -79,19 +73,19 @@
 
         The schedule type. The valid values are 'Hourly', 'Daily', 'Weekly', 'Custom', 'Manual' and 'None'. 'Manual' means to trigger it right away and 'None' means to cancel the schedule.   # noqa: E501
 
         :param type: The type of this ScheduleObj.  # noqa: E501
         :type: str
         """
         allowed_values = ["Hourly", "Daily", "Weekly", "Custom", "Manual", "None"]  # noqa: E501
-        if (self._configuration.client_side_validation and
-                type not in allowed_values):
+        if self._configuration.client_side_validation and type not in allowed_values:
             raise ValueError(
-                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
-                .format(type, allowed_values)
+                "Invalid value for `type` ({0}), must be one of {1}".format(  # noqa: E501
+                    type, allowed_values
+                )
             )
 
         self._type = type
 
     @property
     def cron(self):
         """Gets the cron of this ScheduleObj.  # noqa: E501
@@ -141,26 +135,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScheduleObj, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/schedule_task.py` & `harbor_api_client-2.7.6/src/harbor_client/models/schedule_task.py`

 * *Files 9% similar despite different names*

```diff
@@ -29,30 +29,38 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'vendor_type': 'str',
-        'vendor_id': 'int',
-        'cron': 'str',
-        'update_time': 'datetime'
+        "id": "int",
+        "vendor_type": "str",
+        "vendor_id": "int",
+        "cron": "str",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'vendor_type': 'vendor_type',
-        'vendor_id': 'vendor_id',
-        'cron': 'cron',
-        'update_time': 'update_time'
+        "id": "id",
+        "vendor_type": "vendor_type",
+        "vendor_id": "vendor_id",
+        "cron": "cron",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, vendor_type=None, vendor_id=None, cron=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        vendor_type=None,
+        vendor_id=None,
+        cron=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """ScheduleTask - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._vendor_type = None
@@ -190,26 +198,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(ScheduleTask, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/scheduler_status.py` & `harbor_api_client-2.7.6/src/harbor_client/models/scheduler_status.py`

 * *Files 10% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'paused': 'bool'
-    }
-
-    attribute_map = {
-        'paused': 'paused'
-    }
+    swagger_types = {"paused": "bool"}
+
+    attribute_map = {"paused": "paused"}
 
     def __init__(self, paused=None, _configuration=None):  # noqa: E501
         """SchedulerStatus - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(SchedulerStatus, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/search.py` & `harbor_api_client-2.7.6/src/harbor_client/models/search.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,26 +29,24 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'project': 'list[Project]',
-        'repository': 'list[SearchRepository]',
-        'chart': 'list[SearchResult]'
+        "project": "list[Project]",
+        "repository": "list[SearchRepository]",
+        "chart": "list[SearchResult]",
     }
 
-    attribute_map = {
-        'project': 'project',
-        'repository': 'repository',
-        'chart': 'chart'
-    }
+    attribute_map = {"project": "project", "repository": "repository", "chart": "chart"}
 
-    def __init__(self, project=None, repository=None, chart=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, project=None, repository=None, chart=None, _configuration=None
+    ):  # noqa: E501
         """Search - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._project = None
         self._repository = None
@@ -134,26 +132,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Search, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/search_repository.py` & `harbor_api_client-2.7.6/src/harbor_client/models/search_repository.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'project_id': 'int',
-        'project_name': 'str',
-        'project_public': 'bool',
-        'repository_name': 'str',
-        'pull_count': 'int',
-        'artifact_count': 'int'
+        "project_id": "int",
+        "project_name": "str",
+        "project_public": "bool",
+        "repository_name": "str",
+        "pull_count": "int",
+        "artifact_count": "int",
     }
 
     attribute_map = {
-        'project_id': 'project_id',
-        'project_name': 'project_name',
-        'project_public': 'project_public',
-        'repository_name': 'repository_name',
-        'pull_count': 'pull_count',
-        'artifact_count': 'artifact_count'
+        "project_id": "project_id",
+        "project_name": "project_name",
+        "project_public": "project_public",
+        "repository_name": "repository_name",
+        "pull_count": "pull_count",
+        "artifact_count": "artifact_count",
     }
 
-    def __init__(self, project_id=None, project_name=None, project_public=None, repository_name=None, pull_count=None, artifact_count=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        project_id=None,
+        project_name=None,
+        project_public=None,
+        repository_name=None,
+        pull_count=None,
+        artifact_count=None,
+        _configuration=None,
+    ):  # noqa: E501
         """SearchRepository - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._project_id = None
         self._project_name = None
@@ -218,26 +227,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(SearchRepository, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/search_result.py` & `harbor_api_client-2.7.6/src/harbor_client/models/search_result.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'name': 'str',
-        'score': 'int',
-        'chart': 'ChartVersion'
-    }
-
-    attribute_map = {
-        'name': 'Name',
-        'score': 'Score',
-        'chart': 'Chart'
-    }
+    swagger_types = {"name": "str", "score": "int", "chart": "ChartVersion"}
+
+    attribute_map = {"name": "Name", "score": "Score", "chart": "Chart"}
 
     def __init__(self, name=None, score=None, chart=None, _configuration=None):  # noqa: E501
         """SearchResult - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -132,26 +124,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(SearchResult, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/start_replication_execution.py` & `harbor_api_client-2.7.6/src/harbor_client/models/start_replication_execution.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'policy_id': 'int'
-    }
-
-    attribute_map = {
-        'policy_id': 'policy_id'
-    }
+    swagger_types = {"policy_id": "int"}
+
+    attribute_map = {"policy_id": "policy_id"}
 
     def __init__(self, policy_id=None, _configuration=None):  # noqa: E501
         """StartReplicationExecution - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(StartReplicationExecution, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/statistic.py` & `harbor_api_client-2.7.6/src/harbor_client/models/statistic.py`

 * *Files 8% similar despite different names*

```diff
@@ -29,34 +29,44 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'private_project_count': 'int',
-        'private_repo_count': 'int',
-        'public_project_count': 'int',
-        'public_repo_count': 'int',
-        'total_project_count': 'int',
-        'total_repo_count': 'int',
-        'total_storage_consumption': 'int'
+        "private_project_count": "int",
+        "private_repo_count": "int",
+        "public_project_count": "int",
+        "public_repo_count": "int",
+        "total_project_count": "int",
+        "total_repo_count": "int",
+        "total_storage_consumption": "int",
     }
 
     attribute_map = {
-        'private_project_count': 'private_project_count',
-        'private_repo_count': 'private_repo_count',
-        'public_project_count': 'public_project_count',
-        'public_repo_count': 'public_repo_count',
-        'total_project_count': 'total_project_count',
-        'total_repo_count': 'total_repo_count',
-        'total_storage_consumption': 'total_storage_consumption'
+        "private_project_count": "private_project_count",
+        "private_repo_count": "private_repo_count",
+        "public_project_count": "public_project_count",
+        "public_repo_count": "public_repo_count",
+        "total_project_count": "total_project_count",
+        "total_repo_count": "total_repo_count",
+        "total_storage_consumption": "total_storage_consumption",
     }
 
-    def __init__(self, private_project_count=None, private_repo_count=None, public_project_count=None, public_repo_count=None, total_project_count=None, total_repo_count=None, total_storage_consumption=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        private_project_count=None,
+        private_repo_count=None,
+        public_project_count=None,
+        public_repo_count=None,
+        total_project_count=None,
+        total_repo_count=None,
+        total_storage_consumption=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Statistic - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._private_project_count = None
         self._private_repo_count = None
@@ -246,26 +256,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Statistic, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/stats.py` & `harbor_api_client-2.7.6/src/harbor_client/models/stats.py`

 * *Files 12% similar despite different names*

```diff
@@ -29,30 +29,38 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'total': 'int',
-        'completed': 'int',
-        'metrics': 'dict(str, int)',
-        'ongoing': 'bool',
-        'trigger': 'str'
+        "total": "int",
+        "completed": "int",
+        "metrics": "dict(str, int)",
+        "ongoing": "bool",
+        "trigger": "str",
     }
 
     attribute_map = {
-        'total': 'total',
-        'completed': 'completed',
-        'metrics': 'metrics',
-        'ongoing': 'ongoing',
-        'trigger': 'trigger'
+        "total": "total",
+        "completed": "completed",
+        "metrics": "metrics",
+        "ongoing": "ongoing",
+        "trigger": "trigger",
     }
 
-    def __init__(self, total=None, completed=None, metrics=None, ongoing=None, trigger=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        total=None,
+        completed=None,
+        metrics=None,
+        ongoing=None,
+        trigger=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Stats - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._total = None
         self._completed = None
@@ -181,42 +189,44 @@
 
         The trigger of the scan all job.  # noqa: E501
 
         :param trigger: The trigger of this Stats.  # noqa: E501
         :type: str
         """
         allowed_values = ["Manual", "Schedule", "Event"]  # noqa: E501
-        if (self._configuration.client_side_validation and
-                trigger not in allowed_values):
+        if self._configuration.client_side_validation and trigger not in allowed_values:
             raise ValueError(
-                "Invalid value for `trigger` ({0}), must be one of {1}"  # noqa: E501
-                .format(trigger, allowed_values)
+                "Invalid value for `trigger` ({0}), must be one of {1}".format(  # noqa: E501
+                    trigger, allowed_values
+                )
             )
 
         self._trigger = trigger
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Stats, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/storage.py` & `harbor_api_client-2.7.6/src/harbor_client/models/user_profile.py`

 * *Files 19% similar despite different names*

```diff
@@ -15,120 +15,136 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class Storage(object):
+class UserProfile(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'total': 'int',
-        'free': 'int'
-    }
-
-    attribute_map = {
-        'total': 'total',
-        'free': 'free'
-    }
+    swagger_types = {"email": "str", "realname": "str", "comment": "str"}
 
-    def __init__(self, total=None, free=None, _configuration=None):  # noqa: E501
-        """Storage - a model defined in Swagger"""  # noqa: E501
+    attribute_map = {"email": "email", "realname": "realname", "comment": "comment"}
+
+    def __init__(self, email=None, realname=None, comment=None, _configuration=None):  # noqa: E501
+        """UserProfile - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
-        self._total = None
-        self._free = None
+        self._email = None
+        self._realname = None
+        self._comment = None
         self.discriminator = None
 
-        if total is not None:
-            self.total = total
-        if free is not None:
-            self.free = free
+        if email is not None:
+            self.email = email
+        if realname is not None:
+            self.realname = realname
+        if comment is not None:
+            self.comment = comment
+
+    @property
+    def email(self):
+        """Gets the email of this UserProfile.  # noqa: E501
+
+
+        :return: The email of this UserProfile.  # noqa: E501
+        :rtype: str
+        """
+        return self._email
+
+    @email.setter
+    def email(self, email):
+        """Sets the email of this UserProfile.
+
+
+        :param email: The email of this UserProfile.  # noqa: E501
+        :type: str
+        """
+
+        self._email = email
 
     @property
-    def total(self):
-        """Gets the total of this Storage.  # noqa: E501
+    def realname(self):
+        """Gets the realname of this UserProfile.  # noqa: E501
 
-        Total volume size.  # noqa: E501
 
-        :return: The total of this Storage.  # noqa: E501
-        :rtype: int
+        :return: The realname of this UserProfile.  # noqa: E501
+        :rtype: str
         """
-        return self._total
+        return self._realname
 
-    @total.setter
-    def total(self, total):
-        """Sets the total of this Storage.
+    @realname.setter
+    def realname(self, realname):
+        """Sets the realname of this UserProfile.
 
-        Total volume size.  # noqa: E501
 
-        :param total: The total of this Storage.  # noqa: E501
-        :type: int
+        :param realname: The realname of this UserProfile.  # noqa: E501
+        :type: str
         """
 
-        self._total = total
+        self._realname = realname
 
     @property
-    def free(self):
-        """Gets the free of this Storage.  # noqa: E501
+    def comment(self):
+        """Gets the comment of this UserProfile.  # noqa: E501
 
-        Free volume size.  # noqa: E501
 
-        :return: The free of this Storage.  # noqa: E501
-        :rtype: int
+        :return: The comment of this UserProfile.  # noqa: E501
+        :rtype: str
         """
-        return self._free
+        return self._comment
 
-    @free.setter
-    def free(self, free):
-        """Sets the free of this Storage.
+    @comment.setter
+    def comment(self, comment):
+        """Sets the comment of this UserProfile.
 
-        Free volume size.  # noqa: E501
 
-        :param free: The free of this Storage.  # noqa: E501
-        :type: int
+        :param comment: The comment of this UserProfile.  # noqa: E501
+        :type: str
         """
 
-        self._free = free
+        self._comment = comment
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(Storage, dict):
+        if issubclass(UserProfile, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -136,18 +152,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Storage):
+        if not isinstance(other, UserProfile):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Storage):
+        if not isinstance(other, UserProfile):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/string_config_item.py` & `harbor_api_client-2.7.6/src/harbor_client/models/string_config_item.py`

 * *Files 10% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'value': 'str',
-        'editable': 'bool'
-    }
-
-    attribute_map = {
-        'value': 'value',
-        'editable': 'editable'
-    }
+    swagger_types = {"value": "str", "editable": "bool"}
+
+    attribute_map = {"value": "value", "editable": "editable"}
 
     def __init__(self, value=None, editable=None, _configuration=None):  # noqa: E501
         """StringConfigItem - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(StringConfigItem, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/supported_webhook_event_types.py` & `harbor_api_client-2.7.6/src/harbor_client/models/supported_webhook_event_types.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'event_type': 'list[EventType]',
-        'notify_type': 'list[NotifyType]'
-    }
-
-    attribute_map = {
-        'event_type': 'event_type',
-        'notify_type': 'notify_type'
-    }
+    swagger_types = {"event_type": "list[EventType]", "notify_type": "list[NotifyType]"}
+
+    attribute_map = {"event_type": "event_type", "notify_type": "notify_type"}
 
     def __init__(self, event_type=None, notify_type=None, _configuration=None):  # noqa: E501
         """SupportedWebhookEventTypes - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -102,26 +96,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(SupportedWebhookEventTypes, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/system_info.py` & `harbor_api_client-2.7.6/src/harbor_client/models/system_info.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,21 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'storage': 'list[Storage]'
-    }
-
-    attribute_map = {
-        'storage': 'storage'
-    }
+    swagger_types = {"storage": "list[Storage]"}
+
+    attribute_map = {"storage": "storage"}
 
     def __init__(self, storage=None, _configuration=None):  # noqa: E501
         """SystemInfo - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -78,26 +74,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(SystemInfo, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/tag.py` & `harbor_api_client-2.7.6/src/harbor_client/models/tag.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,36 +29,47 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'repository_id': 'int',
-        'artifact_id': 'int',
-        'name': 'str',
-        'push_time': 'datetime',
-        'pull_time': 'datetime',
-        'immutable': 'bool',
-        'signed': 'bool'
+        "id": "int",
+        "repository_id": "int",
+        "artifact_id": "int",
+        "name": "str",
+        "push_time": "datetime",
+        "pull_time": "datetime",
+        "immutable": "bool",
+        "signed": "bool",
     }
 
     attribute_map = {
-        'id': 'id',
-        'repository_id': 'repository_id',
-        'artifact_id': 'artifact_id',
-        'name': 'name',
-        'push_time': 'push_time',
-        'pull_time': 'pull_time',
-        'immutable': 'immutable',
-        'signed': 'signed'
+        "id": "id",
+        "repository_id": "repository_id",
+        "artifact_id": "artifact_id",
+        "name": "name",
+        "push_time": "push_time",
+        "pull_time": "pull_time",
+        "immutable": "immutable",
+        "signed": "signed",
     }
 
-    def __init__(self, id=None, repository_id=None, artifact_id=None, name=None, push_time=None, pull_time=None, immutable=None, signed=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        repository_id=None,
+        artifact_id=None,
+        name=None,
+        push_time=None,
+        pull_time=None,
+        immutable=None,
+        signed=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Tag - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._repository_id = None
@@ -274,26 +285,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Tag, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/task.py` & `harbor_api_client-2.7.6/src/harbor_client/models/task.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,40 +29,53 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'execution_id': 'int',
-        'status': 'str',
-        'status_message': 'str',
-        'run_count': 'int',
-        'extra_attrs': 'ExtraAttrs',
-        'creation_time': 'str',
-        'update_time': 'str',
-        'start_time': 'str',
-        'end_time': 'str'
+        "id": "int",
+        "execution_id": "int",
+        "status": "str",
+        "status_message": "str",
+        "run_count": "int",
+        "extra_attrs": "ExtraAttrs",
+        "creation_time": "str",
+        "update_time": "str",
+        "start_time": "str",
+        "end_time": "str",
     }
 
     attribute_map = {
-        'id': 'id',
-        'execution_id': 'execution_id',
-        'status': 'status',
-        'status_message': 'status_message',
-        'run_count': 'run_count',
-        'extra_attrs': 'extra_attrs',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time',
-        'start_time': 'start_time',
-        'end_time': 'end_time'
+        "id": "id",
+        "execution_id": "execution_id",
+        "status": "status",
+        "status_message": "status_message",
+        "run_count": "run_count",
+        "extra_attrs": "extra_attrs",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
+        "start_time": "start_time",
+        "end_time": "end_time",
     }
 
-    def __init__(self, id=None, execution_id=None, status=None, status_message=None, run_count=None, extra_attrs=None, creation_time=None, update_time=None, start_time=None, end_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        execution_id=None,
+        status=None,
+        status_message=None,
+        run_count=None,
+        extra_attrs=None,
+        creation_time=None,
+        update_time=None,
+        start_time=None,
+        end_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Task - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._execution_id = None
@@ -328,26 +341,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Task, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/user_creation_req.py` & `harbor_api_client-2.7.6/src/harbor_client/models/user_creation_req.py`

 * *Files 5% similar despite different names*

```diff
@@ -29,30 +29,38 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'email': 'str',
-        'realname': 'str',
-        'comment': 'str',
-        'password': 'str',
-        'username': 'str'
+        "email": "str",
+        "realname": "str",
+        "comment": "str",
+        "password": "str",
+        "username": "str",
     }
 
     attribute_map = {
-        'email': 'email',
-        'realname': 'realname',
-        'comment': 'comment',
-        'password': 'password',
-        'username': 'username'
+        "email": "email",
+        "realname": "realname",
+        "comment": "comment",
+        "password": "password",
+        "username": "username",
     }
 
-    def __init__(self, email=None, realname=None, comment=None, password=None, username=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        email=None,
+        realname=None,
+        comment=None,
+        password=None,
+        username=None,
+        _configuration=None,
+    ):  # noqa: E501
         """UserCreationReq - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._email = None
         self._realname = None
@@ -86,17 +94,18 @@
     def email(self, email):
         """Sets the email of this UserCreationReq.
 
 
         :param email: The email of this UserCreationReq.  # noqa: E501
         :type: str
         """
-        if (self._configuration.client_side_validation and
-                email is not None and len(email) > 255):
-            raise ValueError("Invalid value for `email`, length must be less than or equal to `255`")  # noqa: E501
+        if self._configuration.client_side_validation and email is not None and len(email) > 255:
+            raise ValueError(
+                "Invalid value for `email`, length must be less than or equal to `255`"
+            )  # noqa: E501
 
         self._email = email
 
     @property
     def realname(self):
         """Gets the realname of this UserCreationReq.  # noqa: E501
 
@@ -173,39 +182,46 @@
     def username(self, username):
         """Sets the username of this UserCreationReq.
 
 
         :param username: The username of this UserCreationReq.  # noqa: E501
         :type: str
         """
-        if (self._configuration.client_side_validation and
-                username is not None and len(username) > 255):
-            raise ValueError("Invalid value for `username`, length must be less than or equal to `255`")  # noqa: E501
+        if (
+            self._configuration.client_side_validation
+            and username is not None
+            and len(username) > 255
+        ):
+            raise ValueError(
+                "Invalid value for `username`, length must be less than or equal to `255`"
+            )  # noqa: E501
 
         self._username = username
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(UserCreationReq, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/user_entity.py` & `harbor_api_client-2.7.6/src/harbor_client/models/user_entity.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'user_id': 'int',
-        'username': 'str'
-    }
-
-    attribute_map = {
-        'user_id': 'user_id',
-        'username': 'username'
-    }
+    swagger_types = {"user_id": "int", "username": "str"}
+
+    attribute_map = {"user_id": "user_id", "username": "username"}
 
     def __init__(self, user_id=None, username=None, _configuration=None):  # noqa: E501
         """UserEntity - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -106,26 +100,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(UserEntity, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/user_group.py` & `harbor_api_client-2.7.6/src/harbor_client/models/user_group.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,29 +28,26 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'id': 'int',
-        'group_name': 'str',
-        'group_type': 'int',
-        'ldap_group_dn': 'str'
-    }
+    swagger_types = {"id": "int", "group_name": "str", "group_type": "int", "ldap_group_dn": "str"}
 
     attribute_map = {
-        'id': 'id',
-        'group_name': 'group_name',
-        'group_type': 'group_type',
-        'ldap_group_dn': 'ldap_group_dn'
+        "id": "id",
+        "group_name": "group_name",
+        "group_type": "group_type",
+        "ldap_group_dn": "ldap_group_dn",
     }
 
-    def __init__(self, id=None, group_name=None, group_type=None, ldap_group_dn=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, id=None, group_name=None, group_type=None, ldap_group_dn=None, _configuration=None
+    ):  # noqa: E501
         """UserGroup - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._group_name = None
@@ -162,26 +159,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(UserGroup, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/user_group_search_item.py` & `harbor_api_client-2.7.6/src/harbor_client/models/user_group_search_item.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,27 +28,21 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'id': 'int',
-        'group_name': 'str',
-        'group_type': 'int'
-    }
-
-    attribute_map = {
-        'id': 'id',
-        'group_name': 'group_name',
-        'group_type': 'group_type'
-    }
+    swagger_types = {"id": "int", "group_name": "str", "group_type": "int"}
 
-    def __init__(self, id=None, group_name=None, group_type=None, _configuration=None):  # noqa: E501
+    attribute_map = {"id": "id", "group_name": "group_name", "group_type": "group_type"}
+
+    def __init__(
+        self, id=None, group_name=None, group_type=None, _configuration=None
+    ):  # noqa: E501
         """UserGroupSearchItem - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._group_name = None
@@ -134,26 +128,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(UserGroupSearchItem, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/user_profile.py` & `harbor_api_client-2.7.6/src/harbor_client/models/user_search_resp_item.py`

 * *Files 21% similar despite different names*

```diff
@@ -15,142 +15,114 @@
 import re  # noqa: F401
 
 import six
 
 from harbor_client.configuration import Configuration
 
 
-class UserProfile(object):
+class UserSearchRespItem(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'email': 'str',
-        'realname': 'str',
-        'comment': 'str'
-    }
-
-    attribute_map = {
-        'email': 'email',
-        'realname': 'realname',
-        'comment': 'comment'
-    }
+    swagger_types = {"user_id": "int", "username": "str"}
 
-    def __init__(self, email=None, realname=None, comment=None, _configuration=None):  # noqa: E501
-        """UserProfile - a model defined in Swagger"""  # noqa: E501
+    attribute_map = {"user_id": "user_id", "username": "username"}
+
+    def __init__(self, user_id=None, username=None, _configuration=None):  # noqa: E501
+        """UserSearchRespItem - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
-        self._email = None
-        self._realname = None
-        self._comment = None
+        self._user_id = None
+        self._username = None
         self.discriminator = None
 
-        if email is not None:
-            self.email = email
-        if realname is not None:
-            self.realname = realname
-        if comment is not None:
-            self.comment = comment
+        if user_id is not None:
+            self.user_id = user_id
+        if username is not None:
+            self.username = username
 
     @property
-    def email(self):
-        """Gets the email of this UserProfile.  # noqa: E501
-
-
-        :return: The email of this UserProfile.  # noqa: E501
-        :rtype: str
-        """
-        return self._email
-
-    @email.setter
-    def email(self, email):
-        """Sets the email of this UserProfile.
+    def user_id(self):
+        """Gets the user_id of this UserSearchRespItem.  # noqa: E501
 
+        The ID of the user.  # noqa: E501
 
-        :param email: The email of this UserProfile.  # noqa: E501
-        :type: str
+        :return: The user_id of this UserSearchRespItem.  # noqa: E501
+        :rtype: int
         """
+        return self._user_id
 
-        self._email = email
+    @user_id.setter
+    def user_id(self, user_id):
+        """Sets the user_id of this UserSearchRespItem.
 
-    @property
-    def realname(self):
-        """Gets the realname of this UserProfile.  # noqa: E501
+        The ID of the user.  # noqa: E501
 
-
-        :return: The realname of this UserProfile.  # noqa: E501
-        :rtype: str
-        """
-        return self._realname
-
-    @realname.setter
-    def realname(self, realname):
-        """Sets the realname of this UserProfile.
-
-
-        :param realname: The realname of this UserProfile.  # noqa: E501
-        :type: str
+        :param user_id: The user_id of this UserSearchRespItem.  # noqa: E501
+        :type: int
         """
 
-        self._realname = realname
+        self._user_id = user_id
 
     @property
-    def comment(self):
-        """Gets the comment of this UserProfile.  # noqa: E501
+    def username(self):
+        """Gets the username of this UserSearchRespItem.  # noqa: E501
 
 
-        :return: The comment of this UserProfile.  # noqa: E501
+        :return: The username of this UserSearchRespItem.  # noqa: E501
         :rtype: str
         """
-        return self._comment
+        return self._username
 
-    @comment.setter
-    def comment(self, comment):
-        """Sets the comment of this UserProfile.
+    @username.setter
+    def username(self, username):
+        """Sets the username of this UserSearchRespItem.
 
 
-        :param comment: The comment of this UserProfile.  # noqa: E501
+        :param username: The username of this UserSearchRespItem.  # noqa: E501
         :type: str
         """
 
-        self._comment = comment
+        self._username = username
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
-        if issubclass(UserProfile, dict):
+        if issubclass(UserSearchRespItem, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -158,18 +130,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UserProfile):
+        if not isinstance(other, UserSearchRespItem):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, UserProfile):
+        if not isinstance(other, UserSearchRespItem):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/user_resp.py` & `harbor_api_client-2.7.6/src/harbor_client/models/user_resp.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,40 +29,53 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'email': 'str',
-        'realname': 'str',
-        'comment': 'str',
-        'user_id': 'int',
-        'username': 'str',
-        'sysadmin_flag': 'bool',
-        'admin_role_in_auth': 'bool',
-        'oidc_user_meta': 'OIDCUserInfo',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "email": "str",
+        "realname": "str",
+        "comment": "str",
+        "user_id": "int",
+        "username": "str",
+        "sysadmin_flag": "bool",
+        "admin_role_in_auth": "bool",
+        "oidc_user_meta": "OIDCUserInfo",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'email': 'email',
-        'realname': 'realname',
-        'comment': 'comment',
-        'user_id': 'user_id',
-        'username': 'username',
-        'sysadmin_flag': 'sysadmin_flag',
-        'admin_role_in_auth': 'admin_role_in_auth',
-        'oidc_user_meta': 'oidc_user_meta',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "email": "email",
+        "realname": "realname",
+        "comment": "comment",
+        "user_id": "user_id",
+        "username": "username",
+        "sysadmin_flag": "sysadmin_flag",
+        "admin_role_in_auth": "admin_role_in_auth",
+        "oidc_user_meta": "oidc_user_meta",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, email=None, realname=None, comment=None, user_id=None, username=None, sysadmin_flag=None, admin_role_in_auth=None, oidc_user_meta=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        email=None,
+        realname=None,
+        comment=None,
+        user_id=None,
+        username=None,
+        sysadmin_flag=None,
+        admin_role_in_auth=None,
+        oidc_user_meta=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """UserResp - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._email = None
         self._realname = None
@@ -316,26 +329,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(UserResp, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/user_search.py` & `harbor_api_client-2.7.6/src/harbor_client/models/user_search.py`

 * *Files 8% similar despite different names*

```diff
@@ -28,23 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'user_id': 'int',
-        'username': 'str'
-    }
-
-    attribute_map = {
-        'user_id': 'user_id',
-        'username': 'username'
-    }
+    swagger_types = {"user_id": "int", "username": "str"}
+
+    attribute_map = {"user_id": "user_id", "username": "username"}
 
     def __init__(self, user_id=None, username=None, _configuration=None):  # noqa: E501
         """UserSearch - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -104,26 +98,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(UserSearch, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/vulnerability_summary.py` & `harbor_api_client-2.7.6/src/harbor_client/models/vulnerability_summary.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,25 +28,17 @@
     """
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    swagger_types = {
-        'total': 'int',
-        'fixable': 'int',
-        'summary': 'dict(str, int)'
-    }
-
-    attribute_map = {
-        'total': 'total',
-        'fixable': 'fixable',
-        'summary': 'summary'
-    }
+    swagger_types = {"total": "int", "fixable": "int", "summary": "dict(str, int)"}
+
+    attribute_map = {"total": "total", "fixable": "fixable", "summary": "summary"}
 
     def __init__(self, total=None, fixable=None, summary=None, _configuration=None):  # noqa: E501
         """VulnerabilitySummary - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
@@ -134,26 +126,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(VulnerabilitySummary, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/webhook_job.py` & `harbor_api_client-2.7.6/src/harbor_client/models/webhook_job.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,36 +29,47 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'policy_id': 'int',
-        'event_type': 'str',
-        'notify_type': 'str',
-        'status': 'str',
-        'job_detail': 'str',
-        'creation_time': 'datetime',
-        'update_time': 'datetime'
+        "id": "int",
+        "policy_id": "int",
+        "event_type": "str",
+        "notify_type": "str",
+        "status": "str",
+        "job_detail": "str",
+        "creation_time": "datetime",
+        "update_time": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'policy_id': 'policy_id',
-        'event_type': 'event_type',
-        'notify_type': 'notify_type',
-        'status': 'status',
-        'job_detail': 'job_detail',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time'
+        "id": "id",
+        "policy_id": "policy_id",
+        "event_type": "event_type",
+        "notify_type": "notify_type",
+        "status": "status",
+        "job_detail": "job_detail",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
     }
 
-    def __init__(self, id=None, policy_id=None, event_type=None, notify_type=None, status=None, job_detail=None, creation_time=None, update_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        policy_id=None,
+        event_type=None,
+        notify_type=None,
+        status=None,
+        job_detail=None,
+        creation_time=None,
+        update_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """WebhookJob - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._policy_id = None
@@ -274,26 +285,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(WebhookJob, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/webhook_last_trigger.py` & `harbor_api_client-2.7.6/src/harbor_client/models/webhook_last_trigger.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,30 +29,38 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'policy_name': 'str',
-        'event_type': 'str',
-        'enabled': 'bool',
-        'creation_time': 'datetime',
-        'last_trigger_time': 'datetime'
+        "policy_name": "str",
+        "event_type": "str",
+        "enabled": "bool",
+        "creation_time": "datetime",
+        "last_trigger_time": "datetime",
     }
 
     attribute_map = {
-        'policy_name': 'policy_name',
-        'event_type': 'event_type',
-        'enabled': 'enabled',
-        'creation_time': 'creation_time',
-        'last_trigger_time': 'last_trigger_time'
+        "policy_name": "policy_name",
+        "event_type": "event_type",
+        "enabled": "enabled",
+        "creation_time": "creation_time",
+        "last_trigger_time": "last_trigger_time",
     }
 
-    def __init__(self, policy_name=None, event_type=None, enabled=None, creation_time=None, last_trigger_time=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        policy_name=None,
+        event_type=None,
+        enabled=None,
+        creation_time=None,
+        last_trigger_time=None,
+        _configuration=None,
+    ):  # noqa: E501
         """WebhookLastTrigger - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._policy_name = None
         self._event_type = None
@@ -190,26 +198,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(WebhookLastTrigger, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/webhook_policy.py` & `harbor_api_client-2.7.6/src/harbor_client/models/webhook_policy.py`

 * *Files 4% similar despite different names*

```diff
@@ -29,40 +29,53 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'int',
-        'name': 'str',
-        'description': 'str',
-        'project_id': 'int',
-        'targets': 'list[WebhookTargetObject]',
-        'event_types': 'list[str]',
-        'creator': 'str',
-        'creation_time': 'datetime',
-        'update_time': 'datetime',
-        'enabled': 'bool'
+        "id": "int",
+        "name": "str",
+        "description": "str",
+        "project_id": "int",
+        "targets": "list[WebhookTargetObject]",
+        "event_types": "list[str]",
+        "creator": "str",
+        "creation_time": "datetime",
+        "update_time": "datetime",
+        "enabled": "bool",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'description': 'description',
-        'project_id': 'project_id',
-        'targets': 'targets',
-        'event_types': 'event_types',
-        'creator': 'creator',
-        'creation_time': 'creation_time',
-        'update_time': 'update_time',
-        'enabled': 'enabled'
+        "id": "id",
+        "name": "name",
+        "description": "description",
+        "project_id": "project_id",
+        "targets": "targets",
+        "event_types": "event_types",
+        "creator": "creator",
+        "creation_time": "creation_time",
+        "update_time": "update_time",
+        "enabled": "enabled",
     }
 
-    def __init__(self, id=None, name=None, description=None, project_id=None, targets=None, event_types=None, creator=None, creation_time=None, update_time=None, enabled=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        description=None,
+        project_id=None,
+        targets=None,
+        event_types=None,
+        creator=None,
+        creation_time=None,
+        update_time=None,
+        enabled=None,
+        _configuration=None,
+    ):  # noqa: E501
         """WebhookPolicy - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._name = None
@@ -326,26 +339,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(WebhookPolicy, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/webhook_target_object.py` & `harbor_api_client-2.7.6/src/harbor_client/models/webhook_target_object.py`

 * *Files 12% similar despite different names*

```diff
@@ -29,28 +29,30 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'type': 'str',
-        'address': 'str',
-        'auth_header': 'str',
-        'skip_cert_verify': 'bool'
+        "type": "str",
+        "address": "str",
+        "auth_header": "str",
+        "skip_cert_verify": "bool",
     }
 
     attribute_map = {
-        'type': 'type',
-        'address': 'address',
-        'auth_header': 'auth_header',
-        'skip_cert_verify': 'skip_cert_verify'
+        "type": "type",
+        "address": "address",
+        "auth_header": "auth_header",
+        "skip_cert_verify": "skip_cert_verify",
     }
 
-    def __init__(self, type=None, address=None, auth_header=None, skip_cert_verify=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self, type=None, address=None, auth_header=None, skip_cert_verify=None, _configuration=None
+    ):  # noqa: E501
         """WebhookTargetObject - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._type = None
         self._address = None
@@ -162,26 +164,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(WebhookTargetObject, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/worker.py` & `harbor_api_client-2.7.6/src/harbor_client/models/worker.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,34 +29,44 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'id': 'str',
-        'pool_id': 'str',
-        'job_name': 'str',
-        'job_id': 'str',
-        'start_at': 'datetime',
-        'check_in': 'str',
-        'checkin_at': 'datetime'
+        "id": "str",
+        "pool_id": "str",
+        "job_name": "str",
+        "job_id": "str",
+        "start_at": "datetime",
+        "check_in": "str",
+        "checkin_at": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'pool_id': 'pool_id',
-        'job_name': 'job_name',
-        'job_id': 'job_id',
-        'start_at': 'start_at',
-        'check_in': 'check_in',
-        'checkin_at': 'checkin_at'
+        "id": "id",
+        "pool_id": "pool_id",
+        "job_name": "job_name",
+        "job_id": "job_id",
+        "start_at": "start_at",
+        "check_in": "check_in",
+        "checkin_at": "checkin_at",
     }
 
-    def __init__(self, id=None, pool_id=None, job_name=None, job_id=None, start_at=None, check_in=None, checkin_at=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        pool_id=None,
+        job_name=None,
+        job_id=None,
+        start_at=None,
+        check_in=None,
+        checkin_at=None,
+        _configuration=None,
+    ):  # noqa: E501
         """Worker - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._id = None
         self._pool_id = None
@@ -246,26 +256,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(Worker, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/models/worker_pool.py` & `harbor_api_client-2.7.6/src/harbor_client/models/worker_pool.py`

 * *Files 6% similar despite different names*

```diff
@@ -29,32 +29,41 @@
     Attributes:
       swagger_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     swagger_types = {
-        'pid': 'int',
-        'worker_pool_id': 'str',
-        'start_at': 'datetime',
-        'heartbeat_at': 'datetime',
-        'concurrency': 'int',
-        'host': 'str'
+        "pid": "int",
+        "worker_pool_id": "str",
+        "start_at": "datetime",
+        "heartbeat_at": "datetime",
+        "concurrency": "int",
+        "host": "str",
     }
 
     attribute_map = {
-        'pid': 'pid',
-        'worker_pool_id': 'worker_pool_id',
-        'start_at': 'start_at',
-        'heartbeat_at': 'heartbeat_at',
-        'concurrency': 'concurrency',
-        'host': 'host'
+        "pid": "pid",
+        "worker_pool_id": "worker_pool_id",
+        "start_at": "start_at",
+        "heartbeat_at": "heartbeat_at",
+        "concurrency": "concurrency",
+        "host": "host",
     }
 
-    def __init__(self, pid=None, worker_pool_id=None, start_at=None, heartbeat_at=None, concurrency=None, host=None, _configuration=None):  # noqa: E501
+    def __init__(
+        self,
+        pid=None,
+        worker_pool_id=None,
+        start_at=None,
+        heartbeat_at=None,
+        concurrency=None,
+        host=None,
+        _configuration=None,
+    ):  # noqa: E501
         """WorkerPool - a model defined in Swagger"""  # noqa: E501
         if _configuration is None:
             _configuration = Configuration()
         self._configuration = _configuration
 
         self._pid = None
         self._worker_pool_id = None
@@ -218,26 +227,28 @@
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.swagger_types):
             value = getattr(self, attr)
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
+                result[attr] = list(
+                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
+                )
             elif hasattr(value, "to_dict"):
                 result[attr] = value.to_dict()
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(
+                        lambda item: (item[0], item[1].to_dict())
+                        if hasattr(item[1], "to_dict")
+                        else item,
+                        value.items(),
+                    )
+                )
             else:
                 result[attr] = value
         if issubclass(WorkerPool, dict):
             for key, value in self.items():
                 result[key] = value
 
         return result
```

### Comparing `harbor_api_client-2.7.5/src/harbor_client/rest.py` & `harbor_api_client-2.7.6/src/harbor_client/rest.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,29 +16,29 @@
 import io
 import json
 import logging
 import re
 import ssl
 
 import certifi
+
 # python 2 and python 3 compatibility library
 import six
 from six.moves.urllib.parse import urlencode
 
 try:
     import urllib3
 except ImportError:
-    raise ImportError('Swagger python client requires urllib3.')
+    raise ImportError("Swagger python client requires urllib3.")
 
 
 logger = logging.getLogger(__name__)
 
 
 class RESTResponse(io.IOBase):
-
     def __init__(self, resp):
         self.urllib3_response = resp
         self.status = resp.status
         self.reason = resp.reason
         self.data = resp.data
 
     def getheaders(self):
@@ -47,15 +47,14 @@
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
         return self.urllib3_response.getheader(name, default)
 
 
 class RESTClientObject(object):
-
     def __init__(self, configuration, pools_size=4, maxsize=None):
         # urllib3.PoolManager will pass all kw parameters to connectionpool
         # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
         # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
         # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501
         # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501
 
@@ -70,15 +69,15 @@
             ca_certs = configuration.ssl_ca_cert
         else:
             # if not set certificate file, use Mozilla's root certificates.
             ca_certs = certifi.where()
 
         addition_pool_args = {}
         if configuration.assert_hostname is not None:
-            addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501
+            addition_pool_args["assert_hostname"] = configuration.assert_hostname  # noqa: E501
 
         if maxsize is None:
             if configuration.connection_pool_maxsize is not None:
                 maxsize = configuration.connection_pool_maxsize
             else:
                 maxsize = 4
 
@@ -88,30 +87,38 @@
                 num_pools=pools_size,
                 maxsize=maxsize,
                 cert_reqs=cert_reqs,
                 ca_certs=ca_certs,
                 cert_file=configuration.cert_file,
                 key_file=configuration.key_file,
                 proxy_url=configuration.proxy,
-                **addition_pool_args
+                **addition_pool_args,
             )
         else:
             self.pool_manager = urllib3.PoolManager(
                 num_pools=pools_size,
                 maxsize=maxsize,
                 cert_reqs=cert_reqs,
                 ca_certs=ca_certs,
                 cert_file=configuration.cert_file,
                 key_file=configuration.key_file,
-                **addition_pool_args
+                **addition_pool_args,
             )
 
-    def request(self, method, url, query_params=None, headers=None,
-                body=None, post_params=None, _preload_content=True,
-                _request_timeout=None):
+    def request(
+        self,
+        method,
+        url,
+        query_params=None,
+        headers=None,
+        body=None,
+        post_params=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
         """Perform requests.
 
         :param method: http request method
         :param url: http request url
         :param query_params: query parameters in the url
         :param headers: http request headers
         :param body: request json body, for `application/json`
@@ -123,201 +130,266 @@
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         """
         method = method.upper()
-        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',
-                          'PATCH', 'OPTIONS']
+        assert method in ["GET", "HEAD", "DELETE", "POST", "PUT", "PATCH", "OPTIONS"]
 
         if post_params and body:
-            raise ValueError(
-                "body parameter cannot be used with post_params parameter."
-            )
+            raise ValueError("body parameter cannot be used with post_params parameter.")
 
         post_params = post_params or {}
         headers = headers or {}
 
         timeout = None
         if _request_timeout:
-            if isinstance(_request_timeout, (int, ) if six.PY3 else (int, long)):  # noqa: E501,F821
+            if isinstance(_request_timeout, (int,) if six.PY3 else (int, long)):  # noqa: E501,F821
                 timeout = urllib3.Timeout(total=_request_timeout)
-            elif (isinstance(_request_timeout, tuple) and
-                  len(_request_timeout) == 2):
-                timeout = urllib3.Timeout(
-                    connect=_request_timeout[0], read=_request_timeout[1])
+            elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:
+                timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])
 
-        if 'Content-Type' not in headers:
-            headers['Content-Type'] = 'application/json'
+        if "Content-Type" not in headers:
+            headers["Content-Type"] = "application/json"
 
         try:
             # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
-            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
+            if method in ["POST", "PUT", "PATCH", "OPTIONS", "DELETE"]:
                 if query_params:
-                    url += '?' + urlencode(query_params)
-                if re.search('json', headers['Content-Type'], re.IGNORECASE):
-                    request_body = '{}'
+                    url += "?" + urlencode(query_params)
+                if re.search("json", headers["Content-Type"], re.IGNORECASE):
+                    request_body = "{}"
                     if body is not None:
                         request_body = json.dumps(body)
                     r = self.pool_manager.request(
-                        method, url,
+                        method,
+                        url,
                         body=request_body,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers)
-                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
+                        headers=headers,
+                    )
+                elif headers["Content-Type"] == "application/x-www-form-urlencoded":  # noqa: E501
                     r = self.pool_manager.request(
-                        method, url,
+                        method,
+                        url,
                         fields=post_params,
                         encode_multipart=False,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers)
-                elif headers['Content-Type'] == 'multipart/form-data':
+                        headers=headers,
+                    )
+                elif headers["Content-Type"] == "multipart/form-data":
                     # must del headers['Content-Type'], or the correct
                     # Content-Type which generated by urllib3 will be
                     # overwritten.
-                    del headers['Content-Type']
+                    del headers["Content-Type"]
                     r = self.pool_manager.request(
-                        method, url,
+                        method,
+                        url,
                         fields=post_params,
                         encode_multipart=True,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers)
+                        headers=headers,
+                    )
                 # Pass a `string` parameter directly in the body to support
                 # other content types than Json when `body` argument is
                 # provided in serialized form
                 elif isinstance(body, str):
                     request_body = body
                     r = self.pool_manager.request(
-                        method, url,
+                        method,
+                        url,
                         body=request_body,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers)
+                        headers=headers,
+                    )
                 else:
                     # Cannot generate the request from given parameters
                     msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
                     raise ApiException(status=0, reason=msg)
             # For `GET`, `HEAD`
             else:
-                r = self.pool_manager.request(method, url,
-                                              fields=query_params,
-                                              preload_content=_preload_content,
-                                              timeout=timeout,
-                                              headers=headers)
+                r = self.pool_manager.request(
+                    method,
+                    url,
+                    fields=query_params,
+                    preload_content=_preload_content,
+                    timeout=timeout,
+                    headers=headers,
+                )
         except urllib3.exceptions.SSLError as e:
             msg = "{0}\n{1}".format(type(e).__name__, str(e))
             raise ApiException(status=0, reason=msg)
 
         if _preload_content:
             r = RESTResponse(r)
 
             # In the python 3, the response.data is bytes.
             # we need to decode it to string.
             if six.PY3:
-                r.data = r.data.decode('utf8')
+                r.data = r.data.decode("utf8")
 
             # log response body
             logger.debug("response body: %s", r.data)
 
         if not 200 <= r.status <= 299:
             raise ApiException(http_resp=r)
 
         return r
 
-    def GET(self, url, headers=None, query_params=None, _preload_content=True,
-            _request_timeout=None):
-        return self.request("GET", url,
-                            headers=headers,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            query_params=query_params)
-
-    def HEAD(self, url, headers=None, query_params=None, _preload_content=True,
-             _request_timeout=None):
-        return self.request("HEAD", url,
-                            headers=headers,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            query_params=query_params)
-
-    def OPTIONS(self, url, headers=None, query_params=None, post_params=None,
-                body=None, _preload_content=True, _request_timeout=None):
-        return self.request("OPTIONS", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def DELETE(self, url, headers=None, query_params=None, body=None,
-               _preload_content=True, _request_timeout=None):
-        return self.request("DELETE", url,
-                            headers=headers,
-                            query_params=query_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def POST(self, url, headers=None, query_params=None, post_params=None,
-             body=None, _preload_content=True, _request_timeout=None):
-        return self.request("POST", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def PUT(self, url, headers=None, query_params=None, post_params=None,
-            body=None, _preload_content=True, _request_timeout=None):
-        return self.request("PUT", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def PATCH(self, url, headers=None, query_params=None, post_params=None,
-              body=None, _preload_content=True, _request_timeout=None):
-        return self.request("PATCH", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
+    def GET(
+        self, url, headers=None, query_params=None, _preload_content=True, _request_timeout=None
+    ):
+        return self.request(
+            "GET",
+            url,
+            headers=headers,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            query_params=query_params,
+        )
+
+    def HEAD(
+        self, url, headers=None, query_params=None, _preload_content=True, _request_timeout=None
+    ):
+        return self.request(
+            "HEAD",
+            url,
+            headers=headers,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            query_params=query_params,
+        )
+
+    def OPTIONS(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "OPTIONS",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    def DELETE(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "DELETE",
+            url,
+            headers=headers,
+            query_params=query_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    def POST(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "POST",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    def PUT(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "PUT",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    def PATCH(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "PATCH",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
 
 
 class ApiException(Exception):
-
     def __init__(self, status=None, reason=None, http_resp=None):
         if http_resp:
             self.status = http_resp.status
             self.reason = http_resp.reason
             self.body = http_resp.data
             self.headers = http_resp.getheaders()
         else:
             self.status = status
             self.reason = reason
             self.body = None
             self.headers = None
 
     def __str__(self):
         """Custom error messages for exception"""
-        error_message = "({0})\n"\
-                        "Reason: {1}\n".format(self.status, self.reason)
+        error_message = "({0})\n" "Reason: {1}\n".format(self.status, self.reason)
         if self.headers:
-            error_message += "HTTP response headers: {0}\n".format(
-                self.headers)
+            error_message += "HTTP response headers: {0}\n".format(self.headers)
 
         if self.body:
             error_message += "HTTP response body: {0}\n".format(self.body)
 
         return error_message
```

### Comparing `harbor_api_client-2.7.5/PKG-INFO` & `harbor_api_client-2.7.6/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,28 +1,24 @@
 Metadata-Version: 2.1
 Name: harbor-api-client
-Version: 2.7.5
+Version: 2.7.6
 Summary: Client for the Harbor API
 Home-page: https://container-registry.com
 License: Apache-2.0
 Keywords: Swagger,Harbor API
 Author: Vadim Bauer
 Author-email: vb@container-registry.com
-Requires-Python: >=3.4
+Requires-Python: >=3.8
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.4
-Classifier: Programming Language :: Python :: 3.5
-Classifier: Programming Language :: Python :: 3.6
-Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
-Requires-Dist: certifi (>=2022.12.7,<2023.0.0)
+Requires-Dist: certifi (>=2022.12.7)
 Requires-Dist: python_dateutil (>=2.8.1,<3.0.0)
 Requires-Dist: six (>=1.10,<2.0)
 Requires-Dist: urllib3 (>=1.15.1,<2.0.0)
 Project-URL: Bug Tracker, https://github.com/container-registry/harbor-api-client/issues
 Project-URL: Documentation, https://container-registry.com/docs/
 Project-URL: Repository, https://github.com/container-registry/harbor-api-client
 Description-Content-Type: text/markdown
```

