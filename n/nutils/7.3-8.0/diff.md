# Comparing `tmp/nutils-7.3.tar.gz` & `tmp/nutils-8.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "nutils-7.3.tar", last modified: Fri Jan  1 00:00:00 2016, max compression
+gzip compressed data, was "nutils-8.0.tar", last modified: Fri Jan  1 00:00:00 2016, max compression
```

## Comparing `nutils-7.3.tar` & `nutils-8.0.tar`

### file list

```diff
@@ -1,126 +1,132 @@
--rw-r--r--   0        0        0       13 2023-06-20 07:52:04.243517 nutils-7.3/.codecov.yml
--rw-r--r--   0        0        0       58 2023-06-20 07:52:04.243517 nutils-7.3/.coveragerc
--rw-r--r--   0        0        0      539 2023-06-20 07:52:04.243517 nutils-7.3/.github/workflows/release.yml
--rw-r--r--   0        0        0     9669 2023-06-20 07:52:04.243517 nutils-7.3/.github/workflows/test.yaml
--rw-r--r--   0        0        0       65 2023-06-20 07:52:04.243517 nutils-7.3/.gitignore
--rw-r--r--   0        0        0    39725 2023-06-20 07:52:04.243517 nutils-7.3/CHANGELOG.rst
--rw-r--r--   0        0        0     1062 2023-06-20 07:52:04.243517 nutils-7.3/LICENSE
--rw-r--r--   0        0        0     5629 2023-06-20 07:52:04.243517 nutils-7.3/README.md
--rw-r--r--   0        0        0     1437 2023-06-20 07:52:04.243517 nutils-7.3/devtools/__init__.py
--rw-r--r--   0        0        0     1303 2023-06-20 07:52:04.243517 nutils-7.3/devtools/_git.py
--rw-r--r--   0        0        0      732 2023-06-20 07:52:04.243517 nutils-7.3/devtools/_log_default.py
--rw-r--r--   0        0        0      649 2023-06-20 07:52:04.243517 nutils-7.3/devtools/_log_gha.py
--rw-r--r--   0        0        0     3985 2023-06-20 07:52:04.243517 nutils-7.3/devtools/container/__init__.py
--rw-r--r--   0        0        0     6103 2023-06-20 07:52:04.243517 nutils-7.3/devtools/container/build.py
--rw-r--r--   0        0        0     1698 2023-06-20 07:52:04.243517 nutils-7.3/devtools/container/build_base.py
--rw-r--r--   0        0        0        0 2023-06-20 07:52:04.243517 nutils-7.3/devtools/gha/__init__.py
--rw-r--r--   0        0        0     1242 2023-06-20 07:52:04.243517 nutils-7.3/devtools/gha/configure_mkl.py
--rw-r--r--   0        0        0     1697 2023-06-20 07:52:04.243517 nutils-7.3/devtools/gha/coverage_report_xml.py
--rw-r--r--   0        0        0      776 2023-06-20 07:52:04.243517 nutils-7.3/devtools/gha/get_base_and_image_tags.py
--rw-r--r--   0        0        0      105 2023-06-20 07:52:04.243517 nutils-7.3/docs/_static/mods.css
--rw-r--r--   0        0        0      585 2023-06-20 07:52:04.243517 nutils-7.3/docs/_templates/breadcrumbs.html
--rw-r--r--   0        0        0    11343 2023-06-20 07:52:04.243517 nutils-7.3/docs/conf.py
--rw-r--r--   0        0        0   360414 2023-06-20 07:52:04.247517 nutils-7.3/docs/favicon.ico
--rw-r--r--   0        0        0      510 2023-06-20 07:52:04.247517 nutils-7.3/docs/index.rst
--rw-r--r--   0        0        0     5591 2023-06-20 07:52:04.247517 nutils-7.3/docs/sphinx_mods.py
--rw-r--r--   0        0        0      456 2023-06-20 07:52:04.247517 nutils-7.3/examples/__init__.py
--rw-r--r--   0        0        0     6802 2023-06-20 07:52:04.247517 nutils-7.3/examples/adaptivity.py
--rw-r--r--   0        0        0     4408 2023-06-20 07:52:04.247517 nutils-7.3/examples/burgers.py
--rw-r--r--   0        0        0    12895 2023-06-20 07:52:04.247517 nutils-7.3/examples/cahnhilliard.py
--rw-r--r--   0        0        0    10903 2023-06-20 07:52:04.247517 nutils-7.3/examples/coil.py
--rw-r--r--   0        0        0    12856 2023-06-20 07:52:04.247517 nutils-7.3/examples/cylinderflow.py
--rw-r--r--   0        0        0    15064 2023-06-20 07:52:04.247517 nutils-7.3/examples/drivencavity.py
--rw-r--r--   0        0        0     7185 2023-06-20 07:52:04.247517 nutils-7.3/examples/elasticity.py
--rw-r--r--   0        0        0     5882 2023-06-20 07:52:04.247517 nutils-7.3/examples/finitestrain.py
--rw-r--r--   0        0        0     7492 2023-06-20 07:52:04.247517 nutils-7.3/examples/laplace.py
--rw-r--r--   0        0        0     9758 2023-06-20 07:52:04.247517 nutils-7.3/examples/platewithhole.py
--rw-r--r--   0        0        0     2088 2023-06-20 07:52:04.247517 nutils-7.3/examples/poisson.py
--rw-r--r--   0        0        0      871 2023-06-20 07:52:04.247517 nutils-7.3/nutils/__init__.py
--rw-r--r--   0        0        0    11164 2023-06-20 07:52:04.247517 nutils-7.3/nutils/_graph.py
--rw-r--r--   0        0        0    15035 2023-06-20 07:52:04.247517 nutils-7.3/nutils/cache.py
--rw-r--r--   0        0        0    15210 2023-06-20 07:52:04.247517 nutils-7.3/nutils/cli.py
--rw-r--r--   0        0        0      468 2023-06-20 07:52:04.247517 nutils-7.3/nutils/debug_flags.py
--rw-r--r--   0        0        0    46150 2023-06-20 07:52:04.247517 nutils-7.3/nutils/element.py
--rw-r--r--   0        0        0    20862 2023-06-20 07:52:04.247517 nutils-7.3/nutils/elementseq.py
--rw-r--r--   0        0        0   174749 2023-06-20 07:52:04.251517 nutils-7.3/nutils/evaluable.py
--rw-r--r--   0        0        0     6946 2023-06-20 07:52:04.251517 nutils-7.3/nutils/export.py
--rw-r--r--   0        0        0    84274 2023-06-20 07:52:04.251517 nutils-7.3/nutils/expression_v1.py
--rw-r--r--   0        0        0    40199 2023-06-20 07:52:04.251517 nutils-7.3/nutils/expression_v2.py
--rw-r--r--   0        0        0   139029 2023-06-20 07:52:04.251517 nutils-7.3/nutils/function.py
--rw-r--r--   0        0        0     2475 2023-06-20 07:52:04.251517 nutils-7.3/nutils/matrix/__init__.py
--rw-r--r--   0        0        0      219 2023-06-20 07:52:04.251517 nutils-7.3/nutils/matrix/_auto.py
--rw-r--r--   0        0        0    13356 2023-06-20 07:52:04.251517 nutils-7.3/nutils/matrix/_base.py
--rw-r--r--   0        0        0    14021 2023-06-20 07:52:04.251517 nutils-7.3/nutils/matrix/_mkl.py
--rw-r--r--   0        0        0     2292 2023-06-20 07:52:04.251517 nutils-7.3/nutils/matrix/_numpy.py
--rw-r--r--   0        0        0     4267 2023-06-20 07:52:04.251517 nutils-7.3/nutils/matrix/_scipy.py
--rw-r--r--   0        0        0    31749 2023-06-20 07:52:04.251517 nutils-7.3/nutils/mesh.py
--rw-r--r--   0        0        0    23027 2023-06-20 07:52:04.251517 nutils-7.3/nutils/numeric.py
--rw-r--r--   0        0        0     5767 2023-06-20 07:52:04.251517 nutils-7.3/nutils/parallel.py
--rw-r--r--   0        0        0    19627 2023-06-20 07:52:04.251517 nutils-7.3/nutils/points.py
--rw-r--r--   0        0        0    22402 2023-06-20 07:52:04.251517 nutils-7.3/nutils/pointsseq.py
--rw-r--r--   0        0        0    47965 2023-06-20 07:52:04.251517 nutils-7.3/nutils/sample.py
--rw-r--r--   0        0        0    44018 2023-06-20 07:52:04.251517 nutils-7.3/nutils/solver.py
--rw-r--r--   0        0        0    13225 2023-06-20 07:52:04.251517 nutils-7.3/nutils/sparse.py
--rw-r--r--   0        0        0    11497 2023-06-20 07:52:04.251517 nutils-7.3/nutils/testing.py
--rw-r--r--   0        0        0   148854 2023-06-20 07:52:04.255518 nutils-7.3/nutils/topology.py
--rw-r--r--   0        0        0    24673 2023-06-20 07:52:04.255518 nutils-7.3/nutils/transform.py
--rw-r--r--   0        0        0    38427 2023-06-20 07:52:04.255518 nutils-7.3/nutils/transformseq.py
--rw-r--r--   0        0        0    49559 2023-06-20 07:52:04.255518 nutils-7.3/nutils/types.py
--rw-r--r--   0        0        0     6934 2023-06-20 07:52:04.255518 nutils-7.3/nutils/unit.py
--rw-r--r--   0        0        0    18250 2023-06-20 07:52:04.255518 nutils-7.3/nutils/util.py
--rw-r--r--   0        0        0     1020 2023-06-20 07:52:04.255518 nutils-7.3/nutils/warnings.py
--rw-r--r--   0        0        0      720 2023-06-20 07:52:04.255518 nutils-7.3/pyproject.toml
--rw-r--r--   0        0        0      118 2023-06-20 07:52:04.255518 nutils-7.3/readthedocs.yml
--rw-r--r--   0        0        0        0 2023-06-20 07:52:04.255518 nutils-7.3/tests/__init__.py
--rw-r--r--   0        0        0    16414 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_basis.py
--rw-r--r--   0        0        0    14034 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_cache.py
--rw-r--r--   0        0        0     5572 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_cli.py
--rw-r--r--   0        0        0     2977 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_docs.py
--rw-r--r--   0        0        0     4916 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_element.py
--rw-r--r--   0        0        0     9541 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_elementseq.py
--rw-r--r--   0        0        0    65386 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_evaluable.py
--rw-r--r--   0        0        0     9353 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_export.py
--rw-r--r--   0        0        0    52174 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_expression_v1.py
--rw-r--r--   0        0        0    24532 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_expression_v2.py
--rw-r--r--   0        0        0    18454 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_finitecell.py
--rw-r--r--   0        0        0    67732 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_function.py
--rw-r--r--   0        0        0    13425 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_graph.py
--rw-r--r--   0        0        0     3214 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_ischeme.py
--rw-r--r--   0        0        0    11189 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_matrix.py
--rw-r--r--   0        0        0     7242 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_mesh.py
--rw-r--r--   0        0        0     1388 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_mesh/mesh2d.geo
--rw-r--r--   0        0        0     6702 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_mesh/mesh2d_p1_v2.msh
--rw-r--r--   0        0        0     5618 2023-06-20 07:52:04.255518 nutils-7.3/tests/test_mesh/mesh2d_p1_v4.msh
--rw-r--r--   0        0        0    17648 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh2d_p2_v2.msh
--rw-r--r--   0        0        0    16228 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh2d_p2_v4.msh
--rw-r--r--   0        0        0    35340 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh2d_p3_v2.msh
--rw-r--r--   0        0        0    33181 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh2d_p3_v4.msh
--rw-r--r--   0        0        0    59708 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh2d_p4_v2.msh
--rw-r--r--   0        0        0    56807 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh2d_p4_v4.msh
--rw-r--r--   0        0        0     3221 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh3d.geo
--rw-r--r--   0        0        0    78920 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh3d_p1_v2.msh
--rw-r--r--   0        0        0    59146 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh3d_p1_v4.msh
--rw-r--r--   0        0        0   254705 2023-06-20 07:52:04.259518 nutils-7.3/tests/test_mesh/mesh3d_p2_v2.msh
--rw-r--r--   0        0        0   225898 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_mesh/mesh3d_p2_v4.msh
--rw-r--r--   0        0        0      742 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_mesh/mesh3dmani.geo
--rw-r--r--   0        0        0     5893 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_mesh/mesh3dmani_p1_v2.msh
--rw-r--r--   0        0        0     5587 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_mesh/mesh3dmani_p1_v4.msh
--rw-r--r--   0        0        0    17016 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_mesh/mesh3dmani_p2_v2.msh
--rw-r--r--   0        0        0    16281 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_mesh/mesh3dmani_p2_v4.msh
--rw-r--r--   0        0        0     2665 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_normals.py
--rw-r--r--   0        0        0    11273 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_numeric.py
--rw-r--r--   0        0        0     2204 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_parallel.py
--rw-r--r--   0        0        0     7066 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_points.py
--rw-r--r--   0        0        0    11292 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_pointsseq.py
--rw-r--r--   0        0        0     2268 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_quadrature.py
--rw-r--r--   0        0        0    25943 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_sample.py
--rw-r--r--   0        0        0    13474 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_solver.py
--rw-r--r--   0        0        0    13697 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_sparse.py
--rw-r--r--   0        0        0     1705 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_testing.py
--rw-r--r--   0        0        0    61518 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_topology.py
--rw-r--r--   0        0        0     6397 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_transform.py
--rw-r--r--   0        0        0    21581 2023-06-20 07:52:04.263518 nutils-7.3/tests/test_transformseq.py
--rw-r--r--   0        0        0    38683 2023-06-20 07:52:04.267518 nutils-7.3/tests/test_types.py
--rw-r--r--   0        0        0     2317 2023-06-20 07:52:04.267518 nutils-7.3/tests/test_unit.py
--rw-r--r--   0        0        0     8101 2023-06-20 07:52:04.267518 nutils-7.3/tests/test_util.py
--rw-r--r--   0        0        0     6550 1970-01-01 00:00:00.000000 nutils-7.3/PKG-INFO
+-rw-r--r--   0        0        0       13 2023-07-28 10:56:30.854624 nutils-8.0/.codecov.yml
+-rw-r--r--   0        0        0       58 2023-07-28 10:56:30.854624 nutils-8.0/.coveragerc
+-rw-r--r--   0        0        0      539 2023-07-28 10:56:30.854624 nutils-8.0/.github/workflows/release.yml
+-rw-r--r--   0        0        0     9543 2023-07-28 10:56:30.854624 nutils-8.0/.github/workflows/test.yaml
+-rw-r--r--   0        0        0       65 2023-07-28 10:56:30.854624 nutils-8.0/.gitignore
+-rw-r--r--   0        0        0     8296 2023-07-28 10:56:30.854624 nutils-8.0/CHANGELOG
+-rw-r--r--   0        0        0     1062 2023-07-28 10:56:30.854624 nutils-8.0/LICENSE
+-rw-r--r--   0        0        0     6035 2023-07-28 10:56:30.854624 nutils-8.0/README.md
+-rw-r--r--   0        0        0     1437 2023-07-28 10:56:30.854624 nutils-8.0/devtools/__init__.py
+-rw-r--r--   0        0        0     1303 2023-07-28 10:56:30.854624 nutils-8.0/devtools/_git.py
+-rw-r--r--   0        0        0      732 2023-07-28 10:56:30.854624 nutils-8.0/devtools/_log_default.py
+-rw-r--r--   0        0        0      701 2023-07-28 10:56:30.854624 nutils-8.0/devtools/_log_gha.py
+-rw-r--r--   0        0        0     3985 2023-07-28 10:56:30.854624 nutils-8.0/devtools/container/__init__.py
+-rw-r--r--   0        0        0     5961 2023-07-28 10:56:30.854624 nutils-8.0/devtools/container/build.py
+-rw-r--r--   0        0        0     1698 2023-07-28 10:56:30.854624 nutils-8.0/devtools/container/build_base.py
+-rw-r--r--   0        0        0        0 2023-07-28 10:56:30.854624 nutils-8.0/devtools/gha/__init__.py
+-rw-r--r--   0        0        0     1242 2023-07-28 10:56:30.854624 nutils-8.0/devtools/gha/configure_mkl.py
+-rw-r--r--   0        0        0     1697 2023-07-28 10:56:30.854624 nutils-8.0/devtools/gha/coverage_report_xml.py
+-rw-r--r--   0        0        0      776 2023-07-28 10:56:30.854624 nutils-8.0/devtools/gha/get_base_and_image_tags.py
+-rw-r--r--   0        0        0      105 2023-07-28 10:56:30.854624 nutils-8.0/docs/_static/mods.css
+-rw-r--r--   0        0        0      585 2023-07-28 10:56:30.854624 nutils-8.0/docs/_templates/breadcrumbs.html
+-rw-r--r--   0        0        0    11343 2023-07-28 10:56:30.854624 nutils-8.0/docs/conf.py
+-rw-r--r--   0        0        0   360414 2023-07-28 10:56:30.854624 nutils-8.0/docs/favicon.ico
+-rw-r--r--   0        0        0      510 2023-07-28 10:56:30.854624 nutils-8.0/docs/index.rst
+-rw-r--r--   0        0        0     5591 2023-07-28 10:56:30.854624 nutils-8.0/docs/sphinx_mods.py
+-rw-r--r--   0        0        0      456 2023-07-28 10:56:30.854624 nutils-8.0/examples/__init__.py
+-rw-r--r--   0        0        0     7534 2023-07-28 10:56:30.854624 nutils-8.0/examples/adaptivity.py
+-rw-r--r--   0        0        0     3561 2023-07-28 10:56:30.854624 nutils-8.0/examples/burgers.py
+-rw-r--r--   0        0        0    12672 2023-07-28 10:56:30.854624 nutils-8.0/examples/cahnhilliard.py
+-rw-r--r--   0        0        0    11156 2023-07-28 10:56:30.854624 nutils-8.0/examples/coil.py
+-rw-r--r--   0        0        0    12287 2023-07-28 10:56:30.854624 nutils-8.0/examples/cylinderflow.py
+-rw-r--r--   0        0        0    14036 2023-07-28 10:56:30.854624 nutils-8.0/examples/drivencavity.py
+-rw-r--r--   0        0        0     6133 2023-07-28 10:56:30.854624 nutils-8.0/examples/elasticity.py
+-rw-r--r--   0        0        0     4916 2023-07-28 10:56:30.854624 nutils-8.0/examples/finitestrain.py
+-rw-r--r--   0        0        0     6972 2023-07-28 10:56:30.854624 nutils-8.0/examples/laplace.py
+-rw-r--r--   0        0        0     9749 2023-07-28 10:56:30.858625 nutils-8.0/examples/platewithhole.py
+-rw-r--r--   0        0        0     1564 2023-07-28 10:56:30.858625 nutils-8.0/examples/poisson.py
+-rw-r--r--   0        0        0     5665 2023-07-28 10:56:30.858625 nutils-8.0/examples/torsion.py
+-rw-r--r--   0        0        0    20989 2023-07-28 10:56:30.858625 nutils-8.0/nutils/SI.py
+-rw-r--r--   0        0        0      860 2023-07-28 10:56:30.858625 nutils-8.0/nutils/__init__.py
+-rw-r--r--   0        0        0     1537 2023-07-28 10:56:30.858625 nutils-8.0/nutils/_backports.py
+-rw-r--r--   0        0        0    11089 2023-07-28 10:56:30.858625 nutils-8.0/nutils/_graph.py
+-rw-r--r--   0        0        0    26523 2023-07-28 10:56:30.858625 nutils-8.0/nutils/_util.py
+-rw-r--r--   0        0        0    15246 2023-07-28 10:56:30.858625 nutils-8.0/nutils/cache.py
+-rw-r--r--   0        0        0     1539 2023-07-28 10:56:30.858625 nutils-8.0/nutils/cli.py
+-rw-r--r--   0        0        0      468 2023-07-28 10:56:30.858625 nutils-8.0/nutils/debug_flags.py
+-rw-r--r--   0        0        0    48181 2023-07-28 10:56:30.858625 nutils-8.0/nutils/element.py
+-rw-r--r--   0        0        0    20568 2023-07-28 10:56:30.858625 nutils-8.0/nutils/elementseq.py
+-rw-r--r--   0        0        0   200146 2023-07-28 10:56:30.858625 nutils-8.0/nutils/evaluable.py
+-rw-r--r--   0        0        0    11441 2023-07-28 10:56:30.858625 nutils-8.0/nutils/export.py
+-rw-r--r--   0        0        0    84259 2023-07-28 10:56:30.858625 nutils-8.0/nutils/expression_v1.py
+-rw-r--r--   0        0        0    41347 2023-07-28 10:56:30.858625 nutils-8.0/nutils/expression_v2.py
+-rw-r--r--   0        0        0   168665 2023-07-28 10:56:30.862625 nutils-8.0/nutils/function.py
+-rw-r--r--   0        0        0     2233 2023-07-28 10:56:30.862625 nutils-8.0/nutils/matrix/__init__.py
+-rw-r--r--   0        0        0      219 2023-07-28 10:56:30.862625 nutils-8.0/nutils/matrix/_auto.py
+-rw-r--r--   0        0        0    13463 2023-07-28 10:56:30.862625 nutils-8.0/nutils/matrix/_base.py
+-rw-r--r--   0        0        0    14350 2023-07-28 10:56:30.862625 nutils-8.0/nutils/matrix/_mkl.py
+-rw-r--r--   0        0        0     2292 2023-07-28 10:56:30.862625 nutils-8.0/nutils/matrix/_numpy.py
+-rw-r--r--   0        0        0     4267 2023-07-28 10:56:30.862625 nutils-8.0/nutils/matrix/_scipy.py
+-rw-r--r--   0        0        0    35487 2023-07-28 10:56:30.862625 nutils-8.0/nutils/mesh.py
+-rw-r--r--   0        0        0    23614 2023-07-28 10:56:30.862625 nutils-8.0/nutils/numeric.py
+-rw-r--r--   0        0        0     5682 2023-07-28 10:56:30.862625 nutils-8.0/nutils/parallel.py
+-rw-r--r--   0        0        0    19627 2023-07-28 10:56:30.862625 nutils-8.0/nutils/points.py
+-rw-r--r--   0        0        0    22300 2023-07-28 10:56:30.862625 nutils-8.0/nutils/pointsseq.py
+-rw-r--r--   0        0        0    45140 2023-07-28 10:56:30.862625 nutils-8.0/nutils/sample.py
+-rw-r--r--   0        0        0    48637 2023-07-28 10:56:30.862625 nutils-8.0/nutils/solver.py
+-rw-r--r--   0        0        0    13225 2023-07-28 10:56:30.862625 nutils-8.0/nutils/sparse.py
+-rw-r--r--   0        0        0    11497 2023-07-28 10:56:30.862625 nutils-8.0/nutils/testing.py
+-rw-r--r--   0        0        0   155030 2023-07-28 10:56:30.862625 nutils-8.0/nutils/topology.py
+-rw-r--r--   0        0        0    16670 2023-07-28 10:56:30.862625 nutils-8.0/nutils/transform.py
+-rw-r--r--   0        0        0    34922 2023-07-28 10:56:30.862625 nutils-8.0/nutils/transformseq.py
+-rw-r--r--   0        0        0    23704 2023-07-28 10:56:30.862625 nutils-8.0/nutils/types.py
+-rw-r--r--   0        0        0     6934 2023-07-28 10:56:30.862625 nutils-8.0/nutils/unit.py
+-rw-r--r--   0        0        0      872 2023-07-28 10:56:30.862625 nutils-8.0/nutils/warnings.py
+-rw-r--r--   0        0        0      772 2023-07-28 10:56:30.862625 nutils-8.0/pyproject.toml
+-rw-r--r--   0        0        0      118 2023-07-28 10:56:30.862625 nutils-8.0/readthedocs.yml
+-rw-r--r--   0        0        0        0 2023-07-28 10:56:30.862625 nutils-8.0/tests/__init__.py
+-rw-r--r--   0        0        0     9897 2023-07-28 10:56:30.862625 nutils-8.0/tests/test_SI.py
+-rw-r--r--   0        0        0      793 2023-07-28 10:56:30.862625 nutils-8.0/tests/test_backports.py
+-rw-r--r--   0        0        0    16428 2023-07-28 10:56:30.862625 nutils-8.0/tests/test_basis.py
+-rw-r--r--   0        0        0    14044 2023-07-28 10:56:30.862625 nutils-8.0/tests/test_cache.py
+-rw-r--r--   0        0        0     2116 2023-07-28 10:56:30.862625 nutils-8.0/tests/test_cli.py
+-rw-r--r--   0        0        0     2977 2023-07-28 10:56:30.862625 nutils-8.0/tests/test_docs.py
+-rw-r--r--   0        0        0     6271 2023-07-28 10:56:30.862625 nutils-8.0/tests/test_element.py
+-rw-r--r--   0        0        0     9541 2023-07-28 10:56:30.862625 nutils-8.0/tests/test_elementseq.py
+-rw-r--r--   0        0        0    78239 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_evaluable.py
+-rw-r--r--   0        0        0    10908 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_export.py
+-rw-r--r--   0        0        0    52161 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_expression_v1.py
+-rw-r--r--   0        0        0    24679 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_expression_v2.py
+-rw-r--r--   0        0        0    18942 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_finitecell.py
+-rw-r--r--   0        0        0    74822 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_function.py
+-rw-r--r--   0        0        0    13788 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_graph.py
+-rw-r--r--   0        0        0     3253 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_ischeme.py
+-rw-r--r--   0        0        0    11189 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_matrix.py
+-rw-r--r--   0        0        0     9685 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh.py
+-rw-r--r--   0        0        0     1388 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh2d.geo
+-rw-r--r--   0        0        0     6702 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh2d_p1_v2.msh
+-rw-r--r--   0        0        0     5618 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh2d_p1_v4.msh
+-rw-r--r--   0        0        0    17648 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh2d_p2_v2.msh
+-rw-r--r--   0        0        0    16228 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh2d_p2_v4.msh
+-rw-r--r--   0        0        0    35340 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh2d_p3_v2.msh
+-rw-r--r--   0        0        0    33181 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh2d_p3_v4.msh
+-rw-r--r--   0        0        0    59708 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh2d_p4_v2.msh
+-rw-r--r--   0        0        0    56807 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh2d_p4_v4.msh
+-rw-r--r--   0        0        0     3221 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh3d.geo
+-rw-r--r--   0        0        0    78920 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh3d_p1_v2.msh
+-rw-r--r--   0        0        0    59146 2023-07-28 10:56:30.866624 nutils-8.0/tests/test_mesh/mesh3d_p1_v4.msh
+-rw-r--r--   0        0        0   254705 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_mesh/mesh3d_p2_v2.msh
+-rw-r--r--   0        0        0   225898 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_mesh/mesh3d_p2_v4.msh
+-rw-r--r--   0        0        0      742 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_mesh/mesh3dmani.geo
+-rw-r--r--   0        0        0     5893 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_mesh/mesh3dmani_p1_v2.msh
+-rw-r--r--   0        0        0     5587 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_mesh/mesh3dmani_p1_v4.msh
+-rw-r--r--   0        0        0    17016 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_mesh/mesh3dmani_p2_v2.msh
+-rw-r--r--   0        0        0    16281 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_mesh/mesh3dmani_p2_v4.msh
+-rw-r--r--   0        0        0     2708 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_normals.py
+-rw-r--r--   0        0        0    16473 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_numeric.py
+-rw-r--r--   0        0        0     2206 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_parallel.py
+-rw-r--r--   0        0        0     5654 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_points.py
+-rw-r--r--   0        0        0    11346 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_pointsseq.py
+-rw-r--r--   0        0        0     2297 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_quadrature.py
+-rw-r--r--   0        0        0    27471 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_sample.py
+-rw-r--r--   0        0        0    15933 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_solver.py
+-rw-r--r--   0        0        0    13697 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_sparse.py
+-rw-r--r--   0        0        0     1712 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_testing.py
+-rw-r--r--   0        0        0    64170 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_topology.py
+-rw-r--r--   0        0        0     4607 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_transform.py
+-rw-r--r--   0        0        0    20363 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_transformseq.py
+-rw-r--r--   0        0        0    23999 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_types.py
+-rw-r--r--   0        0        0     2317 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_unit.py
+-rw-r--r--   0        0        0    12562 2023-07-28 10:56:30.870624 nutils-8.0/tests/test_util.py
+-rw-r--r--   0        0        0      379 2023-07-28 10:56:30.874624 nutils-8.0/tests/test_warnings.py
+-rw-r--r--   0        0        0     7032 1970-01-01 00:00:00.000000 nutils-8.0/PKG-INFO
```

### Comparing `nutils-7.3/.github/workflows/release.yml` & `nutils-8.0/.github/workflows/release.yml`

 * *Files identical despite different names*

### Comparing `nutils-7.3/.github/workflows/test.yaml` & `nutils-8.0/.github/workflows/test.yaml`

 * *Files 2% similar despite different names*

```diff
@@ -24,15 +24,15 @@
       - name: Build package
         id: build
         run: |
           # To make the wheels reproducible, set the timestamp of the (files in
           # the) generated wheels to the date of the commit.
           export SOURCE_DATE_EPOCH=`git show -s --format=%ct`
           python3 -m flit build
-          printf "::set-output name=wheel::%s" dist/*.whl
+          echo wheel=`echo dist/*.whl` >> $GITHUB_OUTPUT
       - name: Upload package artifacts
         uses: actions/upload-artifact@v2
         with:
           name: python-package
           path: dist/
           if-no-files-found: error
   test:
@@ -89,18 +89,18 @@
         id: install
         env:
           _numpy_version: ${{ matrix.numpy-version }}
         run: |
           python -um pip install --upgrade --upgrade-strategy eager wheel
           python -um pip install --upgrade --upgrade-strategy eager coverage numpy$_numpy_version
           # Install Nutils from `dist` dir created in job `build-python-package`.
-          python -um pip install "$_wheel[import_gmsh]"
+          python -um pip install "$_wheel[import_gmsh,export_mpl]"
       - name: Install Scipy
         if: ${{ matrix.matrix-backend == 'scipy' }}
-        run: python -um pip install --upgrade --upgrade-strategy eager scipy
+        run: python -um pip install --upgrade scipy
       - name: Configure MKL
         if: ${{ matrix.matrix-backend == 'mkl' }}
         run: |
           python -um pip install --upgrade --upgrade-strategy eager mkl
           python -um devtools.gha.configure_mkl
       - name: Test
         run: python -um coverage run -m unittest discover -b -q -t . -s tests
@@ -136,15 +136,14 @@
         with:
           name: python-package
           path: dist/
       - name: Install Nutils and dependencies
         id: install
         run: |
           python -um pip install --upgrade --upgrade-strategy eager wheel
-          python -um pip install --upgrade --upgrade-strategy eager git+https://github.com/evalf/nutils-SI.git
           # Install Nutils from `dist` dir created in job `build-python-package`.
           python -um pip install "$_wheel[matrix_scipy,export_mpl]"
       - name: Test
         run: python -um unittest discover -b -q -t . -s examples
   test-sphinx:
     name: Test building docs
     runs-on: ubuntu-20.04
```

### Comparing `nutils-7.3/LICENSE` & `nutils-8.0/LICENSE`

 * *Files identical despite different names*

### Comparing `nutils-7.3/README.md` & `nutils-8.0/README.md`

 * *Files 4% similar despite different names*

```diff
@@ -43,14 +43,18 @@
 
     python3 -m pip install --user https://github.com/evalf/nutils/archive/master.zip
 
 To view which version of Nutils is currently installed, run:
 
     python3 -m pip show nutils
 
+Nutils can be installed in a Windows machine using WSL environment.
+If you want to assemble matrices in parallel using nutils on a Windows machine, 
+then WSL is the way to go. Instructions to setup WSL are available [here][13]. 
+After setting up WSL, nutils can be installed using the above instructions. 
 
 First steps
 -----------
 
 To confirm Nutils and its dependencies are installed correctly, try to run the
 Laplace example or any of the other examples included in this repostitory. Make
 sure to use the same version of an example as the version of Nutils that is
@@ -118,7 +122,8 @@
 [6]: http://docs.nutils.org/en/latest/examples/
 [7]: http://docs.nutils.org/en/latest/nutils/
 [8]: https://matrix.to/#/#nutils-users:matrix.org
 [9]: https://doi.org/10.5281/zenodo.822369
 [10]: https://www.docker.com/
 [11]: https://github.com/orgs/evalf/packages/container/package/nutils
 [12]: https://raw.githubusercontent.com/evalf/nutils/master/examples/laplace.py
+[13]: https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview
```

### Comparing `nutils-7.3/devtools/__init__.py` & `nutils-8.0/devtools/__init__.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/devtools/_git.py` & `nutils-8.0/devtools/_git.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/devtools/_log_default.py` & `nutils-8.0/devtools/_log_default.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/devtools/_log_gha.py` & `nutils-8.0/devtools/_log_gha.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+import os
+from pathlib import Path
 from typing import Any
 
 debug = print
 
 
 def info(*args: Any) -> None:
     print('\033[1;37m', end='')
@@ -17,9 +19,9 @@
 
 def error(*args: Any) -> None:
     for line in ' '.join(map(str, args)).split('\n'):
         print('::error ::{}'.format(line))
 
 
 def set_output(key: str, value: str) -> None:
-    print('::set-output name={}::{}'.format(key, value))
+    Path(os.environ['GITHUB_OUTPUT']).open('a').write(f'{key}={value}\n')
     print('\033[1;35mOUTPUT: {}={}\033[0m'.format(key, value))
```

### Comparing `nutils-7.3/devtools/container/__init__.py` & `nutils-8.0/devtools/container/__init__.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/devtools/container/build.py` & `nutils-8.0/devtools/container/build.py`

 * *Files 3% similar despite different names*

```diff
@@ -63,15 +63,14 @@
     else:
         examples = src.path / 'examples'
         log.info(f'using examples from commit {commit}')
 
     container = stack.enter_context(Container.new_from(base, mounts=[Mount(src=wheel, dst=f'/{wheel.name}')]))
 
     container.run('pip', 'install', '--no-cache-dir', f'/{wheel.name}[export_mpl,import_gmsh,matrix_scipy]', env=dict(PYTHONHASHSEED='0'))
-    container.run('pip', 'install', '--no-cache-dir', 'https://github.com/evalf/nutils-SI/archive/main.tar.gz', env=dict(PYTHONHASHSEED='0'))
     container.add_label('org.opencontainers.image.url', 'https://github.com/evalf/nutils')
     container.add_label('org.opencontainers.image.source', 'https://github.com/evalf/nutils')
     container.add_label('org.opencontainers.image.authors', 'Evalf')
     if commit:
         container.add_label('org.opencontainers.image.revision', commit)
     container.add_volume('/app')
     container.add_volume('/log')
```

### Comparing `nutils-7.3/devtools/container/build_base.py` & `nutils-8.0/devtools/container/build_base.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/devtools/gha/configure_mkl.py` & `nutils-8.0/devtools/gha/configure_mkl.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/devtools/gha/coverage_report_xml.py` & `nutils-8.0/devtools/gha/coverage_report_xml.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/devtools/gha/get_base_and_image_tags.py` & `nutils-8.0/devtools/gha/get_base_and_image_tags.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/docs/_templates/breadcrumbs.html` & `nutils-8.0/docs/_templates/breadcrumbs.html`

 * *Files identical despite different names*

### Comparing `nutils-7.3/docs/conf.py` & `nutils-8.0/docs/conf.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/docs/favicon.ico` & `nutils-8.0/docs/favicon.ico`

 * *Files identical despite different names*

### Comparing `nutils-7.3/docs/sphinx_mods.py` & `nutils-8.0/docs/sphinx_mods.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/examples/adaptivity.py` & `nutils-8.0/examples/laplace.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,146 +1,159 @@
-# Adaptive refinement of reentrant corner
-#
-# In this script we solve the Laplace problem on a unit square that has the
-# bottom-right quadrant removed (a.k.a. an L-shaped domain) with Dirichlet
-# boundary conditions matching the harmonic function
-#
-#     ³√(x² + y²) cos(⅔ arctan2(y+x, y-x))
-#
-# shifted by ½ such that the origin coincides with the middle of the unit
-# square. This variation of a well known benchmark problem is known to converge
-# suboptimally under uniform refinement due to a singular gradient in the
-# reentrant corner. This script demonstrates that optimal convergence can be
-# restored by using adaptive refinement.
-
-from nutils import mesh, function, solver, util, export, cli, testing
+from nutils import mesh, function, solver, export, testing
 from nutils.expression_v2 import Namespace
-import numpy
 import treelog
 
+# This is a heavily commented example that strives to introduce the main
+# building blocks of a typical Nutils script.
 
-def main(etype: str, btype: str, degree: int, nrefine: int):
-    '''
-    Adaptively refined Laplace problem on an L-shaped domain.
-
-    .. arguments::
 
-       etype [square]
-         Type of elements (square/triangle/mixed).
-       btype [h-std]
-         Type of basis function (h/th-std/spline), with availability depending on
-         the configured element type.
-       degree [2]
-         Polynomial degree
-       nrefine [5]
-         Number of refinement steps to perform.
+def main(nelems: int = 10,
+         etype: str = 'square',
+         btype: str = 'std',
+         degree: int = 1):
+
+    '''Laplace problem on a unit square
+    
+    Solves Laplace's equation `Δu = 0` on a unit square domain `Ω` with
+    boundary `Γ`, subject to boundary conditions:
+    
+            u = 0                 Γ_left
+        ∂_n u = 0                 Γ_bottom
+        ∂_n u = cos(1) cosh(y)    Γ_right
+            u = cosh(1) sin(x)    Γ_top
+    
+    This problem is constructed to contain all combinations of homogenous and
+    heterogeneous, Dirichlet and Neumann type boundary conditions, as well as to
+    have a known exact solution in `uexact = sin(x) cosh(y)`.
+
+    Parameters
+    ----------
+    nelems
+        Number of elements along edge.
+    etype
+        Type of elements (square/triangle/mixed).
+    btype
+        Type of basis function (std/spline), availability depending on the
+        selected element type.
+    degree
+        Polynomial degree.
     '''
 
-    domain, geom = mesh.unitsquare(2, etype)
+    # A unit square domain is created by calling the nutils.mesh.unitsquare
+    # mesh generator, with the number of elements along an edge as the first
+    # argument, and the type of elements ("square", "triangle", or "mixed") as
+    # the second. The result is a topology object `domain` and a vectored
+    # valued geometry function `geom`.
+
+    domain, geom = mesh.unitsquare(nelems, etype)
+
+    # To be able to write index based tensor contractions, we need to bundle
+    # all relevant functions together in a namespace. Here we add the geometry
+    # `x`, a test function `v`, and the solution `u`. The latter two are formed
+    # by contracting a basis with function arguments of the same name.
+
+    ns = Namespace()
+    ns.x = geom
+    ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
+    ns.add_field(('u', 'v'), domain.basis(btype, degree=degree))
+
+    # We are now ready to implement the Laplace equation. In weak form, the
+    # solution is a scalar field `u` for which ∫_Ω ∇v·∇u - ∫_Γn v f = 0 ∀ v.
+
+    res = domain.integral('∇_i(v) ∇_i(u) dV' @ ns, degree=degree*2)
+    res -= domain.boundary['right'].integral('v cos(1) cosh(x_1) dS' @ ns, degree=degree*2)
+
+    # The Dirichlet constraints are set by finding the coefficients that
+    # minimize the error ∫_Γd (u - u_d)^2. The resulting `cons` dictionary
+    # holds numerical values for all the entries of the function argument `u`
+    # that contribute (up to `droptol`) to the minimization problem. All
+    # remaining entries are set to `NaN`, signifying that these degrees of
+    # freedom are unconstrained.
+
+    sqr = domain.boundary['left'].integral('u^2 dS' @ ns, degree=degree*2)
+    sqr += domain.boundary['top'].integral('(u - cosh(1) sin(x_0))^2 dS' @ ns, degree=degree*2)
+    cons = solver.optimize('u,', sqr, droptol=1e-15)
+
+    # The unconstrained entries of `u` are to be such that the residual
+    # evaluates to zero for all possible values of `v`. The resulting array `u`
+    # matches `cons` in the constrained entries.
+
+    args = solver.solve_linear('u:v', res, constrain=cons)
+
+    # Once all arguments are establised, the corresponding solution can be
+    # vizualised by sampling values of `ns.u` along with physical coordinates
+    # `ns.x`, with the solution vector provided via keyword arguments. The
+    # sample members `tri` and `hull` provide additional inter-point
+    # information required for drawing the mesh and element outlines.
+
+    bezier = domain.sample('bezier', 9)
+    xsmp, usmp = bezier.eval(['x_i', 'u'] @ ns, **args)
+    export.triplot('solution.png', xsmp, usmp, tri=bezier.tri, hull=bezier.hull)
 
-    x, y = geom - .5
-    exact = (x**2 + y**2)**(1/3) * function.cos(function.arctan2(y+x, y-x) * (2/3))
-    domain = domain.trim(exact-1e-15, maxrefine=0)
-    linreg = util.linear_regressor()
-
-    with treelog.iter.fraction('level', range(nrefine+1)) as lrange:
-        for irefine in lrange:
-
-            if irefine:
-                refdom = domain.refined
-                ns.refbasis = refdom.basis(btype, degree=degree)
-                indicator = refdom.integral('∇_k(refbasis_n) ∇_k(u) dV' @ ns, degree=degree*2).eval(lhs=lhs)
-                indicator -= refdom.boundary.integral('refbasis_n ∇_k(u) n_k dS' @ ns, degree=degree*2).eval(lhs=lhs)
-                supp = ns.refbasis.get_support(indicator**2 > numpy.mean(indicator**2))
-                domain = domain.refined_by(refdom.transforms[supp])
-
-            ns = Namespace()
-            ns.x = geom
-            ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
-            ns.basis = domain.basis(btype, degree=degree)
-            ns.u = function.dotarg('lhs', ns.basis)
-            ns.du = ns.u - exact
-
-            sqr = domain.boundary['trimmed'].integral('u^2 dS' @ ns, degree=degree*2)
-            cons = solver.optimize('lhs', sqr, droptol=1e-15)
-
-            sqr = domain.boundary.integral('du^2 dS' @ ns, degree=7)
-            cons = solver.optimize('lhs', sqr, droptol=1e-15, constrain=cons)
-
-            res = domain.integral('∇_k(basis_n) ∇_k(u) dV' @ ns, degree=degree*2)
-            lhs = solver.solve_linear('lhs', res, constrain=cons)
-
-            ndofs = len(ns.basis)
-            error = function.sqrt(domain.integral(['du du dV', '∇_k(du) ∇_k(du) dV'] @ ns, degree=7)).eval(lhs=lhs)
-            rate, offset = linreg.add(numpy.log(len(ns.basis)), numpy.log(error))
-            treelog.user('ndofs: {ndofs}, L2 error: {error[0]:.2e} ({rate[0]:.2f}), H1 error: {error[1]:.2e} ({rate[1]:.2f})'.format(ndofs=len(ns.basis), error=error, rate=rate))
-
-            bezier = domain.sample('bezier', 9)
-            x, u, du = bezier.eval(['x_i', 'u', 'du'] @ ns, lhs=lhs)
-            export.triplot('sol.png', x, u, tri=bezier.tri, hull=bezier.hull)
-            export.triplot('err.png', x, du, tri=bezier.tri, hull=bezier.hull)
-
-    return ndofs, error, lhs
-
-# If the script is executed (as opposed to imported), :func:`nutils.cli.run`
-# calls the main function with arguments provided from the command line. For
-# example, to perform four refinement steps with quadratic basis functions
-# starting from a triangle mesh run :sh:`python3 adaptivity.py etype=triangle
-# degree=2 nrefine=4`.
+    # To confirm that our computation is correct, we use our knowledge of the
+    # analytical solution to evaluate the L2-error of the discrete result.
 
+    err = domain.integral('(u - sin(x_0) cosh(x_1))^2 dV' @ ns, degree=degree*2).eval(**args)**.5
+    treelog.user('L2 error: {:.2e}'.format(err))
+
+    return cons['u'], args['u'], err
 
-if __name__ == '__main__':
-    cli.run(main)
 
 # Once a simulation is developed and tested, it is good practice to save a few
 # strategic return values for regression testing. The :mod:`nutils.testing`
 # module, which builds on the standard :mod:`unittest` framework, facilitates
 # this by providing :func:`nutils.testing.TestCase.assertAlmostEqual64` for the
 # embedding of desired results as compressed base64 data.
 
-
 class test(testing.TestCase):
 
-    def test_square_quadratic(self):
-        ndofs, error, lhs = main(nrefine=2, btype='h-std', etype='square', degree=2)
-        with self.subTest('degrees of freedom'):
-            self.assertEqual(ndofs, 149)
-        with self.subTest('L2-error'):
-            self.assertAlmostEqual(error[0], 0.00065, places=5)
-        with self.subTest('H1-error'):
-            self.assertAlmostEqual(error[1], 0.03461, places=5)
+    def test_simple(self):
+        cons, u, err = main(nelems=4)
+        with self.subTest('constraints'):
+            self.assertAlmostEqual64(cons, '''
+                eNrbKPv1QZ3ip9sL1BgaILDYFMbaZwZj5ZnDWNfNAeWPESU=''')
         with self.subTest('left-hand side'):
-            self.assertAlmostEqual64(lhs, '''
-                eNo1j6FrQmEUxT8RBi4KllVfMsl3z/nK4zEmLC6bhsKCw2gSw5IPFsymGbZiWnr+By8Ii7Yhsk3BMtC4
-                Z9sJ223ncs85vzvmM9+Yhix8hDIjtnkdHqQSdDDDj1Qajr5qPXN/07MZ2vI4V7UOIvmdO/oEZY45xYDn
-                oR7ikLHAHVpcs2A1TLhChDO+MOeWt5xjYzm6fOQrGxxiZPeoMGaf37hCyU72hB0u6PglPcQcKxRI/KUd
-                7AYLvMPpsqGkCTPumzWf+qV92kKevjK36ozDP/FSnh1iteWiqWuf+oMaKuyKaC1i52rKPokiF2WLA/20
-                bya+ZCPbWKRPpvgFaedebw==''')
-
-    def test_triangle_quadratic(self):
-        ndofs, error, lhs = main(nrefine=2, btype='h-std', etype='triangle', degree=2)
-        with self.subTest('degrees of freedom'):
-            self.assertEqual(ndofs, 98)
+            self.assertAlmostEqual64(u, '''
+                eNoBMgDN/7Ed9eB+IfLboCaXNKc01DQaNXM14jXyNR82ZTa+NpI2oTbPNhU3bjf7Ngo3ODd+N9c3SNEU
+                1g==''')
         with self.subTest('L2-error'):
-            self.assertAlmostEqual(error[0], 0.00138, places=5)
-        with self.subTest('H1-error'):
-            self.assertAlmostEqual(error[1], 0.05324, places=5)
+            self.assertAlmostEqual(err, 1.63e-3, places=5)
+
+    def test_spline(self):
+        cons, u, err = main(nelems=4, btype='spline', degree=2)
+        with self.subTest('constraints'):
+            self.assertAlmostEqual64(cons, '''
+                eNqrkmN+sEfhzF0xleRbDA0wKGeCYFuaIdjK5gj2aiT2VXMAJB0VAQ==''')
         with self.subTest('left-hand side'):
-            self.assertAlmostEqual64(lhs, '''
-                eNprMV1oesqU2VTO1Nbko6myWbhpq+kckwST90avjRgYzptYm+YYMwBBk3GQWavZb1NXs2+mm83um1WY
-                bQbyXYEiQWbKZjNM7wJVzjBlYICoPW8CMiXH+LXRR9NwoPkg82xN5IB2MZu2mGabSBnnAbGscYEJj3GV
-                YQAQg/TVGfaA7RI0BsErRjeNeowDgDQPmF9gkmciaJxtArGjzrAKCGWNpYAQAL0kOBE=''')
-
-    def test_mixed_linear(self):
-        ndofs, error, lhs = main(nrefine=2, btype='h-std', etype='mixed', degree=1)
-        with self.subTest('degrees of freedom'):
-            self.assertEqual(ndofs, 34)
+            self.assertAlmostEqual64(u, '''
+                eNqrkmN+sEfhzF0xleRbrsauxsnGc43fGMuZJJgmmNaZ7jBlN7M08wLCDLNFZh/NlM0vmV0y+2CmZV5p
+                vtr8j9kfMynzEPPF5lfNAcuhGvs=''')
         with self.subTest('L2-error'):
-            self.assertAlmostEqual(error[0], 0.00450, places=5)
-        with self.subTest('H1-error'):
-            self.assertAlmostEqual(error[1], 0.11683, places=5)
+            self.assertAlmostEqual(err, 8.04e-5, places=7)
+
+    def test_mixed(self):
+        cons, u, err = main(nelems=4, etype='mixed', degree=2)
+        with self.subTest('constraints'):
+            self.assertAlmostEqual64(cons, '''
+                eNorfLZF2ucJQwMC3pR7+QDG9lCquAtj71Rlu8XQIGfC0FBoiqweE1qaMTTsNsOvRtmcoSHbHL+a1UD5
+                q+YAxhcu1g==''')
         with self.subTest('left-hand side'):
-            self.assertAlmostEqual64(lhs, '''
-                eNprMT1u6mQyxUTRzMCUAQhazL6b3jNrMYPxp5iA5FtMD+lcMgDxHa4aXzS+6HDV+fKO85cMnC8zMBzS
-                AQDBThbY''')
+            self.assertAlmostEqual64(u, '''
+                eNorfLZF2ueJq7GrcYjxDJPpJstNbsq9fOBr3Gh8xWS7iYdSxd19xseMP5hImu5UZbv1xljOxM600DTW
+                NN/0k2mC6SPTx6Z1pnNMGc3kzdaaPjRNMbMyEzWzNOsy223mBYRRZpPNJpktMks1azM7Z7bRbIXZabNX
+                ZiLmH82UzS3Ns80vmj004za/ZPYHCD+Y8ZlLmVuYq5kHm9eahwDxavPF5lfNAWFyPdk=''')
+        with self.subTest('L2-error'):
+            self.assertAlmostEqual(err, 1.25e-4, places=6)
+
+
+# If the script is executed (as opposed to imported), `nutils.cli.run` calls
+# the main function with arguments provided from the command line. For example,
+# to keep with the default arguments simply run `python3 laplace.py`. To select
+# mixed elements and quadratic basis functions add `python3 laplace.py
+# etype=mixed degree=2`.
+
+if __name__ == '__main__':
+    from nutils import cli
+    cli.run(main)
+
 
-# example:tags=hierarchical refinements,Laplace:thumbnail=0
+# example:tags=Laplace
```

### Comparing `nutils-7.3/examples/burgers.py` & `nutils-8.0/examples/burgers.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,113 +1,104 @@
-# Burgers' equation
-#
-# In this script we solve Burgers' equation on a 1D periodic domain, starting
-# from a centered Gaussian and convecting in the positive direction of the
-# first coordinate.
-
-from nutils import mesh, function, solver, export, cli, testing
+from nutils import mesh, function, solver, export, testing
 from nutils.expression_v2 import Namespace
 import treelog as log
 import numpy
 import itertools
 
 
-def main(nelems: int, btype: str, degree: int, timescale: float, newtontol: float, endtime: float):
-    '''
-    Burgers equation on a 1D or 2D periodic domain.
-
-    .. arguments::
-
-       nelems [40]
-         Number of elements along a single dimension.
-       btype [discont]
-         Type of basis function (discont/legendre).
-       degree [1]
-         Polynomial degree for discontinuous basis functions.
-       timescale [.5]
-         Fraction of timestep and element size: timestep=timescale/nelems.
-       newtontol [1e-5]
-         Newton tolerance.
-       endtime [.5]
-         Stopping time.
+def main(nelems: int = 40,
+         btype: str = 'discont',
+         degree: int = 1,
+         timescale: float = .5,
+         newtontol: float = 1e-5,
+         endtime: float = .5):
+
+    '''Burgers' equation
+
+    Solves Burgers' equation on a 1D periodic domain, starting from a centered
+    Gaussian and convecting in the positive direction of the first coordinate.
+
+    Parameters
+    ----------
+    nelems
+        Number of elements along a single dimension.
+    btype
+        Type of basis function (discont/legendre).
+    degree
+        Polynomial degree for discontinuous basis functions.
+    timescale
+        Fraction of timestep and element size: timestep=timescale/nelems.
+    newtontol
+        Newton tolerance.
+    endtime
+        Stopping time.
     '''
 
     domain, geom = mesh.line(numpy.linspace(-.5, .5, nelems+1), periodic=True)
     timestep = timescale / nelems
 
     ns = Namespace()
     ns.x = geom
     ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
-    ns.basis = domain.basis(btype, degree=degree)
-    ns.u = function.dotarg('u', ns.basis)
-    ns.u0 = function.dotarg('u0', ns.basis)
+    ns.add_field(('u', 'u0', 'v'), domain.basis(btype, degree=degree))
     ns.dt = timestep
     ns.dudt = '(u - u0) / dt'
     ns.f = '.5 u^2'
     ns.C = 1
     ns.uinit = 'exp(-25 x^2)'
 
-    res = domain.integral('(basis_n dudt - ∇(basis_n) f) dV' @ ns, degree=degree*2)
-    res -= domain.interfaces.integral('[basis_n] n ({f} - .5 C [u] n) dS' @ ns, degree=degree*2)
+    res = domain.integral('(v dudt - ∇(v) f) dV' @ ns, degree=degree*2)
+    res -= domain.interfaces.integral('[v] n ({f} - .5 C [u] n) dS' @ ns, degree=degree*2)
 
     sqr = domain.integral('(u - uinit)^2 dV' @ ns, degree=max(degree*2, 5))
-    args = solver.optimize(('u',), sqr)
+    args = solver.optimize('u,', sqr)
 
     bezier = domain.sample('bezier', 7)
     with log.iter.plain('timestep', itertools.count(step=timestep)) as times:
         for t in times:
             log.info('time:', round(t, 10))
             x, u = bezier.eval(['x', 'u'] @ ns, **args)
             export.triplot('solution.png', x[:,numpy.newaxis], u, tri=bezier.tri, hull=bezier.hull, clim=(0, 1))
             if t >= endtime:
                 break
             args['u0'] = args['u']
-            args = solver.newton(('u',), (res,), arguments=args).solve(newtontol)
+            args = solver.newton('u:v', res, arguments=args).solve(newtontol)
 
     return args
 
-# If the script is executed (as opposed to imported), :func:`nutils.cli.run`
-# calls the main function with arguments provided from the command line. For
-# example, to simulate until 0.5 seconds run :sh:`python3 burgers.py
-# endtime=0.5`.
-
-
-if __name__ == '__main__':
-    cli.run(main)
-
-# Once a simulation is developed and tested, it is good practice to save a few
-# strategic return values for regression testing. The :mod:`nutils.testing`
-# module, which builds on the standard :mod:`unittest` framework, facilitates
-# this by providing :func:`nutils.testing.TestCase.assertAlmostEqual64` for the
-# embedding of desired results as compressed base64 data.
-
 
 class test(testing.TestCase):
 
     def test_1d_p0(self):
-        args = main(nelems=10, timescale=.1, btype='discont', degree=0, endtime=.01, newtontol=1e-5)
+        args = main(nelems=10, timescale=.1, degree=0, endtime=.01)
         self.assertAlmostEqual64(args['u'], '''
             eNrz1ttqGGOiZSZlrmbuZdZgcsEwUg8AOqwFug==''')
 
     def test_1d_p1(self):
-        args = main(nelems=10, timescale=.1, btype='discont', degree=1, endtime=.01, newtontol=1e-5)
+        args = main(nelems=10, timescale=.1, degree=1, endtime=.01)
         self.assertAlmostEqual64(args['u'], '''
             eNrbocann6u3yqjTyMLUwfSw2TWzKPNM8+9mH8wyTMNNZxptMirW49ffpwYAI6cOVA==''')
 
     def test_1d_p2(self):
-        args = main(nelems=10, timescale=.1, btype='discont', degree=2, endtime=.01, newtontol=1e-5)
+        args = main(nelems=10, timescale=.1, degree=2, endtime=.01)
         self.assertAlmostEqual64(args['u'], '''
             eNrr0c7SrtWfrD/d4JHRE6Ofxj6mnqaKZofNDpjZmQeYB5pHmL8we23mb5ZvWmjKY/LV6KPRFIMZ+o36
             8dp92gCxZxZG''')
 
     def test_1d_p1_legendre(self):
-        args = main(nelems=10, timescale=.1, btype='legendre', degree=1, endtime=.01, newtontol=1e-5)
+        args = main(nelems=10, timescale=.1, btype='legendre', degree=1, endtime=.01)
         self.assertAlmostEqual64(args['u'], '''
             eNrbpbtGt9VQyNDfxMdYzczERNZczdjYnOdsoNmc01kmE870Gj49t0c36BIAAhsO1g==''')
 
     def test_1d_p2_legendre(self):
-        args = main(nelems=10, timescale=.1, btype='legendre', degree=2, endtime=.01, newtontol=1e-5)
+        args = main(nelems=10, timescale=.1, btype='legendre', degree=2, endtime=.01)
         self.assertAlmostEqual64(args['u'], '''
             eNoBPADD/8ot2y2/K4UxITFFLk00RTNNLyY2KzTTKx43QjOOzzM3Ss0pz1A2qsvhKGk0jsyXL48xzc5j
             LswtIdLIK5SlF78=''')
 
+
+if __name__ == '__main__':
+    from nutils import cli
+    cli.run(main)
+
+
 # example:tags=Burgers' equation,discontinuous Galerkin
```

### Comparing `nutils-7.3/examples/cahnhilliard.py` & `nutils-8.0/examples/cahnhilliard.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,271 +1,272 @@
-# Unmixing of immiscible fluids
-#
-# In this script we solve the Cahn-Hilliard equation, which models the unmixing
-# of two phases (`φ=+1` and `φ=-1`) under the influence of surface tension. It
-# is a mixed equation of two scalar equations for phase `φ` and chemical
-# potential `η`:
-#
-#     dφ/dt = -div(J(η))
-#     η = ψ'(φ) σ / ε - σ ε Δ(φ)
-#
-# along with constitutive relations for the flux vector `J = -M ∇η` and the
-# double well potential `ψ = .25 (φ² - 1)²`, and subject to boundary conditions
-# `∂ₙφ = -σd / σ ε` and `∂ₙη = 0`. Parameters are the interface thickness `ε`,
-# fluid surface tension `σ`, differential wall surface tension `σd`, and
-# mobility `M`.
-#
-# Cahn-Hilliard is a diffuse interface model, which means that phases do not
-# separate sharply, but instead form a transition zone between the phases. The
-# transition zone has a thickness proportional to `ε`, as is readily confirmed
-# in one dimension, where a steady state solution on an infinite domain is
-# formed by `η(x) = 0`, `φ(x) = tanh(x / √2 ε)`.
-#
-# The main driver of the unmixing process is the double well potential `ψ` that
-# is proportional to the mixing energy, taking its minima at the pure phases
-# `φ=+1` and `φ=-1`. The interface between the phases adds an energy
-# contribution proportional to its length. At the wall we have a
-# phase-dependent fluid-solid energy. Over time, the system minimizes the total
-# energy:
-#
-#     E(φ) := ∫_Ω ψ(φ) σ / ε + ∫_Ω .5 σ ε ‖∇φ‖² + ∫_Γ (σm + φ σd)
-#             \                \                  \
-#              mixing energy    interface energy   wall energy
-#
-# Proof: the time derivative of `E` followed by substitution of the strong form
-# and boundary conditions yields `dE/dt = ∫_Ω η dφ/dt = -∫_Ω M ‖∇η‖² ≤ 0`. □
-#
-# Switching to discrete time we set `dφ/dt = (φ - φ0) / dt` and add a
-# stabilizing perturbation term `δψ(φ, φ0)` to the doube well potential for
-# reasons outlined below. This yields the following time discrete system:
-#
-#     φ = φ0 - dt div(J(η))
-#     η = (ψ'(φ) + δψ'(φ, φ0)) σ / ε - σ ε Δ(φ)
-#
-# For stability we wish for the perturbation `δψ` to be such that the time
-# discrete system preserves the energy dissipation property `E(φ) ≤ E(φ0)` for
-# any timestep `dt`. To derive suitable perturbation terms to this effect, we
-# define without loss of generality `δψ'(φ, φ0) = .5 (φ - φ0) f(φ, φ0)` and
-# derive the following condition for unconditional stability:
-#
-#     E(φ) - E(φ0) = ∫_Ω .5 (1 - φ² - .5 (φ + φ0)² - f(φ, φ0)) (φ - φ0)² σ / ε
-#                  - ∫_Ω (.5 σ ε ‖∇φ - ∇φ0‖² + dt M ‖∇η‖²) ≤ 0
-#
-# The inequality holds true if the perturbation `f` is bounded from below such
-# that `f(φ, φ0) ≥ 1 - φ² - .5 (φ + φ0)²`. To keep the energy minima at the
-# pure phases we additionally impose that `f(±1, φ0) = 0`, and select `1 - φ²`
-# as a suitable upper bound which we will call "nonlinear".
-#
-# We next observe that `η` is linear in `φ` if `f(φ, φ0) = g(φ0) - φ² - (φ +
-# φ0)²` for any function `g`, which dominates if `g(φ0) ≥ 1 + .5 (φ + φ0)²`.
-# While this cannot be made to hold true for all `φ`, we make it hold for `-√2
-# ≤ φ, φ0 ≤ √2` by defining `g(φ0) = 2 + 2 |φ0| + φ0²`, which we will call
-# "linear". This scheme further satisfies a weak minima preservation `f(±1,
-# ±|φ0|) = 0`.
-#
-# We have thus arrived at the three stabilization schemes implemented here:
-#
-# - nonlinear: `f(φ, φ0) = 1 - φ²`
-# - linear: `f(φ, φ0) = 2 + 2 |φ0| - 2 φ (φ + φ0)`
-# - none: `f(φ, φ0) = 0` (not unconditionally stable)
-#
-# Finally, we observe that the weak formulation:
-#
-#     ∀ δη: ∫_Ω [ dt J(η)·∇δη - δη (φ - φ0) ] = 0
-#     ∀ δφ: ∫_Ω [ δφ (ψ'(φ) + δψ'(φ, φ0)) σ / ε + σ ε ∇(δφ)·∇(φ) ] = ∫_Γ -δφ σd
-#
-# is equivalent to the optimization problem `∂F/∂φ = ∂F/∂η = 0`, where
-#
-#     F(φ, φ0, η) := E(φ) + ∫_Ω [ .5 dt J(η)·∇η + δψ(φ, φ0) σ / ε - η (φ - φ0) ]
-#
-# For this reason, the `stab` enum in this script defines the stabilizing term
-# `δψ`, rather than `f`, allowing Nutils to construct the residuals through
-# automatic differentiation using the `optimize` method.
-#
-# NOTE: This script uses dimensional quantities and requires the nutils.SI
-# module, which is installed separate from the the core nutils.
-
-from nutils import mesh, function, solver, numeric, export, cli, testing
+from nutils import mesh, function, solver, numeric, export, testing
 from nutils.expression_v2 import Namespace
 from nutils.SI import Length, Time, Density, Tension, Energy, Pressure, Velocity, parse
 import numpy
 import itertools
 import enum
 import treelog as log
 
+# NOTE: This script uses dimensional quantities and requires the nutils.SI
+# module, which is installed separate from the the core nutils.
+
 
 class stab(enum.Enum):
     nonlinear = '.25 dφ^2 (1 - φ^2 + φ dφ (2 / 3) - dφ^2 / 6)'
     linear = '.25 dφ^2 (2 + 2 abs(φ0) - (φ + φ0)^2)'
-    none = '0'  # not unconditionally stable
+    none = '0' # not unconditionally stable
 
 
-def main(size: Length, epsilon: Length, mobility: Time/Density, stens: Tension,
-         wtensn: Tension, wtensp: Tension, nelems: int, etype: str, degree: int,
-         timestep: Time, tol: Energy/Length, endtime: Time, seed: int, circle: bool,
-         stab: stab, showflux: bool):
-    '''
-    Cahn-Hilliard equation on a unit square/circle.
-
-    .. arguments::
-
-       size [10cm]
-         Domain size.
-       epsilon [1mm]
-         Interface thickness; defaults to an automatic value based on the
-         configured mesh density if left unspecified.
-       mobility [1mL*s/kg]
-         Mobility.
-       stens [50mN/m]
-         Surface tension.
-       wtensn [30mN/m]
-         Wall surface tension for phase -1.
-       wtensp [20mN/m]
-         Wall surface tension for phase +1.
-       nelems [0]
-         Number of elements along domain edge. When set to zero a value is set
-         automatically based on the configured domain size and epsilon.
-       etype [square]
-         Type of elements (square/triangle/mixed).
-       degree [1]
-         Polynomial degree.
-       timestep [.5s]
-         Time step.
-       tol [1nJ/m]
-         Newton tolerance.
-       endtime [1min]
-         End of the simulation.
-       seed [0]
-         Random seed for the initial condition.
-       circle [yes]
-         Select circular domain as opposed to a unit square.
-       stab [linear]
-         Stabilization method (linear/nonlinear/none).
-       showflux [yes]
-         Overlay flux vectors on phase plot
+def main(size: Length = parse('10cm'),
+         epsilon: Length = parse('1mm'),
+         mobility: Time/Density = parse('1mL*s/kg'),
+         stens: Tension = parse('50mN/m'),
+         wtensn: Tension = parse('30mN/m'),
+         wtensp: Tension = parse('20mN/m'),
+         nelems: int = 0,
+         etype: str = 'rectilinear',
+         degree: int = 1,
+         timestep: Time = parse('.5s'),
+         tol: Energy/Length = parse('1nJ/m'),
+         endtime: Time = parse('1min'),
+         seed: int = 0,
+         circle: bool = True,
+         stab: stab = stab.linear,
+         showflux: bool = True):
+
+    '''Unmixing of immiscible fluids
+
+    Solves the Cahn-Hilliard equation, which models the unmixing of two phases
+    (`φ=+1` and `φ=-1`) under the influence of surface tension. It is a mixed
+    equation of two scalar equations for phase `φ` and chemical potential `η`:
+
+        dφ/dt = -div(J(η))
+        η = ψ'(φ) σ / ε - σ ε Δ(φ)
+
+    along with constitutive relations for the flux vector `J = -M ∇η` and the
+    double well potential `ψ = .25 (φ² - 1)²`, and subject to boundary conditions
+    `∂ₙφ = -σd / σ ε` and `∂ₙη = 0`. Parameters are the interface thickness `ε`,
+    fluid surface tension `σ`, differential wall surface tension `σd`, and
+    mobility `M`.
+
+    Cahn-Hilliard is a diffuse interface model, which means that phases do not
+    separate sharply, but instead form a transition zone between the phases. The
+    transition zone has a thickness proportional to `ε`, as is readily confirmed
+    in one dimension, where a steady state solution on an infinite domain is
+    formed by `η(x) = 0`, `φ(x) = tanh(x / √2 ε)`.
+
+    The main driver of the unmixing process is the double well potential `ψ` that
+    is proportional to the mixing energy, taking its minima at the pure phases
+    `φ=+1` and `φ=-1`. The interface between the phases adds an energy
+    contribution proportional to its length. At the wall we have a
+    phase-dependent fluid-solid energy. Over time, the system minimizes the total
+    energy:
+
+        E(φ) := ∫_Ω ψ(φ) σ / ε + ∫_Ω .5 σ ε ‖∇φ‖² + ∫_Γ (σm + φ σd)
+                \                \                  \ 
+                 mixing energy    interface energy   wall energy
+
+    Proof: the time derivative of `E` followed by substitution of the strong form
+    and boundary conditions yields `dE/dt = ∫_Ω η dφ/dt = -∫_Ω M ‖∇η‖² ≤ 0`. □
+
+    Switching to discrete time we set `dφ/dt = (φ - φ0) / dt` and add a
+    stabilizing perturbation term `δψ(φ, φ0)` to the double well potential for
+    reasons outlined below. This yields the following time discrete system:
+
+        φ = φ0 - dt div(J(η))
+        η = (ψ'(φ) + δψ'(φ, φ0)) σ / ε - σ ε Δ(φ)
+
+    For stability we wish for the perturbation `δψ` to be such that the time
+    discrete system preserves the energy dissipation property `E(φ) ≤ E(φ0)` for
+    any timestep `dt`. To derive suitable perturbation terms to this effect, we
+    define without loss of generality `δψ'(φ, φ0) = .5 (φ - φ0) f(φ, φ0)` and
+    derive the following condition for unconditional stability:
+
+        E(φ) - E(φ0) = ∫_Ω .5 (1 - φ² - .5 (φ + φ0)² - f(φ, φ0)) (φ - φ0)² σ / ε
+                     - ∫_Ω (.5 σ ε ‖∇φ - ∇φ0‖² + dt M ‖∇η‖²) ≤ 0
+
+    The inequality holds true if the perturbation `f` is bounded from below such
+    that `f(φ, φ0) ≥ 1 - φ² - .5 (φ + φ0)²`. To keep the energy minima at the
+    pure phases we additionally impose that `f(±1, φ0) = 0`, and select `1 - φ²`
+    as a suitable upper bound which we will call "nonlinear".
+
+    We next observe that `η` is linear in `φ` if `f(φ, φ0) = g(φ0) - φ² - (φ +
+    φ0)²` for any function `g`, which dominates if `g(φ0) ≥ 1 + .5 (φ + φ0)²`.
+    While this cannot be made to hold true for all `φ`, we make it hold for `-√2
+    ≤ φ, φ0 ≤ √2` by defining `g(φ0) = 2 + 2 |φ0| + φ0²`, which we will call
+    "linear". This scheme further satisfies a weak minima preservation `f(±1,
+    ±|φ0|) = 0`.
+
+    We have thus arrived at the three stabilization schemes implemented here:
+
+    - nonlinear: `f(φ, φ0) = 1 - φ²`
+    - linear: `f(φ, φ0) = 2 + 2 |φ0| - 2 φ (φ + φ0)`
+    - none: `f(φ, φ0) = 0` (not unconditionally stable)
+
+    Finally, we observe that the weak formulation:
+
+        ∀ δη: ∫_Ω [ dt J(η)·∇δη - δη (φ - φ0) ] = 0
+        ∀ δφ: ∫_Ω [ δφ (ψ'(φ) + δψ'(φ, φ0)) σ / ε + σ ε ∇(δφ)·∇(φ) ] = ∫_Γ -δφ σd
+
+    is equivalent to the optimization problem `∂F/∂φ = ∂F/∂η = 0`, where
+
+        F(φ, φ0, η) := E(φ) + ∫_Ω [ .5 dt J(η)·∇η + δψ(φ, φ0) σ / ε - η (φ - φ0) ]
+
+    For this reason, the `stab` enum in this script defines the stabilizing term
+    `δψ`, rather than `f`, allowing Nutils to construct the residuals through
+    automatic differentiation using the `optimize` method.
+
+    Parameters
+    ----------
+    size
+        Domain size.
+    epsilon
+        Interface thickness; defaults to an automatic value based on the
+        configured mesh density if left unspecified.
+    mobility
+        Mobility.
+    stens
+        Surface tension.
+    wtensn
+        Wall surface tension for phase -1.
+    wtensp
+        Wall surface tension for phase +1.
+    nelems
+        Number of elements along domain edge. When set to zero a value is set
+        automatically based on the configured domain size and epsilon.
+    etype
+        Type of elements (square/triangle/mixed).
+    degree
+        Polynomial degree.
+    timestep
+        Time step.
+    tol
+        Newton tolerance.
+    endtime
+        End of the simulation.
+    seed
+        Random seed for the initial condition.
+    circle
+        Select circular domain as opposed to a unit square.
+    stab
+        Stabilization method (linear/nonlinear/none).
+    showflux
+        Overlay flux vectors on phase plot
     '''
 
     nmin = round(size / epsilon)
     if nelems <= 0:
         nelems = nmin
         log.info('setting nelems to {}'.format(nelems))
     elif nelems < nmin:
         log.warning('mesh is too coarse, consider increasing nelems to {:.0f}'.format(nmin))
 
     log.info('contact angle: {:.0f}°'.format(numpy.arccos((wtensn - wtensp) / stens) * 180 / numpy.pi))
 
-    domain, geom = mesh.unitsquare(nelems, etype)
     if circle:
-        angle = (geom-.5) * (numpy.pi/2)
-        geom = .5 + function.sin(angle) * function.cos(angle)[[1, 0]] / numpy.sqrt(2)
+        domain, geom = mesh.unitcircle(nelems, etype)
+        geom = (geom + 1) / 2
+    else:
+        domain, geom = mesh.unitsquare(nelems, etype)
 
+    basis = domain.basis('std', degree=degree)
     bezier = domain.sample('bezier', 5)  # sample for surface plots
     if showflux:
         grid = domain.locate(geom, numeric.simplex_grid([1, 1], 1/40), maxdist=1/nelems, skip_missing=True, tol=1e-5)  # sample for quivers
 
-    φbasis = ηbasis = domain.basis('std', degree=degree)
-    ηbasis *= stens / epsilon  # basis scaling to give η the required unit
-
     ns = Namespace()
     ns.x = size * geom
     ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
+    ns.add_field(('φ', 'φ0'), basis)
+    ns.add_field('η', basis * stens / epsilon) # basis scaling to give η the required unit
     ns.ε = epsilon
     ns.σ = stens
-    ns.φ = function.dotarg('φ', φbasis)
     ns.σmean = (wtensp + wtensn) / 2
     ns.σdiff = (wtensp - wtensn) / 2
     ns.σwall = 'σmean + φ σdiff'
-    ns.φ0 = function.dotarg('φ0', φbasis)
     ns.dφ = 'φ - φ0'
-    ns.η = function.dotarg('η', ηbasis)
     ns.ψ = '.25 (φ^2 - 1)^2'
     ns.δψ = stab.value
     ns.M = mobility
     ns.J_i = '-M ∇_i(η)'
     ns.dt = timestep
 
     nrg_mix = domain.integral('(ψ σ / ε) dV' @ ns, degree=degree*4)
     nrg_iface = domain.integral('.5 σ ε ∇_k(φ) ∇_k(φ) dV' @ ns, degree=degree*4)
     nrg_wall = domain.boundary.integral('σwall dS' @ ns, degree=degree*2)
     nrg = nrg_mix + nrg_iface + nrg_wall + domain.integral('(δψ σ / ε - η dφ + .5 dt J_k ∇_k(η)) dV' @ ns, degree=degree*4)
 
     numpy.random.seed(seed)
-    state = dict(φ=numpy.random.normal(0, .5, φbasis.shape))  # initial condition
+    args = dict(φ=numpy.random.normal(0, .5, basis.shape)) # initial condition
 
     with log.iter.fraction('timestep', range(round(endtime / timestep))) as steps:
         for istep in steps:
 
-            E = numpy.stack(function.eval([nrg_mix, nrg_iface, nrg_wall], **state))
+            E = numpy.stack(function.eval([nrg_mix, nrg_iface, nrg_wall], **args))
             log.user('energy: {0:,.0μJ/m} ({1[0]:.0f}% mixture, {1[1]:.0f}% interface, {1[2]:.0f}% wall)'.format(numpy.sum(E), 100*E/numpy.sum(E)))
 
-            state['φ0'] = state['φ']
-            state = solver.optimize(['φ', 'η'], nrg / tol, arguments=state, tol=1)
+            args['φ0'] = args['φ']
+            args = solver.optimize(['φ', 'η'], nrg / tol, arguments=args, tol=1)
 
             with export.mplfigure('phase.png') as fig:
                 ax = fig.add_subplot(aspect='equal', xlabel='[mm]', ylabel='[mm]')
-                x, φ = bezier.eval(['x_i', 'φ'] @ ns, **state)
+                x, φ = bezier.eval(['x_i', 'φ'] @ ns, **args)
                 im = ax.tripcolor(*(x/'mm').T, bezier.tri, φ, shading='gouraud', cmap='coolwarm')
                 im.set_clim(-1, 1)
                 fig.colorbar(im)
                 if showflux:
-                    x, v = grid.eval(['x_i', 'φ J_i'] @ ns, **state)
+                    x, v = grid.eval(['x_i', 'φ J_i'] @ ns, **args)
                     log.info('largest flux: {:.2mm/s}'.format(numpy.max(numpy.hypot(v[:, 0], v[:, 1]))))
                     ax.quiver(*(x/'mm').T, *(v/'m/s').T)
                 ax.autoscale(enable=True, axis='both', tight=True)
 
-    return state
-
-# If the script is executed (as opposed to imported), :func:`nutils.cli.run`
-# calls the main function with arguments provided from the command line.
-
-
-if __name__ == '__main__':
-    cli.run(main)
-
-# Once a simulation is developed and tested, it is good practice to save a few
-# strategic return values for regression testing. The :mod:`nutils.testing`
-# module, which builds on the standard :mod:`unittest` framework, facilitates
-# this by providing :func:`nutils.testing.TestCase.assertAlmostEqual64` for the
-# embedding of desired results as compressed base64 data.
+    return args
 
 
 class test(testing.TestCase):
 
     def test_initial(self):
-        state = main(size=parse('10cm'), epsilon=parse('5cm'), mobility=parse('1μL*s/kg'),
-                     stens=parse('50mN/m'), wtensn=parse('30mN/m'), wtensp=parse('20mN/m'), nelems=3,
-                     etype='square', degree=2, timestep=parse('1h'), tol=parse('1nJ/m'),
-                     endtime=parse('1h'), seed=0, circle=False, stab=stab.linear, showflux=True)
+        args = main(epsilon=parse('5cm'), mobility=parse('1μL*s/kg'), nelems=3, degree=2, timestep=parse('1h'), endtime=parse('1h'), circle=False)
         with self.subTest('concentration'):
-            self.assertAlmostEqual64(state['φ0'], '''
+            self.assertAlmostEqual64(args['φ0'], '''
                 eNoBYgCd/xM3LjTtNYs3MDcUyt41uc14zjo0LzKzNm812jFhNNMzwDYgzbMzV8o0yCM1rzWeypE3Tcnx
                 L07NzTa4NlMyETREyrPIGMxYMl82VDbjy1/M8clZyf3IRjday6XLmMl6NRnJMF4tqQ==''')
 
     def test_square(self):
-        state = main(size=parse('10cm'), epsilon=parse('5cm'), mobility=parse('1μL*s/kg'),
-                     stens=parse('50mN/m'), wtensn=parse('30mN/m'), wtensp=parse('20mN/m'), nelems=3,
-                     etype='square', degree=2, timestep=parse('1h'), tol=parse('1nJ/m'),
-                     endtime=parse('2h'), seed=0, circle=False, stab=stab.linear, showflux=True)
+        args = main(epsilon=parse('5cm'), mobility=parse('1μL*s/kg'), nelems=3, degree=2, timestep=parse('1h'), endtime=parse('2h'), circle=False)
         with self.subTest('concentration'):
-            self.assertAlmostEqual64(state['φ'], '''
+            self.assertAlmostEqual64(args['φ'], '''
                 eNoBYgCd/zE1EjX1NaA2+TXiMxkz0TS9NL01ajaRNZoxYNElNRM1LDUlNZQw0cqgysI1nTWcNN4xLsuk
                 ybDJvDWaNTQ07s7nysnJ6ckPNQY1CzNozKjK58kOysQ0zTQKM73M3coVyjfKR9cuPg==''')
         with self.subTest('chemical-potential'):
-            self.assertAlmostEqual64(state['η'], '''
+            self.assertAlmostEqual64(args['η'], '''
                 eNoBYgCd/3TIkccBNkQ6IDqIN4HMF8cSx9Y02DmdOVHLMcecxxLIEjQUOAHOa8a1xWw3izb1M9kzPMc0
                 xmnGpzibODY359ETyJHHp8hbyWU2xzZSydfIOsrNyo3GjMjAyyXIm8hkzD3K1ggxvA==''')
 
-    def test_mixedcircle(self):
-        state = main(size=parse('10cm'), epsilon=parse('5cm'), mobility=parse('1μL*s/kg'),
-                     stens=parse('50mN/m'), wtensn=parse('30mN/m'), wtensp=parse('20mN/m'), nelems=3,
-                     etype='mixed', degree=2, timestep=parse('1h'), tol=parse('1nJ/m'),
-                     endtime=parse('2h'), seed=0, circle=True, stab=stab.linear, showflux=True)
+    def test_multipatchcircle(self):
+        args = main(epsilon=parse('5cm'), mobility=parse('1μL*s/kg'), nelems=3, etype='multipatch', degree=2, timestep=parse('1h'), endtime=parse('2h'))
         with self.subTest('concentration'):
-            self.assertAlmostEqual64(state['φ'], '''
-                eNoBYgCd/ww1AzX+NAw1ITXTNMw0iTRPNDI1vDQcNTk0uzJ9NFM0HS4P0SbMcssOy0wzZjNv0b0zlzHI
-                z6U0ps8zM/LPjspVypDKUsuHzk/Mf83PzYfN78/81KfP2zH4MADNhst3z7DMnycvxQ==''')
+            self.assertAlmostEqual64(args['φ'], '''
+                eNoNyE9Ik3EYB3BwZohodpCSIk9NQub7/n7PA5IHu7Y6xKBbgUQK0mGUMIS6jIgmJRZitc3MEi/VxQVz
+                XsouDcHn+7w///B22HYU/wTBOuwUmcfPp8Yhr/JfrnOJJ3iU2/g1X+YHXKMcrdnvVLYt9NwMmlTfBn2g
+                ZhL71OZMl214H72yu+6KmtFdpPxFbzjcu3Rl59rmafdMe1xVS7iFdk2jKdjRcb0JHxGQhriDs/oeoRTk
+                SMoyiJN4JVl5I7OSdLeDqJ6y2ybtj6Ahb8NDXTr+PLpRoEWy9If2qUCz9oV/n+ZsJajil9/hcvyS77JS
+                iSbJcJEStGxbqWC+mHp/zc7bIdttV82cv2aS/ufYuOurLATr2qPzXjX2wx3qCZ1AHMbNBBVd8rZiDXdD
+                v+FM0KEJdGIEXfhtHppJ7ypdpEf2yGV0zER60ziPBc2ik/9Rltpp2tituCb6c8G5YBcHGEAU21KUKXmC
+                ZlzAT3knjyUvn+SefJVNWTl2TXrxHyMaybw=''')
         with self.subTest('chemical-potential'):
-            self.assertAlmostEqual64(state['η'], '''
-                eNoBYgCd/+c1DcppztM3eTYHyZk4ZjVjyfA2AzdGMj032zfLNTE4fMm7yLnGisbqxZTJ2MsfyEA1csiv
-                x+E5xDhjOJA3msZ1xZTFa8dcx/fG8seCx7zH1MihM/c0WDiqMUnLvMYZNpvIqqQ0tQ==''')
+            self.assertAlmostEqual64(args['η'], '''
+                eNoBggF9/lU4VTgzOIo4kDhIOCY3Lzd5Ngw4xjf1N1o3YzV70II3ijZoNuIyZcpFybM1jjXxzgY28TVH
+                zyLKzMjGyXfICsjfx73Hl8dyMzozgstEylLKFsqEyU3I2snuyJvHZMc7yLzHKctJy6rKqci4yGDIrcqK
+                yvLID8royADInMcIyJ7HI8jnx13HcMdax2fHWNPez6/JHzZENjI1V8jHx7AxHMpqx2PHpMgAyDk4SDgR
+                OH84gThhONA3ejY/OJw3Y84NyYY2C8x1NqU2BjfJyQTKYC9rN303ATZmNnY3TTaMNmI0e8mFyf3KKjYz
+                Nj80DDD+Mn3MhsqCM/bLsslNyRo3BzcuNUbLEMk7yDfI0snXyWjJu817zdTK+8hRyLPJt8jYx4/HEMiy
+                x5wzXTNbzP02CTdQNmLKFslCNc7MRcjSx5DJZ8hiOG04JDjJN4020jBZySIwQsvxyJDInMlnyCzIxMes
+                x3DHmMeAx1fHVMdfx0vHS8dsxzzHl8csxz3HSceixxfIfsLEFg==''')
+
+
+if __name__ == '__main__':
+    from nutils import cli
+    cli.run(main)
+
 
 # example:tags=Cahn-Hilliard
```

### Comparing `nutils-7.3/examples/coil.py` & `nutils-8.0/examples/coil.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,54 +1,76 @@
-# Current-induced magnetic field
-#
-# In this script we compute the magnetic field induced by a DC or AC current in
-# one or several toroidal conductors. This problem is modeled with the
-# quasi-static [magnetic vector potential][1] with Lorenz gauge:
-#
-#     ∇_j(∇_j(A_i)) = -μ0 J_i
-#
-# where `A` is the magnetic vector potential, `J` the current density and `μ0`
-# the magnetic permeability. The magnetic field `B` is then given by the curl
-# of the magnetic vector potential. The current density is the sum of an
-# external current `Jext` and the current induced by the magnetic field,
-# `Jind`. The external current is given by
-#
-#     Jext_i = (I / π rwire²) cos(ω t) eθ_i
-#
-# inside the conductor and zero everywhere else, where `ω = 2 π f`. The induced
-# current follows from [Faraday's law of induction][2] and [Ohm's law][3]:
-#
-#     Jind_i = -σ ∂_t(A_i)
-#
-# where `σ` is the conductivity, which is non-zero only inside the conductor.
-#
-# We can solve the temporal component of `A` by letting `A_i = Re(Â_i exp(j ω
-# t))`. This problem in terms of `Â` is:
-#
-#     ∇_j(∇_j(Â_i) = -μ0 Ĵ_i
-#
-# with
-#
-#     Ĵext_i = (I / π rwire²) eθ_i
-#
-# and
-#
-#     Ĵind_i = -j ω σ Â_i
-#
-# [1]: https://en.wikipedia.org/wiki/Magnetic_vector_potential
-# [2]: https://en.wikipedia.org/wiki/Faraday%27s_law_of_induction
-# [3]: https://en.wikipedia.org/wiki/Ohm%27s_law
-
-from nutils import cli, export, function, mesh, solver, testing
+from nutils import export, function, mesh, solver, testing
 from nutils.expression_v2 import Namespace
 import functools
 import numpy
 
 
-def main(nelems: int = 50, degree: int = 3, freq: float = 0., nturns: int = 1, rwire: float = .0025, rcoil: float = 0.025):
+def main(nelems: int = 50,
+         degree: int = 3,
+         freq: float = 0.,
+         rwire: float = .0025,
+         rcoil: float = 0.025,
+         nturns: int = 1):
+
+    '''Current-induced magnetic field
+
+    Computes the magnetic field induced by a DC or AC current in one or several
+    toroidal conductors. This problem is modeled with the quasi-static
+    [magnetic vector potential][1] with Lorenz gauge:
+
+        ∇_j(∇_j(A_i)) = -μ0 J_i
+
+    where `A` is the magnetic vector potential, `J` the current density and `μ0`
+    the magnetic permeability. The magnetic field `B` is then given by the curl
+    of the magnetic vector potential. The current density is the sum of an
+    external current `Jext` and the current induced by the magnetic field,
+    `Jind`. The external current is given by
+
+        Jext_i = (I / π rwire²) cos(ω t) eθ_i
+
+    inside the conductor and zero everywhere else, where `ω = 2 π f`. The induced
+    current follows from [Faraday's law of induction][2] and [Ohm's law][3]:
+
+        Jind_i = -σ ∂_t(A_i)
+
+    where `σ` is the conductivity, which is non-zero only inside the conductor.
+
+    We can solve the temporal component of `A` by letting `A_i = Re(Â_i exp(j ω
+    t))`. This problem in terms of `Â` is:
+
+        ∇_j(∇_j(Â_i) = -μ0 Ĵ_i
+
+    with
+
+        Ĵext_i = (I / π rwire²) eθ_i
+
+    and
+
+        Ĵind_i = -j ω σ Â_i
+
+    [1]: https://en.wikipedia.org/wiki/Magnetic_vector_potential
+    [2]: https://en.wikipedia.org/wiki/Faraday%27s_law_of_induction
+    [3]: https://en.wikipedia.org/wiki/Ohm%27s_law
+
+    Parameters
+    ----------
+    nelems
+        Number of elements per spatial dimension.
+    degree
+        Polynomial degree of discretized magnetic vector potential.
+    freq
+        Alternating current frequency; a value of 0 corresponds to direct
+        current.
+    rwire
+        Radius of the wire.
+    rcoil
+        Radius of the coil, must be larger than `rwire`.
+    nturns
+        Number of windings in the coil, spaced by a distance of `4 rwire`.
+    '''
 
     ns = Namespace()
     ns.j = 1j
     ns.π = numpy.pi
     ns.f = freq
     ns.ω = '2 π f'
     ns.μ0 = '4e-7 π'  # magnetic permeability in vacuum
@@ -69,57 +91,51 @@
     ns.rz = numpy.arctanh(ns.rz0) * 2 * rcoil
     ns.r, ns.z = ns.rz
 
     # Trimming of the wires. The centers of the wires are located at
     # `rcoil,zwires`.
 
     ns.zwires = (numpy.arange(nturns) - (nturns - 1) / 2) * 4 * rwire
-    ns.dwires = ns.rwire - numpy.sqrt((ns.r - ns.rcoil)**2 + functools.reduce(function.min, (ns.z - ns.zwires)**2))
+    ns.dwires = ns.rwire - numpy.sqrt((ns.r - ns.rcoil)**2 + functools.reduce(numpy.minimum, (ns.z - ns.zwires)**2))
     RZ = RZ.withsubdomain(coil=RZ[:-1, :-1].trim(ns.dwires/ns.rwire, maxrefine=4))
 
-    ns.rot = function.stack([function.scatter(function.trignormal(ns.θ), 3, [0, 1]), function.kronecker(1., 0, 3, 2)])
-    ns.eθ = function.stack(['-sin(θ)', 'cos(θ)', '0'] @ ns)
+    ns.rot = numpy.stack([function.scatter(function.trignormal(ns.θ), 3, [0, 1]), function.kronecker(1., 0, 3, 2)])
+    ns.eθ = numpy.stack(['-sin(θ)', 'cos(θ)', '0'] @ ns)
 
     X = RZ * REV
-    #ns.x = function.stack(['r cos(θ)', 'r sin(θ)', 'z'] @ ns)
     ns.x = ns.rz @ ns.rot
     ns.define_for('x', gradient='∇', jacobians=('dV', 'dS'), curl='curl')
-
-    ns.basis = RZ.basis('spline', degree=degree, removedofs=[[0, -1], [-1]])
-    ns.A = function.dotarg('A', ns.basis, dtype=complex) * ns.eθ
-    ns.Atest = function.dotarg('Atest', ns.basis, dtype=float) * ns.eθ
+    ns.add_field(('A', 'Atest'), RZ.basis('spline', degree=degree, removedofs=[[0, -1], [-1]])[:,numpy.newaxis] * ns.eθ, dtype=complex)
     ns.B_i = 'curl_ij(A_j)'
     ns.E_i = '-j ω A_i'
     ns.Jind_i = 'σ E_i'
     ns.I = 1
     ns.Jext_i = 'eθ_i I / π rwire^2'
     ns.J_i = 'Jext_i + Jind_i'
 
     res = REV.integral(RZ.integral('-∇_j(Atest_i) ∇_j(A_i) dV' @ ns, degree=2*degree), degree=0)
     res += REV.integral(RZ['coil'].integral('μ0 Atest_i J_i dV' @ ns, degree=2*degree), degree=0)
 
-    state = solver.solve_linear(('A',), (res.derivative('Atest'),))
+    args = solver.solve_linear('A:Atest,', res)
 
     # Since the coordinate transformation is singular at r=0 we can't evaluate
     # `B` (the curl of `A`) at r=0. We circumvent this problem by projecting `B`
     # on a basis.
 
     ns.Borig = ns.B
-    ns.Bbasis = RZ.basis('spline', degree=degree)
-    ns.B = function.dotarg('B', ns.Bbasis, dtype=complex, shape=(2,)) @ ns.rot
-    ns.Btest = function.dotarg('Btest', ns.Bbasis, shape=(2,)) @ ns.rot
+    ns.add_field(('B', 'Btest'), RZ.basis('spline', degree=degree), ns.rot, dtype=complex)
     res = REV.integral(RZ.integral('Btest_i (B_i - Borig_i) dV' @ ns, degree=2*degree), degree=0)
-    state = solver.solve_linear(('B',), (res.derivative('Btest'),), arguments=state)
+    args = solver.solve_linear('B:Btest,', res, arguments=args)
 
     with export.mplfigure('magnetic-potential-1.png', dpi=300) as fig:
         ax = fig.add_subplot(111, aspect='equal', xlabel='$x_0$', ylabel='$x_2$', adjustable='datalim')
         # Magnetic vector potential. `r < 0` is the imaginary part, `r > 0` the
         # real part.
         smpl = REV0 * RZ[:-1, :-1].sample('bezier', 5)
-        r, z, A, Bmag = smpl.eval(['r', 'z', 'A_1', 'sqrt(real(B_i) real(B_i)) + sqrt(imag(B_i) imag(B_i)) j'] @ ns, **state)
+        r, z, A, Bmag = smpl.eval(['r', 'z', 'A_1', 'sqrt(real(B_i) real(B_i)) + sqrt(imag(B_i) imag(B_i)) j'] @ ns, **args)
         Amax = abs(A).max()
         Bmax = abs(Bmag).max()
         levels = numpy.linspace(-Amax, Amax, 32)[1:-1]
         r = numpy.concatenate([r, r], axis=0)
         z = numpy.concatenate([z, -z], axis=0)
         A = numpy.concatenate([A, A], axis=0)
         Bmag = numpy.concatenate([Bmag, Bmag], axis=0)
@@ -130,15 +146,15 @@
         ax.tricontour(-r, z, tri, -A.imag, colors='k', linewidths=.5, levels=levels)
         imBr = ax.tripcolor(r, z, tri, Bmag.real, shading='gouraud', cmap='Greens')
         imBr.set_clim(0, Bmax)
         ax.tricontour(r, z, tri, A.real, colors='k', linewidths=.5, levels=levels)
         # Current density (wires only). `r < 0` is the imaginary part, `r > 0` the
         # real part.
         smpl = REV0 * RZ['coil'].sample('bezier', 5)
-        r, z, J = smpl.eval(['r', 'z', 'J_1'] @ ns, **state)
+        r, z, J = smpl.eval(['r', 'z', 'J_1'] @ ns, **args)
         Jmax = abs(J).max()
         r = numpy.concatenate([r, r], axis=0)
         z = numpy.concatenate([z, -z], axis=0)
         J = numpy.concatenate([J, J], axis=0)
         tri = numpy.concatenate([smpl.tri+i*smpl.npoints for i in range(2)])
         imJi = ax.tripcolor(-r, z, tri, -J.imag, shading='gouraud', cmap='bwr')
         imJi.set_clim(-Jmax, Jmax)
@@ -161,58 +177,60 @@
         fig.colorbar(imBr, label='$|B|$')
 
     if freq == 0:
         ns.δ = function.eye(3)
         # Reference: https://physics.stackexchange.com/a/355183
         ns.Bexact = ns.δ[2] * ns.μ0 * ns.I * ns.rcoil**2 / 2 * ((ns.rcoil**2 + (ns.z - ns.zwires)**2)**(-3/2)).sum()
         smpl = REV0 * RZ[:-1, :-1].boundary['left'].sample('bezier', 5)
-        B, Bexact, z = smpl.eval(['real(B_2)', 'Bexact_2', 'z'] @ ns, **state)
+        B, Bexact, z = smpl.eval(['real(B_2)', 'Bexact_2', 'z'] @ ns, **args)
         z = numpy.concatenate([-z[::-1], z])
         B = numpy.concatenate([B[::-1], B])
         Bexact = numpy.concatenate([Bexact[::-1], Bexact])
         with export.mplfigure('magnetic-field-x2-axis.png', dpi=300) as fig:
             ax = fig.add_subplot(111, xlabel='$x_2$', ylabel='$B_2$', title='$B_2$ at $x_0 = x_1 = 0$')
             ax.plot(z, B, label='FEM')
             ax.plot(z, Bexact, label='exact', linestyle='dotted')
             ax.legend()
             # Minor ticks at element edges.
             zticks = RZ.boundary['left'].interfaces.sample('gauss', 0).eval(ns.z)
             ax.set_xticks(numpy.concatenate([-zticks[::-1], [0], zticks]), minor=True)
             ax.tick_params(axis='x', direction='in', which='minor', bottom=True, top=True)
             ax.set_xlim(-2*rcoil, 2*rcoil)
 
-    return state
+    return args
 
 
 class test(testing.TestCase):
 
     def test_dc(self):
-        state = main(nelems=16, degree=2)
+        args = main(nelems=16, degree=2)
         with self.subTest('A.real'):
-            self.assertAlmostEqual64(state['A'].real, '''
+            self.assertAlmostEqual64(args['A'].real, '''
                 eNoNke9rzWEYh5NzVmtnvud5nvv+3PdzTn7lIIRlL3Rq/wArinFGaytFo6xjTedISMwsJsNksbJYtlIS
                 U9pqLcqJKL9ytL3xYm92kpkQ2vL9B67P9el6TS/oHuVpPb13zW7WZu2U2WaG4t8CF8xWVsS+YgZF3MYu
                 /OYLTHyFyijrXllrNxvEqxaVa1S/yJBk5CfaEUMnz1MzPXcxV23JVAWjOq4D2qAL9YakZBAp9HKE99F9
                 99E+NcWgw5/yaT+tJzWm3WLlEiI4wu9oKdW6TTYTL/m//oPf4T9rvU7IXvmE7RjjFB+lAXfZjsRrk2uT
                 qxM3fcSfDTfaJSqn8YubeJhKbtIG5kdiImESHX5ez2iFXpWk9MHjPE/Rckq4jDnhO/0xv8SPhfwZOScq
                 d7EG/VzGW0ODHvNdS+GDa7pTy/WJNMgcrmMlBln4ALW6l2aZrtCk/pO3cksaRaSALCrRx8pt1OX+mLzk
                 5JDUS01ILmEYOWzEJB/nKGep1y22j/AYD3AH3chjD6oRxRu+yDVcpN3U49K2wAV+xqP8kPu5i9u4jjfw
                 HI1Ta9ihya2zLdRCh+kg7adGqqMtlKZVFKNpN+JyboFL2f8Z6oV2''')
 
     def test_ac_5(self):
-        state = main(nelems=16, degree=2, freq=1000, nturns=5)
+        args = main(nelems=16, degree=2, freq=1000., nturns=5)
         with self.subTest('A.imag'):
-            self.assertAlmostEqual64(state['A'].imag, '''
+            self.assertAlmostEqual64(args['A'].imag, '''
                 eNoNkEtIlGEYhRcWBqVWNgsxujBImxJmIIwEc2FJCYVaQxEErRIvkyFOhqTB4CLSpE3TxQiLCjXQEdJN
                 QUkZKMxCyxYhmpvvPe/7ft//K11AvPSvzuJZnPOcOZ3TeV1SX3PtERu3n2zEfXRNXqkfXU6s9P5O8wiP
                 8nue5kXeLhXyRHL0mVbZApfn1fj1K4MYwgjeYQLzWEcZpzhPXkqtHrAhF/Pqlzdpg9YpG/kIowb3wGjg
                 rTImSU3YUTfhN9MNaqcEdVIfDdIaNeAPUnxGQpplS12Fn0+7KItCVBhkLSVpC17jNG/wFxnWRbvgtZmk
                 +WxumQ4zY6rNX/ODmrGfp7hH4vrIdnuPzQuTMU9Nv/lpeswe+h407Aic6qRcr9iT3jE6SoepjE5RJXXR
                 MOXiPkI8xBfkoEbtNu859dNAsGycvhFRGHFM4Xjwx3nZqbvtrCtCEQ4hivLALoE+zGIvt/IvvhbwTX3j
                 0khjDB8wjQX8QyFXcidP8j7plbCuaZeLcYwv8VVu5HZ+wG85w6sckZsyI+c0xza6YimWiJTICamSy3Jd
                 7spAwLL1rKa12t5xLdqirdqmtzWp3ZrSVzquGXVaYC/ar/ah+w/zsU82''')
 
 
 if __name__ == '__main__':
+    from nutils import cli
     cli.run(main)
 
+
 # example:tags=electro-magnetism:thumbnail=0
```

### Comparing `nutils-7.3/examples/cylinderflow.py` & `nutils-8.0/examples/cylinderflow.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,79 +1,167 @@
-# Laminar flow around a cylinder
-#
-# In this script we solve the Navier-Stokes equations around a cylinder,
-# demonstrating different flow regimes at different Reynolds numbers.
-#
-# The general conservation laws are:
-#
-# - mass: `Dρ/Dt = 0`
-# - momentum: `D(ρ u_i)/Dt = ∇_j(σ_ij)`
-#
-# where we used the material derivative `D·/Dt := ∂·/∂t + ∇_j(· u_j)`. The
-# stress tensor is `σ_ij := μ (∇_j(u_i) + ∇_i(u_j) - 2 ∇_k(u_k) δ_ij / δ_nn) -
-# p δ_ij`, with pressure `p` and dynamic viscosity `μ`, and `ρ` is the density.
-#
-# Assuming incompressible flow, we take density to be constant. Further
-# introducing a reference length `L` and reference velocity `U`, we make the
-# equations dimensionless by taking spatial coordinates relative to `L`,
-# velocity relative to `U`, time relative to `L / U`, and pressure relative to
-# `ρ U^2`. This reduces the conservation laws to:
-#
-# - mass: `∇_k(u_k) = 0`
-# - momentum: `Du_i/Dt = ∇_j(σ_ij)`
-#
-# where the material derivative simplifies to `D·/Dt := ∂·/∂t + ∇_j(·) u_j`,
-# and the stress tensor becomes `σ_ij := (∇_j(u_i) + ∇_i(u_j)) / Re - p δ_ij`,
-# with Reynolds number `Re = ρ U L / μ`.
-#
-# The weak form is obtained by multiplication of a test function and partial
-# integration of the right hand side of the momentum balance.
-#
-# - mass: `∀ q: ∫_Ω q ∇_k(u_k) = 0`
-# - momentum: `∀ v: ∫_Ω (v_i Du_i/Dt + ∇_j(v_i) σ_ij) = ∫_Γ v_i σ_ij n_j`
-#
-# The exterior boundary is strongly constrained to uniform inflow in the
-# upstream section, and traction-free in the downstream section, in both cases
-# eliminating the right hand boundary integral. The no-slip condition at the
-# interior boundary is constrained strongly in the normal component, and
-# weakly in the tangential component using Nitsche's method. The added boundary
-# integral is scaled to dominate the right hand side of the momentum balance.
-#
-# For the initial condition we take potential flow, meaning the velocity equals
-# the gradient of a harmonic potential field. In order to obtain coefficients
-# against the required basis the flow problem is solved as a coupled first
-# order system: `∇_k(u_k) = 0` and `u_i = uinf_i - ∇_i(p)`, where the free flow
-# velocity `uinf` is introduced so that the scalar field p is zero at infinity.
-# The weak formulation takes the form of an optimization problem:
-#
-#     ∂/∂(u,p) ∫_Ω (.5 Σ_i (u_i - uinf_i)^2 - ∇_i(u_i) p) = 0
-#
-# The script uses a Raviart-Thomas discretization in curvilinear coordinates,
-# resulting in a pointwise divergence-free velocity field. The polar mesh is
-# constructed such that all elements are geometrically similar, growing
-# exponentially with radius and placing the artificial exterior boundary at
-# large (configurable) distance. The reference length is set equal to the
-# diameter of the cylinder and the referency velocity to the magnitude of the
-# inflow velocity, meaning that both quantities are simulated at unit value.
-
-
-from nutils import mesh, function, solver, export, cli, testing, numeric
+from nutils import mesh, function, solver, export, testing, numeric
 from nutils.expression_v2 import Namespace
 import itertools
 import numpy
 import treelog
 
 
+def main(nelems: int = 99,
+         degree: int = 3,
+         reynolds: float = 1000.,
+         uwall: float = 0.,
+         timestep: float = .04,
+         extdiam: float = 12.,
+         endtime: float = 30.):
+
+    '''Flow around a cylinder
+
+    Solves the Navier-Stokes equations around a cylinder, demonstrating
+    different flow regimes at different Reynolds numbers.
+
+    The general conservation laws are:
+
+        Dρ/Dt = 0 (mass)
+        ρ Du_i/Dt = ∇_j(σ_ij) (momentum)
+
+    where we used the material derivative D·/Dt := ∂·/∂t + ∇_j(· u_j). The stress
+    tensor is σ_ij := μ (∇_j(u_i) + ∇_i(u_j) - 2 ∇_k(u_k) δ_ij / δ_nn) - p δ_ij,
+    with pressure p and dynamic viscosity μ, and ρ is the density.
+
+    Assuming incompressible flow, we take density to be constant. Further
+    introducing a reference length L and reference velocity U, we make the
+    equations dimensionless by taking spatial coordinates relative to L, velocity
+    relative to U, time relative to L / U, and pressure relative to ρ U^2. This
+    reduces the conservation laws to:
+
+        ∇_k(u_k) = 0 (mass)
+        Du_i/Dt = ∇_j(σ_ij) (momentum)
+
+    where the material derivative simplifies to D·/Dt := ∂·/∂t + ∇_j(·) u_j, and
+    the stress tensor becomes σ_ij := (∇_j(u_i) + ∇_i(u_j)) / Re - p δ_ij, with
+    Reynolds number Re = ρ U L / μ.
+
+    The weak form is obtained by multiplication of a test function and partial
+    integration of the right hand side of the momentum balance.
+
+        ∀ q: ∫_Ω q ∇_k(u_k) = 0 (mass)
+        ∀ v: ∫_Ω (v_i Du_i/Dt + ∇_j(v_i) σ_ij) = ∫_Γ v_i σ_ij n_j (momentum)
+
+    The exterior boundary is strongly constrained to uniform inflow in the
+    upstream section, and traction-free in the downstream section, in both cases
+    eliminating the right hand boundary integral. The no-slip condition at the
+    interior boundary is constrained strongly in the normal component, and
+    weakly in the tangential component using Nitsche's method. The added boundary
+    integral is scaled to dominate the right hand side of the momentum balance.
+
+    For the initial condition we take potential flow, meaning the velocity equals
+    the gradient of a harmonic potential field. In order to obtain coefficients
+    against the required basis the flow problem is solved as a coupled first
+    order system: ∇_k(u_k) = 0 and u_i = uinf_i - ∇_i(p), where the free flow
+    velocity uinf is introduced so that the scalar field p is zero at infinity.
+    The weak formulation takes the form of an optimization problem:
+
+        ∂/∂(u,p) ∫_Ω (.5 Σ_i (u_i - uinf_i)^2 - ∇_i(u_i) p) = 0
+
+    The script uses a Raviart-Thomas discretization in curvilinear coordinates,
+    resulting in a pointwise divergence-free velocity field. The polar mesh is
+    constructed such that all elements are geometrically similar, growing
+    exponentially with radius and placing the artificial exterior boundary at
+    large (configurable) distance. The reference length is set equal to the
+    diameter of the cylinder and the referency velocity to the magnitude of the
+    inflow velocity, meaning that both quantities are simulated at unit value.
+
+    Parameters
+    ----------
+    nelems
+        Element size expressed in number of elements along the cylinder wall.
+        All elements have similar shape with approximately unit aspect ratio,
+        with elements away from the cylinder wall growing exponentially. Use an
+        odd number to break symmetry and promote early bifurcation.
+    degree
+        Polynomial degree for velocity space; the pressure space is one degree
+        less.
+    reynolds
+        Reynolds number, taking the cylinder diameter as characteristic length
+        and the inflow velocity as characteristic velocity.
+    uwall
+        Cylinder wall velocity, relative to inflow velocity.
+    timestep
+        Time step, relative to the ratio of cylinder diameter to inflow
+        velocity.
+    extdiam
+        Target exterior diameter, relative to cylinder diameter; the actual
+        domain size is rounded to integer multiples of the configured element
+        size.
+    endtime
+        Stopping time, relative to the ratio of cylinder diameter to inflow
+        velocity.
+    '''
+
+    elemangle = 2 * numpy.pi / nelems
+    melems = round(numpy.log(extdiam) / elemangle)
+    treelog.info('creating {}x{} mesh, outer radius {:.2f}'.format(melems, nelems, .5*numpy.exp(elemangle*melems)))
+    domain, geom = mesh.rectilinear([melems, nelems], periodic=(1,))
+    domain = domain.withboundary(inner='left', inflow=domain.boundary['right'][nelems//2:])
+
+    ns = Namespace()
+    ns.δ = function.eye(domain.ndims)
+    ns.Σ = function.ones([domain.ndims])
+    ns.ε = function.levicivita(2)
+    ns.uinf_i = 'δ_i0' # unit horizontal flow
+    ns.Re = reynolds
+    ns.grid = geom * elemangle
+    ns.x_i = '.5 exp(grid_0) (sin(grid_1) δ_i0 + cos(grid_1) δ_i1)' # polar coordinates
+    ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
+    J = ns.x.grad(geom)
+    detJ = numpy.linalg.det(J)
+    ns.add_field(('u', 'u0', 'v'), function.vectorize([
+        domain.basis('spline', degree=(degree, degree-1), removedofs=((0,), None)),
+        domain.basis('spline', degree=(degree-1, degree))]) @ J.T / detJ)
+    ns.add_field(('p', 'q'), domain.basis('spline', degree=degree-1) / detJ)
+    ns.dt = timestep
+    ns.DuDt_i = '(u_i - u0_i) / dt + ∇_j(u_i) u_j' # material derivative
+    ns.σ_ij = '(∇_j(u_i) + ∇_i(u_j)) / Re - p δ_ij'
+    ns.ω = 'ε_ij ∇_j(u_i)'
+    ns.N = 10 * degree / elemangle  # Nitsche constant based on element size = elemangle/2
+    ns.nitsche_i = '(N v_i - (∇_j(v_i) + ∇_i(v_j)) n_j) / Re'
+    ns.rotation = uwall / .5
+    ns.uwall_i = 'rotation ε_ij x_j' # clockwise positive rotation
+
+    sqr = domain.boundary['inflow'].integral('Σ_i (u_i - uinf_i)^2 dS' @ ns, degree=degree*2)
+    cons = solver.optimize('u,', sqr, droptol=1e-15) # constrain inflow boundary to unit horizontal flow
+
+    sqr = domain.integral('(.5 Σ_i (u_i - uinf_i)^2 - ∇_k(u_k) p) dV' @ ns, degree=degree*2)
+    args = solver.optimize('u,p', sqr, constrain=cons) # set initial condition to potential flow
+
+    res = domain.integral('(v_i DuDt_i + ∇_j(v_i) σ_ij + q ∇_k(u_k)) dV' @ ns, degree=degree*3)
+    res += domain.boundary['inner'].integral('(nitsche_i (u_i - uwall_i) - v_i σ_ij n_j) dS' @ ns, degree=degree*2)
+    div = numpy.sqrt(domain.integral('∇_k(u_k)^2 dV' @ ns, degree=2)) # L2 norm of velocity divergence
+
+    postprocess = PostProcessor(domain, ns)
+
+    steps = treelog.iter.fraction('timestep', range(round(endtime / timestep))) if endtime < float('inf') \
+       else treelog.iter.plain('timestep', itertools.count())
+
+    for _ in steps:
+        treelog.info(f'velocity divergence: {div.eval(**args):.0e}')
+        args['u0'] = args['u']
+        args = solver.newton('u:v,p:q', residual=res, arguments=args, constrain=cons).solve(1e-10)
+        postprocess(args)
+
+    return args, numpy.sqrt(domain.integral('∇_k(u_k)^2 dV' @ ns, degree=2))
+
+
 class PostProcessor:
 
     def __init__(self, topo, ns, region=4., aspect=16/9, figscale=7.2, spacing=.05, pstep=.1, vortlim=20):
         self.ns = ns
         self.figsize = aspect * figscale, figscale
         self.bbox = numpy.array([[-.5, aspect-.5], [-.5, .5]]) * region
-        self.bezier = topo.select(function.min(*(ns.x-self.bbox[:,0])*(self.bbox[:,1]-ns.x))).sample('bezier', 5)
+        self.bezier = topo.select(numpy.minimum(*(ns.x-self.bbox[:,0])*(self.bbox[:,1]-ns.x))).sample('bezier', 5)
         self.spacing = spacing
         self.pstep = pstep
         self.vortlim = vortlim
         self.t = 0.
         self.initialize_xgrd()
         self.topo = topo
 
@@ -114,138 +202,44 @@
             ax.plot(0, 0, 'k', marker=(3, 2, -self.t*self.ns.rotation.eval()*180/numpy.pi-90), markersize=20)
         dt = self.ns.dt.eval()
         self.t += dt
         self.xgrd += ugrd * dt
         self.regularize_xgrd()
 
 
-def main(nelems: int, degree: int, reynolds: float, uwall: float, timestep: float, extdiam: float, endtime: float):
-    '''
-    Flow around a cylinder.
-
-    .. arguments::
-
-       nelems [99]
-         Element size expressed in number of elements along the cylinder wall.
-         All elements have similar shape with approximately unit aspect ratio,
-         with elements away from the cylinder wall growing exponentially. Use
-         an odd number to break symmetry and promote early bifurcation.
-       extdiam [12]
-         Target exterior diameter, relative to cylinder diameter; the actual
-         domain size is rounded to integer multiples of the configured element
-         size.
-       degree [3]
-         Polynomial degree for velocity space; the pressure space is one degree
-         less.
-       reynolds [1000]
-         Reynolds number, taking the cylinder diameter as characteristic length
-         and the inflow velocity as characteristic velocity.
-       uwall [0]
-         Cylinder wall velocity, relative to inflow velocity.
-       timestep [.04]
-         Time step, relative to the ratio of cylinder diameter to inflow
-         velocity.
-       endtime [30]
-         Stopping time, relative to the ratio of cylinder diameter to inflow
-         velocity.
-    '''
-
-    elemangle = 2 * numpy.pi / nelems
-    melems = round(numpy.log(extdiam) / elemangle)
-    treelog.info('creating {}x{} mesh, outer radius {:.2f}'.format(melems, nelems, .5*numpy.exp(elemangle*melems)))
-    domain, geom = mesh.rectilinear([melems, nelems], periodic=(1,))
-    domain = domain.withboundary(inner='left', inflow=domain.boundary['right'][nelems//2:])
-
-    ns = Namespace()
-    ns.δ = function.eye(domain.ndims)
-    ns.Σ = function.ones([domain.ndims])
-    ns.ε = function.levicivita(2)
-    ns.uinf_i = 'δ_i0' # unit horizontal flow
-    ns.Re = reynolds
-    ns.grid = geom * elemangle
-    ns.x_i = '.5 exp(grid_0) (sin(grid_1) δ_i0 + cos(grid_1) δ_i1)' # polar coordinates
-    ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
-    J = ns.x.grad(geom)
-    detJ = function.determinant(J)
-    ns.ubasis = function.matmat(function.vectorize([
-        domain.basis('spline', degree=(degree, degree-1), removedofs=((0,), None)),
-        domain.basis('spline', degree=(degree-1, degree))]), J.T) / detJ
-    ns.pbasis = domain.basis('spline', degree=degree-1) / detJ
-    ns.u = function.dotarg('u', ns.ubasis)
-    ns.u0 = function.dotarg('u0', ns.ubasis)
-    ns.p = function.dotarg('p', ns.pbasis)
-    ns.dt = timestep
-    ns.DuDt_i = '(u_i - u0_i) / dt + ∇_j(u_i) u_j' # material derivative
-    ns.σ_ij = '(∇_j(u_i) + ∇_i(u_j)) / Re - p δ_ij'
-    ns.ω = 'ε_ij ∇_j(u_i)'
-    ns.N = 10 * degree / elemangle  # Nitsche constant based on element size = elemangle/2
-    ns.nitsche_ni = '(N ubasis_ni - (∇_j(ubasis_ni) + ∇_i(ubasis_nj)) n_j) / Re'
-    ns.rotation = uwall / .5
-    ns.uwall_i = 'rotation ε_ij x_j' # clockwise positive rotation
-
-    sqr = domain.boundary['inflow'].integral('Σ_i (u_i - uinf_i)^2 dS' @ ns, degree=degree*2)
-    cons = solver.optimize(('u',), sqr, droptol=1e-15) # constrain inflow boundary to unit horizontal flow
-
-    sqr = domain.integral('(.5 Σ_i (u_i - uinf_i)^2 - ∇_k(u_k) p) dV' @ ns, degree=degree*2)
-    args = solver.optimize(('u', 'p'), sqr, constrain=cons) # set initial condition to potential flow
-
-    ures = domain.integral('(ubasis_ni DuDt_i + ∇_j(ubasis_ni) σ_ij) dV' @ ns, degree=degree*3)
-    ures += domain.boundary['inner'].integral('(nitsche_ni (u_i - uwall_i) - ubasis_ni σ_ij n_j) dS' @ ns, degree=degree*2)
-    pres = domain.integral('pbasis_n ∇_k(u_k) dV' @ ns, degree=degree*3)
-
-    postprocess = PostProcessor(domain, ns)
-
-    steps = treelog.iter.fraction('timestep', range(round(endtime / timestep))) if endtime < float('inf') \
-       else treelog.iter.plain('timestep', itertools.count())
-
-    for _ in steps:
-        args['u0'] = args['u']
-        args = solver.newton(('u', 'p'), residual=(ures, pres), arguments=args, constrain=cons).solve(1e-10)
-        postprocess(args)
-
-    return args, numpy.sqrt(domain.integral('∇_k(u_k)^2 dV' @ ns, degree=2))
-
-# If the script is executed (as opposed to imported), :func:`nutils.cli.run`
-# calls the main function with arguments provided from the command line.
-
-
-if __name__ == '__main__':
-    cli.run(main)
-
-# Once a simulation is developed and tested, it is good practice to save a few
-# strategic return values for regression testing. The :mod:`nutils.testing`
-# module, which builds on the standard :mod:`unittest` framework, facilitates
-# this by providing :func:`nutils.testing.TestCase.assertAlmostEqual64` for the
-# embedding of desired results as compressed base64 data.
-
-
 class test(testing.TestCase):
 
     def test_rot0(self):
-        args, div = main(nelems=6, degree=3, reynolds=100, uwall=0, timestep=.1, extdiam=50, endtime=.1)
+        args, div = main(nelems=6, reynolds=100., timestep=.1, extdiam=50., endtime=.1)
         with self.subTest('divergence'):
             self.assertLess(div.eval(**args), 1e-13)
         with self.subTest('velocity'):
             self.assertAlmostEqual64(args['u'], '''
                 eNoBkABv//AzussRy7rL8DNVNU42sskxyLLJTjbPN7Q4SscGxkrHtDj9ObM6SMXmw0jFszofPFU8nsNk
                 wp7DVTyqPS49usKawbrCLj2APuHJi8hHyrk1dTcfNmbJJMhDyb023DeaNiPItMYoyNg3TDndNwnGv8QO
                 xvI5QTv3ORTErsIqxNY7Uj3sO8XCY8H1wgs9nT47Pc/9SG4=''')
         with self.subTest('pressure'):
             self.assertAlmostEqual64(args['p'], '''
                 eNoBSAC3/7w0bzXBzG81vDRXytwzezW0y3s13DOXyYfOxzVVM8c1h87LyJTJ3DezN9w3lMkBxzTIDDgz
                 Ogw4NMhAxu42Ij1DxCI97jZ+wirgIsM=''')
 
     def test_rot1(self):
-        args, div = main(nelems=6, degree=3, reynolds=100, uwall=.5, timestep=.1, extdiam=50, endtime=.1)
+        args, div = main(nelems=6, reynolds=100., uwall=.5, timestep=.1, extdiam=50., endtime=.1)
         with self.subTest('divergence'):
             self.assertLess(div.eval(**args), 1e-13)
         with self.subTest('velocity'):
             self.assertAlmostEqual64(args['u'], '''
                 eNoBkABv//czw8sRy7HL6TNVNU82tckxyLDJTTbPN7Q4SscGxkrHszj9ObM6SMXmw0jFszofPFU8nsNk
                 wp7DVTyqPS49usKawbrCLj2APrnJdMgEym01XDf1NXHJKshPyck24jelNiHIs8YnyNc3SznaNwnGv8QO
                 xvI5QTv4ORTErcIqxNY7Uj3sO8XCY8H1wgs9nT47PdHgSI0=''')
         with self.subTest('pressure'):
             self.assertAlmostEqual64(args['p'], '''
                 eNoBSAC3/+M0kjXDzEs1kjRXyvszijW0y2w1ujOXyV0tAzZXM4I1Dc3LyA7KDTizN6Y3MckBxybJpDgz
                 OjE3j8dAxr84Pz1DxAQ9I8p9wpetHyk=''')
 
+
+if __name__ == '__main__':
+    from nutils import cli
+    cli.run(main)
+
+
 # example:tags=Navier-Stokes,Raviard-Thomas,compatible spaces
```

### Comparing `nutils-7.3/examples/drivencavity.py` & `nutils-8.0/examples/drivencavity.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,89 +1,92 @@
-# Lid-driven cavity flow
-#
-# In this script we solve the lid driven cavity problem for stationary Stokes
-# and Navier-Stokes flow. This benchmark problem consists of a square domain
-# with fixed left, bottom and right boundaries and a top boundary that is
-# moving with constant velocity in positive x-direction. Reference results can
-# be found for instance at <https://www.acenumerics.com/the-benchmarks.html>.
-#
-# The general conservation laws are:
-#
-# - mass: `Dρ/Dt = 0`
-# - momentum: `D(ρ u_i)/Dt = ∇_j(σ_ij)`
-#
-# where we used the material derivative `D·/Dt := ∂·/∂t + ∇_j(· u_j)`. The
-# stress tensor is `σ_ij := μ (∇_j(u_i) + ∇_i(u_j) - 2 ∇_k(u_k) δ_ij / δ_nn) -
-# p δ_ij`, with pressure `p` and dynamic viscosity `μ`, and `ρ` is the density.
-#
-# We assume the flow to be steady and incompressible. Introducing domain width
-# `L` and lid velocity `U`, we make the equations dimensionless by taking
-# spatial coordinates relative to `L`, velocity relative to `U`, and pressure
-# relative to `ρ U^2`. This reduces the conservation laws to:
-#
-# - mass: `∇_k(u_k) = 0`
-# - momentum: `Du_i/Dt = ∇_j(σ_ij)`
-#
-# where the material derivative simplifies to `D·/Dt := ∇_j(·) u_j`, and the
-# stress tensor becomes `σ_ij := (∇_j(u_i) + ∇_i(u_j)) / Re - p δ_ij`, with
-# Reynolds number `Re = ρ U L / μ`.
-#
-# The weak form is obtained through multiplication with a test function and
-# partial integration of the right hand side of the momentum balance.
-#
-# - mass: `∀ q: ∫_Ω q ∇_k(u_k) = 0`
-# - momentum: `∀ v: ∫_Ω (v_i Du_i/Dt + ∇_j(v_i) σ_ij) = ∫_Γ v_i σ_ij n_j`
-#
-# A remaining issue with this system is that its solution is not unique due to
-# its strictly kinematic boundary conditions: since `∫_Ω ∇_k(u_k) = 0` for any
-# `u` that satisfies the non-penetrating boundary conditions, any pressure
-# space that contains unity results in linear dependence. Furthermore, the
-# strong form shows that constant pressure shifts do not affect the momentum
-# balance. Both issues are solved by arbitrarily removing one of the basis
-# functions, which amounts to a pressure point constraint.
-#
-# The normal velocity components at the wall are strongly constrained. The
-# tangential components are either strongly or weakly constrained depending on
-# the `strongbc` parameter. Since the tangential components at the top are
-# incompatible with the normal components at the left and right boundary, the
-# constraints are constructed in two steps to avoid Gibbs type oscillations,
-# and to make sure that the non-penetrating condition takes precedence.
-#
-# Depending on the `compatible` parameter, the script uses either a Taylor-Hood
-# (False) or a Raviart-Thomas (True) discretization. In case of TH, the system
-# is consistently modified by adding `∫_Ω .5 u_i v_i ∇_j(u_j)` to yield the
-# skew-symmetric advective term `∫_Ω .5 (v_i ∇_j(u_i) - u_i ∇_j(v_i)) u_j`. In
-# case of RT, the discretization guarantees a pointwise divergence-free
-# velocity field, and skew symmetry is implied.
-
-from nutils import mesh, function, solver, export, cli, testing
+from nutils import mesh, function, solver, export, testing
 from nutils.expression_v2 import Namespace
 import treelog as log
 import numpy
 
 
-def main(nelems: int, etype: str, degree: int, reynolds: float, compatible: bool, strongbc: bool):
-    '''
-    Driven cavity benchmark problem.
-
-    .. arguments::
-
-       nelems [32]
-         Number of elements along edge.
-       etype [square]
-         Element type (square/triangle/mixed).
-       degree [2]
-         Polynomial degree for velocity; the pressure space is one degree less.
-       reynolds [1000]
-         Reynolds number, taking the domain size as characteristic length.
-       strongbc [no]
-         Use strong boundary constraints
-       compatible [no]
-         Use compatible spaces and weakly imposed boundary conditions; requires
-         etype=square and strongbc=no
+def main(nelems: int = 32,
+         etype: str = 'square',
+         degree: int = 3,
+         reynolds: float = 1000.,
+         compatible: bool = False,
+         strongbc: bool = False):
+
+    '''Lid-driven cavity flow
+
+    Solves the lid driven cavity problem for stationary Stokes and
+    Navier-Stokes flow. This benchmark problem consists of a square domain with
+    fixed left, bottom and right boundaries and a top boundary that is moving
+    at unit velocity in positive x-direction. Reference results can be found
+    for instance at https://www.acenumerics.com/the-benchmarks.html.
+
+    The general conservation laws are:
+
+        Dρ/Dt = 0 (mass)
+        ρ Du_i/Dt = ∇_j(σ_ij) (momentum)
+
+    where we used the material derivative D·/Dt := ∂·/∂t + ∇_j(· u_j). The stress
+    tensor is σ_ij := μ (∇_j(u_i) + ∇_i(u_j) - 2 ∇_k(u_k) δ_ij / δ_nn) - p δ_ij,
+    with pressure p and dynamic viscosity μ, and ρ is the density.
+
+    Assuming steady, incompressible flow, we take density to be constant. Further
+    introducing a reference length L and reference velocity U, we make the
+    equations dimensionless by taking spatial coordinates relative to L, velocity
+    relative to U, and pressure relative to ρ U^2. This reduces the conservation
+    laws to:
+
+        ∇_k(u_k) = 0 (mass)
+        Du_i/Dt = ∇_j(σ_ij) (momentum)
+
+    where the material derivative simplifies to D·/Dt := ∇_j(·) u_j, and the
+    stress tensor becomes σ_ij := (∇_j(u_i) + ∇_i(u_j)) / Re - p δ_ij, with
+    Reynolds number Re = ρ U L / μ.
+
+    The weak form is obtained by multiplication of a test function and partial
+    integration of the right hand side of the momentum balance.
+
+        ∀ q: ∫_Ω q ∇_k(u_k) = 0 (mass)
+        ∀ v: ∫_Ω (v_i Du_i/Dt + ∇_j(v_i) σ_ij) = ∫_Γ v_i σ_ij n_j (momentum)
+
+    A remaining issue with this system is that its solution is not unique due to
+    its strictly kinematic boundary conditions: since ∫_Ω ∇_k(u_k) = 0 for any u
+    that satisfies the non-penetrating boundary conditions, any pressure space
+    that contains unity results in linear dependence. Furthermore, the strong
+    form shows that constant pressure shifts do not affect the momentum balance.
+    Both issues are solved by arbitrarily removing one of the basis functions.
+
+    The normal velocity components at the wall are strongly constrained. The
+    tangential components are either strongly or weakly constrained depending on
+    the `strongbc` parameter. Since the tangential components at the top are
+    incompatible with the normal components at the left and right boundary, the
+    constraints are constructed in two steps to avoid Gibbs type oscillations,
+    and to make sure that the non-penetrating condition takes precedence.
+
+    Depending on the `compatible` parameter, the script uses either a Taylor-Hood
+    (False) or a Raviart-Thomas (True) discretization. In case of TH, the system
+    is consistently modified by adding ∫_Ω .5 u_i v_i ∇_j(u_j) to yield the skew-
+    symmetric advective term ∫_Ω .5 (v_i ∇_j(u_i) - u_i ∇_j(v_i)) u_j. In case of
+    RT, the discretization guarantees a pointwise divergence-free velocity field,
+    and skew symmetry is implied.
+
+    Parameters
+    ----------
+    nelems
+        Number of elements along edge.
+    etype
+        Element type (square/triangle/mixed).
+    degree
+        Polynomial degree for velocity; the pressure space is one degree less.
+    reynolds
+        Reynolds number, taking the domain size as characteristic length.
+    strongbc
+        Use strong boundary constraints
+    compatible
+        Use compatible spaces and weakly imposed boundary conditions; requires
+        etype='square' and strongbc=False
     '''
 
     if compatible and (strongbc or etype != 'square'):
         raise Exception(f'compatible mode requires square elements and weak boundary conditions')
 
     domain, geom = mesh.unitsquare(nelems, etype)
 
@@ -92,84 +95,79 @@
     ns.ε = function.levicivita(2)
     ns.Σ = function.ones([domain.ndims])
     ns.Re = reynolds
     ns.uwall = numpy.stack([domain.boundary.indicator('top'), 0])
     ns.x = geom
     ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
     if not compatible:
-        ns.ubasis = domain.basis('std', degree=degree).vector(domain.ndims)
-        ns.pbasis = domain.basis('std', degree=degree-1)[1:]
-        ns.ψbasis = domain.basis('std', degree=2)[1:]
+        ns.add_field(('u', 'v'), domain.basis('std', degree=degree), shape=(domain.ndims,))
+        ns.add_field(('p', 'q'), domain.basis('std', degree=degree-1)[1:])
+        ns.add_field('ψ', domain.basis('std', degree=2)[1:])
     else:
-        ns.ubasis = function.vectorize([
+        ns.add_field(('u', 'v'), function.vectorize([
             domain.basis('spline', degree=(degree, degree-1)),
-            domain.basis('spline', degree=(degree-1, degree))])
-        ns.pbasis = domain.basis('spline', degree=degree-1)[1:]
-        ns.ψbasis = domain.basis('spline', degree=degree)[1:]
-    ns.u = function.dotarg('u', ns.ubasis)
-    ns.p = function.dotarg('p', ns.pbasis)
-    ns.ψ = function.dotarg('ψ', ns.ψbasis)
+            domain.basis('spline', degree=(degree-1, degree))]))
+        ns.add_field(('p', 'q'), domain.basis('spline', degree=degree-1)[1:])
+        ns.add_field('ψ', domain.basis('spline', degree=degree)[1:])
     ns.σ_ij = '(∇_j(u_i) + ∇_i(u_j)) / Re - p δ_ij'
 
     # weak formulation for Stokes flow, over-integrating for improved
     # efficiency when we turn this to Navier-Stokes later on
-    ures = domain.integral('∇_j(ubasis_ni) σ_ij dV' @ ns, degree=degree*3)
-    pres = domain.integral('pbasis_n ∇_k(u_k) dV' @ ns, degree=degree*3)
+    res = domain.integral('∇_j(v_i) σ_ij dV' @ ns, degree=degree*3)
+    res += domain.integral('q ∇_k(u_k) dV' @ ns, degree=degree*3)
 
     # strong enforcement of non-penetrating boundary conditions
     sqr = domain.boundary.integral('(u_k n_k)^2 dS' @ ns, degree=degree*2)
-    cons = solver.optimize(('u',), sqr, droptol=1e-15)
+    cons = solver.optimize('u,', sqr, droptol=1e-15)
 
     if strongbc:
         # strong enforcement of tangential boundary conditions
         sqr = domain.boundary.integral('(ε_ij n_i (u_j - uwall_j))^2 dS' @ ns, degree=degree*2)
-        tcons = solver.optimize(('u',), sqr, droptol=1e-15)
+        tcons = solver.optimize('u,', sqr, droptol=1e-15)
         cons['u'] = numpy.choose(numpy.isnan(cons['u']), [cons['u'], tcons['u']])
     else:
         # weak enforcement of tangential boundary conditions via Nitsche's method
         ns.N = 5 * degree * nelems # Nitsche constant based on element size = 1/nelems
-        ns.nitsche_ni = '(N ubasis_ni - (∇_j(ubasis_ni) + ∇_i(ubasis_nj)) n_j) / Re'
-        ures += domain.boundary.integral('(nitsche_ni (u_i - uwall_i) - ubasis_ni σ_ij n_j) dS' @ ns, degree=2*degree)
+        ns.nitsche_i = '(N v_i - (∇_j(v_i) + ∇_i(v_j)) n_j) / Re'
+        res += domain.boundary.integral('(nitsche_i (u_i - uwall_i) - v_i σ_ij n_j) dS' @ ns, degree=2*degree)
 
     with log.context('stokes'):
-        args0 = solver.solve_linear(('u', 'p'), (ures, pres), constrain=cons)
+        args0 = solver.solve_linear('u:v,p:q', res, constrain=cons)
         postprocess(domain, ns, **args0)
 
     # change to Navier-Stokes by adding convection
-    ures += domain.integral('ubasis_ni ∇_j(u_i) u_j dV' @ ns, degree=degree*3)
+    res += domain.integral('v_i ∇_j(u_i) u_j dV' @ ns, degree=degree*3)
     if not compatible:
         # add consistent term for skew-symmetry
-        ures += domain.integral('.5 u_i ubasis_ni ∇_j(u_j) dV' @ ns, degree=degree*3)
+        res += domain.integral('.5 u_i v_i ∇_j(u_j) dV' @ ns, degree=degree*3)
 
     with log.context('navier-stokes'):
-        args1 = solver.newton(('u', 'p'), (ures, pres), arguments=args0, constrain=cons).solve(tol=1e-10)
+        args1 = solver.newton('u:v,p:q', res, arguments=args0, constrain=cons).solve(tol=1e-10)
         postprocess(domain, ns, **args1)
 
     return args0, args1
 
+
 # Postprocessing in this script is separated so that it can be reused for the
 # results of Stokes and Navier-Stokes, and because of the extra steps required
 # for establishing streamlines.
 
 def postprocess(domain, ns, **arguments):
 
-    from matplotlib.collections import LineCollection
-
     # reconstruct velocity streamlines
     sqr = domain.integral('Σ_i (u_i - ε_ij ∇_j(ψ))^2 dV' @ ns, degree=4)
-    arguments = solver.optimize(('ψ',), sqr, arguments=arguments)
+    arguments = solver.optimize('ψ,', sqr, arguments=arguments)
 
     bezier = domain.sample('bezier', 9)
     x, u, p, ψ = bezier.eval(['x_i', 'sqrt(u_i u_i)', 'p', 'ψ'] @ ns, **arguments)
+
     with export.mplfigure('flow.png', dpi=150) as fig: # plot velocity as field, pressure as contours, streamlines as dashed
         ax = fig.add_subplot(111, aspect='equal')
-        im = ax.tripcolor(*x.T, bezier.tri, u, shading='gouraud', cmap='hot_r', rasterized=True)
-        im.set_clim(0, 1)
+        im = export.triplot(ax, x, u, tri=bezier.tri, hull=bezier.hull, cmap='hot_r', clim=(0,1))
         fig.colorbar(im, label='velocity')
-        ax.add_collection(LineCollection(x[bezier.hull], colors='k', linewidths=.1, alpha=.5))
         ax.tricontour(x[:, 0], x[:, 1], bezier.tri, ψ, levels=numpy.percentile(ψ, numpy.arange(2,100,3)), colors='k', linestyles='solid', linewidths=.5, zorder=9)
 
     x = numpy.linspace(0, 1, 1001)
     v = domain.locate(ns.x, numpy.stack([x, numpy.repeat(.5, len(x))], 1), tol=1e-10).eval(ns.u[1], **arguments)
     imin = numpy.argmin(v)
     imax = numpy.argmax(v)
     with export.mplfigure('cross-hor.png', dpi=150) as fig:
@@ -182,31 +180,19 @@
     u = domain.locate(ns.x, numpy.stack([numpy.repeat(.5, len(y)), y], 1), tol=1e-10).eval(ns.u[0], **arguments)
     imin = numpy.argmin(u)
     with export.mplfigure('cross-ver.png', dpi=150) as fig:
         ax = fig.add_subplot(111, ylim=(0,1), title='vertical cross section at x=0.5', ylabel='y-coordinate', xlabel='horizontal velocity')
         ax.plot(u, y)
         ax.annotate(f'y={y[imin]:.3f}\nu={u[imin]:.3f}', xy=(u[imin], y[imin]), xytext=(0, y[imin]), arrowprops=dict(arrowstyle="->"), ha='left', va='center')
 
-# If the script is executed (as opposed to imported), :func:`nutils.cli.run`
-# calls the main function with arguments provided from the command line. To
-# keep with the default arguments simply run :sh:`python3 drivencavity.py`.
-
-if __name__ == '__main__':
-    cli.run(main)
-
-# Once a simulation is developed and tested, it is good practice to save a few
-# strategic return values for regression testing. The :mod:`nutils.testing`
-# module, which builds on the standard :mod:`unittest` framework, facilitates
-# this by providing :func:`nutils.testing.TestCase.assertAlmostEqual64` for the
-# embedding of desired results as compressed base64 data.
 
 class test(testing.TestCase):
 
     def test_baseline(self):
-        args0, args1 = main(nelems=3, etype='square', degree=2, reynolds=100, compatible=False, strongbc=False)
+        args0, args1 = main(nelems=3, degree=2, reynolds=100.)
         with self.subTest('stokes-velocity'):
             self.assertAlmostEqual64(args0['u'], '''
                 eNo9jSsLwlAcxQ82gwOjoFZ1ONA9NK6vC2Ky2cU2QeziFxDBJIKfZLv/O92DYRqo6waDGBR3GXjKgfPg
                 Bwh9A6AYA80TMOwCU0OkcwVonGMl8Uaa5C90i9+MipP2tn1gEgFXvgpDGqgRK+smPTWbaqqcdWMfeBPw
                 YcDGBdLMJR3Y/X+zdkhHHrEHM6lENt25+OU8OUi8PUn+klm87lacqiN4uQrZ4tUCLh3g4AFrV6Q/uctG
                 gQ==''')
         with self.subTest('stokes-pressure'):
@@ -219,15 +205,15 @@
                 nM/5nf5xevqZxDOq5w4bCwLlOoD6XDV/n1t//s5ZvjPzTjmdDjx55+Slky/MGaDgHFB3vz4DgynQfS9O
                 A3WcBIkCAB7aSkk=''')
         with self.subTest('navier-stokes-pressure'):
             self.assertAlmostEqual64(args1['p'], '''
                 eNpz01W9oHVmuU7SJYtzgherdcr0n59dfiZT11yP97yCGQDN0Azu''')
 
     def test_mixed(self):
-        args0, args1 = main(nelems=3, etype='mixed', degree=2, reynolds=100, compatible=False, strongbc=False)
+        args0, args1 = main(nelems=3, etype='mixed', degree=2, reynolds=100.)
         with self.subTest('stokes-velocity'):
             self.assertAlmostEqual64(args0['u'], '''
                 eNpjYAABHx0Ghrbz+lcYGJZpR2hrnDtm/EObgWHvWSGD1WeuGTIwmJ9jYLAwnH32p8nKMzFmFqfVTJTP
                 aBszMOw0AenebmJh9tuMgWHGWX9jQ3MGhr9nLA35zxRcWHOm4mzOBQaG55cZGCTPGV6fdUrhwtEzvhe2
                 n+Y8k3RG+Mwio99nuoHqg4G48WzCmTignYUXDfXNzoedATuL4bMeA0Op9qczWqfXnTl2ioHhINAdHufv
                 ntx18qoZSH7FSRAJAB13Sc0=''')
         with self.subTest('stokes-pressure'):
@@ -240,15 +226,15 @@
                 n5xefpbrzEYjZ3MGhiogDr/YYbxbjYHhrH6lYcY55zNgZzGcNWBgUL0Uctr3zLzTt08xMOScZmCYdnbl
                 qQMnpcxB8konQSQACVZG3A==''')
         with self.subTest('navier-stokes-pressure'):
             self.assertAlmostEqual64(args1['p'], '''
                 eNrbqjVZs1/ry/n48z1nSrW9L83RkTmneNZMO/TCOUNbMwDktQ3z''')
 
     def test_compatible(self):
-        args0, args1 = main(nelems=3, etype='square', degree=2, reynolds=100, compatible=True, strongbc=False)
+        args0, args1 = main(nelems=3, degree=2, reynolds=100., compatible=True)
         with self.subTest('stokes-velocity'):
             self.assertAlmostEqual64(args0['u'], '''
                 eNpjYIAAvwvdBr9O2Zk90E8+rXQ6yxzGZ4CDTfr3z0H45hc2mjSagFgn9f1P15+G6Fc0PHSSgQEAx7kX
                 6A==''')
         with self.subTest('stokes-pressure'):
             self.assertAlmostEqual64(args0['p'], '''
                 eNoL1u+7NOfUR929ugvORxlU6W7V1TcUuyiif/PKCf1yUwDfRw2t''')
@@ -257,15 +243,15 @@
                 eNpjYICA1HNRRkGnZ5r26m86bX3awvyBftS5C6dOmDHAwWxDmbMzTUEsrfMrTA6YgFjKV53OOJ0FsR7o
                 F561OMnAAAC5tRfX''')
         with self.subTest('navier-stokes-pressure'):
             self.assertAlmostEqual64(args1['p'], '''
                 eNoz1VYx3HT6t16w/uKz73Uv6R7RNzx35swh7XdXrQ0TzADbMQ6l''')
 
     def test_strong(self):
-        args0, args1 = main(nelems=3, etype='square', degree=2, reynolds=100, compatible=False, strongbc=True)
+        args0, args1 = main(nelems=3, degree=2, reynolds=100., strongbc=True)
         with self.subTest('stokes-velocity'):
             self.assertAlmostEqual64(args0['u'], '''
                 eNpjYMAPDl2wNEg9p2D8QeOQcafBJ9OTJ6abB5lD5E6eVb348oyVkfSZf8YFZ6RNZp6+ZwiTO3KGgUEP
                 iNedYmDoPc3AsMGEgQGh77beyzPHzkqfYTpTcObp6Zmnlc7B5A5dOH4+9dyDMx807M50GvCdOnki8wRM
                 DhcAAEYiNtQ=''')
         with self.subTest('stokes-pressure'):
             self.assertAlmostEqual64(args0['p'], '''
@@ -275,8 +261,14 @@
                 eNpjYMAPAs4H6M8zaDJOO91vKma628TihKx5kDlEbv2Z5fqFZ24aKZ/mNplmmGJy5eRbY5jcpdOGF+tP
                 /9BPPW1gXH6W2eSpkds5mBz72fvnUs/EnHt+etXpCWdZzgSd3W8Ck1M9L3zGGyi/4Pz80+ZnNp44c9L8
                 BEwOFwAA4RM3QA==''')
         with self.subTest('navier-stokes-pressure'):
             self.assertAlmostEqual64(args1['p'], '''
                 eNoBHgDh//ot489SzMEsntHezWTPAC+jL+XN/8wF02UxTc1JNhf0ELc=''')
 
+
+if __name__ == '__main__':
+    from nutils import cli
+    cli.run(main)
+
+
 # example:tags=Stokes,Navier-Stokes,Taylor-Hood,Raviard-Thomas:thumbnail=0
```

### Comparing `nutils-7.3/examples/elasticity.py` & `nutils-8.0/examples/elasticity.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,69 +1,70 @@
-# Plane strain plate under gravitational pull
-#
-# In this script we solve the linear elasticity problem on a unit square
-# domain, clamped at the top boundary, and stretched under the influence of a
-# vertical distributed load.
-
-from nutils import mesh, function, solver, export, cli, testing
+from nutils import mesh, function, solver, export, testing
 from nutils.expression_v2 import Namespace
 import treelog as log
 import numpy
 
-def main(nelems: int, etype: str, btype: str, degree: int, poisson: float, direct: bool):
-    '''
-    Horizontally loaded linear elastic plate.
-
-    .. arguments::
 
-       nelems [24]
-         Number of elements along edge.
-       etype [triangle]
-         Type of elements (square/triangle/mixed).
-       btype [std]
-         Type of basis function (std/spline), with availability depending on the
-         configured element type.
-       degree [2]
-         Polynomial degree.
-       poisson [.3]
-         Poisson's ratio, nonnegative and strictly smaller than 1/2.
-       direct [no]
-         Use direct traction evaluation.
+def main(nelems: int = 24,
+         etype: str = 'triangle',
+         btype: str = 'std',
+         degree: int = 2,
+         poisson: float = .3,
+         direct: bool = False):
+
+    '''Plane strain plate under gravitational pull
+    
+    Solves the linear elasticity problem on a unit square domain, clamped at
+    the top boundary, and stretched under the influence of a vertical
+    distributed load.
+
+    Parameters
+    ----------
+    nelems
+        Number of elements along edge.
+    etype
+        Type of elements (square/triangle/mixed).
+    btype
+        Type of basis function (std/spline), with availability depending on the
+        configured element type.
+    degree
+        Polynomial degree.
+    poisson
+        Poisson's ratio, nonnegative and strictly smaller than 1/2.
+    direct
+        Use direct traction evaluation.
     '''
 
     domain, geom = mesh.unitsquare(nelems, etype)
 
     ns = Namespace()
     ns.δ = function.eye(domain.ndims)
     ns.x = geom
     ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
-
-    basis = domain.basis(btype, degree=degree)
-    ns.u = function.dotarg('u', basis, shape=(2,))
+    ns.add_field(('u', 't'), domain.basis(btype, degree=degree), shape=(2,))
     ns.X_i = 'x_i + u_i'
     ns.λ = 1
     ns.μ = .5/poisson - 1
     ns.ε_ij = '.5 (∇_i(u_j) + ∇_j(u_i))'
     ns.σ_ij = 'λ ε_kk δ_ij + 2 μ ε_ij'
     ns.E = 'ε_ij σ_ij'
     ns.q_i = '-δ_i1'
 
     sqr = domain.boundary['top'].integral('u_k u_k dS' @ ns, degree=degree*2)
     cons = solver.optimize(('u',), sqr, droptol=1e-15)
 
     # solve for equilibrium configuration
     internal = domain.integral('E dV' @ ns, degree=degree*2)
     external = domain.integral('u_i q_i dV' @ ns, degree=degree*2)
-    args = solver.optimize(('u',), internal - external, constrain=cons)
+    args = solver.optimize('u,', internal - external, constrain=cons)
 
     # evaluate tractions and net force
     if direct:
         ns.t_i = 'σ_ij n_j' # <-- this is an inadmissible boundary term
     else:
-        ns.t = function.dotarg('t', basis, shape=(2,))
         external += domain.boundary['top'].integral('u_i t_i dS' @ ns, degree=degree*2)
         invcons = dict(t=numpy.choose(numpy.isnan(cons['u']), [numpy.nan, 0.]))
         args = solver.solve_linear(('t',), [(internal - external).derivative('u')], constrain=invcons, arguments=args)
     F = domain.boundary['top'].integrate('t_i dS' @ ns, degree=degree*2, arguments=args)
     log.user('total clamping force:', F)
 
     # visualize solution
@@ -75,84 +76,72 @@
         im = ax.tripcolor(*X.T, bezier.tri, E, shading='gouraud', rasterized=True, cmap='turbo')
         export.plotlines_(ax, X.T, bezier.hull, colors='k', linewidths=.1, alpha=.5)
         ax.quiver(*Xt.T, *t.T, clip_on=False)
         fig.colorbar(im)
 
     return cons, args
 
-# If the script is executed (as opposed to imported), :func:`nutils.cli.run`
-# calls the main function with arguments provided from the command line. For
-# example, to keep with the default arguments simply run :sh:`python3
-# elasticity.py`. To select mixed elements and quadratic basis functions add
-# :sh:`python3 elasticity.py etype=mixed degree=2`.
-
-if __name__ == '__main__':
-    cli.run(main)
-
-# Once a simulation is developed and tested, it is good practice to save a few
-# strategic return values for regression testing. The :mod:`nutils.testing`
-# module, which builds on the standard :mod:`unittest` framework, facilitates
-# this by providing :func:`nutils.testing.TestCase.assertAlmostEqual64` for the
-# embedding of desired results as compressed base64 data.
 
 class test(testing.TestCase):
 
-    @testing.requires('matplotlib')
-    def test_default(self):
-        cons, args = main(nelems=4, etype='square', btype='std', degree=1, poisson=.25, direct=False)
+    def test_simple(self):
+        cons, args = main(nelems=4, etype='square', degree=1, poisson=.25)
         with self.subTest('constraints'):
             self.assertAlmostEqual64(cons['u'], '''
                 eNpjaGBAhSBAZTEAEKAUAQ==''')
         with self.subTest('displacement'):
             self.assertAlmostEqual64(args['u'], '''
                 eNqT1yk8K6o35ay2PsO5ev3v5xiA4ItW1NlnOrVnX+l+PrtZV+Y8AxiEnGVgqATir0AsARbjuRp1Vupy
                 7VmxS5/P+l6CqHt4ufDs64tTzl69wHCu8QLEPADBQyml''')
         with self.subTest('traction'):
             self.assertAlmostEqual64(args['t'], '''
                 eNpjYEAF7Kd2mqMJMXAZiGKIMTCEYIh9O4+p7qfpTnMA/hUHAg==''')
 
-    @testing.requires('matplotlib')
     def test_mixed(self):
-        cons, args = main(nelems=4, etype='mixed', btype='std', degree=1, poisson=.25, direct=False)
+        cons, args = main(nelems=4, etype='mixed', degree=1, poisson=.25)
         with self.subTest('constraints'):
             self.assertAlmostEqual64(cons['u'], '''
                 eNpjaGDAD2EAmziRYgAgoBQB''')
         with self.subTest('solution'):
             self.assertAlmostEqual64(args['u'], '''
                 eNoz1c0466vXfrZeJ+ystm7TWVl9lnPPdd+erdf/fG66rvR5Bijg0Ko4e0or+uwjjT9nHTVEweKOt2PO
                 rrrcdjbj0uezTpdkwGK2l6afnXW14SznRZ5z+y5wgcUAJX0p8A==''')
         with self.subTest('traction'):
             self.assertAlmostEqual64(args['t'], '''
                 eNpjYMAPXE7tNZ98ls8cXTzFOAVDbMfpz2boYqfMLpkDAGMuCY8=''')
 
-    @testing.requires('matplotlib')
     def test_quadratic(self):
-        cons, args = main(nelems=4, etype='square', btype='std', degree=2, poisson=.25, direct=False)
+        cons, args = main(nelems=4, etype='square', degree=2, poisson=.25)
         with self.subTest('constraints'):
             self.assertAlmostEqual64(cons['u'], '''
                 eNpjaGDAD0FgVA1eNQAj9kgB''')
         with self.subTest('solution'):
             self.assertAlmostEqual64(args['u'], '''
                 eNolkL1KA0EUhcdI+sQnEFPtZma3tlBEQSwCJmskLFisvoAKu40hEAjaqkWaCKaIYCGSOhYiWlidmZ2Z
                 /FQRXyBuirSim+yFr7jwcTn3MNPHkPr4ZU28WD0Ydorf2BV+bs/4o/0sSDzbpocT6qHB6ti0OniyIvxZ
                 BT620uKL3YVz59tw0c67+KBV1FgbYzbFulXkI5YRJbazcLKGgyPTQTUfwKYtXNEJ3miZl2hW3Ob3Fw4h
                 Dgg5iAliWjE/850TshJn2Vs40dDBw8DBZT+A1C1c6Am2dJl3dVac9pM7q0MXx30XG7qKhmojp6b4lEVu
                 qIzoqiTP68DDvfZQU3W8yw4OZYQlWeA5mRZrKvlLD3yY2seyamJX9jAKU/wsrPDrcMbdMOnnH2mlmk4=''')
         with self.subTest('traction'):
             self.assertAlmostEqual64(args['t'], '''
                 eNpjYMAPOk+qWxBQwvDW5L8pITUSZ9LMCamZaCBGUA0DQwBBNfnnCZvzwpiwe4RPE/ZXuZm6BQAVHQ1+''')
 
-    @testing.requires('matplotlib')
     def test_poisson(self):
-        cons, args = main(nelems=4, etype='square', btype='std', degree=1, poisson=.4, direct=False)
+        cons, args = main(nelems=4, etype='square', degree=1, poisson=.4)
         with self.subTest('constraints'):
             self.assertAlmostEqual64(cons['u'], '''
                 eNpjaGBAhSBAZTEAEKAUAQ==''')
         with self.subTest('solution'):
             self.assertAlmostEqual64(args['u'], '''
                 eNqTNig6vcVwwekjRuJn5Iy1zzIAwQs999MdBmWn+w0Zz7QYpoPFGBisTzMw5AMx6xkGhniwmMRF99MV
                 58tOF55jPFNzDqLu6fmi0z7nFpy2OSt+5tEZiHkAKRAl5A==''')
         with self.subTest('traction'):
             self.assertAlmostEqual64(args['t'], '''
                 eNpjYEAF/Sc+maMJMdw0emzGgAFiMdSpn8VUV2j+yRwAoCAJFw==''')
 
+
+if __name__ == '__main__':
+    from nutils import cli
+    cli.run(main)
+
+
 # example:tags=elasticity
```

### Comparing `nutils-7.3/examples/platewithhole.py` & `nutils-8.0/examples/platewithhole.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,47 +1,66 @@
-# Deformation of an infinite plate with a circular hole
-#
-# In this script we solve the linear plane strain elasticity problem for an
-# infinite plate with a circular hole under tension. We do this by placing the
-# circle in the origin of a unit square, imposing symmetry conditions on the
-# left and bottom (named `sym`), and Dirichlet conditions constraining the
-# displacements to the analytical solution to the right and top (named `far`).
-#
-# The script can be run in two modes: by specifying `mode=FCM`, the circular
-# hole is cut out of a regular finite element mesh by means of the Finite Cell
-# Method; by specifying `mode=NURBS` a Non-Uniform Rational BSpline geometry is
-# created to map a regular domain onto the desired shape. Either mode supports
-# sub-parameters which can be specified from the command-line by attaching them
-# in curly braces (e.g. `FCM{nelems=20,degree=1}`).
-
-from nutils import mesh, function, solver, export, cli, testing
+from nutils import mesh, function, solver, export, testing
 from nutils.expression_v2 import Namespace
 from dataclasses import dataclass
 from typing import Union
 import treelog as log
 import numpy
 
 
 @dataclass
 class FCM:
+    '''Finite cell method
+
+    Generate a topology and geometry by meshing the unit square, followed by
+    removing the circular cut-out using the Finite Cell Method. Then restrict a
+    basis from the base topology to the trimmed topology for analysis.
+
+    Parameters
+    ----------
+    nelems
+        Number of elements along one dimension in the base mesh.
+    etype
+        Element type to use in the base mesh (square/triangle/mixed/multipatch).
+    btype
+        Basis type, options depending on the select element type.
+    degree
+        Polynomial degree of the basis functions.
+    maxrefine
+        Quad-tree refinement depth of the finite cell procedure.
+    '''
+
     nelems: int = 9
     etype: str = 'square'
     btype: str = 'std'
     degree: int = 2
     maxrefine: int = 2
+
     def generate(self, radius):
         topo0, geom = mesh.unitsquare(self.nelems, self.etype)
-        topo = topo0.trim(function.norm2(geom) - radius, maxrefine=self.maxrefine, name='hole')
+        topo = topo0.trim(numpy.linalg.norm(geom) - radius, maxrefine=self.maxrefine, name='hole')
         basis = topo.basis(self.btype, degree=self.degree)
         return topo.withboundary(sym='left,bottom', far='top,right'), geom, basis, self.degree
 
 
 @dataclass
 class NURBS:
+    '''Non-Uniform Radional B-Splines
+
+    Generate a 1x2 structured topology, map it using quadratic NURBS to a
+    square domain with circular cut-out, and refine several times before
+    constructing a NURBS basis for analysis.
+
+    Parameters
+    ----------
+    nrefine
+        Number of refinement levels for analysis.
+    '''
+
     nrefine: int = 2
+
     def generate(self, radius):
         topo, geom0 = mesh.rectilinear([1, 2])
         bsplinebasis = topo.basis('spline', degree=2)
         controlweights = numpy.ones(12)
         controlweights[1:3] = .5 + .25 * numpy.sqrt(2)
         weightfunc = bsplinebasis @ controlweights
         nurbsbasis = bsplinebasis * controlweights / weightfunc
@@ -57,40 +76,55 @@
             bsplinebasis = topo.basis('spline', degree=2)
             sqr = topo.integral((function.dotarg('w', bsplinebasis) - weightfunc)**2, degree=9)
             controlweights = solver.optimize('w', sqr)
             nurbsbasis = bsplinebasis * controlweights / weightfunc
         return topo.withboundary(hole='left', sym='top,bottom', far='right'), geom, nurbsbasis, 5
 
 
-def main(mode: Union[FCM, NURBS], radius: float, traction: float, poisson: float):
-    '''
-    Horizontally loaded linear elastic plate with circular hole.
-
-    .. arguments::
-
-       mode [NURBS]
-         Discretization strategy: FCM (Finite Cell Method) or NURBS.
-       radius [.5]
-         Cut-out radius.
-       traction [.1]
-         Far field traction (relative to Young's modulus).
-       poisson [.3]
-         Poisson's ratio, nonnegative and strictly smaller than 1/2.
+def main(mode: Union[FCM, NURBS] = NURBS,
+         radius: float = .5,
+         traction: float = .1,
+         poisson: float = .3):
+
+    '''Deformation of an infinite plate with a circular hole
+
+    Solves the linear plane strain elasticity problem for an infinite plate
+    with a circular hole under tension. We do this by placing the circle in the
+    origin of a unit square, imposing symmetry conditions on the left and
+    bottom ("sym"), and Dirichlet conditions constraining the displacements to
+    the analytical solution to the right and top ("far").
+
+    The script can be run in two modes: by specifying `mode=FCM`, the circular
+    hole is cut out of a regular finite element mesh by means of the Finite Cell
+    Method; by specifying `mode=NURBS` a Non-Uniform Rational BSpline geometry is
+    created to map a regular domain onto the desired shape. Either mode supports
+    sub-parameters which can be specified from the command-line by attaching them
+    in curly braces (e.g. `FCM{nelems=20,degree=1}`).
+
+    Parameters
+    ----------
+    mode
+        Discretization strategy: FCM (Finite Cell Method) or NURBS.
+    radius
+        Cut-out radius.
+    traction
+        Far field traction (relative to Young's modulus).
+    poisson
+        Poisson's ratio, nonnegative and strictly smaller than 1/2.
     '''
 
     topo, geom, basis, degree = mode.generate(radius)
 
     ns = Namespace()
     ns.δ = function.eye(topo.ndims)
     ns.x = geom
     ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
     ns.λ = 2 * poisson
     ns.μ = 1 - poisson
-    ns.ubasis = basis.vector(2)
-    ns.u = function.dotarg('u', ns.ubasis)
+    ns.add_field(('u', 'v'), basis, shape=(2,))
     ns.X_i = 'x_i + u_i'
     ns.ε_ij = '(∇_j(u_i) + ∇_i(u_j)) / 2'
     ns.σ_ij = 'λ ε_kk δ_ij + 2 μ ε_ij'
     ns.r2 = 'x_k x_k'
     ns.R2 = radius**2 / ns.r2
     ns.k = (3-poisson) / (1+poisson) # plane stress parameter
     ns.scale = traction * (1+poisson) / 2
@@ -103,95 +137,79 @@
 
     sqr = topo.boundary['sym'].integral('(u_i n_i)^2 dS' @ ns, degree=degree*2)
     cons = solver.optimize(('u',), sqr, droptol=1e-15)
 
     sqr = topo.boundary['far'].integral('du_k du_k dS' @ ns, degree=20)
     cons = solver.optimize(('u',), sqr, droptol=1e-15, constrain=cons)
 
-    res = topo.integral('∇_j(ubasis_ni) σ_ij dV' @ ns, degree=degree*2)
-    args = solver.solve_linear(('u',), (res,), constrain=cons)
+    res = topo.integral('∇_j(v_i) σ_ij dV' @ ns, degree=degree*2)
+    args = solver.solve_linear('u:v', res, constrain=cons)
 
     bezier = topo.sample('bezier', 5)
     X, σxx = bezier.eval(['X_i', 'σ_00'] @ ns, **args)
     export.triplot('stressxx.png', X, σxx, tri=bezier.tri, hull=bezier.hull, clim=(numpy.nanmin(σxx), numpy.nanmax(σxx)), cmap='jet')
 
     err = numpy.sqrt(topo.integrate(['du_k du_k dV', '∇_j(du_i) ∇_j(du_i) dV'] @ ns, degree=max(degree, 3)*2, arguments=args))
     log.user('errors: L2={:.2e}, H1={:.2e}'.format(*err))
 
     return err, cons, args
 
-# If the script is executed (as opposed to imported), :func:`nutils.cli.run`
-# calls the main function with arguments provided from the command line. For
-# example, to keep with the default arguments simply run :sh:`python3
-# platewithhole.py`. To select mixed elements and quadratic basis functions add
-# :sh:`python3 platewithhole.py etype=mixed degree=2`.
-
-
-if __name__ == '__main__':
-    cli.run(main)
-
-# Once a simulation is developed and tested, it is good practice to save a few
-# strategic return values for regression testing. The :mod:`nutils.testing`
-# module, which builds on the standard :mod:`unittest` framework, facilitates
-# this by providing :func:`nutils.testing.TestCase.assertAlmostEqual64` for the
-# embedding of desired results as compressed base64 data.
-
 
 class test(testing.TestCase):
 
     def test_spline(self):
-        err, cons, args = main(mode=FCM(nelems=4, etype='square', btype='spline', degree=2, maxrefine=2), traction=.1, radius=.5, poisson=.3)
+        err, cons, args = main(mode=FCM(nelems=4, btype='spline'))
         with self.subTest('l2-error'):
             self.assertAlmostEqual(err[0], .00033, places=5)
         with self.subTest('h1-error'):
-            self.assertAlmostEqual(err[1], .00672, places=5)
+            self.assertAlmostEqual(err[1], .00674, places=5)
         with self.subTest('constraints'):
             self.assertAlmostEqual64(cons['u'], '''
                 eNpjaGBoYGBAxvrnGBow4X89g3NQFSjQwLAGq7i10Wus4k+NfM8fNWZgOGL89upc47WX0ozvXjAzPn1e
                 1TjnPACrACoJ''')
         with self.subTest('left-hand side'):
             self.assertAlmostEqual64(args['u'], '''
-                eNpbZHbajIHhxzkGBhMgtgdi/XPypyRPvjFxO/PccPq5Vn2vcxr6luf+6xmcm2LMwLDQePf5c0bTzx8x
-                5D7vaTjnnIFhzbmlQPH5xhV39Y3vXlxtJHoh2EjvvLXR63MbgOIbjRdfrTXeecnUeO+Fn0Yrzj818j1/
-                FCh+xPjt1bnGay+lGd+9YGZ8+ryqcc55AK+AP/0=''')
+                eNpbb3bMjIHhxzkGBhMgtgdi/XMqp8RPvjLxOPPCcNq5Fn3Pcxr6luf+6xmcm2LMwLDQePf5c0bTzx8x
+                5DnvaTjnnIFhzbmlQPH5xgvu6hvfvbjaSPRCsJHeeWuj1+c2AMU3Gi++Wmu885Kp8d4LP41WnH9q5Hv+
+                KFD8iPHbq3ON115KM757wcz49HlV45zzAL8gQC8=''')
 
     def test_mixed(self):
-        err, cons, args = main(mode=FCM(nelems=4, etype='mixed', btype='std', degree=2, maxrefine=2), traction=.1, radius=.5, poisson=.3)
+        err, cons, args = main(mode=FCM(nelems=4, etype='mixed'))
         with self.subTest('l2-error'):
             self.assertAlmostEqual(err[0], .00024, places=5)
         with self.subTest('h1-error'):
-            self.assertAlmostEqual(err[1], .00739, places=5)
+            self.assertAlmostEqual(err[1], .00740, places=5)
         with self.subTest('constraints'):
             self.assertAlmostEqual64(cons['u'], '''
                 eNpjaGDADhlwiOEU1z8HZusbgukkg5BzRJqKFRoa1oD1HzfceA5NH9FmgKC10SuwOdONpM7DxDYa77gM
                 MueoMQPDEePzV2Hic42XXmoynnQRxvc3dryQbnz3Aoj91Mj3vJnx6fOqxjnnAQzkV94=''')
         with self.subTest('left-hand side'):
             self.assertAlmostEqual64(args['u'], '''
-                eNoNzE8og3EcBvC3uUo5rNUOnBSK9/19n0Ic0Eo5oJBmRxcaB04kUnPgoETmT2w7LVrtMBy4auMw+35/
-                7/vaykFSFEopKTnIe/jU01PPU6FNWcQIn+Or5CBfSqCGD1uDYhi7/KbW+dma5aK65gX6Y8Po8HSzZQ7y
-                vBniHyvFV9aq17V7TK42O9kwFS9YUzxhjXIcZxLCnIzjTsfxah/BMFJotjUlZYz6xYeoPqEPKaigbKhb
-                9lOj9NGa9KgtVmqJH9UT36gcp71dEr6HaVS5GS8f46AcQ9itx739SQXdBL8dRqeTo1odox35poh2yJVh
-                apEueucsRWWPgpJFoLKPNzeHC/fU+yl48pDyMi6dCFbsBNJODNu2iawOoE4PoVdP4kH/UkZeaEDaUJQG
-                zMg/DouRUg==''')
+                eNoNzEEoQ3EcB/AXVymHtdqBkyLx3v/3LTQHtHJQKKHZ0YXMQS6sSM2BcrKMqbHTotUOw4GrthzWfr//
+                e6+nHJYUyUopKSnlHT717Vvfr0cpSWCWr/FVs1GuZdHKmb6QGMYRN9Qev1irXFUVTtAfG8agb5gtc5LX
+                zQj/WDm+s3b8bsBncosZZsNUvGEt8YI1w2lcSQRrMg9Pp/FmZ2EYOfTYmnIyR+PShLi+oA8pq5DsqxoH
+                qEvGaFdG1AErtclP6pnvVYnz/u4MVj2OZrfg53OceElE3Q482p9U0d0I2FGEnRK16SQdyjfFtEOuTFOv
+                DFGDi7QsxxSSIoIPGby7Jdy4l/5PxVeGeFu4dWLYtk+Rd5JI2SaKOoh2PYVRvYi6/qWCvNKE9KMqnViR
+                fyhZkYI=''')
 
     def test_nurbs0(self):
-        err, cons, args = main(mode=NURBS(nrefine=0), traction=.1, radius=.5, poisson=.3)
+        err, cons, args = main(mode=NURBS(nrefine=0))
         with self.subTest('l2-error'):
             self.assertAlmostEqual(err[0], .00200, places=5)
         with self.subTest('h1-error'):
             self.assertAlmostEqual(err[1], .02271, places=5)
         with self.subTest('constraints'):
             self.assertAlmostEqual64(cons['u'], '''
                 eNpjYGBoQIIggMZXOKdmnHRe3vjh+cvGDAwA6w0LgQ==''')
         with self.subTest('left-hand side'):
             self.assertAlmostEqual64(args['u'], '''
                 eNpjYJh07qLhhnOTjb0vTDdmAAKVcy/1u85lGYforQDzFc6pGSedlzd+eP4ykA8AvkQRaA==''')
 
     def test_nurbs2(self):
-        err, cons, args = main(mode=NURBS(nrefine=2), traction=.1, radius=.5, poisson=.3)
+        err, cons, args = main(mode=NURBS(nrefine=2))
         with self.subTest('l2-error'):
             self.assertAlmostEqual(err[0], .00009, places=5)
         with self.subTest('h1-error'):
             self.assertAlmostEqual(err[1], .00286, places=5)
         with self.subTest('constraints'):
             self.assertAlmostEqual64(cons['u'], '''
                 eNpjYGBoIAKCwCBXp3kuysDjnLXR+3NPjTzPqxrnAnHeeQvjk+dTjZ9d2GG85soJYwYGAPkhPtE=''')
@@ -199,8 +217,14 @@
             self.assertAlmostEqual64(args['u'], '''
                 eNpjYOg890mv85yM4axz0kYHz+00Yj6vZJxzPtWY+0KPMffFucaml+caMwBB5LlCvYhzCw0qzu0wPHyu
                 0sjlPIsx14VoY/6LvcaxlxYZz7myCKzO+dwWPZdzBwzqz20z/Hguxmj2+TtGHRdsjHdfbDB2v7zUeMXV
                 pWB1VucC9B3OORmuOCdhZHR+ktGu87eNbC6oGstfLDA+eWm1seG19WB1Buf+6ruce2p469wco9Dzb4wm
                 n2c23nZe3djqQqpx88XNxrOv7gOr0zwXZeBxztro/bmnRp7nVY1zgTjvvIXxSaBfnl3YYbzmygmgOgDU
                 Imlr''')
 
+
+if __name__ == '__main__':
+    from nutils import cli
+    cli.run(main)
+
+
 # example:tags=elasticity,FCM,NURBS
```

### Comparing `nutils-7.3/examples/poisson.py` & `nutils-8.0/examples/poisson.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-# Poisson's equation on a unit square
-#
-# In this script we solve Poisson's equation `Δu = 1` subject to boundary
-# constraints, using the fact that the solution to the strong form minimizes
-# the functional `∫ .5 ‖∇u‖² - u`. The domain is a unit square, and the
-# solution is constrained to zero along the entire boundary.
+from nutils import mesh, function, solver, export, testing
 
-from nutils import mesh, function, solver, export, cli, testing
+# This script demonstrates direct function manipulation without the aid of
+# namespace expressions.
 
 
-def main(nelems: int):
-    '''
-    Poisson's equation on a unit square.
+def main(nelems: int = 32):
+    '''Poisson's equation on a unit square
 
-    .. arguments::
+    Solves Poisson's equation `Δu = 1` subject to boundary constraints, using
+    the fact that the solution to the strong form minimizes the functional `∫
+    .5 ‖∇u‖² - u`. The domain is a unit square, and the solution is constrained
+    to zero along the entire boundary.
 
-       nelems [32]
-         Number of elements along edge.
+    Parameters
+    ----------
+    nelems
+        Number of elements along edge.
     '''
 
     topo, x = mesh.unitsquare(nelems, etype='square')
     u = function.dotarg('u', topo.basis('std', degree=1))
     g = u.grad(x)
     J = function.J(x)
 
@@ -32,31 +32,22 @@
     bezier = topo.sample('bezier', 3)
     x, u = bezier.eval([x, u], **args)
     export.triplot('u.png', x, u, tri=bezier.tri, cmap='jet')
 
     return args
 
 
-# If the script is executed (as opposed to imported), :func:`nutils.cli.run`
-# calls the main function with arguments provided from the command line. To
-# keep with the default arguments simply run :sh:`python3 poisson.py`.
-
-
-if __name__ == '__main__':
-    cli.run(main)
-
-# Once a simulation is developed and tested, it is good practice to save a few
-# strategic return values for regression testing. The :mod:`nutils.testing`
-# module, which builds on the standard :mod:`unittest` framework, facilitates
-# this by providing :func:`nutils.testing.TestCase.assertAlmostEqual64` for the
-# embedding of desired results as compressed base64 data.
-
-
 class test(testing.TestCase):
 
-    def test_default(self):
+    def test_simple(self):
         args = main(nelems=10)
         self.assertAlmostEqual64(args['u'], '''
             eNp9zrENwCAMBEBGYQJ444o2ozAAYgFmYhLEFqxAmye1FUtf+PSy7Jw9J6yoKGiMYsUTrq44kaVKZ7JM
             +lWlDdlymEFXXC2o3H1C8mmzXz5t6OwhPfTDO+2na9+1f7D/teYFdsk5vQ==''')
 
+
+if __name__ == '__main__':
+    from nutils import cli
+    cli.run(main)
+
+
 # example:tags=Poisson's equation
```

### Comparing `nutils-7.3/nutils/__init__.py` & `nutils-8.0/nutils/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,16 +3,16 @@
 import sys
 import numpy
 from distutils.version import LooseVersion
 
 assert sys.version_info >= (3, 5)
 assert LooseVersion(numpy.version.version) >= LooseVersion('1.16'), 'nutils requires numpy 1.16 or higher, got {}'.format(numpy.version.version)
 
-__version__ = version = '7.3'
-version_name = 'hiyamugi'
+__version__ = version = '8.0'
+version_name = 'idiyappam'
 long_version = ('{} "{}"' if version_name else '{}').format(version, version_name)
 
 __all__ = [
     'cache',
     'cli',
     'element',
     'elementseq',
@@ -32,12 +32,11 @@
     'sparse',
     'testing',
     'topology',
     'transform',
     'transformseq',
     'types',
     'unit',
-    'util',
     'warnings',
 ]
 
 # vim:sw=2:sts=2:et
```

### Comparing `nutils-7.3/nutils/_graph.py` & `nutils-8.0/nutils/_graph.py`

 * *Files 9% similar despite different names*

```diff
@@ -24,46 +24,46 @@
         self.subgraph = subgraph
 
     @abc.abstractmethod
     def __bool__(self) -> bool:
         raise NotImplementedError  # pragma: no cover
 
     @abc.abstractmethod
-    def _generate_asciitree_nodes(self, cache: MutableMapping['Node[Metadata]', str], subgraph_ids: Mapping[Optional[Subgraph], str], id_gen: Iterator[str], select: str, bridge: str) -> Generator[str, None, None]:
+    def _generate_asciitree_nodes(self, cache: MutableMapping['Node[Metadata]', str], id_gen_map: Mapping[Optional[Subgraph], Iterator[str]], select: str, bridge: str) -> Generator[str, None, None]:
         raise NotImplementedError  # pragma: no cover
 
     @abc.abstractmethod
     def _collect_graphviz_nodes_edges(self, cache: MutableMapping['Node[Metadata]', str], id_gen: Iterator[str], nodes: MutableMapping[Optional[Subgraph], List[str]], edges: List[str], parent_subgraph: Optional[Subgraph], fill_color: Optional[GraphvizColorCallback] = None) -> Optional[str]:
         raise NotImplementedError  # pragma: no cover
 
     def walk(self, seen: MutableSet['Node[Metadata]']) -> Iterator['Node[Metadata]']:
         raise NotImplementedError  # pragma: no cover
 
     def generate_asciitree(self, richoutput: bool = False) -> str:
         subgraph_children = _collect_subgraphs(self)
         if len(subgraph_children) > 1:
-            subgraph_ids = {}  # type: Dict[Optional[Subgraph], str]
-            parts = ['SUBGRAPHS\n'], _generate_asciitree_subgraphs(subgraph_children, subgraph_ids, None, '', ''), ['NODES\n']  # type: Sequence[Iterable[str]]
+            id_gen_map = {}  # type: Dict[Optional[Subgraph], Iterator[str]]
+            parts = ['SUBGRAPHS\n'], _generate_asciitree_subgraphs(subgraph_children, id_gen_map, None, '', ''), ['NODES\n']  # type: Sequence[Iterable[str]]
         else:
-            subgraph_ids = {None: ''}
+            id_gen_map = {None: (f'%{i}' for i in itertools.count())}
             parts = []
-        asciitree = ''.join(itertools.chain(*parts, self._generate_asciitree_nodes({}, subgraph_ids, map(str, itertools.count()), '', '')))
+        asciitree = ''.join(itertools.chain(*parts, self._generate_asciitree_nodes({}, id_gen_map, '', '')))
         if not richoutput:
             asciitree = asciitree.replace('├', ':').replace('└', ':').replace('│', '|')
         return asciitree
 
     def generate_graphviz_source(self, *, fill_color: Optional[GraphvizColorCallback] = None) -> str:
         edges = []  # type: List[str]
         nodes = {}  # type: Dict[Optional[Subgraph], List[str]]
         subgraph_children = _collect_subgraphs(self)
         id_gen = map(str, itertools.count())
         self._collect_graphviz_nodes_edges({}, id_gen, nodes, edges, None, fill_color)
-        return ''.join(itertools.chain(['digraph {graph [dpi=72];'], _generate_graphviz_subgraphs(subgraph_children, nodes, None, id_gen), edges, ['}']))
+        return ''.join(itertools.chain(['digraph {bgcolor="darkgray";'], _generate_graphviz_subgraphs(subgraph_children, nodes, None, id_gen), edges, ['}']))
 
-    def export_graphviz(self, *, fill_color: Optional[GraphvizColorCallback] = None, dot_path: str = 'dot', image_type: str = 'png') -> None:
+    def export_graphviz(self, *, fill_color: Optional[GraphvizColorCallback] = None, dot_path: str = 'dot', image_type: str = 'svg') -> None:
         src = self.generate_graphviz_source(fill_color=fill_color)
         with treelog.infofile('dot.'+image_type, 'wb') as img:
             src = src.replace(';', ';\n')
             status = subprocess.run([dot_path, '-Gstart=1', '-T'+image_type], input=src.encode(), stdout=subprocess.PIPE)
             if status.returncode:
                 for i, line in enumerate(src.split('\n'), 1):
                     print('{:04d}  {}'.format(i, line))
@@ -78,24 +78,23 @@
         self._args = tuple(args)
         self._kwargs = dict(kwargs)
         super().__init__(metadata, subgraph)
 
     def __bool__(self) -> bool:
         return True
 
-    def _generate_asciitree_nodes(self, cache: MutableMapping[Node[Metadata], str], subgraph_ids: Mapping[Optional[Subgraph], str], id_gen: Iterator[str], select: str, bridge: str) -> Generator[str, None, None]:
+    def _generate_asciitree_nodes(self, cache: MutableMapping[Node[Metadata], str], id_gen_map: Mapping[Optional[Subgraph], str], select: str, bridge: str) -> Generator[str, None, None]:
         if self in cache:
             yield '{}{}\n'.format(select, cache[self])
         else:
-            subgraph_id = subgraph_ids[self.subgraph]
-            cache[self] = id = '%{}{}'.format(subgraph_id, next(id_gen))
+            cache[self] = id = next(id_gen_map[self.subgraph])
             yield '{}{} = {}\n'.format(select, id, self._label.replace('\n', '; '))
             args = tuple(('', arg) for arg in self._args if arg) + tuple(('{} = '.format(name), arg) for name, arg in self._kwargs.items())
             for i, (prefix, arg) in enumerate(args, 1-len(args)):
-                yield from arg._generate_asciitree_nodes(cache, subgraph_ids, id_gen, bridge+('├ ' if i else '└ ')+prefix, bridge+('│ ' if i else '  '))
+                yield from arg._generate_asciitree_nodes(cache, id_gen_map, bridge+('├ ' if i else '└ ')+prefix, bridge+('│ ' if i else '  '))
 
     def _collect_graphviz_nodes_edges(self, cache: MutableMapping[Node[Metadata], str], id_gen: Iterator[str], nodes: MutableMapping[Optional[Subgraph], List[str]], edges: List[str], parent_subgraph: Optional[Subgraph], fill_color: Optional[GraphvizColorCallback] = None) -> Optional[str]:
         if self in cache:
             return cache[self]
         cache[self] = id = next(id_gen)
         if self._kwargs:
             table = ['<TABLE BORDER="1" CELLBORDER="0" CELLSPACING="0">']
@@ -133,15 +132,15 @@
     def __init__(self, label: str, metadata: Metadata) -> None:
         self._label = label
         super().__init__(metadata)
 
     def __bool__(self) -> bool:
         return True
 
-    def _generate_asciitree_nodes(self, cache: MutableMapping[Node[Metadata], str], subgraph_ids: Mapping[Optional[Subgraph], str], id_gen: Iterator[str], select: str, bridge: str) -> Generator[str, None, None]:
+    def _generate_asciitree_nodes(self, cache: MutableMapping[Node[Metadata], str], id_gen_map: Mapping[Optional[Subgraph], str], select: str, bridge: str) -> Generator[str, None, None]:
         yield '{}{}\n'.format(select, self._label.replace('\n', '; '))
 
     def _collect_graphviz_nodes_edges(self, cache: MutableMapping[Node[Metadata], str], id_gen: Iterator[str], nodes: MutableMapping[Optional[Subgraph], List[str]], edges: List[str], parent_subgraph: Optional[Subgraph], fill_color: Optional[GraphvizColorCallback] = None) -> Optional[str]:
         id = next(id_gen)
         attributes = ['shape=box', 'label="{}"'.format(self._label.replace('"', '\\"')), *_graphviz_fill_color_attributes(self, fill_color)]
         nodes.setdefault(parent_subgraph, []).append('{} [{}];'.format(id, ','.join(attributes)))
         return id
@@ -157,15 +156,15 @@
 
     def __init__(self, metadata: Metadata) -> None:
         super().__init__(metadata)
 
     def __bool__(self) -> bool:
         return False
 
-    def _generate_asciitree_nodes(self, cache: MutableMapping[Node[Metadata], str], subgraph_ids: Mapping[Optional[Subgraph], str], id_gen: Iterator[str], select: str, bridge: str) -> Generator[str, None, None]:
+    def _generate_asciitree_nodes(self, cache: MutableMapping[Node[Metadata], str], id_gen_map: Mapping[Optional[Subgraph], str], select: str, bridge: str) -> Generator[str, None, None]:
         yield '{}\n'.format(select)
 
     def _collect_graphviz_nodes_edges(self, cache: MutableMapping[Node[Metadata], str], id_gen: Iterator[str], nodes: MutableMapping[Optional[Subgraph], List[str]], edges: List[str], parent_subgraph: Optional[Subgraph], fill_color: Optional[GraphvizColorCallback] = None) -> Optional[str]:
         return None
 
     def walk(self, seen: MutableSet[Node[Metadata]]) -> Iterator[Node[Metadata]]:
         if self in seen:
@@ -193,24 +192,25 @@
                 children[subgraph.parent] = [subgraph]
                 subgraph = subgraph.parent
             subgraph = typing.cast(Subgraph, subgraph)
             children[subgraph.parent].append(subgraph)
     return children
 
 
-def _generate_asciitree_subgraphs(children: Mapping[Optional[Subgraph], Sequence[Subgraph]], subgraph_ids: MutableMapping[Optional[Subgraph], str], subgraph: Optional[Subgraph], select: str, bridge: str) -> Iterator[str]:
-    assert subgraph not in subgraph_ids
-    subgraph_ids[subgraph] = id = chr(ord('A') + len(subgraph_ids))
+def _generate_asciitree_subgraphs(children: Mapping[Optional[Subgraph], Sequence[Subgraph]], id_gen_map: MutableMapping[Optional[Subgraph], Iterator[str]], subgraph: Optional[Subgraph], select: str, bridge: str) -> Iterator[str]:
+    assert subgraph not in id_gen_map
+    id = chr(ord('A') + len(id_gen_map))
+    id_gen_map[subgraph] = (f'%{id}{i}' for i in itertools.count())
     if subgraph:
         yield '{}{} = {}\n'.format(select, id, subgraph.label.replace('\n', '; '))
     else:
         yield '{}{}\n'.format(select, id)
     for i, child in enumerate(children[subgraph], 1-len(children[subgraph])):
-        yield from _generate_asciitree_subgraphs(children, subgraph_ids, child, bridge+('├ ' if i else '└ '), bridge+('│ ' if i else '  '))
+        yield from _generate_asciitree_subgraphs(children, id_gen_map, child, bridge+('├ ' if i else '└ '), bridge+('│ ' if i else '  '))
 
 
 def _generate_graphviz_subgraphs(children: Mapping[Optional[Subgraph], Sequence[Subgraph]], nodes: Mapping[Optional[Subgraph], Sequence[str]], subgraph: Optional[Subgraph], id_gen: Iterator[str]) -> Iterator[str]:
     for child in children[subgraph]:
-        yield 'subgraph cluster{} {{'.format(next(id_gen))
+        yield 'subgraph cluster{} {{bgcolor="lightgray";color="none";'.format(next(id_gen))
         yield from _generate_graphviz_subgraphs(children, nodes, child, id_gen)
         yield '}'
     yield from nodes.get(subgraph, ())
```

### Comparing `nutils-7.3/nutils/cache.py` & `nutils-8.0/nutils/cache.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 """
 The cache module.
 """
 
-from . import types, util
+from . import types, _util as util
 import os
 import numpy
 import functools
 import inspect
 import builtins
 import pathlib
 import pickle
 import itertools
 import hashlib
 import abc
 import contextlib
 import treelog as log
+import appdirs
 
 
 class Wrapper:
     'function decorator that caches results by arguments'
 
     def __init__(self, func):
         self.func = func
@@ -68,32 +69,35 @@
             else 'effectivity {}% (hit {}/{} calls over {} functions)'.format(100*hits/count, hits, count, len(self.cache))
 
     @property
     def __nutils_hash__(self):
         return hashlib.sha1(b'nutils.cache.WrapperCache\0').digest()
 
 
-_cache = util.settable()
+@util.set_current
+@util.defaults_from_env
+def caching(cache: bool = False, cachedir: str = appdirs.user_cache_dir('nutils', 'evalf')):
+    return pathlib.Path(cachedir).expanduser() if cache else None
 
 
 def enable(cachedir: str):
     '''
     Enable cacheing and set the cache directory to ``cachedir``.  Affects
     functions decorated with :func:`function` and subclasses of
     :class:`Recursion`.
     '''
-    return _cache.sets(pathlib.Path(cachedir))
+    return caching(True, pathlib.Path(cachedir))
 
 
 def disable():
     '''
     Disable cacheing.  Affects functions decorated with :func:`function` and
     subclasses of :class:`Recursion`.
     '''
-    return _cache.sets(None)
+    return caching(False)
 
 # Define platform-dependent `_lock_file` function.
 
 
 def _lock_file_fallback(f): pass
 
 
@@ -175,26 +179,26 @@
     # Hash of the full function name (closest thing to a unique representation of
     # `func`).
     func_key = hashlib.sha1('{}.{}:{}'.format(func.__module__, func.__qualname__, version).encode()).digest()
     canonicalize = types.argument_canonicalizer(inspect.signature(func))
 
     @functools.wraps(func)
     def wrapper(*args, **kwargs):
-        if _cache.value is None:
+        if caching.current is None:
             return func(*args, **kwargs)
         args, kwargs = canonicalize(*args, **kwargs)
         # Hash the function key and the canonicalized arguments and compute the
         # hexdigest.  This is used to identify cache file `cachefile`.
         h = hashlib.sha1(func_key)
         for arg in args:
             h.update(types.nutils_hash(arg))
         for hkv in sorted(hashlib.sha1(k.encode()).digest()+types.nutils_hash(v) for k, v in kwargs.items()):
             h.update(hkv)
         hkey = h.hexdigest()
-        cachefile = _cache.value/hkey
+        cachefile = caching.current/hkey
         # Open and lock `cachefile`.  Try to read it and, if successful, unlock
         # the file (implicitly by closing the file) and return the value.  If
         # reading fails, e.g. because the file did not exist, call `func`, store
         # the result, unlock and return.  While not necessary per se, we lock the
         # file immediately to avoid checking twice if there is a cached value: once
         # before locking the file, and once after locking, at which point another
         # party may have written something to the cache already.
@@ -324,22 +328,22 @@
     8
     '''
 
     __slots__ = ()
 
     def __iter__(self):
         length = type(self).length
-        if _cache.value is None:
+        if caching.current is None:
             yield from self.resume_index([], 0)
         else:
             # The hash of `types.Immutable` uniquely defines this `Recursion`, so use
             # this to identify the cache directory.  All iterations are stored as
             # separate files, numbered '0000', '0001', ..., in this directory.
             hkey = self.__nutils_hash__.hex()
-            cachepath = _cache.value / hkey
+            cachepath = caching.current / hkey
             cachepath.mkdir(exist_ok=True, parents=True)
             log.debug('[cache.Recursion {}] start iterating'.format(hkey))
             # The `history` variable is updated while reading from the cache and
             # truncated to the required length.
             history = []
             # The `exhausted` variable controls if we are reading items from the
             # cache (`False`) or we are computing values and writing to the cache.
@@ -399,8 +403,8 @@
         '''
         Resume recursion from ``history``.
 
         .. Note:: This function is abstract.
         '''
         raise NotImplementedError
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/element.py` & `nutils-8.0/nutils/element.py`

 * *Files 7% similar despite different names*

```diff
@@ -4,41 +4,85 @@
 objects like the :class:`MosaicReference`. A set of (interconnected) elements
 together form a :class:`nutils.topology.Topology`. Elements have edges and
 children (for refinement), which are in turn elements and map onto self by an
 affine transformation. They also have a well defined reference coordinate
 system, and provide pointsets for purposes of integration and sampling.
 """
 
-from . import util, numeric, cache, transform, warnings, types, points
+from . import _util as util, numeric, cache, transform, warnings, types, points
+from ._backports import cached_property
+from typing import Tuple
+from numbers import Integral
+import nutils_poly as poly
 import numpy
 import re
 import math
 import itertools
 import operator
 import functools
 _ = numpy.newaxis
 
 
 # REFERENCE ELEMENTS
 
 class Reference(types.Singleton):
-    'reference element'
+    '''Reference element.
 
-    __slots__ = 'ndims',
-    __cache__ = 'connectivity', 'edgechildren', 'ribbons', 'volume', 'centroid', '_linear_bernstein', 'getpoints'
+    .. py:attribute:: vertices
 
-    @types.apply_annotations
-    def __init__(self, ndims: int):
+       Array of shape ``nverts x ndims`` that defines the coordinates of the
+       element's vertices.
+
+    .. py:attribute:: edge_vertices
+
+       Sequence of integer arrays that specifies per edge (outer sequence,
+       corresponding to ``edges``) for each vertex (inner sequence,
+       corresponding to ``edges[iedge].vertices``) its index in ``vertices``.
+    '''
+
+    def __init__(self, ndims: Integral):
+        assert isinstance(ndims, Integral), f'ndims={ndims!r}'
         super().__init__()
         self.ndims = ndims
 
     @property
     def nverts(self):
         return len(self.vertices)
 
+    @property
+    def simplices(self):
+        '''Partition of the element consisting of simplices.
+
+        The `simplices` attribute is a sequence of integer arrays that specify
+        per simplex the indices of the vertices in :attr:`vertices`.
+        '''
+
+        raise NotImplementedError(self)
+
+    @property
+    def simplex_transforms(self):
+        '''Sequence of transforms from simplex to parent element.
+
+        The `simplex_transforms` attribute is a sequence of objects of type
+        :class:`nutils.transform.TransformItem` that provide per simplex the
+        coordinate mapping from the simplex to the parent element. The origin
+        of the simplex-local coordinate system maps to its first vertex, the
+        first unit vector to the second, the second to the third, and so on.
+        '''
+
+        return tuple(transform.simplex(vertices) for vertices in self.vertices[self.simplices])
+
+    def inside(self, point, eps=0):
+        for strans in self.simplex_transforms:
+            spoint = strans.invapply(point) # point in simplex coordinates
+            tol = -eps / strans.det # account for simplex scale
+            if all(bary >= tol for bary in (*spoint, 1-spoint.sum())):
+                return True
+        return False
+
     __and__ = lambda self, other: self if self == other else NotImplemented
     __or__ = lambda self, other: self if self == other else NotImplemented
     __rand__ = lambda self, other: self.__and__(other)
     __ror__ = lambda self, other: self.__or__(other)
     __sub__ = __rsub__ = lambda self, other: self.empty if self == other else NotImplemented
     __bool__ = __nonzero__ = lambda self: bool(self.volume)
 
@@ -74,15 +118,15 @@
     def edges(self):
         return list(zip(self.edge_transforms, self.edge_refs))
 
     @property
     def children(self):
         return list(zip(self.child_transforms, self.child_refs))
 
-    @property
+    @cached_property
     def connectivity(self):
         # Nested tuple with connectivity information about edges of children:
         # connectivity[ichild][iedge] = ioppchild (interface) or -1 (boundary).
         connectivity = [-numpy.ones(child.nedges, dtype=int) for child in self.child_refs]
         vmap = {}
         for ichild, (ctrans, cref) in enumerate(self.children):
             for iedge, etrans in enumerate(cref.edge_transforms):
@@ -96,145 +140,129 @@
                     connectivity[ichild][iedge] = jchild
         for etrans, eref in self.edges:
             for ctrans in eref.child_transforms:
                 vmap.pop(etrans * ctrans, None)
         assert not any(self.child_refs[ichild].edge_refs[iedge] for ichild, iedge in vmap.values()), 'not all boundary elements recovered'
         return tuple(types.frozenarray(c, copy=False) for c in connectivity)
 
-    @property
+    @cached_property
     def edgechildren(self):
         edgechildren = []
         for iedge, (etrans, eref) in enumerate(self.edges):
             children = []
             for ichild, ctrans in enumerate(eref.child_transforms):
                 ctrans_, etrans_ = etrans.swapup(ctrans)
                 ichild_ = self.child_transforms.index(ctrans_)
                 iedge_ = self.child_refs[ichild].edge_transforms.index(etrans_)
                 children.append((ichild_, iedge_))
             edgechildren.append(types.frozenarray(children))
         return tuple(edgechildren)
 
-    @property
-    def ribbons(self):
-        # tuples of (iedge1,jedge1), (iedge2,jedge2) pairs
-        assert self.ndims >= 2
-        transforms = {}
-        ribbons = []
-        for iedge1, (etrans1, edge1) in enumerate(self.edges):
-            if edge1:
-                for iedge2, (etrans2, edge2) in enumerate(edge1.edges):
-                    if edge2:
-                        key = tuple(sorted(tuple(p) for p in (etrans1 * etrans2).apply(edge2.vertices)))
-                        try:
-                            jedge1, jedge2 = transforms.pop(key)
-                        except KeyError:
-                            transforms[key] = iedge1, iedge2
-                        else:
-                            assert self.edge_refs[jedge1].edge_refs[jedge2] == edge2
-                            ribbons.append(((iedge1, iedge2), (jedge1, jedge2)))
-        assert not transforms
-        return tuple(ribbons)
-
     def getischeme(self, ischeme):
         ischeme, degree = parse_legacy_ischeme(ischeme)
         points = self.getpoints(ischeme, degree)
         return points.coords, getattr(points, 'weights', None)
 
     def getpoints(self, ischeme, degree):
         if ischeme == '_centroid':
-            gauss = self.getpoints('gauss', 1)
-            if gauss.npoints == 1:
-                return gauss
-            volume = gauss.weights.sum()
-            return points.CoordsUniformPoints(gauss.coords.T[_] @ gauss.weights / volume, volume)
+            return self._getpoints_centroid
         raise Exception('unsupported ischeme for {}: {!r}'.format(self.__class__.__name__, ischeme))
 
+    @cached_property
+    def _getpoints_centroid(self):
+        gauss = self.getpoints('gauss', 1)
+        if gauss.npoints == 1:
+            return gauss
+        volume = gauss.weights.sum()
+        return points.CoordsUniformPoints(types.arraydata(gauss.coords.T[_] @ gauss.weights / volume), volume)
+
     def with_children(self, child_refs):
         child_refs = tuple(child_refs)
         if not any(child_refs):
             return self.empty
         if child_refs == self.child_refs:
             return self
         return WithChildrenReference(self, child_refs)
 
-    @property
+    @cached_property
     def volume(self):
         volume, = self.getpoints('_centroid', None).weights
         return volume
 
-    @property
+    @cached_property
     def centroid(self):
         centroid, = self.getpoints('_centroid', None).coords
         return centroid
 
     def trim(self, levels, maxrefine, ndivisions):
         'trim element along levelset'
 
-        assert len(levels) == self.nvertices_by_level(maxrefine)
+        assert len(levels) == self._nlinear_by_level(maxrefine)
         return self if not self or numpy.greater_equal(levels, 0).all() \
             else self.empty if numpy.less_equal(levels, 0).all() \
             else self.with_children(cref.trim(clevels, maxrefine-1, ndivisions)
                                     for cref, clevels in zip(self.child_refs, self.child_divide(levels, maxrefine))) if maxrefine > 0 \
-            else self.slice(lambda vertices: numeric.dot(numeric.poly_eval(self._linear_bernstein, vertices), levels), ndivisions)
+            else self.slice(poly.eval_outer(self._linear_bernstein, self.vertices) @ levels, ndivisions)
 
-    @property
+    @cached_property
     def _linear_bernstein(self):
         return self.get_poly_coeffs('bernstein', degree=1)
 
-    def slice(self, levelfunc, ndivisions):
+    def slice(self, levels, ndivisions):
         # slice along levelset by recursing over dimensions
 
-        levels = levelfunc(self.vertices)
-
-        assert numeric.isint(ndivisions)
-        assert len(levels) == self.nverts
+        assert len(levels) == len(self.vertices)
         if numpy.greater_equal(levels, 0).all():
             return self
         if numpy.less_equal(levels, 0).all():
             return self.empty
+        assert self.ndims >= 1
 
-        nbins = 2**ndivisions
+        refs = tuple(edgeref.slice(levels[edgeverts], ndivisions) for edgeverts, edgeref in zip(self.edge_vertices, self.edge_refs))
+        if sum(ref != baseref for ref, baseref in zip(refs, self.edge_refs)) < self.ndims:
+            return self
+        if sum(bool(ref) for ref in refs) < self.ndims:
+            return self.empty
 
         if self.ndims == 1:
 
-            l0, l1 = levels
+            # For 1D elements a midpoint is introduced through linear
+            # interpolation of the vertex levels, followed by a binning step to
+            # remove near-vertex cuts and improve robustness for topology-wide
+            # connectivity.
+
+            iedge = [i for (i,), edge in zip(self.edge_vertices, self.edge_refs) if edge]
+            l0, l1 = levels[iedge]
+            nbins = 2**ndivisions
             xi = numpy.round(l0/(l0-l1) * nbins)
             if xi in (0, nbins):
                 return self.empty if xi == 0 and l1 < 0 or xi == nbins and l0 < 0 else self
-            v0, v1 = self.vertices
+            v0, v1 = self.vertices[iedge]
             midpoint = v0 + (xi/nbins) * (v1-v0)
-            refs = [edgeref if levelfunc(edgetrans.apply(numpy.zeros((1, 0)))) > 0 else edgeref.empty for edgetrans, edgeref in self.edges]
 
         else:
 
-            refs = [edgeref.slice(lambda vertices: levelfunc(edgetrans.apply(vertices)), ndivisions) for edgetrans, edgeref in self.edges]
-            if sum(ref != baseref for ref, baseref in zip(refs, self.edge_refs)) <= 1:
-                return self
-            if sum(bool(ref) for ref in refs) <= 1:
-                return self.empty
-
-            clevel = levelfunc(self.centroid[_])[0]
-
-            select = clevel*levels <= 0 if clevel != 0 else levels != 0
-            levels = levels[select]
-            vertices = self.vertices[select]
-
-            xi = numpy.round(levels/(levels-clevel) * nbins)
-            midpoint = numpy.mean(vertices + (self.centroid-vertices)*(xi/nbins)[:, _], axis=0)
-
-        if tuple(refs) == tuple(self.edge_refs):
-            return self
-        if not any(refs):
-            return self.empty
-
-        mosaic = MosaicReference(self, refs, midpoint)
-        return self.empty if mosaic.volume == 0 else mosaic if mosaic.volume < self.volume else self
+            # For higher-dimensional elements, the first vertex that is newly
+            # introduced by an edge slice is selected to serve as 'midpoint'.
+            # In case no new vertices are introduced (all edges are either
+            # fully retained or fully removed) then the first vertex is
+            # selected that occurs in only one of the edges. Either situation
+            # guarantees that the selected vertex lies on the exterior hull.
+
+            for trans, edge, emap, newedge in zip(self.edge_transforms, self.edge_refs, self.edge_vertices, refs):
+                if newedge.nverts > edge.nverts:
+                    midpoint = trans.apply(newedge.vertices[edge.nverts])
+                    break
+            else:
+                count = numpy.zeros(self.nverts, dtype=int)
+                for emap, eref in zip(self.edge_vertices, refs):
+                    count[emap[eref.simplices]] += 1
+                midpoint = self.vertices[count==1][0]
 
-    def cone(self, trans, tip):
-        return Cone(self, trans, tip)
+        return MosaicReference(self, refs, types.arraydata(midpoint))
 
     def check_edges(self, tol=1e-15, print=print):
         volume = 0
         zero = 0
         for trans, edge in self.edges:
             if edge:
                 gauss = edge.getpoints('gauss', 1)
@@ -242,18 +270,18 @@
                 zero += w_normal.sum(0)
                 volume += numeric.contract(trans.apply(gauss.coords), w_normal, axis=0)
         if numpy.greater(abs(zero), tol).any():
             print('divergence check failed: {} != 0'.format(zero))
         if numpy.greater(abs(volume - self.volume), tol).any():
             print('divergence check failed: {} != {}'.format(volume, self.volume))
 
-    def vertex_cover(self, ctransforms, maxrefine):
+    def _linear_cover(self, ctransforms, maxrefine):
         if maxrefine < 0:
             raise Exception('maxrefine is too low')
-        npoints = self.nvertices_by_level(maxrefine)
+        npoints = self._nlinear_by_level(maxrefine)
         allindices = numpy.arange(npoints)
         if len(ctransforms) == 1:
             ctrans, = ctransforms
             assert not ctrans
             return ((), self.getpoints('vertex', maxrefine), allindices),
         if maxrefine == 0:
             raise Exception('maxrefine is too low')
@@ -262,15 +290,15 @@
             ichild = self.child_transforms.index(ctrans[0])
             cbins[ichild].add(ctrans[1:])
         if not all(cbins):
             raise Exception('transformations to not form an element cover')
         fcache = cache.WrapperCache()
         return tuple(((ctrans,) + trans, points, cindices[indices])
                      for ctrans, cref, cbin, cindices in zip(self.child_transforms, self.child_refs, cbins, self.child_divide(allindices, maxrefine))
-                     for trans, points, indices in fcache[cref.vertex_cover](frozenset(cbin), maxrefine-1))
+                     for trans, points, indices in fcache[cref._linear_cover](frozenset(cbin), maxrefine-1))
 
     def __str__(self):
         return self.__class__.__name__
 
     __repr__ = __str__
 
     def get_ndofs(self, degree):
@@ -279,38 +307,41 @@
     def get_poly_coeffs(self, basis, **kwargs):
         raise NotImplementedError
 
     def get_edge_dofs(self, degree, iedge):
         raise NotImplementedError
 
 
-strictreference = types.strict[Reference]
-
-
 class EmptyLike(Reference):
     'inverse reference element'
 
-    __slots__ = 'baseref',
-
     volume = 0
 
     @property
     def empty(self):
         return self
 
-    @types.apply_annotations
-    def __init__(self, baseref: strictreference):
+    def __init__(self, baseref: Reference):
+        assert isinstance(baseref, Reference), f'baseref={baseref!r}'
         self.baseref = baseref
         super().__init__(baseref.ndims)
 
     @property
     def vertices(self):
         return self.baseref.vertices
 
     @property
+    def edge_vertices(self):
+        return self.baseref.edge_vertices
+
+    @property
+    def simplices(self):
+        return types.frozenarray(numpy.empty([0, self.ndims+1], dtype=int), copy=False)
+
+    @property
     def edge_transforms(self):
         return self.baseref.edge_transforms
 
     @property
     def edge_refs(self):
         return tuple(eref.empty for eref in self.baseref.edge_refs)
 
@@ -325,182 +356,145 @@
     __and__ = __sub__ = lambda self, other: self if other.ndims == self.ndims else NotImplemented
     __or__ = lambda self, other: other if other.ndims == self.ndims else NotImplemented
     __rsub__ = lambda self, other: other if other.ndims == self.ndims else NotImplemented
 
     def trim(self, levels, maxrefine, ndivisions):
         return self
 
-    def inside(self, point, eps=0):
-        return False
-
 
 class SimplexReference(Reference):
     'simplex reference'
 
-    __slots__ = ()
-    __cache__ = 'edge_refs', 'edge_transforms', 'ribbons', '_get_poly_coeffs_bernstein', '_get_poly_coeffs_lagrange', '_integer_barycentric_coordinates'
-
     @property
     def vertices(self):
-        return types.frozenarray(numpy.concatenate([numpy.zeros(self.ndims)[_, :], numpy.eye(self.ndims)], axis=0), copy=False)
+        return types.frozenarray(numpy.eye(self.ndims+1)[1:].T, copy=False) # first vertex in origin
+
+    @cached_property
+    def edge_vertices(self):
+        return tuple(types.frozenarray(numpy.arange(self.ndims+1).repeat(self.ndims).reshape(self.ndims,self.ndims+1).T[::-1], copy=False))
 
     @property
+    def simplices(self):
+        return types.frozenarray(numpy.arange(self.ndims+1)[numpy.newaxis], copy=False)
+
+    @property
+    def simplex_transforms(self):
+        # The definition of self.vertices is such that the conventions of
+        # Reference.simplex_transforms result in the identity map.
+        return transform.Identity(self.ndims),
+
+    @cached_property
     def edge_refs(self):
         assert self.ndims > 0
         return (getsimplex(self.ndims-1),) * (self.ndims+1)
 
-    @property
+    @cached_property
     def edge_transforms(self):
         assert self.ndims > 0
         return tuple(transform.SimplexEdge(self.ndims, i) for i in range(self.ndims+1))
 
     @property
     def child_refs(self):
         return tuple([self] * (2**self.ndims))
 
     @property
     def child_transforms(self):
         return tuple(transform.SimplexChild(self.ndims, ichild) for ichild in range(2**self.ndims))
 
-    @property
-    def ribbons(self):
-        return tuple(((iedge1, iedge2), (iedge2+1, iedge1)) for iedge1 in range(self.ndims+1) for iedge2 in range(iedge1, self.ndims))
-
     def getpoints(self, ischeme, degree):
         if ischeme == 'gauss':
             return points.SimplexGaussPoints(self.ndims, degree if numeric.isint(degree) else sum(degree))
         if ischeme == 'vtk':
             return points.SimplexBezierPoints(self.ndims, 2)
         if ischeme == 'vertex':
             return points.SimplexBezierPoints(self.ndims, 2**(degree or 0) + 1)
         if ischeme == 'bezier':
             return points.SimplexBezierPoints(self.ndims, degree)
         return super().getpoints(ischeme, degree)
 
-    @property
-    def simplices(self):
-        return (transform.Identity(self.ndims), self),
-
     def get_ndofs(self, degree):
         prod = lambda start, stop: functools.reduce(operator.mul, range(start, stop), 1)
         return prod(degree+1, degree+1+self.ndims) // prod(1, self.ndims+1)
 
-    def get_poly_coeffs(self, basis, **kwargs):
-        f = getattr(self, '_get_poly_coeffs_{}'.format(basis), None)
-        if f:
-            return f(**kwargs)
+    def get_poly_coeffs(self, basis, degree):
+        if basis in _poly_coeffs:
+            return _poly_coeffs[basis](self.ndims, degree)
         else:
             raise ValueError('basis {!r} undefined on {}'.format(basis, type(self).__qualname__))
 
-    def _integer_barycentric_coordinates(self, degree):
-        return tuple(
-            (degree-sum(i), *i[::-1])
-            for i in itertools.product(*[range(degree+1)]*self.ndims)
-            if sum(i) <= degree)
-
-    def _get_poly_coeffs_bernstein(self, degree):
-        ndofs = self.get_ndofs(degree)
-        coeffs = numpy.zeros((ndofs,)+(degree+1,)*self.ndims)
-        for i, p in enumerate(self._integer_barycentric_coordinates(degree)):
-            p = p[1:]
-            for q in itertools.product(*[range(degree+1)]*self.ndims):
-                if sum(p+q) <= degree:
-                    coeffs[(i,)+tuple(map(operator.add, p, q))] = (-1)**sum(q)*math.factorial(degree)//util.product(map(math.factorial, (degree-sum(p+q), *p, *q)))
-        assert i == ndofs - 1
-        return types.frozenarray(coeffs, copy=False)
-
-    def _get_poly_coeffs_lagrange(self, degree):
-        if self.ndims == 0:
-            coeffs = numpy.ones((1,))
-        elif degree == 0:
-            coeffs = numpy.ones((1, *[1]*self.ndims))
-        else:
-            P = numpy.array(tuple(self._integer_barycentric_coordinates(degree)), dtype=int)[:, 1:]
-            coeffs_ = numpy.linalg.inv(((P[:, _, :]/degree)**P[_, :, :]).prod(-1))
-            coeffs = numpy.zeros((len(P), *[degree+1]*self.ndims), dtype=float)
-            for i, p in enumerate(P):
-                coeffs[(slice(None), *p)] = coeffs_[i]
-        return types.frozenarray(coeffs, copy=False)
-
     def get_edge_dofs(self, degree, iedge):
-        return types.frozenarray(tuple(i for i, j in enumerate(self._integer_barycentric_coordinates(degree)) if j[iedge] == 0), dtype=int)
-
-    def inside(self, point, eps=0):
-        return numpy.greater_equal(point, -eps).all(axis=0) and numpy.less_equal(numpy.sum(point, axis=0), 1+eps)
+        return types.frozenarray(tuple(i for i, j in enumerate(_integer_barycentric_coordinates(self.ndims, degree)) if j[iedge] == 0), dtype=int)
 
 
 class PointReference(SimplexReference):
     '0D simplex'
 
-    __slots__ = ()
-    __cache__ = 'getpoints',
-
     def __init__(self):
         super().__init__(ndims=0)
 
     def getpoints(self, ischeme, degree):
-        return points.CoordsWeightsPoints(numpy.empty([1, 0]), [1.])
+        return self._getpoints_any
+
+    @cached_property
+    def _getpoints_any(self):
+        return points.CoordsWeightsPoints(types.arraydata(numpy.empty([1, 0])), types.arraydata([1.]))
 
-    def nvertices_by_level(self, n):
+    def _nlinear_by_level(self, n):
         return 1
 
     def child_divide(self, vals, n):
         return vals,
 
 
 class LineReference(SimplexReference):
     '1D simplex'
 
-    __slots__ = '_bernsteincache',
-
     def __init__(self):
         self._bernsteincache = []  # TEMPORARY
         super().__init__(ndims=1)
 
     def getpoints(self, ischeme, degree):
         if ischeme == 'uniform':
-            return points.CoordsUniformPoints(numpy.arange(.5, degree)[:, _] / degree, 1)
+            return points.CoordsUniformPoints(types.arraydata(numpy.arange(.5, degree)[:, _] / degree), 1.)
         return super().getpoints(ischeme, degree)
 
-    def nvertices_by_level(self, n):
+    def _nlinear_by_level(self, n):
         return 2**n + 1
 
     def child_divide(self, vals, n):
         assert n > 0
-        assert len(vals) == self.nvertices_by_level(n)
+        assert len(vals) == self._nlinear_by_level(n)
         m = (len(vals)+1) // 2
         return vals[:m], vals[m-1:]
 
 
 class TriangleReference(SimplexReference):
     '2D simplex'
 
-    __slots__ = ()
-
     def __init__(self):
         super().__init__(ndims=2)
 
     def getpoints(self, ischeme, degree):
         if ischeme == 'uniform':
             p = numpy.arange(1./3, degree) / degree
             C = numpy.empty([2, degree, degree])
             C[0] = p[:, _]
             C[1] = p[_, :]
             coords = C.reshape(2, -1)
             flip = numpy.greater(coords.sum(0), 1)
             coords[:, flip] = 1 - coords[::-1, flip]
-            return points.CoordsUniformPoints(coords.T, .5)
+            return points.CoordsUniformPoints(types.arraydata(coords.T), .5)
         return super().getpoints(ischeme, degree)
 
-    def nvertices_by_level(self, n):
+    def _nlinear_by_level(self, n):
         m = 2**n + 1
         return ((m+1)*m) // 2
 
     def child_divide(self, vals, n):
-        assert len(vals) == self.nvertices_by_level(n)
+        assert len(vals) == self._nlinear_by_level(n)
         np = 1 + 2**n  # points along parent edge
         mp = 1 + 2**(n-1)  # points along child edge
         cvals = []
         for i in range(mp):
             j = numpy.arange(mp-i)
             cvals.append([vals[b+a*np-(a*(a-1))//2] for a, b in [(i, j), (i, mp-1+j), (mp-1+i, j), (i+j, mp-1-j)]])
         return numpy.concatenate(cvals, axis=1)
@@ -527,32 +521,30 @@
     # h-i\  g-i\  g-h\  d-e\
     # c-e-f a-d-f a-b-c a-b-c
     #
     # CHILDREN:
     # d\g e\h f\i i\j e\g g\h g\i h\i
     # a-b b-c d-e g-h b-d b-e d-e e-g
 
-    __slots__ = ()
-
     _children_vertices = [0, 1, 3, 6], [1, 2, 4, 7], [3, 4, 5, 8], [6, 7, 8, 9], [1, 3, 4, 6], [1, 4, 6, 7], [3, 4, 6, 8], [4, 6, 7, 8]
 
     def __init__(self):
         super().__init__(ndims=3)
 
     def getindices_vertex(self, n):
         m = 2**n+1
         indis = numpy.arange(m)
         return numpy.array([[i, j, k] for k in indis for j in indis[:m-k] for i in indis[:m-j-k]])
 
-    def nvertices_by_level(self, n):
+    def _nlinear_by_level(self, n):
         m = 2**n+1
         return ((m+2)*(m+1)*m)//6
 
     def child_divide(self, vals, n):
-        assert len(vals) == self.nvertices_by_level(n)
+        assert len(vals) == self._nlinear_by_level(n)
 
         child_indices = self.getindices_vertex(1)
 
         offset = numpy.array([1, 0, 0, 0])
         linear = numpy.array([[-1, -1, -1], [1, 0, 0], [0, 1, 0], [0, 0, 1]])
 
         m = 2**n+1
@@ -571,60 +563,88 @@
 
         return numpy.array(cvals)
 
 
 class TensorReference(Reference):
     'tensor reference'
 
-    __slots__ = 'ref1', 'ref2'
-    __cache__ = 'vertices', 'edge_transforms', 'ribbons', 'child_transforms', 'getpoints', 'get_poly_coeffs', 'centroid'
-
     def __init__(self, ref1, ref2):
         assert not isinstance(ref1, TensorReference)
         self.ref1 = ref1
         self.ref2 = ref2
         super().__init__(ref1.ndims + ref2.ndims)
 
     def product(self, other):
         return self.ref1.product(self.ref2.product(other))
 
-    @property
+    @cached_property
     def vertices(self):
         vertices = numpy.empty((self.ref1.nverts, self.ref2.nverts, self.ndims), dtype=float)
         vertices[:, :, :self.ref1.ndims] = self.ref1.vertices[:, _]
         vertices[:, :, self.ref1.ndims:] = self.ref2.vertices[_, :]
         return types.frozenarray(vertices.reshape(self.ref1.nverts*self.ref2.nverts, self.ndims), copy=False)
 
-    @property
+    @cached_property
+    def edge_vertices(self):
+        n1 = self.ref1.nverts
+        n2 = self.ref2.nverts
+        edge_vertices = [everts[:,_] * n2 + numpy.arange(n2) for everts in self.ref1.edge_vertices] \
+                      + [numpy.arange(n1)[:,_] * n2 + everts for everts in self.ref2.edge_vertices]
+        return tuple(types.frozenarray(e.ravel(), copy=False) for e in edge_vertices)
+
+    @cached_property
+    def simplices(self):
+        if self.ref1.ndims != 1 and self.ref2.ndims != 1:
+            raise NotImplementedError((self.ref1, self.ref2))
+        # For an n-dimensional simplex with vertices a0,a1,..,an, the extruded
+        # element has vertices a0,a1,..,an,b0,b1,..,bn. These can be divided in
+        # simplices by selecting a0,a1,..,an,b0; a1,..,an,b0,n1; and so on until
+        # an,b0,b1,..,bn; resulting in n+1 n+1-dimensional simplices.
+        indices = self.ref1.simplices[:,numpy.newaxis,:,numpy.newaxis] * self.ref2.nverts \
+                + self.ref2.simplices[numpy.newaxis,:,numpy.newaxis,:]
+        if self.ref1.ndims != 1:
+            indices = indices.swapaxes(2,3) # simplex strips require penultimate axis to be of length 2
+        assert indices.shape[2] == 2
+        indices = numeric.overlapping(indices.reshape(-1, 2*self.ndims), n=self.ndims+1).copy() # nsimplex x nstrip x ndims+1
+        # to see determinants: X = self.vertices[indices]; numpy.linalg.det(X[...,1:,:] - X[...,:1,:])
+        if self.ndims % 2 == 0: # simplex strips of even dimension (e.g. triangles) have alternating orientation
+            indices[:,::2,:2] = indices[:,::2,1::-1].copy() # flip every other simplex
+        return types.frozenarray(indices.reshape(-1, self.ndims+1), copy=False)
+
+    @cached_property
     def centroid(self):
         return types.frozenarray(numpy.concatenate([self.ref1.centroid, self.ref2.centroid]), copy=False)
 
-    def nvertices_by_level(self, n):
-        return self.ref1.nvertices_by_level(n) * self.ref2.nvertices_by_level(n)
+    def _nlinear_by_level(self, n):
+        return self.ref1._nlinear_by_level(n) * self.ref2._nlinear_by_level(n)
 
     def child_divide(self, vals, n):
-        np1 = self.ref1.nvertices_by_level(n)
-        np2 = self.ref2.nvertices_by_level(n)
+        np1 = self.ref1._nlinear_by_level(n)
+        np2 = self.ref2._nlinear_by_level(n)
         return [v2.swapaxes(0, 1).reshape((-1,)+vals.shape[1:])
                 for v1 in self.ref1.child_divide(vals.reshape((np1, np2)+vals.shape[1:]), n)
                 for v2 in self.ref2.child_divide(v1.swapaxes(0, 1), n)]
 
     def __str__(self):
         return '{}*{}'.format(self.ref1, self.ref2)
 
     def getpoints(self, ischeme, degree):
         if self.ref1.ndims == 0:
             return self.ref2.getpoints(ischeme, degree)
         if self.ref2.ndims == 0:
             return self.ref1.getpoints(ischeme, degree)
-        if ischeme != 'vtk':
-            ischeme1, ischeme2 = ischeme.split('*', 1) if '*' in ischeme else (ischeme, ischeme)
-            degree1 = degree if not isinstance(degree, tuple) else degree[0]
-            degree2 = degree if not isinstance(degree, tuple) else degree[1] if len(degree) == 2 else degree[1:]
-            return self.ref1.getpoints(ischeme1, degree1) * self.ref2.getpoints(ischeme2, degree2)
+        if ischeme == 'vtk':
+            return self._getpoints_vtk
+        ischeme1, ischeme2 = ischeme.split('*', 1) if '*' in ischeme else (ischeme, ischeme)
+        degree1 = degree if not isinstance(degree, tuple) else degree[0]
+        degree2 = degree if not isinstance(degree, tuple) else degree[1] if len(degree) == 2 else degree[1:]
+        return self.ref1.getpoints(ischeme1, degree1) * self.ref2.getpoints(ischeme2, degree2)
+
+    @cached_property
+    def _getpoints_vtk(self):
         if self.ref1.ndims == self.ref2.ndims == 1:
             coords = numpy.empty([2, 2, 2])
             coords[..., :1] = self.ref1.vertices[:, _]
             coords[0, :, 1:] = self.ref2.vertices
             coords[1, :, 1:] = self.ref2.vertices[::-1]
         elif self.ref1.ndims <= 1 and self.ref2.ndims >= 1:
             coords = numpy.empty([self.ref1.nverts, self.ref2.nverts, self.ndims])
@@ -634,15 +654,15 @@
             coords = numpy.empty([self.ref2.nverts, self.ref1.nverts, self.ndims])
             coords[..., :self.ref1.ndims] = self.ref1.vertices[_, :]
             coords[..., self.ref1.ndims:] = self.ref2.vertices[:, _]
         else:
             raise NotImplementedError
         return points.CoordsPoints(coords.reshape(self.nverts, self.ndims))
 
-    @property
+    @cached_property
     def edge_transforms(self):
         edge_transforms = []
         if self.ref1.ndims:
             edge_transforms.extend(transform.TensorEdge1(trans1, self.ref2.ndims) for trans1 in self.ref1.edge_transforms)
         if self.ref2.ndims:
             edge_transforms.extend(transform.TensorEdge2(self.ref1.ndims, trans2) for trans2 in self.ref2.edge_transforms)
         return tuple(edge_transforms)
@@ -652,57 +672,34 @@
         edge_refs = []
         if self.ref1.ndims:
             edge_refs.extend(edge1 * self.ref2 for edge1 in self.ref1.edge_refs)
         if self.ref2.ndims:
             edge_refs.extend(self.ref1 * edge2 for edge2 in self.ref2.edge_refs)
         return tuple(edge_refs)
 
-    @property
-    def ribbons(self):
-        if self.ref1.ndims == 0:
-            return self.ref2.ribbons
-        if self.ref2.ndims == 0:
-            return self.ref1.ribbons
-        ribbons = []
-        for iedge1 in range(self.ref1.nedges):
-            #iedge = self.ref1.edge_refs[iedge] * self.ref2
-            for iedge2 in range(self.ref2.nedges):
-                #jedge = self.ref1 * self.ref2.edge_refs[jedge]
-                jedge1 = self.ref1.nedges + iedge2
-                jedge2 = iedge1
-                if self.ref1.ndims > 1:
-                    iedge2 += self.ref1.edge_refs[iedge1].nedges
-                ribbons.append(((iedge1, iedge2), (jedge1, jedge2)))
-        if self.ref1.ndims >= 2:
-            ribbons.extend(self.ref1.ribbons)
-        if self.ref2.ndims >= 2:
-            ribbons.extend(((iedge1+self.ref1.nedges, iedge2+self.ref1.nedges),
-                            (jedge1+self.ref1.nedges, jedge2+self.ref1.nedges)) for (iedge1, iedge2), (jedge1, jedge2) in self.ref2.ribbons)
-        return tuple(ribbons)
-
-    @property
+    @cached_property
     def child_transforms(self):
         return tuple(transform.TensorChild(trans1, trans2) for trans1 in self.ref1.child_transforms for trans2 in self.ref2.child_transforms)
 
     @property
     def child_refs(self):
         return tuple(child1 * child2 for child1 in self.ref1.child_refs for child2 in self.ref2.child_refs)
 
     def inside(self, point, eps=0):
         return self.ref1.inside(point[:self.ref1.ndims], eps) and self.ref2.inside(point[self.ref1.ndims:], eps)
 
-    @property
-    def simplices(self):
-        return tuple((transform.TensorChild(trans1, trans2), TensorReference(simplex1, simplex2)) for trans1, simplex1 in self.ref1.simplices for trans2, simplex2 in self.ref2.simplices)
-
     def get_ndofs(self, degree):
         return self.ref1.get_ndofs(degree)*self.ref2.get_ndofs(degree)
 
     def get_poly_coeffs(self, basis, **kwargs):
-        return numeric.poly_outer_product(self.ref1.get_poly_coeffs(basis, **kwargs), self.ref2.get_poly_coeffs(basis, **kwargs))
+        coeffs1 = self.ref1.get_poly_coeffs(basis, **kwargs)
+        coeffs2 = self.ref2.get_poly_coeffs(basis, **kwargs)
+        coeffs = poly.mul_different_vars(coeffs1[:,numpy.newaxis], coeffs2[numpy.newaxis], self.ref1.ndims, self.ref2.ndims)
+        coeffs = coeffs.reshape(-1, coeffs.shape[-1])
+        return types.frozenarray(coeffs, dtype=float, copy=False)
 
     def get_edge_dofs(self, degree, iedge):
         if not numeric.isint(iedge) or iedge < 0 or iedge >= self.nedges:
             raise IndexError('edge index out of range')
         nd2 = self.ref2.get_ndofs(degree)
         if iedge < self.ref1.nedges:
             dofs1 = self.ref1.get_edge_dofs(degree, iedge)
@@ -717,103 +714,17 @@
         for ref in self.ref1, self.ref2:
             if isinstance(ref, TensorReference):
                 yield from ref._flat_refs
             else:
                 yield ref
 
 
-class Cone(Reference):
-    'cone'
-
-    __slots__ = 'edgeref', 'etrans', 'tip', 'extnorm', 'height'
-    __cache__ = 'vertices', 'edge_transforms', 'edge_refs'
-
-    @types.apply_annotations
-    def __init__(self, edgeref, etrans, tip: types.arraydata):
-        assert etrans.fromdims == edgeref.ndims
-        assert etrans.todims == tip.shape[0]
-        super().__init__(etrans.todims)
-        self.edgeref = edgeref
-        self.etrans = etrans
-        self.tip = numpy.asarray(tip)
-        ext = etrans.ext
-        self.extnorm = numpy.linalg.norm(ext)
-        self.height = numpy.dot(etrans.offset - self.tip, ext) / self.extnorm
-        assert self.height >= 0, 'tip is positioned at the negative side of edge'
-
-    @property
-    def vertices(self):
-        return types.frozenarray(numpy.vstack([[self.tip], self.etrans.apply(self.edgeref.vertices)]), copy=False)
-
-    @property
-    def edge_transforms(self):
-        edge_transforms = [self.etrans]
-        if self.edgeref.ndims > 0:
-            for trans, edge in self.edgeref.edges:
-                if edge:
-                    b = self.etrans.apply(trans.offset)
-                    A = numpy.hstack([numpy.dot(self.etrans.linear, trans.linear), (self.tip-b)[:, _]])
-                    newtrans = transform.Updim(A, b, isflipped=self.etrans.isflipped ^ trans.isflipped ^ (self.ndims % 2 == 1))  # isflipped logic tested up to 3D
-                    edge_transforms.append(newtrans)
-        else:
-            edge_transforms.append(transform.Updim(numpy.zeros((1, 0)), self.tip, isflipped=not self.etrans.isflipped))
-        return tuple(edge_transforms)
-
-    @property
-    def edge_refs(self):
-        edge_refs = [self.edgeref]
-        if self.edgeref.ndims > 0:
-            extrudetrans = transform.Updim(numpy.eye(self.ndims-1)[:, :-1], numpy.zeros(self.ndims-1), isflipped=self.ndims % 2 == 0)
-            tip = numpy.array([0]*(self.ndims-2)+[1], dtype=float)
-            edge_refs.extend(edge.cone(extrudetrans, tip) for edge in self.edgeref.edge_refs if edge)
-        else:
-            edge_refs.append(getsimplex(0))
-        return tuple(edge_refs)
-
-    def getpoints(self, ischeme, degree):
-        if ischeme == 'gauss':
-            if self.nverts == self.ndims+1:  # use optimal gauss schemes for simplex-like cones
-                pnts = getsimplex(self.ndims).getpoints(ischeme, degree)
-                linearT = self.etrans.apply(self.edgeref.vertices) - self.tip
-                coords = pnts.coords @ linearT + self.tip
-                weights = pnts.weights * abs(numpy.linalg.det(linearT))
-                return points.CoordsWeightsPoints(coords, weights)
-            epoints = self.edgeref.getpoints('gauss', degree)
-            tx, tw = points.gauss((degree + self.ndims - 1)//2)
-            wx = tx**(self.ndims-1) * tw * self.extnorm * self.height
-            return points.CoordsWeightsPoints((tx[:, _, _] * (self.etrans.apply(epoints.coords)-self.tip)[_, :, :] + self.tip).reshape(-1, self.ndims), (epoints.weights[_, :] * wx[:, _]).ravel())
-        if ischeme in ('_centroid', 'uniform'):
-            layers = [(i+1, (i+.5)/degree) for i in range(degree)] if ischeme == 'uniform' \
-                else [(None, self.ndims/(self.ndims+1))]  # centroid
-            coords = numpy.concatenate([self.etrans.apply(self.edgeref.getpoints(ischeme, p).coords) * w + self.tip * (1-w) for p, w in layers])
-            volume = self.edgeref.volume * self.extnorm * self.height / self.ndims
-            return points.CoordsUniformPoints(coords, volume)
-        if ischeme == 'vtk' and self.nverts == 5 and self.ndims == 3:  # pyramid
-            return points.CoordsPoints(self.vertices[[1, 2, 4, 3, 0]])
-        return points.ConePoints(self.edgeref.getpoints(ischeme, degree), self.etrans, self.tip)
-
-    @property
-    def simplices(self):
-        if self.nverts == self.ndims+1 or self.edgeref.ndims == 2 and self.edgeref.nverts == 4:  # simplices and square-based pyramids are ok
-            return [(transform.Identity(self.ndims), self)]
-        return tuple((transform.Identity(self.ndims), ref.cone(self.etrans*trans, self.tip)) for trans, ref in self.edgeref.simplices)
-
-    def inside(self, point, eps=0):
-        # point = etrans.apply(epoint) * xi + tip * (1-xi) => etrans.apply(epoint) = tip + (point-tip) / xi
-        xi = numpy.dot(self.etrans.ext, point-self.tip) / numpy.dot(self.etrans.ext, self.etrans.offset-self.tip)
-        return -eps <= xi <= 1+eps and self.edgeref.inside(numpy.linalg.solve(
-            numpy.dot(self.etrans.linear.T, self.etrans.linear),
-            numpy.dot(self.etrans.linear.T, self.tip + (point-self.tip)/xi - self.etrans.offset)), eps=eps)
-
-
 class OwnChildReference(Reference):
     'forward self as child'
 
-    __slots__ = 'baseref', 'child_refs', 'child_transforms'
-
     def __init__(self, baseref):
         self.baseref = baseref
         self.child_refs = baseref,
         self.child_transforms = transform.Identity(baseref.ndims),
         super().__init__(baseref.ndims)
 
     @property
@@ -827,65 +738,57 @@
     @property
     def edge_refs(self):
         return [OwnChildReference(edge) for edge in self.baseref.edge_refs]
 
     def getpoints(self, ischeme, degree):
         return self.baseref.getpoints(ischeme, degree)
 
-    @property
-    def simplices(self):
-        return self.baseref.simplices
-
     def get_ndofs(self, degree):
         return self.baseref.get_ndofs(degree)
 
     def get_poly_coeffs(self, basis, **kwargs):
         return self.baseref.get_poly_coeffs(basis, **kwargs)
 
     def get_edge_dofs(self, degree, iedge):
         return self.baseref.get_edge_dofs(degree, iedge)
 
 
 class WithChildrenReference(Reference):
     'base reference with explicit children'
 
-    __slots__ = 'baseref', 'child_transforms', 'child_refs'
-    __cache__ = '__extra_edges', 'edge_transforms', 'edge_refs', 'connectivity'
-
-    @types.apply_annotations
-    def __init__(self, baseref, child_refs: tuple):
-        assert len(child_refs) == baseref.nchildren and any(child_refs) and child_refs != baseref.child_refs
-        assert all(isinstance(child_ref, Reference) for child_ref in child_refs)
-        assert all(child_ref.ndims == baseref.ndims for child_ref in child_refs)
+    def __init__(self, baseref: Reference, child_refs: Tuple[Reference,...]):
+        assert isinstance(baseref, Reference), f'baseref={baseref!r}'
+        assert isinstance(child_refs, tuple) and len(child_refs) == baseref.nchildren and all(isinstance(ref, Reference) and ref.ndims == baseref.ndims for ref in child_refs), f'child_refs={child_refs!r}'
+        assert any(child_refs) and child_refs != baseref.child_refs
         self.baseref = baseref
         self.child_transforms = baseref.child_transforms
         self.child_refs = child_refs
         super().__init__(baseref.ndims)
 
     def check_edges(self, tol=1e-15, print=print):
         super().check_edges(tol=tol, print=print)
         for cref in self.child_refs:
             cref.check_edges(tol=tol, print=print)
 
     @property
     def vertices(self):
         return self.baseref.vertices
 
-    def nvertices_by_level(self, n):
-        return self.baseref.nvertices_by_level(n)
+    def _nlinear_by_level(self, n):
+        return self.baseref._nlinear_by_level(n)
 
     def child_divide(self, vals, n):
         return self.baseref.child_divide(vals, n)
 
     __sub__ = lambda self, other: self.empty if other in (self, self.baseref) else self.baseref.with_children(self_child-other_child for self_child, other_child in zip(self.child_refs, other.child_refs)) if isinstance(other, WithChildrenReference) and other.baseref in (self, self.baseref) else NotImplemented
     __rsub__ = lambda self, other: self.baseref.with_children(other_child - self_child for self_child, other_child in zip(self.child_refs, other.child_refs)) if other == self.baseref else NotImplemented
     __and__ = lambda self, other: self if other == self.baseref else other if isinstance(other, WithChildrenReference) and self == other.baseref else self.baseref.with_children(self_child & other_child for self_child, other_child in zip(self.child_refs, other.child_refs)) if isinstance(other, WithChildrenReference) and other.baseref == self.baseref else NotImplemented
     __or__ = lambda self, other: other if other == self.baseref else self.baseref.with_children(self_child | other_child for self_child, other_child in zip(self.child_refs, other.child_refs)) if isinstance(other, WithChildrenReference) and other.baseref == self.baseref else NotImplemented
 
-    @property
+    @cached_property
     def __extra_edges(self):
         extra_edges = [(ichild, iedge, cref.edge_refs[iedge])
                        for ichild, cref in enumerate(self.child_refs) if cref
                        for iedge in range(self.baseref.child_refs[ichild].nedges, cref.nedges)]
         for ichild, edges in enumerate(self.baseref.connectivity):
             cref = self.child_refs[ichild]
             if not cref:
@@ -922,27 +825,23 @@
         if ischeme == '_centroid':
             return super().getpoints(ischeme, degree)
         if ischeme == 'bezier':
             degree = degree//2+1  # modify child degree to keep (approximate) uniformity
             dedup = True
         else:
             dedup = False
-        childpoints = [points.TransformPoints(ref.getpoints(ischeme, degree), trans) for trans, ref in self.children if ref]
-        return points.ConcatPoints(childpoints, points.find_duplicates(childpoints) if dedup else ())
-
-    @property
-    def simplices(self):
-        return [(trans2*trans1, simplex) for trans2, child in self.children for trans1, simplex in (child.simplices if child else [])]
+        childpoints = tuple(points.TransformPoints(ref.getpoints(ischeme, degree), trans) for trans, ref in self.children if ref)
+        return points.ConcatPoints(childpoints, points.find_duplicates(childpoints) if dedup else frozenset())
 
-    @property
+    @cached_property
     def edge_transforms(self):
         return tuple(self.baseref.edge_transforms) \
             + tuple(transform.ScaledUpdim(self.child_transforms[ichild], self.child_refs[ichild].edge_transforms[iedge]) for ichild, iedge, ref in self.__extra_edges)
 
-    @property
+    @cached_property
     def edge_refs(self):
         refs = []
         for etrans, eref in self.baseref.edges:
             children = []
             if eref:
                 for ctrans, cref in eref.children:
                     ctrans_, etrans_ = etrans.swapup(ctrans)
@@ -950,15 +849,15 @@
                     cref = self.child_refs[ichild]
                     children.append(cref.edge_refs[cref.edge_transforms.index(etrans_)])
             refs.append(eref.with_children(children))
         for ichild, iedge, ref in self.__extra_edges:
             refs.append(OwnChildReference(ref))
         return tuple(refs)
 
-    @property
+    @cached_property
     def connectivity(self):
         return tuple(types.frozenarray(edges.tolist() + [-1] * (self.child_refs[ichild].nedges - len(edges))) for ichild, edges in enumerate(self.baseref.connectivity))
 
     def inside(self, point, eps=0):
         return any(cref.inside(ctrans.invapply(point), eps=eps) for ctrans, cref in self.children)
 
     def get_ndofs(self, degree):
@@ -970,128 +869,211 @@
     def get_edge_dofs(self, degree, iedge):
         return self.baseref.get_edge_dofs(degree, iedge)
 
 
 class MosaicReference(Reference):
     'triangulation'
 
-    __slots__ = 'baseref', '_edge_refs', '_midpoint', 'edge_refs', 'edge_transforms'
-    __cache__ = 'vertices', 'subrefs'
-
-    @types.apply_annotations
-    def __init__(self, baseref, edge_refs: tuple, midpoint: types.arraydata):
-        assert len(edge_refs) == baseref.nedges
+    def __init__(self, baseref: Reference, edge_refs: Tuple[Reference,...], midpoint: types.arraydata):
+        assert isinstance(baseref, Reference), f'baseref={baseref!r}'
+        assert isinstance(edge_refs, tuple) and len(edge_refs) == baseref.nedges and all(isinstance(ref, Reference) and ref.ndims == baseref.ndims-1 for ref in edge_refs), f'baseref={baseref!r}'
         assert edge_refs != tuple(baseref.edge_refs)
+        assert midpoint.shape == (baseref.ndims,)
+        assert all(numpy.all(edge.vertices == newedge.vertices[:edge.nverts])
+            for edge, newedge in zip(baseref.edge_refs, edge_refs))
+
+        vertices = list(baseref.vertices)
+        match, = (baseref.vertices == midpoint).all(1).nonzero()
+        if match.size:
+            imidpoint, = match
+        else:
+            imidpoint = len(vertices)
+            vertices.append(numpy.asarray(midpoint))
 
-        self.baseref = baseref
-        self._edge_refs = edge_refs
-        self._midpoint = numpy.asarray(midpoint)
-        self.edge_refs = list(edge_refs)
-        self.edge_transforms = list(baseref.edge_transforms)
+        # The remainder of this constructor is concerned with establishing the
+        # edges of the mosaic, and setting up the corresponding edge-vertex
+        # relations.
 
         if baseref.ndims == 1:
 
-            assert any(edge_refs) and not all(edge_refs), 'invalid 1D mosaic: exactly one edge should be non-empty'
-            iedge, = [i for i, edge in enumerate(edge_refs) if edge]
-            self.edge_refs.append(getsimplex(0))
-            self.edge_transforms.append(transform.Updim(linear=numpy.zeros((1, 0)), offset=self._midpoint, isflipped=not baseref.edge_transforms[iedge].isflipped))
+            # For 1D elements the situation is simple: the midpoint represents
+            # the only new vertex (already added to vertices) as well as the
+            # only new edge, with a trivial edge-vertex relationship.
+
+            assert not match.size, '1D mosaic must introduce a new vertex'
+            edge_vertices = (*baseref.edge_vertices, types.frozenarray([imidpoint]))
+            orientation = [not trans.isflipped for trans, edge in zip(baseref.edge_transforms, edge_refs) if edge]
+            assert len(orientation) == 1, 'invalid 1D mosaic: exactly one edge should be non-empty'
 
         else:
 
-            newedges = [(etrans1, etrans2, edge) for (etrans1, orig), new in zip(baseref.edges, edge_refs) for etrans2, edge in new.edges[orig.nedges:]]
-            for (iedge1, iedge2), (jedge1, jedge2) in baseref.ribbons:
-                Ei = edge_refs[iedge1]
-                ei = Ei.edge_refs[iedge2]
-                Ej = edge_refs[jedge1]
-                ej = Ej.edge_refs[jedge2]
-                ejsubi = ej - ei
-                if ejsubi:
-                    newedges.append((self.edge_transforms[jedge1], Ej.edge_transforms[jedge2], ejsubi))
-                eisubj = ei - ej
-                if eisubj:
-                    newedges.append((self.edge_transforms[iedge1], Ei.edge_transforms[iedge2], eisubj))
-
-            extrudetrans = transform.Updim(numpy.eye(baseref.ndims-1)[:, :-1], numpy.zeros(baseref.ndims-1), isflipped=baseref.ndims % 2 == 0)
-            tip = numpy.array([0]*(baseref.ndims-2)+[1], dtype=float)
-            for etrans, trans, edge in newedges:
-                b = etrans.apply(trans.offset)
-                A = numpy.hstack([numpy.dot(etrans.linear, trans.linear), (self._midpoint-b)[:, _]])
-                newtrans = transform.Updim(A, b, isflipped=etrans.isflipped ^ trans.isflipped ^ (baseref.ndims % 2 == 1))  # isflipped logic tested up to 3D
-                self.edge_transforms.append(newtrans)
-                self.edge_refs.append(edge.cone(extrudetrans, tip))
+            # For higher-dimensional elements the situation is more complex.
+            # Firstly, the new edge_refs may introduce new vertices. Luckily
+            # here the previously asserted convention applies that the vertices
+            # of the original edge are repeated in the modified edge, so we can
+            # focus our attention on the new ones, having only to deduplicate
+            # between them.
+
+            edge_vertices = []
+            for trans, edge, emap, newedge in zip(baseref.edge_transforms, baseref.edge_refs, baseref.edge_vertices, edge_refs):
+                for v in trans.apply(newedge.vertices[edge.nverts:]):
+                    for i, v_ in enumerate(vertices[baseref.nverts:], start=baseref.nverts):
+                        if (v == v_).all():
+                            break # the new vertex was already added by a previous edge
+                    else:
+                        i = len(vertices)
+                        vertices.append(v)
+                    emap = types.frozenarray([*emap, i])
+                edge_vertices.append(emap)
+
+            # Secondly, new edges (which will be pulled to the midpoint) can
+            # originate either from new edge-edges, or from existing ones that
+            # find themselves without a counterpart. The former situation is
+            # trivial, following the convention that existing edge transforms
+            # are copied over in the modified edge.
+
+            assert all(edge.edge_transforms == newedge.edge_transforms[:edge.nverts]
+                for edge, newedge in zip(baseref.edge_refs, edge_refs))
+
+            # The latter, however, is more tricky. This is the situation that
+            # occurs, for instance, when two out of four edges of a square are
+            # cleanly removed, making two existing edge-edges the new exterior.
+            # Identifying these situations requires an examination of all the
+            # modified edges, that is, edge-edges in locations that pre-existed
+            # in baseref. Knowing that the edges of baseref form a watertight
+            # hull, we employ the strategy of first identifying all edge-edge
+            # counterparts, and then comparing the new references in the
+            # identified locations to see if one of the two disappeared: in
+            # this case the other reference is added to the exterior set.
+
+            # NOTE: establishing edge-edge relations could potentially be
+            # cached for reuse at the level of baseref. However, since this is
+            # the only place that the information is used and all edge pairs
+            # need to anyhow be examined for gaps, it is not clear that the
+            # gains merit the additional complexity.
+
+            orientation = []
+            seen = {}
+            for edge1, newemap1, etrans1, newedge1 in zip(baseref.edge_refs, edge_vertices, baseref.edge_transforms, edge_refs):
+                newedge1_edge = zip(newedge1.edge_vertices, newedge1.edge_transforms, newedge1.edge_refs)
+                trimmed = [] # trimmed will be populated with a subset of newedge1_edge
+                for edge2, (newemap2, etrans2, newedge2) in zip(edge1.edge_refs, newedge1_edge):
+                    if edge2: # existing non-empty edge
+
+                        # To identify matching edge-edges we map their vertices
+                        # to the numbering of the baseref for comparison. Since
+                        # matching edge-edges have must have equal references,
+                        # and by construction have matching orientation, the
+                        # vertex ordering will be consistent between them.
+
+                        key = tuple(newemap1[newemap2])
+
+                        # NOTE: there have been anecdotal reports that suggest
+                        # the assumption of matching edges may be violated, but
+                        # it is not clear in what scenario this can occur. If
+                        # the 'not seen' assertion below fails, please provide
+                        # the developers with a reproducable issue for study.
+
+                        try:
+                            newedge2_ = seen.pop(key)
+                        except KeyError:
+                            seen[key] = newedge2
+                        else: # a counterpart is found, placing newedge2 against newedge2_
+                            if not newedge2:
+                                trimmed.append((newemap2, etrans2.flipped, newedge2_))
+                            elif not newedge2_:
+                                trimmed.append((newemap2, etrans2, newedge2))
+                            elif newedge2 != newedge2_:
+                                raise NotImplementedError
+
+                # Since newedge1_edge was zipped against the shorter list of
+                # original edge1.edge_refs, what remains are the new edge-edges
+                # that can be added without further examination.
+
+                trimmed.extend(newedge1_edge)
+
+                # What remains is only to extend the edge-vertex relations and
+                # to track if the new edges are left- or right-handed.
+
+                for newemap2, etrans2, newedge2 in trimmed:
+                    for simplex in newemap1[newemap2[newedge2.simplices]]:
+                        if imidpoint not in simplex:
+                            edge_vertices.append(types.frozenarray([imidpoint, *simplex]))
+                            orientation.append(not etrans1.isflipped^etrans2.isflipped)
+
+            assert not seen, f'leftover unmatched edges ({seen}) indicate the edges of baseref ({baseref}) are not watertight!'
+
+        self.baseref = baseref
+        self._edge_refs = edge_refs
+        self.vertices = types.frozenarray(vertices, copy=False)
+        self._imidpoint = imidpoint
+        self._midpoint = midpoint
+        self.edge_vertices = tuple(edge_vertices)
+        self.edge_refs = edge_refs + (getsimplex(baseref.ndims-1),) * len(orientation)
+        self.edge_transforms = baseref.edge_transforms + tuple(transform.simplex(vertices, isflipped)
+          for vertices, isflipped in zip(self.vertices[numpy.array(edge_vertices[baseref.nedges:])], orientation))
 
         super().__init__(baseref.ndims)
 
-    @property
-    def vertices(self):
-        vertices, indices = util.unique([vertex for etrans, eref in self.edges if eref for vertex in etrans.apply(eref.vertices)], key=types.arraydata)
-        return types.frozenarray(vertices)
+    def _with_edges(self, edge_refs):
+        edge_refs = tuple(edge_refs)
+        return self.baseref if edge_refs == self.baseref.edge_refs \
+          else self.empty if not any(edge_refs) \
+          else MosaicReference(self.baseref, edge_refs, self._midpoint)
 
     def __and__(self, other):
         if other in (self, self.baseref):
             return self
         if isinstance(other, MosaicReference) and other.baseref == self:
             return other
-        if isinstance(other, MosaicReference) and self.baseref == other.baseref and numpy.equal(other._midpoint, self._midpoint).all():
-            isect_edge_refs = [selfedge & otheredge for selfedge, otheredge in zip(self._edge_refs, other._edge_refs)]
-            if not any(isect_edge_refs):
-                return self.empty
-            return MosaicReference(self.baseref, isect_edge_refs, self._midpoint)
+        if isinstance(other, MosaicReference) and self.baseref == other.baseref and other._midpoint == self._midpoint:
+            return self._with_edges(selfedge & otheredge for selfedge, otheredge in zip(self._edge_refs, other._edge_refs))
         return NotImplemented
 
     def __or__(self, other):
         if other in (self, self.baseref):
             return other
-        if isinstance(other, MosaicReference) and self.baseref == other.baseref and numpy.equal(other._midpoint, self._midpoint).all():
-            union_edge_refs = [selfedge | otheredge for selfedge, otheredge in zip(self._edge_refs, other._edge_refs)]
-            if tuple(union_edge_refs) == tuple(self.baseref.edge_refs):
-                return self.baseref
-            return MosaicReference(self.baseref, union_edge_refs, self._midpoint)
+        if isinstance(other, MosaicReference) and self.baseref == other.baseref and other._midpoint == self._midpoint:
+            return self._with_edges(selfedge | otheredge for selfedge, otheredge in zip(self._edge_refs, other._edge_refs))
         return NotImplemented
 
     def __sub__(self, other):
         if other in (self, self.baseref):
             return self.empty
         if isinstance(other, MosaicReference) and other.baseref == self:
-            inv_edge_refs = [baseedge - edge for baseedge, edge in zip(self.edge_refs, other._edge_refs)]
-            return MosaicReference(self, inv_edge_refs, other._midpoint)
+            return other._with_edges(baseedge - edge for baseedge, edge in zip(self.edge_refs, other._edge_refs))
         return NotImplemented
 
     def __rsub__(self, other):
         if other == self.baseref:
-            inv_edge_refs = [baseedge - edge for baseedge, edge in zip(other.edge_refs, self._edge_refs)]
-            return MosaicReference(other, inv_edge_refs, self._midpoint)
+            return self._with_edges(baseedge - edge for baseedge, edge in zip(other.edge_refs, self._edge_refs))
         return NotImplemented
 
-    def nvertices_by_level(self, n):
-        return self.baseref.nvertices_by_level(n)
+    def _nlinear_by_level(self, n):
+        return self.baseref._nlinear_by_level(n)
 
-    @property
-    def subrefs(self):
-        return tuple(ref.cone(trans, self._midpoint) for trans, ref in zip(self.baseref.edge_transforms, self._edge_refs) if ref)
-
-    @property
+    @cached_property
     def simplices(self):
-        return [simplex for subvol in self.subrefs for simplex in subvol.simplices]
+        indices = []
+        for vmap, etrans, eref in zip(self.edge_vertices, self.baseref.edge_transforms, self._edge_refs):
+            for index in vmap[eref.simplices]:
+                if self._imidpoint not in index:
+                    indices.append([self._imidpoint, *index] if not etrans.isflipped else [index[0], self._imidpoint, *index[1:]])
+        return types.frozenarray(indices, dtype=int)
 
     def getpoints(self, ischeme, degree):
         if ischeme == 'vertex':
             return self.baseref.getpoints(ischeme, degree)
-        if ischeme == '_centroid':
+        elif ischeme in ('gauss', 'uniform', 'bezier'):
+            simplexpoints = getsimplex(self.ndims).getpoints(ischeme, degree)
+            subpoints = tuple(points.TransformPoints(simplexpoints, strans) for strans in self.simplex_transforms)
+            dups = points.find_duplicates(subpoints) if ischeme == 'bezier' else frozenset()
+            return points.ConcatPoints(subpoints, dups)
+        else:
             return super().getpoints(ischeme, degree)
-        subpoints = [subvol.getpoints(ischeme, degree) for subvol in self.subrefs]
-        dups = points.find_duplicates(subpoints) if ischeme == 'bezier' else ()
-        # NOTE We could consider postprocessing gauss1 to a single point scheme,
-        # rather than a concatenation, but for that we would have to verify that
-        # the centroid is contained in the element. We leave this optimization for
-        # later, to be combined with a reduction of gauss schemes of any degree.
-        return points.ConcatPoints(subpoints, dups)
-
-    def inside(self, point, eps=0):
-        return any(subref.inside(point, eps=eps) for subref in self.subrefs)
 
     def get_ndofs(self, degree):
         return self.baseref.get_ndofs(degree)
 
     def get_poly_coeffs(self, basis, **kwargs):
         return self.baseref.get_poly_coeffs(basis, **kwargs)
 
@@ -1123,8 +1105,47 @@
     return index
 
 
 def arglexsort(triangulation):
     return numpy.argsort(numeric.asobjvector(tuple(tri) for tri in triangulation))
 
 
-# vim:sw=2:sts=2:et
+# globally cached utilities
+
+
+@functools.lru_cache(maxsize=16)
+def _integer_barycentric_coordinates(ndims: int, degree: int):
+    return tuple(
+        (degree-sum(i), *i[::-1])
+        for i in itertools.product(*[range(degree+1)]*ndims)
+        if sum(i) <= degree)
+
+
+@functools.lru_cache(maxsize=16)
+def _get_poly_coeffs_bernstein(ndims: int, degree: int):
+    powers = _integer_barycentric_coordinates(ndims, degree)
+    ndofs = len(powers)
+    coeffs = numpy.zeros((ndofs, poly.ncoeffs(ndims, degree)), dtype=float)
+    for i, p in enumerate(powers):
+        for j, q in enumerate(powers[::-1]):
+            q_sub_p = tuple(map(operator.sub, q, p))
+            if all(power >= 0 for power in q_sub_p[1:]):
+                coeffs[i, j] = (-1)**q_sub_p[0]*math.factorial(degree)//util.product(map(math.factorial, (q[0], *p[1:], *q_sub_p[1:])))
+    return types.frozenarray(coeffs, copy=False)
+
+
+@functools.lru_cache(maxsize=16)
+def _get_poly_coeffs_lagrange(ndims: int, degree: int):
+    if ndims == 0 or degree == 0:
+        return types.frozenarray(numpy.ones((1, 1), dtype=float), copy=True)
+    else:
+        P = numpy.array(tuple(_integer_barycentric_coordinates(ndims, degree)), dtype=int)[:, 1:]
+        coeffs = numpy.linalg.inv(((P[_, :, :]/degree)**P[::-1, _, :]).prod(-1))
+        return types.frozenarray(coeffs, copy=False)
+
+
+_poly_coeffs = dict(
+    bernstein = _get_poly_coeffs_bernstein,
+    lagrange = _get_poly_coeffs_lagrange)
+
+
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/elementseq.py` & `nutils-8.0/nutils/elementseq.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """The elementseq module."""
 
-from . import types, numeric, util
+from . import types, numeric, _util as util
 from .element import Reference
 from .pointsseq import PointsSequence
+from ._backports import cached_property
 from typing import Tuple, Sequence, Iterable, Iterator, Optional, Union, overload
 import abc
 import itertools
 import operator
 import numpy
 
 
@@ -19,16 +20,14 @@
         The number of dimensions of the references in this sequence.
 
     Notes
     -----
     Subclasses must implement :meth:`__len__` and :meth:`get`.
     '''
 
-    __slots__ = 'ndims'
-
     @staticmethod
     def from_iter(value: Iterable[Reference], ndims: int) -> 'References':
         '''Create a :class:`References` sequence from an iterator.
 
         Parameters
         ----------
         value : iterable of :class:`~nutils.element.Reference` objects
@@ -319,16 +318,14 @@
         '''Return a sequence of :class:`~nutils.points.Points`.'''
 
         return PointsSequence.from_iter((reference.getpoints(ischeme, degree) for reference in self), self.ndims)
 
 
 class _Empty(References):
 
-    __slots__ = ()
-
     def __len__(self) -> int:
         return 0
 
     def get(self, index: int) -> Reference:
         raise IndexError('sequence index out of range')
 
     @property
@@ -341,16 +338,14 @@
 
     def getpoints(self, ischeme, degree) -> PointsSequence:
         return PointsSequence.empty(self.ndims)
 
 
 class _Plain(References):
 
-    __slots__ = 'items'
-
     def __init__(self, items: Tuple[Reference, ...], ndims: int) -> None:
         assert len(items), 'inefficient; this should have been `_Empty`'
         assert not all(item == items[0] for item in items), 'inefficient; this should have been `_Uniform`'
         assert all(item.ndims == ndims for item in items), 'not all items have ndims equal to {}'.format(ndims)
         self.items = items
         super().__init__(ndims)
 
@@ -362,17 +357,14 @@
 
     def get(self, index) -> Reference:
         return self.items[index]
 
 
 class _Uniform(References):
 
-    __slots__ = 'item', 'length'
-    __cache__ = 'children', 'edges'
-
     def __init__(self, item: Reference, length: int) -> None:
         assert length >= 0, 'length should be nonnegative'
         assert length > 0, 'inefficient; this should have been `_Empty`'
         self.item = item
         self.length = length
         super().__init__(item.ndims)
 
@@ -403,34 +395,32 @@
 
     def product(self, other: References) -> References:
         if isinstance(other, _Uniform):
             return References.uniform(self.item.product(other.item), len(self) * len(other))
         else:
             return super().product(other)
 
-    @property
+    @cached_property
     def children(self) -> References:
         return References.from_iter(self.item.child_refs, self.ndims).repeat(len(self))
 
-    @property
+    @cached_property
     def edges(self) -> References:
         return References.from_iter(self.item.edge_refs, self.ndims-1).repeat(len(self))
 
     @property
     def isuniform(self) -> bool:
         return True
 
     def getpoints(self, ischeme: str, degree: int) -> PointsSequence:
         return PointsSequence.uniform(self.item.getpoints(ischeme, degree), len(self))
 
 
 class _Take(References):
 
-    __slots__ = 'parent', 'indices'
-
     def __init__(self, parent: References, indices: types.arraydata) -> None:
         assert indices.shape[0] > 1, 'inefficient; this should have been `_Empty` or `_Uniform`'
         assert not isinstance(parent, _Uniform), 'inefficient; this should have been `_Uniform`'
         self.parent = parent
         self.indices = numpy.asarray(indices)
         _check_take(len(parent), self.indices)
         super().__init__(parent.ndims)
@@ -451,16 +441,14 @@
     def compress(self, mask: numpy.ndarray) -> References:
         _check_compress(len(self), mask)
         return self.parent.take(numpy.compress(mask, self.indices))
 
 
 class _Repeat(References):
 
-    __slots__ = 'parent', 'count'
-
     def __init__(self, parent: References, count: int) -> None:
         assert count >= 0, 'count should be nonnegative'
         assert count > 0, 'inefficient; this should have been `_Empty`'
         assert not isinstance(parent, _Uniform), 'inefficient; this should have been `_Uniform`'
         self.parent = parent
         self.count = count
         super().__init__(parent.ndims)
@@ -492,16 +480,14 @@
 
     def getpoints(self, ischeme: str, degree: int) -> PointsSequence:
         return self.parent.getpoints(ischeme, degree).repeat(self.count)
 
 
 class _Product(References):
 
-    __slots__ = 'sequence1', 'sequence2'
-
     def __init__(self, sequence1: References, sequence2: References) -> None:
         assert not (isinstance(sequence1, _Uniform) and isinstance(sequence2, _Uniform)), 'inefficient; this should have been `_Uniform`'
         self.sequence1 = sequence1
         self.sequence2 = sequence2
         super().__init__(sequence1.ndims + sequence2.ndims)
 
     def __len__(self) -> int:
@@ -519,16 +505,14 @@
 
     def getpoints(self, ischeme: str, degree: int) -> PointsSequence:
         return self.sequence1.getpoints(ischeme, degree).product(self.sequence2.getpoints(ischeme, degree))
 
 
 class _Chain(References):
 
-    __slots__ = 'sequence1', 'sequence2'
-
     def __init__(self, sequence1: References, sequence2: References) -> None:
         assert sequence1.ndims == sequence2.ndims, 'cannot chain sequences with different ndims'
         assert sequence1 and sequence2, 'inefficient; at least one of the sequences is empty'
         assert not _merge_chain(sequence1, sequence2), 'inefficient; this should have been `_Uniform` or `_Repeat`'
         self.sequence1 = sequence1
         self.sequence2 = sequence2
         super().__init__(sequence1.ndims)
@@ -568,23 +552,20 @@
 
     def getpoints(self, ischeme: str, degree: int) -> PointsSequence:
         return self.sequence1.getpoints(ischeme, degree).chain(self.sequence2.getpoints(ischeme, degree))
 
 
 class _Derived(References):
 
-    __slots__ = 'parent', 'derived_refs'
-    __cache__ = 'offsets'
-
     def __init__(self, parent: References, derived_attribute: str, ndims: int) -> None:
         self.parent = parent
         self.derived_refs = operator.attrgetter(derived_attribute)
         super().__init__(ndims)
 
-    @property
+    @cached_property
     def offsets(self) -> numpy.ndarray:
         return types.frozenarray(numpy.cumsum([0, *(len(self.derived_refs(ref)) for ref in self.parent)]), copy=False)
 
     def __len__(self) -> int:
         return self.offsets[-1]
 
     def __iter__(self) -> Iterator[Reference]:
@@ -650,8 +631,8 @@
     if not numeric.isboolarray(mask):
         raise IndexError('expected an array of booleans')
     if not mask.ndim == 1:
         raise IndexError('expected an array with dimension 1 but got {}'.format(mask.ndim))
     if len(mask) != length:
         raise IndexError('expected an array with length {} but got {}'.format(length, len(mask)))
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/evaluable.py` & `nutils-8.0/nutils/evaluable.py`

 * *Files 4% similar despite different names*

```diff
@@ -87,10836 +87,12424 @@
 00000560: 6620 7479 7069 6e67 2e54 5950 455f 4348  f typing.TYPE_CH
 00000570: 4543 4b49 4e47 3a0a 2020 2020 6672 6f6d  ECKING:.    from
 00000580: 2074 7970 696e 675f 6578 7465 6e73 696f   typing_extensio
 00000590: 6e73 2069 6d70 6f72 7420 5072 6f74 6f63  ns import Protoc
 000005a0: 6f6c 0a65 6c73 653a 0a20 2020 2050 726f  ol.else:.    Pro
 000005b0: 746f 636f 6c20 3d20 6f62 6a65 6374 0a0a  tocol = object..
 000005c0: 6672 6f6d 202e 2069 6d70 6f72 7420 6465  from . import de
-000005d0: 6275 675f 666c 6167 732c 2075 7469 6c2c  bug_flags, util,
-000005e0: 2074 7970 6573 2c20 6e75 6d65 7269 632c   types, numeric,
-000005f0: 2063 6163 6865 2c20 7761 726e 696e 6773   cache, warnings
-00000600: 2c20 7061 7261 6c6c 656c 2c20 7370 6172  , parallel, spar
-00000610: 7365 0a66 726f 6d20 2e5f 6772 6170 6820  se.from ._graph 
-00000620: 696d 706f 7274 204e 6f64 652c 2052 6567  import Node, Reg
-00000630: 756c 6172 4e6f 6465 2c20 4475 706c 6963  ularNode, Duplic
-00000640: 6174 6564 4c65 6166 4e6f 6465 2c20 496e  atedLeafNode, In
-00000650: 7669 7369 626c 654e 6f64 652c 2053 7562  visibleNode, Sub
-00000660: 6772 6170 680a 696d 706f 7274 206e 756d  graph.import num
-00000670: 7079 0a69 6d70 6f72 7420 7379 730a 696d  py.import sys.im
-00000680: 706f 7274 2069 7465 7274 6f6f 6c73 0a69  port itertools.i
-00000690: 6d70 6f72 7420 6675 6e63 746f 6f6c 730a  mport functools.
-000006a0: 696d 706f 7274 206f 7065 7261 746f 720a  import operator.
-000006b0: 696d 706f 7274 2069 6e73 7065 6374 0a69  import inspect.i
-000006c0: 6d70 6f72 7420 6e75 6d62 6572 730a 696d  mport numbers.im
-000006d0: 706f 7274 2062 7569 6c74 696e 730a 696d  port builtins.im
-000006e0: 706f 7274 2072 650a 696d 706f 7274 2074  port re.import t
-000006f0: 7970 6573 2061 7320 6275 696c 7469 6e5f  ypes as builtin_
-00000700: 7479 7065 730a 696d 706f 7274 2061 6263  types.import abc
-00000710: 0a69 6d70 6f72 7420 636f 6c6c 6563 7469  .import collecti
-00000720: 6f6e 732e 6162 630a 696d 706f 7274 206d  ons.abc.import m
-00000730: 6174 680a 696d 706f 7274 2074 7265 656c  ath.import treel
-00000740: 6f67 2061 7320 6c6f 670a 696d 706f 7274  og as log.import
-00000750: 2077 6561 6b72 6566 0a69 6d70 6f72 7420   weakref.import 
-00000760: 7469 6d65 0a69 6d70 6f72 7420 636f 6e74  time.import cont
-00000770: 6578 746c 6962 0a69 6d70 6f72 7420 7375  extlib.import su
-00000780: 6270 726f 6365 7373 0a69 6d70 6f72 7420  bprocess.import 
-00000790: 6f73 0a0a 6772 6170 6876 697a 203d 206f  os..graphviz = o
-000007a0: 732e 656e 7669 726f 6e2e 6765 7428 274e  s.environ.get('N
-000007b0: 5554 494c 535f 4752 4150 4856 495a 2729  UTILS_GRAPHVIZ')
-000007c0: 0a0a 6973 6576 616c 7561 626c 6520 3d20  ..isevaluable = 
-000007d0: 6c61 6d62 6461 2061 7267 3a20 6973 696e  lambda arg: isin
-000007e0: 7374 616e 6365 2861 7267 2c20 4576 616c  stance(arg, Eval
-000007f0: 7561 626c 6529 0a0a 0a64 6566 2073 7472  uable)...def str
-00000800: 6963 7465 7661 6c75 6162 6c65 2876 616c  ictevaluable(val
-00000810: 7565 293a 0a20 2020 2069 6620 6e6f 7420  ue):.    if not 
-00000820: 6973 696e 7374 616e 6365 2876 616c 7565  isinstance(value
-00000830: 2c20 4576 616c 7561 626c 6529 3a0a 2020  , Evaluable):.  
-00000840: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00000850: 6545 7272 6f72 2827 6578 7065 6374 6564  eError('expected
-00000860: 2061 6e20 6f62 6a65 6374 206f 6620 7479   an object of ty
-00000870: 7065 207b 2172 7d20 6275 7420 676f 7420  pe {!r} but got 
-00000880: 7b21 727d 2077 6974 6820 7479 7065 207b  {!r} with type {
-00000890: 2172 7d27 2e66 6f72 6d61 7428 4576 616c  !r}'.format(Eval
-000008a0: 7561 626c 652e 5f5f 7175 616c 6e61 6d65  uable.__qualname
-000008b0: 5f5f 2c20 7661 6c75 652c 2074 7970 6528  __, value, type(
-000008c0: 7661 6c75 6529 2e5f 5f71 7561 6c6e 616d  value).__qualnam
-000008d0: 655f 5f29 290a 2020 2020 7265 7475 726e  e__)).    return
-000008e0: 2076 616c 7565 0a0a 0a64 6566 2073 696d   value...def sim
-000008f0: 706c 6966 6965 6428 7661 6c75 6529 3a0a  plified(value):.
-00000900: 2020 2020 7265 7475 726e 2073 7472 6963      return stric
-00000910: 7465 7661 6c75 6162 6c65 2876 616c 7565  tevaluable(value
-00000920: 292e 7369 6d70 6c69 6669 6564 0a0a 0a5f  ).simplified..._
-00000930: 7479 7065 5f6f 7264 6572 203d 2062 6f6f  type_order = boo
-00000940: 6c2c 2069 6e74 2c20 666c 6f61 742c 2063  l, int, float, c
-00000950: 6f6d 706c 6578 0a61 7364 7479 7065 203d  omplex.asdtype =
-00000960: 206c 616d 6264 6120 6172 673a 2061 7267   lambda arg: arg
-00000970: 2069 6620 616e 7928 6172 6720 6973 2064   if any(arg is d
-00000980: 7479 7065 2066 6f72 2064 7479 7065 2069  type for dtype i
-00000990: 6e20 5f74 7970 655f 6f72 6465 7229 2065  n _type_order) e
-000009a0: 6c73 6520 7b27 6627 3a20 666c 6f61 742c  lse {'f': float,
-000009b0: 2027 6927 3a20 696e 742c 2027 6227 3a20   'i': int, 'b': 
-000009c0: 626f 6f6c 2c20 2763 273a 2063 6f6d 706c  bool, 'c': compl
-000009d0: 6578 7d5b 6e75 6d70 792e 6474 7970 6528  ex}[numpy.dtype(
-000009e0: 6172 6729 2e6b 696e 645d 0a0a 0a64 6566  arg).kind]...def
-000009f0: 2061 7361 7272 6179 2861 7267 293a 0a20   asarray(arg):. 
-00000a00: 2020 2069 6620 6861 7361 7474 7228 7479     if hasattr(ty
-00000a10: 7065 2861 7267 292c 2027 6173 5f65 7661  pe(arg), 'as_eva
-00000a20: 6c75 6162 6c65 5f61 7272 6179 2729 3a0a  luable_array'):.
-00000a30: 2020 2020 2020 2020 7265 7475 726e 2061          return a
-00000a40: 7267 2e61 735f 6576 616c 7561 626c 655f  rg.as_evaluable_
-00000a50: 6172 7261 790a 2020 2020 6966 205f 636f  array.    if _co
-00000a60: 6e74 6169 6e73 6172 7261 7928 6172 6729  ntainsarray(arg)
-00000a70: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00000a80: 2073 7461 636b 2861 7267 2c20 6178 6973   stack(arg, axis
-00000a90: 3d30 290a 2020 2020 656c 7365 3a0a 2020  =0).    else:.  
-00000aa0: 2020 2020 2020 7265 7475 726e 2043 6f6e        return Con
-00000ab0: 7374 616e 7428 6172 6729 0a0a 0a61 7361  stant(arg)...asa
-00000ac0: 7272 6179 7320 3d20 7479 7065 732e 7475  rrays = types.tu
-00000ad0: 706c 655b 6173 6172 7261 795d 0a0a 0a64  ple[asarray]...d
-00000ae0: 6566 2061 7369 6e64 6578 2861 7267 293a  ef asindex(arg):
-00000af0: 0a20 2020 2061 7267 203d 2061 7361 7272  .    arg = asarr
-00000b00: 6179 2861 7267 290a 2020 2020 6966 2061  ay(arg).    if a
-00000b10: 7267 2e6e 6469 6d20 6f72 2061 7267 2e64  rg.ndim or arg.d
-00000b20: 7479 7065 2021 3d20 696e 743a 0a20 2020  type != int:.   
-00000b30: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-00000b40: 4572 726f 7228 2761 7267 756d 656e 7420  Error('argument 
-00000b50: 6973 206e 6f74 2061 6e20 696e 6465 783a  is not an index:
-00000b60: 207b 7d27 2e66 6f72 6d61 7428 6172 6729   {}'.format(arg)
-00000b70: 290a 2020 2020 6966 2061 7267 2e5f 696e  ).    if arg._in
-00000b80: 7462 6f75 6e64 735b 305d 203c 2030 3a0a  tbounds[0] < 0:.
-00000b90: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-00000ba0: 6c75 6545 7272 6f72 2827 696e 6465 7820  lueError('index 
-00000bb0: 6d75 7374 2062 6520 6e6f 6e2d 6e65 6761  must be non-nega
-00000bc0: 7469 7665 2729 0a20 2020 2072 6574 7572  tive').    retur
-00000bd0: 6e20 6172 670a 0a0a 4074 7970 6573 2e61  n arg...@types.a
-00000be0: 7070 6c79 5f61 6e6e 6f74 6174 696f 6e73  pply_annotations
-00000bf0: 0a64 6566 2065 7175 616c 696e 6465 7828  .def equalindex(
-00000c00: 6e3a 2061 7369 6e64 6578 2c20 6d3a 2061  n: asindex, m: a
-00000c10: 7369 6e64 6578 293a 0a20 2020 2027 2727  sindex):.    '''
-00000c20: 436f 6d70 6172 6520 7477 6f20 6172 7261  Compare two arra
-00000c30: 7920 696e 6469 6365 732e 0a0a 2020 2020  y indices...    
-00000c40: 5265 7475 726e 7320 6054 7275 6560 2069  Returns `True` i
-00000c50: 6620 7468 6520 7477 6f20 696e 6469 6365  f the two indice
-00000c60: 7320 6172 6520 6365 7274 6169 6e6c 7920  s are certainly 
-00000c70: 6571 7561 6c2c 2060 4661 6c73 6560 2069  equal, `False` i
-00000c80: 6620 7468 6579 2061 7265 0a20 2020 2063  f they are.    c
-00000c90: 6572 7461 696e 6c79 206e 6f74 2065 7175  ertainly not equ
-00000ca0: 616c 2c20 6f72 2060 4e6f 6e65 6020 6966  al, or `None` if
-00000cb0: 2065 7175 616c 6974 7920 6361 6e6e 6f74   equality cannot
-00000cc0: 2062 6520 6465 7465 726d 696e 6564 2061   be determined a
-00000cd0: 7420 636f 6d70 696c 650a 2020 2020 7469  t compile.    ti
-00000ce0: 6d65 2e0a 2020 2020 2727 270a 0a20 2020  me..    '''..   
-00000cf0: 2069 6620 6e20 6973 206d 3a0a 2020 2020   if n is m:.    
-00000d00: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
-00000d10: 2020 2020 6e20 3d20 6e2e 7369 6d70 6c69      n = n.simpli
-00000d20: 6669 6564 0a20 2020 206d 203d 206d 2e73  fied.    m = m.s
-00000d30: 696d 706c 6966 6965 640a 2020 2020 6966  implified.    if
-00000d40: 206e 2069 7320 6d3a 0a20 2020 2020 2020   n is m:.       
-00000d50: 2072 6574 7572 6e20 5472 7565 0a20 2020   return True.   
-00000d60: 2069 6620 6e2e 6172 6775 6d65 6e74 7320   if n.arguments 
-00000d70: 213d 206d 2e61 7267 756d 656e 7473 3a0a  != m.arguments:.
-00000d80: 2020 2020 2020 2020 7265 7475 726e 2046          return F
-00000d90: 616c 7365 0a20 2020 2069 6620 6e2e 6973  alse.    if n.is
-00000da0: 636f 6e73 7461 6e74 3a20 2023 2069 6d70  constant:  # imp
-00000db0: 6c69 6573 206d 2e69 7363 6f6e 7374 616e  lies m.isconstan
-00000dc0: 740a 2020 2020 2020 2020 7265 7475 726e  t.        return
-00000dd0: 2069 6e74 286e 2920 3d3d 2069 6e74 286d   int(n) == int(m
-00000de0: 290a 0a0a 6173 7368 6170 6520 3d20 7479  )...asshape = ty
-00000df0: 7065 732e 7475 706c 655b 6173 696e 6465  pes.tuple[asinde
-00000e00: 785d 0a0a 0a40 7479 7065 732e 6170 706c  x]...@types.appl
-00000e10: 795f 616e 6e6f 7461 7469 6f6e 730a 6465  y_annotations.de
-00000e20: 6620 6571 7561 6c73 6861 7065 284e 3a20  f equalshape(N: 
-00000e30: 6173 7368 6170 652c 204d 3a20 6173 7368  asshape, M: assh
-00000e40: 6170 6529 3a0a 2020 2020 2727 2743 6f6d  ape):.    '''Com
-00000e50: 7061 7265 2074 776f 2061 7272 6179 2073  pare two array s
-00000e60: 6861 7065 732e 0a0a 2020 2020 5265 7475  hapes...    Retu
-00000e70: 726e 7320 6054 7275 6560 2069 6620 616c  rns `True` if al
-00000e80: 6c20 696e 6469 6365 7320 6172 6520 6365  l indices are ce
-00000e90: 7274 6169 6e6c 7920 6571 7561 6c2c 2060  rtainly equal, `
-00000ea0: 4661 6c73 6560 2069 6620 616e 7920 696e  False` if any in
-00000eb0: 6469 6365 7320 6172 650a 2020 2020 6365  dices are.    ce
-00000ec0: 7274 6169 6e6c 7920 6e6f 7420 6571 7561  rtainly not equa
-00000ed0: 6c2c 206f 7220 604e 6f6e 6560 2069 6620  l, or `None` if 
-00000ee0: 6571 7561 6c69 7479 2063 616e 6e6f 7420  equality cannot 
-00000ef0: 6265 2064 6574 6572 6d69 6e65 6420 6174  be determined at
-00000f00: 2063 6f6d 7069 6c65 0a20 2020 2074 696d   compile.    tim
-00000f10: 652e 0a20 2020 2027 2727 0a0a 2020 2020  e..    '''..    
-00000f20: 6966 204e 203d 3d20 4d3a 0a20 2020 2020  if N == M:.     
-00000f30: 2020 2072 6574 7572 6e20 5472 7565 0a20     return True. 
-00000f40: 2020 2069 6620 6c65 6e28 4e29 2021 3d20     if len(N) != 
-00000f50: 6c65 6e28 4d29 3a0a 2020 2020 2020 2020  len(M):.        
-00000f60: 7265 7475 726e 2046 616c 7365 0a20 2020  return False.   
-00000f70: 2072 6574 7661 6c20 3d20 5472 7565 0a20   retval = True. 
-00000f80: 2020 2066 6f72 2065 7120 696e 206d 6170     for eq in map
-00000f90: 2865 7175 616c 696e 6465 782c 204e 2c20  (equalindex, N, 
-00000fa0: 4d29 3a0a 2020 2020 2020 2020 6966 2065  M):.        if e
-00000fb0: 7120 3d3d 2046 616c 7365 3a0a 2020 2020  q == False:.    
-00000fc0: 2020 2020 2020 2020 7265 7475 726e 2046          return F
-00000fd0: 616c 7365 0a20 2020 2020 2020 2069 6620  alse.        if 
-00000fe0: 6571 203d 3d20 4e6f 6e65 3a0a 2020 2020  eq == None:.    
-00000ff0: 2020 2020 2020 2020 7265 7476 616c 203d          retval =
-00001000: 204e 6f6e 650a 2020 2020 7265 7475 726e   None.    return
-00001010: 2072 6574 7661 6c0a 0a0a 636c 6173 7320   retval...class 
-00001020: 4578 7065 6e73 6976 6545 7661 6c75 6174  ExpensiveEvaluat
-00001030: 696f 6e57 6172 6e69 6e67 2877 6172 6e69  ionWarning(warni
-00001040: 6e67 732e 4e75 7469 6c73 496e 6566 6669  ngs.NutilsIneffi
-00001050: 6369 656e 6379 5761 726e 696e 6729 3a0a  ciencyWarning):.
-00001060: 2020 2020 7061 7373 0a0a 0a64 6566 2072      pass...def r
-00001070: 6570 6c61 6365 2866 756e 633d 4e6f 6e65  eplace(func=None
-00001080: 2c20 6465 7074 6866 6972 7374 3d46 616c  , depthfirst=Fal
-00001090: 7365 2c20 7265 6375 7273 6976 653d 4661  se, recursive=Fa
-000010a0: 6c73 652c 206c 7275 3d34 293a 0a20 2020  lse, lru=4):.   
-000010b0: 2027 2727 6465 636f 7261 746f 7220 666f   '''decorator fo
-000010c0: 7220 6465 6570 206f 626a 6563 7420 7265  r deep object re
-000010d0: 706c 6163 656d 656e 740a 0a20 2020 2047  placement..    G
-000010e0: 656e 6572 6174 6573 2061 2064 6565 7020  enerates a deep 
-000010f0: 7265 706c 6163 656d 656e 7420 6d65 7468  replacement meth
-00001100: 6f64 2066 6f72 2067 656e 6572 616c 206f  od for general o
-00001110: 626a 6563 7473 2062 6173 6564 206f 6e20  bjects based on 
-00001120: 6120 6361 6c6c 6162 6c65 0a20 2020 2074  a callable.    t
-00001130: 6861 7420 6973 2061 7070 6c69 6564 2028  hat is applied (
-00001140: 7265 6375 7273 6976 656c 7929 206f 6e20  recursively) on 
-00001150: 696e 6469 7669 6475 616c 2063 6f6e 7374  individual const
-00001160: 7275 6374 6f72 2061 7267 756d 656e 7473  ructor arguments
-00001170: 2e0a 0a20 2020 2041 7267 730a 2020 2020  ...    Args.    
-00001180: 2d2d 2d2d 0a20 2020 2066 756e 630a 2020  ----.    func.  
-00001190: 2020 2020 2020 4361 6c6c 6162 6c65 2077        Callable w
-000011a0: 6869 6368 206d 6170 7320 616e 206f 626a  hich maps an obj
-000011b0: 6563 7420 6f6e 746f 2061 206e 6577 206f  ect onto a new o
-000011c0: 626a 6563 742c 206f 7220 604e 6f6e 6560  bject, or `None`
-000011d0: 2069 6620 6e6f 0a20 2020 2020 2020 2072   if no.        r
-000011e0: 6570 6c61 6365 6d65 6e74 2069 7320 6d61  eplacement is ma
-000011f0: 6465 2e20 4974 206d 7573 7420 6861 7665  de. It must have
-00001200: 206f 6e65 2070 6f73 6974 696f 6e61 6c20   one positional 
-00001210: 6172 6775 6d65 6e74 2066 6f72 2074 6865  argument for the
-00001220: 206f 626a 6563 742c 0a20 2020 2020 2020   object,.       
-00001230: 2061 6e64 206d 6179 2068 6176 6520 616e   and may have an
-00001240: 7920 6e75 6d62 6572 206f 6620 6164 6469  y number of addi
-00001250: 7469 6f6e 616c 2070 6f73 6974 696f 6e61  tional positiona
-00001260: 6c20 616e 642f 6f72 206b 6579 776f 7264  l and/or keyword
-00001270: 0a20 2020 2020 2020 2061 7267 756d 656e  .        argumen
-00001280: 7473 2e0a 2020 2020 6465 7074 6866 6972  ts..    depthfir
-00001290: 7374 203a 203a 636c 6173 733a 6062 6f6f  st : :class:`boo
-000012a0: 6c60 0a20 2020 2020 2020 2049 6620 6054  l`.        If `T
-000012b0: 7275 6560 2c20 6465 636f 6d70 6f73 6520  rue`, decompose 
-000012c0: 6561 6368 206f 626a 6563 7420 6173 2066  each object as f
-000012d0: 6172 2061 2070 6f73 7369 626c 652c 2074  ar a possible, t
-000012e0: 6865 6e20 6170 706c 7920 6066 756e 6360  hen apply `func`
-000012f0: 2074 6f0a 2020 2020 2020 2020 616c 6c20   to.        all 
-00001300: 6172 6775 6d65 6e74 7320 6173 2074 6865  arguments as the
-00001310: 206f 626a 6563 7473 2061 7265 2072 6563   objects are rec
-00001320: 6f6e 7374 7275 6374 6564 2e20 4f74 6865  onstructed. Othe
-00001330: 7277 6973 6520 6170 706c 7920 6066 756e  rwise apply `fun
-00001340: 6360 0a20 2020 2020 2020 2064 6972 6563  c`.        direc
-00001350: 746c 7920 6f6e 2065 6163 6820 6e65 7720  tly on each new 
-00001360: 6f62 6a65 6374 2074 6861 7420 6973 2065  object that is e
-00001370: 6e63 6f75 6e74 6572 6564 2069 6e20 7468  ncountered in th
-00001380: 6520 6465 636f 6d70 6f73 6974 696f 6e2c  e decomposition,
-00001390: 0a20 2020 2020 2020 2070 726f 6365 6469  .        procedi
-000013a0: 6e67 206f 6e6c 7920 6966 2074 6865 2072  ng only if the r
-000013b0: 6574 7572 6e20 7661 6c75 6520 6973 2060  eturn value is `
-000013c0: 4e6f 6e65 602e 0a20 2020 2072 6563 7572  None`..    recur
-000013d0: 7369 7665 203a 203a 636c 6173 733a 6062  sive : :class:`b
-000013e0: 6f6f 6c60 0a20 2020 2020 2020 2049 6620  ool`.        If 
-000013f0: 6054 7275 6560 2c20 7265 7065 6174 2072  `True`, repeat r
-00001400: 6570 6c61 6365 6d65 6e74 2066 6f72 2061  eplacement for a
-00001410: 6e79 206f 626a 6563 7420 7265 7475 726e  ny object return
-00001420: 6564 2062 7920 6066 756e 6360 2075 6e74  ed by `func` unt
-00001430: 696c 2069 740a 2020 2020 2020 2020 7265  il it.        re
-00001440: 7475 726e 7320 604e 6f6e 6560 2e20 4f74  turns `None`. Ot
-00001450: 6865 7277 6973 6520 7065 7266 6f72 6d20  herwise perform 
-00001460: 6120 7369 6e67 6c65 2c20 6e6f 6e2d 7265  a single, non-re
-00001470: 6375 7273 6976 6520 7377 6565 702e 0a20  cursive sweep.. 
-00001480: 2020 206c 7275 203a 203a 636c 6173 733a     lru : :class:
-00001490: 6069 6e74 600a 2020 2020 2020 2020 4d61  `int`.        Ma
-000014a0: 7869 6d75 6d20 7369 7a65 206f 6620 7468  ximum size of th
-000014b0: 6520 6c65 6173 742d 7265 6365 6e74 6c79  e least-recently
-000014c0: 2d75 7365 6420 6361 6368 652e 2041 2070  -used cache. A p
-000014d0: 6572 7369 7374 656e 7420 7765 616b 2d6b  ersistent weak-k
-000014e0: 6579 0a20 2020 2020 2020 2064 6963 7469  ey.        dicti
-000014f0: 6f6e 6172 7920 6973 206d 6169 6e74 6169  onary is maintai
-00001500: 6e65 6420 666f 7220 6576 6572 7920 756e  ned for every un
-00001510: 6971 7565 2073 6574 206f 6620 6675 6e63  ique set of func
-00001520: 7469 6f6e 2061 7267 756d 656e 7473 2e20  tion arguments. 
-00001530: 5768 656e 0a20 2020 2020 2020 2074 6865  When.        the
-00001540: 2073 697a 6520 6f66 2060 6c72 7560 2069   size of `lru` i
-00001550: 7320 7265 6163 6865 642c 2074 6865 206c  s reached, the l
-00001560: 6561 7374 2072 6563 656e 746c 7920 7573  east recently us
-00001570: 6564 2063 6163 6865 2069 7320 6472 6f70  ed cache is drop
-00001580: 7065 642e 0a0a 2020 2020 5265 7475 726e  ped...    Return
-00001590: 730a 2020 2020 2d2d 2d2d 2d2d 2d0a 2020  s.    -------.  
-000015a0: 2020 3a61 6e79 3a60 6361 6c6c 6162 6c65    :any:`callable
-000015b0: 600a 2020 2020 2020 2020 5468 6520 6d65  `.        The me
-000015c0: 7468 6f64 2074 6861 7420 7365 6172 6368  thod that search
-000015d0: 6573 2074 6865 206f 626a 6563 7420 746f  es the object to
-000015e0: 2070 6572 666f 726d 2074 6865 2072 6570   perform the rep
-000015f0: 6c61 6365 6d65 6e74 732e 0a20 2020 2027  lacements..    '
-00001600: 2727 0a0a 2020 2020 6966 2066 756e 6320  ''..    if func 
-00001610: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-00001620: 2072 6574 7572 6e20 6675 6e63 746f 6f6c   return functool
-00001630: 732e 7061 7274 6961 6c28 7265 706c 6163  s.partial(replac
-00001640: 652c 2064 6570 7468 6669 7273 743d 6465  e, depthfirst=de
-00001650: 7074 6866 6972 7374 2c20 7265 6375 7273  pthfirst, recurs
-00001660: 6976 653d 7265 6375 7273 6976 652c 206c  ive=recursive, l
-00001670: 7275 3d6c 7275 290a 0a20 2020 2073 6967  ru=lru)..    sig
-00001680: 6e61 7475 7265 203d 2069 6e73 7065 6374  nature = inspect
-00001690: 2e73 6967 6e61 7475 7265 2866 756e 6329  .signature(func)
-000016a0: 0a20 2020 2061 7267 756d 656e 7473 203d  .    arguments =
-000016b0: 205b 5d20 2023 206c 6973 7420 6f66 2070   []  # list of p
-000016c0: 6173 7420 6675 6e63 7469 6f6e 2061 7267  ast function arg
-000016d0: 756d 656e 7473 2c20 6c65 6173 7420 7265  uments, least re
-000016e0: 6365 6e74 6c79 2075 7365 6420 6c61 7374  cently used last
-000016f0: 0a20 2020 2063 6163 6865 7320 3d20 5b5d  .    caches = []
-00001700: 2020 2320 6c69 7374 206f 6620 7765 616b    # list of weak
-00001710: 2d6b 6579 2064 6963 7469 6f6e 6172 6965  -key dictionarie
-00001720: 7320 6d61 7463 6869 6e67 2061 7267 756d  s matching argum
-00001730: 656e 7473 2028 6162 6f76 6529 0a0a 2020  ents (above)..  
-00001740: 2020 7265 6d65 6d62 6572 203d 206f 626a    remember = obj
-00001750: 6563 7428 2920 2023 2074 6f6b 656e 2074  ect()  # token t
-00001760: 6f20 7369 676e 616c 2074 6861 7420 7273  o signal that rs
-00001770: 7461 636b 5b2d 315d 2063 616e 2062 6520  tack[-1] can be 
-00001780: 6361 6368 6564 2061 7320 7468 6520 7265  cached as the re
-00001790: 706c 6163 656d 656e 7420 6f66 2066 7374  placement of fst
-000017a0: 6163 6b5b 2d31 5d0a 2020 2020 7265 6372  ack[-1].    recr
-000017b0: 6561 7465 203d 206f 626a 6563 7428 2920  eate = object() 
-000017c0: 2023 2074 6f6b 656e 2074 6f20 7369 676e   # token to sign
-000017d0: 616c 2074 6861 7420 616c 6c20 6172 6775  al that all argu
-000017e0: 6d65 6e74 7320 666f 7220 6f62 6a65 6374  ments for object
-000017f0: 2072 6563 7265 6174 696f 6e20 6172 6520   recreation are 
-00001800: 7265 6164 7920 6f6e 2072 7374 6163 6b0a  ready on rstack.
-00001810: 2020 2020 7065 6e64 696e 6720 3d20 6f62      pending = ob
-00001820: 6a65 6374 2829 2020 2320 746f 6b65 6e20  ject()  # token 
-00001830: 746f 2068 6f6c 6420 7468 6520 706c 6163  to hold the plac
-00001840: 6520 6f66 2061 2063 6163 6861 626c 6520  e of a cachable 
-00001850: 6f62 6a65 6374 2070 656e 6469 6e67 2063  object pending c
-00001860: 7265 6174 696f 6e0a 2020 2020 6964 656e  reation.    iden
-00001870: 7469 7479 203d 206f 626a 6563 7428 2920  tity = object() 
-00001880: 2023 2074 6f6b 656e 2074 6f20 686f 6c64   # token to hold
-00001890: 2074 6865 2070 6c61 6365 206f 6620 7468   the place of th
-000018a0: 6520 6361 6368 6520 7661 6c75 6520 696e  e cache value in
-000018b0: 2063 6173 6520 6974 206d 6174 6368 6573   case it matches
-000018c0: 206b 6579 2c20 746f 2061 766f 6964 2063   key, to avoid c
-000018d0: 6972 6375 6c61 7220 7265 6665 7265 6e63  ircular referenc
-000018e0: 6573 0a0a 2020 2020 4066 756e 6374 6f6f  es..    @functoo
-000018f0: 6c73 2e77 7261 7073 2866 756e 6329 0a20  ls.wraps(func). 
-00001900: 2020 2064 6566 2077 7261 7070 6564 2874     def wrapped(t
-00001910: 6172 6765 742c 202a 6675 6e63 6172 6773  arget, *funcargs
-00001920: 2c20 2a2a 6675 6e63 6b77 6172 6773 293a  , **funckwargs):
-00001930: 0a0a 2020 2020 2020 2020 2320 7265 7472  ..        # retr
-00001940: 6965 7665 206f 7220 6372 6561 7465 2061  ieve or create a
-00001950: 2077 6561 6b2d 6b65 7920 6469 6374 696f   weak-key dictio
-00001960: 6e61 7279 0a20 2020 2020 2020 2062 6f75  nary.        bou
-00001970: 6e64 203d 2073 6967 6e61 7475 7265 2e62  nd = signature.b
-00001980: 696e 6428 4e6f 6e65 2c20 2a66 756e 6361  ind(None, *funca
-00001990: 7267 732c 202a 2a66 756e 636b 7761 7267  rgs, **funckwarg
-000019a0: 7329 0a20 2020 2020 2020 2062 6f75 6e64  s).        bound
-000019b0: 2e61 7070 6c79 5f64 6566 6175 6c74 7328  .apply_defaults(
-000019c0: 290a 2020 2020 2020 2020 7472 793a 0a20  ).        try:. 
-000019d0: 2020 2020 2020 2020 2020 2069 6e64 6578             index
-000019e0: 203d 2061 7267 756d 656e 7473 2e69 6e64   = arguments.ind
-000019f0: 6578 2862 6f75 6e64 2e61 7267 756d 656e  ex(bound.argumen
-00001a00: 7473 2920 2023 2062 7920 7573 696e 6720  ts)  # by using 
-00001a10: 696e 6465 782c 2061 7267 756d 656e 7473  index, arguments
-00001a20: 206e 6565 6420 6e6f 7420 6265 2068 6173   need not be has
-00001a30: 6861 626c 650a 2020 2020 2020 2020 6578  hable.        ex
-00001a40: 6365 7074 2056 616c 7565 4572 726f 723a  cept ValueError:
-00001a50: 0a20 2020 2020 2020 2020 2020 2069 6e64  .            ind
-00001a60: 6578 203d 202d 310a 2020 2020 2020 2020  ex = -1.        
-00001a70: 2020 2020 6361 6368 6520 3d20 7765 616b      cache = weak
-00001a80: 7265 662e 5765 616b 4b65 7944 6963 7469  ref.WeakKeyDicti
-00001a90: 6f6e 6172 7928 290a 2020 2020 2020 2020  onary().        
-00001aa0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00001ab0: 2020 6361 6368 6520 3d20 6361 6368 6573    cache = caches
-00001ac0: 5b69 6e64 6578 5d0a 2020 2020 2020 2020  [index].        
-00001ad0: 6966 2069 6e64 6578 2021 3d20 303a 2020  if index != 0:  
-00001ae0: 2320 6675 6e63 7469 6f6e 2061 7267 756d  # function argum
-00001af0: 656e 7473 2061 7265 206e 6f74 2074 6865  ents are not the
-00001b00: 206d 6f73 7420 7265 6365 6e74 2028 706f   most recent (po
-00001b10: 7373 6962 6c79 206e 6577 290a 2020 2020  ssibly new).    
-00001b20: 2020 2020 2020 2020 6966 2069 6e64 6578          if index
-00001b30: 203e 2030 206f 7220 6c65 6e28 6172 6775   > 0 or len(argu
-00001b40: 6d65 6e74 7329 203e 3d20 6c72 753a 0a20  ments) >= lru:. 
-00001b50: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00001b60: 6163 6865 732e 706f 7028 696e 6465 7829  aches.pop(index)
-00001b70: 2020 2320 706f 7020 6d61 7463 6869 6e67    # pop matching
-00001b80: 2028 6f72 206f 6c64 6573 7429 2069 7465   (or oldest) ite
-00001b90: 6d0a 2020 2020 2020 2020 2020 2020 2020  m.              
-00001ba0: 2020 6172 6775 6d65 6e74 732e 706f 7028    arguments.pop(
-00001bb0: 696e 6465 7829 0a20 2020 2020 2020 2020  index).         
-00001bc0: 2020 2063 6163 6865 732e 696e 7365 7274     caches.insert
-00001bd0: 2830 2c20 6361 6368 6529 2020 2320 696e  (0, cache)  # in
-00001be0: 7365 7274 2070 6f70 7065 6420 286f 7220  sert popped (or 
-00001bf0: 6e65 7729 2069 7465 6d20 746f 2066 726f  new) item to fro
-00001c00: 6e74 0a20 2020 2020 2020 2020 2020 2061  nt.            a
-00001c10: 7267 756d 656e 7473 2e69 6e73 6572 7428  rguments.insert(
-00001c20: 302c 2062 6f75 6e64 2e61 7267 756d 656e  0, bound.argumen
-00001c30: 7473 290a 0a20 2020 2020 2020 2066 7374  ts)..        fst
-00001c40: 6163 6b20 3d20 5b74 6172 6765 745d 2020  ack = [target]  
-00001c50: 2320 7374 6163 6b20 6f66 2075 6e70 726f  # stack of unpro
-00001c60: 6365 7373 6564 206f 626a 6563 7473 2061  cessed objects a
-00001c70: 6e64 2063 6f6d 6d61 6e64 2074 6f6b 656e  nd command token
-00001c80: 730a 2020 2020 2020 2020 7273 7461 636b  s.        rstack
-00001c90: 203d 205b 5d20 2023 2073 7461 636b 206f   = []  # stack o
-00001ca0: 6620 7072 6f63 6573 7365 6420 6f62 6a65  f processed obje
-00001cb0: 6374 730a 2020 2020 2020 2020 5f73 7461  cts.        _sta
-00001cc0: 636b 203d 2066 7374 6163 6b20 6966 2072  ck = fstack if r
-00001cd0: 6563 7572 7369 7665 2065 6c73 6520 7273  ecursive else rs
-00001ce0: 7461 636b 0a0a 2020 2020 2020 2020 7472  tack..        tr
-00001cf0: 793a 0a20 2020 2020 2020 2020 2020 2077  y:.            w
-00001d00: 6869 6c65 2066 7374 6163 6b3a 0a20 2020  hile fstack:.   
-00001d10: 2020 2020 2020 2020 2020 2020 206f 626a               obj
-00001d20: 203d 2066 7374 6163 6b2e 706f 7028 290a   = fstack.pop().
-00001d30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001d40: 2069 6620 6f62 6a20 6973 2072 6563 7265   if obj is recre
-00001d50: 6174 653a 0a20 2020 2020 2020 2020 2020  ate:.           
-00001d60: 2020 2020 2020 2020 2061 7267 7320 3d20           args = 
-00001d70: 5b72 7374 6163 6b2e 706f 7028 2920 666f  [rstack.pop() fo
-00001d80: 7220 6f62 6a20 696e 2072 616e 6765 2866  r obj in range(f
-00001d90: 7374 6163 6b2e 706f 7028 2929 5d0a 2020  stack.pop())].  
-00001da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001db0: 2020 6620 3d20 6673 7461 636b 2e70 6f70    f = fstack.pop
-00001dc0: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
-00001dd0: 2020 2020 2020 2072 203d 2066 282a 6172         r = f(*ar
-00001de0: 6773 290a 2020 2020 2020 2020 2020 2020  gs).            
-00001df0: 2020 2020 2020 2020 6966 2064 6570 7468          if depth
-00001e00: 6669 7273 743a 0a20 2020 2020 2020 2020  first:.         
-00001e10: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-00001e20: 6577 7220 3d20 6675 6e63 2872 2c20 2a66  ewr = func(r, *f
-00001e30: 756e 6361 7267 732c 202a 2a66 756e 636b  uncargs, **funck
-00001e40: 7761 7267 7329 0a20 2020 2020 2020 2020  wargs).         
-00001e50: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00001e60: 6620 6e65 7772 2069 7320 6e6f 7420 4e6f  f newr is not No
-00001e70: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00001e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001e90: 5f73 7461 636b 2e61 7070 656e 6428 6e65  _stack.append(ne
-00001ea0: 7772 290a 2020 2020 2020 2020 2020 2020  wr).            
-00001eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001ec0: 636f 6e74 696e 7565 0a20 2020 2020 2020  continue.       
-00001ed0: 2020 2020 2020 2020 2020 2020 2072 7374               rst
-00001ee0: 6163 6b2e 6170 7065 6e64 2872 290a 2020  ack.append(r).  
-00001ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001f00: 2020 636f 6e74 696e 7565 0a0a 2020 2020    continue..    
-00001f10: 2020 2020 2020 2020 2020 2020 6966 206f              if o
-00001f20: 626a 2069 7320 7265 6d65 6d62 6572 3a0a  bj is remember:.
-00001f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001f40: 2020 2020 6f62 6a20 3d20 6673 7461 636b      obj = fstack
-00001f50: 2e70 6f70 2829 0a20 2020 2020 2020 2020  .pop().         
-00001f60: 2020 2020 2020 2020 2020 2063 6163 6865             cache
-00001f70: 5b6f 626a 5d20 3d20 7273 7461 636b 5b2d  [obj] = rstack[-
-00001f80: 315d 2069 6620 7273 7461 636b 5b2d 315d  1] if rstack[-1]
-00001f90: 2069 7320 6e6f 7420 6f62 6a20 656c 7365   is not obj else
-00001fa0: 2069 6465 6e74 6974 790a 2020 2020 2020   identity.      
-00001fb0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00001fc0: 6e74 696e 7565 0a0a 2020 2020 2020 2020  ntinue..        
-00001fd0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
-00001fe0: 7461 6e63 6528 6f62 6a2c 2028 7475 706c  tance(obj, (tupl
-00001ff0: 652c 206c 6973 742c 2064 6963 742c 2073  e, list, dict, s
-00002000: 6574 2c20 6672 6f7a 656e 7365 7429 293a  et, frozenset)):
-00002010: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002020: 2020 2020 2069 6620 6e6f 7420 6f62 6a3a       if not obj:
-00002030: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002040: 2020 2020 2020 2020 2072 7374 6163 6b2e           rstack.
-00002050: 6170 7065 6e64 286f 626a 2920 2023 2073  append(obj)  # s
-00002060: 686f 7274 6375 7420 746f 2061 766f 6964  hortcut to avoid
-00002070: 2072 6563 7265 6174 696f 6e20 6f66 2065   recreation of e
-00002080: 6d70 7479 2063 6f6e 7461 696e 6572 0a20  mpty container. 
-00002090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000020a0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-000020b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000020c0: 2066 7374 6163 6b2e 6170 7065 6e64 286c   fstack.append(l
-000020d0: 616d 6264 6120 2a78 2c20 543d 7479 7065  ambda *x, T=type
-000020e0: 286f 626a 293a 2054 2878 2929 0a20 2020  (obj): T(x)).   
-000020f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002100: 2020 2020 2066 7374 6163 6b2e 6170 7065       fstack.appe
-00002110: 6e64 286c 656e 286f 626a 2929 0a20 2020  nd(len(obj)).   
-00002120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002130: 2020 2020 2066 7374 6163 6b2e 6170 7065       fstack.appe
-00002140: 6e64 2872 6563 7265 6174 6529 0a20 2020  nd(recreate).   
-00002150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002160: 2020 2020 2066 7374 6163 6b2e 6578 7465       fstack.exte
-00002170: 6e64 286f 626a 2069 6620 6e6f 7420 6973  nd(obj if not is
-00002180: 696e 7374 616e 6365 286f 626a 2c20 6469  instance(obj, di
-00002190: 6374 2920 656c 7365 206f 626a 2e69 7465  ct) else obj.ite
-000021a0: 6d73 2829 290a 2020 2020 2020 2020 2020  ms()).          
-000021b0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-000021c0: 7565 0a0a 2020 2020 2020 2020 2020 2020  ue..            
-000021d0: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-000021e0: 2020 2020 2020 2020 2020 2020 2072 203d               r =
-000021f0: 2063 6163 6865 5b6f 626a 5d0a 2020 2020   cache[obj].    
-00002200: 2020 2020 2020 2020 2020 2020 6578 6365              exce
-00002210: 7074 204b 6579 4572 726f 723a 2020 2320  pt KeyError:  # 
-00002220: 6f62 6a65 6374 2063 616e 2062 6520 7765  object can be we
-00002230: 616b 6c79 2063 6163 6865 642c 2062 7574  akly cached, but
-00002240: 2069 736e 2774 0a20 2020 2020 2020 2020   isn't.         
-00002250: 2020 2020 2020 2020 2020 2063 6163 6865             cache
-00002260: 5b6f 626a 5d20 3d20 7065 6e64 696e 670a  [obj] = pending.
-00002270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002280: 2020 2020 6673 7461 636b 2e61 7070 656e      fstack.appen
-00002290: 6428 6f62 6a29 0a20 2020 2020 2020 2020  d(obj).         
-000022a0: 2020 2020 2020 2020 2020 2066 7374 6163             fstac
-000022b0: 6b2e 6170 7065 6e64 2872 656d 656d 6265  k.append(remembe
-000022c0: 7229 0a20 2020 2020 2020 2020 2020 2020  r).             
-000022d0: 2020 2065 7863 6570 7420 5479 7065 4572     except TypeEr
-000022e0: 726f 723a 2020 2320 6f62 6a65 6374 2063  ror:  # object c
-000022f0: 616e 6e6f 7420 6265 2072 6566 6572 656e  annot be referen
-00002300: 6365 6420 6f72 2069 7320 6e6f 7420 6861  ced or is not ha
-00002310: 7368 6162 6c65 0a20 2020 2020 2020 2020  shable.         
-00002320: 2020 2020 2020 2020 2020 2070 6173 730a             pass.
-00002330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002340: 656c 7365 3a20 2023 206f 626a 6563 7420  else:  # object 
-00002350: 6973 2069 6e20 6361 6368 650a 2020 2020  is in cache.    
-00002360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002370: 6966 2072 2069 7320 7065 6e64 696e 673a  if r is pending:
-00002380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002390: 2020 2020 2020 2020 2070 656e 6469 6e67           pending
-000023a0: 5f6f 626a 7320 3d20 5b6b 2066 6f72 206b  _objs = [k for k
-000023b0: 2c20 7620 696e 2063 6163 6865 2e69 7465  , v in cache.ite
-000023c0: 6d73 2829 2069 6620 7620 6973 2070 656e  ms() if v is pen
-000023d0: 6469 6e67 5d0a 2020 2020 2020 2020 2020  ding].          
-000023e0: 2020 2020 2020 2020 2020 2020 2020 696e                in
-000023f0: 6465 7820 3d20 7065 6e64 696e 675f 6f62  dex = pending_ob
-00002400: 6a73 2e69 6e64 6578 286f 626a 290a 2020  js.index(obj).  
-00002410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002420: 2020 2020 2020 7261 6973 6520 4578 6365        raise Exce
-00002430: 7074 696f 6e28 277b 7d40 7265 706c 6163  ption('{}@replac
-00002440: 6520 6361 7567 6874 2069 6e20 6120 6369  e caught in a ci
-00002450: 7263 756c 6172 2064 6570 656e 6465 6e63  rcular dependenc
-00002460: 655c 6e27 2e66 6f72 6d61 7428 6675 6e63  e\n'.format(func
-00002470: 2e5f 5f6e 616d 655f 5f29 202b 2054 7570  .__name__) + Tup
-00002480: 6c65 2870 656e 6469 6e67 5f6f 626a 735b  le(pending_objs[
-00002490: 696e 6465 783a 5d29 2e61 7363 6969 7472  index:]).asciitr
-000024a0: 6565 2829 2e73 706c 6974 2827 5c6e 272c  ee().split('\n',
-000024b0: 2031 295b 315d 290a 2020 2020 2020 2020   1)[1]).        
-000024c0: 2020 2020 2020 2020 2020 2020 7273 7461              rsta
-000024d0: 636b 2e61 7070 656e 6428 7220 6966 2072  ck.append(r if r
-000024e0: 2069 7320 6e6f 7420 6964 656e 7469 7479   is not identity
-000024f0: 2065 6c73 6520 6f62 6a29 0a20 2020 2020   else obj).     
-00002500: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00002510: 6f6e 7469 6e75 650a 0a20 2020 2020 2020  ontinue..       
-00002520: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-00002530: 6465 7074 6866 6972 7374 3a0a 2020 2020  depthfirst:.    
-00002540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002550: 6e65 7772 203d 2066 756e 6328 6f62 6a2c  newr = func(obj,
-00002560: 202a 6675 6e63 6172 6773 2c20 2a2a 6675   *funcargs, **fu
-00002570: 6e63 6b77 6172 6773 290a 2020 2020 2020  nckwargs).      
-00002580: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00002590: 206e 6577 7220 6973 206e 6f74 204e 6f6e   newr is not Non
-000025a0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-000025b0: 2020 2020 2020 2020 2020 205f 7374 6163             _stac
-000025c0: 6b2e 6170 7065 6e64 286e 6577 7229 0a20  k.append(newr). 
-000025d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025e0: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
-000025f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002600: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
-00002610: 2020 2020 2020 2020 2020 662c 2061 7267            f, arg
-00002620: 7320 3d20 6f62 6a2e 5f5f 7265 6475 6365  s = obj.__reduce
-00002630: 5f5f 2829 0a20 2020 2020 2020 2020 2020  __().           
-00002640: 2020 2020 2065 7863 6570 743a 2020 2320       except:  # 
-00002650: 6f62 6a20 6361 6e6e 6f74 2062 6520 7265  obj cannot be re
-00002660: 6475 6365 6420 696e 746f 2061 2063 6f6e  duced into a con
-00002670: 7374 7275 6374 6f72 2061 6e64 2069 7473  structor and its
-00002680: 2061 7267 756d 656e 7473 0a20 2020 2020   arguments.     
-00002690: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000026a0: 7374 6163 6b2e 6170 7065 6e64 286f 626a  stack.append(obj
-000026b0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-000026c0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-000026d0: 2020 2020 2020 2020 2020 2020 6673 7461              fsta
-000026e0: 636b 2e61 7070 656e 6428 6629 0a20 2020  ck.append(f).   
-000026f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002700: 2066 7374 6163 6b2e 6170 7065 6e64 286c   fstack.append(l
-00002710: 656e 2861 7267 7329 290a 2020 2020 2020  en(args)).      
-00002720: 2020 2020 2020 2020 2020 2020 2020 6673                fs
-00002730: 7461 636b 2e61 7070 656e 6428 7265 6372  tack.append(recr
-00002740: 6561 7465 290a 2020 2020 2020 2020 2020  eate).          
-00002750: 2020 2020 2020 2020 2020 6673 7461 636b            fstack
-00002760: 2e65 7874 656e 6428 6172 6773 290a 0a20  .extend(args).. 
-00002770: 2020 2020 2020 2020 2020 2061 7373 6572             asser
-00002780: 7420 6c65 6e28 7273 7461 636b 2920 3d3d  t len(rstack) ==
-00002790: 2031 0a0a 2020 2020 2020 2020 6669 6e61   1..        fina
-000027a0: 6c6c 793a 0a20 2020 2020 2020 2020 2020  lly:.           
-000027b0: 2077 6869 6c65 2066 7374 6163 6b3a 0a20   while fstack:. 
-000027c0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000027d0: 6620 6673 7461 636b 2e70 6f70 2829 2069  f fstack.pop() i
-000027e0: 7320 7265 6d65 6d62 6572 3a0a 2020 2020  s remember:.    
-000027f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002800: 6173 7365 7274 2063 6163 6865 2e70 6f70  assert cache.pop
-00002810: 2866 7374 6163 6b2e 706f 7028 2929 2069  (fstack.pop()) i
-00002820: 7320 7065 6e64 696e 670a 0a20 2020 2020  s pending..     
-00002830: 2020 2072 6574 7572 6e20 7273 7461 636b     return rstack
-00002840: 5b30 5d0a 0a20 2020 2072 6574 7572 6e20  [0]..    return 
-00002850: 7772 6170 7065 640a 0a0a 636c 6173 7320  wrapped...class 
-00002860: 4576 616c 7561 626c 6528 7479 7065 732e  Evaluable(types.
-00002870: 5369 6e67 6c65 746f 6e29 3a0a 2020 2020  Singleton):.    
-00002880: 2742 6173 6520 636c 6173 7327 0a0a 2020  'Base class'..  
-00002890: 2020 5f5f 736c 6f74 735f 5f20 3d20 275f    __slots__ = '_
-000028a0: 5f61 7267 7327 0a20 2020 205f 5f63 6163  _args'.    __cac
-000028b0: 6865 5f5f 203d 2027 6465 7065 6e64 656e  he__ = 'dependen
-000028c0: 6369 6573 272c 2027 6172 6775 6d65 6e74  cies', 'argument
-000028d0: 7327 2c20 276f 7264 6572 6564 6465 7073  s', 'ordereddeps
-000028e0: 272c 2027 6465 7065 6e64 656e 6379 7472  ', 'dependencytr
-000028f0: 6565 272c 2027 6f70 7469 6d69 7a65 645f  ee', 'optimized_
-00002900: 666f 725f 6e75 6d70 7927 2c20 275f 6c6f  for_numpy', '_lo
-00002910: 6f70 5f63 6f6e 6361 7465 6e61 7465 5f64  op_concatenate_d
-00002920: 6570 7327 0a0a 2020 2020 4074 7970 6573  eps'..    @types
-00002930: 2e61 7070 6c79 5f61 6e6e 6f74 6174 696f  .apply_annotatio
-00002940: 6e73 0a20 2020 2064 6566 205f 5f69 6e69  ns.    def __ini
-00002950: 745f 5f28 7365 6c66 2c20 6172 6773 3a20  t__(self, args: 
-00002960: 7479 7065 732e 7475 706c 655b 7374 7269  types.tuple[stri
-00002970: 6374 6576 616c 7561 626c 655d 293a 0a20  ctevaluable]):. 
-00002980: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
-00002990: 5f69 6e69 745f 5f28 290a 2020 2020 2020  _init__().      
-000029a0: 2020 7365 6c66 2e5f 5f61 7267 7320 3d20    self.__args = 
-000029b0: 6172 6773 0a0a 2020 2020 6465 6620 6576  args..    def ev
-000029c0: 616c 6628 7365 6c66 2c20 2a61 7267 7329  alf(self, *args)
-000029d0: 3a0a 2020 2020 2020 2020 7261 6973 6520  :.        raise 
-000029e0: 4e6f 7449 6d70 6c65 6d65 6e74 6564 4572  NotImplementedEr
-000029f0: 726f 7228 2745 7661 6c75 6162 6c65 2064  ror('Evaluable d
-00002a00: 6572 6976 6174 6976 6573 2073 686f 756c  erivatives shoul
-00002a10: 6420 696d 706c 656d 656e 7420 7468 6520  d implement the 
-00002a20: 6576 616c 6620 6d65 7468 6f64 2729 0a0a  evalf method')..
-00002a30: 2020 2020 6465 6620 6576 616c 665f 7769      def evalf_wi
-00002a40: 7468 7469 6d65 7328 7365 6c66 2c20 7469  thtimes(self, ti
-00002a50: 6d65 732c 202a 6172 6773 293a 0a20 2020  mes, *args):.   
-00002a60: 2020 2020 2077 6974 6820 7469 6d65 735b       with times[
-00002a70: 7365 6c66 5d3a 0a20 2020 2020 2020 2020  self]:.         
-00002a80: 2020 2072 6574 7572 6e20 7365 6c66 2e65     return self.e
-00002a90: 7661 6c66 282a 6172 6773 290a 0a20 2020  valf(*args)..   
-00002aa0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-00002ab0: 6566 2064 6570 656e 6465 6e63 6965 7328  ef dependencies(
-00002ac0: 7365 6c66 293a 0a20 2020 2020 2020 2027  self):.        '
-00002ad0: 2727 636f 6c6c 6563 7469 6f6e 206f 6620  ''collection of 
-00002ae0: 616c 6c20 6675 6e63 7469 6f6e 2061 7267  all function arg
-00002af0: 756d 656e 7473 2727 270a 2020 2020 2020  uments'''.      
-00002b00: 2020 6465 7073 203d 207b 7d0a 2020 2020    deps = {}.    
-00002b10: 2020 2020 666f 7220 6675 6e63 2069 6e20      for func in 
-00002b20: 7365 6c66 2e5f 5f61 7267 733a 0a20 2020  self.__args:.   
-00002b30: 2020 2020 2020 2020 2066 756e 6364 6570           funcdep
-00002b40: 7320 3d20 6675 6e63 2e64 6570 656e 6465  s = func.depende
-00002b50: 6e63 6965 730a 2020 2020 2020 2020 2020  ncies.          
-00002b60: 2020 6465 7073 2e75 7064 6174 6528 6675    deps.update(fu
-00002b70: 6e63 6465 7073 290a 2020 2020 2020 2020  ncdeps).        
-00002b80: 2020 2020 6465 7073 5b66 756e 635d 203d      deps[func] =
-00002b90: 206c 656e 2866 756e 6364 6570 7329 0a20   len(funcdeps). 
-00002ba0: 2020 2020 2020 2072 6574 7572 6e20 7479         return ty
-00002bb0: 7065 732e 6672 6f7a 656e 6469 6374 2864  pes.frozendict(d
-00002bc0: 6570 7329 0a0a 2020 2020 4070 726f 7065  eps)..    @prope
-00002bd0: 7274 790a 2020 2020 6465 6620 6172 6775  rty.    def argu
-00002be0: 6d65 6e74 7328 7365 6c66 293a 0a20 2020  ments(self):.   
-00002bf0: 2020 2020 2027 6120 6672 6f7a 656e 7365       'a frozense
-00002c00: 7420 6f66 2061 6c6c 2061 7267 756d 656e  t of all argumen
-00002c10: 7473 206f 6620 7468 6973 2065 7661 6c75  ts of this evalu
-00002c20: 6162 6c65 270a 2020 2020 2020 2020 7265  able'.        re
-00002c30: 7475 726e 2066 726f 7a65 6e73 6574 2829  turn frozenset()
-00002c40: 2e75 6e69 6f6e 282a 2863 6869 6c64 2e61  .union(*(child.a
-00002c50: 7267 756d 656e 7473 2066 6f72 2063 6869  rguments for chi
-00002c60: 6c64 2069 6e20 7365 6c66 2e5f 5f61 7267  ld in self.__arg
-00002c70: 7329 290a 0a20 2020 2040 7072 6f70 6572  s))..    @proper
-00002c80: 7479 0a20 2020 2064 6566 2069 7363 6f6e  ty.    def iscon
-00002c90: 7374 616e 7428 7365 6c66 293a 0a20 2020  stant(self):.   
-00002ca0: 2020 2020 2072 6574 7572 6e20 4556 414c       return EVAL
-00002cb0: 4152 4753 206e 6f74 2069 6e20 7365 6c66  ARGS not in self
-00002cc0: 2e64 6570 656e 6465 6e63 6965 730a 0a20  .dependencies.. 
-00002cd0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00002ce0: 2064 6566 206f 7264 6572 6564 6465 7073   def ordereddeps
-00002cf0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00002d00: 2727 2763 6f6c 6c65 6374 696f 6e20 6f66  '''collection of
-00002d10: 2061 6c6c 2066 756e 6374 696f 6e20 6172   all function ar
-00002d20: 6775 6d65 6e74 7320 7375 6368 2074 6861  guments such tha
-00002d30: 7420 7468 6520 6172 6775 6d65 6e74 7320  t the arguments 
-00002d40: 746f 0a20 2020 2020 2020 2064 6570 656e  to.        depen
-00002d50: 6465 6e63 6965 735b 695d 2063 616e 2062  dencies[i] can b
-00002d60: 6520 666f 756e 6420 696e 2064 6570 656e  e found in depen
-00002d70: 6465 6e63 6965 735b 3a69 5d27 2727 0a20  dencies[:i]'''. 
-00002d80: 2020 2020 2020 2064 6570 7320 3d20 7365         deps = se
-00002d90: 6c66 2e64 6570 656e 6465 6e63 6965 732e  lf.dependencies.
-00002da0: 636f 7079 2829 0a20 2020 2020 2020 2064  copy().        d
-00002db0: 6570 732e 706f 7028 4556 414c 4152 4753  eps.pop(EVALARGS
-00002dc0: 2c20 4e6f 6e65 290a 2020 2020 2020 2020  , None).        
-00002dd0: 7265 7475 726e 2074 7570 6c65 285b 4556  return tuple([EV
-00002de0: 414c 4152 4753 5d20 2b20 736f 7274 6564  ALARGS] + sorted
-00002df0: 2864 6570 732c 206b 6579 3d64 6570 732e  (deps, key=deps.
-00002e00: 5f5f 6765 7469 7465 6d5f 5f29 290a 0a20  __getitem__)).. 
-00002e10: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00002e20: 2064 6566 2064 6570 656e 6465 6e63 7974   def dependencyt
-00002e30: 7265 6528 7365 6c66 293a 0a20 2020 2020  ree(self):.     
-00002e40: 2020 2027 2727 6c6f 6f6b 7570 2074 6162     '''lookup tab
-00002e50: 6c65 206f 6620 6675 6e63 7469 6f6e 2061  le of function a
-00002e60: 7267 756d 656e 7473 2069 6e74 6f20 6f72  rguments into or
-00002e70: 6465 7265 6464 6570 732c 2073 7563 6820  dereddeps, such 
-00002e80: 7468 6174 0a20 2020 2020 2020 206f 7264  that.        ord
-00002e90: 6572 6564 6465 7073 5b69 5d2e 5f5f 6172  ereddeps[i].__ar
-00002ea0: 6773 5b6a 5d20 3d3d 206f 7264 6572 6564  gs[j] == ordered
-00002eb0: 6465 7073 5b64 6570 656e 6465 6e63 7974  deps[dependencyt
-00002ec0: 7265 655b 695d 5b6a 5d5d 2c20 616e 640a  ree[i][j]], and.
-00002ed0: 2020 2020 2020 2020 7365 6c66 2e5f 5f61          self.__a
-00002ee0: 7267 735b 6a5d 203d 3d20 6f72 6465 7265  rgs[j] == ordere
-00002ef0: 6464 6570 735b 6465 7065 6e64 656e 6379  ddeps[dependency
-00002f00: 7472 6565 5b2d 315d 5b6a 5d5d 2727 270a  tree[-1][j]]'''.
-00002f10: 2020 2020 2020 2020 6172 6773 203d 2073          args = s
-00002f20: 656c 662e 6f72 6465 7265 6464 6570 730a  elf.ordereddeps.
-00002f30: 2020 2020 2020 2020 7265 7475 726e 2074          return t
-00002f40: 7570 6c65 2874 7570 6c65 286d 6170 2861  uple(tuple(map(a
-00002f50: 7267 732e 696e 6465 782c 2066 756e 632e  rgs.index, func.
-00002f60: 5f5f 6172 6773 2929 2066 6f72 2066 756e  __args)) for fun
-00002f70: 6320 696e 2061 7267 732b 2873 656c 662c  c in args+(self,
-00002f80: 2929 0a0a 2020 2020 4070 726f 7065 7274  ))..    @propert
-00002f90: 790a 2020 2020 6465 6620 7365 7269 616c  y.    def serial
-00002fa0: 697a 6564 2873 656c 6629 3a0a 2020 2020  ized(self):.    
-00002fb0: 2020 2020 7265 7475 726e 207a 6970 2873      return zip(s
-00002fc0: 656c 662e 6f72 6465 7265 6464 6570 735b  elf.ordereddeps[
-00002fd0: 313a 5d2b 2873 656c 662c 292c 2073 656c  1:]+(self,), sel
-00002fe0: 662e 6465 7065 6e64 656e 6379 7472 6565  f.dependencytree
-00002ff0: 5b31 3a5d 290a 0a20 2020 2064 6566 205f  [1:])..    def _
-00003000: 6e6f 6465 2873 656c 662c 2063 6163 6865  node(self, cache
-00003010: 2c20 7375 6267 7261 7068 2c20 7469 6d65  , subgraph, time
-00003020: 7329 3a0a 2020 2020 2020 2020 6966 2073  s):.        if s
-00003030: 656c 6620 696e 2063 6163 6865 3a0a 2020  elf in cache:.  
-00003040: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00003050: 2063 6163 6865 5b73 656c 665d 0a20 2020   cache[self].   
-00003060: 2020 2020 2061 7267 7320 3d20 7475 706c       args = tupl
-00003070: 6528 6172 672e 5f6e 6f64 6528 6361 6368  e(arg._node(cach
-00003080: 652c 2073 7562 6772 6170 682c 2074 696d  e, subgraph, tim
-00003090: 6573 2920 666f 7220 6172 6720 696e 2073  es) for arg in s
-000030a0: 656c 662e 5f5f 6172 6773 290a 2020 2020  elf.__args).    
-000030b0: 2020 2020 6c61 6265 6c20 3d20 275c 6e27      label = '\n'
-000030c0: 2e6a 6f69 6e28 6669 6c74 6572 284e 6f6e  .join(filter(Non
-000030d0: 652c 2028 7479 7065 2873 656c 6629 2e5f  e, (type(self)._
-000030e0: 5f6e 616d 655f 5f2c 2073 656c 662e 5f6e  _name__, self._n
-000030f0: 6f64 655f 6465 7461 696c 7329 2929 0a20  ode_details))). 
-00003100: 2020 2020 2020 2063 6163 6865 5b73 656c         cache[sel
-00003110: 665d 203d 206e 6f64 6520 3d20 5265 6775  f] = node = Regu
-00003120: 6c61 724e 6f64 6528 6c61 6265 6c2c 2061  larNode(label, a
-00003130: 7267 732c 207b 7d2c 2028 7479 7065 2873  rgs, {}, (type(s
-00003140: 656c 6629 2e5f 5f6e 616d 655f 5f2c 2074  elf).__name__, t
-00003150: 696d 6573 5b73 656c 665d 292c 2073 7562  imes[self]), sub
-00003160: 6772 6170 6829 0a20 2020 2020 2020 2072  graph).        r
-00003170: 6574 7572 6e20 6e6f 6465 0a0a 2020 2020  eturn node..    
-00003180: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-00003190: 6620 5f6e 6f64 655f 6465 7461 696c 7328  f _node_details(
-000031a0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-000031b0: 6574 7572 6e20 2727 0a0a 2020 2020 6465  eturn ''..    de
-000031c0: 6620 6173 6369 6974 7265 6528 7365 6c66  f asciitree(self
-000031d0: 2c20 7269 6368 6f75 7470 7574 3d46 616c  , richoutput=Fal
-000031e0: 7365 293a 0a20 2020 2020 2020 2027 7374  se):.        'st
-000031f0: 7269 6e67 2072 6570 7265 7365 6e74 6174  ring representat
-00003200: 696f 6e27 0a0a 2020 2020 2020 2020 7265  ion'..        re
-00003210: 7475 726e 2073 656c 662e 5f6e 6f64 6528  turn self._node(
-00003220: 7b7d 2c20 4e6f 6e65 2c20 636f 6c6c 6563  {}, None, collec
-00003230: 7469 6f6e 732e 6465 6661 756c 7464 6963  tions.defaultdic
-00003240: 7428 5f53 7461 7473 2929 2e67 656e 6572  t(_Stats)).gener
-00003250: 6174 655f 6173 6369 6974 7265 6528 7269  ate_asciitree(ri
-00003260: 6368 6f75 7470 7574 290a 0a20 2020 2064  choutput)..    d
-00003270: 6566 205f 5f73 7472 5f5f 2873 656c 6629  ef __str__(self)
-00003280: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00003290: 2073 656c 662e 5f5f 636c 6173 735f 5f2e   self.__class__.
-000032a0: 5f5f 6e61 6d65 5f5f 0a0a 2020 2020 6465  __name__..    de
-000032b0: 6620 6576 616c 2873 656c 662c 202a 2a65  f eval(self, **e
-000032c0: 7661 6c61 7267 7329 3a0a 2020 2020 2020  valargs):.      
-000032d0: 2020 2727 2745 7661 6c75 6174 6520 6675    '''Evaluate fu
-000032e0: 6e63 7469 6f6e 206f 6e20 6120 7370 6563  nction on a spec
-000032f0: 6966 6965 6420 656c 656d 656e 742c 2070  ified element, p
-00003300: 6f69 6e74 2073 6574 2e27 2727 0a0a 2020  oint set.'''..  
-00003310: 2020 2020 2020 7661 6c75 6573 203d 205b        values = [
-00003320: 6576 616c 6172 6773 5d0a 2020 2020 2020  evalargs].      
-00003330: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
-00003340: 2020 2076 616c 7565 732e 6578 7465 6e64     values.extend
-00003350: 286f 702e 6576 616c 6628 2a5b 7661 6c75  (op.evalf(*[valu
-00003360: 6573 5b69 5d20 666f 7220 6920 696e 2069  es[i] for i in i
-00003370: 6e64 6963 6573 5d29 2066 6f72 206f 702c  ndices]) for op,
-00003380: 2069 6e64 6963 6573 2069 6e20 7365 6c66   indices in self
-00003390: 2e73 6572 6961 6c69 7a65 6429 0a20 2020  .serialized).   
-000033a0: 2020 2020 2065 7863 6570 7420 4b65 7962       except Keyb
-000033b0: 6f61 7264 496e 7465 7272 7570 743a 0a20  oardInterrupt:. 
-000033c0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-000033d0: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
-000033e0: 4578 6365 7074 696f 6e20 6173 2065 3a0a  Exception as e:.
-000033f0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00003400: 6520 4576 616c 7561 7469 6f6e 4572 726f  e EvaluationErro
-00003410: 7228 7365 6c66 2c20 7661 6c75 6573 2920  r(self, values) 
-00003420: 6672 6f6d 2065 0a20 2020 2020 2020 2065  from e.        e
-00003430: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00003440: 2072 6574 7572 6e20 7661 6c75 6573 5b2d   return values[-
-00003450: 315d 0a0a 2020 2020 6465 6620 6576 616c  1]..    def eval
-00003460: 5f77 6974 6874 696d 6573 2873 656c 662c  _withtimes(self,
-00003470: 2074 696d 6573 2c20 2a2a 6576 616c 6172   times, **evalar
-00003480: 6773 293a 0a20 2020 2020 2020 2027 2727  gs):.        '''
-00003490: 4576 616c 7561 7465 2066 756e 6374 696f  Evaluate functio
-000034a0: 6e20 6f6e 2061 2073 7065 6369 6669 6564  n on a specified
-000034b0: 2065 6c65 6d65 6e74 2c20 706f 696e 7420   element, point 
-000034c0: 7365 7420 7768 696c 6520 6d65 6173 7572  set while measur
-000034d0: 6520 7469 6d65 206f 6620 6561 6368 2073  e time of each s
-000034e0: 7465 702e 2727 270a 0a20 2020 2020 2020  tep.'''..       
-000034f0: 2076 616c 7565 7320 3d20 5b65 7661 6c61   values = [evala
-00003500: 7267 735d 0a20 2020 2020 2020 2074 7279  rgs].        try
-00003510: 3a0a 2020 2020 2020 2020 2020 2020 7661  :.            va
-00003520: 6c75 6573 2e65 7874 656e 6428 6f70 2e65  lues.extend(op.e
-00003530: 7661 6c66 5f77 6974 6874 696d 6573 2874  valf_withtimes(t
-00003540: 696d 6573 2c20 2a5b 7661 6c75 6573 5b69  imes, *[values[i
-00003550: 5d20 666f 7220 6920 696e 2069 6e64 6963  ] for i in indic
-00003560: 6573 5d29 2066 6f72 206f 702c 2069 6e64  es]) for op, ind
-00003570: 6963 6573 2069 6e20 7365 6c66 2e73 6572  ices in self.ser
-00003580: 6961 6c69 7a65 6429 0a20 2020 2020 2020  ialized).       
-00003590: 2065 7863 6570 7420 4b65 7962 6f61 7264   except Keyboard
-000035a0: 496e 7465 7272 7570 743a 0a20 2020 2020  Interrupt:.     
-000035b0: 2020 2020 2020 2072 6169 7365 0a20 2020         raise.   
-000035c0: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
-000035d0: 7074 696f 6e20 6173 2065 3a0a 2020 2020  ption as e:.    
-000035e0: 2020 2020 2020 2020 7261 6973 6520 4576          raise Ev
-000035f0: 616c 7561 7469 6f6e 4572 726f 7228 7365  aluationError(se
-00003600: 6c66 2c20 7661 6c75 6573 2920 6672 6f6d  lf, values) from
-00003610: 2065 0a20 2020 2020 2020 2065 6c73 653a   e.        else:
-00003620: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00003630: 7572 6e20 7661 6c75 6573 5b2d 315d 0a0a  urn values[-1]..
-00003640: 2020 2020 4063 6f6e 7465 7874 6c69 622e      @contextlib.
-00003650: 636f 6e74 6578 746d 616e 6167 6572 0a20  contextmanager. 
-00003660: 2020 2064 6566 2073 6573 7369 6f6e 2873     def session(s
-00003670: 656c 662c 2067 7261 7068 7669 7a29 3a0a  elf, graphviz):.
-00003680: 2020 2020 2020 2020 6966 2067 7261 7068          if graph
-00003690: 7669 7a20 6973 204e 6f6e 653a 0a20 2020  viz is None:.   
-000036a0: 2020 2020 2020 2020 2079 6965 6c64 2073           yield s
-000036b0: 656c 662e 6576 616c 0a20 2020 2020 2020  elf.eval.       
-000036c0: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
-000036d0: 2020 2020 7374 6174 7320 3d20 636f 6c6c      stats = coll
-000036e0: 6563 7469 6f6e 732e 6465 6661 756c 7464  ections.defaultd
-000036f0: 6963 7428 5f53 7461 7473 290a 0a20 2020  ict(_Stats)..   
-00003700: 2020 2020 2064 6566 2065 7661 6c28 2a2a       def eval(**
-00003710: 6172 6773 293a 0a20 2020 2020 2020 2020  args):.         
-00003720: 2020 2072 6574 7572 6e20 7365 6c66 2e65     return self.e
-00003730: 7661 6c5f 7769 7468 7469 6d65 7328 7374  val_withtimes(st
-00003740: 6174 732c 202a 2a61 7267 7329 0a20 2020  ats, **args).   
-00003750: 2020 2020 2077 6974 6820 6c6f 672e 636f       with log.co
-00003760: 6e74 6578 7428 2765 7661 6c27 293a 0a20  ntext('eval'):. 
-00003770: 2020 2020 2020 2020 2020 2079 6965 6c64             yield
-00003780: 2065 7661 6c0a 2020 2020 2020 2020 2020   eval.          
-00003790: 2020 6e6f 6465 203d 2073 656c 662e 5f6e    node = self._n
-000037a0: 6f64 6528 7b7d 2c20 4e6f 6e65 2c20 7374  ode({}, None, st
-000037b0: 6174 7329 0a20 2020 2020 2020 2020 2020  ats).           
-000037c0: 206d 6178 7469 6d65 203d 2062 7569 6c74   maxtime = built
-000037d0: 696e 732e 6d61 7828 6e2e 6d65 7461 6461  ins.max(n.metada
-000037e0: 7461 5b31 5d2e 7469 6d65 2066 6f72 206e  ta[1].time for n
-000037f0: 2069 6e20 6e6f 6465 2e77 616c 6b28 7365   in node.walk(se
-00003800: 7428 2929 290a 2020 2020 2020 2020 2020  t())).          
-00003810: 2020 746f 7474 696d 6520 3d20 6275 696c    tottime = buil
-00003820: 7469 6e73 2e73 756d 286e 2e6d 6574 6164  tins.sum(n.metad
-00003830: 6174 615b 315d 2e74 696d 6520 666f 7220  ata[1].time for 
-00003840: 6e20 696e 206e 6f64 652e 7761 6c6b 2873  n in node.walk(s
-00003850: 6574 2829 2929 0a20 2020 2020 2020 2020  et())).         
-00003860: 2020 2061 6767 7374 6174 7320 3d20 7475     aggstats = tu
-00003870: 706c 6528 286b 6579 2c20 6275 696c 7469  ple((key, builti
-00003880: 6e73 2e73 756d 2876 2e74 696d 6520 666f  ns.sum(v.time fo
-00003890: 7220 7620 696e 2076 616c 7565 7329 2c20  r v in values), 
-000038a0: 6275 696c 7469 6e73 2e73 756d 2876 2e6e  builtins.sum(v.n
-000038b0: 6361 6c6c 7320 666f 7220 7620 696e 2076  calls for v in v
-000038c0: 616c 7565 7329 2920 666f 7220 6b65 792c  alues)) for key,
-000038d0: 2076 616c 7565 7320 696e 2075 7469 6c2e   values in util.
-000038e0: 6761 7468 6572 286e 2e6d 6574 6164 6174  gather(n.metadat
-000038f0: 6120 666f 7220 6e20 696e 206e 6f64 652e  a for n in node.
-00003900: 7761 6c6b 2873 6574 2829 2929 290a 2020  walk(set()))).  
-00003910: 2020 2020 2020 2020 2020 6669 6c6c 5f63            fill_c
-00003920: 6f6c 6f72 203d 2028 6c61 6d62 6461 206e  olor = (lambda n
-00003930: 6f64 653a 2027 302c 7b3a 2e32 667d 2c31  ode: '0,{:.2f},1
-00003940: 272e 666f 726d 6174 286e 6f64 652e 6d65  '.format(node.me
-00003950: 7461 6461 7461 5b31 5d2e 7469 6d65 2f6d  tadata[1].time/m
-00003960: 6178 7469 6d65 2929 2069 6620 6d61 7874  axtime)) if maxt
-00003970: 696d 6520 656c 7365 204e 6f6e 650a 2020  ime else None.  
-00003980: 2020 2020 2020 2020 2020 6e6f 6465 2e65            node.e
-00003990: 7870 6f72 745f 6772 6170 6876 697a 2866  xport_graphviz(f
-000039a0: 696c 6c5f 636f 6c6f 723d 6669 6c6c 5f63  ill_color=fill_c
-000039b0: 6f6c 6f72 2c20 646f 745f 7061 7468 3d67  olor, dot_path=g
-000039c0: 7261 7068 7669 7a29 0a20 2020 2020 2020  raphviz).       
-000039d0: 2020 2020 206c 6f67 2e69 6e66 6f28 2774       log.info('t
-000039e0: 6f74 616c 2074 696d 653a 207b 3a2e 3066  otal time: {:.0f
-000039f0: 7d6d 735c 6e27 2e66 6f72 6d61 7428 746f  }ms\n'.format(to
-00003a00: 7474 696d 652f 3165 3629 202b 2027 5c6e  ttime/1e6) + '\n
-00003a10: 272e 6a6f 696e 2827 7b3a 342e 3066 7d20  '.join('{:4.0f} 
-00003a20: 7b7d 2028 7b7d 2063 616c 6c73 2c20 6176  {} ({} calls, av
-00003a30: 6720 7b3a 2e33 667d 2070 6572 2063 616c  g {:.3f} per cal
-00003a40: 6c29 272e 666f 726d 6174 2874 202f 2031  l)'.format(t / 1
-00003a50: 6536 2c20 6b2c 206e 2c20 7420 2f20 2831  e6, k, n, t / (1
-00003a60: 6536 2a6e 2929 0a20 2020 2020 2020 2020  e6*n)).         
-00003a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003ab0: 2020 2020 2066 6f72 206b 2c20 742c 206e       for k, t, n
-00003ac0: 2069 6e20 736f 7274 6564 2861 6767 7374   in sorted(aggst
-00003ad0: 6174 732c 2072 6576 6572 7365 3d54 7275  ats, reverse=Tru
-00003ae0: 652c 206b 6579 3d6c 616d 6264 6120 6974  e, key=lambda it
-00003af0: 656d 3a20 6974 656d 5b31 5d29 2069 6620  em: item[1]) if 
-00003b00: 6e29 290a 0a20 2020 2064 6566 205f 7374  n))..    def _st
-00003b10: 6163 6b28 7365 6c66 2c20 7661 6c75 6573  ack(self, values
-00003b20: 293a 0a20 2020 2020 2020 206c 696e 6573  ):.        lines
-00003b30: 203d 205b 2720 2025 3020 3d20 4556 414c   = ['  %0 = EVAL
-00003b40: 4152 4753 275d 0a20 2020 2020 2020 2066  ARGS'].        f
-00003b50: 6f72 2028 6f70 2c20 696e 6469 6365 7329  or (op, indices)
-00003b60: 2c20 7620 696e 207a 6970 2873 656c 662e  , v in zip(self.
-00003b70: 7365 7269 616c 697a 6564 2c20 7661 6c75  serialized, valu
-00003b80: 6573 293a 0a20 2020 2020 2020 2020 2020  es):.           
-00003b90: 206c 696e 6573 5b2d 315d 202b 3d20 2720   lines[-1] += ' 
-00003ba0: 2d2d 3e20 2720 2b20 7479 7065 2876 292e  --> ' + type(v).
-00003bb0: 5f5f 6e61 6d65 5f5f 0a20 2020 2020 2020  __name__.       
-00003bc0: 2020 2020 2069 6620 6e75 6d65 7269 632e       if numeric.
-00003bd0: 6973 6172 7261 7928 7629 3a0a 2020 2020  isarray(v):.    
-00003be0: 2020 2020 2020 2020 2020 2020 6c69 6e65              line
-00003bf0: 735b 2d31 5d20 2b3d 2027 287b 7d29 272e  s[-1] += '({})'.
-00003c00: 666f 726d 6174 2827 2c27 2e6a 6f69 6e28  format(','.join(
-00003c10: 6d61 7028 7374 722c 2076 2e73 6861 7065  map(str, v.shape
-00003c20: 2929 290a 2020 2020 2020 2020 2020 2020  ))).            
-00003c30: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
-00003c40: 2020 2020 2063 6f64 6520 3d20 6f70 2e65       code = op.e
-00003c50: 7661 6c66 2e5f 5f63 6f64 655f 5f0a 2020  valf.__code__.  
-00003c60: 2020 2020 2020 2020 2020 2020 2020 6f66                of
-00003c70: 6673 6574 203d 2031 2069 6620 6765 7461  fset = 1 if geta
-00003c80: 7474 7228 6f70 2e65 7661 6c66 2c20 275f  ttr(op.evalf, '_
-00003c90: 5f73 656c 665f 5f27 2c20 4e6f 6e65 2920  _self__', None) 
-00003ca0: 6973 206e 6f74 204e 6f6e 6520 656c 7365  is not None else
-00003cb0: 2030 0a20 2020 2020 2020 2020 2020 2020   0.             
-00003cc0: 2020 206e 616d 6573 203d 2063 6f64 652e     names = code.
-00003cd0: 636f 5f76 6172 6e61 6d65 735b 6f66 6673  co_varnames[offs
-00003ce0: 6574 3a63 6f64 652e 636f 5f61 7267 636f  et:code.co_argco
-00003cf0: 756e 745d 0a20 2020 2020 2020 2020 2020  unt].           
-00003d00: 2020 2020 206e 616d 6573 202b 3d20 7475       names += tu
-00003d10: 706c 6528 277b 7d5b 7b7d 5d27 2e66 6f72  ple('{}[{}]'.for
-00003d20: 6d61 7428 636f 6465 2e63 6f5f 7661 726e  mat(code.co_varn
-00003d30: 616d 6573 5b63 6f64 652e 636f 5f61 7267  ames[code.co_arg
-00003d40: 636f 756e 745d 2c20 6e29 2066 6f72 206e  count], n) for n
-00003d50: 2069 6e20 7261 6e67 6528 6c65 6e28 696e   in range(len(in
-00003d60: 6469 6365 7329 202d 206c 656e 286e 616d  dices) - len(nam
-00003d70: 6573 2929 290a 2020 2020 2020 2020 2020  es))).          
-00003d80: 2020 2020 2020 6172 6773 203d 206d 6170        args = map
-00003d90: 2827 207b 7d3d 257b 7d27 2e66 6f72 6d61  (' {}=%{}'.forma
-00003da0: 742c 206e 616d 6573 2c20 696e 6469 6365  t, names, indice
-00003db0: 7329 0a20 2020 2020 2020 2020 2020 2065  s).            e
-00003dc0: 7863 6570 743a 0a20 2020 2020 2020 2020  xcept:.         
-00003dd0: 2020 2020 2020 2061 7267 7320 3d20 6d61         args = ma
-00003de0: 7028 2720 257b 7d27 2e66 6f72 6d61 742c  p(' %{}'.format,
-00003df0: 2069 6e64 6963 6573 290a 2020 2020 2020   indices).      
-00003e00: 2020 2020 2020 6c69 6e65 732e 6170 7065        lines.appe
-00003e10: 6e64 2827 2020 257b 7d20 3d20 7b7d 3a7b  nd('  %{} = {}:{
-00003e20: 7d27 2e66 6f72 6d61 7428 6c65 6e28 6c69  }'.format(len(li
-00003e30: 6e65 7329 2c20 6f70 2c20 272c 272e 6a6f  nes), op, ','.jo
-00003e40: 696e 2861 7267 7329 2929 0a20 2020 2020  in(args))).     
-00003e50: 2020 2072 6574 7572 6e20 6c69 6e65 730a     return lines.
-00003e60: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00003e70: 2020 2040 7265 706c 6163 6528 6465 7074     @replace(dept
-00003e80: 6866 6972 7374 3d54 7275 652c 2072 6563  hfirst=True, rec
-00003e90: 7572 7369 7665 3d54 7275 6529 0a20 2020  ursive=True).   
-00003ea0: 2064 6566 2073 696d 706c 6966 6965 6428   def simplified(
-00003eb0: 6f62 6a29 3a0a 2020 2020 2020 2020 6966  obj):.        if
-00003ec0: 2069 7369 6e73 7461 6e63 6528 6f62 6a2c   isinstance(obj,
-00003ed0: 2045 7661 6c75 6162 6c65 293a 0a20 2020   Evaluable):.   
-00003ee0: 2020 2020 2020 2020 2072 6574 7661 6c20           retval 
-00003ef0: 3d20 6f62 6a2e 5f73 696d 706c 6966 6965  = obj._simplifie
-00003f00: 6428 290a 2020 2020 2020 2020 2020 2020  d().            
-00003f10: 6966 2072 6574 7661 6c20 6973 206e 6f74  if retval is not
-00003f20: 204e 6f6e 6520 616e 6420 6973 696e 7374   None and isinst
-00003f30: 616e 6365 286f 626a 2c20 4172 7261 7929  ance(obj, Array)
-00003f40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00003f50: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
-00003f60: 6e63 6528 7265 7476 616c 2c20 4172 7261  nce(retval, Arra
-00003f70: 7929 2061 6e64 2065 7175 616c 7368 6170  y) and equalshap
-00003f80: 6528 7265 7476 616c 2e73 6861 7065 2c20  e(retval.shape, 
-00003f90: 6f62 6a2e 7368 6170 6529 2061 6e64 2072  obj.shape) and r
-00003fa0: 6574 7661 6c2e 6474 7970 6520 3d3d 206f  etval.dtype == o
-00003fb0: 626a 2e64 7479 7065 2c20 277b 7d20 2d2d  bj.dtype, '{} --
-00003fc0: 7369 6d70 6c69 6679 2d2d 3e20 7b7d 272e  simplify--> {}'.
-00003fd0: 666f 726d 6174 286f 626a 2c20 7265 7476  format(obj, retv
-00003fe0: 616c 290a 2020 2020 2020 2020 2020 2020  al).            
-00003ff0: 7265 7475 726e 2072 6574 7661 6c0a 0a20  return retval.. 
-00004000: 2020 2064 6566 205f 7369 6d70 6c69 6669     def _simplifi
-00004010: 6564 2873 656c 6629 3a0a 2020 2020 2020  ed(self):.      
-00004020: 2020 7265 7475 726e 0a0a 2020 2020 4070    return..    @p
-00004030: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00004040: 6f70 7469 6d69 7a65 645f 666f 725f 6e75  optimized_for_nu
-00004050: 6d70 7928 7365 6c66 293a 0a20 2020 2020  mpy(self):.     
-00004060: 2020 2072 6574 7661 6c20 3d20 7365 6c66     retval = self
-00004070: 2e5f 6f70 7469 6d69 7a65 645f 666f 725f  ._optimized_for_
-00004080: 6e75 6d70 7931 2829 206f 7220 7365 6c66  numpy1() or self
-00004090: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000040a0: 7265 7476 616c 2e5f 636f 6d62 696e 655f  retval._combine_
-000040b0: 6c6f 6f70 5f63 6f6e 6361 7465 6e61 7465  loop_concatenate
-000040c0: 7328 6672 6f7a 656e 7365 7428 2929 0a0a  s(frozenset())..
-000040d0: 2020 2020 4074 7970 6573 2e61 7070 6c79      @types.apply
-000040e0: 5f61 6e6e 6f74 6174 696f 6e73 0a20 2020  _annotations.   
-000040f0: 2040 7265 706c 6163 6528 6465 7074 6866   @replace(depthf
-00004100: 6972 7374 3d54 7275 652c 2072 6563 7572  irst=True, recur
-00004110: 7369 7665 3d54 7275 6529 0a20 2020 2064  sive=True).    d
-00004120: 6566 205f 6f70 7469 6d69 7a65 645f 666f  ef _optimized_fo
-00004130: 725f 6e75 6d70 7931 286f 626a 3a20 7369  r_numpy1(obj: si
-00004140: 6d70 6c69 6669 6564 2e66 6765 7429 3a0a  mplified.fget):.
-00004150: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
-00004160: 7461 6e63 6528 6f62 6a2c 2045 7661 6c75  tance(obj, Evalu
-00004170: 6162 6c65 293a 0a20 2020 2020 2020 2020  able):.         
-00004180: 2020 2072 6574 7661 6c20 3d20 6f62 6a2e     retval = obj.
-00004190: 5f73 696d 706c 6966 6965 6428 2920 6f72  _simplified() or
-000041a0: 206f 626a 2e5f 6f70 7469 6d69 7a65 645f   obj._optimized_
-000041b0: 666f 725f 6e75 6d70 7928 290a 2020 2020  for_numpy().    
-000041c0: 2020 2020 2020 2020 6966 2072 6574 7661          if retva
-000041d0: 6c20 6973 206e 6f74 204e 6f6e 6520 616e  l is not None an
-000041e0: 6420 6973 696e 7374 616e 6365 286f 626a  d isinstance(obj
-000041f0: 2c20 4172 7261 7929 3a0a 2020 2020 2020  , Array):.      
-00004200: 2020 2020 2020 2020 2020 6173 7365 7274            assert
-00004210: 2069 7369 6e73 7461 6e63 6528 7265 7476   isinstance(retv
-00004220: 616c 2c20 4172 7261 7929 2061 6e64 2065  al, Array) and e
-00004230: 7175 616c 7368 6170 6528 7265 7476 616c  qualshape(retval
-00004240: 2e73 6861 7065 2c20 6f62 6a2e 7368 6170  .shape, obj.shap
-00004250: 6529 2c20 277b 307d 2e5f 6f70 7469 6d69  e), '{0}._optimi
-00004260: 7a65 645f 666f 725f 6e75 6d70 7920 6f72  zed_for_numpy or
-00004270: 207b 307d 2e5f 7369 6d70 6c69 6669 6564   {0}._simplified
-00004280: 2072 6573 756c 7465 6420 696e 2073 6861   resulted in sha
-00004290: 7065 2063 6861 6e67 6527 2e66 6f72 6d61  pe change'.forma
-000042a0: 7428 7479 7065 286f 626a 292e 5f5f 6e61  t(type(obj).__na
-000042b0: 6d65 5f5f 290a 2020 2020 2020 2020 2020  me__).          
-000042c0: 2020 7265 7475 726e 2072 6574 7661 6c0a    return retval.
-000042d0: 0a20 2020 2064 6566 205f 6f70 7469 6d69  .    def _optimi
-000042e0: 7a65 645f 666f 725f 6e75 6d70 7928 7365  zed_for_numpy(se
-000042f0: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-00004300: 7572 6e0a 0a20 2020 2040 7072 6f70 6572  urn..    @proper
-00004310: 7479 0a20 2020 2064 6566 205f 6c6f 6f70  ty.    def _loop
-00004320: 5f63 6f6e 6361 7465 6e61 7465 5f64 6570  _concatenate_dep
-00004330: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
-00004340: 2064 6570 7320 3d20 5b5d 0a20 2020 2020   deps = [].     
-00004350: 2020 2066 6f72 2061 7267 2069 6e20 7365     for arg in se
-00004360: 6c66 2e5f 5f61 7267 733a 0a20 2020 2020  lf.__args:.     
-00004370: 2020 2020 2020 2064 6570 7320 2b3d 205b         deps += [
-00004380: 6465 7020 666f 7220 6465 7020 696e 2061  dep for dep in a
-00004390: 7267 2e5f 6c6f 6f70 5f63 6f6e 6361 7465  rg._loop_concate
-000043a0: 6e61 7465 5f64 6570 7320 6966 2064 6570  nate_deps if dep
-000043b0: 206e 6f74 2069 6e20 6465 7073 5d0a 2020   not in deps].  
-000043c0: 2020 2020 2020 7265 7475 726e 2074 7570        return tup
-000043d0: 6c65 2864 6570 7329 0a0a 2020 2020 6465  le(deps)..    de
-000043e0: 6620 5f63 6f6d 6269 6e65 5f6c 6f6f 705f  f _combine_loop_
-000043f0: 636f 6e63 6174 656e 6174 6573 2873 656c  concatenates(sel
-00004400: 662c 206f 7574 6572 5f65 7863 6c75 6465  f, outer_exclude
-00004410: 293a 0a20 2020 2020 2020 2077 6869 6c65  ):.        while
-00004420: 2054 7275 653a 0a20 2020 2020 2020 2020   True:.         
-00004430: 2020 2065 7863 6c75 6465 203d 2073 6574     exclude = set
-00004440: 286f 7574 6572 5f65 7863 6c75 6465 290a  (outer_exclude).
-00004450: 2020 2020 2020 2020 2020 2020 636f 6d62              comb
-00004460: 696e 6520 3d20 7b7d 0a20 2020 2020 2020  ine = {}.       
-00004470: 2020 2020 2023 2043 6f6c 6c65 6374 2061       # Collect a
-00004480: 6c6c 2074 6f70 2d6c 6576 656c 2060 4c6f  ll top-level `Lo
-00004490: 6f70 436f 6e63 6174 656e 6174 6560 2069  opConcatenate` i
-000044a0: 6e73 7461 6e63 6573 2069 6e20 6063 6f6d  nstances in `com
-000044b0: 6269 6e65 6020 616e 6420 616c 6c0a 2020  bine` and all.  
-000044c0: 2020 2020 2020 2020 2020 2320 7468 6569            # thei
-000044d0: 7220 6465 7065 6e64 656e 7420 604c 6f6f  r dependent `Loo
-000044e0: 7043 6f6e 6361 7465 6e61 7465 6020 696e  pConcatenate` in
-000044f0: 7374 616e 6365 7320 696e 2060 6578 636c  stances in `excl
-00004500: 7564 6560 2e0a 2020 2020 2020 2020 2020  ude`..          
-00004510: 2020 666f 7220 6c63 2069 6e20 7365 6c66    for lc in self
-00004520: 2e5f 6c6f 6f70 5f63 6f6e 6361 7465 6e61  ._loop_concatena
-00004530: 7465 5f64 6570 733a 0a20 2020 2020 2020  te_deps:.       
-00004540: 2020 2020 2020 2020 206c 6373 203d 2063           lcs = c
-00004550: 6f6d 6269 6e65 2e73 6574 6465 6661 756c  ombine.setdefaul
-00004560: 7428 6c63 2e69 6e64 6578 2c20 5b5d 290a  t(lc.index, []).
-00004570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004580: 6966 206c 6320 6e6f 7420 696e 206c 6373  if lc not in lcs
-00004590: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000045a0: 2020 2020 2020 6c63 732e 6170 7065 6e64        lcs.append
-000045b0: 286c 6329 0a20 2020 2020 2020 2020 2020  (lc).           
-000045c0: 2020 2020 2020 2020 2065 7863 6c75 6465           exclude
-000045d0: 2e75 7064 6174 6528 7365 7428 6c63 2e5f  .update(set(lc._
-000045e0: 6c6f 6f70 5f63 6f6e 6361 7465 6e61 7465  loop_concatenate
-000045f0: 5f64 6570 7329 202d 207b 6c63 7d29 0a20  _deps) - {lc}). 
-00004600: 2020 2020 2020 2020 2020 2023 2043 6f6d             # Com
-00004610: 6269 6e65 2074 6f70 2d6c 6576 656c 2060  bine top-level `
-00004620: 4c6f 6f70 436f 6e63 6174 656e 6174 6560  LoopConcatenate`
-00004630: 2069 6e73 7461 6e63 6573 2065 7863 6c75   instances exclu
-00004640: 6469 6e67 2074 686f 7365 2069 6e0a 2020  ding those in.  
-00004650: 2020 2020 2020 2020 2020 2320 6065 7863            # `exc
-00004660: 6c75 6465 602e 0a20 2020 2020 2020 2020  lude`..         
-00004670: 2020 2072 6570 6c61 6365 6d65 6e74 7320     replacements 
-00004680: 3d20 7b7d 0a20 2020 2020 2020 2020 2020  = {}.           
-00004690: 2066 6f72 2069 6e64 6578 2c20 6c63 7320   for index, lcs 
-000046a0: 696e 2063 6f6d 6269 6e65 2e69 7465 6d73  in combine.items
-000046b0: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
-000046c0: 2020 2020 6c63 7320 3d20 5b6c 6320 666f      lcs = [lc fo
-000046d0: 7220 6c63 2069 6e20 6c63 7320 6966 206c  r lc in lcs if l
-000046e0: 6320 6e6f 7420 696e 2065 7863 6c75 6465  c not in exclude
-000046f0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00004700: 2020 6966 206e 6f74 206c 6373 3a0a 2020    if not lcs:.  
-00004710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004720: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
-00004730: 2020 2020 2020 2020 2020 2023 2057 6527             # We'
-00004740: 7265 2065 7874 7261 6374 696e 6720 6461  re extracting da
-00004750: 7461 2066 726f 6d20 604c 6f6f 7043 6f6e  ta from `LoopCon
-00004760: 6361 7465 6e61 7465 6020 696e 2066 6176  catenate` in fav
-00004770: 6f72 206f 6620 7573 696e 670a 2020 2020  or of using.    
-00004780: 2020 2020 2020 2020 2020 2020 2320 606c              # `l
-00004790: 6f6f 705f 636f 6e63 6174 656e 6174 655f  oop_concatenate_
-000047a0: 636f 6d62 696e 6564 286c 6373 2c20 2e2e  combined(lcs, ..
-000047b0: 2e29 6020 6265 6361 7573 6520 7468 6520  .)` because the 
-000047c0: 6c61 7465 7220 7265 7175 6972 6573 0a20  later requires. 
-000047d0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-000047e0: 2072 6561 7070 6c79 696e 6720 7369 6d70   reapplying simp
-000047f0: 6c69 6669 6361 7469 6f6e 7320 7468 6174  lifications that
-00004800: 2061 7265 2061 6c72 6561 6479 2061 7070   are already app
-00004810: 6c69 6564 2069 6e20 7468 6520 666f 726d  lied in the form
-00004820: 6572 2e0a 2020 2020 2020 2020 2020 2020  er..            
-00004830: 2020 2020 2320 466f 7220 6578 616d 706c      # For exampl
-00004840: 652c 2069 6e20 606c 6f6f 705f 636f 6e63  e, in `loop_conc
-00004850: 6174 656e 6174 655f 636f 6d62 696e 6564  atenate_combined
-00004860: 6020 7468 6520 6f66 6673 6574 7320 2875  ` the offsets (u
-00004870: 7365 6420 6279 0a20 2020 2020 2020 2020  sed by.         
-00004880: 2020 2020 2020 2023 2073 7461 7274 2c20         # start, 
-00004890: 7374 6f70 2061 6e64 2074 6865 2063 6f6e  stop and the con
-000048a0: 6361 7465 6e61 7469 6f6e 206c 656e 6774  catenation lengt
-000048b0: 6829 2061 7265 2066 6f72 6d65 6420 6279  h) are formed by
-000048c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000048d0: 2023 2060 6c6f 6f70 5f63 6f6e 6361 7465   # `loop_concate
-000048e0: 6e61 7465 602d 696e 6720 6066 756e 632e  nate`-ing `func.
-000048f0: 7368 6170 655b 2d31 5d60 2e20 4966 2074  shape[-1]`. If t
-00004900: 6865 2073 6861 7065 2069 7320 636f 6e73  he shape is cons
-00004910: 7461 6e74 2c0a 2020 2020 2020 2020 2020  tant,.          
-00004920: 2020 2020 2020 2320 7468 6973 2063 616e        # this can
-00004930: 2062 6520 7369 6d70 6c69 6669 6564 2074   be simplified t
-00004940: 6f20 6120 6052 616e 6765 602e 0a20 2020  o a `Range`..   
-00004950: 2020 2020 2020 2020 2020 2020 2064 6174               dat
-00004960: 6120 3d20 5475 706c 6528 2854 7570 6c65  a = Tuple((Tuple
-00004970: 286c 632e 6675 6e63 6461 7461 2920 666f  (lc.funcdata) fo
-00004980: 7220 6c63 2069 6e20 6c63 7329 290a 2020  r lc in lcs)).  
-00004990: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000049a0: 436f 6d62 696e 6520 604c 6f6f 7043 6f6e  Combine `LoopCon
-000049b0: 6361 7465 6e61 7465 6020 696e 7374 616e  catenate` instan
-000049c0: 6365 7320 696e 2060 6461 7461 6020 6578  ces in `data` ex
-000049d0: 636c 7564 696e 670a 2020 2020 2020 2020  cluding.        
-000049e0: 2020 2020 2020 2020 2320 606f 7574 6572          # `outer
-000049f0: 5f65 7863 6c75 6465 6020 616e 6420 7468  _exclude` and th
-00004a00: 6f73 6520 7468 6174 2077 696c 6c20 6265  ose that will be
-00004a10: 2070 726f 6365 7373 6564 2069 6e20 6120   processed in a 
-00004a20: 7375 6273 6571 7565 6e74 206c 6f6f 700a  subsequent loop.
-00004a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004a40: 2320 2874 6865 2072 656d 6169 6e64 6572  # (the remainder
-00004a50: 206f 6620 6065 7863 6c75 6465 6029 2e20   of `exclude`). 
-00004a60: 5468 6520 6c61 7474 6572 2063 6f6e 7369  The latter consi
-00004a70: 7374 7320 6f66 206c 6f6f 7073 2074 6861  sts of loops tha
-00004a80: 7420 6172 650a 2020 2020 2020 2020 2020  t are.          
-00004a90: 2020 2020 2020 2320 696e 7661 7269 616e        # invarian
-00004aa0: 7420 772e 722e 742e 2074 6865 2063 7572  t w.r.t. the cur
-00004ab0: 7265 6e74 206c 6f6f 7020 6069 6e64 6578  rent loop `index
-00004ac0: 602e 0a20 2020 2020 2020 2020 2020 2020  `..             
-00004ad0: 2020 2064 6174 6120 3d20 6461 7461 2e5f     data = data._
-00004ae0: 636f 6d62 696e 655f 6c6f 6f70 5f63 6f6e  combine_loop_con
-00004af0: 6361 7465 6e61 7465 7328 6578 636c 7564  catenates(exclud
-00004b00: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
-00004b10: 2020 2063 6f6d 6269 6e65 6420 3d20 4c6f     combined = Lo
-00004b20: 6f70 436f 6e63 6174 656e 6174 6543 6f6d  opConcatenateCom
-00004b30: 6269 6e65 6428 6461 7461 2c20 696e 6465  bined(data, inde
-00004b40: 782e 5f6e 616d 652c 2069 6e64 6578 2e6c  x._name, index.l
-00004b50: 656e 6774 6829 0a20 2020 2020 2020 2020  ength).         
-00004b60: 2020 2020 2020 2066 6f72 2069 2c20 6c63         for i, lc
-00004b70: 2069 6e20 656e 756d 6572 6174 6528 6c63   in enumerate(lc
-00004b80: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-00004b90: 2020 2020 2020 2020 696e 7462 6f75 6e64          intbound
-00004ba0: 7320 3d20 6469 6374 287a 6970 2828 275f  s = dict(zip(('_
-00004bb0: 6c6f 7765 7227 2c20 275f 7570 7065 7227  lower', '_upper'
-00004bc0: 292c 206c 632e 5f69 6e74 626f 756e 6473  ), lc._intbounds
-00004bd0: 2929 2069 6620 6c63 2e64 7479 7065 203d  )) if lc.dtype =
-00004be0: 3d20 696e 7420 656c 7365 207b 7d0a 2020  = int else {}.  
-00004bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004c00: 2020 7265 706c 6163 656d 656e 7473 5b6c    replacements[l
-00004c10: 635d 203d 2041 7272 6179 4672 6f6d 5475  c] = ArrayFromTu
-00004c20: 706c 6528 636f 6d62 696e 6564 2c20 692c  ple(combined, i,
-00004c30: 206c 632e 7368 6170 652c 206c 632e 6474   lc.shape, lc.dt
-00004c40: 7970 652c 202a 2a69 6e74 626f 756e 6473  ype, **intbounds
-00004c50: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-00004c60: 2072 6570 6c61 6365 6d65 6e74 733a 0a20   replacements:. 
-00004c70: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00004c80: 656c 6620 3d20 7265 706c 6163 6528 6c61  elf = replace(la
-00004c90: 6d62 6461 206b 6579 3a20 7265 706c 6163  mbda key: replac
-00004ca0: 656d 656e 7473 2e67 6574 286b 6579 2920  ements.get(key) 
-00004cb0: 6966 2069 7369 6e73 7461 6e63 6528 6b65  if isinstance(ke
-00004cc0: 792c 204c 6f6f 7043 6f6e 6361 7465 6e61  y, LoopConcatena
-00004cd0: 7465 2920 656c 7365 204e 6f6e 652c 2072  te) else None, r
-00004ce0: 6563 7572 7369 7665 3d46 616c 7365 2c20  ecursive=False, 
-00004cf0: 6465 7074 6866 6972 7374 3d46 616c 7365  depthfirst=False
-00004d00: 2928 7365 6c66 290a 2020 2020 2020 2020  )(self).        
-00004d10: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00004d20: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00004d30: 2073 656c 660a 0a0a 636c 6173 7320 4576   self...class Ev
-00004d40: 616c 7561 7469 6f6e 4572 726f 7228 4578  aluationError(Ex
-00004d50: 6365 7074 696f 6e29 3a0a 2020 2020 6465  ception):.    de
-00004d60: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
-00004d70: 2066 2c20 7661 6c75 6573 293a 0a20 2020   f, values):.   
-00004d80: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
-00004d90: 6e69 745f 5f28 2765 7661 6c75 6174 696f  nit__('evaluatio
-00004da0: 6e20 6661 696c 6564 2069 6e20 7374 6570  n failed in step
-00004db0: 207b 7d2f 7b7d 5c6e 272e 666f 726d 6174   {}/{}\n'.format
-00004dc0: 286c 656e 2876 616c 7565 7329 2c20 6c65  (len(values), le
-00004dd0: 6e28 662e 6465 7065 6e64 656e 6369 6573  n(f.dependencies
-00004de0: 2929 202b 2027 5c6e 272e 6a6f 696e 2866  )) + '\n'.join(f
-00004df0: 2e5f 7374 6163 6b28 7661 6c75 6573 2929  ._stack(values))
-00004e00: 290a 0a0a 636c 6173 7320 4556 414c 4152  )...class EVALAR
-00004e10: 4753 2845 7661 6c75 6162 6c65 293a 0a20  GS(Evaluable):. 
-00004e20: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
-00004e30: 7365 6c66 293a 0a20 2020 2020 2020 2073  self):.        s
-00004e40: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
-00004e50: 6172 6773 3d28 2929 0a0a 2020 2020 6465  args=())..    de
-00004e60: 6620 5f6e 6f64 6528 7365 6c66 2c20 6361  f _node(self, ca
-00004e70: 6368 652c 2073 7562 6772 6170 682c 2074  che, subgraph, t
-00004e80: 696d 6573 293a 0a20 2020 2020 2020 2072  imes):.        r
-00004e90: 6574 7572 6e20 496e 7669 7369 626c 654e  eturn InvisibleN
-00004ea0: 6f64 6528 2874 7970 6528 7365 6c66 292e  ode((type(self).
-00004eb0: 5f5f 6e61 6d65 5f5f 2c20 5f53 7461 7473  __name__, _Stats
-00004ec0: 2829 2929 0a0a 0a45 5641 4c41 5247 5320  ()))...EVALARGS 
-00004ed0: 3d20 4556 414c 4152 4753 2829 0a0a 0a63  = EVALARGS()...c
-00004ee0: 6c61 7373 2045 7661 6c75 6162 6c65 436f  lass EvaluableCo
-00004ef0: 6e73 7461 6e74 2845 7661 6c75 6162 6c65  nstant(Evaluable
-00004f00: 293a 0a20 2020 2027 2727 4576 616c 7561  ):.    '''Evalua
-00004f10: 7465 2074 6f20 7468 6520 6769 7665 6e20  te to the given 
-00004f20: 636f 6e73 7461 6e74 2076 616c 7565 2e0a  constant value..
-00004f30: 0a20 2020 2050 6172 616d 6574 6572 730a  .    Parameters.
-00004f40: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
-00004f50: 2020 2076 616c 7565 0a20 2020 2020 2020     value.       
-00004f60: 2054 6865 2072 6574 7572 6e20 7661 6c75   The return valu
-00004f70: 6520 6f66 2060 6065 7661 6c60 602e 0a20  e of ``eval``.. 
-00004f80: 2020 2027 2727 0a0a 2020 2020 5f5f 736c     '''..    __sl
-00004f90: 6f74 735f 5f20 3d20 2776 616c 7565 270a  ots__ = 'value'.
-00004fa0: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-00004fb0: 5f28 7365 6c66 2c20 7661 6c75 6529 3a0a  _(self, value):.
-00004fc0: 2020 2020 2020 2020 7365 6c66 2e76 616c          self.val
-00004fd0: 7565 203d 2076 616c 7565 0a20 2020 2020  ue = value.     
-00004fe0: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
-00004ff0: 745f 5f28 2829 290a 0a20 2020 2064 6566  t__(())..    def
-00005000: 2065 7661 6c66 2873 656c 6629 3a0a 2020   evalf(self):.  
-00005010: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00005020: 662e 7661 6c75 650a 0a20 2020 2040 7072  f.value..    @pr
-00005030: 6f70 6572 7479 0a20 2020 2064 6566 205f  operty.    def _
-00005040: 6e6f 6465 5f64 6574 6169 6c73 2873 656c  node_details(sel
-00005050: 6629 3a0a 2020 2020 2020 2020 7320 3d20  f):.        s = 
-00005060: 7265 7072 2873 656c 662e 7661 6c75 6529  repr(self.value)
-00005070: 0a20 2020 2020 2020 2069 6620 275c 6e27  .        if '\n'
-00005080: 2069 6e20 733a 0a20 2020 2020 2020 2020   in s:.         
-00005090: 2020 2073 203d 2073 2e73 706c 6974 2827     s = s.split('
-000050a0: 5c6e 272c 2031 295b 305d 202b 2027 2e2e  \n', 1)[0] + '..
-000050b0: 2e27 0a20 2020 2020 2020 2069 6620 6c65  .'.        if le
-000050c0: 6e28 7329 203e 2032 303a 0a20 2020 2020  n(s) > 20:.     
-000050d0: 2020 2020 2020 2073 203d 2073 5b3a 3137         s = s[:17
-000050e0: 5d20 2b20 272e 2e2e 270a 2020 2020 2020  ] + '...'.      
-000050f0: 2020 7265 7475 726e 2073 0a0a 0a63 6c61    return s...cla
-00005100: 7373 2054 7570 6c65 2845 7661 6c75 6162  ss Tuple(Evaluab
-00005110: 6c65 293a 0a0a 2020 2020 5f5f 736c 6f74  le):..    __slot
-00005120: 735f 5f20 3d20 2769 7465 6d73 270a 0a20  s__ = 'items'.. 
-00005130: 2020 2040 7479 7065 732e 6170 706c 795f     @types.apply_
-00005140: 616e 6e6f 7461 7469 6f6e 730a 2020 2020  annotations.    
-00005150: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00005160: 662c 2069 7465 6d73 3a20 7479 7065 732e  f, items: types.
-00005170: 7475 706c 655b 7374 7269 6374 6576 616c  tuple[stricteval
-00005180: 7561 626c 655d 293a 0a20 2020 2020 2020  uable]):.       
-00005190: 2073 656c 662e 6974 656d 7320 3d20 6974   self.items = it
-000051a0: 656d 730a 2020 2020 2020 2020 7375 7065  ems.        supe
-000051b0: 7228 292e 5f5f 696e 6974 5f5f 2869 7465  r().__init__(ite
-000051c0: 6d73 290a 0a20 2020 2064 6566 2065 7661  ms)..    def eva
-000051d0: 6c66 2873 656c 662c 202a 6974 656d 7329  lf(self, *items)
-000051e0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-000051f0: 2069 7465 6d73 0a0a 2020 2020 6465 6620   items..    def 
-00005200: 5f5f 6974 6572 5f5f 2873 656c 6629 3a0a  __iter__(self):.
-00005210: 2020 2020 2020 2020 2769 7465 7261 7465          'iterate
-00005220: 270a 0a20 2020 2020 2020 2072 6574 7572  '..        retur
-00005230: 6e20 6974 6572 2873 656c 662e 6974 656d  n iter(self.item
-00005240: 7329 0a0a 2020 2020 6465 6620 5f5f 6c65  s)..    def __le
-00005250: 6e5f 5f28 7365 6c66 293a 0a20 2020 2020  n__(self):.     
-00005260: 2020 2027 6c65 6e67 7468 270a 0a20 2020     'length'..   
-00005270: 2020 2020 2072 6574 7572 6e20 6c65 6e28       return len(
-00005280: 7365 6c66 2e69 7465 6d73 290a 0a20 2020  self.items)..   
-00005290: 2064 6566 205f 5f67 6574 6974 656d 5f5f   def __getitem__
-000052a0: 2873 656c 662c 2069 7465 6d29 3a0a 2020  (self, item):.  
-000052b0: 2020 2020 2020 2767 6574 2069 7465 6d27        'get item'
-000052c0: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-000052d0: 2073 656c 662e 6974 656d 735b 6974 656d   self.items[item
-000052e0: 5d0a 0a20 2020 2064 6566 205f 5f61 6464  ]..    def __add
-000052f0: 5f5f 2873 656c 662c 206f 7468 6572 293a  __(self, other):
-00005300: 0a20 2020 2020 2020 2027 6164 6427 0a0a  .        'add'..
-00005310: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-00005320: 7570 6c65 2873 656c 662e 6974 656d 7320  uple(self.items 
-00005330: 2b20 7475 706c 6528 6f74 6865 7229 290a  + tuple(other)).
-00005340: 0a20 2020 2064 6566 205f 5f72 6164 645f  .    def __radd_
-00005350: 5f28 7365 6c66 2c20 6f74 6865 7229 3a0a  _(self, other):.
-00005360: 2020 2020 2020 2020 2761 6464 270a 0a20          'add'.. 
-00005370: 2020 2020 2020 2072 6574 7572 6e20 5475         return Tu
-00005380: 706c 6528 7475 706c 6528 6f74 6865 7229  ple(tuple(other)
-00005390: 202b 2073 656c 662e 6974 656d 7329 0a0a   + self.items)..
-000053a0: 0a63 6c61 7373 2053 7061 7273 6541 7272  .class SparseArr
-000053b0: 6179 2845 7661 6c75 6162 6c65 293a 0a20  ay(Evaluable):. 
-000053c0: 2020 2027 7370 6172 7365 2061 7272 6179     'sparse array
-000053d0: 270a 0a20 2020 2040 7479 7065 732e 6170  '..    @types.ap
-000053e0: 706c 795f 616e 6e6f 7461 7469 6f6e 730a  ply_annotations.
-000053f0: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
-00005400: 2873 656c 662c 2063 6875 6e6b 733a 2074  (self, chunks: t
-00005410: 7970 6573 2e74 7570 6c65 5b61 7361 7272  ypes.tuple[asarr
-00005420: 6179 735d 2c20 7368 6170 653a 2061 7361  ays], shape: asa
-00005430: 7272 6179 732c 2064 7479 7065 3a20 6173  rrays, dtype: as
-00005440: 6474 7970 6529 3a0a 2020 2020 2020 2020  dtype):.        
-00005450: 7365 6c66 2e5f 7368 6170 6520 3d20 7368  self._shape = sh
-00005460: 6170 650a 2020 2020 2020 2020 7365 6c66  ape.        self
-00005470: 2e5f 6474 7970 6520 3d20 6474 7970 650a  ._dtype = dtype.
-00005480: 2020 2020 2020 2020 7375 7065 7228 292e          super().
-00005490: 5f5f 696e 6974 5f5f 2861 7267 733d 5b54  __init__(args=[T
-000054a0: 7570 6c65 2873 6861 7065 292c 202a 6d61  uple(shape), *ma
-000054b0: 7028 5475 706c 652c 2063 6875 6e6b 7329  p(Tuple, chunks)
-000054c0: 5d29 0a0a 2020 2020 6465 6620 6576 616c  ])..    def eval
-000054d0: 6628 7365 6c66 2c20 7368 6170 652c 202a  f(self, shape, *
-000054e0: 6368 756e 6b73 293a 0a20 2020 2020 2020  chunks):.       
-000054f0: 206c 656e 6774 6820 3d20 6275 696c 7469   length = builti
-00005500: 6e73 2e73 756d 2876 616c 7565 732e 7369  ns.sum(values.si
-00005510: 7a65 2066 6f72 202a 696e 6469 6365 732c  ze for *indices,
-00005520: 2076 616c 7565 7320 696e 2063 6875 6e6b   values in chunk
-00005530: 7329 0a20 2020 2020 2020 2064 6174 6120  s).        data 
-00005540: 3d20 6e75 6d70 792e 656d 7074 7928 286c  = numpy.empty((l
-00005550: 656e 6774 682c 292c 2064 7479 7065 3d73  ength,), dtype=s
-00005560: 7061 7273 652e 6474 7970 6528 7475 706c  parse.dtype(tupl
-00005570: 6528 6d61 7028 696e 742c 2073 6861 7065  e(map(int, shape
-00005580: 2929 2c20 7365 6c66 2e5f 6474 7970 6529  )), self._dtype)
-00005590: 290a 2020 2020 2020 2020 7374 6172 7420  ).        start 
-000055a0: 3d20 300a 2020 2020 2020 2020 666f 7220  = 0.        for 
-000055b0: 2a69 6e64 6963 6573 2c20 7661 6c75 6573  *indices, values
-000055c0: 2069 6e20 6368 756e 6b73 3a0a 2020 2020   in chunks:.    
-000055d0: 2020 2020 2020 2020 7374 6f70 203d 2073          stop = s
-000055e0: 7461 7274 202b 2076 616c 7565 732e 7369  tart + values.si
-000055f0: 7a65 0a20 2020 2020 2020 2020 2020 2064  ze.            d
-00005600: 203d 2064 6174 615b 7374 6172 743a 7374   = data[start:st
-00005610: 6f70 5d2e 7265 7368 6170 6528 7661 6c75  op].reshape(valu
-00005620: 6573 2e73 6861 7065 290a 2020 2020 2020  es.shape).      
-00005630: 2020 2020 2020 645b 2776 616c 7565 275d        d['value']
-00005640: 203d 2076 616c 7565 730a 2020 2020 2020   = values.      
-00005650: 2020 2020 2020 666f 7220 6964 696d 2c20        for idim, 
-00005660: 6969 2069 6e20 656e 756d 6572 6174 6528  ii in enumerate(
-00005670: 696e 6469 6365 7329 3a0a 2020 2020 2020  indices):.      
-00005680: 2020 2020 2020 2020 2020 645b 2769 6e64            d['ind
-00005690: 6578 275d 5b27 6927 2b73 7472 2869 6469  ex']['i'+str(idi
-000056a0: 6d29 5d20 3d20 6969 0a20 2020 2020 2020  m)] = ii.       
-000056b0: 2020 2020 2073 7461 7274 203d 2073 746f       start = sto
-000056c0: 700a 2020 2020 2020 2020 7265 7475 726e  p.        return
-000056d0: 2064 6174 610a 0a23 2041 5252 4159 4655   data..# ARRAYFU
-000056e0: 4e43 0a23 0a23 2054 6865 206d 6169 6e20  NC.#.# The main 
-000056f0: 6576 616c 7561 626c 652e 2043 6c6f 7365  evaluable. Close
-00005700: 6c79 206d 696d 6963 7320 6120 6e75 6d70  ly mimics a nump
-00005710: 7920 6172 7261 792e 0a0a 0a64 6566 2061  y array....def a
-00005720: 6464 2861 2c20 6229 3a0a 2020 2020 612c  dd(a, b):.    a,
-00005730: 2062 203d 205f 6e75 6d70 795f 616c 6967   b = _numpy_alig
-00005740: 6e28 612c 2062 290a 2020 2020 7265 7475  n(a, b).    retu
-00005750: 726e 2041 6464 285b 612c 2062 5d29 0a0a  rn Add([a, b])..
-00005760: 0a64 6566 206d 756c 7469 706c 7928 612c  .def multiply(a,
-00005770: 2062 293a 0a20 2020 2061 2c20 6220 3d20   b):.    a, b = 
-00005780: 5f6e 756d 7079 5f61 6c69 676e 2861 2c20  _numpy_align(a, 
-00005790: 6229 0a20 2020 2072 6574 7572 6e20 4d75  b).    return Mu
-000057a0: 6c74 6970 6c79 285b 612c 2062 5d29 0a0a  ltiply([a, b])..
-000057b0: 0a64 6566 2073 756d 2861 7267 2c20 6178  .def sum(arg, ax
-000057c0: 6973 3d4e 6f6e 6529 3a0a 2020 2020 2727  is=None):.    ''
-000057d0: 2753 756d 2061 7272 6179 2065 6c65 6d65  'Sum array eleme
-000057e0: 6e74 7320 6f76 6572 2061 2067 6976 656e  nts over a given
-000057f0: 2061 7869 732e 2727 270a 0a20 2020 2069   axis.'''..    i
-00005800: 6620 6178 6973 2069 7320 4e6f 6e65 3a0a  f axis is None:.
-00005810: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-00005820: 756d 2861 7267 290a 2020 2020 6178 6573  um(arg).    axes
-00005830: 203d 2028 6178 6973 2c29 2069 6620 6e75   = (axis,) if nu
-00005840: 6d65 7269 632e 6973 696e 7428 6178 6973  meric.isint(axis
-00005850: 2920 656c 7365 2061 7869 730a 2020 2020  ) else axis.    
-00005860: 7375 6d6d 6564 203d 2054 7261 6e73 706f  summed = Transpo
-00005870: 7365 2e74 6f5f 656e 6428 6172 672c 202a  se.to_end(arg, *
-00005880: 6178 6573 290a 2020 2020 666f 7220 6920  axes).    for i 
-00005890: 696e 2072 616e 6765 286c 656e 2861 7865  in range(len(axe
-000058a0: 7329 293a 0a20 2020 2020 2020 2073 756d  s)):.        sum
-000058b0: 6d65 6420 3d20 5375 6d28 7375 6d6d 6564  med = Sum(summed
-000058c0: 290a 2020 2020 7265 7475 726e 2073 756d  ).    return sum
-000058d0: 6d65 640a 0a0a 6465 6620 7072 6f64 7563  med...def produc
-000058e0: 7428 6172 672c 2061 7869 7329 3a0a 2020  t(arg, axis):.  
-000058f0: 2020 7265 7475 726e 2050 726f 6475 6374    return Product
-00005900: 2854 7261 6e73 706f 7365 2e74 6f5f 656e  (Transpose.to_en
-00005910: 6428 6172 672c 2061 7869 7329 290a 0a0a  d(arg, axis))...
-00005920: 6465 6620 706f 7765 7228 6172 672c 206e  def power(arg, n
-00005930: 293a 0a20 2020 2061 7267 2c20 6e20 3d20  ):.    arg, n = 
-00005940: 5f6e 756d 7079 5f61 6c69 676e 2861 7267  _numpy_align(arg
-00005950: 2c20 6e29 0a20 2020 2072 6574 7572 6e20  , n).    return 
-00005960: 506f 7765 7228 6172 672c 206e 290a 0a0a  Power(arg, n)...
-00005970: 6465 6620 646f 7428 612c 2062 2c20 6178  def dot(a, b, ax
-00005980: 6573 293a 0a20 2020 2027 2727 0a20 2020  es):.    '''.   
-00005990: 2043 6f6e 7472 6163 7420 6060 6160 6020   Contract ``a`` 
-000059a0: 616e 6420 6060 6260 6020 616c 6f6e 6720  and ``b`` along 
-000059b0: 6060 6178 6573 6060 2e0a 2020 2020 2727  ``axes``..    ''
-000059c0: 270a 0a20 2020 2072 6574 7572 6e20 6d75  '..    return mu
-000059d0: 6c74 6970 6c79 2861 2c20 6229 2e73 756d  ltiply(a, b).sum
-000059e0: 2861 7865 7329 0a0a 0a64 6566 2063 6f6e  (axes)...def con
-000059f0: 6a75 6761 7465 2861 7267 293a 0a20 2020  jugate(arg):.   
-00005a00: 2061 7267 203d 2061 7361 7272 6179 2861   arg = asarray(a
-00005a10: 7267 290a 2020 2020 6966 2061 7267 2e64  rg).    if arg.d
-00005a20: 7479 7065 203d 3d20 636f 6d70 6c65 783a  type == complex:
-00005a30: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00005a40: 436f 6e6a 7567 6174 6528 6172 6729 0a20  Conjugate(arg). 
-00005a50: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00005a60: 2072 6574 7572 6e20 6172 670a 0a0a 636f   return arg...co
-00005a70: 6e6a 7567 6174 650a 0a0a 6465 6620 7265  njugate...def re
-00005a80: 616c 2861 7267 293a 0a20 2020 2061 7267  al(arg):.    arg
-00005a90: 203d 2061 7361 7272 6179 2861 7267 290a   = asarray(arg).
-00005aa0: 2020 2020 6966 2061 7267 2e64 7479 7065      if arg.dtype
-00005ab0: 203d 3d20 636f 6d70 6c65 783a 0a20 2020   == complex:.   
-00005ac0: 2020 2020 2072 6574 7572 6e20 5265 616c       return Real
-00005ad0: 2861 7267 290a 2020 2020 656c 7365 3a0a  (arg).    else:.
-00005ae0: 2020 2020 2020 2020 7265 7475 726e 2061          return a
-00005af0: 7267 0a0a 0a64 6566 2069 6d61 6728 6172  rg...def imag(ar
-00005b00: 6729 3a0a 2020 2020 6172 6720 3d20 6173  g):.    arg = as
-00005b10: 6172 7261 7928 6172 6729 0a20 2020 2069  array(arg).    i
-00005b20: 6620 6172 672e 6474 7970 6520 3d3d 2063  f arg.dtype == c
-00005b30: 6f6d 706c 6578 3a0a 2020 2020 2020 2020  omplex:.        
-00005b40: 7265 7475 726e 2049 6d61 6728 6172 6729  return Imag(arg)
-00005b50: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-00005b60: 2020 2072 6574 7572 6e20 7a65 726f 735f     return zeros_
-00005b70: 6c69 6b65 2861 7267 290a 0a0a 6465 6620  like(arg)...def 
-00005b80: 7472 616e 7370 6f73 6528 6172 672c 2074  transpose(arg, t
-00005b90: 7261 6e73 3d4e 6f6e 6529 3a0a 2020 2020  rans=None):.    
-00005ba0: 6172 6720 3d20 6173 6172 7261 7928 6172  arg = asarray(ar
-00005bb0: 6729 0a20 2020 2069 6620 7472 616e 7320  g).    if trans 
-00005bc0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-00005bd0: 206e 6f72 6d74 7261 6e73 203d 2072 616e   normtrans = ran
-00005be0: 6765 2861 7267 2e6e 6469 6d2d 312c 202d  ge(arg.ndim-1, -
-00005bf0: 312c 202d 3129 0a20 2020 2065 6c73 653a  1, -1).    else:
-00005c00: 0a20 2020 2020 2020 206e 6f72 6d74 7261  .        normtra
-00005c10: 6e73 203d 205f 6e6f 726d 6469 6d73 2861  ns = _normdims(a
-00005c20: 7267 2e6e 6469 6d2c 2074 7261 6e73 290a  rg.ndim, trans).
-00005c30: 2020 2020 2020 2020 6173 7365 7274 2073          assert s
-00005c40: 6f72 7465 6428 6e6f 726d 7472 616e 7329  orted(normtrans)
-00005c50: 203d 3d20 6c69 7374 2872 616e 6765 2861   == list(range(a
-00005c60: 7267 2e6e 6469 6d29 290a 2020 2020 7265  rg.ndim)).    re
-00005c70: 7475 726e 2054 7261 6e73 706f 7365 2861  turn Transpose(a
-00005c80: 7267 2c20 6e6f 726d 7472 616e 7329 0a0a  rg, normtrans)..
-00005c90: 0a64 6566 2073 7761 7061 7865 7328 6172  .def swapaxes(ar
-00005ca0: 672c 2061 7869 7331 2c20 6178 6973 3229  g, axis1, axis2)
-00005cb0: 3a0a 2020 2020 6172 6720 3d20 6173 6172  :.    arg = asar
-00005cc0: 7261 7928 6172 6729 0a20 2020 2074 7261  ray(arg).    tra
-00005cd0: 6e73 203d 206e 756d 7079 2e61 7261 6e67  ns = numpy.arang
-00005ce0: 6528 6172 672e 6e64 696d 290a 2020 2020  e(arg.ndim).    
-00005cf0: 7472 616e 735b 6178 6973 315d 2c20 7472  trans[axis1], tr
-00005d00: 616e 735b 6178 6973 325d 203d 2074 7261  ans[axis2] = tra
-00005d10: 6e73 5b61 7869 7332 5d2c 2074 7261 6e73  ns[axis2], trans
-00005d20: 5b61 7869 7331 5d0a 2020 2020 7265 7475  [axis1].    retu
-00005d30: 726e 2074 7261 6e73 706f 7365 2861 7267  rn transpose(arg
-00005d40: 2c20 7472 616e 7329 0a0a 0a64 6566 2061  , trans)...def a
-00005d50: 6c69 676e 2861 7267 2c20 7768 6572 652c  lign(arg, where,
-00005d60: 2073 6861 7065 293a 0a20 2020 2027 2727   shape):.    '''
-00005d70: 416c 6967 6e20 6172 7261 7920 746f 2074  Align array to t
-00005d80: 6172 6765 7420 7368 6170 652e 0a0a 2020  arget shape...  
-00005d90: 2020 5468 6520 616c 6967 6e20 6f70 6572    The align oper
-00005da0: 6174 696f 6e20 6361 6e20 6265 2063 6f6e  ation can be con
-00005db0: 7369 6465 7265 6420 7468 6520 6f70 706f  sidered the oppo
-00005dc0: 7369 7465 206f 6620 7472 616e 7370 6f73  site of transpos
-00005dd0: 653a 2069 6e73 7465 6164 206f 660a 2020  e: instead of.  
-00005de0: 2020 7370 6563 6966 7969 6e67 2066 6f72    specifying for
-00005df0: 2065 6163 6820 6178 6973 206f 6620 7468   each axis of th
-00005e00: 6520 7265 7475 726e 2076 616c 7565 2074  e return value t
-00005e10: 6865 206f 7269 6769 6e61 6c20 706f 7369  he original posi
-00005e20: 7469 6f6e 2069 6e20 7468 650a 2020 2020  tion in the.    
-00005e30: 6172 6775 6d65 6e74 2c20 616c 6967 6e20  argument, align 
-00005e40: 7370 6563 6966 6965 7320 666f 7220 6561  specifies for ea
-00005e50: 6368 2061 7869 7320 6f66 2074 6865 2061  ch axis of the a
-00005e60: 7267 756d 656e 7420 7468 6520 6e65 7720  rgument the new 
-00005e70: 706f 7369 7469 6f6e 2069 6e0a 2020 2020  position in.    
-00005e80: 7468 6520 7265 7475 726e 2076 616c 7565  the return value
-00005e90: 2e20 496e 2061 6464 6974 696f 6e2c 2074  . In addition, t
-00005ea0: 6865 2072 6574 7572 6e20 7661 6c75 6520  he return value 
-00005eb0: 6d61 7920 6265 206f 6620 6869 6768 6572  may be of higher
-00005ec0: 2064 696d 656e 7369 6f6e 2c0a 2020 2020   dimension,.    
-00005ed0: 7769 7468 206e 6577 2061 7865 7320 6265  with new axes be
-00005ee0: 696e 6720 696e 7365 7274 6564 2061 6363  ing inserted acc
-00005ef0: 6f72 6469 6e67 2074 6f20 7468 6520 6060  ording to the ``
-00005f00: 7368 6170 6560 6020 6172 6775 6d65 6e74  shape`` argument
-00005f10: 2e0a 0a20 2020 2041 7267 730a 2020 2020  ...    Args.    
-00005f20: 2d2d 2d2d 0a20 2020 2061 7267 203a 203a  ----.    arg : :
-00005f30: 636c 6173 733a 6041 7272 6179 600a 2020  class:`Array`.  
-00005f40: 2020 2020 2020 4f72 6967 696e 616c 2061        Original a
-00005f50: 7272 6179 2e0a 2020 2020 7768 6572 6520  rray..    where 
-00005f60: 3a20 3a63 6c61 7373 3a60 7475 706c 6560  : :class:`tuple`
-00005f70: 206f 6620 696e 7465 6765 7273 0a20 2020   of integers.   
-00005f80: 2020 2020 204e 6577 2061 7869 7320 706f       New axis po
-00005f90: 7369 7469 6f6e 732e 0a20 2020 2073 6861  sitions..    sha
-00005fa0: 7065 203a 203a 636c 6173 733a 6074 7570  pe : :class:`tup
-00005fb0: 6c65 600a 2020 2020 2020 2020 5368 6170  le`.        Shap
-00005fc0: 6520 6f66 2074 6865 2061 6c69 676e 6564  e of the aligned
-00005fd0: 2061 7272 6179 2e0a 0a20 2020 2052 6574   array...    Ret
-00005fe0: 7572 6e73 0a20 2020 202d 2d2d 2d2d 2d2d  urns.    -------
-00005ff0: 0a20 2020 203a 636c 6173 733a 6041 7272  .    :class:`Arr
-00006000: 6179 600a 2020 2020 2020 2020 5468 6520  ay`.        The 
-00006010: 616c 6967 6e65 6420 6172 7261 792e 0a20  aligned array.. 
-00006020: 2020 2027 2727 0a0a 2020 2020 7768 6572     '''..    wher
-00006030: 6520 3d20 6c69 7374 2877 6865 7265 290a  e = list(where).
-00006040: 2020 2020 666f 7220 692c 206c 656e 6774      for i, lengt
-00006050: 6820 696e 2065 6e75 6d65 7261 7465 2873  h in enumerate(s
-00006060: 6861 7065 293a 0a20 2020 2020 2020 2069  hape):.        i
-00006070: 6620 6920 6e6f 7420 696e 2077 6865 7265  f i not in where
-00006080: 3a0a 2020 2020 2020 2020 2020 2020 6172  :.            ar
-00006090: 6720 3d20 496e 7365 7274 4178 6973 2861  g = InsertAxis(a
-000060a0: 7267 2c20 6c65 6e67 7468 290a 2020 2020  rg, length).    
-000060b0: 2020 2020 2020 2020 7768 6572 652e 6170          where.ap
-000060c0: 7065 6e64 2869 290a 2020 2020 6966 2077  pend(i).    if w
-000060d0: 6865 7265 2021 3d20 6c69 7374 2872 616e  here != list(ran
-000060e0: 6765 286c 656e 2873 6861 7065 2929 293a  ge(len(shape))):
-000060f0: 0a20 2020 2020 2020 2061 7267 203d 2054  .        arg = T
-00006100: 7261 6e73 706f 7365 2861 7267 2c20 6e75  ranspose(arg, nu
-00006110: 6d70 792e 6172 6773 6f72 7428 7768 6572  mpy.argsort(wher
-00006120: 6529 290a 2020 2020 6173 7365 7274 2065  e)).    assert e
-00006130: 7175 616c 7368 6170 6528 6172 672e 7368  qualshape(arg.sh
-00006140: 6170 652c 2073 6861 7065 290a 2020 2020  ape, shape).    
-00006150: 7265 7475 726e 2061 7267 0a0a 0a64 6566  return arg...def
-00006160: 2075 6e61 6c69 676e 282a 6172 6773 293a   unalign(*args):
-00006170: 0a20 2020 2027 2727 5265 6d6f 7665 2028  .    '''Remove (
-00006180: 6a6f 696e 7429 2069 6e73 6572 7465 6420  joint) inserted 
-00006190: 6178 6573 2e0a 0a20 2020 2047 6976 656e  axes...    Given
-000061a0: 206f 6e65 206f 7220 6d6f 7265 2065 7175   one or more equ
-000061b0: 616c 6c79 2073 6861 7065 6420 6172 7261  ally shaped arra
-000061c0: 7920 6172 6775 6d65 6e74 732c 2072 6574  y arguments, ret
-000061d0: 7572 6e20 7468 6520 7368 6f72 7465 7374  urn the shortest
-000061e0: 2063 6f6d 6d6f 6e0a 2020 2020 6178 6973   common.    axis
-000061f0: 2076 6563 746f 7220 616c 6f6e 6720 7769   vector along wi
-00006200: 7468 2066 756e 6374 696f 6e20 6172 6775  th function argu
-00006210: 6d65 6e74 7320 7375 6368 2074 6861 7420  ments such that 
-00006220: 7468 6520 6f72 6967 696e 616c 2061 7272  the original arr
-00006230: 6179 7320 6361 6e0a 2020 2020 6265 2072  ays can.    be r
-00006240: 6563 6f76 6572 6564 2062 7920 3a66 756e  ecovered by :fun
-00006250: 633a 6061 6c69 676e 602e 0a20 2020 2027  c:`align`..    '
-00006260: 2727 0a0a 2020 2020 6173 7365 7274 2061  ''..    assert a
-00006270: 7267 730a 2020 2020 6966 206c 656e 2861  rgs.    if len(a
-00006280: 7267 7329 203d 3d20 313a 0a20 2020 2020  rgs) == 1:.     
-00006290: 2020 2072 6574 7572 6e20 6172 6773 5b30     return args[0
-000062a0: 5d2e 5f75 6e61 6c69 676e 6564 0a20 2020  ]._unaligned.   
-000062b0: 2069 6620 616e 7928 6172 672e 6e64 696d   if any(arg.ndim
-000062c0: 2021 3d20 6172 6773 5b30 5d2e 6e64 696d   != args[0].ndim
-000062d0: 2066 6f72 2061 7267 2069 6e20 6172 6773   for arg in args
-000062e0: 5b31 3a5d 293a 0a20 2020 2020 2020 2072  [1:]):.        r
-000062f0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-00006300: 2776 6172 7969 6e67 2064 696d 656e 7369  'varying dimensi
-00006310: 6f6e 7320 696e 2075 6e61 6c69 676e 2729  ons in unalign')
-00006320: 0a20 2020 206e 6f6e 696e 7320 3d20 6675  .    nonins = fu
-00006330: 6e63 746f 6f6c 732e 7265 6475 6365 286f  nctools.reduce(o
-00006340: 7065 7261 746f 722e 6f72 5f2c 205b 7365  perator.or_, [se
-00006350: 7428 6172 672e 5f75 6e61 6c69 676e 6564  t(arg._unaligned
-00006360: 5b31 5d29 2066 6f72 2061 7267 2069 6e20  [1]) for arg in 
-00006370: 6172 6773 5d29 0a20 2020 2069 6620 6c65  args]).    if le
-00006380: 6e28 6e6f 6e69 6e73 2920 3d3d 2061 7267  n(nonins) == arg
-00006390: 735b 305d 2e6e 6469 6d3a 0a20 2020 2020  s[0].ndim:.     
-000063a0: 2020 2072 6574 7572 6e20 282a 6172 6773     return (*args
-000063b0: 2c20 7475 706c 6528 7261 6e67 6528 6172  , tuple(range(ar
-000063c0: 6773 5b30 5d2e 6e64 696d 2929 290a 2020  gs[0].ndim))).  
-000063d0: 2020 7265 7420 3d20 5b5d 0a20 2020 2066    ret = [].    f
-000063e0: 6f72 2061 7267 2069 6e20 6172 6773 3a0a  or arg in args:.
-000063f0: 2020 2020 2020 2020 756e 616c 6967 6e65          unaligne
-00006400: 642c 2077 6865 7265 203d 2061 7267 2e5f  d, where = arg._
-00006410: 756e 616c 6967 6e65 640a 2020 2020 2020  unaligned.      
-00006420: 2020 666f 7220 6920 696e 2073 6f72 7465    for i in sorte
-00006430: 6428 6e6f 6e69 6e73 202d 2073 6574 2877  d(nonins - set(w
-00006440: 6865 7265 2929 3a0a 2020 2020 2020 2020  here)):.        
-00006450: 2020 2020 756e 616c 6967 6e65 6420 3d20      unaligned = 
-00006460: 496e 7365 7274 4178 6973 2875 6e61 6c69  InsertAxis(unali
-00006470: 676e 6564 2c20 6172 6773 5b30 5d2e 7368  gned, args[0].sh
-00006480: 6170 655b 695d 290a 2020 2020 2020 2020  ape[i]).        
-00006490: 2020 2020 7768 6572 6520 2b3d 2069 2c0a      where += i,.
-000064a0: 2020 2020 2020 2020 6966 206e 6f74 2072          if not r
-000064b0: 6574 3a20 2023 2066 6972 7374 2061 7267  et:  # first arg
-000064c0: 756d 656e 740a 2020 2020 2020 2020 2020  ument.          
-000064d0: 2020 636f 6d6d 6f6e 7768 6572 6520 3d20    commonwhere = 
-000064e0: 7768 6572 650a 2020 2020 2020 2020 656c  where.        el
-000064f0: 6966 2077 6865 7265 2021 3d20 636f 6d6d  if where != comm
-00006500: 6f6e 7768 6572 653a 0a20 2020 2020 2020  onwhere:.       
-00006510: 2020 2020 2075 6e61 6c69 676e 6564 203d       unaligned =
-00006520: 2054 7261 6e73 706f 7365 2875 6e61 6c69   Transpose(unali
-00006530: 676e 6564 2c20 6d61 7028 7768 6572 652e  gned, map(where.
-00006540: 696e 6465 782c 2063 6f6d 6d6f 6e77 6865  index, commonwhe
-00006550: 7265 2929 0a20 2020 2020 2020 2072 6574  re)).        ret
-00006560: 2e61 7070 656e 6428 756e 616c 6967 6e65  .append(unaligne
-00006570: 6429 0a20 2020 2072 6574 7572 6e20 282a  d).    return (*
-00006580: 7265 742c 2063 6f6d 6d6f 6e77 6865 7265  ret, commonwhere
-00006590: 290a 0a23 2041 5252 4159 530a 0a0a 5f41  )..# ARRAYS..._A
-000065a0: 7272 6179 4d65 7461 203d 2074 7970 6528  rrayMeta = type(
-000065b0: 4576 616c 7561 626c 6529 0a0a 6966 2064  Evaluable)..if d
-000065c0: 6562 7567 5f66 6c61 6773 2e73 7061 7273  ebug_flags.spars
-000065d0: 653a 0a20 2020 2064 6566 205f 6368 756e  e:.    def _chun
-000065e0: 6b65 645f 6173 7370 6172 7365 5f63 6865  ked_assparse_che
-000065f0: 636b 6572 286f 7269 6729 3a0a 2020 2020  cker(orig):.    
-00006600: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
-00006610: 7461 6e63 6528 6f72 6967 2c20 7072 6f70  tance(orig, prop
-00006620: 6572 7479 290a 0a20 2020 2020 2020 2040  erty)..        @
-00006630: 7072 6f70 6572 7479 0a20 2020 2020 2020  property.       
-00006640: 2064 6566 205f 6173 7370 6172 7365 2873   def _assparse(s
-00006650: 656c 6629 3a0a 2020 2020 2020 2020 2020  elf):.          
-00006660: 2020 6368 756e 6b73 203d 206f 7269 672e    chunks = orig.
-00006670: 6667 6574 2873 656c 6629 0a20 2020 2020  fget(self).     
-00006680: 2020 2020 2020 2061 7373 6572 7420 6973         assert is
-00006690: 696e 7374 616e 6365 2863 6875 6e6b 732c  instance(chunks,
-000066a0: 2074 7570 6c65 290a 2020 2020 2020 2020   tuple).        
-000066b0: 2020 2020 6173 7365 7274 2061 6c6c 2869      assert all(i
-000066c0: 7369 6e73 7461 6e63 6528 6368 756e 6b2c  sinstance(chunk,
-000066d0: 2074 7570 6c65 2920 666f 7220 6368 756e   tuple) for chun
-000066e0: 6b20 696e 2063 6875 6e6b 7329 0a20 2020  k in chunks).   
-000066f0: 2020 2020 2020 2020 2061 7373 6572 7420           assert 
-00006700: 616c 6c28 616c 6c28 6973 696e 7374 616e  all(all(isinstan
-00006710: 6365 2869 7465 6d2c 2041 7272 6179 2920  ce(item, Array) 
-00006720: 666f 7220 6974 656d 2069 6e20 6368 756e  for item in chun
-00006730: 6b29 2066 6f72 2063 6875 6e6b 2069 6e20  k) for chunk in 
-00006740: 6368 756e 6b73 290a 2020 2020 2020 2020  chunks).        
-00006750: 2020 2020 6966 2073 656c 662e 6e64 696d      if self.ndim
-00006760: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00006770: 2020 666f 7220 2a69 6e64 6963 6573 2c20    for *indices, 
-00006780: 7661 6c75 6573 2069 6e20 6368 756e 6b73  values in chunks
-00006790: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000067a0: 2020 2020 2020 6173 7365 7274 206c 656e        assert len
-000067b0: 2869 6e64 6963 6573 2920 3d3d 2073 656c  (indices) == sel
-000067c0: 662e 6e64 696d 0a20 2020 2020 2020 2020  f.ndim.         
-000067d0: 2020 2020 2020 2020 2020 2061 7373 6572             asser
-000067e0: 7420 616c 6c28 6964 782e 6474 7970 6520  t all(idx.dtype 
-000067f0: 3d3d 2069 6e74 2066 6f72 2069 6478 2069  == int for idx i
-00006800: 6e20 696e 6469 6365 7329 0a20 2020 2020  n indices).     
-00006810: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-00006820: 7373 6572 7420 616c 6c28 6571 7561 6c73  ssert all(equals
-00006830: 6861 7065 2869 6478 2e73 6861 7065 2c20  hape(idx.shape, 
-00006840: 7661 6c75 6573 2e73 6861 7065 2920 666f  values.shape) fo
-00006850: 7220 6964 7820 696e 2069 6e64 6963 6573  r idx in indices
-00006860: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
-00006870: 6966 2063 6875 6e6b 733a 0a20 2020 2020  if chunks:.     
-00006880: 2020 2020 2020 2020 2020 2061 7373 6572             asser
-00006890: 7420 6c65 6e28 6368 756e 6b73 2920 3d3d  t len(chunks) ==
-000068a0: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
-000068b0: 2020 2063 6875 6e6b 2c20 3d20 6368 756e     chunk, = chun
-000068c0: 6b73 0a20 2020 2020 2020 2020 2020 2020  ks.             
-000068d0: 2020 2061 7373 6572 7420 6c65 6e28 6368     assert len(ch
-000068e0: 756e 6b29 203d 3d20 310a 2020 2020 2020  unk) == 1.      
-000068f0: 2020 2020 2020 2020 2020 7661 6c75 6573            values
-00006900: 2c20 3d20 6368 756e 6b0a 2020 2020 2020  , = chunk.      
-00006910: 2020 2020 2020 2020 2020 6173 7365 7274            assert
-00006920: 2076 616c 7565 732e 7368 6170 6520 3d3d   values.shape ==
-00006930: 2028 290a 2020 2020 2020 2020 2020 2020   ().            
-00006940: 7265 7475 726e 2063 6875 6e6b 730a 2020  return chunks.  
-00006950: 2020 2020 2020 7265 7475 726e 205f 6173        return _as
-00006960: 7370 6172 7365 0a0a 2020 2020 636c 6173  sparse..    clas
-00006970: 7320 5f41 7272 6179 4d65 7461 285f 4172  s _ArrayMeta(_Ar
-00006980: 7261 794d 6574 6129 3a0a 2020 2020 2020  rayMeta):.      
-00006990: 2020 6465 6620 5f5f 6e65 775f 5f28 6d63    def __new__(mc
-000069a0: 6c73 2c20 6e61 6d65 2c20 6261 7365 732c  ls, name, bases,
-000069b0: 206e 616d 6573 7061 6365 293a 0a20 2020   namespace):.   
-000069c0: 2020 2020 2020 2020 2069 6620 275f 6173           if '_as
-000069d0: 7370 6172 7365 2720 696e 206e 616d 6573  sparse' in names
-000069e0: 7061 6365 3a0a 2020 2020 2020 2020 2020  pace:.          
-000069f0: 2020 2020 2020 6e61 6d65 7370 6163 655b        namespace[
-00006a00: 275f 6173 7370 6172 7365 275d 203d 205f  '_assparse'] = _
-00006a10: 6368 756e 6b65 645f 6173 7370 6172 7365  chunked_assparse
-00006a20: 5f63 6865 636b 6572 286e 616d 6573 7061  _checker(namespa
-00006a30: 6365 5b27 5f61 7373 7061 7273 6527 5d29  ce['_assparse'])
-00006a40: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00006a50: 7572 6e20 7375 7065 7228 292e 5f5f 6e65  urn super().__ne
-00006a60: 775f 5f28 6d63 6c73 2c20 6e61 6d65 2c20  w__(mcls, name, 
-00006a70: 6261 7365 732c 206e 616d 6573 7061 6365  bases, namespace
-00006a80: 290a 0a69 6620 6465 6275 675f 666c 6167  )..if debug_flag
-00006a90: 732e 6576 616c 663a 0a20 2020 2063 6c61  s.evalf:.    cla
-00006aa0: 7373 205f 6576 616c 665f 6368 6563 6b65  ss _evalf_checke
-00006ab0: 723a 0a20 2020 2020 2020 2064 6566 205f  r:.        def _
-00006ac0: 5f69 6e69 745f 5f28 7365 6c66 2c20 6f72  _init__(self, or
-00006ad0: 6967 293a 0a20 2020 2020 2020 2020 2020  ig):.           
-00006ae0: 2073 656c 662e 6576 616c 665f 6f62 6a20   self.evalf_obj 
-00006af0: 3d20 6765 7461 7474 7228 6f72 6967 2c20  = getattr(orig, 
-00006b00: 275f 5f67 6574 5f5f 272c 206c 616d 6264  '__get__', lambd
-00006b10: 6120 2a61 7267 733a 206f 7269 6729 0a0a  a *args: orig)..
-00006b20: 2020 2020 2020 2020 6465 6620 5f5f 6765          def __ge
-00006b30: 745f 5f28 7365 6c66 2c20 696e 7374 616e  t__(self, instan
-00006b40: 6365 2c20 6f77 6e65 7229 3a0a 2020 2020  ce, owner):.    
-00006b50: 2020 2020 2020 2020 6576 616c 6620 3d20          evalf = 
-00006b60: 7365 6c66 2e65 7661 6c66 5f6f 626a 2869  self.evalf_obj(i
-00006b70: 6e73 7461 6e63 652c 206f 776e 6572 290a  nstance, owner).
-00006b80: 0a20 2020 2020 2020 2020 2020 2040 6675  .            @fu
-00006b90: 6e63 746f 6f6c 732e 7772 6170 7328 6576  nctools.wraps(ev
-00006ba0: 616c 6629 0a20 2020 2020 2020 2020 2020  alf).           
-00006bb0: 2064 6566 2065 7661 6c66 5f77 6974 685f   def evalf_with_
-00006bc0: 6368 6563 6b28 2a61 7267 732c 202a 2a6b  check(*args, **k
-00006bd0: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
-00006be0: 2020 2020 2020 2020 7265 7320 3d20 6576          res = ev
-00006bf0: 616c 6628 2a61 7267 732c 202a 2a6b 7761  alf(*args, **kwa
-00006c00: 7267 7329 0a20 2020 2020 2020 2020 2020  rgs).           
-00006c10: 2020 2020 2061 7373 6572 7420 6e6f 7420       assert not 
-00006c20: 6861 7361 7474 7228 696e 7374 616e 6365  hasattr(instance
-00006c30: 2c20 2764 7479 7065 2729 206f 7220 6173  , 'dtype') or as
-00006c40: 6474 7970 6528 7265 732e 6474 7970 6529  dtype(res.dtype)
-00006c50: 203d 3d20 696e 7374 616e 6365 2e64 7479   == instance.dty
-00006c60: 7065 2c20 2828 696e 7374 616e 6365 2e64  pe, ((instance.d
-00006c70: 7479 7065 2c20 7265 732e 6474 7970 6529  type, res.dtype)
-00006c80: 2c20 696e 7374 616e 6365 2c20 7265 7329  , instance, res)
-00006c90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006ca0: 2061 7373 6572 7420 6e6f 7420 6861 7361   assert not hasa
-00006cb0: 7474 7228 696e 7374 616e 6365 2c20 276e  ttr(instance, 'n
-00006cc0: 6469 6d27 2920 6f72 2072 6573 2e6e 6469  dim') or res.ndi
-00006cd0: 6d20 3d3d 2069 6e73 7461 6e63 652e 6e64  m == instance.nd
-00006ce0: 696d 0a20 2020 2020 2020 2020 2020 2020  im.             
-00006cf0: 2020 2061 7373 6572 7420 6e6f 7420 6861     assert not ha
-00006d00: 7361 7474 7228 696e 7374 616e 6365 2c20  sattr(instance, 
-00006d10: 2773 6861 7065 2729 206f 7220 616c 6c28  'shape') or all(
-00006d20: 6d20 3d3d 206e 2066 6f72 206d 2c20 6e20  m == n for m, n 
-00006d30: 696e 207a 6970 2872 6573 2e73 6861 7065  in zip(res.shape
-00006d40: 2c20 696e 7374 616e 6365 2e73 6861 7065  , instance.shape
-00006d50: 2920 6966 2069 7369 6e73 7461 6e63 6528  ) if isinstance(
-00006d60: 6e2c 2069 6e74 2929 2c20 2773 6861 7065  n, int)), 'shape
-00006d70: 206d 6973 6d61 7463 6827 0a20 2020 2020   mismatch'.     
-00006d80: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00006d90: 6e20 7265 730a 2020 2020 2020 2020 2020  n res.          
-00006da0: 2020 7265 7475 726e 2065 7661 6c66 5f77    return evalf_w
-00006db0: 6974 685f 6368 6563 6b0a 0a20 2020 2063  ith_check..    c
-00006dc0: 6c61 7373 205f 4172 7261 794d 6574 6128  lass _ArrayMeta(
-00006dd0: 5f41 7272 6179 4d65 7461 293a 0a20 2020  _ArrayMeta):.   
-00006de0: 2020 2020 2064 6566 205f 5f6e 6577 5f5f       def __new__
-00006df0: 286d 636c 732c 206e 616d 652c 2062 6173  (mcls, name, bas
-00006e00: 6573 2c20 6e61 6d65 7370 6163 6529 3a0a  es, namespace):.
-00006e10: 2020 2020 2020 2020 2020 2020 6966 2027              if '
-00006e20: 6576 616c 6627 2069 6e20 6e61 6d65 7370  evalf' in namesp
-00006e30: 6163 653a 0a20 2020 2020 2020 2020 2020  ace:.           
-00006e40: 2020 2020 206e 616d 6573 7061 6365 5b27       namespace['
-00006e50: 6576 616c 6627 5d20 3d20 5f65 7661 6c66  evalf'] = _evalf
-00006e60: 5f63 6865 636b 6572 286e 616d 6573 7061  _checker(namespa
-00006e70: 6365 5b27 6576 616c 6627 5d29 0a20 2020  ce['evalf']).   
-00006e80: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00006e90: 7375 7065 7228 292e 5f5f 6e65 775f 5f28  super().__new__(
-00006ea0: 6d63 6c73 2c20 6e61 6d65 2c20 6261 7365  mcls, name, base
-00006eb0: 732c 206e 616d 6573 7061 6365 290a 0a0a  s, namespace)...
-00006ec0: 636c 6173 7320 4173 4576 616c 7561 626c  class AsEvaluabl
-00006ed0: 6541 7272 6179 2850 726f 746f 636f 6c29  eArray(Protocol)
-00006ee0: 3a0a 2020 2020 2750 726f 746f 636f 6c20  :.    'Protocol 
-00006ef0: 666f 7220 636f 6e76 6572 7369 6f6e 2069  for conversion i
-00006f00: 6e74 6f20 616e 203a 636c 6173 733a 6041  nto an :class:`A
-00006f10: 7272 6179 602e 270a 0a20 2020 2040 7072  rray`.'..    @pr
-00006f20: 6f70 6572 7479 0a20 2020 2064 6566 2061  operty.    def a
-00006f30: 735f 6576 616c 7561 626c 655f 6172 7261  s_evaluable_arra
-00006f40: 7928 7365 6c66 2920 2d3e 2027 4172 7261  y(self) -> 'Arra
-00006f50: 7927 3a0a 2020 2020 2020 2020 274c 6f77  y':.        'Low
-00006f60: 6572 2074 6869 7320 6f62 6a65 6374 2074  er this object t
-00006f70: 6f20 6120 3a63 6c61 7373 3a60 6e75 7469  o a :class:`nuti
-00006f80: 6c73 2e65 7661 6c75 6162 6c65 2e41 7272  ls.evaluable.Arr
-00006f90: 6179 602e 270a 0a0a 636c 6173 7320 4172  ay`.'...class Ar
-00006fa0: 7261 7928 4576 616c 7561 626c 652c 206d  ray(Evaluable, m
-00006fb0: 6574 6163 6c61 7373 3d5f 4172 7261 794d  etaclass=_ArrayM
-00006fc0: 6574 6129 3a0a 2020 2020 2727 270a 2020  eta):.    '''.  
-00006fd0: 2020 4261 7365 2063 6c61 7373 2066 6f72    Base class for
-00006fe0: 2061 7272 6179 2076 616c 7565 6420 6675   array valued fu
-00006ff0: 6e63 7469 6f6e 732e 0a0a 2020 2020 4174  nctions...    At
-00007000: 7472 6962 7574 6573 0a20 2020 202d 2d2d  tributes.    ---
-00007010: 2d2d 2d2d 2d2d 2d0a 2020 2020 7368 6170  -------.    shap
-00007020: 6520 3a20 3a63 6c61 7373 3a60 7475 706c  e : :class:`tupl
-00007030: 6560 206f 6620 3a63 6c61 7373 3a60 696e  e` of :class:`in
-00007040: 7460 5c5c 730a 2020 2020 2020 2020 5468  t`\\s.        Th
-00007050: 6520 7368 6170 6520 6f66 2074 6869 7320  e shape of this 
-00007060: 6172 7261 7920 6675 6e63 7469 6f6e 2e0a  array function..
-00007070: 2020 2020 6e64 696d 203a 203a 636c 6173      ndim : :clas
-00007080: 733a 6069 6e74 600a 2020 2020 2020 2020  s:`int`.        
-00007090: 5468 6520 6e75 6d62 6572 206f 6620 6469  The number of di
-000070a0: 6d65 6e73 696f 6e73 206f 6620 7468 6973  mensions of this
-000070b0: 2061 7272 6179 2061 7272 6179 2066 756e   array array fun
-000070c0: 6374 696f 6e2e 2020 4571 7561 6c20 746f  ction.  Equal to
-000070d0: 0a20 2020 2020 2020 2060 606c 656e 2873  .        ``len(s
-000070e0: 6861 7065 2960 602e 0a20 2020 2064 7479  hape)``..    dty
-000070f0: 7065 203a 203a 636c 6173 733a 6069 6e74  pe : :class:`int
-00007100: 602c 203a 636c 6173 733a 6066 6c6f 6174  `, :class:`float
-00007110: 600a 2020 2020 2020 2020 5468 6520 6474  `.        The dt
-00007120: 7970 6520 6f66 2074 6865 2061 7272 6179  ype of the array
-00007130: 2065 6c65 6d65 6e74 732e 0a20 2020 2027   elements..    '
-00007140: 2727 0a0a 2020 2020 5f5f 736c 6f74 735f  ''..    __slots_
-00007150: 5f20 3d20 2773 6861 7065 272c 2027 6474  _ = 'shape', 'dt
-00007160: 7970 6527 2c20 275f 5f69 6e64 6578 270a  ype', '__index'.
-00007170: 2020 2020 5f5f 6361 6368 655f 5f20 3d20      __cache__ = 
-00007180: 2761 7373 7061 7273 6527 2c20 275f 6173  'assparse', '_as
-00007190: 7370 6172 7365 272c 2027 5f69 6e74 626f  sparse', '_intbo
-000071a0: 756e 6473 270a 0a20 2020 205f 5f61 7272  unds'..    __arr
-000071b0: 6179 5f70 7269 6f72 6974 795f 5f20 3d20  ay_priority__ = 
-000071c0: 312e 2020 2320 6874 7470 3a2f 2f73 7461  1.  # http://sta
-000071d0: 636b 6f76 6572 666c 6f77 2e63 6f6d 2f71  ckoverflow.com/q
-000071e0: 7565 7374 696f 6e73 2f37 3034 3234 3936  uestions/7042496
-000071f0: 2f6e 756d 7079 2d63 6f65 7263 696f 6e2d  /numpy-coercion-
-00007200: 7072 6f62 6c65 6d2d 666f 722d 6c65 6674  problem-for-left
-00007210: 2d73 6964 6564 2d62 696e 6172 792d 6f70  -sided-binary-op
-00007220: 6572 6174 6f72 2f37 3035 3735 3330 2337  erator/7057530#7
-00007230: 3035 3735 3330 0a0a 2020 2020 4074 7970  057530..    @typ
-00007240: 6573 2e61 7070 6c79 5f61 6e6e 6f74 6174  es.apply_annotat
-00007250: 696f 6e73 0a20 2020 2064 6566 205f 5f69  ions.    def __i
-00007260: 6e69 745f 5f28 7365 6c66 2c20 6172 6773  nit__(self, args
-00007270: 3a20 7479 7065 732e 7475 706c 655b 7374  : types.tuple[st
-00007280: 7269 6374 6576 616c 7561 626c 655d 2c20  rictevaluable], 
-00007290: 7368 6170 653a 2061 7373 6861 7065 2c20  shape: asshape, 
-000072a0: 6474 7970 653a 2061 7364 7479 7065 293a  dtype: asdtype):
-000072b0: 0a20 2020 2020 2020 2073 656c 662e 7368  .        self.sh
-000072c0: 6170 6520 3d20 7368 6170 650a 2020 2020  ape = shape.    
-000072d0: 2020 2020 7365 6c66 2e64 7479 7065 203d      self.dtype =
-000072e0: 2064 7479 7065 0a20 2020 2020 2020 2073   dtype.        s
-000072f0: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
-00007300: 6172 6773 3d61 7267 7329 0a0a 2020 2020  args=args)..    
-00007310: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-00007320: 6620 6e64 696d 2873 656c 6629 3a0a 2020  f ndim(self):.  
-00007330: 2020 2020 2020 7265 7475 726e 206c 656e        return len
-00007340: 2873 656c 662e 7368 6170 6529 0a0a 2020  (self.shape)..  
-00007350: 2020 6465 6620 5f5f 6765 7469 7465 6d5f    def __getitem_
-00007360: 5f28 7365 6c66 2c20 6974 656d 293a 0a20  _(self, item):. 
-00007370: 2020 2020 2020 2069 6620 6e6f 7420 6973         if not is
-00007380: 696e 7374 616e 6365 2869 7465 6d2c 2074  instance(item, t
-00007390: 7570 6c65 293a 0a20 2020 2020 2020 2020  uple):.         
-000073a0: 2020 2069 7465 6d20 3d20 6974 656d 2c0a     item = item,.
-000073b0: 2020 2020 2020 2020 6966 202e 2e2e 2069          if ... i
-000073c0: 6e20 6974 656d 3a0a 2020 2020 2020 2020  n item:.        
-000073d0: 2020 2020 6965 6c6c 203d 2069 7465 6d2e      iell = item.
-000073e0: 696e 6465 7828 2e2e 2e29 0a20 2020 2020  index(...).     
-000073f0: 2020 2020 2020 2069 6620 2e2e 2e20 696e         if ... in
-00007400: 2069 7465 6d5b 6965 6c6c 2b31 3a5d 3a0a   item[iell+1:]:.
-00007410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007420: 7261 6973 6520 496e 6465 7845 7272 6f72  raise IndexError
-00007430: 2827 616e 2069 6e64 6578 2063 616e 2068  ('an index can h
-00007440: 6176 6520 6f6e 6c79 2061 2073 696e 676c  ave only a singl
-00007450: 6520 656c 6c69 7073 6973 2729 0a20 2020  e ellipsis').   
-00007460: 2020 2020 2020 2020 2023 2072 6570 6c61           # repla
-00007470: 6365 2065 6c6c 6970 7369 7320 6279 2074  ce ellipsis by t
-00007480: 6865 2061 7070 726f 7072 6961 7465 206e  he appropriate n
-00007490: 756d 6265 7220 6f66 2073 6c69 6365 284e  umber of slice(N
-000074a0: 6f6e 6529 0a20 2020 2020 2020 2020 2020  one).           
-000074b0: 2069 7465 6d20 3d20 6974 656d 5b3a 6965   item = item[:ie
-000074c0: 6c6c 5d20 2b20 2873 6c69 6365 284e 6f6e  ll] + (slice(Non
-000074d0: 6529 2c29 2a28 7365 6c66 2e6e 6469 6d2d  e),)*(self.ndim-
-000074e0: 6c65 6e28 6974 656d 292b 3129 202b 2069  len(item)+1) + i
-000074f0: 7465 6d5b 6965 6c6c 2b31 3a5d 0a20 2020  tem[iell+1:].   
-00007500: 2020 2020 2069 6620 6c65 6e28 6974 656d       if len(item
-00007510: 2920 3e20 7365 6c66 2e6e 6469 6d3a 0a20  ) > self.ndim:. 
-00007520: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00007530: 2049 6e64 6578 4572 726f 7228 2774 6f6f   IndexError('too
-00007540: 206d 616e 7920 696e 6469 6365 7320 666f   many indices fo
-00007550: 7220 6172 7261 7927 290a 2020 2020 2020  r array').      
-00007560: 2020 6172 7261 7920 3d20 7365 6c66 0a20    array = self. 
-00007570: 2020 2020 2020 2066 6f72 2061 7869 732c         for axis,
-00007580: 2069 7420 696e 2072 6576 6572 7365 6428   it in reversed(
-00007590: 7475 706c 6528 656e 756d 6572 6174 6528  tuple(enumerate(
-000075a0: 6974 656d 2929 293a 0a20 2020 2020 2020  item))):.       
-000075b0: 2020 2020 2061 7272 6179 203d 2067 6574       array = get
-000075c0: 2861 7272 6179 2c20 6178 6973 2c20 6974  (array, axis, it
-000075d0: 656d 3d69 7429 2069 6620 6e75 6d65 7269  em=it) if numeri
-000075e0: 632e 6973 696e 7428 6974 2920 5c0a 2020  c.isint(it) \.  
-000075f0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00007600: 7365 205f 7461 6b65 736c 6963 6528 6172  se _takeslice(ar
-00007610: 7261 792c 2069 742c 2061 7869 7329 2069  ray, it, axis) i
-00007620: 6620 6973 696e 7374 616e 6365 2869 742c  f isinstance(it,
-00007630: 2073 6c69 6365 2920 5c0a 2020 2020 2020   slice) \.      
-00007640: 2020 2020 2020 2020 2020 656c 7365 2074            else t
-00007650: 616b 6528 6172 7261 792c 2069 742c 2061  ake(array, it, a
-00007660: 7869 7329 0a20 2020 2020 2020 2072 6574  xis).        ret
-00007670: 7572 6e20 6172 7261 790a 0a20 2020 2064  urn array..    d
-00007680: 6566 205f 5f62 6f6f 6c5f 5f28 7365 6c66  ef __bool__(self
-00007690: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-000076a0: 6e20 5472 7565 0a0a 2020 2020 6465 6620  n True..    def 
-000076b0: 5f5f 6c65 6e5f 5f28 7365 6c66 293a 0a20  __len__(self):. 
-000076c0: 2020 2020 2020 2069 6620 7365 6c66 2e6e         if self.n
-000076d0: 6469 6d20 3d3d 2030 3a0a 2020 2020 2020  dim == 0:.      
-000076e0: 2020 2020 2020 7261 6973 6520 5479 7065        raise Type
-000076f0: 4572 726f 7228 276c 656e 2829 206f 6620  Error('len() of 
-00007700: 756e 7369 7a65 6420 6f62 6a65 6374 2729  unsized object')
-00007710: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00007720: 7365 6c66 2e73 6861 7065 5b30 5d0a 0a20  self.shape[0].. 
-00007730: 2020 2064 6566 205f 5f69 6e64 6578 5f5f     def __index__
-00007740: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00007750: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
-00007760: 2069 6e64 6578 203d 2073 656c 662e 5f5f   index = self.__
-00007770: 696e 6465 780a 2020 2020 2020 2020 6578  index.        ex
-00007780: 6365 7074 2041 7474 7269 6275 7465 4572  cept AttributeEr
-00007790: 726f 723a 0a20 2020 2020 2020 2020 2020  ror:.           
-000077a0: 2069 6620 7365 6c66 2e6e 6469 6d20 6f72   if self.ndim or
-000077b0: 2073 656c 662e 6474 7970 6520 6e6f 7420   self.dtype not 
-000077c0: 696e 2028 696e 742c 2062 6f6f 6c29 206f  in (int, bool) o
-000077d0: 7220 6e6f 7420 7365 6c66 2e69 7363 6f6e  r not self.iscon
-000077e0: 7374 616e 743a 0a20 2020 2020 2020 2020  stant:.         
-000077f0: 2020 2020 2020 2072 6169 7365 2054 7970         raise Typ
-00007800: 6545 7272 6f72 2827 6361 6e6e 6f74 2063  eError('cannot c
-00007810: 6f6e 7665 7274 207b 2172 7d20 746f 2069  onvert {!r} to i
-00007820: 6e74 272e 666f 726d 6174 2873 656c 6629  nt'.format(self)
-00007830: 290a 2020 2020 2020 2020 2020 2020 696e  ).            in
-00007840: 6465 7820 3d20 7365 6c66 2e5f 5f69 6e64  dex = self.__ind
-00007850: 6578 203d 2069 6e74 2873 656c 662e 7369  ex = int(self.si
-00007860: 6d70 6c69 6669 6564 2e65 7661 6c28 2929  mplified.eval())
-00007870: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00007880: 696e 6465 780a 0a20 2020 2073 697a 6520  index..    size 
-00007890: 3d20 7072 6f70 6572 7479 286c 616d 6264  = property(lambd
-000078a0: 6120 7365 6c66 3a20 7574 696c 2e70 726f  a self: util.pro
-000078b0: 6475 6374 2873 656c 662e 7368 6170 6529  duct(self.shape)
-000078c0: 2069 6620 7365 6c66 2e6e 6469 6d20 656c   if self.ndim el
-000078d0: 7365 2031 290a 2020 2020 5420 3d20 7072  se 1).    T = pr
-000078e0: 6f70 6572 7479 286c 616d 6264 6120 7365  operty(lambda se
-000078f0: 6c66 3a20 7472 616e 7370 6f73 6528 7365  lf: transpose(se
-00007900: 6c66 2929 0a0a 2020 2020 5f5f 6164 645f  lf))..    __add_
-00007910: 5f20 3d20 5f5f 7261 6464 5f5f 203d 2061  _ = __radd__ = a
-00007920: 6464 0a20 2020 205f 5f73 7562 5f5f 203d  dd.    __sub__ =
-00007930: 206c 616d 6264 6120 7365 6c66 2c20 6f74   lambda self, ot
-00007940: 6865 723a 2073 7562 7472 6163 7428 7365  her: subtract(se
-00007950: 6c66 2c20 6f74 6865 7229 0a20 2020 205f  lf, other).    _
-00007960: 5f72 7375 625f 5f20 3d20 6c61 6d62 6461  _rsub__ = lambda
-00007970: 2073 656c 662c 206f 7468 6572 3a20 7375   self, other: su
-00007980: 6274 7261 6374 286f 7468 6572 2c20 7365  btract(other, se
-00007990: 6c66 290a 2020 2020 5f5f 6d75 6c5f 5f20  lf).    __mul__ 
-000079a0: 3d20 5f5f 726d 756c 5f5f 203d 206d 756c  = __rmul__ = mul
-000079b0: 7469 706c 790a 2020 2020 5f5f 7472 7565  tiply.    __true
-000079c0: 6469 765f 5f20 3d20 6c61 6d62 6461 2073  div__ = lambda s
-000079d0: 656c 662c 206f 7468 6572 3a20 6469 7669  elf, other: divi
-000079e0: 6465 2873 656c 662c 206f 7468 6572 290a  de(self, other).
-000079f0: 2020 2020 5f5f 7274 7275 6564 6976 5f5f      __rtruediv__
-00007a00: 203d 206c 616d 6264 6120 7365 6c66 2c20   = lambda self, 
-00007a10: 6f74 6865 723a 2064 6976 6964 6528 6f74  other: divide(ot
-00007a20: 6865 722c 2073 656c 6629 0a20 2020 205f  her, self).    _
-00007a30: 5f70 6f73 5f5f 203d 206c 616d 6264 6120  _pos__ = lambda 
-00007a40: 7365 6c66 3a20 7365 6c66 0a20 2020 205f  self: self.    _
-00007a50: 5f6e 6567 5f5f 203d 206c 616d 6264 6120  _neg__ = lambda 
-00007a60: 7365 6c66 3a20 6e65 6761 7469 7665 2873  self: negative(s
-00007a70: 656c 6629 0a20 2020 205f 5f70 6f77 5f5f  elf).    __pow__
-00007a80: 203d 2070 6f77 6572 0a20 2020 205f 5f61   = power.    __a
-00007a90: 6273 5f5f 203d 206c 616d 6264 6120 7365  bs__ = lambda se
-00007aa0: 6c66 3a20 6162 7328 7365 6c66 290a 2020  lf: abs(self).  
-00007ab0: 2020 5f5f 6d6f 645f 5f20 3d20 6c61 6d62    __mod__ = lamb
-00007ac0: 6461 2073 656c 662c 206f 7468 6572 3a20  da self, other: 
-00007ad0: 6d6f 6428 7365 6c66 2c20 6f74 6865 7229  mod(self, other)
-00007ae0: 0a20 2020 205f 5f69 6e74 5f5f 203d 205f  .    __int__ = _
-00007af0: 5f69 6e64 6578 5f5f 0a20 2020 205f 5f73  _index__.    __s
-00007b00: 7472 5f5f 203d 205f 5f72 6570 725f 5f20  tr__ = __repr__ 
-00007b10: 3d20 6c61 6d62 6461 2073 656c 663a 2027  = lambda self: '
-00007b20: 7b7d 2e7b 7d3c 7b7d 3e27 2e66 6f72 6d61  {}.{}<{}>'.forma
-00007b30: 7428 7479 7065 2873 656c 6629 2e5f 5f6d  t(type(self).__m
-00007b40: 6f64 756c 655f 5f2c 2074 7970 6528 7365  odule__, type(se
-00007b50: 6c66 292e 5f5f 6e61 6d65 5f5f 2c20 7365  lf).__name__, se
-00007b60: 6c66 2e5f 7368 6170 655f 7374 7228 666f  lf._shape_str(fo
-00007b70: 726d 3d73 7472 2929 0a20 2020 205f 7368  rm=str)).    _sh
-00007b80: 6170 655f 7374 7220 3d20 6c61 6d62 6461  ape_str = lambda
-00007b90: 2073 656c 662c 2066 6f72 6d3a 2027 7b7d   self, form: '{}
-00007ba0: 3a7b 7d27 2e66 6f72 6d61 7428 7365 6c66  :{}'.format(self
-00007bb0: 2e64 7479 7065 2e5f 5f6e 616d 655f 5f5b  .dtype.__name__[
-00007bc0: 305d 2069 6620 6861 7361 7474 7228 7365  0] if hasattr(se
-00007bd0: 6c66 2c20 2764 7479 7065 2729 2065 6c73  lf, 'dtype') els
-00007be0: 6520 273f 272c 2027 2c27 2e6a 6f69 6e28  e '?', ','.join(
-00007bf0: 7374 7228 696e 7428 6c65 6e67 7468 2929  str(int(length))
-00007c00: 2069 6620 6c65 6e67 7468 2e69 7363 6f6e   if length.iscon
-00007c10: 7374 616e 7420 656c 7365 2027 3f27 2066  stant else '?' f
-00007c20: 6f72 206c 656e 6774 6820 696e 2073 656c  or length in sel
-00007c30: 662e 7368 6170 6529 2069 6620 6861 7361  f.shape) if hasa
-00007c40: 7474 7228 7365 6c66 2c20 2773 6861 7065  ttr(self, 'shape
-00007c50: 2729 2065 6c73 6520 273f 2729 0a0a 2020  ') else '?')..  
-00007c60: 2020 7375 6d20 3d20 7375 6d0a 2020 2020    sum = sum.    
-00007c70: 7072 6f64 203d 2070 726f 6475 6374 0a20  prod = product. 
-00007c80: 2020 2064 6f74 203d 2064 6f74 0a20 2020     dot = dot.   
-00007c90: 2073 7761 7061 7865 7320 3d20 7377 6170   swapaxes = swap
-00007ca0: 6178 6573 0a20 2020 2074 7261 6e73 706f  axes.    transpo
-00007cb0: 7365 203d 2074 7261 6e73 706f 7365 0a20  se = transpose. 
-00007cc0: 2020 2063 686f 6f73 6520 3d20 6c61 6d62     choose = lamb
-00007cd0: 6461 2073 656c 662c 2063 686f 6963 6573  da self, choices
-00007ce0: 3a20 4368 6f6f 7365 2873 656c 662c 2063  : Choose(self, c
-00007cf0: 686f 6963 6573 290a 2020 2020 636f 6e6a  hoices).    conj
-00007d00: 7567 6174 6520 3d20 636f 6e6a 7567 6174  ugate = conjugat
-00007d10: 650a 0a20 2020 2040 7072 6f70 6572 7479  e..    @property
-00007d20: 0a20 2020 2064 6566 2072 6561 6c28 7365  .    def real(se
-00007d30: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-00007d40: 7572 6e20 7265 616c 2873 656c 6629 0a0a  urn real(self)..
-00007d50: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-00007d60: 2020 6465 6620 696d 6167 2873 656c 6629    def imag(self)
-00007d70: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00007d80: 2069 6d61 6728 7365 6c66 290a 0a20 2020   imag(self)..   
-00007d90: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-00007da0: 6566 2061 7373 7061 7273 6528 7365 6c66  ef assparse(self
-00007db0: 293a 0a20 2020 2020 2020 2027 436f 6e76  ):.        'Conv
-00007dc0: 6572 7420 746f 2061 203a 636c 6173 733a  ert to a :class:
-00007dd0: 6053 7061 7273 6541 7272 6179 602e 270a  `SparseArray`.'.
-00007de0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00007df0: 5370 6172 7365 4172 7261 7928 7365 6c66  SparseArray(self
-00007e00: 2e73 696d 706c 6966 6965 642e 5f61 7373  .simplified._ass
-00007e10: 7061 7273 652c 2073 656c 662e 7368 6170  parse, self.shap
-00007e20: 652c 2073 656c 662e 6474 7970 6529 0a0a  e, self.dtype)..
-00007e30: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-00007e40: 2020 6465 6620 5f61 7373 7061 7273 6528    def _assparse(
-00007e50: 7365 6c66 293a 0a20 2020 2020 2020 2023  self):.        #
-00007e60: 2043 6f6e 7665 7274 2074 6f20 6120 7365   Convert to a se
-00007e70: 7175 656e 6365 206f 6620 7370 6172 7365  quence of sparse
-00007e80: 2043 4f4f 2061 7272 6179 732e 2054 6865   COO arrays. The
-00007e90: 2072 6574 7572 6e65 6420 6461 7461 2069   returned data i
-00007ea0: 7320 6120 7475 706c 650a 2020 2020 2020  s a tuple.      
-00007eb0: 2020 2320 6f66 2060 282a 696e 6469 6365    # of `(*indice
-00007ec0: 732c 2076 616c 7565 7329 6020 7475 706c  s, values)` tupl
-00007ed0: 6573 2c20 7768 6572 6520 6076 616c 7565  es, where `value
-00007ee0: 7360 2069 7320 616e 2060 4172 7261 7960  s` is an `Array`
-00007ef0: 2077 6974 6820 7468 650a 2020 2020 2020   with the.      
-00007f00: 2020 2320 7361 6d65 2064 7479 7065 2061    # same dtype a
-00007f10: 7320 6073 656c 6660 2c20 6275 7420 7468  s `self`, but th
-00007f20: 6973 2069 7320 6e6f 7420 656e 666f 7263  is is not enforc
-00007f30: 6564 2079 6574 2c20 616e 6420 6561 6368  ed yet, and each
-00007f40: 2069 6e64 6578 2069 6e0a 2020 2020 2020   index in.      
-00007f50: 2020 2320 6069 6e64 6963 6573 6020 6973    # `indices` is
-00007f60: 2061 6e20 6041 7272 6179 6020 7769 7468   an `Array` with
-00007f70: 2064 7479 7065 2060 696e 7460 2061 6e64   dtype `int` and
-00007f80: 2074 6865 2065 7861 6374 2073 616d 6520   the exact same 
-00007f90: 7368 6170 6520 6173 0a20 2020 2020 2020  shape as.       
-00007fa0: 2023 2060 7661 6c75 6573 602e 2054 6865   # `values`. The
-00007fb0: 206c 656e 6774 6820 6f66 2060 696e 6469   length of `indi
-00007fc0: 6365 7360 2065 7175 616c 7320 6073 656c  ces` equals `sel
-00007fd0: 662e 6e64 696d 602e 2049 6e20 6164 6469  f.ndim`. In addi
-00007fe0: 7469 6f6e 2c20 6966 0a20 2020 2020 2020  tion, if.       
-00007ff0: 2023 2060 7365 6c66 6020 6973 2030 6420   # `self` is 0d 
-00008000: 7468 6520 6c65 6e67 7468 206f 6620 6073  the length of `s
-00008010: 656c 662e 5f61 7373 7061 7273 6560 2069  elf._assparse` i
-00008020: 7320 6174 206d 6f73 7420 6f6e 6520 616e  s at most one an
-00008030: 6420 7468 650a 2020 2020 2020 2020 2320  d the.        # 
-00008040: 6076 616c 7565 7360 2061 7272 6179 206d  `values` array m
-00008050: 7573 7420 6265 2030 6420 6173 2077 656c  ust be 0d as wel
-00008060: 6c2e 0a20 2020 2020 2020 2023 0a20 2020  l..        #.   
-00008070: 2020 2020 2023 2054 6865 2073 7061 7273       # The spars
-00008080: 6520 6461 7461 2063 616e 2062 6520 7265  e data can be re
-00008090: 6173 7365 6d62 6c65 6420 6166 7465 7220  assembled after 
-000080a0: 6576 616c 7561 7469 6f6e 2062 790a 2020  evaluation by.  
-000080b0: 2020 2020 2020 230a 2020 2020 2020 2020        #.        
-000080c0: 2320 2020 2020 6465 6e73 6520 3d20 6e75  #     dense = nu
-000080d0: 6d70 792e 7a65 726f 7328 7365 6c66 2e73  mpy.zeros(self.s
-000080e0: 6861 7065 290a 2020 2020 2020 2020 2320  hape).        # 
-000080f0: 2020 2020 666f 7220 4930 2c2e 2e2e 2c49      for I0,...,I
-00008100: 6b2c 5620 696e 2073 656c 662e 5f61 7373  k,V in self._ass
-00008110: 7061 7273 653a 0a20 2020 2020 2020 2023  parse:.        #
-00008120: 2020 2020 2020 2066 6f72 2069 302c 2e2e         for i0,..
-00008130: 2e2c 696b 2c76 2069 6e20 7a69 7028 4930  .,ik,v in zip(I0
-00008140: 2e65 7661 6c28 292e 7261 7665 6c28 292c  .eval().ravel(),
-00008150: 2e2e 2e2c 496b 2e65 7661 6c28 292e 7261  ...,Ik.eval().ra
-00008160: 7665 6c28 292c 562e 6576 616c 2829 2e72  vel(),V.eval().r
-00008170: 6176 656c 2829 293a 0a20 2020 2020 2020  avel()):.       
-00008180: 2023 2020 2020 2020 2020 2064 656e 7365   #         dense
-00008190: 5b69 302c 2e2e 2e2c 696b 5d20 3d20 760a  [i0,...,ik] = v.
-000081a0: 0a20 2020 2020 2020 2069 6e64 6963 6573  .        indices
-000081b0: 203d 205b 7072 6570 656e 6461 7865 7328   = [prependaxes(
-000081c0: 6170 7065 6e64 6178 6573 2852 616e 6765  appendaxes(Range
-000081d0: 286c 656e 6774 6829 2c20 7365 6c66 2e73  (length), self.s
-000081e0: 6861 7065 5b69 2b31 3a5d 292c 2073 656c  hape[i+1:]), sel
-000081f0: 662e 7368 6170 655b 3a69 5d29 2066 6f72  f.shape[:i]) for
-00008200: 2069 2c20 6c65 6e67 7468 2069 6e20 656e   i, length in en
-00008210: 756d 6572 6174 6528 7365 6c66 2e73 6861  umerate(self.sha
-00008220: 7065 295d 0a20 2020 2020 2020 2072 6574  pe)].        ret
-00008230: 7572 6e20 282a 696e 6469 6365 732c 2073  urn (*indices, s
-00008240: 656c 6629 2c0a 0a20 2020 2064 6566 205f  elf),..    def _
-00008250: 6e6f 6465 2873 656c 662c 2063 6163 6865  node(self, cache
-00008260: 2c20 7375 6267 7261 7068 2c20 7469 6d65  , subgraph, time
-00008270: 7329 3a0a 2020 2020 2020 2020 6966 2073  s):.        if s
-00008280: 656c 6620 696e 2063 6163 6865 3a0a 2020  elf in cache:.  
-00008290: 2020 2020 2020 2020 2020 7265 7475 726e            return
-000082a0: 2063 6163 6865 5b73 656c 665d 0a20 2020   cache[self].   
-000082b0: 2020 2020 2061 7267 7320 3d20 7475 706c       args = tupl
-000082c0: 6528 6172 672e 5f6e 6f64 6528 6361 6368  e(arg._node(cach
-000082d0: 652c 2073 7562 6772 6170 682c 2074 696d  e, subgraph, tim
-000082e0: 6573 2920 666f 7220 6172 6720 696e 2073  es) for arg in s
-000082f0: 656c 662e 5f45 7661 6c75 6162 6c65 5f5f  elf._Evaluable__
-00008300: 6172 6773 290a 2020 2020 2020 2020 626f  args).        bo
-00008310: 756e 6473 203d 2027 5b7b 7d2c 7b7d 5d27  unds = '[{},{}]'
-00008320: 2e66 6f72 6d61 7428 2a73 656c 662e 5f69  .format(*self._i
-00008330: 6e74 626f 756e 6473 2920 6966 2073 656c  ntbounds) if sel
-00008340: 662e 6474 7970 6520 3d3d 2069 6e74 2065  f.dtype == int e
-00008350: 6c73 6520 4e6f 6e65 0a20 2020 2020 2020  lse None.       
-00008360: 206c 6162 656c 203d 2027 5c6e 272e 6a6f   label = '\n'.jo
-00008370: 696e 2866 696c 7465 7228 4e6f 6e65 2c20  in(filter(None, 
-00008380: 2874 7970 6528 7365 6c66 292e 5f5f 6e61  (type(self).__na
-00008390: 6d65 5f5f 2c20 7365 6c66 2e5f 6e6f 6465  me__, self._node
-000083a0: 5f64 6574 6169 6c73 2c20 7365 6c66 2e5f  _details, self._
-000083b0: 7368 6170 655f 7374 7228 666f 726d 3d72  shape_str(form=r
-000083c0: 6570 7229 2c20 626f 756e 6473 2929 290a  epr), bounds))).
-000083d0: 2020 2020 2020 2020 6361 6368 655b 7365          cache[se
-000083e0: 6c66 5d20 3d20 6e6f 6465 203d 2052 6567  lf] = node = Reg
-000083f0: 756c 6172 4e6f 6465 286c 6162 656c 2c20  ularNode(label, 
-00008400: 6172 6773 2c20 7b7d 2c20 2874 7970 6528  args, {}, (type(
-00008410: 7365 6c66 292e 5f5f 6e61 6d65 5f5f 2c20  self).__name__, 
-00008420: 7469 6d65 735b 7365 6c66 5d29 2c20 7375  times[self]), su
-00008430: 6267 7261 7068 290a 2020 2020 2020 2020  bgraph).        
-00008440: 7265 7475 726e 206e 6f64 650a 0a20 2020  return node..   
-00008450: 2023 2073 696d 706c 6966 6963 6174 696f   # simplificatio
-00008460: 6e73 0a20 2020 205f 6d75 6c74 6970 6c79  ns.    _multiply
-00008470: 203d 206c 616d 6264 6120 7365 6c66 2c20   = lambda self, 
-00008480: 6f74 6865 723a 204e 6f6e 650a 2020 2020  other: None.    
-00008490: 5f74 7261 6e73 706f 7365 203d 206c 616d  _transpose = lam
-000084a0: 6264 6120 7365 6c66 2c20 6178 6573 3a20  bda self, axes: 
-000084b0: 4e6f 6e65 0a20 2020 205f 696e 7365 7274  None.    _insert
-000084c0: 6178 6973 203d 206c 616d 6264 6120 7365  axis = lambda se
-000084d0: 6c66 2c20 6178 6973 2c20 6c65 6e67 7468  lf, axis, length
-000084e0: 3a20 4e6f 6e65 0a20 2020 205f 706f 7765  : None.    _powe
-000084f0: 7220 3d20 6c61 6d62 6461 2073 656c 662c  r = lambda self,
-00008500: 206e 3a20 4e6f 6e65 0a20 2020 205f 6164   n: None.    _ad
-00008510: 6420 3d20 6c61 6d62 6461 2073 656c 662c  d = lambda self,
-00008520: 206f 7468 6572 3a20 4e6f 6e65 0a20 2020   other: None.   
-00008530: 205f 7375 6d20 3d20 6c61 6d62 6461 2073   _sum = lambda s
-00008540: 656c 662c 2061 7869 733a 204e 6f6e 650a  elf, axis: None.
-00008550: 2020 2020 5f74 616b 6520 3d20 6c61 6d62      _take = lamb
-00008560: 6461 2073 656c 662c 2069 6e64 6578 2c20  da self, index, 
-00008570: 6178 6973 3a20 4e6f 6e65 0a20 2020 205f  axis: None.    _
-00008580: 7274 616b 6520 3d20 6c61 6d62 6461 2073  rtake = lambda s
-00008590: 656c 662c 2069 6e64 6578 2c20 6178 6973  elf, index, axis
-000085a0: 3a20 4e6f 6e65 0a20 2020 205f 6465 7465  : None.    _dete
-000085b0: 726d 696e 616e 7420 3d20 6c61 6d62 6461  rminant = lambda
-000085c0: 2073 656c 662c 2061 7869 7331 2c20 6178   self, axis1, ax
-000085d0: 6973 323a 204e 6f6e 650a 2020 2020 5f69  is2: None.    _i
-000085e0: 6e76 6572 7365 203d 206c 616d 6264 6120  nverse = lambda 
-000085f0: 7365 6c66 2c20 6178 6973 312c 2061 7869  self, axis1, axi
-00008600: 7332 3a20 4e6f 6e65 0a20 2020 205f 7461  s2: None.    _ta
-00008610: 6b65 6469 6167 203d 206c 616d 6264 6120  kediag = lambda 
-00008620: 7365 6c66 2c20 6178 6973 312c 2061 7869  self, axis1, axi
-00008630: 7332 3a20 4e6f 6e65 0a20 2020 205f 6469  s2: None.    _di
-00008640: 6167 6f6e 616c 697a 6520 3d20 6c61 6d62  agonalize = lamb
-00008650: 6461 2073 656c 662c 2061 7869 733a 204e  da self, axis: N
-00008660: 6f6e 650a 2020 2020 5f70 726f 6475 6374  one.    _product
-00008670: 203d 206c 616d 6264 6120 7365 6c66 3a20   = lambda self: 
-00008680: 4e6f 6e65 0a20 2020 205f 7369 676e 203d  None.    _sign =
-00008690: 206c 616d 6264 6120 7365 6c66 3a20 4e6f   lambda self: No
-000086a0: 6e65 0a20 2020 205f 6569 6720 3d20 6c61  ne.    _eig = la
-000086b0: 6d62 6461 2073 656c 662c 2073 796d 6d65  mbda self, symme
-000086c0: 7472 6963 3a20 4e6f 6e65 0a20 2020 205f  tric: None.    _
-000086d0: 696e 666c 6174 6520 3d20 6c61 6d62 6461  inflate = lambda
-000086e0: 2073 656c 662c 2064 6f66 6d61 702c 206c   self, dofmap, l
-000086f0: 656e 6774 682c 2061 7869 733a 204e 6f6e  ength, axis: Non
-00008700: 650a 2020 2020 5f72 696e 666c 6174 6520  e.    _rinflate 
-00008710: 3d20 6c61 6d62 6461 2073 656c 662c 2066  = lambda self, f
-00008720: 756e 632c 206c 656e 6774 682c 2061 7869  unc, length, axi
-00008730: 733a 204e 6f6e 650a 2020 2020 5f75 6e72  s: None.    _unr
-00008740: 6176 656c 203d 206c 616d 6264 6120 7365  avel = lambda se
-00008750: 6c66 2c20 6178 6973 2c20 7368 6170 653a  lf, axis, shape:
-00008760: 204e 6f6e 650a 2020 2020 5f72 6176 656c   None.    _ravel
-00008770: 203d 206c 616d 6264 6120 7365 6c66 2c20   = lambda self, 
-00008780: 6178 6973 3a20 4e6f 6e65 0a20 2020 205f  axis: None.    _
-00008790: 6c6f 6f70 7375 6d20 3d20 6c61 6d62 6461  loopsum = lambda
-000087a0: 2073 656c 662c 206c 6f6f 705f 696e 6465   self, loop_inde
-000087b0: 783a 204e 6f6e 6520 2023 204e 4f54 453a  x: None  # NOTE:
-000087c0: 2074 7970 6520 6f66 2060 6c6f 6f70 5f69   type of `loop_i
-000087d0: 6e64 6578 6020 6973 2060 5f4c 6f6f 7049  ndex` is `_LoopI
-000087e0: 6e64 6578 600a 2020 2020 5f72 6561 6c20  ndex`.    _real 
-000087f0: 3d20 6c61 6d62 6461 2073 656c 663a 204e  = lambda self: N
-00008800: 6f6e 650a 2020 2020 5f69 6d61 6720 3d20  one.    _imag = 
-00008810: 6c61 6d62 6461 2073 656c 663a 204e 6f6e  lambda self: Non
-00008820: 650a 2020 2020 5f63 6f6e 6a75 6761 7465  e.    _conjugate
-00008830: 203d 206c 616d 6264 6120 7365 6c66 3a20   = lambda self: 
-00008840: 4e6f 6e65 0a0a 2020 2020 4070 726f 7065  None..    @prope
-00008850: 7274 790a 2020 2020 6465 6620 5f75 6e61  rty.    def _una
-00008860: 6c69 676e 6564 2873 656c 6629 3a0a 2020  ligned(self):.  
-00008870: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00008880: 662c 2074 7570 6c65 2872 616e 6765 2873  f, tuple(range(s
-00008890: 656c 662e 6e64 696d 2929 0a0a 2020 2020  elf.ndim))..    
-000088a0: 5f64 6961 676f 6e61 6c73 203d 2028 290a  _diagonals = ().
-000088b0: 2020 2020 5f69 6e66 6c61 7469 6f6e 7320      _inflations 
-000088c0: 3d20 2829 0a0a 2020 2020 6465 6620 5f64  = ()..    def _d
-000088d0: 6572 6976 6174 6976 6528 7365 6c66 2c20  erivative(self, 
-000088e0: 7661 722c 2073 6565 6e29 3a0a 2020 2020  var, seen):.    
-000088f0: 2020 2020 6966 2073 656c 662e 6474 7970      if self.dtyp
-00008900: 6520 696e 2028 626f 6f6c 2c20 696e 7429  e in (bool, int)
-00008910: 206f 7220 7661 7220 6e6f 7420 696e 2073   or var not in s
-00008920: 656c 662e 6465 7065 6e64 656e 6369 6573  elf.dependencies
-00008930: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00008940: 7475 726e 205a 6572 6f73 2873 656c 662e  turn Zeros(self.
-00008950: 7368 6170 6520 2b20 7661 722e 7368 6170  shape + var.shap
-00008960: 652c 2064 7479 7065 3d73 656c 662e 6474  e, dtype=self.dt
-00008970: 7970 6529 0a20 2020 2020 2020 2072 6169  ype).        rai
-00008980: 7365 204e 6f74 496d 706c 656d 656e 7465  se NotImplemente
-00008990: 6445 7272 6f72 2827 6465 7269 7661 7469  dError('derivati
-000089a0: 7665 206e 6f74 2064 6566 696e 6564 2066  ve not defined f
-000089b0: 6f72 207b 7d27 2e66 6f72 6d61 7428 7365  or {}'.format(se
-000089c0: 6c66 2e5f 5f63 6c61 7373 5f5f 2e5f 5f6e  lf.__class__.__n
-000089d0: 616d 655f 5f29 290a 0a20 2020 2040 7072  ame__))..    @pr
-000089e0: 6f70 6572 7479 0a20 2020 2064 6566 2061  operty.    def a
-000089f0: 735f 6576 616c 7561 626c 655f 6172 7261  s_evaluable_arra
-00008a00: 7928 7365 6c66 293a 0a20 2020 2020 2020  y(self):.       
-00008a10: 2027 7265 7475 726e 2073 656c 6627 0a0a   'return self'..
-00008a20: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00008a30: 656c 660a 0a20 2020 2040 7072 6f70 6572  elf..    @proper
-00008a40: 7479 0a20 2020 2064 6566 205f 696e 7462  ty.    def _intb
-00008a50: 6f75 6e64 7328 7365 6c66 293a 0a20 2020  ounds(self):.   
-00008a60: 2020 2020 2023 2069 6e63 6c75 7369 7665       # inclusive
-00008a70: 206c 6f77 6572 2061 6e64 2075 7070 6572   lower and upper
-00008a80: 2062 6f75 6e64 730a 2020 2020 2020 2020   bounds.        
-00008a90: 6966 2073 656c 662e 6e64 696d 203d 3d20  if self.ndim == 
-00008aa0: 3020 616e 6420 7365 6c66 2e64 7479 7065  0 and self.dtype
-00008ab0: 203d 3d20 696e 7420 616e 6420 7365 6c66   == int and self
-00008ac0: 2e69 7363 6f6e 7374 616e 743a 0a20 2020  .isconstant:.   
-00008ad0: 2020 2020 2020 2020 2076 616c 7565 203d           value =
-00008ae0: 2073 656c 662e 5f5f 696e 6465 785f 5f28   self.__index__(
-00008af0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
-00008b00: 7475 726e 2076 616c 7565 2c20 7661 6c75  turn value, valu
-00008b10: 650a 2020 2020 2020 2020 656c 7365 3a0a  e.        else:.
-00008b20: 2020 2020 2020 2020 2020 2020 6c6f 7765              lowe
-00008b30: 722c 2075 7070 6572 203d 2073 656c 662e  r, upper = self.
-00008b40: 5f69 6e74 626f 756e 6473 5f69 6d70 6c28  _intbounds_impl(
-00008b50: 290a 2020 2020 2020 2020 2020 2020 6173  ).            as
-00008b60: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
-00008b70: 6c6f 7765 722c 2069 6e74 2920 6f72 206c  lower, int) or l
-00008b80: 6f77 6572 203d 3d20 666c 6f61 7428 272d  ower == float('-
-00008b90: 696e 6627 2920 6f72 206c 6f77 6572 203d  inf') or lower =
-00008ba0: 3d20 666c 6f61 7428 2769 6e66 2729 0a20  = float('inf'). 
-00008bb0: 2020 2020 2020 2020 2020 2061 7373 6572             asser
-00008bc0: 7420 6973 696e 7374 616e 6365 2875 7070  t isinstance(upp
-00008bd0: 6572 2c20 696e 7429 206f 7220 7570 7065  er, int) or uppe
-00008be0: 7220 3d3d 2066 6c6f 6174 2827 2d69 6e66  r == float('-inf
-00008bf0: 2729 206f 7220 7570 7065 7220 3d3d 2066  ') or upper == f
-00008c00: 6c6f 6174 2827 696e 6627 290a 2020 2020  loat('inf').    
-00008c10: 2020 2020 2020 2020 6173 7365 7274 206c          assert l
-00008c20: 6f77 6572 203c 3d20 7570 7065 720a 2020  ower <= upper.  
-00008c30: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00008c40: 206c 6f77 6572 2c20 7570 7065 720a 0a20   lower, upper.. 
-00008c50: 2020 2064 6566 205f 696e 7462 6f75 6e64     def _intbound
-00008c60: 735f 696d 706c 2873 656c 6629 3a0a 2020  s_impl(self):.  
-00008c70: 2020 2020 2020 7265 7475 726e 2066 6c6f        return flo
-00008c80: 6174 2827 2d69 6e66 2729 2c20 666c 6f61  at('-inf'), floa
-00008c90: 7428 2769 6e66 2729 0a0a 2020 2020 4070  t('inf')..    @p
-00008ca0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00008cb0: 5f63 6f6e 7374 5f75 6e69 666f 726d 2873  _const_uniform(s
-00008cc0: 656c 6629 3a0a 2020 2020 2020 2020 6966  elf):.        if
-00008cd0: 2073 656c 662e 6474 7970 6520 3d3d 2069   self.dtype == i
-00008ce0: 6e74 3a0a 2020 2020 2020 2020 2020 2020  nt:.            
-00008cf0: 6c6f 7765 722c 2075 7070 6572 203d 2073  lower, upper = s
-00008d00: 656c 662e 5f69 6e74 626f 756e 6473 0a20  elf._intbounds. 
-00008d10: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00008d20: 6e20 6c6f 7765 7220 6966 206c 6f77 6572  n lower if lower
-00008d30: 203d 3d20 7570 7065 7220 656c 7365 204e   == upper else N
-00008d40: 6f6e 650a 0a0a 636c 6173 7320 4e50 6f69  one...class NPoi
-00008d50: 6e74 7328 4172 7261 7929 3a0a 2020 2020  nts(Array):.    
-00008d60: 2754 6865 206c 656e 6774 6820 6f66 2074  'The length of t
-00008d70: 6865 2070 6f69 6e74 7320 6178 6973 2e27  he points axis.'
-00008d80: 0a0a 2020 2020 5f5f 736c 6f74 735f 5f20  ..    __slots__ 
-00008d90: 3d20 2829 0a0a 2020 2020 6465 6620 5f5f  = ()..    def __
-00008da0: 696e 6974 5f5f 2873 656c 6629 3a0a 2020  init__(self):.  
-00008db0: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
-00008dc0: 696e 6974 5f5f 2861 7267 733d 5b45 5641  init__(args=[EVA
-00008dd0: 4c41 5247 535d 2c20 7368 6170 653d 2829  LARGS], shape=()
-00008de0: 2c20 6474 7970 653d 696e 7429 0a0a 2020  , dtype=int)..  
-00008df0: 2020 6465 6620 6576 616c 6628 7365 6c66    def evalf(self
-00008e00: 2c20 6576 616c 6172 6773 293a 0a20 2020  , evalargs):.   
-00008e10: 2020 2020 2070 6f69 6e74 7320 3d20 6576       points = ev
-00008e20: 616c 6172 6773 5b27 5f70 6f69 6e74 7327  alargs['_points'
-00008e30: 5d2e 636f 6f72 6473 0a20 2020 2020 2020  ].coords.       
-00008e40: 2072 6574 7572 6e20 7479 7065 732e 6672   return types.fr
-00008e50: 6f7a 656e 6172 7261 7928 706f 696e 7473  ozenarray(points
-00008e60: 2e73 6861 7065 5b30 5d29 0a0a 2020 2020  .shape[0])..    
-00008e70: 6465 6620 5f69 6e74 626f 756e 6473 5f69  def _intbounds_i
-00008e80: 6d70 6c28 7365 6c66 293a 0a20 2020 2020  mpl(self):.     
-00008e90: 2020 2072 6574 7572 6e20 302c 2066 6c6f     return 0, flo
-00008ea0: 6174 2827 696e 6627 290a 0a0a 636c 6173  at('inf')...clas
-00008eb0: 7320 506f 696e 7473 2841 7272 6179 293a  s Points(Array):
-00008ec0: 0a0a 2020 2020 5f5f 736c 6f74 735f 5f20  ..    __slots__ 
-00008ed0: 3d20 2829 0a0a 2020 2020 6465 6620 5f5f  = ()..    def __
-00008ee0: 696e 6974 5f5f 2873 656c 662c 206e 706f  init__(self, npo
-00008ef0: 696e 7473 2c20 6e64 696d 293a 0a20 2020  ints, ndim):.   
-00008f00: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
-00008f10: 6e69 745f 5f28 6172 6773 3d5b 4556 414c  nit__(args=[EVAL
-00008f20: 4152 4753 5d2c 2073 6861 7065 3d28 6e70  ARGS], shape=(np
-00008f30: 6f69 6e74 732c 206e 6469 6d29 2c20 6474  oints, ndim), dt
-00008f40: 7970 653d 666c 6f61 7429 0a0a 2020 2020  ype=float)..    
-00008f50: 6465 6620 6576 616c 6628 7365 6c66 2c20  def evalf(self, 
-00008f60: 6576 616c 6172 6773 293a 0a20 2020 2020  evalargs):.     
-00008f70: 2020 2072 6574 7572 6e20 6576 616c 6172     return evalar
-00008f80: 6773 5b27 5f70 6f69 6e74 7327 5d2e 636f  gs['_points'].co
-00008f90: 6f72 6473 0a0a 0a63 6c61 7373 2057 6569  ords...class Wei
-00008fa0: 6768 7473 2841 7272 6179 293a 0a0a 2020  ghts(Array):..  
-00008fb0: 2020 5f5f 736c 6f74 735f 5f20 3d20 2829    __slots__ = ()
-00008fc0: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
-00008fd0: 5f5f 2873 656c 662c 206e 706f 696e 7473  __(self, npoints
-00008fe0: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
-00008ff0: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
-00009000: 3d5b 4556 414c 4152 4753 5d2c 2073 6861  =[EVALARGS], sha
-00009010: 7065 3d28 6e70 6f69 6e74 732c 292c 2064  pe=(npoints,), d
-00009020: 7479 7065 3d66 6c6f 6174 290a 0a20 2020  type=float)..   
-00009030: 2064 6566 2065 7661 6c66 2873 656c 662c   def evalf(self,
-00009040: 2065 7661 6c61 7267 7329 3a0a 2020 2020   evalargs):.    
-00009050: 2020 2020 7765 6967 6874 7320 3d20 6576      weights = ev
-00009060: 616c 6172 6773 5b27 5f70 6f69 6e74 7327  alargs['_points'
-00009070: 5d2e 7765 6967 6874 730a 2020 2020 2020  ].weights.      
-00009080: 2020 6173 7365 7274 206e 756d 6572 6963    assert numeric
-00009090: 2e69 7361 7272 6179 2877 6569 6768 7473  .isarray(weights
-000090a0: 2920 616e 6420 7765 6967 6874 732e 6e64  ) and weights.nd
-000090b0: 696d 203d 3d20 310a 2020 2020 2020 2020  im == 1.        
-000090c0: 7265 7475 726e 2077 6569 6768 7473 0a0a  return weights..
-000090d0: 0a63 6c61 7373 204e 6f72 6d61 6c28 4172  .class Normal(Ar
-000090e0: 7261 7929 3a0a 2020 2020 276e 6f72 6d61  ray):.    'norma
-000090f0: 6c27 0a0a 2020 2020 5f5f 736c 6f74 735f  l'..    __slots_
-00009100: 5f20 3d20 276c 6772 6164 272c 0a0a 2020  _ = 'lgrad',..  
-00009110: 2020 4074 7970 6573 2e61 7070 6c79 5f61    @types.apply_a
-00009120: 6e6e 6f74 6174 696f 6e73 0a20 2020 2064  nnotations.    d
-00009130: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
-00009140: 2c20 6c67 7261 643a 2061 7361 7272 6179  , lgrad: asarray
-00009150: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
-00009160: 7420 6c67 7261 642e 6e64 696d 203e 3d20  t lgrad.ndim >= 
-00009170: 3220 616e 6420 6571 7561 6c69 6e64 6578  2 and equalindex
-00009180: 286c 6772 6164 2e73 6861 7065 5b2d 325d  (lgrad.shape[-2]
-00009190: 2c20 6c67 7261 642e 7368 6170 655b 2d31  , lgrad.shape[-1
-000091a0: 5d29 0a20 2020 2020 2020 2061 7373 6572  ]).        asser
-000091b0: 7420 6c67 7261 642e 6474 7970 6520 213d  t lgrad.dtype !=
-000091c0: 2063 6f6d 706c 6578 0a20 2020 2020 2020   complex.       
-000091d0: 2073 656c 662e 6c67 7261 6420 3d20 6c67   self.lgrad = lg
-000091e0: 7261 640a 2020 2020 2020 2020 7375 7065  rad.        supe
-000091f0: 7228 292e 5f5f 696e 6974 5f5f 2861 7267  r().__init__(arg
-00009200: 733d 5b6c 6772 6164 5d2c 2073 6861 7065  s=[lgrad], shape
-00009210: 3d6c 6772 6164 2e73 6861 7065 5b3a 2d31  =lgrad.shape[:-1
-00009220: 5d2c 2064 7479 7065 3d66 6c6f 6174 290a  ], dtype=float).
-00009230: 0a20 2020 2064 6566 205f 7369 6d70 6c69  .    def _simpli
-00009240: 6669 6564 2873 656c 6629 3a0a 2020 2020  fied(self):.    
-00009250: 2020 2020 6966 2065 7175 616c 696e 6465      if equalinde
-00009260: 7828 7365 6c66 2e73 6861 7065 5b2d 315d  x(self.shape[-1]
-00009270: 2c20 3129 3a0a 2020 2020 2020 2020 2020  , 1):.          
-00009280: 2020 7265 7475 726e 2053 6967 6e28 5461    return Sign(Ta
-00009290: 6b65 2873 656c 662e 6c67 7261 642c 2030  ke(self.lgrad, 0
-000092a0: 2929 0a20 2020 2020 2020 2075 6e61 6c69  )).        unali
-000092b0: 676e 6564 2c20 7768 6572 6520 3d20 756e  gned, where = un
-000092c0: 616c 6967 6e28 7365 6c66 2e6c 6772 6164  align(self.lgrad
-000092d0: 290a 2020 2020 2020 2020 666f 7220 6178  ).        for ax
-000092e0: 6973 2069 6e20 7365 6c66 2e6e 6469 6d20  is in self.ndim 
-000092f0: 2d20 312c 2073 656c 662e 6e64 696d 3a0a  - 1, self.ndim:.
-00009300: 2020 2020 2020 2020 2020 2020 6966 2061              if a
-00009310: 7869 7320 6e6f 7420 696e 2077 6865 7265  xis not in where
-00009320: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00009330: 2020 756e 616c 6967 6e65 6420 3d20 496e    unaligned = In
-00009340: 7365 7274 4178 6973 2875 6e61 6c69 676e  sertAxis(unalign
-00009350: 6564 2c20 7365 6c66 2e6c 6772 6164 2e73  ed, self.lgrad.s
-00009360: 6861 7065 5b61 7869 735d 290a 2020 2020  hape[axis]).    
-00009370: 2020 2020 2020 2020 2020 2020 7768 6572              wher
-00009380: 6520 2b3d 2061 7869 732c 0a20 2020 2020  e += axis,.     
-00009390: 2020 2069 6620 6c65 6e28 7768 6572 6529     if len(where)
-000093a0: 203c 2073 656c 662e 6e64 696d 202b 2031   < self.ndim + 1
-000093b0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-000093c0: 2077 6865 7265 5b2d 323a 5d20 213d 2028   where[-2:] != (
-000093d0: 7365 6c66 2e6e 6469 6d20 2d20 312c 2073  self.ndim - 1, s
-000093e0: 656c 662e 6e64 696d 293a 0a20 2020 2020  elf.ndim):.     
-000093f0: 2020 2020 2020 2020 2020 2075 6e61 6c69             unali
-00009400: 676e 6564 203d 2054 7261 6e73 706f 7365  gned = Transpose
-00009410: 2875 6e61 6c69 676e 6564 2c20 6e75 6d70  (unaligned, nump
-00009420: 792e 6172 6773 6f72 7428 7768 6572 6529  y.argsort(where)
-00009430: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00009440: 2020 7768 6572 6520 3d20 7475 706c 6528    where = tuple(
-00009450: 736f 7274 6564 2877 6865 7265 2929 0a20  sorted(where)). 
-00009460: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00009470: 6e20 616c 6967 6e28 4e6f 726d 616c 2875  n align(Normal(u
-00009480: 6e61 6c69 676e 6564 292c 2077 6865 7265  naligned), where
-00009490: 5b3a 2d31 5d2c 2073 656c 662e 7368 6170  [:-1], self.shap
-000094a0: 6529 0a0a 2020 2020 6465 6620 6576 616c  e)..    def eval
-000094b0: 6628 7365 6c66 2c20 6c67 7261 6429 3a0a  f(self, lgrad):.
-000094c0: 2020 2020 2020 2020 6e20 3d20 6c67 7261          n = lgra
-000094d0: 645b 2e2e 2e2c 202d 315d 0a20 2020 2020  d[..., -1].     
-000094e0: 2020 2023 206f 7274 686f 6e6f 726d 616c     # orthonormal
-000094f0: 697a 6520 6e20 746f 2047 0a20 2020 2020  ize n to G.     
-00009500: 2020 2047 203d 206c 6772 6164 5b2e 2e2e     G = lgrad[...
-00009510: 2c20 3a2d 315d 0a20 2020 2020 2020 2047  , :-1].        G
-00009520: 4720 3d20 6e75 6d70 792e 6569 6e73 756d  G = numpy.einsum
-00009530: 2827 2e2e 2e6b 692c 2e2e 2e6b 6a2d 3e2e  ('...ki,...kj->.
-00009540: 2e2e 696a 272c 2047 2c20 4729 0a20 2020  ..ij', G, G).   
-00009550: 2020 2020 2076 3120 3d20 6e75 6d70 792e       v1 = numpy.
-00009560: 6569 6e73 756d 2827 2e2e 2e69 6a2c 2e2e  einsum('...ij,..
-00009570: 2e69 2d3e 2e2e 2e6a 272c 2047 2c20 6e29  .i->...j', G, n)
-00009580: 0a20 2020 2020 2020 2076 3220 3d20 6e75  .        v2 = nu
-00009590: 6d70 792e 6c69 6e61 6c67 2e73 6f6c 7665  mpy.linalg.solve
-000095a0: 2847 472c 2076 3129 0a20 2020 2020 2020  (GG, v1).       
-000095b0: 2076 3320 3d20 6e75 6d70 792e 6569 6e73   v3 = numpy.eins
-000095c0: 756d 2827 2e2e 2e69 6a2c 2e2e 2e6a 2d3e  um('...ij,...j->
-000095d0: 2e2e 2e69 272c 2047 2c20 7632 290a 2020  ...i', G, v2).  
-000095e0: 2020 2020 2020 7265 7475 726e 206e 756d        return num
-000095f0: 6572 6963 2e6e 6f72 6d61 6c69 7a65 286e  eric.normalize(n
-00009600: 202d 2076 3329 0a0a 2020 2020 6465 6620   - v3)..    def 
-00009610: 5f64 6572 6976 6174 6976 6528 7365 6c66  _derivative(self
-00009620: 2c20 7661 722c 2073 6565 6e29 3a0a 2020  , var, seen):.  
-00009630: 2020 2020 2020 6966 2065 7175 616c 696e        if equalin
-00009640: 6465 7828 7365 6c66 2e73 6861 7065 5b2d  dex(self.shape[-
-00009650: 315d 2c20 3129 3a0a 2020 2020 2020 2020  1], 1):.        
-00009660: 2020 2020 7265 7475 726e 207a 6572 6f73      return zeros
-00009670: 2873 656c 662e 7368 6170 6520 2b20 7661  (self.shape + va
-00009680: 722e 7368 6170 6529 0a20 2020 2020 2020  r.shape).       
-00009690: 2047 203d 2073 656c 662e 6c67 7261 645b   G = self.lgrad[
-000096a0: 2e2e 2e2c 203a 2d31 5d0a 2020 2020 2020  ..., :-1].      
-000096b0: 2020 696e 7647 4720 3d20 696e 7665 7273    invGG = invers
-000096c0: 6528 6569 6e73 756d 2827 416b 692c 416b  e(einsum('Aki,Ak
-000096d0: 6a2d 3e41 696a 272c 2047 2c20 4729 290a  j->Aij', G, G)).
-000096e0: 2020 2020 2020 2020 7265 7475 726e 202d          return -
-000096f0: 6569 6e73 756d 2827 4169 6c2c 416c 6a2c  einsum('Ail,Alj,
-00009700: 416b 2c41 6b6a 422d 3e41 6942 272c 2047  Ak,AkjB->AiB', G
-00009710: 2c20 696e 7647 472c 2073 656c 662c 2064  , invGG, self, d
-00009720: 6572 6976 6174 6976 6528 472c 2076 6172  erivative(G, var
-00009730: 2c20 7365 656e 2929 0a0a 0a63 6c61 7373  , seen))...class
-00009740: 2043 6f6e 7374 616e 7428 4172 7261 7929   Constant(Array)
-00009750: 3a0a 0a20 2020 205f 5f73 6c6f 7473 5f5f  :..    __slots__
-00009760: 203d 2027 7661 6c75 6527 2c0a 2020 2020   = 'value',.    
-00009770: 5f5f 6361 6368 655f 5f20 3d20 275f 6973  __cache__ = '_is
-00009780: 756e 6974 270a 0a20 2020 2040 7479 7065  unit'..    @type
-00009790: 732e 6170 706c 795f 616e 6e6f 7461 7469  s.apply_annotati
-000097a0: 6f6e 730a 2020 2020 6465 6620 5f5f 696e  ons.    def __in
-000097b0: 6974 5f5f 2873 656c 662c 2076 616c 7565  it__(self, value
-000097c0: 3a20 7479 7065 732e 6172 7261 7964 6174  : types.arraydat
-000097d0: 6129 3a0a 2020 2020 2020 2020 7365 6c66  a):.        self
-000097e0: 2e76 616c 7565 203d 206e 756d 7079 2e61  .value = numpy.a
-000097f0: 7361 7272 6179 2876 616c 7565 290a 2020  sarray(value).  
-00009800: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
-00009810: 696e 6974 5f5f 2861 7267 733d 5b5d 2c20  init__(args=[], 
-00009820: 7368 6170 653d 7661 6c75 652e 7368 6170  shape=value.shap
-00009830: 652c 2064 7479 7065 3d76 616c 7565 2e64  e, dtype=value.d
-00009840: 7479 7065 290a 0a20 2020 2064 6566 205f  type)..    def _
-00009850: 7369 6d70 6c69 6669 6564 2873 656c 6629  simplified(self)
-00009860: 3a0a 2020 2020 2020 2020 6966 206e 6f74  :.        if not
-00009870: 2073 656c 662e 7661 6c75 652e 616e 7928   self.value.any(
-00009880: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-00009890: 6574 7572 6e20 7a65 726f 735f 6c69 6b65  eturn zeros_like
-000098a0: 2873 656c 6629 0a20 2020 2020 2020 2066  (self).        f
-000098b0: 6f72 2069 2c20 7368 2069 6e20 656e 756d  or i, sh in enum
-000098c0: 6572 6174 6528 7365 6c66 2e73 6861 7065  erate(self.shape
-000098d0: 293a 0a20 2020 2020 2020 2020 2020 2023  ):.            #
-000098e0: 2046 696e 6420 616e 6420 7265 706c 6163   Find and replac
-000098f0: 6520 696e 7661 7269 616e 7420 6178 6573  e invariant axes
-00009900: 2077 6974 6820 496e 7365 7274 4178 6973   with InsertAxis
-00009910: 2e20 5369 6e63 6520 6073 656c 662e 7661  . Since `self.va
-00009920: 6c75 652e 616e 7928 2960 0a20 2020 2020  lue.any()`.     
-00009930: 2020 2020 2020 2023 2069 7320 4661 6c73         # is Fals
-00009940: 6520 666f 7220 6172 7261 7973 2077 6974  e for arrays wit
-00009950: 6820 6120 7a65 726f 2d6c 656e 6774 6820  h a zero-length 
-00009960: 6178 6973 2c20 7765 2063 616e 2061 7272  axis, we can arr
-00009970: 6976 6520 6865 7265 206f 6e6c 7920 6966  ive here only if
-00009980: 2061 6c6c 0a20 2020 2020 2020 2020 2020   all.           
-00009990: 2023 2061 7865 7320 6861 7665 2061 7420   # axes have at 
-000099a0: 6c65 6173 7420 6c65 6e67 7468 206f 6e65  least length one
-000099b0: 2c20 6865 6e63 6520 7468 6520 666f 6c6c  , hence the foll
-000099c0: 6f77 696e 6720 7374 6174 656d 656e 7420  owing statement 
-000099d0: 7368 6f75 6c64 2077 6f72 6b2e 0a20 2020  should work..   
-000099e0: 2020 2020 2020 2020 2066 6972 7374 2c20           first, 
-000099f0: 2a6f 7468 6572 7320 3d20 6e75 6d70 792e  *others = numpy.
-00009a00: 726f 6c6c 6178 6973 2873 656c 662e 7661  rollaxis(self.va
-00009a10: 6c75 652c 2069 290a 2020 2020 2020 2020  lue, i).        
-00009a20: 2020 2020 6966 2061 6c6c 286e 756d 7079      if all(numpy
-00009a30: 2e65 7175 616c 2866 6972 7374 2c20 6f74  .equal(first, ot
-00009a40: 6865 7229 2e61 6c6c 2829 2066 6f72 206f  her).all() for o
-00009a50: 7468 6572 2069 6e20 6f74 6865 7273 293a  ther in others):
-00009a60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009a70: 2072 6574 7572 6e20 696e 7365 7274 6178   return insertax
-00009a80: 6973 2843 6f6e 7374 616e 7428 6669 7273  is(Constant(firs
-00009a90: 7429 2c20 692c 2073 6829 0a0a 2020 2020  t), i, sh)..    
-00009aa0: 6465 6620 6576 616c 6628 7365 6c66 293a  def evalf(self):
-00009ab0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00009ac0: 7365 6c66 2e76 616c 7565 0a0a 2020 2020  self.value..    
-00009ad0: 6465 6620 5f6e 6f64 6528 7365 6c66 2c20  def _node(self, 
-00009ae0: 6361 6368 652c 2073 7562 6772 6170 682c  cache, subgraph,
-00009af0: 2074 696d 6573 293a 0a20 2020 2020 2020   times):.       
-00009b00: 2069 6620 7365 6c66 2e6e 6469 6d3a 0a20   if self.ndim:. 
-00009b10: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00009b20: 6e20 7375 7065 7228 292e 5f6e 6f64 6528  n super()._node(
-00009b30: 6361 6368 652c 2073 7562 6772 6170 682c  cache, subgraph,
-00009b40: 2074 696d 6573 290a 2020 2020 2020 2020   times).        
-00009b50: 656c 6966 2073 656c 6620 696e 2063 6163  elif self in cac
-00009b60: 6865 3a0a 2020 2020 2020 2020 2020 2020  he:.            
-00009b70: 7265 7475 726e 2063 6163 6865 5b73 656c  return cache[sel
-00009b80: 665d 0a20 2020 2020 2020 2065 6c73 653a  f].        else:
-00009b90: 0a20 2020 2020 2020 2020 2020 206c 6162  .            lab
-00009ba0: 656c 203d 2027 7b7d 272e 666f 726d 6174  el = '{}'.format
-00009bb0: 2873 656c 662e 7661 6c75 655b 2829 5d29  (self.value[()])
-00009bc0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00009bd0: 6c65 6e28 6c61 6265 6c29 203e 2039 3a0a  len(label) > 9:.
-00009be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009bf0: 6c61 6265 6c20 3d20 277e 7b3a 2e32 657d  label = '~{:.2e}
-00009c00: 272e 666f 726d 6174 2873 656c 662e 7661  '.format(self.va
-00009c10: 6c75 655b 2829 5d29 0a20 2020 2020 2020  lue[()]).       
-00009c20: 2020 2020 2063 6163 6865 5b73 656c 665d       cache[self]
-00009c30: 203d 206e 6f64 6520 3d20 4475 706c 6963   = node = Duplic
-00009c40: 6174 6564 4c65 6166 4e6f 6465 286c 6162  atedLeafNode(lab
-00009c50: 656c 2c20 2874 7970 6528 7365 6c66 292e  el, (type(self).
-00009c60: 5f5f 6e61 6d65 5f5f 2c20 7469 6d65 735b  __name__, times[
-00009c70: 7365 6c66 5d29 290a 2020 2020 2020 2020  self])).        
-00009c80: 2020 2020 7265 7475 726e 206e 6f64 650a      return node.
-00009c90: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00009ca0: 2020 2064 6566 205f 6973 756e 6974 2873     def _isunit(s
-00009cb0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-00009cc0: 7475 726e 206e 756d 7079 2e65 7175 616c  turn numpy.equal
-00009cd0: 2873 656c 662e 7661 6c75 652c 2031 292e  (self.value, 1).
-00009ce0: 616c 6c28 290a 0a20 2020 2064 6566 205f  all()..    def _
-00009cf0: 7472 616e 7370 6f73 6528 7365 6c66 2c20  transpose(self, 
-00009d00: 6178 6573 293a 0a20 2020 2020 2020 2072  axes):.        r
-00009d10: 6574 7572 6e20 436f 6e73 7461 6e74 2873  eturn Constant(s
-00009d20: 656c 662e 7661 6c75 652e 7472 616e 7370  elf.value.transp
-00009d30: 6f73 6528 6178 6573 2929 0a0a 2020 2020  ose(axes))..    
-00009d40: 6465 6620 5f73 756d 2873 656c 662c 2061  def _sum(self, a
-00009d50: 7869 7329 3a0a 2020 2020 2020 2020 7265  xis):.        re
-00009d60: 7475 726e 2043 6f6e 7374 616e 7428 6e75  turn Constant(nu
-00009d70: 6d70 792e 7375 6d28 7365 6c66 2e76 616c  mpy.sum(self.val
-00009d80: 7565 2c20 6178 6973 2929 0a0a 2020 2020  ue, axis))..    
-00009d90: 6465 6620 5f61 6464 2873 656c 662c 206f  def _add(self, o
-00009da0: 7468 6572 293a 0a20 2020 2020 2020 2069  ther):.        i
-00009db0: 6620 6973 696e 7374 616e 6365 286f 7468  f isinstance(oth
-00009dc0: 6572 2c20 436f 6e73 7461 6e74 293a 0a20  er, Constant):. 
-00009dd0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00009de0: 6e20 436f 6e73 7461 6e74 286e 756d 7079  n Constant(numpy
-00009df0: 2e61 6464 2873 656c 662e 7661 6c75 652c  .add(self.value,
-00009e00: 206f 7468 6572 2e76 616c 7565 2929 0a0a   other.value))..
-00009e10: 2020 2020 6465 6620 5f69 6e76 6572 7365      def _inverse
-00009e20: 2873 656c 662c 2061 7869 7331 2c20 6178  (self, axis1, ax
-00009e30: 6973 3229 3a0a 2020 2020 2020 2020 7661  is2):.        va
-00009e40: 6c75 6520 3d20 6e75 6d70 792e 7472 616e  lue = numpy.tran
-00009e50: 7370 6f73 6528 7365 6c66 2e76 616c 7565  spose(self.value
-00009e60: 2c20 7475 706c 6528 6920 666f 7220 6920  , tuple(i for i 
-00009e70: 696e 2072 616e 6765 2873 656c 662e 6e64  in range(self.nd
-00009e80: 696d 2920 6966 2069 2021 3d20 6178 6973  im) if i != axis
-00009e90: 3120 616e 6420 6920 213d 2061 7869 7332  1 and i != axis2
-00009ea0: 2920 2b20 2861 7869 7331 2c20 6178 6973  ) + (axis1, axis
-00009eb0: 3229 290a 2020 2020 2020 2020 7265 7475  2)).        retu
-00009ec0: 726e 2043 6f6e 7374 616e 7428 6e75 6d70  rn Constant(nump
-00009ed0: 792e 6c69 6e61 6c67 2e69 6e76 2876 616c  y.linalg.inv(val
-00009ee0: 7565 2929 0a0a 2020 2020 6465 6620 5f70  ue))..    def _p
-00009ef0: 726f 6475 6374 2873 656c 6629 3a0a 2020  roduct(self):.  
-00009f00: 2020 2020 2020 7265 7475 726e 2043 6f6e        return Con
-00009f10: 7374 616e 7428 7365 6c66 2e76 616c 7565  stant(self.value
-00009f20: 2e70 726f 6428 2d31 2929 0a0a 2020 2020  .prod(-1))..    
-00009f30: 6465 6620 5f6d 756c 7469 706c 7928 7365  def _multiply(se
-00009f40: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-00009f50: 2020 2020 6966 2073 656c 662e 5f69 7375      if self._isu
-00009f60: 6e69 743a 0a20 2020 2020 2020 2020 2020  nit:.           
-00009f70: 2072 6574 7572 6e20 6f74 6865 720a 2020   return other.  
-00009f80: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-00009f90: 6e63 6528 6f74 6865 722c 2043 6f6e 7374  nce(other, Const
-00009fa0: 616e 7429 3a0a 2020 2020 2020 2020 2020  ant):.          
-00009fb0: 2020 7265 7475 726e 2043 6f6e 7374 616e    return Constan
-00009fc0: 7428 6e75 6d70 792e 6d75 6c74 6970 6c79  t(numpy.multiply
-00009fd0: 2873 656c 662e 7661 6c75 652c 206f 7468  (self.value, oth
-00009fe0: 6572 2e76 616c 7565 2929 0a0a 2020 2020  er.value))..    
-00009ff0: 6465 6620 5f74 616b 6564 6961 6728 7365  def _takediag(se
-0000a000: 6c66 2c20 6178 6973 312c 2061 7869 7332  lf, axis1, axis2
-0000a010: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
-0000a020: 7420 6178 6973 3120 3c20 6178 6973 320a  t axis1 < axis2.
-0000a030: 2020 2020 2020 2020 7265 7475 726e 2043          return C
-0000a040: 6f6e 7374 616e 7428 6e75 6d70 792e 6569  onstant(numpy.ei
-0000a050: 6e73 756d 2827 2e2e 2e6b 6b2d 3e2e 2e2e  nsum('...kk->...
-0000a060: 6b27 2c20 6e75 6d70 792e 7472 616e 7370  k', numpy.transp
-0000a070: 6f73 6528 7365 6c66 2e76 616c 7565 2c0a  ose(self.value,.
-0000a080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0c0: 2020 2020 6c69 7374 2872 616e 6765 2861      list(range(a
-0000a0d0: 7869 7331 2929 202b 206c 6973 7428 7261  xis1)) + list(ra
-0000a0e0: 6e67 6528 6178 6973 312b 312c 2061 7869  nge(axis1+1, axi
-0000a0f0: 7332 2929 202b 206c 6973 7428 7261 6e67  s2)) + list(rang
-0000a100: 6528 6178 6973 322b 312c 2073 656c 662e  e(axis2+1, self.
-0000a110: 6e64 696d 2929 202b 205b 6178 6973 312c  ndim)) + [axis1,
-0000a120: 2061 7869 7332 5d29 2929 0a0a 2020 2020   axis2])))..    
-0000a130: 6465 6620 5f74 616b 6528 7365 6c66 2c20  def _take(self, 
-0000a140: 696e 6465 782c 2061 7869 7329 3a0a 2020  index, axis):.  
-0000a150: 2020 2020 2020 6966 2069 6e64 6578 2e69        if index.i
-0000a160: 7363 6f6e 7374 616e 743a 0a20 2020 2020  sconstant:.     
-0000a170: 2020 2020 2020 2069 6e64 6578 5f20 3d20         index_ = 
-0000a180: 696e 6465 782e 6576 616c 2829 0a20 2020  index.eval().   
-0000a190: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000a1a0: 436f 6e73 7461 6e74 2873 656c 662e 7661  Constant(self.va
-0000a1b0: 6c75 652e 7461 6b65 2869 6e64 6578 5f2c  lue.take(index_,
-0000a1c0: 2061 7869 7329 290a 0a20 2020 2064 6566   axis))..    def
-0000a1d0: 205f 706f 7765 7228 7365 6c66 2c20 6e29   _power(self, n)
-0000a1e0: 3a0a 2020 2020 2020 2020 6966 2069 7369  :.        if isi
-0000a1f0: 6e73 7461 6e63 6528 6e2c 2043 6f6e 7374  nstance(n, Const
-0000a200: 616e 7429 3a0a 2020 2020 2020 2020 2020  ant):.          
-0000a210: 2020 7265 7475 726e 2043 6f6e 7374 616e    return Constan
-0000a220: 7428 6e75 6d70 792e 706f 7765 7228 7365  t(numpy.power(se
-0000a230: 6c66 2e76 616c 7565 2c20 6e2e 7661 6c75  lf.value, n.valu
-0000a240: 6529 290a 0a20 2020 2064 6566 205f 6569  e))..    def _ei
-0000a250: 6728 7365 6c66 2c20 7379 6d6d 6574 7269  g(self, symmetri
-0000a260: 6329 3a0a 2020 2020 2020 2020 6569 6776  c):.        eigv
-0000a270: 616c 2c20 6569 6776 6563 203d 2028 6e75  al, eigvec = (nu
-0000a280: 6d70 792e 6c69 6e61 6c67 2e65 6967 6820  mpy.linalg.eigh 
-0000a290: 6966 2073 796d 6d65 7472 6963 2065 6c73  if symmetric els
-0000a2a0: 6520 6e75 6d70 792e 6c69 6e61 6c67 2e65  e numpy.linalg.e
-0000a2b0: 6967 2928 7365 6c66 2e76 616c 7565 290a  ig)(self.value).
-0000a2c0: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-0000a2d0: 7570 6c65 2828 436f 6e73 7461 6e74 2865  uple((Constant(e
-0000a2e0: 6967 7661 6c29 2c20 436f 6e73 7461 6e74  igval), Constant
-0000a2f0: 2865 6967 7665 6329 2929 0a0a 2020 2020  (eigvec)))..    
-0000a300: 6465 6620 5f73 6967 6e28 7365 6c66 293a  def _sign(self):
-0000a310: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000a320: 436f 6e73 7461 6e74 286e 756d 7079 2e73  Constant(numpy.s
-0000a330: 6967 6e28 7365 6c66 2e76 616c 7565 2929  ign(self.value))
-0000a340: 0a0a 2020 2020 6465 6620 5f75 6e72 6176  ..    def _unrav
-0000a350: 656c 2873 656c 662c 2061 7869 732c 2073  el(self, axis, s
-0000a360: 6861 7065 293a 0a20 2020 2020 2020 2073  hape):.        s
-0000a370: 6861 7065 203d 2073 656c 662e 7661 6c75  hape = self.valu
-0000a380: 652e 7368 6170 655b 3a61 7869 735d 202b  e.shape[:axis] +
-0000a390: 2073 6861 7065 202b 2073 656c 662e 7661   shape + self.va
-0000a3a0: 6c75 652e 7368 6170 655b 6178 6973 2b31  lue.shape[axis+1
-0000a3b0: 3a5d 0a20 2020 2020 2020 2072 6574 7572  :].        retur
-0000a3c0: 6e20 436f 6e73 7461 6e74 2873 656c 662e  n Constant(self.
-0000a3d0: 7661 6c75 652e 7265 7368 6170 6528 7368  value.reshape(sh
-0000a3e0: 6170 6529 290a 0a20 2020 2064 6566 205f  ape))..    def _
-0000a3f0: 6465 7465 726d 696e 616e 7428 7365 6c66  determinant(self
-0000a400: 2c20 6178 6973 312c 2061 7869 7332 293a  , axis1, axis2):
-0000a410: 0a20 2020 2020 2020 2076 616c 7565 203d  .        value =
-0000a420: 206e 756d 7079 2e74 7261 6e73 706f 7365   numpy.transpose
-0000a430: 2873 656c 662e 7661 6c75 652c 2074 7570  (self.value, tup
-0000a440: 6c65 2869 2066 6f72 2069 2069 6e20 7261  le(i for i in ra
-0000a450: 6e67 6528 7365 6c66 2e6e 6469 6d29 2069  nge(self.ndim) i
-0000a460: 6620 6920 213d 2061 7869 7331 2061 6e64  f i != axis1 and
-0000a470: 2069 2021 3d20 6178 6973 3229 202b 2028   i != axis2) + (
-0000a480: 6178 6973 312c 2061 7869 7332 2929 0a20  axis1, axis2)). 
-0000a490: 2020 2020 2020 2072 6574 7572 6e20 436f         return Co
-0000a4a0: 6e73 7461 6e74 286e 756d 7079 2e6c 696e  nstant(numpy.lin
-0000a4b0: 616c 672e 6465 7428 7661 6c75 6529 290a  alg.det(value)).
-0000a4c0: 0a20 2020 2064 6566 205f 696e 7462 6f75  .    def _intbou
-0000a4d0: 6e64 735f 696d 706c 2873 656c 6629 3a0a  nds_impl(self):.
-0000a4e0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-0000a4f0: 6474 7970 6520 3d3d 2069 6e74 2061 6e64  dtype == int and
-0000a500: 2073 656c 662e 7661 6c75 652e 7369 7a65   self.value.size
-0000a510: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000a520: 7475 726e 2069 6e74 2873 656c 662e 7661  turn int(self.va
-0000a530: 6c75 652e 6d69 6e28 2929 2c20 696e 7428  lue.min()), int(
-0000a540: 7365 6c66 2e76 616c 7565 2e6d 6178 2829  self.value.max()
-0000a550: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-0000a560: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000a570: 726e 2073 7570 6572 2829 2e5f 696e 7462  rn super()._intb
-0000a580: 6f75 6e64 735f 696d 706c 2829 0a0a 2020  ounds_impl()..  
-0000a590: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-0000a5a0: 6465 6620 5f63 6f6e 7374 5f75 6e69 666f  def _const_unifo
-0000a5b0: 726d 2873 656c 6629 3a0a 2020 2020 2020  rm(self):.      
-0000a5c0: 2020 6966 2073 656c 662e 6e64 696d 203d    if self.ndim =
-0000a5d0: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
-0000a5e0: 2072 6574 7572 6e20 7365 6c66 2e64 7479   return self.dty
-0000a5f0: 7065 2873 656c 662e 7661 6c75 655b 2829  pe(self.value[()
-0000a600: 5d29 0a0a 0a63 6c61 7373 2049 6e73 6572  ])...class Inser
-0000a610: 7441 7869 7328 4172 7261 7929 3a0a 0a20  tAxis(Array):.. 
-0000a620: 2020 205f 5f73 6c6f 7473 5f5f 203d 2027     __slots__ = '
-0000a630: 6675 6e63 272c 2027 6c65 6e67 7468 270a  func', 'length'.
-0000a640: 2020 2020 5f5f 6361 6368 655f 5f20 3d20      __cache__ = 
-0000a650: 275f 756e 616c 6967 6e65 6427 2c20 275f  '_unaligned', '_
-0000a660: 696e 666c 6174 696f 6e73 270a 0a20 2020  inflations'..   
-0000a670: 2040 7479 7065 732e 6170 706c 795f 616e   @types.apply_an
-0000a680: 6e6f 7461 7469 6f6e 730a 2020 2020 6465  notations.    de
-0000a690: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
-0000a6a0: 2066 756e 633a 2061 7361 7272 6179 2c20   func: asarray, 
-0000a6b0: 6c65 6e67 7468 3a20 6173 696e 6465 7829  length: asindex)
-0000a6c0: 3a0a 2020 2020 2020 2020 7365 6c66 2e66  :.        self.f
-0000a6d0: 756e 6320 3d20 6675 6e63 0a20 2020 2020  unc = func.     
-0000a6e0: 2020 2073 656c 662e 6c65 6e67 7468 203d     self.length =
-0000a6f0: 206c 656e 6774 680a 2020 2020 2020 2020   length.        
-0000a700: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-0000a710: 2861 7267 733d 5b66 756e 632c 206c 656e  (args=[func, len
-0000a720: 6774 685d 2c20 7368 6170 653d 282a 6675  gth], shape=(*fu
-0000a730: 6e63 2e73 6861 7065 2c20 6c65 6e67 7468  nc.shape, length
-0000a740: 292c 2064 7479 7065 3d66 756e 632e 6474  ), dtype=func.dt
-0000a750: 7970 6529 0a0a 2020 2020 4070 726f 7065  ype)..    @prope
-0000a760: 7274 790a 2020 2020 6465 6620 5f64 6961  rty.    def _dia
-0000a770: 676f 6e61 6c73 2873 656c 6629 3a0a 2020  gonals(self):.  
-0000a780: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-0000a790: 662e 6675 6e63 2e5f 6469 6167 6f6e 616c  f.func._diagonal
-0000a7a0: 730a 0a20 2020 2040 7072 6f70 6572 7479  s..    @property
-0000a7b0: 0a20 2020 2064 6566 205f 696e 666c 6174  .    def _inflat
-0000a7c0: 696f 6e73 2873 656c 6629 3a0a 2020 2020  ions(self):.    
-0000a7d0: 2020 2020 7265 7475 726e 2074 7570 6c65      return tuple
-0000a7e0: 2828 6178 6973 2c20 7479 7065 732e 6672  ((axis, types.fr
-0000a7f0: 6f7a 656e 6469 6374 2828 646f 666d 6170  ozendict((dofmap
-0000a800: 2c20 496e 7365 7274 4178 6973 2866 756e  , InsertAxis(fun
-0000a810: 632c 2073 656c 662e 6c65 6e67 7468 2929  c, self.length))
-0000a820: 2066 6f72 2064 6f66 6d61 702c 2066 756e   for dofmap, fun
-0000a830: 6320 696e 2070 6172 7473 2e69 7465 6d73  c in parts.items
-0000a840: 2829 2929 2066 6f72 2061 7869 732c 2070  ())) for axis, p
-0000a850: 6172 7473 2069 6e20 7365 6c66 2e66 756e  arts in self.fun
-0000a860: 632e 5f69 6e66 6c61 7469 6f6e 7329 0a0a  c._inflations)..
-0000a870: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-0000a880: 2020 6465 6620 5f75 6e61 6c69 676e 6564    def _unaligned
-0000a890: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000a8a0: 7265 7475 726e 2073 656c 662e 6675 6e63  return self.func
-0000a8b0: 2e5f 756e 616c 6967 6e65 640a 0a20 2020  ._unaligned..   
-0000a8c0: 2064 6566 205f 7369 6d70 6c69 6669 6564   def _simplified
-0000a8d0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000a8e0: 7265 7475 726e 2073 656c 662e 6675 6e63  return self.func
-0000a8f0: 2e5f 696e 7365 7274 6178 6973 2873 656c  ._insertaxis(sel
-0000a900: 662e 6e64 696d 2d31 2c20 7365 6c66 2e6c  f.ndim-1, self.l
-0000a910: 656e 6774 6829 0a0a 2020 2020 6465 6620  ength)..    def 
-0000a920: 6576 616c 6628 7365 6c66 2c20 6675 6e63  evalf(self, func
-0000a930: 2c20 6c65 6e67 7468 293a 0a20 2020 2020  , length):.     
-0000a940: 2020 2069 6620 6c65 6e67 7468 203d 3d20     if length == 
-0000a950: 313a 0a20 2020 2020 2020 2020 2020 2072  1:.            r
-0000a960: 6574 7572 6e20 6675 6e63 5b2e 2e2e 2c20  eturn func[..., 
-0000a970: 6e75 6d70 792e 6e65 7761 7869 735d 0a20  numpy.newaxis]. 
-0000a980: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-0000a990: 2020 2020 2020 2020 7265 7475 726e 206e          return n
-0000a9a0: 756d 7079 2e6e 6461 7272 6179 2862 7566  umpy.ndarray(buf
-0000a9b0: 6665 723d 6675 6e63 2c20 6474 7970 653d  fer=func, dtype=
-0000a9c0: 6675 6e63 2e64 7479 7065 2c20 7368 6170  func.dtype, shap
-0000a9d0: 653d 282a 6675 6e63 2e73 6861 7065 2c20  e=(*func.shape, 
-0000a9e0: 6c65 6e67 7468 292c 2073 7472 6964 6573  length), strides
-0000a9f0: 3d28 2a66 756e 632e 7374 7269 6465 732c  =(*func.strides,
-0000aa00: 2030 2929 0a20 2020 2020 2020 2065 7863   0)).        exc
-0000aa10: 6570 7420 5661 6c75 6545 7272 6f72 3a20  ept ValueError: 
-0000aa20: 2023 206e 6f6e 2d63 6f6e 7469 6775 6f75   # non-contiguou
-0000aa30: 7320 6461 7461 0a20 2020 2020 2020 2020  s data.         
-0000aa40: 2020 2072 6574 7572 6e20 6e75 6d70 792e     return numpy.
-0000aa50: 7265 7065 6174 2866 756e 635b 2e2e 2e2c  repeat(func[...,
-0000aa60: 206e 756d 7079 2e6e 6577 6178 6973 5d2c   numpy.newaxis],
-0000aa70: 206c 656e 6774 682c 202d 3129 0a0a 2020   length, -1)..  
-0000aa80: 2020 6465 6620 5f64 6572 6976 6174 6976    def _derivativ
-0000aa90: 6528 7365 6c66 2c20 7661 722c 2073 6565  e(self, var, see
-0000aaa0: 6e29 3a0a 2020 2020 2020 2020 7265 7475  n):.        retu
-0000aab0: 726e 2069 6e73 6572 7461 7869 7328 6465  rn insertaxis(de
-0000aac0: 7269 7661 7469 7665 2873 656c 662e 6675  rivative(self.fu
-0000aad0: 6e63 2c20 7661 722c 2073 6565 6e29 2c20  nc, var, seen), 
-0000aae0: 7365 6c66 2e6e 6469 6d2d 312c 2073 656c  self.ndim-1, sel
-0000aaf0: 662e 6c65 6e67 7468 290a 0a20 2020 2064  f.length)..    d
-0000ab00: 6566 205f 7375 6d28 7365 6c66 2c20 6929  ef _sum(self, i)
-0000ab10: 3a0a 2020 2020 2020 2020 6966 2069 203d  :.        if i =
-0000ab20: 3d20 7365 6c66 2e6e 6469 6d20 2d20 313a  = self.ndim - 1:
-0000ab30: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000ab40: 7572 6e20 7365 6c66 2e66 756e 6320 2a20  urn self.func * 
-0000ab50: 7365 6c66 2e6c 656e 6774 680a 2020 2020  self.length.    
-0000ab60: 2020 2020 7265 7475 726e 2049 6e73 6572      return Inser
-0000ab70: 7441 7869 7328 7375 6d28 7365 6c66 2e66  tAxis(sum(self.f
-0000ab80: 756e 632c 2069 292c 2073 656c 662e 6c65  unc, i), self.le
-0000ab90: 6e67 7468 290a 0a20 2020 2064 6566 205f  ngth)..    def _
-0000aba0: 7072 6f64 7563 7428 7365 6c66 293a 0a20  product(self):. 
-0000abb0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-0000abc0: 6c66 2e66 756e 632a 2a73 656c 662e 6c65  lf.func**self.le
-0000abd0: 6e67 7468 0a0a 2020 2020 6465 6620 5f70  ngth..    def _p
-0000abe0: 6f77 6572 2873 656c 662c 206e 293a 0a20  ower(self, n):. 
-0000abf0: 2020 2020 2020 2075 6e61 6c69 676e 6564         unaligned
-0000ac00: 312c 2075 6e61 6c69 676e 6564 322c 2077  1, unaligned2, w
-0000ac10: 6865 7265 203d 2075 6e61 6c69 676e 2873  here = unalign(s
-0000ac20: 656c 662c 206e 290a 2020 2020 2020 2020  elf, n).        
-0000ac30: 6966 206c 656e 2877 6865 7265 2920 213d  if len(where) !=
-0000ac40: 2073 656c 662e 6e64 696d 3a0a 2020 2020   self.ndim:.    
-0000ac50: 2020 2020 2020 2020 7265 7475 726e 2061          return a
-0000ac60: 6c69 676e 2875 6e61 6c69 676e 6564 3120  lign(unaligned1 
-0000ac70: 2a2a 2075 6e61 6c69 676e 6564 322c 2077  ** unaligned2, w
-0000ac80: 6865 7265 2c20 7365 6c66 2e73 6861 7065  here, self.shape
-0000ac90: 290a 0a20 2020 2064 6566 205f 6164 6428  )..    def _add(
-0000aca0: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-0000acb0: 2020 2020 2020 756e 616c 6967 6e65 6431        unaligned1
-0000acc0: 2c20 756e 616c 6967 6e65 6432 2c20 7768  , unaligned2, wh
-0000acd0: 6572 6520 3d20 756e 616c 6967 6e28 7365  ere = unalign(se
-0000ace0: 6c66 2c20 6f74 6865 7229 0a20 2020 2020  lf, other).     
-0000acf0: 2020 2069 6620 6c65 6e28 7768 6572 6529     if len(where)
-0000ad00: 2021 3d20 7365 6c66 2e6e 6469 6d3a 0a20   != self.ndim:. 
-0000ad10: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000ad20: 6e20 616c 6967 6e28 756e 616c 6967 6e65  n align(unaligne
-0000ad30: 6431 202b 2075 6e61 6c69 676e 6564 322c  d1 + unaligned2,
-0000ad40: 2077 6865 7265 2c20 7365 6c66 2e73 6861   where, self.sha
-0000ad50: 7065 290a 0a20 2020 2064 6566 205f 6469  pe)..    def _di
-0000ad60: 6167 6f6e 616c 697a 6528 7365 6c66 2c20  agonalize(self, 
-0000ad70: 6178 6973 293a 0a20 2020 2020 2020 2069  axis):.        i
-0000ad80: 6620 6178 6973 203c 2073 656c 662e 6e64  f axis < self.nd
-0000ad90: 696d 202d 2031 3a0a 2020 2020 2020 2020  im - 1:.        
-0000ada0: 2020 2020 7265 7475 726e 2069 6e73 6572      return inser
-0000adb0: 7461 7869 7328 6469 6167 6f6e 616c 697a  taxis(diagonaliz
-0000adc0: 6528 7365 6c66 2e66 756e 632c 2061 7869  e(self.func, axi
-0000add0: 732c 2073 656c 662e 6e64 696d 202d 2031  s, self.ndim - 1
-0000ade0: 292c 2073 656c 662e 6e64 696d 202d 2031  ), self.ndim - 1
-0000adf0: 2c20 7365 6c66 2e6c 656e 6774 6829 0a0a  , self.length)..
-0000ae00: 2020 2020 6465 6620 5f69 6e66 6c61 7465      def _inflate
-0000ae10: 2873 656c 662c 2064 6f66 6d61 702c 206c  (self, dofmap, l
-0000ae20: 656e 6774 682c 2061 7869 7329 3a0a 2020  ength, axis):.  
-0000ae30: 2020 2020 2020 6966 2061 7869 7320 2b20        if axis + 
-0000ae40: 646f 666d 6170 2e6e 6469 6d20 3c20 7365  dofmap.ndim < se
-0000ae50: 6c66 2e6e 6469 6d3a 0a20 2020 2020 2020  lf.ndim:.       
-0000ae60: 2020 2020 2072 6574 7572 6e20 496e 7365       return Inse
-0000ae70: 7274 4178 6973 285f 696e 666c 6174 6528  rtAxis(_inflate(
-0000ae80: 7365 6c66 2e66 756e 632c 2064 6f66 6d61  self.func, dofma
-0000ae90: 702c 206c 656e 6774 682c 2061 7869 7329  p, length, axis)
-0000aea0: 2c20 7365 6c66 2e6c 656e 6774 6829 0a20  , self.length). 
-0000aeb0: 2020 2020 2020 2065 6c69 6620 6178 6973         elif axis
-0000aec0: 203d 3d20 7365 6c66 2e6e 6469 6d3a 0a20   == self.ndim:. 
-0000aed0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000aee0: 6e20 696e 7365 7274 6178 6973 2849 6e66  n insertaxis(Inf
-0000aef0: 6c61 7465 2873 656c 662e 6675 6e63 2c20  late(self.func, 
-0000af00: 646f 666d 6170 2c20 6c65 6e67 7468 292c  dofmap, length),
-0000af10: 2073 656c 662e 6e64 696d 202d 2031 2c20   self.ndim - 1, 
-0000af20: 7365 6c66 2e6c 656e 6774 6829 0a0a 2020  self.length)..  
-0000af30: 2020 6465 6620 5f69 6e73 6572 7461 7869    def _insertaxi
-0000af40: 7328 7365 6c66 2c20 6178 6973 2c20 6c65  s(self, axis, le
-0000af50: 6e67 7468 293a 0a20 2020 2020 2020 2069  ngth):.        i
-0000af60: 6620 6178 6973 203d 3d20 7365 6c66 2e6e  f axis == self.n
-0000af70: 6469 6d20 2d20 313a 0a20 2020 2020 2020  dim - 1:.       
-0000af80: 2020 2020 2072 6574 7572 6e20 496e 7365       return Inse
-0000af90: 7274 4178 6973 2849 6e73 6572 7441 7869  rtAxis(InsertAxi
-0000afa0: 7328 7365 6c66 2e66 756e 632c 206c 656e  s(self.func, len
-0000afb0: 6774 6829 2c20 7365 6c66 2e6c 656e 6774  gth), self.lengt
-0000afc0: 6829 0a0a 2020 2020 6465 6620 5f74 616b  h)..    def _tak
-0000afd0: 6528 7365 6c66 2c20 696e 6465 782c 2061  e(self, index, a
-0000afe0: 7869 7329 3a0a 2020 2020 2020 2020 6966  xis):.        if
-0000aff0: 2061 7869 7320 3d3d 2073 656c 662e 6e64   axis == self.nd
-0000b000: 696d 202d 2031 3a0a 2020 2020 2020 2020  im - 1:.        
-0000b010: 2020 2020 7265 7475 726e 2061 7070 656e      return appen
-0000b020: 6461 7865 7328 7365 6c66 2e66 756e 632c  daxes(self.func,
-0000b030: 2069 6e64 6578 2e73 6861 7065 290a 2020   index.shape).  
-0000b040: 2020 2020 2020 7265 7475 726e 2049 6e73        return Ins
-0000b050: 6572 7441 7869 7328 5f74 616b 6528 7365  ertAxis(_take(se
-0000b060: 6c66 2e66 756e 632c 2069 6e64 6578 2c20  lf.func, index, 
-0000b070: 6178 6973 292c 2073 656c 662e 6c65 6e67  axis), self.leng
-0000b080: 7468 290a 0a20 2020 2064 6566 205f 7461  th)..    def _ta
-0000b090: 6b65 6469 6167 2873 656c 662c 2061 7869  kediag(self, axi
-0000b0a0: 7331 2c20 6178 6973 3229 3a0a 2020 2020  s1, axis2):.    
-0000b0b0: 2020 2020 6173 7365 7274 2061 7869 7331      assert axis1
-0000b0c0: 203c 2061 7869 7332 0a20 2020 2020 2020   < axis2.       
-0000b0d0: 2069 6620 6178 6973 3220 3d3d 2073 656c   if axis2 == sel
-0000b0e0: 662e 6e64 696d 2d31 3a0a 2020 2020 2020  f.ndim-1:.      
-0000b0f0: 2020 2020 2020 7265 7475 726e 2054 7261        return Tra
-0000b100: 6e73 706f 7365 2e74 6f5f 656e 6428 7365  nspose.to_end(se
-0000b110: 6c66 2e66 756e 632c 2061 7869 7331 290a  lf.func, axis1).
-0000b120: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0000b130: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000b140: 2069 6e73 6572 7461 7869 7328 5f74 616b   insertaxis(_tak
-0000b150: 6564 6961 6728 7365 6c66 2e66 756e 632c  ediag(self.func,
-0000b160: 2061 7869 7331 2c20 6178 6973 3229 2c20   axis1, axis2), 
-0000b170: 7365 6c66 2e6e 6469 6d2d 332c 2073 656c  self.ndim-3, sel
-0000b180: 662e 6c65 6e67 7468 290a 0a20 2020 2064  f.length)..    d
-0000b190: 6566 205f 756e 7261 7665 6c28 7365 6c66  ef _unravel(self
-0000b1a0: 2c20 6178 6973 2c20 7368 6170 6529 3a0a  , axis, shape):.
-0000b1b0: 2020 2020 2020 2020 6966 2061 7869 7320          if axis 
-0000b1c0: 3d3d 2073 656c 662e 6e64 696d 202d 2031  == self.ndim - 1
-0000b1d0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000b1e0: 7475 726e 2049 6e73 6572 7441 7869 7328  turn InsertAxis(
-0000b1f0: 496e 7365 7274 4178 6973 2873 656c 662e  InsertAxis(self.
-0000b200: 6675 6e63 2c20 7368 6170 655b 305d 292c  func, shape[0]),
-0000b210: 2073 6861 7065 5b31 5d29 0a20 2020 2020   shape[1]).     
-0000b220: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000b230: 2020 2020 2072 6574 7572 6e20 496e 7365       return Inse
-0000b240: 7274 4178 6973 2875 6e72 6176 656c 2873  rtAxis(unravel(s
-0000b250: 656c 662e 6675 6e63 2c20 6178 6973 2c20  elf.func, axis, 
-0000b260: 7368 6170 6529 2c20 7365 6c66 2e6c 656e  shape), self.len
-0000b270: 6774 6829 0a0a 2020 2020 6465 6620 5f73  gth)..    def _s
-0000b280: 6967 6e28 7365 6c66 293a 0a20 2020 2020  ign(self):.     
-0000b290: 2020 2072 6574 7572 6e20 496e 7365 7274     return Insert
-0000b2a0: 4178 6973 2853 6967 6e28 7365 6c66 2e66  Axis(Sign(self.f
-0000b2b0: 756e 6329 2c20 7365 6c66 2e6c 656e 6774  unc), self.lengt
-0000b2c0: 6829 0a0a 2020 2020 6465 6620 5f64 6574  h)..    def _det
-0000b2d0: 6572 6d69 6e61 6e74 2873 656c 662c 2061  erminant(self, a
-0000b2e0: 7869 7331 2c20 6178 6973 3229 3a0a 2020  xis1, axis2):.  
-0000b2f0: 2020 2020 2020 6966 2061 7869 7331 203c        if axis1 <
-0000b300: 2073 656c 662e 6e64 696d 2d31 2061 6e64   self.ndim-1 and
-0000b310: 2061 7869 7332 203c 2073 656c 662e 6e64   axis2 < self.nd
-0000b320: 696d 2d31 3a0a 2020 2020 2020 2020 2020  im-1:.          
-0000b330: 2020 7265 7475 726e 2049 6e73 6572 7441    return InsertA
-0000b340: 7869 7328 6465 7465 726d 696e 616e 7428  xis(determinant(
-0000b350: 7365 6c66 2e66 756e 632c 2028 6178 6973  self.func, (axis
-0000b360: 312c 2061 7869 7332 2929 2c20 7365 6c66  1, axis2)), self
-0000b370: 2e6c 656e 6774 6829 0a0a 2020 2020 6465  .length)..    de
-0000b380: 6620 5f69 6e76 6572 7365 2873 656c 662c  f _inverse(self,
-0000b390: 2061 7869 7331 2c20 6178 6973 3229 3a0a   axis1, axis2):.
-0000b3a0: 2020 2020 2020 2020 6966 2061 7869 7331          if axis1
-0000b3b0: 203c 2073 656c 662e 6e64 696d 2d31 2061   < self.ndim-1 a
-0000b3c0: 6e64 2061 7869 7332 203c 2073 656c 662e  nd axis2 < self.
-0000b3d0: 6e64 696d 2d31 3a0a 2020 2020 2020 2020  ndim-1:.        
-0000b3e0: 2020 2020 7265 7475 726e 2049 6e73 6572      return Inser
-0000b3f0: 7441 7869 7328 696e 7665 7273 6528 7365  tAxis(inverse(se
-0000b400: 6c66 2e66 756e 632c 2028 6178 6973 312c  lf.func, (axis1,
-0000b410: 2061 7869 7332 2929 2c20 7365 6c66 2e6c   axis2)), self.l
-0000b420: 656e 6774 6829 0a0a 2020 2020 6465 6620  ength)..    def 
-0000b430: 5f6c 6f6f 7073 756d 2873 656c 662c 2069  _loopsum(self, i
-0000b440: 6e64 6578 293a 0a20 2020 2020 2020 2072  ndex):.        r
-0000b450: 6574 7572 6e20 496e 7365 7274 4178 6973  eturn InsertAxis
-0000b460: 286c 6f6f 705f 7375 6d28 7365 6c66 2e66  (loop_sum(self.f
-0000b470: 756e 632c 2069 6e64 6578 292c 2073 656c  unc, index), sel
-0000b480: 662e 6c65 6e67 7468 290a 0a20 2020 2040  f.length)..    @
-0000b490: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-0000b4a0: 205f 6173 7370 6172 7365 2873 656c 6629   _assparse(self)
-0000b4b0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-0000b4c0: 2074 7570 6c65 2828 2a28 496e 7365 7274   tuple((*(Insert
-0000b4d0: 4178 6973 2869 6478 2c20 7365 6c66 2e6c  Axis(idx, self.l
-0000b4e0: 656e 6774 6829 2066 6f72 2069 6478 2069  ength) for idx i
-0000b4f0: 6e20 696e 6469 6365 7329 2c20 7072 6570  n indices), prep
-0000b500: 656e 6461 7865 7328 5261 6e67 6528 7365  endaxes(Range(se
-0000b510: 6c66 2e6c 656e 6774 6829 2c20 7661 6c75  lf.length), valu
-0000b520: 6573 2e73 6861 7065 292c 2049 6e73 6572  es.shape), Inser
-0000b530: 7441 7869 7328 7661 6c75 6573 2c20 7365  tAxis(values, se
-0000b540: 6c66 2e6c 656e 6774 6829 2920 666f 7220  lf.length)) for 
-0000b550: 2a69 6e64 6963 6573 2c20 7661 6c75 6573  *indices, values
-0000b560: 2069 6e20 7365 6c66 2e66 756e 632e 5f61   in self.func._a
-0000b570: 7373 7061 7273 6529 0a0a 2020 2020 6465  ssparse)..    de
-0000b580: 6620 5f69 6e74 626f 756e 6473 5f69 6d70  f _intbounds_imp
-0000b590: 6c28 7365 6c66 293a 0a20 2020 2020 2020  l(self):.       
-0000b5a0: 2072 6574 7572 6e20 7365 6c66 2e66 756e   return self.fun
-0000b5b0: 632e 5f69 6e74 626f 756e 6473 0a0a 2020  c._intbounds..  
-0000b5c0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-0000b5d0: 6465 6620 5f63 6f6e 7374 5f75 6e69 666f  def _const_unifo
-0000b5e0: 726d 2873 656c 6629 3a0a 2020 2020 2020  rm(self):.      
-0000b5f0: 2020 7265 7475 726e 2073 656c 662e 6675    return self.fu
-0000b600: 6e63 2e5f 636f 6e73 745f 756e 6966 6f72  nc._const_unifor
-0000b610: 6d0a 0a0a 636c 6173 7320 5472 616e 7370  m...class Transp
-0000b620: 6f73 6528 4172 7261 7929 3a0a 0a20 2020  ose(Array):..   
-0000b630: 205f 5f73 6c6f 7473 5f5f 203d 2027 6675   __slots__ = 'fu
-0000b640: 6e63 272c 2027 6178 6573 270a 2020 2020  nc', 'axes'.    
-0000b650: 5f5f 6361 6368 655f 5f20 3d20 275f 696e  __cache__ = '_in
-0000b660: 7661 7865 7327 2c20 275f 756e 616c 6967  vaxes', '_unalig
-0000b670: 6e65 6427 2c20 275f 6469 6167 6f6e 616c  ned', '_diagonal
-0000b680: 7327 2c20 275f 696e 666c 6174 696f 6e73  s', '_inflations
-0000b690: 270a 0a20 2020 2040 636c 6173 736d 6574  '..    @classmet
-0000b6a0: 686f 640a 2020 2020 4074 7970 6573 2e61  hod.    @types.a
-0000b6b0: 7070 6c79 5f61 6e6e 6f74 6174 696f 6e73  pply_annotations
-0000b6c0: 0a20 2020 2064 6566 205f 656e 6428 636c  .    def _end(cl
-0000b6d0: 732c 2061 7272 6179 3a20 6173 6172 7261  s, array: asarra
-0000b6e0: 792c 2061 7865 732c 2069 6e76 6572 743d  y, axes, invert=
-0000b6f0: 4661 6c73 6529 3a0a 2020 2020 2020 2020  False):.        
-0000b700: 6178 6573 203d 205b 6e75 6d65 7269 632e  axes = [numeric.
-0000b710: 6e6f 726d 6469 6d28 6172 7261 792e 6e64  normdim(array.nd
-0000b720: 696d 2c20 6178 6973 2920 666f 7220 6178  im, axis) for ax
-0000b730: 6973 2069 6e20 6178 6573 5d0a 2020 2020  is in axes].    
-0000b740: 2020 2020 6966 2061 6c6c 2861 203d 3d20      if all(a == 
-0000b750: 6220 666f 7220 612c 2062 2069 6e20 656e  b for a, b in en
-0000b760: 756d 6572 6174 6528 6178 6573 2c20 7374  umerate(axes, st
-0000b770: 6172 743d 6172 7261 792e 6e64 696d 2d6c  art=array.ndim-l
-0000b780: 656e 2861 7865 7329 2929 3a0a 2020 2020  en(axes))):.    
-0000b790: 2020 2020 2020 2020 7265 7475 726e 2061          return a
-0000b7a0: 7272 6179 0a20 2020 2020 2020 2074 7261  rray.        tra
-0000b7b0: 6e73 203d 205b 6920 666f 7220 6920 696e  ns = [i for i in
-0000b7c0: 2072 616e 6765 2861 7272 6179 2e6e 6469   range(array.ndi
-0000b7d0: 6d29 2069 6620 6920 6e6f 7420 696e 2061  m) if i not in a
-0000b7e0: 7865 735d 0a20 2020 2020 2020 2074 7261  xes].        tra
-0000b7f0: 6e73 2e65 7874 656e 6428 6178 6573 290a  ns.extend(axes).
-0000b800: 2020 2020 2020 2020 6966 206c 656e 2874          if len(t
-0000b810: 7261 6e73 2920 213d 2061 7272 6179 2e6e  rans) != array.n
-0000b820: 6469 6d3a 0a20 2020 2020 2020 2020 2020  dim:.           
-0000b830: 2072 6169 7365 2045 7863 6570 7469 6f6e   raise Exception
-0000b840: 2827 6475 706c 6963 6174 6520 6178 6573  ('duplicate axes
-0000b850: 2729 0a20 2020 2020 2020 2072 6574 7572  ').        retur
-0000b860: 6e20 636c 7328 6172 7261 792c 206e 756d  n cls(array, num
-0000b870: 7079 2e61 7267 736f 7274 2874 7261 6e73  py.argsort(trans
-0000b880: 2920 6966 2069 6e76 6572 7420 656c 7365  ) if invert else
-0000b890: 2074 7261 6e73 290a 0a20 2020 2040 636c   trans)..    @cl
-0000b8a0: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
-0000b8b0: 6620 6672 6f6d 5f65 6e64 2863 6c73 2c20  f from_end(cls, 
-0000b8c0: 6172 7261 792c 202a 6178 6573 293a 0a20  array, *axes):. 
-0000b8d0: 2020 2020 2020 2072 6574 7572 6e20 636c         return cl
-0000b8e0: 732e 5f65 6e64 2861 7272 6179 2c20 6178  s._end(array, ax
-0000b8f0: 6573 2c20 696e 7665 7274 3d54 7275 6529  es, invert=True)
-0000b900: 0a0a 2020 2020 4063 6c61 7373 6d65 7468  ..    @classmeth
-0000b910: 6f64 0a20 2020 2064 6566 2074 6f5f 656e  od.    def to_en
-0000b920: 6428 636c 732c 2061 7272 6179 2c20 2a61  d(cls, array, *a
-0000b930: 7865 7329 3a0a 2020 2020 2020 2020 7265  xes):.        re
-0000b940: 7475 726e 2063 6c73 2e5f 656e 6428 6172  turn cls._end(ar
-0000b950: 7261 792c 2061 7865 732c 2069 6e76 6572  ray, axes, inver
-0000b960: 743d 4661 6c73 6529 0a0a 2020 2020 4074  t=False)..    @t
-0000b970: 7970 6573 2e61 7070 6c79 5f61 6e6e 6f74  ypes.apply_annot
-0000b980: 6174 696f 6e73 0a20 2020 2064 6566 205f  ations.    def _
-0000b990: 5f69 6e69 745f 5f28 7365 6c66 2c20 6675  _init__(self, fu
-0000b9a0: 6e63 3a20 6173 6172 7261 792c 2061 7865  nc: asarray, axe
-0000b9b0: 733a 2074 7970 6573 2e74 7570 6c65 5b74  s: types.tuple[t
-0000b9c0: 7970 6573 2e73 7472 6963 7469 6e74 5d29  ypes.strictint])
-0000b9d0: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
-0000b9e0: 2073 6f72 7465 6428 6178 6573 2920 3d3d   sorted(axes) ==
-0000b9f0: 206c 6973 7428 7261 6e67 6528 6675 6e63   list(range(func
-0000ba00: 2e6e 6469 6d29 290a 2020 2020 2020 2020  .ndim)).        
-0000ba10: 7365 6c66 2e66 756e 6320 3d20 6675 6e63  self.func = func
-0000ba20: 0a20 2020 2020 2020 2073 656c 662e 6178  .        self.ax
-0000ba30: 6573 203d 2061 7865 730a 2020 2020 2020  es = axes.      
-0000ba40: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-0000ba50: 5f5f 2861 7267 733d 5b66 756e 635d 2c20  __(args=[func], 
-0000ba60: 7368 6170 653d 5b66 756e 632e 7368 6170  shape=[func.shap
-0000ba70: 655b 6e5d 2066 6f72 206e 2069 6e20 6178  e[n] for n in ax
-0000ba80: 6573 5d2c 2064 7479 7065 3d66 756e 632e  es], dtype=func.
-0000ba90: 6474 7970 6529 0a0a 2020 2020 4070 726f  dtype)..    @pro
-0000baa0: 7065 7274 790a 2020 2020 6465 6620 5f64  perty.    def _d
-0000bab0: 6961 676f 6e61 6c73 2873 656c 6629 3a0a  iagonals(self):.
-0000bac0: 2020 2020 2020 2020 7265 7475 726e 2074          return t
-0000bad0: 7570 6c65 2866 726f 7a65 6e73 6574 2873  uple(frozenset(s
-0000bae0: 656c 662e 5f69 6e76 6178 6573 5b69 5d20  elf._invaxes[i] 
-0000baf0: 666f 7220 6920 696e 2061 7865 7329 2066  for i in axes) f
-0000bb00: 6f72 2061 7865 7320 696e 2073 656c 662e  or axes in self.
-0000bb10: 6675 6e63 2e5f 6469 6167 6f6e 616c 7329  func._diagonals)
-0000bb20: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-0000bb30: 2020 2020 6465 6620 5f69 6e66 6c61 7469      def _inflati
-0000bb40: 6f6e 7328 7365 6c66 293a 0a20 2020 2020  ons(self):.     
-0000bb50: 2020 2072 6574 7572 6e20 7475 706c 6528     return tuple(
-0000bb60: 2873 656c 662e 5f69 6e76 6178 6573 5b61  (self._invaxes[a
-0000bb70: 7869 735d 2c20 7479 7065 732e 6672 6f7a  xis], types.froz
-0000bb80: 656e 6469 6374 2828 646f 666d 6170 2c20  endict((dofmap, 
-0000bb90: 5472 616e 7370 6f73 6528 6675 6e63 2c20  Transpose(func, 
-0000bba0: 7365 6c66 2e5f 6178 6573 5f66 6f72 2864  self._axes_for(d
-0000bbb0: 6f66 6d61 702e 6e64 696d 2c20 7365 6c66  ofmap.ndim, self
-0000bbc0: 2e5f 696e 7661 7865 735b 6178 6973 5d29  ._invaxes[axis])
-0000bbd0: 2929 2066 6f72 2064 6f66 6d61 702c 2066  )) for dofmap, f
-0000bbe0: 756e 6320 696e 2070 6172 7473 2e69 7465  unc in parts.ite
-0000bbf0: 6d73 2829 2929 2066 6f72 2061 7869 732c  ms())) for axis,
-0000bc00: 2070 6172 7473 2069 6e20 7365 6c66 2e66   parts in self.f
-0000bc10: 756e 632e 5f69 6e66 6c61 7469 6f6e 7329  unc._inflations)
-0000bc20: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-0000bc30: 2020 2020 6465 6620 5f75 6e61 6c69 676e      def _unalign
-0000bc40: 6564 2873 656c 6629 3a0a 2020 2020 2020  ed(self):.      
-0000bc50: 2020 756e 616c 6967 6e65 642c 2077 6865    unaligned, whe
-0000bc60: 7265 203d 2075 6e61 6c69 676e 2873 656c  re = unalign(sel
-0000bc70: 662e 6675 6e63 290a 2020 2020 2020 2020  f.func).        
-0000bc80: 7265 7475 726e 2075 6e61 6c69 676e 6564  return unaligned
-0000bc90: 2c20 7475 706c 6528 7365 6c66 2e5f 696e  , tuple(self._in
-0000bca0: 7661 7865 735b 695d 2066 6f72 2069 2069  vaxes[i] for i i
-0000bcb0: 6e20 7768 6572 6529 0a0a 2020 2020 4070  n where)..    @p
-0000bcc0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-0000bcd0: 5f69 6e76 6178 6573 2873 656c 6629 3a0a  _invaxes(self):.
-0000bce0: 2020 2020 2020 2020 7265 7475 726e 2074          return t
-0000bcf0: 7570 6c65 286e 756d 7079 2e61 7267 736f  uple(numpy.argso
-0000bd00: 7274 2873 656c 662e 6178 6573 2929 0a0a  rt(self.axes))..
-0000bd10: 2020 2020 6465 6620 5f73 696d 706c 6966      def _simplif
-0000bd20: 6965 6428 7365 6c66 293a 0a20 2020 2020  ied(self):.     
-0000bd30: 2020 2069 6620 7365 6c66 2e61 7865 7320     if self.axes 
-0000bd40: 3d3d 2074 7570 6c65 2872 616e 6765 2873  == tuple(range(s
-0000bd50: 656c 662e 6e64 696d 2929 3a0a 2020 2020  elf.ndim)):.    
-0000bd60: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0000bd70: 656c 662e 6675 6e63 0a20 2020 2020 2020  elf.func.       
-0000bd80: 2072 6574 7572 6e20 7365 6c66 2e66 756e   return self.fun
-0000bd90: 632e 5f74 7261 6e73 706f 7365 2873 656c  c._transpose(sel
-0000bda0: 662e 6178 6573 290a 0a20 2020 2064 6566  f.axes)..    def
-0000bdb0: 2065 7661 6c66 2873 656c 662c 2061 7272   evalf(self, arr
-0000bdc0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-0000bdd0: 6e20 6172 722e 7472 616e 7370 6f73 6528  n arr.transpose(
-0000bde0: 7365 6c66 2e61 7865 7329 0a0a 2020 2020  self.axes)..    
-0000bdf0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-0000be00: 6620 5f6e 6f64 655f 6465 7461 696c 7328  f _node_details(
-0000be10: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-0000be20: 6574 7572 6e20 272c 272e 6a6f 696e 286d  eturn ','.join(m
-0000be30: 6170 2873 7472 2c20 7365 6c66 2e61 7865  ap(str, self.axe
-0000be40: 7329 290a 0a20 2020 2064 6566 205f 7472  s))..    def _tr
-0000be50: 616e 7370 6f73 6528 7365 6c66 2c20 6178  anspose(self, ax
-0000be60: 6573 293a 0a20 2020 2020 2020 2069 6620  es):.        if 
-0000be70: 6178 6573 203d 3d20 7365 6c66 2e5f 696e  axes == self._in
-0000be80: 7661 7865 733a 0a20 2020 2020 2020 2020  vaxes:.         
-0000be90: 2020 2023 204e 4f54 453a 2057 6869 6c65     # NOTE: While
-0000bea0: 2077 6520 636f 756c 6420 6c65 6176 6520   we could leave 
-0000beb0: 7468 6973 2070 6172 7469 6375 6c61 7220  this particular 
-0000bec0: 7369 6d70 6c69 6669 6361 7469 6f6e 2074  simplification t
-0000bed0: 6f20 6265 2064 6561 6c74 0a20 2020 2020  o be dealt.     
-0000bee0: 2020 2020 2020 2023 2077 6974 6820 6279         # with by
-0000bef0: 2054 7261 6e73 706f 7365 2c20 7468 6520   Transpose, the 
-0000bf00: 6265 6e65 6669 7420 6f66 2068 616e 646c  benefit of handl
-0000bf10: 696e 6720 6974 2064 6972 6563 746c 7920  ing it directly 
-0000bf20: 6973 2074 6861 7420 5f61 6464 2061 6e64  is that _add and
-0000bf30: 0a20 2020 2020 2020 2020 2020 2023 205f  .            # _
-0000bf40: 6d75 6c74 6970 6c79 2063 616e 2072 656c  multiply can rel
-0000bf50: 7920 6f6e 205f 7472 616e 7370 6f73 6520  y on _transpose 
-0000bf60: 666f 7220 7468 6520 7269 6768 7420 6861  for the right ha
-0000bf70: 6e64 2073 6964 6520 7769 7468 6f75 7420  nd side without 
-0000bf80: 6861 7669 6e67 0a20 2020 2020 2020 2020  having.         
-0000bf90: 2020 2023 2074 6f20 7365 7061 7261 7465     # to separate
-0000bfa0: 6c79 2061 6363 6f75 6e74 2066 6f72 2074  ly account for t
-0000bfb0: 6865 2074 7269 7669 616c 2063 6173 652e  he trivial case.
-0000bfc0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000bfd0: 7572 6e20 7365 6c66 2e66 756e 630a 2020  urn self.func.  
-0000bfe0: 2020 2020 2020 6e65 7761 7865 7320 3d20        newaxes = 
-0000bff0: 5b73 656c 662e 6178 6573 5b69 5d20 666f  [self.axes[i] fo
-0000c000: 7220 6920 696e 2061 7865 735d 0a20 2020  r i in axes].   
-0000c010: 2020 2020 2072 6574 7572 6e20 5472 616e       return Tran
-0000c020: 7370 6f73 6528 7365 6c66 2e66 756e 632c  spose(self.func,
-0000c030: 206e 6577 6178 6573 290a 0a20 2020 2064   newaxes)..    d
-0000c040: 6566 205f 7461 6b65 6469 6167 2873 656c  ef _takediag(sel
-0000c050: 662c 2061 7869 7331 2c20 6178 6973 3229  f, axis1, axis2)
-0000c060: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
-0000c070: 2061 7869 7331 203c 2061 7869 7332 0a20   axis1 < axis2. 
-0000c080: 2020 2020 2020 206f 7269 6731 2c20 6f72         orig1, or
-0000c090: 6967 3220 3d20 736f 7274 6564 2873 656c  ig2 = sorted(sel
-0000c0a0: 662e 6178 6573 5b61 7869 735d 2066 6f72  f.axes[axis] for
-0000c0b0: 2061 7869 7320 696e 205b 6178 6973 312c   axis in [axis1,
-0000c0c0: 2061 7869 7332 5d29 0a20 2020 2020 2020   axis2]).       
-0000c0d0: 2069 6620 6f72 6967 3120 3d3d 2073 656c   if orig1 == sel
-0000c0e0: 662e 6e64 696d 2d32 3a0a 2020 2020 2020  f.ndim-2:.      
-0000c0f0: 2020 2020 2020 7265 7475 726e 2054 7261        return Tra
-0000c100: 6e73 706f 7365 2854 616b 6544 6961 6728  nspose(TakeDiag(
-0000c110: 7365 6c66 2e66 756e 6329 2c20 282a 7365  self.func), (*se
-0000c120: 6c66 2e61 7865 735b 3a61 7869 7331 5d2c  lf.axes[:axis1],
-0000c130: 202a 7365 6c66 2e61 7865 735b 6178 6973   *self.axes[axis
-0000c140: 312b 313a 6178 6973 325d 2c20 2a73 656c  1+1:axis2], *sel
-0000c150: 662e 6178 6573 5b61 7869 7332 2b31 3a5d  f.axes[axis2+1:]
-0000c160: 2c20 7365 6c66 2e6e 6469 6d2d 3229 290a  , self.ndim-2)).
-0000c170: 2020 2020 2020 2020 7472 7974 616b 6564          trytaked
-0000c180: 6961 6720 3d20 7365 6c66 2e66 756e 632e  iag = self.func.
-0000c190: 5f74 616b 6564 6961 6728 6f72 6967 312c  _takediag(orig1,
-0000c1a0: 206f 7269 6732 290a 2020 2020 2020 2020   orig2).        
-0000c1b0: 6966 2074 7279 7461 6b65 6469 6167 2069  if trytakediag i
-0000c1c0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-0000c1d0: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-0000c1e0: 7261 6e73 706f 7365 2874 7279 7461 6b65  ranspose(trytake
-0000c1f0: 6469 6167 2c20 5b61 782d 2861 7820 3e20  diag, [ax-(ax > 
-0000c200: 6f72 6967 3129 2d28 6178 203e 206f 7269  orig1)-(ax > ori
-0000c210: 6732 2920 666f 7220 6178 2069 6e20 7365  g2) for ax in se
-0000c220: 6c66 2e61 7865 735b 3a61 7869 7331 5d20  lf.axes[:axis1] 
-0000c230: 2b20 7365 6c66 2e61 7865 735b 6178 6973  + self.axes[axis
-0000c240: 312b 313a 6178 6973 325d 202b 2073 656c  1+1:axis2] + sel
-0000c250: 662e 6178 6573 5b61 7869 7332 2b31 3a5d  f.axes[axis2+1:]
-0000c260: 5d20 2b20 5b73 656c 662e 6e64 696d 2d32  ] + [self.ndim-2
-0000c270: 5d29 0a0a 2020 2020 6465 6620 5f73 756d  ])..    def _sum
-0000c280: 2873 656c 662c 2069 293a 0a20 2020 2020  (self, i):.     
-0000c290: 2020 2061 7869 7320 3d20 7365 6c66 2e61     axis = self.a
-0000c2a0: 7865 735b 695d 0a20 2020 2020 2020 2074  xes[i].        t
-0000c2b0: 7279 7375 6d20 3d20 7365 6c66 2e66 756e  rysum = self.fun
-0000c2c0: 632e 5f73 756d 2861 7869 7329 0a20 2020  c._sum(axis).   
-0000c2d0: 2020 2020 2069 6620 7472 7973 756d 2069       if trysum i
-0000c2e0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-0000c2f0: 2020 2020 2020 2020 6178 6573 203d 205b          axes = [
-0000c300: 6178 2d28 6178 203e 2061 7869 7329 2066  ax-(ax > axis) f
-0000c310: 6f72 2061 7820 696e 2073 656c 662e 6178  or ax in self.ax
-0000c320: 6573 2069 6620 6178 2021 3d20 6178 6973  es if ax != axis
-0000c330: 5d0a 2020 2020 2020 2020 2020 2020 7265  ].            re
-0000c340: 7475 726e 2054 7261 6e73 706f 7365 2874  turn Transpose(t
-0000c350: 7279 7375 6d2c 2061 7865 7329 0a20 2020  rysum, axes).   
-0000c360: 2020 2020 2069 6620 6178 6973 203d 3d20       if axis == 
-0000c370: 7365 6c66 2e6e 6469 6d20 2d20 313a 0a20  self.ndim - 1:. 
-0000c380: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000c390: 6e20 5472 616e 7370 6f73 6528 5375 6d28  n Transpose(Sum(
-0000c3a0: 7365 6c66 2e66 756e 6329 2c20 7365 6c66  self.func), self
-0000c3b0: 2e5f 6178 6573 5f66 6f72 2830 2c20 6929  ._axes_for(0, i)
-0000c3c0: 290a 0a20 2020 2064 6566 205f 6465 7269  )..    def _deri
-0000c3d0: 7661 7469 7665 2873 656c 662c 2076 6172  vative(self, var
-0000c3e0: 2c20 7365 656e 293a 0a20 2020 2020 2020  , seen):.       
-0000c3f0: 2072 6574 7572 6e20 7472 616e 7370 6f73   return transpos
-0000c400: 6528 6465 7269 7661 7469 7665 2873 656c  e(derivative(sel
-0000c410: 662e 6675 6e63 2c20 7661 722c 2073 6565  f.func, var, see
-0000c420: 6e29 2c20 7365 6c66 2e61 7865 732b 7475  n), self.axes+tu
-0000c430: 706c 6528 7261 6e67 6528 7365 6c66 2e6e  ple(range(self.n
-0000c440: 6469 6d2c 2073 656c 662e 6e64 696d 2b76  dim, self.ndim+v
-0000c450: 6172 2e6e 6469 6d29 2929 0a0a 2020 2020  ar.ndim)))..    
-0000c460: 6465 6620 5f6d 756c 7469 706c 7928 7365  def _multiply(se
-0000c470: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-0000c480: 2020 2020 6f74 6865 725f 7472 616e 7320      other_trans 
-0000c490: 3d20 6f74 6865 722e 5f74 7261 6e73 706f  = other._transpo
-0000c4a0: 7365 2873 656c 662e 5f69 6e76 6178 6573  se(self._invaxes
-0000c4b0: 290a 2020 2020 2020 2020 6966 206f 7468  ).        if oth
-0000c4c0: 6572 5f74 7261 6e73 2069 7320 6e6f 7420  er_trans is not 
-0000c4d0: 4e6f 6e65 2061 6e64 206e 6f74 2069 7369  None and not isi
-0000c4e0: 6e73 7461 6e63 6528 6f74 6865 725f 7472  nstance(other_tr
-0000c4f0: 616e 732c 2054 7261 6e73 706f 7365 293a  ans, Transpose):
-0000c500: 0a20 2020 2020 2020 2020 2020 2023 2054  .            # T
-0000c510: 6865 2073 6563 6f6e 6420 636c 6175 7365  he second clause
-0000c520: 2069 7320 746f 2061 766f 6964 2069 6e66   is to avoid inf
-0000c530: 696e 6974 6520 7265 6375 7273 696f 6e73  inite recursions
-0000c540: 3b20 7365 650a 2020 2020 2020 2020 2020  ; see.          
-0000c550: 2020 2320 7465 7374 732e 7465 7374 5f65    # tests.test_e
-0000c560: 7661 6c75 6162 6c65 2e73 696d 706c 6966  valuable.simplif
-0000c570: 792e 7465 7374 5f6d 756c 7469 706c 795f  y.test_multiply_
-0000c580: 7472 616e 7370 6f73 652e 0a20 2020 2020  transpose..     
-0000c590: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
-0000c5a0: 616e 7370 6f73 6528 4d75 6c74 6970 6c79  anspose(Multiply
-0000c5b0: 285b 7365 6c66 2e66 756e 632c 206f 7468  ([self.func, oth
-0000c5c0: 6572 5f74 7261 6e73 5d29 2c20 7365 6c66  er_trans]), self
-0000c5d0: 2e61 7865 7329 0a20 2020 2020 2020 2074  .axes).        t
-0000c5e0: 7279 6d75 6c74 6970 6c79 203d 2073 656c  rymultiply = sel
-0000c5f0: 662e 6675 6e63 2e5f 6d75 6c74 6970 6c79  f.func._multiply
-0000c600: 2854 7261 6e73 706f 7365 286f 7468 6572  (Transpose(other
-0000c610: 2c20 7365 6c66 2e5f 696e 7661 7865 7329  , self._invaxes)
-0000c620: 290a 2020 2020 2020 2020 6966 2074 7279  ).        if try
-0000c630: 6d75 6c74 6970 6c79 2069 7320 6e6f 7420  multiply is not 
-0000c640: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0000c650: 2020 7265 7475 726e 2054 7261 6e73 706f    return Transpo
-0000c660: 7365 2874 7279 6d75 6c74 6970 6c79 2c20  se(trymultiply, 
-0000c670: 7365 6c66 2e61 7865 7329 0a0a 2020 2020  self.axes)..    
-0000c680: 6465 6620 5f61 6464 2873 656c 662c 206f  def _add(self, o
-0000c690: 7468 6572 293a 0a20 2020 2020 2020 206f  ther):.        o
-0000c6a0: 7468 6572 5f74 7261 6e73 203d 206f 7468  ther_trans = oth
-0000c6b0: 6572 2e5f 7472 616e 7370 6f73 6528 7365  er._transpose(se
-0000c6c0: 6c66 2e5f 696e 7661 7865 7329 0a20 2020  lf._invaxes).   
-0000c6d0: 2020 2020 2069 6620 6f74 6865 725f 7472       if other_tr
-0000c6e0: 616e 7320 6973 206e 6f74 204e 6f6e 6520  ans is not None 
-0000c6f0: 616e 6420 6e6f 7420 6973 696e 7374 616e  and not isinstan
-0000c700: 6365 286f 7468 6572 5f74 7261 6e73 2c20  ce(other_trans, 
-0000c710: 5472 616e 7370 6f73 6529 3a0a 2020 2020  Transpose):.    
-0000c720: 2020 2020 2020 2020 2320 5468 6520 7365          # The se
-0000c730: 636f 6e64 2063 6c61 7573 6520 6973 2074  cond clause is t
-0000c740: 6f20 6176 6f69 6420 696e 6669 6e69 7465  o avoid infinite
-0000c750: 2072 6563 7572 7369 6f6e 730a 2020 2020   recursions.    
-0000c760: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-0000c770: 7261 6e73 706f 7365 2873 656c 662e 6675  ranspose(self.fu
-0000c780: 6e63 202b 206f 7468 6572 5f74 7261 6e73  nc + other_trans
-0000c790: 2c20 7365 6c66 2e61 7865 7329 0a20 2020  , self.axes).   
-0000c7a0: 2020 2020 2074 7279 6164 6420 3d20 7365       tryadd = se
-0000c7b0: 6c66 2e66 756e 632e 5f61 6464 2854 7261  lf.func._add(Tra
-0000c7c0: 6e73 706f 7365 286f 7468 6572 2c20 7365  nspose(other, se
-0000c7d0: 6c66 2e5f 696e 7661 7865 7329 290a 2020  lf._invaxes)).  
-0000c7e0: 2020 2020 2020 6966 2074 7279 6164 6420        if tryadd 
-0000c7f0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
-0000c800: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000c810: 5472 616e 7370 6f73 6528 7472 7961 6464  Transpose(tryadd
-0000c820: 2c20 7365 6c66 2e61 7865 7329 0a0a 2020  , self.axes)..  
-0000c830: 2020 6465 6620 5f74 616b 6528 7365 6c66    def _take(self
-0000c840: 2c20 696e 6469 6365 732c 2061 7869 7329  , indices, axis)
-0000c850: 3a0a 2020 2020 2020 2020 7472 7974 616b  :.        trytak
-0000c860: 6520 3d20 7365 6c66 2e66 756e 632e 5f74  e = self.func._t
-0000c870: 616b 6528 696e 6469 6365 732c 2073 656c  ake(indices, sel
-0000c880: 662e 6178 6573 5b61 7869 735d 290a 2020  f.axes[axis]).  
-0000c890: 2020 2020 2020 6966 2074 7279 7461 6b65        if trytake
-0000c8a0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
-0000c8b0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000c8c0: 2054 7261 6e73 706f 7365 2874 7279 7461   Transpose(tryta
-0000c8d0: 6b65 2c20 7365 6c66 2e5f 6178 6573 5f66  ke, self._axes_f
-0000c8e0: 6f72 2869 6e64 6963 6573 2e6e 6469 6d2c  or(indices.ndim,
-0000c8f0: 2061 7869 7329 290a 2020 2020 2020 2020   axis)).        
-0000c900: 6966 2073 656c 662e 6178 6573 5b61 7869  if self.axes[axi
-0000c910: 735d 203d 3d20 7365 6c66 2e6e 6469 6d20  s] == self.ndim 
-0000c920: 2d20 313a 0a20 2020 2020 2020 2020 2020  - 1:.           
-0000c930: 2072 6574 7572 6e20 5472 616e 7370 6f73   return Transpos
-0000c940: 6528 5461 6b65 2873 656c 662e 6675 6e63  e(Take(self.func
-0000c950: 2c20 696e 6469 6365 7329 2c20 7365 6c66  , indices), self
-0000c960: 2e5f 6178 6573 5f66 6f72 2869 6e64 6963  ._axes_for(indic
-0000c970: 6573 2e6e 6469 6d2c 2061 7869 7329 290a  es.ndim, axis)).
-0000c980: 0a20 2020 2064 6566 205f 6178 6573 5f66  .    def _axes_f
-0000c990: 6f72 2873 656c 662c 206e 6469 6d2c 2061  or(self, ndim, a
-0000c9a0: 7869 7329 3a0a 2020 2020 2020 2020 6675  xis):.        fu
-0000c9b0: 6e63 6178 6973 203d 2073 656c 662e 6178  ncaxis = self.ax
-0000c9c0: 6573 5b61 7869 735d 0a20 2020 2020 2020  es[axis].       
-0000c9d0: 2061 7865 7320 3d20 5b61 782b 2861 7820   axes = [ax+(ax 
-0000c9e0: 3e20 6675 6e63 6178 6973 292a 286e 6469  > funcaxis)*(ndi
-0000c9f0: 6d2d 3129 2066 6f72 2061 7820 696e 2073  m-1) for ax in s
-0000ca00: 656c 662e 6178 6573 2069 6620 6178 2021  elf.axes if ax !
-0000ca10: 3d20 6675 6e63 6178 6973 5d0a 2020 2020  = funcaxis].    
-0000ca20: 2020 2020 6178 6573 5b61 7869 733a 6178      axes[axis:ax
-0000ca30: 6973 5d20 3d20 7261 6e67 6528 6675 6e63  is] = range(func
-0000ca40: 6178 6973 2c20 6675 6e63 6178 6973 202b  axis, funcaxis +
-0000ca50: 206e 6469 6d29 0a20 2020 2020 2020 2072   ndim).        r
-0000ca60: 6574 7572 6e20 6178 6573 0a0a 2020 2020  eturn axes..    
-0000ca70: 6465 6620 5f70 6f77 6572 2873 656c 662c  def _power(self,
-0000ca80: 206e 293a 0a20 2020 2020 2020 206e 5f74   n):.        n_t
-0000ca90: 7261 6e73 203d 2054 7261 6e73 706f 7365  rans = Transpose
-0000caa0: 286e 2c20 7365 6c66 2e5f 696e 7661 7865  (n, self._invaxe
-0000cab0: 7329 0a20 2020 2020 2020 2072 6574 7572  s).        retur
-0000cac0: 6e20 5472 616e 7370 6f73 6528 506f 7765  n Transpose(Powe
-0000cad0: 7228 7365 6c66 2e66 756e 632c 206e 5f74  r(self.func, n_t
-0000cae0: 7261 6e73 292c 2073 656c 662e 6178 6573  rans), self.axes
-0000caf0: 290a 0a20 2020 2064 6566 205f 7369 676e  )..    def _sign
-0000cb00: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000cb10: 7265 7475 726e 2054 7261 6e73 706f 7365  return Transpose
-0000cb20: 2853 6967 6e28 7365 6c66 2e66 756e 6329  (Sign(self.func)
-0000cb30: 2c20 7365 6c66 2e61 7865 7329 0a0a 2020  , self.axes)..  
-0000cb40: 2020 6465 6620 5f75 6e72 6176 656c 2873    def _unravel(s
-0000cb50: 656c 662c 2061 7869 732c 2073 6861 7065  elf, axis, shape
-0000cb60: 293a 0a20 2020 2020 2020 206f 7269 675f  ):.        orig_
-0000cb70: 6178 6973 203d 2073 656c 662e 6178 6573  axis = self.axes
-0000cb80: 5b61 7869 735d 0a20 2020 2020 2020 2074  [axis].        t
-0000cb90: 7279 756e 7261 7665 6c20 3d20 7365 6c66  ryunravel = self
-0000cba0: 2e66 756e 632e 5f75 6e72 6176 656c 286f  .func._unravel(o
-0000cbb0: 7269 675f 6178 6973 2c20 7368 6170 6529  rig_axis, shape)
-0000cbc0: 0a20 2020 2020 2020 2069 6620 7472 7975  .        if tryu
-0000cbd0: 6e72 6176 656c 2069 7320 6e6f 7420 4e6f  nravel is not No
-0000cbe0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-0000cbf0: 6178 6573 203d 205b 6178 202b 2028 6178  axes = [ax + (ax
-0000cc00: 203e 206f 7269 675f 6178 6973 2920 666f   > orig_axis) fo
-0000cc10: 7220 6178 2069 6e20 7365 6c66 2e61 7865  r ax in self.axe
-0000cc20: 735d 0a20 2020 2020 2020 2020 2020 2061  s].            a
-0000cc30: 7865 732e 696e 7365 7274 2861 7869 732b  xes.insert(axis+
-0000cc40: 312c 206f 7269 675f 6178 6973 2b31 290a  1, orig_axis+1).
-0000cc50: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000cc60: 726e 2054 7261 6e73 706f 7365 2874 7279  rn Transpose(try
-0000cc70: 756e 7261 7665 6c2c 2061 7865 7329 0a0a  unravel, axes)..
-0000cc80: 2020 2020 6465 6620 5f70 726f 6475 6374      def _product
-0000cc90: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000cca0: 6966 2073 656c 662e 6178 6573 5b2d 315d  if self.axes[-1]
-0000ccb0: 203d 3d20 7365 6c66 2e6e 6469 6d2d 313a   == self.ndim-1:
-0000ccc0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000ccd0: 7572 6e20 5472 616e 7370 6f73 6528 5072  urn Transpose(Pr
-0000cce0: 6f64 7563 7428 7365 6c66 2e66 756e 6329  oduct(self.func)
-0000ccf0: 2c20 7365 6c66 2e61 7865 735b 3a2d 315d  , self.axes[:-1]
-0000cd00: 290a 0a20 2020 2064 6566 205f 6465 7465  )..    def _dete
-0000cd10: 726d 696e 616e 7428 7365 6c66 2c20 6178  rminant(self, ax
-0000cd20: 6973 312c 2061 7869 7332 293a 0a20 2020  is1, axis2):.   
-0000cd30: 2020 2020 206f 7269 6731 2c20 6f72 6967       orig1, orig
-0000cd40: 3220 3d20 7365 6c66 2e61 7865 735b 6178  2 = self.axes[ax
-0000cd50: 6973 315d 2c20 7365 6c66 2e61 7865 735b  is1], self.axes[
-0000cd60: 6178 6973 325d 0a20 2020 2020 2020 2074  axis2].        t
-0000cd70: 7279 6465 7420 3d20 7365 6c66 2e66 756e  rydet = self.fun
-0000cd80: 632e 5f64 6574 6572 6d69 6e61 6e74 286f  c._determinant(o
-0000cd90: 7269 6731 2c20 6f72 6967 3229 0a20 2020  rig1, orig2).   
-0000cda0: 2020 2020 2069 6620 7472 7964 6574 3a0a       if trydet:.
-0000cdb0: 2020 2020 2020 2020 2020 2020 6178 6573              axes
-0000cdc0: 203d 205b 6178 2d28 6178 203e 206f 7269   = [ax-(ax > ori
-0000cdd0: 6731 292d 2861 7820 3e20 6f72 6967 3229  g1)-(ax > orig2)
-0000cde0: 2066 6f72 2061 7820 696e 2073 656c 662e   for ax in self.
-0000cdf0: 6178 6573 2069 6620 6178 2021 3d20 6f72  axes if ax != or
-0000ce00: 6967 3120 616e 6420 6178 2021 3d20 6f72  ig1 and ax != or
-0000ce10: 6967 325d 0a20 2020 2020 2020 2020 2020  ig2].           
-0000ce20: 2072 6574 7572 6e20 5472 616e 7370 6f73   return Transpos
-0000ce30: 6528 7472 7964 6574 2c20 6178 6573 290a  e(trydet, axes).
-0000ce40: 0a20 2020 2064 6566 205f 696e 7665 7273  .    def _invers
-0000ce50: 6528 7365 6c66 2c20 6178 6973 312c 2061  e(self, axis1, a
-0000ce60: 7869 7332 293a 0a20 2020 2020 2020 2074  xis2):.        t
-0000ce70: 7279 696e 7620 3d20 7365 6c66 2e66 756e  ryinv = self.fun
-0000ce80: 632e 5f69 6e76 6572 7365 2873 656c 662e  c._inverse(self.
-0000ce90: 6178 6573 5b61 7869 7331 5d2c 2073 656c  axes[axis1], sel
-0000cea0: 662e 6178 6573 5b61 7869 7332 5d29 0a20  f.axes[axis2]). 
-0000ceb0: 2020 2020 2020 2069 6620 7472 7969 6e76         if tryinv
-0000cec0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000ced0: 7475 726e 2054 7261 6e73 706f 7365 2874  turn Transpose(t
-0000cee0: 7279 696e 762c 2073 656c 662e 6178 6573  ryinv, self.axes
-0000cef0: 290a 0a20 2020 2064 6566 205f 7261 7665  )..    def _rave
-0000cf00: 6c28 7365 6c66 2c20 6178 6973 293a 0a20  l(self, axis):. 
-0000cf10: 2020 2020 2020 2069 6620 7365 6c66 2e61         if self.a
-0000cf20: 7865 735b 6178 6973 5d20 3d3d 2073 656c  xes[axis] == sel
-0000cf30: 662e 6e64 696d 2d32 2061 6e64 2073 656c  f.ndim-2 and sel
-0000cf40: 662e 6178 6573 5b61 7869 732b 315d 203d  f.axes[axis+1] =
-0000cf50: 3d20 7365 6c66 2e6e 6469 6d2d 313a 0a20  = self.ndim-1:. 
-0000cf60: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000cf70: 6e20 5472 616e 7370 6f73 6528 5261 7665  n Transpose(Rave
-0000cf80: 6c28 7365 6c66 2e66 756e 6329 2c20 7365  l(self.func), se
-0000cf90: 6c66 2e61 7865 735b 3a2d 315d 290a 0a20  lf.axes[:-1]).. 
-0000cfa0: 2020 2064 6566 205f 696e 666c 6174 6528     def _inflate(
-0000cfb0: 7365 6c66 2c20 646f 666d 6170 2c20 6c65  self, dofmap, le
-0000cfc0: 6e67 7468 2c20 6178 6973 293a 0a20 2020  ngth, axis):.   
-0000cfd0: 2020 2020 2069 203d 2073 656c 662e 6178       i = self.ax
-0000cfe0: 6573 5b61 7869 735d 2069 6620 646f 666d  es[axis] if dofm
-0000cff0: 6170 2e6e 6469 6d20 656c 7365 2073 656c  ap.ndim else sel
-0000d000: 662e 6675 6e63 2e6e 6469 6d0a 2020 2020  f.func.ndim.    
-0000d010: 2020 2020 6966 2073 656c 662e 6178 6573      if self.axes
-0000d020: 5b61 7869 733a 6178 6973 2b64 6f66 6d61  [axis:axis+dofma
-0000d030: 702e 6e64 696d 5d20 3d3d 2074 7570 6c65  p.ndim] == tuple
-0000d040: 2872 616e 6765 2869 2c20 692b 646f 666d  (range(i, i+dofm
-0000d050: 6170 2e6e 6469 6d29 293a 0a20 2020 2020  ap.ndim)):.     
-0000d060: 2020 2020 2020 2074 7279 696e 666c 6174         tryinflat
-0000d070: 6520 3d20 7365 6c66 2e66 756e 632e 5f69  e = self.func._i
-0000d080: 6e66 6c61 7465 2864 6f66 6d61 702c 206c  nflate(dofmap, l
-0000d090: 656e 6774 682c 2069 290a 2020 2020 2020  ength, i).      
-0000d0a0: 2020 2020 2020 6966 2074 7279 696e 666c        if tryinfl
-0000d0b0: 6174 6520 6973 206e 6f74 204e 6f6e 653a  ate is not None:
-0000d0c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d0d0: 2061 7865 7320 3d20 5b61 782d 2861 7820   axes = [ax-(ax 
-0000d0e0: 3e20 6929 2a28 646f 666d 6170 2e6e 6469  > i)*(dofmap.ndi
-0000d0f0: 6d2d 3129 2066 6f72 2061 7820 696e 2073  m-1) for ax in s
-0000d100: 656c 662e 6178 6573 5d0a 2020 2020 2020  elf.axes].      
-0000d110: 2020 2020 2020 2020 2020 6178 6573 5b61            axes[a
-0000d120: 7869 733a 6178 6973 2b64 6f66 6d61 702e  xis:axis+dofmap.
-0000d130: 6e64 696d 5d20 3d20 692c 0a20 2020 2020  ndim] = i,.     
-0000d140: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000d150: 6e20 5472 616e 7370 6f73 6528 7472 7969  n Transpose(tryi
-0000d160: 6e66 6c61 7465 2c20 6178 6573 290a 0a20  nflate, axes).. 
-0000d170: 2020 2064 6566 205f 6469 6167 6f6e 616c     def _diagonal
-0000d180: 697a 6528 7365 6c66 2c20 6178 6973 293a  ize(self, axis):
-0000d190: 0a20 2020 2020 2020 2074 7279 6469 6167  .        trydiag
-0000d1a0: 6f6e 616c 697a 6520 3d20 7365 6c66 2e66  onalize = self.f
-0000d1b0: 756e 632e 5f64 6961 676f 6e61 6c69 7a65  unc._diagonalize
-0000d1c0: 2873 656c 662e 6178 6573 5b61 7869 735d  (self.axes[axis]
-0000d1d0: 290a 2020 2020 2020 2020 6966 2074 7279  ).        if try
-0000d1e0: 6469 6167 6f6e 616c 697a 6520 6973 206e  diagonalize is n
-0000d1f0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-0000d200: 2020 2020 2072 6574 7572 6e20 5472 616e       return Tran
-0000d210: 7370 6f73 6528 7472 7964 6961 676f 6e61  spose(trydiagona
-0000d220: 6c69 7a65 2c20 7365 6c66 2e61 7865 7320  lize, self.axes 
-0000d230: 2b20 2873 656c 662e 6e64 696d 2c29 290a  + (self.ndim,)).
-0000d240: 0a20 2020 2064 6566 205f 696e 7365 7274  .    def _insert
-0000d250: 6178 6973 2873 656c 662c 2061 7869 732c  axis(self, axis,
-0000d260: 206c 656e 6774 6829 3a0a 2020 2020 2020   length):.      
-0000d270: 2020 7265 7475 726e 2054 7261 6e73 706f    return Transpo
-0000d280: 7365 2849 6e73 6572 7441 7869 7328 7365  se(InsertAxis(se
-0000d290: 6c66 2e66 756e 632c 206c 656e 6774 6829  lf.func, length)
-0000d2a0: 2c20 7365 6c66 2e61 7865 735b 3a61 7869  , self.axes[:axi
-0000d2b0: 735d 202b 2028 7365 6c66 2e6e 6469 6d2c  s] + (self.ndim,
-0000d2c0: 2920 2b20 7365 6c66 2e61 7865 735b 6178  ) + self.axes[ax
-0000d2d0: 6973 3a5d 290a 0a20 2020 2064 6566 205f  is:])..    def _
-0000d2e0: 6c6f 6f70 7375 6d28 7365 6c66 2c20 696e  loopsum(self, in
-0000d2f0: 6465 7829 3a0a 2020 2020 2020 2020 7265  dex):.        re
-0000d300: 7475 726e 2054 7261 6e73 706f 7365 286c  turn Transpose(l
-0000d310: 6f6f 705f 7375 6d28 7365 6c66 2e66 756e  oop_sum(self.fun
-0000d320: 632c 2069 6e64 6578 292c 2073 656c 662e  c, index), self.
-0000d330: 6178 6573 290a 0a20 2020 2040 7072 6f70  axes)..    @prop
-0000d340: 6572 7479 0a20 2020 2064 6566 205f 6173  erty.    def _as
-0000d350: 7370 6172 7365 2873 656c 6629 3a0a 2020  sparse(self):.  
-0000d360: 2020 2020 2020 7265 7475 726e 2074 7570        return tup
-0000d370: 6c65 2828 2a28 696e 6469 6365 735b 695d  le((*(indices[i]
-0000d380: 2066 6f72 2069 2069 6e20 7365 6c66 2e61   for i in self.a
-0000d390: 7865 7329 2c20 7661 6c75 6573 2920 666f  xes), values) fo
-0000d3a0: 7220 2a69 6e64 6963 6573 2c20 7661 6c75  r *indices, valu
-0000d3b0: 6573 2069 6e20 7365 6c66 2e66 756e 632e  es in self.func.
-0000d3c0: 5f61 7373 7061 7273 6529 0a0a 2020 2020  _assparse)..    
-0000d3d0: 6465 6620 5f69 6e74 626f 756e 6473 5f69  def _intbounds_i
-0000d3e0: 6d70 6c28 7365 6c66 293a 0a20 2020 2020  mpl(self):.     
-0000d3f0: 2020 2072 6574 7572 6e20 7365 6c66 2e66     return self.f
-0000d400: 756e 632e 5f69 6e74 626f 756e 6473 0a0a  unc._intbounds..
-0000d410: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-0000d420: 2020 6465 6620 5f63 6f6e 7374 5f75 6e69    def _const_uni
-0000d430: 666f 726d 2873 656c 6629 3a0a 2020 2020  form(self):.    
-0000d440: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0000d450: 6675 6e63 2e5f 636f 6e73 745f 756e 6966  func._const_unif
-0000d460: 6f72 6d0a 0a0a 636c 6173 7320 5072 6f64  orm...class Prod
-0000d470: 7563 7428 4172 7261 7929 3a0a 0a20 2020  uct(Array):..   
-0000d480: 205f 5f73 6c6f 7473 5f5f 203d 2027 6675   __slots__ = 'fu
-0000d490: 6e63 272c 0a0a 2020 2020 4074 7970 6573  nc',..    @types
-0000d4a0: 2e61 7070 6c79 5f61 6e6e 6f74 6174 696f  .apply_annotatio
-0000d4b0: 6e73 0a20 2020 2064 6566 205f 5f69 6e69  ns.    def __ini
-0000d4c0: 745f 5f28 7365 6c66 2c20 6675 6e63 3a20  t__(self, func: 
-0000d4d0: 6173 6172 7261 7929 3a0a 2020 2020 2020  asarray):.      
-0000d4e0: 2020 6173 7365 7274 2066 756e 632e 6474    assert func.dt
-0000d4f0: 7970 6520 213d 2062 6f6f 6c2c 2027 5072  ype != bool, 'Pr
-0000d500: 6f64 7563 7428 7b7d 2927 2e66 6f72 6d61  oduct({})'.forma
-0000d510: 7428 6675 6e63 290a 2020 2020 2020 2020  t(func).        
-0000d520: 7365 6c66 2e66 756e 6320 3d20 6675 6e63  self.func = func
-0000d530: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
-0000d540: 2e5f 5f69 6e69 745f 5f28 6172 6773 3d5b  .__init__(args=[
-0000d550: 6675 6e63 5d2c 2073 6861 7065 3d66 756e  func], shape=fun
-0000d560: 632e 7368 6170 655b 3a2d 315d 2c20 6474  c.shape[:-1], dt
-0000d570: 7970 653d 6675 6e63 2e64 7479 7065 290a  ype=func.dtype).
-0000d580: 0a20 2020 2064 6566 205f 7369 6d70 6c69  .    def _simpli
-0000d590: 6669 6564 2873 656c 6629 3a0a 2020 2020  fied(self):.    
-0000d5a0: 2020 2020 6966 2065 7175 616c 696e 6465      if equalinde
-0000d5b0: 7828 7365 6c66 2e66 756e 632e 7368 6170  x(self.func.shap
-0000d5c0: 655b 2d31 5d2c 2031 293a 0a20 2020 2020  e[-1], 1):.     
-0000d5d0: 2020 2020 2020 2072 6574 7572 6e20 6765         return ge
-0000d5e0: 7428 7365 6c66 2e66 756e 632c 2073 656c  t(self.func, sel
-0000d5f0: 662e 6e64 696d 2c20 3029 0a20 2020 2020  f.ndim, 0).     
-0000d600: 2020 2072 6574 7572 6e20 7365 6c66 2e66     return self.f
-0000d610: 756e 632e 5f70 726f 6475 6374 2829 0a0a  unc._product()..
-0000d620: 2020 2020 6465 6620 6576 616c 6628 7365      def evalf(se
-0000d630: 6c66 2c20 6172 7229 3a0a 2020 2020 2020  lf, arr):.      
-0000d640: 2020 6173 7365 7274 2061 7272 2e6e 6469    assert arr.ndi
-0000d650: 6d20 3d3d 2073 656c 662e 6e64 696d 2b31  m == self.ndim+1
-0000d660: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000d670: 6e75 6d70 792e 7072 6f64 7563 7428 6172  numpy.product(ar
-0000d680: 722c 2061 7869 733d 2d31 290a 0a20 2020  r, axis=-1)..   
-0000d690: 2064 6566 205f 6465 7269 7661 7469 7665   def _derivative
-0000d6a0: 2873 656c 662c 2076 6172 2c20 7365 656e  (self, var, seen
-0000d6b0: 293a 0a20 2020 2020 2020 2067 7261 6420  ):.        grad 
-0000d6c0: 3d20 6465 7269 7661 7469 7665 2873 656c  = derivative(sel
-0000d6d0: 662e 6675 6e63 2c20 7661 722c 2073 6565  f.func, var, see
-0000d6e0: 6e29 0a20 2020 2020 2020 2066 756e 6373  n).        funcs
-0000d6f0: 203d 2050 726f 6475 6374 2869 6e73 6572   = Product(inser
-0000d700: 7461 7869 7328 7365 6c66 2e66 756e 632c  taxis(self.func,
-0000d710: 202d 322c 2073 656c 662e 6675 6e63 2e73   -2, self.func.s
-0000d720: 6861 7065 5b2d 315d 2920 2b20 4469 6167  hape[-1]) + Diag
-0000d730: 6f6e 616c 697a 6528 3120 2d20 7365 6c66  onalize(1 - self
-0000d740: 2e66 756e 6329 2920 2023 2072 6570 6c61  .func))  # repla
-0000d750: 6365 2064 6961 676f 6e61 6c20 656e 7472  ce diagonal entr
-0000d760: 6965 7320 6279 2031 0a20 2020 2020 2020  ies by 1.       
-0000d770: 2072 6574 7572 6e20 6569 6e73 756d 2827   return einsum('
-0000d780: 4169 2c41 6942 2d3e 4142 272c 2066 756e  Ai,AiB->AB', fun
-0000d790: 6373 2c20 6772 6164 290a 0a20 2020 2064  cs, grad)..    d
-0000d7a0: 6566 205f 7461 6b65 2873 656c 662c 2069  ef _take(self, i
-0000d7b0: 6e64 6963 6573 2c20 6178 6973 293a 0a20  ndices, axis):. 
-0000d7c0: 2020 2020 2020 2072 6574 7572 6e20 5072         return Pr
-0000d7d0: 6f64 7563 7428 5f74 616b 6528 7365 6c66  oduct(_take(self
-0000d7e0: 2e66 756e 632c 2069 6e64 6963 6573 2c20  .func, indices, 
-0000d7f0: 6178 6973 2929 0a0a 2020 2020 6465 6620  axis))..    def 
-0000d800: 5f74 616b 6564 6961 6728 7365 6c66 2c20  _takediag(self, 
-0000d810: 6178 6973 312c 2061 7869 7332 293a 0a20  axis1, axis2):. 
-0000d820: 2020 2020 2020 2072 6574 7572 6e20 7072         return pr
-0000d830: 6f64 7563 7428 5f74 616b 6564 6961 6728  oduct(_takediag(
-0000d840: 7365 6c66 2e66 756e 632c 2061 7869 7331  self.func, axis1
-0000d850: 2c20 6178 6973 3229 2c20 7365 6c66 2e6e  , axis2), self.n
-0000d860: 6469 6d2d 3229 0a0a 0a63 6c61 7373 2049  dim-2)...class I
-0000d870: 6e76 6572 7365 2841 7272 6179 293a 0a20  nverse(Array):. 
-0000d880: 2020 2027 2727 0a20 2020 204d 6174 7269     '''.    Matri
-0000d890: 7820 696e 7665 7273 6520 6f66 2060 6066  x inverse of ``f
-0000d8a0: 756e 6360 6020 6f76 6572 2074 6865 206c  unc`` over the l
-0000d8b0: 6173 7420 7477 6f20 6178 6573 2e20 2041  ast two axes.  A
-0000d8c0: 6c6c 206f 7468 6572 2061 7865 7320 6172  ll other axes ar
-0000d8d0: 650a 2020 2020 7472 6561 7465 6420 656c  e.    treated el
-0000d8e0: 656d 656e 742d 7769 7365 2e0a 2020 2020  ement-wise..    
-0000d8f0: 2727 270a 0a20 2020 205f 5f73 6c6f 7473  '''..    __slots
-0000d900: 5f5f 203d 2027 6675 6e63 272c 0a0a 2020  __ = 'func',..  
-0000d910: 2020 4074 7970 6573 2e61 7070 6c79 5f61    @types.apply_a
-0000d920: 6e6e 6f74 6174 696f 6e73 0a20 2020 2064  nnotations.    d
-0000d930: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
-0000d940: 2c20 6675 6e63 3a20 6173 6172 7261 7929  , func: asarray)
-0000d950: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
-0000d960: 2066 756e 632e 6e64 696d 203e 3d20 3220   func.ndim >= 2 
-0000d970: 616e 6420 6571 7561 6c69 6e64 6578 2866  and equalindex(f
-0000d980: 756e 632e 7368 6170 655b 2d31 5d2c 2066  unc.shape[-1], f
-0000d990: 756e 632e 7368 6170 655b 2d32 5d29 0a20  unc.shape[-2]). 
-0000d9a0: 2020 2020 2020 2073 656c 662e 6675 6e63         self.func
-0000d9b0: 203d 2066 756e 630a 2020 2020 2020 2020   = func.        
-0000d9c0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-0000d9d0: 2861 7267 733d 5b66 756e 635d 2c20 7368  (args=[func], sh
-0000d9e0: 6170 653d 6675 6e63 2e73 6861 7065 2c20  ape=func.shape, 
-0000d9f0: 6474 7970 653d 636f 6d70 6c65 7820 6966  dtype=complex if
-0000da00: 2066 756e 632e 6474 7970 6520 3d3d 2063   func.dtype == c
-0000da10: 6f6d 706c 6578 2065 6c73 6520 666c 6f61  omplex else floa
-0000da20: 7429 0a0a 2020 2020 6465 6620 5f73 696d  t)..    def _sim
-0000da30: 706c 6966 6965 6428 7365 6c66 293a 0a20  plified(self):. 
-0000da40: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
-0000da50: 7365 6c66 2e66 756e 632e 5f69 6e76 6572  self.func._inver
-0000da60: 7365 2873 656c 662e 6e64 696d 2d32 2c20  se(self.ndim-2, 
-0000da70: 7365 6c66 2e6e 6469 6d2d 3129 0a20 2020  self.ndim-1).   
-0000da80: 2020 2020 2069 6620 7265 7375 6c74 2069       if result i
-0000da90: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-0000daa0: 2020 2020 2020 2020 7265 7475 726e 2072          return r
-0000dab0: 6573 756c 740a 2020 2020 2020 2020 6966  esult.        if
-0000dac0: 2065 7175 616c 696e 6465 7828 7365 6c66   equalindex(self
-0000dad0: 2e66 756e 632e 7368 6170 655b 2d31 5d2c  .func.shape[-1],
-0000dae0: 2031 293a 0a20 2020 2020 2020 2020 2020   1):.           
-0000daf0: 2072 6574 7572 6e20 7265 6369 7072 6f63   return reciproc
-0000db00: 616c 2873 656c 662e 6675 6e63 290a 0a20  al(self.func).. 
-0000db10: 2020 2064 6566 2065 7661 6c66 2873 656c     def evalf(sel
-0000db20: 662c 2061 7272 293a 0a20 2020 2020 2020  f, arr):.       
-0000db30: 2072 6574 7572 6e20 6e75 6d65 7269 632e   return numeric.
-0000db40: 696e 7628 6172 7229 0a0a 2020 2020 6465  inv(arr)..    de
-0000db50: 6620 5f64 6572 6976 6174 6976 6528 7365  f _derivative(se
-0000db60: 6c66 2c20 7661 722c 2073 6565 6e29 3a0a  lf, var, seen):.
-0000db70: 2020 2020 2020 2020 7265 7475 726e 202d          return -
-0000db80: 6569 6e73 756d 2827 4169 6a2c 416a 6b42  einsum('Aij,AjkB
-0000db90: 2c41 6b6c 2d3e 4169 6c42 272c 2073 656c  ,Akl->AilB', sel
-0000dba0: 662c 2064 6572 6976 6174 6976 6528 7365  f, derivative(se
-0000dbb0: 6c66 2e66 756e 632c 2076 6172 2c20 7365  lf.func, var, se
-0000dbc0: 656e 292c 2073 656c 6629 0a0a 2020 2020  en), self)..    
-0000dbd0: 6465 6620 5f65 6967 2873 656c 662c 2073  def _eig(self, s
-0000dbe0: 796d 6d65 7472 6963 293a 0a20 2020 2020  ymmetric):.     
-0000dbf0: 2020 2065 6967 7661 6c2c 2065 6967 7665     eigval, eigve
-0000dc00: 6320 3d20 4569 6728 7365 6c66 2e66 756e  c = Eig(self.fun
-0000dc10: 632c 2073 796d 6d65 7472 6963 290a 2020  c, symmetric).  
-0000dc20: 2020 2020 2020 7265 7475 726e 2054 7570        return Tup
-0000dc30: 6c65 2828 7265 6369 7072 6f63 616c 2865  le((reciprocal(e
-0000dc40: 6967 7661 6c29 2c20 6569 6776 6563 2929  igval), eigvec))
-0000dc50: 0a0a 2020 2020 6465 6620 5f64 6574 6572  ..    def _deter
-0000dc60: 6d69 6e61 6e74 2873 656c 662c 2061 7869  minant(self, axi
-0000dc70: 7331 2c20 6178 6973 3229 3a0a 2020 2020  s1, axis2):.    
-0000dc80: 2020 2020 6966 2073 6f72 7465 6428 5b61      if sorted([a
-0000dc90: 7869 7331 2c20 6178 6973 325d 2920 3d3d  xis1, axis2]) ==
-0000dca0: 205b 7365 6c66 2e6e 6469 6d2d 322c 2073   [self.ndim-2, s
-0000dcb0: 656c 662e 6e64 696d 2d31 5d3a 0a20 2020  elf.ndim-1]:.   
-0000dcc0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000dcd0: 7265 6369 7072 6f63 616c 2844 6574 6572  reciprocal(Deter
-0000dce0: 6d69 6e61 6e74 2873 656c 662e 6675 6e63  minant(self.func
-0000dcf0: 2929 0a0a 2020 2020 6465 6620 5f74 616b  ))..    def _tak
-0000dd00: 6528 7365 6c66 2c20 696e 6469 6365 732c  e(self, indices,
-0000dd10: 2061 7869 7329 3a0a 2020 2020 2020 2020   axis):.        
-0000dd20: 6966 2061 7869 7320 3c20 7365 6c66 2e6e  if axis < self.n
-0000dd30: 6469 6d20 2d20 323a 0a20 2020 2020 2020  dim - 2:.       
-0000dd40: 2020 2020 2072 6574 7572 6e20 496e 7665       return Inve
-0000dd50: 7273 6528 5f74 616b 6528 7365 6c66 2e66  rse(_take(self.f
-0000dd60: 756e 632c 2069 6e64 6963 6573 2c20 6178  unc, indices, ax
-0000dd70: 6973 2929 0a0a 2020 2020 6465 6620 5f74  is))..    def _t
-0000dd80: 616b 6564 6961 6728 7365 6c66 2c20 6178  akediag(self, ax
-0000dd90: 6973 312c 2061 7869 7332 293a 0a20 2020  is1, axis2):.   
-0000dda0: 2020 2020 2061 7373 6572 7420 6178 6973       assert axis
-0000ddb0: 3120 3c20 6178 6973 320a 2020 2020 2020  1 < axis2.      
-0000ddc0: 2020 6966 2061 7869 7332 203c 2073 656c    if axis2 < sel
-0000ddd0: 662e 6e64 696d 2d32 3a0a 2020 2020 2020  f.ndim-2:.      
-0000dde0: 2020 2020 2020 7265 7475 726e 2069 6e76        return inv
-0000ddf0: 6572 7365 285f 7461 6b65 6469 6167 2873  erse(_takediag(s
-0000de00: 656c 662e 6675 6e63 2c20 6178 6973 312c  elf.func, axis1,
-0000de10: 2061 7869 7332 292c 2028 7365 6c66 2e6e   axis2), (self.n
-0000de20: 6469 6d2d 342c 2073 656c 662e 6e64 696d  dim-4, self.ndim
-0000de30: 2d33 2929 0a0a 2020 2020 6465 6620 5f75  -3))..    def _u
-0000de40: 6e72 6176 656c 2873 656c 662c 2061 7869  nravel(self, axi
-0000de50: 732c 2073 6861 7065 293a 0a20 2020 2020  s, shape):.     
-0000de60: 2020 2069 6620 6178 6973 203c 2073 656c     if axis < sel
-0000de70: 662e 6e64 696d 2d32 3a0a 2020 2020 2020  f.ndim-2:.      
-0000de80: 2020 2020 2020 7265 7475 726e 2049 6e76        return Inv
-0000de90: 6572 7365 2875 6e72 6176 656c 2873 656c  erse(unravel(sel
-0000dea0: 662e 6675 6e63 2c20 6178 6973 2c20 7368  f.func, axis, sh
-0000deb0: 6170 6529 290a 0a0a 636c 6173 7320 496e  ape))...class In
-0000dec0: 7465 7270 6f6c 6174 6528 4172 7261 7929  terpolate(Array)
-0000ded0: 3a0a 2020 2020 2769 6e74 6572 706f 6c61  :.    'interpola
-0000dee0: 7465 2075 6e69 666f 726d 6c79 2073 7061  te uniformly spa
-0000def0: 6365 6420 6461 7461 3b20 7374 6570 7769  ced data; stepwi
-0000df00: 7365 2066 6f72 206e 6f77 270a 0a20 2020  se for now'..   
-0000df10: 205f 5f73 6c6f 7473 5f5f 203d 2027 7870   __slots__ = 'xp
-0000df20: 272c 2027 6670 272c 2027 6c65 6674 272c  ', 'fp', 'left',
-0000df30: 2027 7269 6768 7427 0a0a 2020 2020 4074   'right'..    @t
-0000df40: 7970 6573 2e61 7070 6c79 5f61 6e6e 6f74  ypes.apply_annot
-0000df50: 6174 696f 6e73 0a20 2020 2064 6566 205f  ations.    def _
-0000df60: 5f69 6e69 745f 5f28 7365 6c66 2c20 783a  _init__(self, x:
-0000df70: 2061 7361 7272 6179 2c20 7870 3a20 7479   asarray, xp: ty
-0000df80: 7065 732e 6172 7261 7964 6174 612c 2066  pes.arraydata, f
-0000df90: 703a 2074 7970 6573 2e61 7272 6179 6461  p: types.arrayda
-0000dfa0: 7461 2c20 6c65 6674 3a20 7479 7065 732e  ta, left: types.
-0000dfb0: 7374 7269 6374 666c 6f61 7420 3d20 4e6f  strictfloat = No
-0000dfc0: 6e65 2c20 7269 6768 743a 2074 7970 6573  ne, right: types
-0000dfd0: 2e73 7472 6963 7466 6c6f 6174 203d 204e  .strictfloat = N
-0000dfe0: 6f6e 6529 3a0a 2020 2020 2020 2020 7870  one):.        xp
-0000dff0: 203d 206e 756d 7079 2e61 7361 7272 6179   = numpy.asarray
-0000e000: 2878 7029 0a20 2020 2020 2020 2066 7020  (xp).        fp 
-0000e010: 3d20 6e75 6d70 792e 6173 6172 7261 7928  = numpy.asarray(
-0000e020: 6670 290a 2020 2020 2020 2020 6173 7365  fp).        asse
-0000e030: 7274 2078 702e 6e64 696d 203d 3d20 6670  rt xp.ndim == fp
-0000e040: 2e6e 6469 6d20 3d3d 2031 0a20 2020 2020  .ndim == 1.     
-0000e050: 2020 2069 6620 6e6f 7420 6e75 6d70 792e     if not numpy.
-0000e060: 6772 6561 7465 7228 6e75 6d70 792e 6469  greater(numpy.di
-0000e070: 6666 2878 7029 2c20 3029 2e61 6c6c 2829  ff(xp), 0).all()
-0000e080: 3a0a 2020 2020 2020 2020 2020 2020 7761  :.            wa
-0000e090: 726e 696e 6773 2e77 6172 6e28 2773 7570  rnings.warn('sup
-0000e0a0: 706c 6965 6420 782d 7661 6c75 6573 2061  plied x-values a
-0000e0b0: 7265 206e 6f6e 2d69 6e63 7265 6173 696e  re non-increasin
-0000e0c0: 6727 290a 2020 2020 2020 2020 6173 7365  g').        asse
-0000e0d0: 7274 2078 2e6e 6469 6d20 3d3d 2030 0a20  rt x.ndim == 0. 
-0000e0e0: 2020 2020 2020 2061 7373 6572 7420 782e         assert x.
-0000e0f0: 6474 7970 6520 213d 2063 6f6d 706c 6578  dtype != complex
-0000e100: 2061 6e64 2078 702e 6474 7970 652e 6b69   and xp.dtype.ki
-0000e110: 6e64 2021 3d20 2763 270a 2020 2020 2020  nd != 'c'.      
-0000e120: 2020 7365 6c66 2e78 7020 3d20 7870 0a20    self.xp = xp. 
-0000e130: 2020 2020 2020 2073 656c 662e 6670 203d         self.fp =
-0000e140: 2066 700a 2020 2020 2020 2020 7365 6c66   fp.        self
-0000e150: 2e6c 6566 7420 3d20 6c65 6674 0a20 2020  .left = left.   
-0000e160: 2020 2020 2073 656c 662e 7269 6768 7420       self.right 
-0000e170: 3d20 7269 6768 740a 2020 2020 2020 2020  = right.        
-0000e180: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-0000e190: 2861 7267 733d 5b78 5d2c 2073 6861 7065  (args=[x], shape
-0000e1a0: 3d28 292c 2064 7479 7065 3d63 6f6d 706c  =(), dtype=compl
-0000e1b0: 6578 2069 6620 6670 2e64 7479 7065 2e6b  ex if fp.dtype.k
-0000e1c0: 696e 6420 3d3d 2027 6327 2065 6c73 6520  ind == 'c' else 
-0000e1d0: 666c 6f61 7429 0a0a 2020 2020 6465 6620  float)..    def 
-0000e1e0: 6576 616c 6628 7365 6c66 2c20 7829 3a0a  evalf(self, x):.
-0000e1f0: 2020 2020 2020 2020 7265 7475 726e 206e          return n
-0000e200: 756d 7079 2e69 6e74 6572 7028 782c 2073  umpy.interp(x, s
-0000e210: 656c 662e 7870 2c20 7365 6c66 2e66 702c  elf.xp, self.fp,
-0000e220: 2073 656c 662e 6c65 6674 2c20 7365 6c66   self.left, self
-0000e230: 2e72 6967 6874 290a 0a0a 636c 6173 7320  .right)...class 
-0000e240: 4465 7465 726d 696e 616e 7428 4172 7261  Determinant(Arra
-0000e250: 7929 3a0a 0a20 2020 205f 5f73 6c6f 7473  y):..    __slots
-0000e260: 5f5f 203d 2027 6675 6e63 272c 0a0a 2020  __ = 'func',..  
-0000e270: 2020 4074 7970 6573 2e61 7070 6c79 5f61    @types.apply_a
-0000e280: 6e6e 6f74 6174 696f 6e73 0a20 2020 2064  nnotations.    d
-0000e290: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
-0000e2a0: 2c20 6675 6e63 3a20 6173 6172 7261 7929  , func: asarray)
-0000e2b0: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
-0000e2c0: 2069 7361 7272 6179 2866 756e 6329 2061   isarray(func) a
-0000e2d0: 6e64 2066 756e 632e 6e64 696d 203e 3d20  nd func.ndim >= 
-0000e2e0: 3220 616e 6420 6571 7561 6c69 6e64 6578  2 and equalindex
-0000e2f0: 2866 756e 632e 7368 6170 655b 2d31 5d2c  (func.shape[-1],
-0000e300: 2066 756e 632e 7368 6170 655b 2d32 5d29   func.shape[-2])
-0000e310: 0a20 2020 2020 2020 2073 656c 662e 6675  .        self.fu
-0000e320: 6e63 203d 2066 756e 630a 2020 2020 2020  nc = func.      
-0000e330: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-0000e340: 5f5f 2861 7267 733d 5b66 756e 635d 2c20  __(args=[func], 
-0000e350: 7368 6170 653d 6675 6e63 2e73 6861 7065  shape=func.shape
-0000e360: 5b3a 2d32 5d2c 2064 7479 7065 3d63 6f6d  [:-2], dtype=com
-0000e370: 706c 6578 2069 6620 6675 6e63 2e64 7479  plex if func.dty
-0000e380: 7065 203d 3d20 636f 6d70 6c65 7820 656c  pe == complex el
-0000e390: 7365 2066 6c6f 6174 290a 0a20 2020 2064  se float)..    d
-0000e3a0: 6566 205f 7369 6d70 6c69 6669 6564 2873  ef _simplified(s
-0000e3b0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-0000e3c0: 7375 6c74 203d 2073 656c 662e 6675 6e63  sult = self.func
-0000e3d0: 2e5f 6465 7465 726d 696e 616e 7428 7365  ._determinant(se
-0000e3e0: 6c66 2e6e 6469 6d2c 2073 656c 662e 6e64  lf.ndim, self.nd
-0000e3f0: 696d 2b31 290a 2020 2020 2020 2020 6966  im+1).        if
-0000e400: 2072 6573 756c 7420 6973 206e 6f74 204e   result is not N
-0000e410: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-0000e420: 2072 6574 7572 6e20 7265 7375 6c74 0a20   return result. 
-0000e430: 2020 2020 2020 2069 6620 6571 7561 6c69         if equali
-0000e440: 6e64 6578 2873 656c 662e 6675 6e63 2e73  ndex(self.func.s
-0000e450: 6861 7065 5b2d 315d 2c20 3129 3a0a 2020  hape[-1], 1):.  
-0000e460: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000e470: 2054 616b 6528 5461 6b65 2873 656c 662e   Take(Take(self.
-0000e480: 6675 6e63 2c20 7a65 726f 7328 2829 2c20  func, zeros((), 
-0000e490: 696e 7429 292c 207a 6572 6f73 2828 292c  int)), zeros((),
-0000e4a0: 2069 6e74 2929 0a0a 2020 2020 6465 6620   int))..    def 
-0000e4b0: 6576 616c 6628 7365 6c66 2c20 6172 7229  evalf(self, arr)
-0000e4c0: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
-0000e4d0: 2061 7272 2e6e 6469 6d20 3d3d 2073 656c   arr.ndim == sel
-0000e4e0: 662e 6e64 696d 2b32 0a20 2020 2020 2020  f.ndim+2.       
-0000e4f0: 2072 6574 7572 6e20 6e75 6d70 792e 6c69   return numpy.li
-0000e500: 6e61 6c67 2e64 6574 2861 7272 290a 0a20  nalg.det(arr).. 
-0000e510: 2020 2064 6566 205f 6465 7269 7661 7469     def _derivati
-0000e520: 7665 2873 656c 662c 2076 6172 2c20 7365  ve(self, var, se
-0000e530: 656e 293a 0a20 2020 2020 2020 2072 6574  en):.        ret
-0000e540: 7572 6e20 6569 6e73 756d 2827 412c 416a  urn einsum('A,Aj
-0000e550: 692c 4169 6a42 2d3e 4142 272c 2073 656c  i,AijB->AB', sel
-0000e560: 662c 2069 6e76 6572 7365 2873 656c 662e  f, inverse(self.
-0000e570: 6675 6e63 292c 2064 6572 6976 6174 6976  func), derivativ
-0000e580: 6528 7365 6c66 2e66 756e 632c 2076 6172  e(self.func, var
-0000e590: 2c20 7365 656e 2929 0a0a 2020 2020 6465  , seen))..    de
-0000e5a0: 6620 5f74 616b 6528 7365 6c66 2c20 696e  f _take(self, in
-0000e5b0: 6465 782c 2061 7869 7329 3a0a 2020 2020  dex, axis):.    
-0000e5c0: 2020 2020 7265 7475 726e 2044 6574 6572      return Deter
-0000e5d0: 6d69 6e61 6e74 285f 7461 6b65 2873 656c  minant(_take(sel
-0000e5e0: 662e 6675 6e63 2c20 696e 6465 782c 2061  f.func, index, a
-0000e5f0: 7869 7329 290a 0a20 2020 2064 6566 205f  xis))..    def _
-0000e600: 7461 6b65 6469 6167 2873 656c 662c 2061  takediag(self, a
-0000e610: 7869 7331 2c20 6178 6973 3229 3a0a 2020  xis1, axis2):.  
-0000e620: 2020 2020 2020 7265 7475 726e 2064 6574        return det
-0000e630: 6572 6d69 6e61 6e74 285f 7461 6b65 6469  erminant(_takedi
-0000e640: 6167 2873 656c 662e 6675 6e63 2c20 6178  ag(self.func, ax
-0000e650: 6973 312c 2061 7869 7332 292c 2028 7365  is1, axis2), (se
-0000e660: 6c66 2e6e 6469 6d2d 322c 2073 656c 662e  lf.ndim-2, self.
-0000e670: 6e64 696d 2d31 2929 0a0a 0a63 6c61 7373  ndim-1))...class
-0000e680: 204d 756c 7469 706c 7928 4172 7261 7929   Multiply(Array)
-0000e690: 3a0a 0a20 2020 205f 5f73 6c6f 7473 5f5f  :..    __slots__
-0000e6a0: 203d 2027 6675 6e63 7327 2c0a 0a20 2020   = 'funcs',..   
-0000e6b0: 2040 7479 7065 732e 6170 706c 795f 616e   @types.apply_an
-0000e6c0: 6e6f 7461 7469 6f6e 730a 2020 2020 6465  notations.    de
-0000e6d0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
-0000e6e0: 2066 756e 6373 3a20 7479 7065 732e 6672   funcs: types.fr
-0000e6f0: 6f7a 656e 6d75 6c74 6973 6574 5b61 7361  ozenmultiset[asa
-0000e700: 7272 6179 5d29 3a0a 2020 2020 2020 2020  rray]):.        
-0000e710: 7365 6c66 2e66 756e 6373 203d 2066 756e  self.funcs = fun
-0000e720: 6373 0a20 2020 2020 2020 2066 756e 6331  cs.        func1
-0000e730: 2c20 6675 6e63 3220 3d20 6675 6e63 730a  , func2 = funcs.
-0000e740: 2020 2020 2020 2020 6173 7365 7274 2065          assert e
-0000e750: 7175 616c 7368 6170 6528 6675 6e63 312e  qualshape(func1.
-0000e760: 7368 6170 652c 2066 756e 6332 2e73 6861  shape, func2.sha
-0000e770: 7065 2920 616e 6420 6675 6e63 312e 6474  pe) and func1.dt
-0000e780: 7970 6520 3d3d 2066 756e 6332 2e64 7479  ype == func2.dty
-0000e790: 7065 2021 3d20 626f 6f6c 2c20 274d 756c  pe != bool, 'Mul
-0000e7a0: 7469 706c 7928 7b7d 2c20 7b7d 2927 2e66  tiply({}, {})'.f
-0000e7b0: 6f72 6d61 7428 6675 6e63 312c 2066 756e  ormat(func1, fun
-0000e7c0: 6332 290a 2020 2020 2020 2020 7375 7065  c2).        supe
-0000e7d0: 7228 292e 5f5f 696e 6974 5f5f 2861 7267  r().__init__(arg
-0000e7e0: 733d 7365 6c66 2e66 756e 6373 2c20 7368  s=self.funcs, sh
-0000e7f0: 6170 653d 6675 6e63 312e 7368 6170 652c  ape=func1.shape,
-0000e800: 2064 7479 7065 3d66 756e 6331 2e64 7479   dtype=func1.dty
-0000e810: 7065 290a 0a20 2020 2064 6566 205f 7369  pe)..    def _si
-0000e820: 6d70 6c69 6669 6564 2873 656c 6629 3a0a  mplified(self):.
-0000e830: 2020 2020 2020 2020 6675 6e63 312c 2066          func1, f
-0000e840: 756e 6332 203d 2073 656c 662e 6675 6e63  unc2 = self.func
-0000e850: 730a 2020 2020 2020 2020 6966 2066 756e  s.        if fun
-0000e860: 6331 2e5f 636f 6e73 745f 756e 6966 6f72  c1._const_unifor
-0000e870: 6d20 3d3d 2031 3a0a 2020 2020 2020 2020  m == 1:.        
-0000e880: 2020 2020 7265 7475 726e 2066 756e 6332      return func2
-0000e890: 0a20 2020 2020 2020 2069 6620 6675 6e63  .        if func
-0000e8a0: 322e 5f63 6f6e 7374 5f75 6e69 666f 726d  2._const_uniform
-0000e8b0: 203d 3d20 313a 0a20 2020 2020 2020 2020   == 1:.         
-0000e8c0: 2020 2072 6574 7572 6e20 6675 6e63 310a     return func1.
-0000e8d0: 2020 2020 2020 2020 756e 616c 6967 6e65          unaligne
-0000e8e0: 6431 2c20 756e 616c 6967 6e65 6432 2c20  d1, unaligned2, 
-0000e8f0: 7768 6572 6520 3d20 756e 616c 6967 6e28  where = unalign(
-0000e900: 6675 6e63 312c 2066 756e 6332 290a 2020  func1, func2).  
-0000e910: 2020 2020 2020 6966 206c 656e 2877 6865        if len(whe
-0000e920: 7265 2920 213d 2073 656c 662e 6e64 696d  re) != self.ndim
-0000e930: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000e940: 7475 726e 2061 6c69 676e 2875 6e61 6c69  turn align(unali
-0000e950: 676e 6564 3120 2a20 756e 616c 6967 6e65  gned1 * unaligne
-0000e960: 6432 2c20 7768 6572 652c 2073 656c 662e  d2, where, self.
-0000e970: 7368 6170 6529 0a20 2020 2020 2020 2066  shape).        f
-0000e980: 6f72 2061 7869 7331 2c20 6178 6973 322c  or axis1, axis2,
-0000e990: 202a 6f74 6865 7220 696e 206d 6170 2873   *other in map(s
-0000e9a0: 6f72 7465 642c 2066 756e 6331 2e5f 6469  orted, func1._di
-0000e9b0: 6167 6f6e 616c 7320 6f72 2066 756e 6332  agonals or func2
-0000e9c0: 2e5f 6469 6167 6f6e 616c 7329 3a0a 2020  ._diagonals):.  
-0000e9d0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000e9e0: 2064 6961 676f 6e61 6c69 7a65 284d 756c   diagonalize(Mul
-0000e9f0: 7469 706c 7928 7461 6b65 6469 6167 2866  tiply(takediag(f
-0000ea00: 756e 632c 2061 7869 7331 2c20 6178 6973  unc, axis1, axis
-0000ea10: 3229 2066 6f72 2066 756e 6320 696e 2073  2) for func in s
-0000ea20: 656c 662e 6675 6e63 7329 2c20 6178 6973  elf.funcs), axis
-0000ea30: 312c 2061 7869 7332 290a 2020 2020 2020  1, axis2).      
-0000ea40: 2020 666f 7220 692c 2070 6172 7473 2069    for i, parts i
-0000ea50: 6e20 6675 6e63 312e 5f69 6e66 6c61 7469  n func1._inflati
-0000ea60: 6f6e 733a 0a20 2020 2020 2020 2020 2020  ons:.           
-0000ea70: 2072 6574 7572 6e20 7574 696c 2e73 756d   return util.sum
-0000ea80: 285f 696e 666c 6174 6528 6620 2a20 5f74  (_inflate(f * _t
-0000ea90: 616b 6528 6675 6e63 322c 2064 6f66 6d61  ake(func2, dofma
-0000eaa0: 702c 2069 292c 2064 6f66 6d61 702c 2073  p, i), dofmap, s
-0000eab0: 656c 662e 7368 6170 655b 695d 2c20 6929  elf.shape[i], i)
-0000eac0: 2066 6f72 2064 6f66 6d61 702c 2066 2069   for dofmap, f i
-0000ead0: 6e20 7061 7274 732e 6974 656d 7328 2929  n parts.items())
-0000eae0: 0a20 2020 2020 2020 2066 6f72 2069 2c20  .        for i, 
-0000eaf0: 7061 7274 7320 696e 2066 756e 6332 2e5f  parts in func2._
-0000eb00: 696e 666c 6174 696f 6e73 3a0a 2020 2020  inflations:.    
-0000eb10: 2020 2020 2020 2020 7265 7475 726e 2075          return u
-0000eb20: 7469 6c2e 7375 6d28 5f69 6e66 6c61 7465  til.sum(_inflate
-0000eb30: 285f 7461 6b65 2866 756e 6331 2c20 646f  (_take(func1, do
-0000eb40: 666d 6170 2c20 6929 202a 2066 2c20 646f  fmap, i) * f, do
-0000eb50: 666d 6170 2c20 7365 6c66 2e73 6861 7065  fmap, self.shape
-0000eb60: 5b69 5d2c 2069 2920 666f 7220 646f 666d  [i], i) for dofm
-0000eb70: 6170 2c20 6620 696e 2070 6172 7473 2e69  ap, f in parts.i
-0000eb80: 7465 6d73 2829 290a 2020 2020 2020 2020  tems()).        
-0000eb90: 7265 7475 726e 2066 756e 6331 2e5f 6d75  return func1._mu
-0000eba0: 6c74 6970 6c79 2866 756e 6332 2920 6f72  ltiply(func2) or
-0000ebb0: 2066 756e 6332 2e5f 6d75 6c74 6970 6c79   func2._multiply
-0000ebc0: 2866 756e 6331 290a 0a20 2020 2064 6566  (func1)..    def
-0000ebd0: 205f 6f70 7469 6d69 7a65 645f 666f 725f   _optimized_for_
-0000ebe0: 6e75 6d70 7928 7365 6c66 293a 0a20 2020  numpy(self):.   
-0000ebf0: 2020 2020 2066 756e 6331 2c20 6675 6e63       func1, func
-0000ec00: 3220 3d20 7365 6c66 2e66 756e 6373 0a20  2 = self.funcs. 
-0000ec10: 2020 2020 2020 2069 6620 6675 6e63 312e         if func1.
-0000ec20: 5f63 6f6e 7374 5f75 6e69 666f 726d 203d  _const_uniform =
-0000ec30: 3d20 2d31 2061 6e64 2066 756e 6332 2e64  = -1 and func2.d
-0000ec40: 7479 7065 2021 3d20 626f 6f6c 3a0a 2020  type != bool:.  
-0000ec50: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000ec60: 204e 6567 6174 6976 6528 6675 6e63 3229   Negative(func2)
-0000ec70: 0a20 2020 2020 2020 2069 6620 6675 6e63  .        if func
-0000ec80: 322e 5f63 6f6e 7374 5f75 6e69 666f 726d  2._const_uniform
-0000ec90: 203d 3d20 2d31 2061 6e64 2066 756e 6331   == -1 and func1
-0000eca0: 2e64 7479 7065 2021 3d20 626f 6f6c 3a0a  .dtype != bool:.
-0000ecb0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000ecc0: 726e 204e 6567 6174 6976 6528 6675 6e63  rn Negative(func
-0000ecd0: 3129 0a20 2020 2020 2020 2069 6620 7365  1).        if se
-0000ece0: 6c66 2e64 7479 7065 2021 3d20 636f 6d70  lf.dtype != comp
-0000ecf0: 6c65 7820 616e 6420 6675 6e63 3120 3d3d  lex and func1 ==
-0000ed00: 2073 6967 6e28 6675 6e63 3229 3a0a 2020   sign(func2):.  
-0000ed10: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000ed20: 2041 6273 6f6c 7574 6528 6675 6e63 3229   Absolute(func2)
-0000ed30: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-0000ed40: 2e64 7479 7065 2021 3d20 636f 6d70 6c65  .dtype != comple
-0000ed50: 7820 616e 6420 6675 6e63 3220 3d3d 2073  x and func2 == s
-0000ed60: 6967 6e28 6675 6e63 3129 3a0a 2020 2020  ign(func1):.    
-0000ed70: 2020 2020 2020 2020 7265 7475 726e 2041          return A
-0000ed80: 6273 6f6c 7574 6528 6675 6e63 3129 0a20  bsolute(func1). 
-0000ed90: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
-0000eda0: 6c66 2e6e 6469 6d3a 0a20 2020 2020 2020  lf.ndim:.       
-0000edb0: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
-0000edc0: 2020 2020 756e 616c 6967 6e65 6431 2c20      unaligned1, 
-0000edd0: 7768 6572 6531 203d 2075 6e61 6c69 676e  where1 = unalign
-0000ede0: 2866 756e 6331 290a 2020 2020 2020 2020  (func1).        
-0000edf0: 756e 616c 6967 6e65 6432 2c20 7768 6572  unaligned2, wher
-0000ee00: 6532 203d 2075 6e61 6c69 676e 2866 756e  e2 = unalign(fun
-0000ee10: 6332 290a 2020 2020 2020 2020 7265 7475  c2).        retu
-0000ee20: 726e 2045 696e 7375 6d28 2875 6e61 6c69  rn Einsum((unali
-0000ee30: 676e 6564 312c 2075 6e61 6c69 676e 6564  gned1, unaligned
-0000ee40: 3229 2c20 2877 6865 7265 312c 2077 6865  2), (where1, whe
-0000ee50: 7265 3229 2c20 7475 706c 6528 7261 6e67  re2), tuple(rang
-0000ee60: 6528 7365 6c66 2e6e 6469 6d29 2929 0a0a  e(self.ndim)))..
-0000ee70: 2020 2020 6465 6620 6576 616c 6628 7365      def evalf(se
-0000ee80: 6c66 2c20 6172 7231 2c20 6172 7232 293a  lf, arr1, arr2):
-0000ee90: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000eea0: 6172 7231 202a 2061 7272 320a 0a20 2020  arr1 * arr2..   
-0000eeb0: 2064 6566 205f 7375 6d28 7365 6c66 2c20   def _sum(self, 
-0000eec0: 6178 6973 293a 0a20 2020 2020 2020 2066  axis):.        f
-0000eed0: 756e 6331 2c20 6675 6e63 3220 3d20 7365  unc1, func2 = se
-0000eee0: 6c66 2e66 756e 6373 0a20 2020 2020 2020  lf.funcs.       
-0000eef0: 2075 6e61 6c69 676e 6564 2c20 7768 6572   unaligned, wher
-0000ef00: 6520 3d20 756e 616c 6967 6e28 6675 6e63  e = unalign(func
-0000ef10: 3129 0a20 2020 2020 2020 2069 6620 6178  1).        if ax
-0000ef20: 6973 206e 6f74 2069 6e20 7768 6572 653a  is not in where:
-0000ef30: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000ef40: 7572 6e20 616c 6967 6e28 756e 616c 6967  urn align(unalig
-0000ef50: 6e65 642c 205b 692d 2869 203e 2061 7869  ned, [i-(i > axi
-0000ef60: 7329 2066 6f72 2069 2069 6e20 7768 6572  s) for i in wher
-0000ef70: 655d 2c20 7365 6c66 2e73 6861 7065 5b3a  e], self.shape[:
-0000ef80: 6178 6973 5d2b 7365 6c66 2e73 6861 7065  axis]+self.shape
-0000ef90: 5b61 7869 732b 313a 5d29 202a 2073 756d  [axis+1:]) * sum
-0000efa0: 2866 756e 6332 2c20 6178 6973 290a 2020  (func2, axis).  
-0000efb0: 2020 2020 2020 756e 616c 6967 6e65 642c        unaligned,
-0000efc0: 2077 6865 7265 203d 2075 6e61 6c69 676e   where = unalign
-0000efd0: 2866 756e 6332 290a 2020 2020 2020 2020  (func2).        
-0000efe0: 6966 2061 7869 7320 6e6f 7420 696e 2077  if axis not in w
-0000eff0: 6865 7265 3a0a 2020 2020 2020 2020 2020  here:.          
-0000f000: 2020 7265 7475 726e 2073 756d 2866 756e    return sum(fun
-0000f010: 6331 2c20 6178 6973 2920 2a20 616c 6967  c1, axis) * alig
-0000f020: 6e28 756e 616c 6967 6e65 642c 205b 692d  n(unaligned, [i-
-0000f030: 2869 203e 2061 7869 7329 2066 6f72 2069  (i > axis) for i
-0000f040: 2069 6e20 7768 6572 655d 2c20 7365 6c66   in where], self
-0000f050: 2e73 6861 7065 5b3a 6178 6973 5d2b 7365  .shape[:axis]+se
-0000f060: 6c66 2e73 6861 7065 5b61 7869 732b 313a  lf.shape[axis+1:
-0000f070: 5d29 0a0a 2020 2020 6465 6620 5f61 6464  ])..    def _add
-0000f080: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
-0000f090: 2020 2020 2020 2066 756e 6331 2c20 6675         func1, fu
-0000f0a0: 6e63 3220 3d20 7365 6c66 2e66 756e 6373  nc2 = self.funcs
-0000f0b0: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
-0000f0c0: 7374 616e 6365 286f 7468 6572 2c20 4d75  stance(other, Mu
-0000f0d0: 6c74 6970 6c79 293a 0a20 2020 2020 2020  ltiply):.       
-0000f0e0: 2020 2020 2066 6f72 2063 6f6d 6d6f 6e20       for common 
-0000f0f0: 696e 2073 656c 662e 6675 6e63 7320 2620  in self.funcs & 
-0000f100: 6f74 6865 722e 6675 6e63 733a 0a20 2020  other.funcs:.   
-0000f110: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0000f120: 7572 6e20 636f 6d6d 6f6e 202a 2041 6464  urn common * Add
-0000f130: 2873 656c 662e 6675 6e63 7320 2b20 6f74  (self.funcs + ot
-0000f140: 6865 722e 6675 6e63 7320 2d20 5b63 6f6d  her.funcs - [com
-0000f150: 6d6f 6e2c 2063 6f6d 6d6f 6e5d 290a 0a20  mon, common]).. 
-0000f160: 2020 2064 6566 205f 6465 7465 726d 696e     def _determin
-0000f170: 616e 7428 7365 6c66 2c20 6178 6973 312c  ant(self, axis1,
-0000f180: 2061 7869 7332 293a 0a20 2020 2020 2020   axis2):.       
-0000f190: 2066 756e 6331 2c20 6675 6e63 3220 3d20   func1, func2 = 
-0000f1a0: 7365 6c66 2e66 756e 6373 0a20 2020 2020  self.funcs.     
-0000f1b0: 2020 2061 7869 7331 2c20 6178 6973 3220     axis1, axis2 
-0000f1c0: 3d20 736f 7274 6564 285b 6178 6973 312c  = sorted([axis1,
-0000f1d0: 2061 7869 7332 5d29 0a20 2020 2020 2020   axis2]).       
-0000f1e0: 2069 6620 6571 7561 6c69 6e64 6578 2873   if equalindex(s
-0000f1f0: 656c 662e 7368 6170 655b 6178 6973 315d  elf.shape[axis1]
-0000f200: 2c20 3129 2061 6e64 2065 7175 616c 696e  , 1) and equalin
-0000f210: 6465 7828 7365 6c66 2e73 6861 7065 5b61  dex(self.shape[a
-0000f220: 7869 7332 5d2c 2031 293a 0a20 2020 2020  xis2], 1):.     
-0000f230: 2020 2020 2020 2072 6574 7572 6e20 4d75         return Mu
-0000f240: 6c74 6970 6c79 285b 6465 7465 726d 696e  ltiply([determin
-0000f250: 616e 7428 6675 6e63 312c 2028 6178 6973  ant(func1, (axis
-0000f260: 312c 2061 7869 7332 2929 2c20 6465 7465  1, axis2)), dete
-0000f270: 726d 696e 616e 7428 6675 6e63 322c 2028  rminant(func2, (
-0000f280: 6178 6973 312c 2061 7869 7332 2929 5d29  axis1, axis2))])
-0000f290: 0a20 2020 2020 2020 2075 6e61 6c69 676e  .        unalign
-0000f2a0: 6564 312c 2077 6865 7265 3120 3d20 756e  ed1, where1 = un
-0000f2b0: 616c 6967 6e28 6675 6e63 3129 0a20 2020  align(func1).   
-0000f2c0: 2020 2020 2069 6620 7b61 7869 7331 2c20       if {axis1, 
-0000f2d0: 6178 6973 327d 2e69 7364 6973 6a6f 696e  axis2}.isdisjoin
-0000f2e0: 7428 7768 6572 6531 293a 0a20 2020 2020  t(where1):.     
-0000f2f0: 2020 2020 2020 2064 3220 3d20 6465 7465         d2 = dete
-0000f300: 726d 696e 616e 7428 6675 6e63 322c 2028  rminant(func2, (
-0000f310: 6178 6973 312c 2061 7869 7332 2929 0a20  axis1, axis2)). 
-0000f320: 2020 2020 2020 2020 2020 2064 3120 3d20             d1 = 
-0000f330: 616c 6967 6e28 756e 616c 6967 6e65 6431  align(unaligned1
-0000f340: 2a2a 7365 6c66 2e73 6861 7065 5b61 7869  **self.shape[axi
-0000f350: 7331 5d2c 205b 692d 2869 203e 2061 7869  s1], [i-(i > axi
-0000f360: 7331 292d 2869 203e 2061 7869 7332 2920  s1)-(i > axis2) 
-0000f370: 666f 7220 6920 696e 2077 6865 7265 3120  for i in where1 
-0000f380: 6966 2069 206e 6f74 2069 6e20 2861 7869  if i not in (axi
-0000f390: 7331 2c20 6178 6973 3229 5d2c 2064 322e  s1, axis2)], d2.
-0000f3a0: 7368 6170 6529 0a20 2020 2020 2020 2020  shape).         
-0000f3b0: 2020 2072 6574 7572 6e20 6431 202a 2064     return d1 * d
-0000f3c0: 320a 2020 2020 2020 2020 756e 616c 6967  2.        unalig
-0000f3d0: 6e65 6432 2c20 7768 6572 6532 203d 2075  ned2, where2 = u
-0000f3e0: 6e61 6c69 676e 2866 756e 6332 290a 2020  nalign(func2).  
-0000f3f0: 2020 2020 2020 6966 207b 6178 6973 312c        if {axis1,
-0000f400: 2061 7869 7332 7d2e 6973 6469 736a 6f69   axis2}.isdisjoi
-0000f410: 6e74 2877 6865 7265 3229 3a0a 2020 2020  nt(where2):.    
-0000f420: 2020 2020 2020 2020 6431 203d 2064 6574          d1 = det
-0000f430: 6572 6d69 6e61 6e74 2866 756e 6331 2c20  erminant(func1, 
-0000f440: 2861 7869 7331 2c20 6178 6973 3229 290a  (axis1, axis2)).
-0000f450: 2020 2020 2020 2020 2020 2020 6432 203d              d2 =
-0000f460: 2061 6c69 676e 2875 6e61 6c69 676e 6564   align(unaligned
-0000f470: 322a 2a73 656c 662e 7368 6170 655b 6178  2**self.shape[ax
-0000f480: 6973 315d 2c20 5b69 2d28 6920 3e20 6178  is1], [i-(i > ax
-0000f490: 6973 3129 2d28 6920 3e20 6178 6973 3229  is1)-(i > axis2)
-0000f4a0: 2066 6f72 2069 2069 6e20 7768 6572 6532   for i in where2
-0000f4b0: 2069 6620 6920 6e6f 7420 696e 2028 6178   if i not in (ax
-0000f4c0: 6973 312c 2061 7869 7332 295d 2c20 6431  is1, axis2)], d1
-0000f4d0: 2e73 6861 7065 290a 2020 2020 2020 2020  .shape).        
-0000f4e0: 2020 2020 7265 7475 726e 2064 3120 2a20      return d1 * 
-0000f4f0: 6432 0a0a 2020 2020 6465 6620 5f70 726f  d2..    def _pro
-0000f500: 6475 6374 2873 656c 6629 3a0a 2020 2020  duct(self):.    
-0000f510: 2020 2020 6675 6e63 312c 2066 756e 6332      func1, func2
-0000f520: 203d 2073 656c 662e 6675 6e63 730a 2020   = self.funcs.  
-0000f530: 2020 2020 2020 7265 7475 726e 204d 756c        return Mul
-0000f540: 7469 706c 7928 5b50 726f 6475 6374 2866  tiply([Product(f
-0000f550: 756e 6331 292c 2050 726f 6475 6374 2866  unc1), Product(f
-0000f560: 756e 6332 295d 290a 0a20 2020 2064 6566  unc2)])..    def
-0000f570: 205f 6d75 6c74 6970 6c79 2873 656c 662c   _multiply(self,
-0000f580: 206f 7468 6572 293a 0a20 2020 2020 2020   other):.       
-0000f590: 2066 756e 6331 2c20 6675 6e63 3220 3d20   func1, func2 = 
-0000f5a0: 7365 6c66 2e66 756e 6373 0a20 2020 2020  self.funcs.     
-0000f5b0: 2020 2066 756e 6331 5f6f 7468 6572 203d     func1_other =
-0000f5c0: 2066 756e 6331 2e5f 6d75 6c74 6970 6c79   func1._multiply
-0000f5d0: 286f 7468 6572 290a 2020 2020 2020 2020  (other).        
-0000f5e0: 6966 2066 756e 6331 5f6f 7468 6572 2069  if func1_other i
-0000f5f0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-0000f600: 2020 2020 2020 2020 7265 7475 726e 204d          return M
-0000f610: 756c 7469 706c 7928 5b66 756e 6331 5f6f  ultiply([func1_o
-0000f620: 7468 6572 2c20 6675 6e63 325d 290a 2020  ther, func2]).  
-0000f630: 2020 2020 2020 6675 6e63 325f 6f74 6865        func2_othe
-0000f640: 7220 3d20 6675 6e63 322e 5f6d 756c 7469  r = func2._multi
-0000f650: 706c 7928 6f74 6865 7229 0a20 2020 2020  ply(other).     
-0000f660: 2020 2069 6620 6675 6e63 325f 6f74 6865     if func2_othe
-0000f670: 7220 6973 206e 6f74 204e 6f6e 653a 0a20  r is not None:. 
-0000f680: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000f690: 6e20 4d75 6c74 6970 6c79 285b 6675 6e63  n Multiply([func
-0000f6a0: 312c 2066 756e 6332 5f6f 7468 6572 5d29  1, func2_other])
-0000f6b0: 0a20 2020 2020 2020 2023 2052 656f 7264  .        # Reord
-0000f6c0: 6572 2074 6865 206d 756c 7469 706c 6963  er the multiplic
-0000f6d0: 6174 696f 6e73 2073 7563 6820 7468 6174  ations such that
-0000f6e0: 2074 6865 2061 6d6f 756e 7420 6f66 2066   the amount of f
-0000f6f0: 6c6f 7073 2069 7320 6d69 6e69 6d69 7a65  lops is minimize
-0000f700: 642e 0a20 2020 2020 2020 2023 2054 6865  d..        # The
-0000f710: 2066 6c6f 7073 2061 7265 2063 6f75 6e74   flops are count
-0000f720: 6564 2062 6173 6564 206f 6e20 7468 6520  ed based on the 
-0000f730: 6c6f 7765 7220 696e 7420 626f 756e 6473  lower int bounds
-0000f740: 206f 6620 7468 6520 7368 6170 6520 616e   of the shape an
-0000f750: 6420 6c6f 6f70 0a20 2020 2020 2020 2023  d loop.        #
-0000f760: 206c 656e 6774 6873 2c20 6578 636c 7564   lengths, exclud
-0000f770: 696e 6720 636f 6d6d 6f6e 2069 6e73 6572  ing common inser
-0000f780: 7465 6420 6178 6573 2061 6e64 2069 6e76  ted axes and inv
-0000f790: 6172 6961 6e74 206c 6f6f 7073 206f 6620  ariant loops of 
-0000f7a0: 7468 6520 696e 6e65 720a 2020 2020 2020  the inner.      
-0000f7b0: 2020 2320 7072 6f64 7563 742e 0a20 2020    # product..   
-0000f7c0: 2020 2020 2073 697a 6573 203d 205b 5d0a       sizes = [].
-0000f7d0: 2020 2020 2020 2020 756e 616c 6967 6e65          unaligne
-0000f7e0: 6420 3d20 7475 706c 6528 6d61 7028 756e  d = tuple(map(un
-0000f7f0: 616c 6967 6e2c 2028 6675 6e63 312c 2066  align, (func1, f
-0000f800: 756e 6332 2c20 6f74 6865 7229 2929 0a20  unc2, other))). 
-0000f810: 2020 2020 2020 2066 6f72 2028 6631 2c20         for (f1, 
-0000f820: 7731 292c 2028 6632 2c20 7732 2920 696e  w1), (f2, w2) in
-0000f830: 2069 7465 7274 6f6f 6c73 2e63 6f6d 6269   itertools.combi
-0000f840: 6e61 7469 6f6e 7328 756e 616c 6967 6e65  nations(unaligne
-0000f850: 642c 2032 293a 0a20 2020 2020 2020 2020  d, 2):.         
-0000f860: 2020 206c 656e 6774 6873 203d 205b 7365     lengths = [se
-0000f870: 6c66 2e73 6861 7065 5b69 5d20 666f 7220  lf.shape[i] for 
-0000f880: 6920 696e 2073 6574 2877 3129 207c 2073  i in set(w1) | s
-0000f890: 6574 2877 3229 5d0a 2020 2020 2020 2020  et(w2)].        
-0000f8a0: 2020 2020 6c65 6e67 7468 7320 2b3d 205b      lengths += [
-0000f8b0: 6172 672e 6c65 6e67 7468 2066 6f72 2061  arg.length for a
-0000f8c0: 7267 2069 6e20 6631 2e61 7267 756d 656e  rg in f1.argumen
-0000f8d0: 7473 207c 2066 322e 6172 6775 6d65 6e74  ts | f2.argument
-0000f8e0: 7320 6966 2069 7369 6e73 7461 6e63 6528  s if isinstance(
-0000f8f0: 6172 672c 205f 4c6f 6f70 496e 6465 7829  arg, _LoopIndex)
-0000f900: 5d0a 2020 2020 2020 2020 2020 2020 7369  ].            si
-0000f910: 7a65 732e 6170 7065 6e64 2875 7469 6c2e  zes.append(util.
-0000f920: 7072 6f64 7563 7428 286d 6178 2831 2c20  product((max(1, 
-0000f930: 6c65 6e67 7468 2e5f 696e 7462 6f75 6e64  length._intbound
-0000f940: 735b 305d 2920 666f 7220 6c65 6e67 7468  s[0]) for length
-0000f950: 2069 6e20 6c65 6e67 7468 7329 2c20 3129   in lengths), 1)
-0000f960: 290a 2020 2020 2020 2020 6d69 6e5f 7369  ).        min_si
-0000f970: 7a65 203d 206d 696e 2873 697a 6573 290a  ze = min(sizes).
-0000f980: 2020 2020 2020 2020 6966 2073 697a 6573          if sizes
-0000f990: 5b30 5d20 3d3d 206d 696e 5f73 697a 653a  [0] == min_size:
-0000f9a0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000f9b0: 7572 6e20 2023 2073 7461 7475 7320 7175  urn  # status qu
-0000f9c0: 6f0a 2020 2020 2020 2020 656c 6966 2073  o.        elif s
-0000f9d0: 697a 6573 5b31 5d20 3d3d 206d 696e 5f73  izes[1] == min_s
-0000f9e0: 697a 653a 0a20 2020 2020 2020 2020 2020  ize:.           
-0000f9f0: 2072 6574 7572 6e20 2866 756e 6331 202a   return (func1 *
-0000fa00: 206f 7468 6572 2920 2a20 6675 6e63 320a   other) * func2.
-0000fa10: 2020 2020 2020 2020 656c 6966 2073 697a          elif siz
-0000fa20: 6573 5b32 5d20 3d3d 206d 696e 5f73 697a  es[2] == min_siz
-0000fa30: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-0000fa40: 6574 7572 6e20 2866 756e 6332 202a 206f  eturn (func2 * o
-0000fa50: 7468 6572 2920 2a20 6675 6e63 310a 0a20  ther) * func1.. 
-0000fa60: 2020 2064 6566 205f 6465 7269 7661 7469     def _derivati
-0000fa70: 7665 2873 656c 662c 2076 6172 2c20 7365  ve(self, var, se
-0000fa80: 656e 293a 0a20 2020 2020 2020 2066 756e  en):.        fun
-0000fa90: 6331 2c20 6675 6e63 3220 3d20 7365 6c66  c1, func2 = self
-0000faa0: 2e66 756e 6373 0a20 2020 2020 2020 2072  .funcs.        r
-0000fab0: 6574 7572 6e20 6569 6e73 756d 2827 412c  eturn einsum('A,
-0000fac0: 4142 2d3e 4142 272c 2066 756e 6331 2c20  AB->AB', func1, 
-0000fad0: 6465 7269 7661 7469 7665 2866 756e 6332  derivative(func2
-0000fae0: 2c20 7661 722c 2073 6565 6e29 2920 5c0a  , var, seen)) \.
-0000faf0: 2020 2020 2020 2020 2020 2020 2b20 6569              + ei
-0000fb00: 6e73 756d 2827 412c 4142 2d3e 4142 272c  nsum('A,AB->AB',
-0000fb10: 2066 756e 6332 2c20 6465 7269 7661 7469   func2, derivati
-0000fb20: 7665 2866 756e 6331 2c20 7661 722c 2073  ve(func1, var, s
-0000fb30: 6565 6e29 290a 0a20 2020 2064 6566 205f  een))..    def _
-0000fb40: 7461 6b65 6469 6167 2873 656c 662c 2061  takediag(self, a
-0000fb50: 7869 7331 2c20 6178 6973 3229 3a0a 2020  xis1, axis2):.  
-0000fb60: 2020 2020 2020 6675 6e63 312c 2066 756e        func1, fun
-0000fb70: 6332 203d 2073 656c 662e 6675 6e63 730a  c2 = self.funcs.
-0000fb80: 2020 2020 2020 2020 7265 7475 726e 204d          return M
-0000fb90: 756c 7469 706c 7928 5b5f 7461 6b65 6469  ultiply([_takedi
-0000fba0: 6167 2866 756e 6331 2c20 6178 6973 312c  ag(func1, axis1,
-0000fbb0: 2061 7869 7332 292c 205f 7461 6b65 6469   axis2), _takedi
-0000fbc0: 6167 2866 756e 6332 2c20 6178 6973 312c  ag(func2, axis1,
-0000fbd0: 2061 7869 7332 295d 290a 0a20 2020 2064   axis2)])..    d
-0000fbe0: 6566 205f 7461 6b65 2873 656c 662c 2069  ef _take(self, i
-0000fbf0: 6e64 6578 2c20 6178 6973 293a 0a20 2020  ndex, axis):.   
-0000fc00: 2020 2020 2066 756e 6331 2c20 6675 6e63       func1, func
-0000fc10: 3220 3d20 7365 6c66 2e66 756e 6373 0a20  2 = self.funcs. 
-0000fc20: 2020 2020 2020 2072 6574 7572 6e20 4d75         return Mu
-0000fc30: 6c74 6970 6c79 285b 5f74 616b 6528 6675  ltiply([_take(fu
-0000fc40: 6e63 312c 2069 6e64 6578 2c20 6178 6973  nc1, index, axis
-0000fc50: 292c 205f 7461 6b65 2866 756e 6332 2c20  ), _take(func2, 
-0000fc60: 696e 6465 782c 2061 7869 7329 5d29 0a0a  index, axis)])..
-0000fc70: 2020 2020 6465 6620 5f73 6967 6e28 7365      def _sign(se
-0000fc80: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-0000fc90: 7572 6e20 4d75 6c74 6970 6c79 285b 5369  urn Multiply([Si
-0000fca0: 676e 2866 756e 6329 2066 6f72 2066 756e  gn(func) for fun
-0000fcb0: 6320 696e 2073 656c 662e 6675 6e63 735d  c in self.funcs]
-0000fcc0: 290a 0a20 2020 2064 6566 205f 756e 7261  )..    def _unra
-0000fcd0: 7665 6c28 7365 6c66 2c20 6178 6973 2c20  vel(self, axis, 
-0000fce0: 7368 6170 6529 3a0a 2020 2020 2020 2020  shape):.        
-0000fcf0: 7265 7475 726e 204d 756c 7469 706c 7928  return Multiply(
-0000fd00: 5b75 6e72 6176 656c 2866 756e 632c 2061  [unravel(func, a
-0000fd10: 7869 732c 2073 6861 7065 2920 666f 7220  xis, shape) for 
-0000fd20: 6675 6e63 2069 6e20 7365 6c66 2e66 756e  func in self.fun
-0000fd30: 6373 5d29 0a0a 2020 2020 6465 6620 5f69  cs])..    def _i
-0000fd40: 6e76 6572 7365 2873 656c 662c 2061 7869  nverse(self, axi
-0000fd50: 7331 2c20 6178 6973 3229 3a0a 2020 2020  s1, axis2):.    
-0000fd60: 2020 2020 6675 6e63 312c 2066 756e 6332      func1, func2
-0000fd70: 203d 2073 656c 662e 6675 6e63 730a 2020   = self.funcs.  
-0000fd80: 2020 2020 2020 6966 2073 6574 2875 6e61        if set(una
-0000fd90: 6c69 676e 2866 756e 6331 295b 315d 292e  lign(func1)[1]).
-0000fda0: 6973 6469 736a 6f69 6e74 2828 6178 6973  isdisjoint((axis
-0000fdb0: 312c 2061 7869 7332 2929 3a0a 2020 2020  1, axis2)):.    
-0000fdc0: 2020 2020 2020 2020 7265 7475 726e 2064          return d
-0000fdd0: 6976 6964 6528 696e 7665 7273 6528 6675  ivide(inverse(fu
-0000fde0: 6e63 322c 2028 6178 6973 312c 2061 7869  nc2, (axis1, axi
-0000fdf0: 7332 2929 2c20 6675 6e63 3129 0a20 2020  s2)), func1).   
-0000fe00: 2020 2020 2069 6620 7365 7428 756e 616c       if set(unal
-0000fe10: 6967 6e28 6675 6e63 3229 5b31 5d29 2e69  ign(func2)[1]).i
-0000fe20: 7364 6973 6a6f 696e 7428 2861 7869 7331  sdisjoint((axis1
-0000fe30: 2c20 6178 6973 3229 293a 0a20 2020 2020  , axis2)):.     
-0000fe40: 2020 2020 2020 2072 6574 7572 6e20 6469         return di
-0000fe50: 7669 6465 2869 6e76 6572 7365 2866 756e  vide(inverse(fun
-0000fe60: 6331 2c20 2861 7869 7331 2c20 6178 6973  c1, (axis1, axis
-0000fe70: 3229 292c 2066 756e 6332 290a 0a20 2020  2)), func2)..   
-0000fe80: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-0000fe90: 6566 205f 6173 7370 6172 7365 2873 656c  ef _assparse(sel
-0000fea0: 6629 3a0a 2020 2020 2020 2020 6675 6e63  f):.        func
-0000feb0: 312c 2066 756e 6332 203d 2073 656c 662e  1, func2 = self.
-0000fec0: 6675 6e63 730a 2020 2020 2020 2020 756e  funcs.        un
-0000fed0: 696e 7365 7274 6564 312c 2077 6865 7265  inserted1, where
-0000fee0: 3120 3d20 756e 616c 6967 6e28 6675 6e63  1 = unalign(func
-0000fef0: 3129 0a20 2020 2020 2020 2075 6e69 6e73  1).        unins
-0000ff00: 6572 7465 6432 2c20 7768 6572 6532 203d  erted2, where2 =
-0000ff10: 2075 6e61 6c69 676e 2866 756e 6332 290a   unalign(func2).
-0000ff20: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
-0000ff30: 6574 2877 6865 7265 3129 2026 2073 6574  et(where1) & set
-0000ff40: 2877 6865 7265 3229 3a0a 2020 2020 2020  (where2):.      
-0000ff50: 2020 2020 2020 7370 6172 7365 203d 205b        sparse = [
-0000ff60: 5d0a 2020 2020 2020 2020 2020 2020 666f  ].            fo
-0000ff70: 7220 2a69 6e64 6963 6573 312c 2076 616c  r *indices1, val
-0000ff80: 7565 7331 2069 6e20 756e 696e 7365 7274  ues1 in uninsert
-0000ff90: 6564 312e 5f61 7373 7061 7273 653a 0a20  ed1._assparse:. 
-0000ffa0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000ffb0: 6f72 202a 696e 6469 6365 7332 2c20 7661  or *indices2, va
-0000ffc0: 6c75 6573 3220 696e 2075 6e69 6e73 6572  lues2 in uninser
-0000ffd0: 7465 6432 2e5f 6173 7370 6172 7365 3a0a  ted2._assparse:.
-0000ffe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fff0: 2020 2020 696e 6469 6365 7320 3d20 5b4e      indices = [N
-00010000: 6f6e 655d 202a 2073 656c 662e 6e64 696d  one] * self.ndim
-00010010: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010020: 2020 2020 2066 6f72 2069 2c20 6a20 696e       for i, j in
-00010030: 2065 6e75 6d65 7261 7465 2877 6865 7265   enumerate(where
-00010040: 3129 3a0a 2020 2020 2020 2020 2020 2020  1):.            
-00010050: 2020 2020 2020 2020 2020 2020 696e 6469              indi
-00010060: 6365 735b 6a5d 203d 2061 7070 656e 6461  ces[j] = appenda
-00010070: 7865 7328 696e 6469 6365 7331 5b69 5d2c  xes(indices1[i],
-00010080: 2076 616c 7565 7332 2e73 6861 7065 290a   values2.shape).
-00010090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000100a0: 2020 2020 666f 7220 692c 206a 2069 6e20      for i, j in 
-000100b0: 656e 756d 6572 6174 6528 7768 6572 6532  enumerate(where2
-000100c0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-000100d0: 2020 2020 2020 2020 2020 2069 6e64 6963             indic
-000100e0: 6573 5b6a 5d20 3d20 7072 6570 656e 6461  es[j] = prependa
-000100f0: 7865 7328 696e 6469 6365 7332 5b69 5d2c  xes(indices2[i],
-00010100: 2076 616c 7565 7331 2e73 6861 7065 290a   values1.shape).
-00010110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010120: 2020 2020 6173 7365 7274 2061 6c6c 2869      assert all(i
-00010130: 6e64 6963 6573 290a 2020 2020 2020 2020  ndices).        
-00010140: 2020 2020 2020 2020 2020 2020 7661 6c75              valu
-00010150: 6573 203d 2061 7070 656e 6461 7865 7328  es = appendaxes(
-00010160: 7661 6c75 6573 312c 2076 616c 7565 7332  values1, values2
-00010170: 2e73 6861 7065 2920 2a20 7072 6570 656e  .shape) * prepen
-00010180: 6461 7865 7328 7661 6c75 6573 322c 2076  daxes(values2, v
-00010190: 616c 7565 7331 2e73 6861 7065 290a 2020  alues1.shape).  
-000101a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000101b0: 2020 7370 6172 7365 2e61 7070 656e 6428    sparse.append(
-000101c0: 282a 696e 6469 6365 732c 2076 616c 7565  (*indices, value
-000101d0: 7329 290a 2020 2020 2020 2020 2020 2020  s)).            
-000101e0: 7265 7475 726e 2074 7570 6c65 2873 7061  return tuple(spa
-000101f0: 7273 6529 0a20 2020 2020 2020 2072 6574  rse).        ret
-00010200: 7572 6e20 7375 7065 7228 292e 5f61 7373  urn super()._ass
-00010210: 7061 7273 650a 0a20 2020 2064 6566 205f  parse..    def _
-00010220: 696e 7462 6f75 6e64 735f 696d 706c 2873  intbounds_impl(s
-00010230: 656c 6629 3a0a 2020 2020 2020 2020 6675  elf):.        fu
-00010240: 6e63 312c 2066 756e 6332 203d 2073 656c  nc1, func2 = sel
-00010250: 662e 6675 6e63 730a 2020 2020 2020 2020  f.funcs.        
-00010260: 6578 7472 656d 6120 3d20 5b62 3120 616e  extrema = [b1 an
-00010270: 6420 6232 2061 6e64 2062 3120 2a20 6232  d b2 and b1 * b2
-00010280: 2066 6f72 2062 3120 696e 2066 756e 6331   for b1 in func1
-00010290: 2e5f 696e 7462 6f75 6e64 7320 666f 7220  ._intbounds for 
-000102a0: 6232 2069 6e20 6675 6e63 322e 5f69 6e74  b2 in func2._int
-000102b0: 626f 756e 6473 5d0a 2020 2020 2020 2020  bounds].        
-000102c0: 7265 7475 726e 206d 696e 2865 7874 7265  return min(extre
-000102d0: 6d61 292c 206d 6178 2865 7874 7265 6d61  ma), max(extrema
-000102e0: 290a 0a0a 636c 6173 7320 4164 6428 4172  )...class Add(Ar
-000102f0: 7261 7929 3a0a 0a20 2020 205f 5f73 6c6f  ray):..    __slo
-00010300: 7473 5f5f 203d 2027 6675 6e63 7327 2c0a  ts__ = 'funcs',.
-00010310: 2020 2020 5f5f 6361 6368 655f 5f20 3d20      __cache__ = 
-00010320: 275f 696e 666c 6174 696f 6e73 270a 0a20  '_inflations'.. 
-00010330: 2020 2040 7479 7065 732e 6170 706c 795f     @types.apply_
-00010340: 616e 6e6f 7461 7469 6f6e 730a 2020 2020  annotations.    
-00010350: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00010360: 662c 2066 756e 6373 3a20 7479 7065 732e  f, funcs: types.
-00010370: 6672 6f7a 656e 6d75 6c74 6973 6574 5b61  frozenmultiset[a
-00010380: 7361 7272 6179 5d29 3a0a 2020 2020 2020  sarray]):.      
-00010390: 2020 7365 6c66 2e66 756e 6373 203d 2066    self.funcs = f
-000103a0: 756e 6373 0a20 2020 2020 2020 2066 756e  uncs.        fun
-000103b0: 6331 2c20 6675 6e63 3220 3d20 6675 6e63  c1, func2 = func
-000103c0: 730a 2020 2020 2020 2020 6173 7365 7274  s.        assert
-000103d0: 2065 7175 616c 7368 6170 6528 6675 6e63   equalshape(func
-000103e0: 312e 7368 6170 652c 2066 756e 6332 2e73  1.shape, func2.s
-000103f0: 6861 7065 2920 616e 6420 6675 6e63 312e  hape) and func1.
-00010400: 6474 7970 6520 3d3d 2066 756e 6332 2e64  dtype == func2.d
-00010410: 7479 7065 2021 3d20 626f 6f6c 2c20 2741  type != bool, 'A
-00010420: 6464 287b 7d2c 207b 7d29 272e 666f 726d  dd({}, {})'.form
-00010430: 6174 2866 756e 6331 2c20 6675 6e63 3229  at(func1, func2)
-00010440: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
-00010450: 2e5f 5f69 6e69 745f 5f28 6172 6773 3d73  .__init__(args=s
-00010460: 656c 662e 6675 6e63 732c 2073 6861 7065  elf.funcs, shape
-00010470: 3d66 756e 6331 2e73 6861 7065 2c20 6474  =func1.shape, dt
-00010480: 7970 653d 6675 6e63 312e 6474 7970 6529  ype=func1.dtype)
-00010490: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-000104a0: 2020 2020 6465 6620 5f69 6e66 6c61 7469      def _inflati
-000104b0: 6f6e 7328 7365 6c66 293a 0a20 2020 2020  ons(self):.     
-000104c0: 2020 2066 756e 6331 2c20 6675 6e63 3220     func1, func2 
-000104d0: 3d20 7365 6c66 2e66 756e 6373 0a20 2020  = self.funcs.   
-000104e0: 2020 2020 2066 756e 6332 5f69 6e66 6c61       func2_infla
-000104f0: 7469 6f6e 7320 3d20 6469 6374 2866 756e  tions = dict(fun
-00010500: 6332 2e5f 696e 666c 6174 696f 6e73 290a  c2._inflations).
-00010510: 2020 2020 2020 2020 696e 666c 6174 696f          inflatio
-00010520: 6e73 203d 205b 5d0a 2020 2020 2020 2020  ns = [].        
-00010530: 666f 7220 6178 6973 2c20 7061 7274 7331  for axis, parts1
-00010540: 2069 6e20 6675 6e63 312e 5f69 6e66 6c61   in func1._infla
-00010550: 7469 6f6e 733a 0a20 2020 2020 2020 2020  tions:.         
-00010560: 2020 2069 6620 6178 6973 206e 6f74 2069     if axis not i
-00010570: 6e20 6675 6e63 325f 696e 666c 6174 696f  n func2_inflatio
-00010580: 6e73 3a0a 2020 2020 2020 2020 2020 2020  ns:.            
-00010590: 2020 2020 636f 6e74 696e 7565 0a20 2020      continue.   
-000105a0: 2020 2020 2020 2020 2070 6172 7473 3220           parts2 
-000105b0: 3d20 6675 6e63 325f 696e 666c 6174 696f  = func2_inflatio
-000105c0: 6e73 5b61 7869 735d 0a20 2020 2020 2020  ns[axis].       
-000105d0: 2020 2020 2064 6f66 6d61 7073 203d 2073       dofmaps = s
-000105e0: 6574 2870 6172 7473 3129 207c 2073 6574  et(parts1) | set
-000105f0: 2870 6172 7473 3229 0a20 2020 2020 2020  (parts2).       
-00010600: 2020 2020 2069 6620 286c 656e 2870 6172       if (len(par
-00010610: 7473 3129 203c 206c 656e 2864 6f66 6d61  ts1) < len(dofma
-00010620: 7073 2920 616e 6420 6c65 6e28 7061 7274  ps) and len(part
-00010630: 7332 2920 3c20 6c65 6e28 646f 666d 6170  s2) < len(dofmap
-00010640: 7329 2020 2320 6e65 6974 6865 7220 7365  s)  # neither se
-00010650: 7420 6973 2061 2073 7562 7365 7420 6f66  t is a subset of
-00010660: 2074 6865 206f 7468 6572 3b20 746f 7461   the other; tota
-00010670: 6c20 6d61 7920 6265 2064 656e 7365 0a20  l may be dense. 
-00010680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010690: 2020 2061 6e64 2073 656c 662e 7368 6170     and self.shap
-000106a0: 655b 6178 6973 5d2e 6973 636f 6e73 7461  e[axis].isconsta
-000106b0: 6e74 2061 6e64 2061 6c6c 2864 6f66 6d61  nt and all(dofma
-000106c0: 702e 6973 636f 6e73 7461 6e74 2066 6f72  p.isconstant for
-000106d0: 2064 6f66 6d61 7020 696e 2064 6f66 6d61   dofmap in dofma
-000106e0: 7073 2929 3a0a 2020 2020 2020 2020 2020  ps)):.          
-000106f0: 2020 2020 2020 6d61 736b 203d 206e 756d        mask = num
-00010700: 7079 2e7a 6572 6f73 2869 6e74 2873 656c  py.zeros(int(sel
-00010710: 662e 7368 6170 655b 6178 6973 5d29 2c20  f.shape[axis]), 
-00010720: 6474 7970 653d 626f 6f6c 290a 2020 2020  dtype=bool).    
-00010730: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00010740: 646f 666d 6170 2069 6e20 646f 666d 6170  dofmap in dofmap
-00010750: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-00010760: 2020 2020 2020 206d 6173 6b5b 646f 666d         mask[dofm
-00010770: 6170 2e65 7661 6c28 295d 203d 2054 7275  ap.eval()] = Tru
-00010780: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-00010790: 2020 6966 206d 6173 6b2e 616c 6c28 293a    if mask.all():
-000107a0: 2020 2320 6178 6973 2061 6464 7320 7570    # axis adds up
-000107b0: 2074 6f20 6465 6e73 650a 2020 2020 2020   to dense.      
-000107c0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-000107d0: 6e74 696e 7565 0a20 2020 2020 2020 2020  ntinue.         
-000107e0: 2020 2069 6e66 6c61 7469 6f6e 732e 6170     inflations.ap
-000107f0: 7065 6e64 2828 6178 6973 2c20 7479 7065  pend((axis, type
-00010800: 732e 6672 6f7a 656e 6469 6374 2828 646f  s.frozendict((do
-00010810: 666d 6170 2c20 7574 696c 2e73 756d 2870  fmap, util.sum(p
-00010820: 6172 7473 5b64 6f66 6d61 705d 2066 6f72  arts[dofmap] for
-00010830: 2070 6172 7473 2069 6e20 2870 6172 7473   parts in (parts
-00010840: 312c 2070 6172 7473 3229 2069 6620 646f  1, parts2) if do
-00010850: 666d 6170 2069 6e20 7061 7274 7329 2920  fmap in parts)) 
-00010860: 666f 7220 646f 666d 6170 2069 6e20 646f  for dofmap in do
-00010870: 666d 6170 7329 2929 0a20 2020 2020 2020  fmaps))).       
-00010880: 2072 6574 7572 6e20 7475 706c 6528 696e   return tuple(in
-00010890: 666c 6174 696f 6e73 290a 0a20 2020 2064  flations)..    d
-000108a0: 6566 205f 7369 6d70 6c69 6669 6564 2873  ef _simplified(s
-000108b0: 656c 6629 3a0a 2020 2020 2020 2020 6675  elf):.        fu
-000108c0: 6e63 312c 2066 756e 6332 203d 2073 656c  nc1, func2 = sel
-000108d0: 662e 6675 6e63 730a 2020 2020 2020 2020  f.funcs.        
-000108e0: 6966 2066 756e 6331 203d 3d20 6675 6e63  if func1 == func
-000108f0: 323a 0a20 2020 2020 2020 2020 2020 2072  2:.            r
-00010900: 6574 7572 6e20 6d75 6c74 6970 6c79 2866  eturn multiply(f
-00010910: 756e 6331 2c20 3229 0a20 2020 2020 2020  unc1, 2).       
-00010920: 2066 6f72 2061 7865 7331 2069 6e20 6675   for axes1 in fu
-00010930: 6e63 312e 5f64 6961 676f 6e61 6c73 3a0a  nc1._diagonals:.
-00010940: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00010950: 6178 6573 3220 696e 2066 756e 6332 2e5f  axes2 in func2._
-00010960: 6469 6167 6f6e 616c 733a 0a20 2020 2020  diagonals:.     
-00010970: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-00010980: 6e28 6178 6573 3120 2620 6178 6573 3229  n(axes1 & axes2)
-00010990: 203e 3d20 323a 0a20 2020 2020 2020 2020   >= 2:.         
-000109a0: 2020 2020 2020 2020 2020 2061 7865 7320             axes 
-000109b0: 3d20 736f 7274 6564 2861 7865 7331 2026  = sorted(axes1 &
-000109c0: 2061 7865 7332 295b 3a32 5d0a 2020 2020   axes2)[:2].    
-000109d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000109e0: 7265 7475 726e 2064 6961 676f 6e61 6c69  return diagonali
-000109f0: 7a65 2874 616b 6564 6961 6728 6675 6e63  ze(takediag(func
-00010a00: 312c 202a 6178 6573 2920 2b20 7461 6b65  1, *axes) + take
-00010a10: 6469 6167 2866 756e 6332 2c20 2a61 7865  diag(func2, *axe
-00010a20: 7329 2c20 2a61 7865 7329 0a20 2020 2020  s), *axes).     
-00010a30: 2020 2023 204e 4f54 453a 2057 6869 6c65     # NOTE: While
-00010a40: 2069 7420 6973 2074 656d 7074 696e 6720   it is tempting 
-00010a50: 746f 2075 7365 2074 6865 205f 696e 666c  to use the _infl
-00010a60: 6174 696f 6e73 2061 7474 7269 6275 7465  ations attribute
-00010a70: 2074 6f20 7075 7368 0a20 2020 2020 2020   to push.       
-00010a80: 2023 2061 6464 6974 696f 6e73 2074 6872   # additions thr
-00010a90: 6f75 6768 2063 6f6d 6d6f 6e20 696e 666c  ough common infl
-00010aa0: 6174 696f 6e73 2c20 646f 696e 6720 736f  ations, doing so
-00010ab0: 206d 6179 2072 6573 756c 7420 696e 2069   may result in i
-00010ac0: 6e66 696e 6974 650a 2020 2020 2020 2020  nfinite.        
-00010ad0: 2320 7265 6375 7273 696f 6e20 696e 2063  # recursion in c
-00010ae0: 6173 6520 7477 6f20 6f72 206d 6f72 6520  ase two or more 
-00010af0: 6178 6573 2061 7265 2069 6e66 6c61 7465  axes are inflate
-00010b00: 642e 2054 6869 7320 6d65 6368 616e 6973  d. This mechanis
-00010b10: 6d20 6973 0a20 2020 2020 2020 2023 2069  m is.        # i
-00010b20: 6c6c 7573 7472 6174 6564 2069 6e20 7468  llustrated in th
-00010b30: 6520 666f 6c6c 6f77 696e 6720 7363 6865  e following sche
-00010b40: 6d61 7469 632c 2069 6e20 7768 6963 6820  matic, in which 
-00010b50: 3c49 3e20 616e 6420 3c4a 3e20 7265 7072  <I> and <J> repr
-00010b60: 6573 656e 740a 2020 2020 2020 2020 2320  esent.        # 
-00010b70: 696e 666c 6174 696f 6e73 2061 6c6f 6e67  inflations along
-00010b80: 2061 7869 7320 3120 616e 6420 3c4b 3e20   axis 1 and <K> 
-00010b90: 616e 6420 3c4c 3e20 696e 666c 6174 696f  and <L> inflatio
-00010ba0: 6e73 2061 6c6f 6e67 2061 7869 7320 323a  ns along axis 2:
-00010bb0: 0a20 2020 2020 2020 2023 0a20 2020 2020  .        #.     
-00010bc0: 2020 2023 2020 2020 2020 2020 4120 2020     #        A   
-00010bd0: 4220 2020 4320 2020 4420 2020 4520 2020  B   C   D   E   
-00010be0: 4620 2020 4720 2020 480a 2020 2020 2020  F   G   H.      
-00010bf0: 2020 2320 2020 2020 2020 3c49 3e20 3c4a    #       <I> <J
-00010c00: 3e20 3c49 3e20 3c4a 3e20 3c49 3e20 3c4a  > <I> <J> <I> <J
-00010c10: 3e20 3c49 3e20 3c4a 3e0a 2020 2020 2020  > <I> <J>.      
-00010c20: 2020 2320 202e 2d2d 2020 2020 5c2b 2f20    #  .--    \+/ 
-00010c30: 2020 2020 5c2b 2f20 2020 2020 5c2b 2f20      \+/     \+/ 
-00010c40: 2020 2020 5c2b 2f20 2020 3c2d 2d2e 0a20      \+/   <--.. 
-00010c50: 2020 2020 2020 2023 2020 7c20 2020 2020         #  |     
-00010c60: 2020 5c5f 5f3c 4b3e 5f5f 2f20 2020 2020    \__<K>__/     
-00010c70: 2020 5c5f 5f3c 4c3e 5f5f 2f20 2020 2020    \__<L>__/     
-00010c80: 2020 7c0a 2020 2020 2020 2020 2320 207c    |.        #  |
-00010c90: 2020 2020 2020 2020 2020 205c 5f5f 5f5f             \____
-00010ca0: 5f5f 5f2b 5f5f 5f5f 5f5f 5f2f 2020 2020  ___+_______/    
-00010cb0: 2020 2020 2020 207c 0a20 2020 2020 2020         |.       
-00010cc0: 2023 2020 7c20 2020 2020 2020 2020 2020   #  |           
-00010cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010ce0: 2020 2020 2020 2020 2020 2020 7c0a 2020              |.  
-00010cf0: 2020 2020 2020 2320 207c 2020 2020 2041        #  |     A
-00010d00: 2020 2045 2020 2043 2020 2047 2020 2042     E   C   G   B
-00010d10: 2020 2046 2020 2044 2020 2048 2020 2020     F   D   H    
-00010d20: 207c 0a20 2020 2020 2020 2023 2020 7c20   |.        #  | 
-00010d30: 2020 203c 4b3e 203c 4c3e 203c 4b3e 203c     <K> <L> <K> <
-00010d40: 4c3e 203c 4b3e 203c 4c3e 203c 4b3e 203c  L> <K> <L> <K> <
-00010d50: 4c3e 2020 2020 7c0a 2020 2020 2020 2020  L>    |.        
-00010d60: 2320 2027 2d2d 3e20 2020 5c2b 2f20 2020  #  '-->   \+/   
-00010d70: 2020 5c2b 2f20 2020 2020 5c2b 2f20 2020    \+/     \+/   
-00010d80: 2020 5c2b 2f20 2020 202d 2d27 0a20 2020    \+/    --'.   
-00010d90: 2020 2020 2023 2020 2020 2020 2020 2020       #          
-00010da0: 5c5f 5f3c 493e 5f5f 2f20 2020 2020 2020  \__<I>__/       
-00010db0: 5c5f 5f3c 4a3e 5f5f 2f0a 2020 2020 2020  \__<J>__/.      
-00010dc0: 2020 2320 2020 2020 2020 2020 2020 2020    #             
-00010dd0: 205c 5f5f 5f5f 5f5f 5f2b 5f5f 5f5f 5f5f   \_______+______
-00010de0: 5f2f 0a20 2020 2020 2020 2023 0a20 2020  _/.        #.   
-00010df0: 2020 2020 2023 2057 6520 696e 7374 6561       # We instea
-00010e00: 6420 7265 6c79 206f 6e20 496e 666c 6174  d rely on Inflat
-00010e10: 652e 5f61 6464 2074 6f20 6861 6e64 6c65  e._add to handle
-00010e20: 2074 6869 7320 7369 7475 6174 696f 6e2e   this situation.
-00010e30: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00010e40: 6675 6e63 312e 5f61 6464 2866 756e 6332  func1._add(func2
-00010e50: 2920 6f72 2066 756e 6332 2e5f 6164 6428  ) or func2._add(
-00010e60: 6675 6e63 3129 0a0a 2020 2020 6465 6620  func1)..    def 
-00010e70: 6576 616c 6628 7365 6c66 2c20 6172 7231  evalf(self, arr1
-00010e80: 2c20 6172 7232 3d4e 6f6e 6529 3a0a 2020  , arr2=None):.  
-00010e90: 2020 2020 2020 7265 7475 726e 2061 7272        return arr
-00010ea0: 3120 2b20 6172 7232 0a0a 2020 2020 6465  1 + arr2..    de
-00010eb0: 6620 5f73 756d 2873 656c 662c 2061 7869  f _sum(self, axi
-00010ec0: 7329 3a0a 2020 2020 2020 2020 7265 7475  s):.        retu
-00010ed0: 726e 2041 6464 285b 7375 6d28 6675 6e63  rn Add([sum(func
-00010ee0: 2c20 6178 6973 2920 666f 7220 6675 6e63  , axis) for func
-00010ef0: 2069 6e20 7365 6c66 2e66 756e 6373 5d29   in self.funcs])
-00010f00: 0a0a 2020 2020 6465 6620 5f64 6572 6976  ..    def _deriv
-00010f10: 6174 6976 6528 7365 6c66 2c20 7661 722c  ative(self, var,
-00010f20: 2073 6565 6e29 3a0a 2020 2020 2020 2020   seen):.        
-00010f30: 6675 6e63 312c 2066 756e 6332 203d 2073  func1, func2 = s
-00010f40: 656c 662e 6675 6e63 730a 2020 2020 2020  elf.funcs.      
-00010f50: 2020 7265 7475 726e 2064 6572 6976 6174    return derivat
-00010f60: 6976 6528 6675 6e63 312c 2076 6172 2c20  ive(func1, var, 
-00010f70: 7365 656e 2920 2b20 6465 7269 7661 7469  seen) + derivati
-00010f80: 7665 2866 756e 6332 2c20 7661 722c 2073  ve(func2, var, s
-00010f90: 6565 6e29 0a0a 2020 2020 6465 6620 5f74  een)..    def _t
-00010fa0: 616b 6564 6961 6728 7365 6c66 2c20 6178  akediag(self, ax
-00010fb0: 6973 312c 2061 7869 7332 293a 0a20 2020  is1, axis2):.   
-00010fc0: 2020 2020 2066 756e 6331 2c20 6675 6e63       func1, func
-00010fd0: 3220 3d20 7365 6c66 2e66 756e 6373 0a20  2 = self.funcs. 
-00010fe0: 2020 2020 2020 2072 6574 7572 6e20 4164         return Ad
-00010ff0: 6428 5b5f 7461 6b65 6469 6167 2866 756e  d([_takediag(fun
-00011000: 6331 2c20 6178 6973 312c 2061 7869 7332  c1, axis1, axis2
-00011010: 292c 205f 7461 6b65 6469 6167 2866 756e  ), _takediag(fun
-00011020: 6332 2c20 6178 6973 312c 2061 7869 7332  c2, axis1, axis2
-00011030: 295d 290a 0a20 2020 2064 6566 205f 7461  )])..    def _ta
-00011040: 6b65 2873 656c 662c 2069 6e64 6578 2c20  ke(self, index, 
-00011050: 6178 6973 293a 0a20 2020 2020 2020 2066  axis):.        f
-00011060: 756e 6331 2c20 6675 6e63 3220 3d20 7365  unc1, func2 = se
-00011070: 6c66 2e66 756e 6373 0a20 2020 2020 2020  lf.funcs.       
-00011080: 2072 6574 7572 6e20 4164 6428 5b5f 7461   return Add([_ta
-00011090: 6b65 2866 756e 6331 2c20 696e 6465 782c  ke(func1, index,
-000110a0: 2061 7869 7329 2c20 5f74 616b 6528 6675   axis), _take(fu
-000110b0: 6e63 322c 2069 6e64 6578 2c20 6178 6973  nc2, index, axis
-000110c0: 295d 290a 0a20 2020 2064 6566 205f 6164  )])..    def _ad
-000110d0: 6428 7365 6c66 2c20 6f74 6865 7229 3a0a  d(self, other):.
-000110e0: 2020 2020 2020 2020 6675 6e63 312c 2066          func1, f
-000110f0: 756e 6332 203d 2073 656c 662e 6675 6e63  unc2 = self.func
-00011100: 730a 2020 2020 2020 2020 6675 6e63 315f  s.        func1_
-00011110: 6f74 6865 7220 3d20 6675 6e63 312e 5f61  other = func1._a
-00011120: 6464 286f 7468 6572 290a 2020 2020 2020  dd(other).      
-00011130: 2020 6966 2066 756e 6331 5f6f 7468 6572    if func1_other
-00011140: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
-00011150: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00011160: 2041 6464 285b 6675 6e63 315f 6f74 6865   Add([func1_othe
-00011170: 722c 2066 756e 6332 5d29 0a20 2020 2020  r, func2]).     
-00011180: 2020 2066 756e 6332 5f6f 7468 6572 203d     func2_other =
-00011190: 2066 756e 6332 2e5f 6164 6428 6f74 6865   func2._add(othe
-000111a0: 7229 0a20 2020 2020 2020 2069 6620 6675  r).        if fu
-000111b0: 6e63 325f 6f74 6865 7220 6973 206e 6f74  nc2_other is not
-000111c0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-000111d0: 2020 2072 6574 7572 6e20 4164 6428 5b66     return Add([f
-000111e0: 756e 6331 2c20 6675 6e63 325f 6f74 6865  unc1, func2_othe
-000111f0: 725d 290a 0a20 2020 2064 6566 205f 756e  r])..    def _un
-00011200: 7261 7665 6c28 7365 6c66 2c20 6178 6973  ravel(self, axis
-00011210: 2c20 7368 6170 6529 3a0a 2020 2020 2020  , shape):.      
-00011220: 2020 7265 7475 726e 2041 6464 285b 756e    return Add([un
-00011230: 7261 7665 6c28 6675 6e63 2c20 6178 6973  ravel(func, axis
-00011240: 2c20 7368 6170 6529 2066 6f72 2066 756e  , shape) for fun
-00011250: 6320 696e 2073 656c 662e 6675 6e63 735d  c in self.funcs]
-00011260: 290a 0a20 2020 2064 6566 205f 6c6f 6f70  )..    def _loop
-00011270: 7375 6d28 7365 6c66 2c20 696e 6465 7829  sum(self, index)
-00011280: 3a0a 2020 2020 2020 2020 6966 2061 6e79  :.        if any
-00011290: 2869 6e64 6578 206e 6f74 2069 6e20 6675  (index not in fu
-000112a0: 6e63 2e61 7267 756d 656e 7473 2066 6f72  nc.arguments for
-000112b0: 2066 756e 6320 696e 2073 656c 662e 6675   func in self.fu
-000112c0: 6e63 7329 3a0a 2020 2020 2020 2020 2020  ncs):.          
-000112d0: 2020 7265 7475 726e 2041 6464 285b 6c6f    return Add([lo
-000112e0: 6f70 5f73 756d 2866 756e 632c 2069 6e64  op_sum(func, ind
-000112f0: 6578 2920 666f 7220 6675 6e63 2069 6e20  ex) for func in 
-00011300: 7365 6c66 2e66 756e 6373 5d29 0a0a 2020  self.funcs])..  
-00011310: 2020 6465 6620 5f6d 756c 7469 706c 7928    def _multiply(
-00011320: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-00011330: 2020 2020 2020 6675 6e63 312c 2066 756e        func1, fun
-00011340: 6332 203d 2073 656c 662e 6675 6e63 730a  c2 = self.funcs.
-00011350: 2020 2020 2020 2020 6966 2028 6675 6e63          if (func
-00011360: 312e 5f69 6e66 6c61 7469 6f6e 7320 6f72  1._inflations or
-00011370: 2066 756e 6331 2e5f 6469 6167 6f6e 616c   func1._diagonal
-00011380: 7329 2061 6e64 2028 6675 6e63 322e 5f69  s) and (func2._i
-00011390: 6e66 6c61 7469 6f6e 7320 6f72 2066 756e  nflations or fun
-000113a0: 6332 2e5f 6469 6167 6f6e 616c 7329 3a0a  c2._diagonals):.
-000113b0: 2020 2020 2020 2020 2020 2020 2320 4e4f              # NO
-000113c0: 5445 3a20 4173 2074 6869 7320 6f70 6572  TE: As this oper
-000113d0: 6174 696f 6e20 6973 2074 6865 2070 7265  ation is the pre
-000113e0: 6369 7365 206f 7070 6f73 6974 6520 6f66  cise opposite of
-000113f0: 204d 756c 7469 706c 792e 5f61 6464 2c20   Multiply._add, 
-00011400: 7468 6572 650a 2020 2020 2020 2020 2020  there.          
-00011410: 2020 2320 6170 7065 6172 7320 746f 2062    # appears to b
-00011420: 6520 6120 6772 6561 7420 7269 736b 206f  e a great risk o
-00011430: 6620 7265 6375 7273 696f 6e2e 2048 6f77  f recursion. How
-00011440: 6576 6572 2c20 7369 6e63 6520 626f 7468  ever, since both
-00011450: 2066 6163 746f 7273 0a20 2020 2020 2020   factors.       
-00011460: 2020 2020 2023 2061 7265 2073 7061 7273       # are spars
-00011470: 652c 2077 6520 6361 6e20 6265 2063 6572  e, we can be cer
-00011480: 7461 696e 2074 6861 7420 7375 6273 6571  tain that subseq
-00011490: 7565 6e74 2073 696d 7069 6669 6361 7469  uent simpificati
-000114a0: 6f6e 7320 7769 6c6c 0a20 2020 2020 2020  ons will.       
-000114b0: 2020 2020 2023 2069 7272 6576 6572 7369       # irreversi
-000114c0: 626c 7920 7072 6f63 6573 7320 7468 6520  bly process the 
-000114d0: 6e65 7720 7465 726d 7320 6265 666f 7265  new terms before
-000114e0: 2072 6561 6368 696e 6720 7468 6973 2070   reaching this p
-000114f0: 6f69 6e74 2e0a 2020 2020 2020 2020 2020  oint..          
-00011500: 2020 7265 7475 726e 2028 6675 6e63 3120    return (func1 
-00011510: 2a20 6f74 6865 7229 202b 2028 6675 6e63  * other) + (func
-00011520: 3220 2a20 6f74 6865 7229 0a0a 2020 2020  2 * other)..    
-00011530: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-00011540: 6620 5f61 7373 7061 7273 6528 7365 6c66  f _assparse(self
-00011550: 293a 0a20 2020 2020 2020 2066 756e 6331  ):.        func1
-00011560: 2c20 6675 6e63 3220 3d20 7365 6c66 2e66  , func2 = self.f
-00011570: 756e 6373 0a20 2020 2020 2020 2072 6574  uncs.        ret
-00011580: 7572 6e20 5f67 6174 6865 7273 7061 7273  urn _gatherspars
-00011590: 6563 6875 6e6b 7328 6974 6572 746f 6f6c  echunks(itertool
-000115a0: 732e 6368 6169 6e28 6675 6e63 312e 5f61  s.chain(func1._a
-000115b0: 7373 7061 7273 652c 2066 756e 6332 2e5f  ssparse, func2._
-000115c0: 6173 7370 6172 7365 2929 0a0a 2020 2020  assparse))..    
-000115d0: 6465 6620 5f69 6e74 626f 756e 6473 5f69  def _intbounds_i
-000115e0: 6d70 6c28 7365 6c66 293a 0a20 2020 2020  mpl(self):.     
-000115f0: 2020 2066 756e 6331 2c20 6675 6e63 3220     func1, func2 
-00011600: 3d20 7365 6c66 2e66 756e 6373 0a20 2020  = self.funcs.   
-00011610: 2020 2020 206c 6f77 6572 312c 2075 7070       lower1, upp
-00011620: 6572 3120 3d20 6675 6e63 312e 5f69 6e74  er1 = func1._int
-00011630: 626f 756e 6473 0a20 2020 2020 2020 206c  bounds.        l
-00011640: 6f77 6572 322c 2075 7070 6572 3220 3d20  ower2, upper2 = 
-00011650: 6675 6e63 322e 5f69 6e74 626f 756e 6473  func2._intbounds
-00011660: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00011670: 6c6f 7765 7231 202b 206c 6f77 6572 322c  lower1 + lower2,
-00011680: 2075 7070 6572 3120 2b20 7570 7065 7232   upper1 + upper2
-00011690: 0a0a 0a63 6c61 7373 2045 696e 7375 6d28  ...class Einsum(
-000116a0: 4172 7261 7929 3a0a 0a20 2020 205f 5f73  Array):..    __s
-000116b0: 6c6f 7473 5f5f 203d 2027 6172 6773 272c  lots__ = 'args',
-000116c0: 2027 6f75 745f 6964 7827 2c20 2761 7267   'out_idx', 'arg
-000116d0: 735f 6964 7827 2c20 275f 6569 6e73 756d  s_idx', '_einsum
-000116e0: 666d 7427 2c20 275f 6861 735f 7375 6d6d  fmt', '_has_summ
-000116f0: 6564 5f61 7865 7327 0a0a 2020 2020 4074  ed_axes'..    @t
-00011700: 7970 6573 2e61 7070 6c79 5f61 6e6e 6f74  ypes.apply_annot
-00011710: 6174 696f 6e73 0a20 2020 2064 6566 205f  ations.    def _
-00011720: 5f69 6e69 745f 5f28 7365 6c66 2c20 6172  _init__(self, ar
-00011730: 6773 3a20 6173 6172 7261 7973 2c20 6172  gs: asarrays, ar
-00011740: 6773 5f69 6478 3a20 7479 7065 732e 7475  gs_idx: types.tu
-00011750: 706c 655b 7479 7065 732e 7475 706c 655b  ple[types.tuple[
-00011760: 7479 7065 732e 7374 7269 6374 696e 745d  types.strictint]
-00011770: 5d2c 206f 7574 5f69 6478 3a20 7479 7065  ], out_idx: type
-00011780: 732e 7475 706c 655b 7479 7065 732e 7374  s.tuple[types.st
-00011790: 7269 6374 696e 745d 293a 0a20 2020 2020  rictint]):.     
-000117a0: 2020 2069 6620 6c65 6e28 6172 6773 5f69     if len(args_i
-000117b0: 6478 2920 213d 206c 656e 2861 7267 7329  dx) != len(args)
-000117c0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-000117d0: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
-000117e0: 4578 7065 6374 6564 206f 6e65 206c 6973  Expected one lis
-000117f0: 7420 6f66 2069 6e64 6963 6573 2066 6f72  t of indices for
-00011800: 2065 7665 7279 2061 7267 756d 656e 742c   every argument,
-00011810: 2062 7574 2067 6f74 207b 7d20 616e 6420   but got {} and 
-00011820: 7b7d 2c20 7265 7370 6563 7469 7665 6c79  {}, respectively
-00011830: 2e27 2e66 6f72 6d61 7428 6c65 6e28 6172  .'.format(len(ar
-00011840: 6773 5f69 6478 292c 206c 656e 2861 7267  gs_idx), len(arg
-00011850: 7329 2929 0a20 2020 2020 2020 2066 6f72  s))).        for
-00011860: 2069 6172 672c 2028 6964 782c 2061 7267   iarg, (idx, arg
-00011870: 2920 696e 2065 6e75 6d65 7261 7465 287a  ) in enumerate(z
-00011880: 6970 2861 7267 735f 6964 782c 2061 7267  ip(args_idx, arg
-00011890: 7329 2c20 3129 3a0a 2020 2020 2020 2020  s), 1):.        
-000118a0: 2020 2020 6966 206c 656e 2869 6478 2920      if len(idx) 
-000118b0: 213d 2061 7267 2e6e 6469 6d3a 0a20 2020  != arg.ndim:.   
-000118c0: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-000118d0: 7365 2056 616c 7565 4572 726f 7228 2745  se ValueError('E
-000118e0: 7870 6563 7465 6420 6f6e 6520 696e 6465  xpected one inde
-000118f0: 7820 666f 7220 6576 6572 7920 6178 6973  x for every axis
-00011900: 206f 6620 6172 6775 6d65 6e74 207b 7d2c   of argument {},
-00011910: 2062 7574 2067 6f74 207b 7d20 616e 6420   but got {} and 
-00011920: 7b7d 2c20 7265 7370 6563 7469 7665 6c79  {}, respectively
-00011930: 2e27 2e66 6f72 6d61 7428 6961 7267 2c20  .'.format(iarg, 
-00011940: 6c65 6e28 6964 7829 2c20 6172 672e 6e64  len(idx), arg.nd
-00011950: 696d 2929 0a20 2020 2020 2020 2064 7479  im)).        dty
-00011960: 7065 203d 2061 7267 735b 305d 2e64 7479  pe = args[0].dty
-00011970: 7065 0a20 2020 2020 2020 2069 6620 6474  pe.        if dt
-00011980: 7970 6520 3d3d 2062 6f6f 6c20 6f72 2061  ype == bool or a
-00011990: 6e79 2861 7267 2e64 7479 7065 2021 3d20  ny(arg.dtype != 
-000119a0: 6474 7970 6520 666f 7220 6172 6720 696e  dtype for arg in
-000119b0: 2061 7267 735b 313a 5d29 3a0a 2020 2020   args[1:]):.    
-000119c0: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-000119d0: 6c75 6545 7272 6f72 2827 496e 636f 6e73  lueError('Incons
-000119e0: 6973 7465 6e74 206f 7220 696e 7661 6c69  istent or invali
-000119f0: 6420 6474 7970 6573 2e27 290a 2020 2020  d dtypes.').    
-00011a00: 2020 2020 6966 206c 656e 286f 7574 5f69      if len(out_i
-00011a10: 6478 2920 213d 206c 656e 2873 6574 286f  dx) != len(set(o
-00011a20: 7574 5f69 6478 2929 3a0a 2020 2020 2020  ut_idx)):.      
-00011a30: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00011a40: 6545 7272 6f72 2827 5265 7065 6174 6564  eError('Repeated
-00011a50: 206f 7574 7075 7420 696e 6469 6365 732e   output indices.
-00011a60: 2729 0a20 2020 2020 2020 206c 656e 6774  ').        lengt
-00011a70: 6873 203d 207b 7d0a 2020 2020 2020 2020  hs = {}.        
-00011a80: 666f 7220 6964 782c 2061 7267 2069 6e20  for idx, arg in 
-00011a90: 7a69 7028 6172 6773 5f69 6478 2c20 6172  zip(args_idx, ar
-00011aa0: 6773 293a 0a20 2020 2020 2020 2020 2020  gs):.           
-00011ab0: 2066 6f72 2069 2c20 6c65 6e67 7468 2069   for i, length i
-00011ac0: 6e20 7a69 7028 6964 782c 2061 7267 2e73  n zip(idx, arg.s
-00011ad0: 6861 7065 293a 0a20 2020 2020 2020 2020  hape):.         
-00011ae0: 2020 2020 2020 2069 6620 6920 6e6f 7420         if i not 
-00011af0: 696e 206c 656e 6774 6873 3a0a 2020 2020  in lengths:.    
-00011b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b10: 6c65 6e67 7468 735b 695d 203d 206c 656e  lengths[i] = len
-00011b20: 6774 680a 2020 2020 2020 2020 2020 2020  gth.            
-00011b30: 2020 2020 656c 6966 206e 6f74 2065 7175      elif not equ
-00011b40: 616c 696e 6465 7828 6c65 6e67 7468 735b  alindex(lengths[
-00011b50: 695d 2c20 6c65 6e67 7468 293a 0a20 2020  i], length):.   
-00011b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b70: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00011b80: 7228 2741 7865 7320 7769 7468 2069 6e64  r('Axes with ind
-00011b90: 6578 207b 7d20 6861 7665 2064 6966 6665  ex {} have diffe
-00011ba0: 7265 6e74 206c 656e 6774 6873 2e27 2e66  rent lengths.'.f
-00011bb0: 6f72 6d61 7428 6929 290a 2020 2020 2020  ormat(i)).      
-00011bc0: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
-00011bd0: 2020 2073 6861 7065 203d 205b 6c65 6e67     shape = [leng
-00011be0: 7468 735b 695d 2066 6f72 2069 2069 6e20  ths[i] for i in 
-00011bf0: 6f75 745f 6964 785d 0a20 2020 2020 2020  out_idx].       
-00011c00: 2065 7863 6570 7420 4b65 7945 7272 6f72   except KeyError
-00011c10: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-00011c20: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
-00011c30: 4f75 7470 7574 2061 7869 7320 7b7d 2069  Output axis {} i
-00011c40: 7320 6e6f 7420 6c69 7374 6564 2069 6e20  s not listed in 
-00011c50: 616e 7920 6f66 2074 6865 2061 7267 756d  any of the argum
-00011c60: 656e 7473 2e27 2e66 6f72 6d61 7428 272c  ents.'.format(',
-00011c70: 2027 2e6a 6f69 6e28 6920 666f 7220 6920   '.join(i for i 
-00011c80: 696e 206f 7574 5f69 6478 2069 6620 6920  in out_idx if i 
-00011c90: 6e6f 7420 696e 206c 656e 6774 6873 2929  not in lengths))
-00011ca0: 290a 2020 2020 2020 2020 7365 6c66 2e61  ).        self.a
-00011cb0: 7267 7320 3d20 6172 6773 0a20 2020 2020  rgs = args.     
-00011cc0: 2020 2073 656c 662e 6172 6773 5f69 6478     self.args_idx
-00011cd0: 203d 2061 7267 735f 6964 780a 2020 2020   = args_idx.    
-00011ce0: 2020 2020 7365 6c66 2e6f 7574 5f69 6478      self.out_idx
-00011cf0: 203d 206f 7574 5f69 6478 0a20 2020 2020   = out_idx.     
-00011d00: 2020 2073 656c 662e 5f65 696e 7375 6d66     self._einsumf
-00011d10: 6d74 203d 2027 2c27 2e6a 6f69 6e28 2727  mt = ','.join(''
-00011d20: 2e6a 6f69 6e28 6368 7228 3937 2b69 2920  .join(chr(97+i) 
-00011d30: 666f 7220 6920 696e 2069 6478 2920 666f  for i in idx) fo
-00011d40: 7220 6964 7820 696e 2061 7267 735f 6964  r idx in args_id
-00011d50: 7829 202b 2027 2d3e 2720 2b20 2727 2e6a  x) + '->' + ''.j
-00011d60: 6f69 6e28 6368 7228 3937 2b69 2920 666f  oin(chr(97+i) fo
-00011d70: 7220 6920 696e 206f 7574 5f69 6478 290a  r i in out_idx).
-00011d80: 2020 2020 2020 2020 7365 6c66 2e5f 6861          self._ha
-00011d90: 735f 7375 6d6d 6564 5f61 7865 7320 3d20  s_summed_axes = 
-00011da0: 6c65 6e28 6c65 6e67 7468 7329 203e 206c  len(lengths) > l
-00011db0: 656e 286f 7574 5f69 6478 290a 2020 2020  en(out_idx).    
-00011dc0: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
-00011dd0: 6974 5f5f 2861 7267 733d 7365 6c66 2e61  it__(args=self.a
-00011de0: 7267 732c 2073 6861 7065 3d73 6861 7065  rgs, shape=shape
-00011df0: 2c20 6474 7970 653d 6474 7970 6529 0a0a  , dtype=dtype)..
-00011e00: 2020 2020 6465 6620 6576 616c 6628 7365      def evalf(se
-00011e10: 6c66 2c20 2a61 7267 7329 3a0a 2020 2020  lf, *args):.    
-00011e20: 2020 2020 6966 2073 656c 662e 5f68 6173      if self._has
-00011e30: 5f73 756d 6d65 645f 6178 6573 3a0a 2020  _summed_axes:.  
-00011e40: 2020 2020 2020 2020 2020 6172 6773 203d            args =
-00011e50: 2074 7570 6c65 286e 756d 7079 2e61 7361   tuple(numpy.asa
-00011e60: 7272 6179 2861 7267 2c20 6f72 6465 723d  rray(arg, order=
-00011e70: 2746 2729 2066 6f72 2061 7267 2069 6e20  'F') for arg in 
-00011e80: 6172 6773 290a 2020 2020 2020 2020 7265  args).        re
-00011e90: 7475 726e 206e 756d 7079 2e63 6f72 652e  turn numpy.core.
-00011ea0: 6d75 6c74 6961 7272 6179 2e63 5f65 696e  multiarray.c_ein
-00011eb0: 7375 6d28 7365 6c66 2e5f 6569 6e73 756d  sum(self._einsum
-00011ec0: 666d 742c 202a 6172 6773 290a 0a20 2020  fmt, *args)..   
-00011ed0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-00011ee0: 6566 205f 6e6f 6465 5f64 6574 6169 6c73  ef _node_details
-00011ef0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00011f00: 7265 7475 726e 2073 656c 662e 5f65 696e  return self._ein
-00011f10: 7375 6d66 6d74 0a0a 2020 2020 6465 6620  sumfmt..    def 
-00011f20: 5f73 696d 706c 6966 6965 6428 7365 6c66  _simplified(self
-00011f30: 293a 0a20 2020 2020 2020 2066 6f72 2069  ):.        for i
-00011f40: 2c20 6172 6720 696e 2065 6e75 6d65 7261  , arg in enumera
-00011f50: 7465 2873 656c 662e 6172 6773 293a 0a20  te(self.args):. 
-00011f60: 2020 2020 2020 2020 2020 2069 6620 6973             if is
-00011f70: 696e 7374 616e 6365 2861 7267 2c20 5472  instance(arg, Tr
-00011f80: 616e 7370 6f73 6529 3a20 2023 2061 6273  anspose):  # abs
-00011f90: 6f72 6220 6054 7261 6e73 706f 7365 600a  orb `Transpose`.
-00011fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011fb0: 6964 7820 3d20 7475 706c 6528 6d61 7028  idx = tuple(map(
-00011fc0: 7365 6c66 2e61 7267 735f 6964 785b 695d  self.args_idx[i]
-00011fd0: 2e5f 5f67 6574 6974 656d 5f5f 2c20 6e75  .__getitem__, nu
-00011fe0: 6d70 792e 6172 6773 6f72 7428 6172 672e  mpy.argsort(arg.
-00011ff0: 6178 6573 2929 290a 2020 2020 2020 2020  axes))).        
-00012000: 2020 2020 2020 2020 7265 7475 726e 2045          return E
-00012010: 696e 7375 6d28 7365 6c66 2e61 7267 735b  insum(self.args[
-00012020: 3a69 5d2b 2861 7267 2e66 756e 632c 292b  :i]+(arg.func,)+
-00012030: 7365 6c66 2e61 7267 735b 692b 313a 5d2c  self.args[i+1:],
-00012040: 2073 656c 662e 6172 6773 5f69 6478 5b3a   self.args_idx[:
-00012050: 695d 2b28 6964 782c 292b 7365 6c66 2e61  i]+(idx,)+self.a
-00012060: 7267 735f 6964 785b 692b 313a 5d2c 2073  rgs_idx[i+1:], s
-00012070: 656c 662e 6f75 745f 6964 7829 0a0a 2020  elf.out_idx)..  
-00012080: 2020 6465 6620 5f73 756d 2873 656c 662c    def _sum(self,
-00012090: 2061 7869 7329 3a0a 2020 2020 2020 2020   axis):.        
-000120a0: 6966 206e 6f74 2028 3020 3c3d 2061 7869  if not (0 <= axi
-000120b0: 7320 3c20 7365 6c66 2e6e 6469 6d29 3a0a  s < self.ndim):.
-000120c0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-000120d0: 6520 496e 6465 7845 7272 6f72 2827 4178  e IndexError('Ax
-000120e0: 6973 206f 7574 206f 6620 7261 6e67 652e  is out of range.
-000120f0: 2729 0a20 2020 2020 2020 2072 6574 7572  ').        retur
-00012100: 6e20 4569 6e73 756d 2873 656c 662e 6172  n Einsum(self.ar
-00012110: 6773 2c20 7365 6c66 2e61 7267 735f 6964  gs, self.args_id
-00012120: 782c 2073 656c 662e 6f75 745f 6964 785b  x, self.out_idx[
-00012130: 3a61 7869 735d 202b 2073 656c 662e 6f75  :axis] + self.ou
-00012140: 745f 6964 785b 6178 6973 2b31 3a5d 290a  t_idx[axis+1:]).
-00012150: 0a20 2020 2064 6566 205f 7461 6b65 6469  .    def _takedi
-00012160: 6167 2873 656c 662c 2061 7869 7331 2c20  ag(self, axis1, 
-00012170: 6178 6973 3229 3a0a 2020 2020 2020 2020  axis2):.        
-00012180: 6966 206e 6f74 2028 3020 3c3d 2061 7869  if not (0 <= axi
-00012190: 7331 203c 2061 7869 7332 203c 2073 656c  s1 < axis2 < sel
-000121a0: 662e 6e64 696d 293a 0a20 2020 2020 2020  f.ndim):.       
-000121b0: 2020 2020 2072 6169 7365 2049 6e64 6578       raise Index
-000121c0: 4572 726f 7228 2741 7869 7320 6f75 7420  Error('Axis out 
-000121d0: 6f66 2072 616e 6765 2e27 290a 2020 2020  of range.').    
-000121e0: 2020 2020 696b 6565 702c 2069 726d 203d      ikeep, irm =
-000121f0: 2073 656c 662e 6f75 745f 6964 785b 6178   self.out_idx[ax
-00012200: 6973 315d 2c20 7365 6c66 2e6f 7574 5f69  is1], self.out_i
-00012210: 6478 5b61 7869 7332 5d0a 2020 2020 2020  dx[axis2].      
-00012220: 2020 6172 6773 5f69 6478 203d 2074 7570    args_idx = tup
-00012230: 6c65 2874 7570 6c65 2869 6b65 6570 2069  le(tuple(ikeep i
-00012240: 6620 6920 3d3d 2069 726d 2065 6c73 6520  f i == irm else 
-00012250: 6920 666f 7220 6920 696e 2069 6478 2920  i for i in idx) 
-00012260: 666f 7220 6964 7820 696e 2073 656c 662e  for idx in self.
-00012270: 6172 6773 5f69 6478 290a 2020 2020 2020  args_idx).      
-00012280: 2020 7265 7475 726e 2045 696e 7375 6d28    return Einsum(
-00012290: 7365 6c66 2e61 7267 732c 2061 7267 735f  self.args, args_
-000122a0: 6964 782c 2073 656c 662e 6f75 745f 6964  idx, self.out_id
-000122b0: 785b 3a61 7869 7331 5d20 2b20 7365 6c66  x[:axis1] + self
-000122c0: 2e6f 7574 5f69 6478 5b61 7869 7331 2b31  .out_idx[axis1+1
-000122d0: 3a61 7869 7332 5d20 2b20 7365 6c66 2e6f  :axis2] + self.o
-000122e0: 7574 5f69 6478 5b61 7869 7332 2b31 3a5d  ut_idx[axis2+1:]
-000122f0: 202b 2028 696b 6565 702c 2929 0a0a 0a63   + (ikeep,))...c
-00012300: 6c61 7373 2053 756d 2841 7272 6179 293a  lass Sum(Array):
-00012310: 0a0a 2020 2020 5f5f 736c 6f74 735f 5f20  ..    __slots__ 
-00012320: 3d20 2766 756e 6327 0a0a 2020 2020 4074  = 'func'..    @t
-00012330: 7970 6573 2e61 7070 6c79 5f61 6e6e 6f74  ypes.apply_annot
-00012340: 6174 696f 6e73 0a20 2020 2064 6566 205f  ations.    def _
-00012350: 5f69 6e69 745f 5f28 7365 6c66 2c20 6675  _init__(self, fu
-00012360: 6e63 3a20 6173 6172 7261 7929 3a0a 2020  nc: asarray):.  
-00012370: 2020 2020 2020 6173 7365 7274 2066 756e        assert fun
-00012380: 632e 6474 7970 6520 213d 2062 6f6f 6c2c  c.dtype != bool,
-00012390: 2027 5375 6d28 7b7d 2927 2e66 6f72 6d61   'Sum({})'.forma
-000123a0: 7428 6675 6e63 290a 2020 2020 2020 2020  t(func).        
-000123b0: 7365 6c66 2e66 756e 6320 3d20 6675 6e63  self.func = func
-000123c0: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
-000123d0: 2e5f 5f69 6e69 745f 5f28 6172 6773 3d5b  .__init__(args=[
-000123e0: 6675 6e63 5d2c 2073 6861 7065 3d66 756e  func], shape=fun
-000123f0: 632e 7368 6170 655b 3a2d 315d 2c20 6474  c.shape[:-1], dt
-00012400: 7970 653d 6675 6e63 2e64 7479 7065 290a  ype=func.dtype).
-00012410: 0a20 2020 2064 6566 205f 7369 6d70 6c69  .    def _simpli
-00012420: 6669 6564 2873 656c 6629 3a0a 2020 2020  fied(self):.    
-00012430: 2020 2020 6966 2065 7175 616c 696e 6465      if equalinde
-00012440: 7828 7365 6c66 2e66 756e 632e 7368 6170  x(self.func.shap
-00012450: 655b 2d31 5d2c 2031 293a 0a20 2020 2020  e[-1], 1):.     
-00012460: 2020 2020 2020 2072 6574 7572 6e20 5461         return Ta
-00012470: 6b65 2873 656c 662e 6675 6e63 2c20 3029  ke(self.func, 0)
-00012480: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00012490: 7365 6c66 2e66 756e 632e 5f73 756d 2873  self.func._sum(s
-000124a0: 656c 662e 6e64 696d 290a 0a20 2020 2064  elf.ndim)..    d
-000124b0: 6566 2065 7661 6c66 2873 656c 662c 2061  ef evalf(self, a
-000124c0: 7272 293a 0a20 2020 2020 2020 2061 7373  rr):.        ass
-000124d0: 6572 7420 6172 722e 6e64 696d 203d 3d20  ert arr.ndim == 
-000124e0: 7365 6c66 2e6e 6469 6d2b 310a 2020 2020  self.ndim+1.    
-000124f0: 2020 2020 7265 7475 726e 206e 756d 7079      return numpy
-00012500: 2e73 756d 2861 7272 2c20 2d31 290a 0a20  .sum(arr, -1).. 
-00012510: 2020 2064 6566 205f 7375 6d28 7365 6c66     def _sum(self
-00012520: 2c20 6178 6973 293a 0a20 2020 2020 2020  , axis):.       
-00012530: 2074 7279 7375 6d20 3d20 7365 6c66 2e66   trysum = self.f
-00012540: 756e 632e 5f73 756d 2861 7869 7329 0a20  unc._sum(axis). 
-00012550: 2020 2020 2020 2069 6620 7472 7973 756d         if trysum
-00012560: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
-00012570: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00012580: 2053 756d 2874 7279 7375 6d29 0a0a 2020   Sum(trysum)..  
-00012590: 2020 6465 6620 5f64 6572 6976 6174 6976    def _derivativ
-000125a0: 6528 7365 6c66 2c20 7661 722c 2073 6565  e(self, var, see
-000125b0: 6e29 3a0a 2020 2020 2020 2020 7265 7475  n):.        retu
-000125c0: 726e 2073 756d 2864 6572 6976 6174 6976  rn sum(derivativ
-000125d0: 6528 7365 6c66 2e66 756e 632c 2076 6172  e(self.func, var
-000125e0: 2c20 7365 656e 292c 2073 656c 662e 6e64  , seen), self.nd
-000125f0: 696d 290a 0a20 2020 2040 7072 6f70 6572  im)..    @proper
-00012600: 7479 0a20 2020 2064 6566 205f 6173 7370  ty.    def _assp
-00012610: 6172 7365 2873 656c 6629 3a0a 2020 2020  arse(self):.    
-00012620: 2020 2020 6368 756e 6b73 203d 205b 5d0a      chunks = [].
-00012630: 2020 2020 2020 2020 666f 7220 2a69 6e64          for *ind
-00012640: 6963 6573 2c20 5f72 6d69 6478 2c20 7661  ices, _rmidx, va
-00012650: 6c75 6573 2069 6e20 7365 6c66 2e66 756e  lues in self.fun
-00012660: 632e 5f61 7373 7061 7273 653a 0a20 2020  c._assparse:.   
-00012670: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-00012680: 2e6e 6469 6d20 3d3d 2030 3a0a 2020 2020  .ndim == 0:.    
-00012690: 2020 2020 2020 2020 2020 2020 6e73 756d              nsum
-000126a0: 203d 2076 616c 7565 732e 6e64 696d 0a20   = values.ndim. 
-000126b0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-000126c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000126d0: 202a 696e 6469 6365 732c 2077 6865 7265   *indices, where
-000126e0: 203d 2075 6e61 6c69 676e 282a 696e 6469   = unalign(*indi
-000126f0: 6365 7329 0a20 2020 2020 2020 2020 2020  ces).           
-00012700: 2020 2020 2076 616c 7565 7320 3d20 7472       values = tr
-00012710: 616e 7370 6f73 6528 7661 6c75 6573 2c20  anspose(values, 
-00012720: 7768 6572 6520 2b20 7475 706c 6528 6920  where + tuple(i 
-00012730: 666f 7220 6920 696e 2072 616e 6765 2876  for i in range(v
-00012740: 616c 7565 732e 6e64 696d 2920 6966 2069  alues.ndim) if i
-00012750: 206e 6f74 2069 6e20 7768 6572 6529 290a   not in where)).
-00012760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012770: 6e73 756d 203d 2076 616c 7565 732e 6e64  nsum = values.nd
-00012780: 696d 202d 206c 656e 2877 6865 7265 290a  im - len(where).
-00012790: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-000127a0: 6920 696e 2072 616e 6765 286e 7375 6d29  i in range(nsum)
-000127b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000127c0: 2020 7661 6c75 6573 203d 2053 756d 2876    values = Sum(v
-000127d0: 616c 7565 7329 0a20 2020 2020 2020 2020  alues).         
-000127e0: 2020 2063 6875 6e6b 732e 6170 7065 6e64     chunks.append
-000127f0: 2828 2a69 6e64 6963 6573 2c20 7661 6c75  ((*indices, valu
-00012800: 6573 2929 0a20 2020 2020 2020 2072 6574  es)).        ret
-00012810: 7572 6e20 5f67 6174 6865 7273 7061 7273  urn _gatherspars
-00012820: 6563 6875 6e6b 7328 6368 756e 6b73 290a  echunks(chunks).
-00012830: 0a20 2020 2064 6566 205f 696e 7462 6f75  .    def _intbou
-00012840: 6e64 735f 696d 706c 2873 656c 6629 3a0a  nds_impl(self):.
-00012850: 2020 2020 2020 2020 6c6f 7765 725f 6675          lower_fu
-00012860: 6e63 2c20 7570 7065 725f 6675 6e63 203d  nc, upper_func =
-00012870: 2073 656c 662e 6675 6e63 2e5f 696e 7462   self.func._intb
-00012880: 6f75 6e64 730a 2020 2020 2020 2020 6c6f  ounds.        lo
-00012890: 7765 725f 6c65 6e67 7468 2c20 7570 7065  wer_length, uppe
-000128a0: 725f 6c65 6e67 7468 203d 2073 656c 662e  r_length = self.
-000128b0: 6675 6e63 2e73 6861 7065 5b2d 315d 2e5f  func.shape[-1]._
-000128c0: 696e 7462 6f75 6e64 730a 2020 2020 2020  intbounds.      
-000128d0: 2020 6966 2075 7070 6572 5f6c 656e 6774    if upper_lengt
-000128e0: 6820 3d3d 2030 3a0a 2020 2020 2020 2020  h == 0:.        
-000128f0: 2020 2020 7265 7475 726e 2030 2c20 300a      return 0, 0.
-00012900: 2020 2020 2020 2020 656c 6966 206c 6f77          elif low
-00012910: 6572 5f6c 656e 6774 6820 3d3d 2030 3a0a  er_length == 0:.
-00012920: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00012930: 726e 206d 696e 2830 2c20 6c6f 7765 725f  rn min(0, lower_
-00012940: 6675 6e63 202a 2075 7070 6572 5f6c 656e  func * upper_len
-00012950: 6774 6829 2c20 6d61 7828 302c 2075 7070  gth), max(0, upp
-00012960: 6572 5f66 756e 6320 2a20 7570 7065 725f  er_func * upper_
-00012970: 6c65 6e67 7468 290a 2020 2020 2020 2020  length).        
-00012980: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00012990: 2020 7265 7475 726e 206d 696e 286c 6f77    return min(low
-000129a0: 6572 5f66 756e 6320 2a20 6c6f 7765 725f  er_func * lower_
-000129b0: 6c65 6e67 7468 2c20 6c6f 7765 725f 6675  length, lower_fu
-000129c0: 6e63 202a 2075 7070 6572 5f6c 656e 6774  nc * upper_lengt
-000129d0: 6829 2c20 6d61 7828 7570 7065 725f 6675  h), max(upper_fu
-000129e0: 6e63 202a 206c 6f77 6572 5f6c 656e 6774  nc * lower_lengt
-000129f0: 682c 2075 7070 6572 5f66 756e 6320 2a20  h, upper_func * 
-00012a00: 7570 7065 725f 6c65 6e67 7468 290a 0a0a  upper_length)...
-00012a10: 636c 6173 7320 5461 6b65 4469 6167 2841  class TakeDiag(A
-00012a20: 7272 6179 293a 0a0a 2020 2020 5f5f 736c  rray):..    __sl
-00012a30: 6f74 735f 5f20 3d20 2766 756e 6327 0a20  ots__ = 'func'. 
-00012a40: 2020 205f 5f63 6163 6865 5f5f 203d 2027     __cache__ = '
-00012a50: 5f61 7373 7061 7273 6527 0a0a 2020 2020  _assparse'..    
-00012a60: 4074 7970 6573 2e61 7070 6c79 5f61 6e6e  @types.apply_ann
-00012a70: 6f74 6174 696f 6e73 0a20 2020 2064 6566  otations.    def
-00012a80: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
-00012a90: 6675 6e63 3a20 6173 6172 7261 7929 3a0a  func: asarray):.
-00012aa0: 2020 2020 2020 2020 6966 2066 756e 632e          if func.
-00012ab0: 6e64 696d 203c 2032 3a0a 2020 2020 2020  ndim < 2:.      
-00012ac0: 2020 2020 2020 7261 6973 6520 4578 6365        raise Exce
-00012ad0: 7074 696f 6e28 2774 616b 6564 6961 6720  ption('takediag 
-00012ae0: 7265 7175 6972 6573 2061 6e20 6172 6775  requires an argu
-00012af0: 6d65 6e74 206f 6620 6469 6d65 6e73 696f  ment of dimensio
-00012b00: 6e20 3e3d 2032 2729 0a20 2020 2020 2020  n >= 2').       
-00012b10: 2069 6620 6e6f 7420 6571 7561 6c69 6e64   if not equalind
-00012b20: 6578 2866 756e 632e 7368 6170 655b 2d31  ex(func.shape[-1
-00012b30: 5d2c 2066 756e 632e 7368 6170 655b 2d32  ], func.shape[-2
-00012b40: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
-00012b50: 7261 6973 6520 4578 6365 7074 696f 6e28  raise Exception(
-00012b60: 2774 616b 6564 6961 6720 6178 6573 2064  'takediag axes d
-00012b70: 6f20 6e6f 7420 6d61 7463 6827 290a 2020  o not match').  
-00012b80: 2020 2020 2020 7365 6c66 2e66 756e 6320        self.func 
-00012b90: 3d20 6675 6e63 0a20 2020 2020 2020 2073  = func.        s
-00012ba0: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
-00012bb0: 6172 6773 3d5b 6675 6e63 5d2c 2073 6861  args=[func], sha
-00012bc0: 7065 3d66 756e 632e 7368 6170 655b 3a2d  pe=func.shape[:-
-00012bd0: 315d 2c20 6474 7970 653d 6675 6e63 2e64  1], dtype=func.d
-00012be0: 7479 7065 290a 0a20 2020 2064 6566 205f  type)..    def _
-00012bf0: 7369 6d70 6c69 6669 6564 2873 656c 6629  simplified(self)
-00012c00: 3a0a 2020 2020 2020 2020 6966 2065 7175  :.        if equ
-00012c10: 616c 696e 6465 7828 7365 6c66 2e73 6861  alindex(self.sha
-00012c20: 7065 5b2d 315d 2c20 3129 3a0a 2020 2020  pe[-1], 1):.    
-00012c30: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-00012c40: 616b 6528 7365 6c66 2e66 756e 632c 2030  ake(self.func, 0
-00012c50: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-00012c60: 2073 656c 662e 6675 6e63 2e5f 7461 6b65   self.func._take
-00012c70: 6469 6167 2873 656c 662e 6e64 696d 2d31  diag(self.ndim-1
-00012c80: 2c20 7365 6c66 2e6e 6469 6d29 0a0a 2020  , self.ndim)..  
-00012c90: 2020 6465 6620 6576 616c 6628 7365 6c66    def evalf(self
-00012ca0: 2c20 6172 7229 3a0a 2020 2020 2020 2020  , arr):.        
-00012cb0: 6173 7365 7274 2061 7272 2e6e 6469 6d20  assert arr.ndim 
-00012cc0: 3d3d 2073 656c 662e 6e64 696d 2b31 0a20  == self.ndim+1. 
-00012cd0: 2020 2020 2020 2072 6574 7572 6e20 6e75         return nu
-00012ce0: 6d70 792e 6569 6e73 756d 2827 2e2e 2e6b  mpy.einsum('...k
-00012cf0: 6b2d 3e2e 2e2e 6b27 2c20 6172 722c 206f  k->...k', arr, o
-00012d00: 7074 696d 697a 653d 4661 6c73 6529 0a0a  ptimize=False)..
-00012d10: 2020 2020 6465 6620 5f64 6572 6976 6174      def _derivat
-00012d20: 6976 6528 7365 6c66 2c20 7661 722c 2073  ive(self, var, s
-00012d30: 6565 6e29 3a0a 2020 2020 2020 2020 7265  een):.        re
-00012d40: 7475 726e 2074 616b 6564 6961 6728 6465  turn takediag(de
-00012d50: 7269 7661 7469 7665 2873 656c 662e 6675  rivative(self.fu
-00012d60: 6e63 2c20 7661 722c 2073 6565 6e29 2c20  nc, var, seen), 
-00012d70: 7365 6c66 2e6e 6469 6d2d 312c 2073 656c  self.ndim-1, sel
-00012d80: 662e 6e64 696d 290a 0a20 2020 2064 6566  f.ndim)..    def
-00012d90: 205f 7461 6b65 2873 656c 662c 2069 6e64   _take(self, ind
-00012da0: 6578 2c20 6178 6973 293a 0a20 2020 2020  ex, axis):.     
-00012db0: 2020 2069 6620 6178 6973 203c 2073 656c     if axis < sel
-00012dc0: 662e 6e64 696d 202d 2031 3a0a 2020 2020  f.ndim - 1:.    
-00012dd0: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-00012de0: 616b 6544 6961 6728 5f74 616b 6528 7365  akeDiag(_take(se
-00012df0: 6c66 2e66 756e 632c 2069 6e64 6578 2c20  lf.func, index, 
-00012e00: 6178 6973 2929 0a20 2020 2020 2020 2066  axis)).        f
-00012e10: 756e 6320 3d20 5f74 616b 6528 5461 6b65  unc = _take(Take
-00012e20: 2873 656c 662e 6675 6e63 2c20 696e 6465  (self.func, inde
-00012e30: 7829 2c20 696e 6465 782c 2073 656c 662e  x), index, self.
-00012e40: 6e64 696d 2d31 290a 2020 2020 2020 2020  ndim-1).        
-00012e50: 666f 7220 6920 696e 2072 6576 6572 7365  for i in reverse
-00012e60: 6428 7261 6e67 6528 7365 6c66 2e6e 6469  d(range(self.ndi
-00012e70: 6d2d 312c 2073 656c 662e 6e64 696d 2d31  m-1, self.ndim-1
-00012e80: 2b69 6e64 6578 2e6e 6469 6d29 293a 0a20  +index.ndim)):. 
-00012e90: 2020 2020 2020 2020 2020 2066 756e 6320             func 
-00012ea0: 3d20 7461 6b65 6469 6167 2866 756e 632c  = takediag(func,
-00012eb0: 2069 2c20 692b 696e 6465 782e 6e64 696d   i, i+index.ndim
-00012ec0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-00012ed0: 2066 756e 630a 0a20 2020 2064 6566 205f   func..    def _
-00012ee0: 7375 6d28 7365 6c66 2c20 6178 6973 293a  sum(self, axis):
-00012ef0: 0a20 2020 2020 2020 2069 6620 6178 6973  .        if axis
-00012f00: 2021 3d20 7365 6c66 2e6e 6469 6d20 2d20   != self.ndim - 
-00012f10: 313a 0a20 2020 2020 2020 2020 2020 2072  1:.            r
-00012f20: 6574 7572 6e20 5461 6b65 4469 6167 2873  eturn TakeDiag(s
-00012f30: 756d 2873 656c 662e 6675 6e63 2c20 6178  um(self.func, ax
-00012f40: 6973 2929 0a0a 2020 2020 4070 726f 7065  is))..    @prope
-00012f50: 7274 790a 2020 2020 6465 6620 5f61 7373  rty.    def _ass
-00012f60: 7061 7273 6528 7365 6c66 293a 0a20 2020  parse(self):.   
-00012f70: 2020 2020 2063 6875 6e6b 7320 3d20 5b5d       chunks = []
-00012f80: 0a20 2020 2020 2020 2066 6f72 202a 696e  .        for *in
-00012f90: 6469 6365 732c 2076 616c 7565 7320 696e  dices, values in
-00012fa0: 2073 656c 662e 6675 6e63 2e5f 6173 7370   self.func._assp
-00012fb0: 6172 7365 3a0a 2020 2020 2020 2020 2020  arse:.          
-00012fc0: 2020 6966 2069 6e64 6963 6573 5b2d 325d    if indices[-2]
-00012fd0: 203d 3d20 696e 6469 6365 735b 2d31 5d3a   == indices[-1]:
-00012fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012ff0: 2063 6875 6e6b 732e 6170 7065 6e64 2828   chunks.append((
-00013000: 2a69 6e64 6963 6573 5b3a 2d31 5d2c 2076  *indices[:-1], v
-00013010: 616c 7565 7329 290a 2020 2020 2020 2020  alues)).        
-00013020: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00013030: 2020 2020 2020 2020 2020 2a69 6e64 6963            *indic
-00013040: 6573 2c20 7661 6c75 6573 203d 206d 6170  es, values = map
-00013050: 285f 666c 6174 2c20 282a 696e 6469 6365  (_flat, (*indice
-00013060: 732c 2076 616c 7565 7329 290a 2020 2020  s, values)).    
-00013070: 2020 2020 2020 2020 2020 2020 6d61 736b              mask
-00013080: 203d 2045 7175 616c 2869 6e64 6963 6573   = Equal(indices
-00013090: 5b2d 325d 2c20 696e 6469 6365 735b 2d31  [-2], indices[-1
-000130a0: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-000130b0: 2020 2063 6875 6e6b 732e 6170 7065 6e64     chunks.append
-000130c0: 2874 7570 6c65 2874 616b 6528 6172 722c  (tuple(take(arr,
-000130d0: 206d 6173 6b2c 2030 2920 666f 7220 6172   mask, 0) for ar
-000130e0: 7220 696e 2028 2a69 6e64 6963 6573 5b3a  r in (*indices[:
-000130f0: 2d31 5d2c 2076 616c 7565 7329 2929 0a20  -1], values))). 
-00013100: 2020 2020 2020 2072 6574 7572 6e20 5f67         return _g
-00013110: 6174 6865 7273 7061 7273 6563 6875 6e6b  athersparsechunk
-00013120: 7328 6368 756e 6b73 290a 0a20 2020 2064  s(chunks)..    d
-00013130: 6566 205f 696e 7462 6f75 6e64 735f 696d  ef _intbounds_im
-00013140: 706c 2873 656c 6629 3a0a 2020 2020 2020  pl(self):.      
-00013150: 2020 7265 7475 726e 2073 656c 662e 6675    return self.fu
-00013160: 6e63 2e5f 696e 7462 6f75 6e64 730a 0a0a  nc._intbounds...
-00013170: 636c 6173 7320 5461 6b65 2841 7272 6179  class Take(Array
-00013180: 293a 0a0a 2020 2020 5f5f 736c 6f74 735f  ):..    __slots_
-00013190: 5f20 3d20 2766 756e 6327 2c20 2769 6e64  _ = 'func', 'ind
-000131a0: 6963 6573 270a 0a20 2020 2040 7479 7065  ices'..    @type
-000131b0: 732e 6170 706c 795f 616e 6e6f 7461 7469  s.apply_annotati
-000131c0: 6f6e 730a 2020 2020 6465 6620 5f5f 696e  ons.    def __in
-000131d0: 6974 5f5f 2873 656c 662c 2066 756e 633a  it__(self, func:
-000131e0: 2061 7361 7272 6179 2c20 696e 6469 6365   asarray, indice
-000131f0: 733a 2061 7361 7272 6179 293a 0a20 2020  s: asarray):.   
-00013200: 2020 2020 2069 6620 6675 6e63 2e6e 6469       if func.ndi
-00013210: 6d20 3d3d 2030 3a0a 2020 2020 2020 2020  m == 0:.        
-00013220: 2020 2020 7261 6973 6520 4578 6365 7074      raise Except
-00013230: 696f 6e28 2763 616e 6e6f 7420 7461 6b65  ion('cannot take
-00013240: 2061 2073 6361 6c61 7220 6675 6e63 7469   a scalar functi
-00013250: 6f6e 2729 0a20 2020 2020 2020 2069 6620  on').        if 
-00013260: 696e 6469 6365 732e 6474 7970 6520 213d  indices.dtype !=
-00013270: 2069 6e74 3a0a 2020 2020 2020 2020 2020   int:.          
-00013280: 2020 7261 6973 6520 4578 6365 7074 696f    raise Exceptio
-00013290: 6e28 2769 6e76 616c 6964 2069 6e64 6963  n('invalid indic
-000132a0: 6573 2061 7267 756d 656e 7420 666f 7220  es argument for 
-000132b0: 7461 6b65 2729 0a20 2020 2020 2020 2073  take').        s
-000132c0: 656c 662e 6675 6e63 203d 2066 756e 630a  elf.func = func.
-000132d0: 2020 2020 2020 2020 7365 6c66 2e69 6e64          self.ind
-000132e0: 6963 6573 203d 2069 6e64 6963 6573 0a20  ices = indices. 
-000132f0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
-00013300: 5f69 6e69 745f 5f28 6172 6773 3d5b 6675  _init__(args=[fu
-00013310: 6e63 2c20 696e 6469 6365 735d 2c20 7368  nc, indices], sh
-00013320: 6170 653d 6675 6e63 2e73 6861 7065 5b3a  ape=func.shape[:
-00013330: 2d31 5d2b 696e 6469 6365 732e 7368 6170  -1]+indices.shap
-00013340: 652c 2064 7479 7065 3d66 756e 632e 6474  e, dtype=func.dt
-00013350: 7970 6529 0a0a 2020 2020 6465 6620 5f73  ype)..    def _s
-00013360: 696d 706c 6966 6965 6428 7365 6c66 293a  implified(self):
-00013370: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00013380: 2e69 6e64 6963 6573 2e73 697a 6520 3d3d  .indices.size ==
-00013390: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-000133a0: 7265 7475 726e 207a 6572 6f73 5f6c 696b  return zeros_lik
-000133b0: 6528 7365 6c66 290a 2020 2020 2020 2020  e(self).        
-000133c0: 756e 616c 6967 6e65 642c 2077 6865 7265  unaligned, where
-000133d0: 203d 2075 6e61 6c69 676e 2873 656c 662e   = unalign(self.
-000133e0: 696e 6469 6365 7329 0a20 2020 2020 2020  indices).       
-000133f0: 2069 6620 6c65 6e28 7768 6572 6529 203c   if len(where) <
-00013400: 2073 656c 662e 696e 6469 6365 732e 6e64   self.indices.nd
-00013410: 696d 3a0a 2020 2020 2020 2020 2020 2020  im:.            
-00013420: 6e20 3d20 7365 6c66 2e66 756e 632e 6e64  n = self.func.nd
-00013430: 696d 2d31 0a20 2020 2020 2020 2020 2020  im-1.           
-00013440: 2072 6574 7572 6e20 616c 6967 6e28 5461   return align(Ta
-00013450: 6b65 2873 656c 662e 6675 6e63 2c20 756e  ke(self.func, un
-00013460: 616c 6967 6e65 6429 2c20 282a 7261 6e67  aligned), (*rang
-00013470: 6528 6e29 2c20 2a28 6e2b 6920 666f 7220  e(n), *(n+i for 
-00013480: 6920 696e 2077 6865 7265 2929 2c20 7365  i in where)), se
-00013490: 6c66 2e73 6861 7065 290a 2020 2020 2020  lf.shape).      
-000134a0: 2020 7472 7974 616b 6520 3d20 7365 6c66    trytake = self
-000134b0: 2e66 756e 632e 5f74 616b 6528 7365 6c66  .func._take(self
-000134c0: 2e69 6e64 6963 6573 2c20 7365 6c66 2e66  .indices, self.f
-000134d0: 756e 632e 6e64 696d 2d31 2920 6f72 205c  unc.ndim-1) or \
-000134e0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-000134f0: 662e 696e 6469 6365 732e 5f72 7461 6b65  f.indices._rtake
-00013500: 2873 656c 662e 6675 6e63 2c20 7365 6c66  (self.func, self
-00013510: 2e66 756e 632e 6e64 696d 2d31 290a 2020  .func.ndim-1).  
-00013520: 2020 2020 2020 6966 2074 7279 7461 6b65        if trytake
-00013530: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00013540: 7475 726e 2074 7279 7461 6b65 0a20 2020  turn trytake.   
-00013550: 2020 2020 2066 6f72 2061 7869 732c 2070       for axis, p
-00013560: 6172 7473 2069 6e20 7365 6c66 2e66 756e  arts in self.fun
-00013570: 632e 5f69 6e66 6c61 7469 6f6e 733a 0a20  c._inflations:. 
-00013580: 2020 2020 2020 2020 2020 2069 6620 6178             if ax
-00013590: 6973 203d 3d20 7365 6c66 2e66 756e 632e  is == self.func.
-000135a0: 6e64 696d 202d 2031 3a0a 2020 2020 2020  ndim - 1:.      
-000135b0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-000135c0: 2075 7469 6c2e 7375 6d28 496e 666c 6174   util.sum(Inflat
-000135d0: 6528 6675 6e63 2c20 646f 666d 6170 2c20  e(func, dofmap, 
-000135e0: 7365 6c66 2e66 756e 632e 7368 6170 655b  self.func.shape[
-000135f0: 2d31 5d29 2e5f 7461 6b65 2873 656c 662e  -1])._take(self.
-00013600: 696e 6469 6365 732c 2073 656c 662e 6675  indices, self.fu
-00013610: 6e63 2e6e 6469 6d20 2d20 3129 2066 6f72  nc.ndim - 1) for
-00013620: 2064 6f66 6d61 702c 2066 756e 6320 696e   dofmap, func in
-00013630: 2070 6172 7473 2e69 7465 6d73 2829 290a   parts.items()).
-00013640: 0a20 2020 2064 6566 2065 7661 6c66 2873  .    def evalf(s
-00013650: 656c 662c 2061 7272 2c20 696e 6469 6365  elf, arr, indice
-00013660: 7329 3a0a 2020 2020 2020 2020 7265 7475  s):.        retu
-00013670: 726e 2061 7272 5b2e 2e2e 2c20 696e 6469  rn arr[..., indi
-00013680: 6365 735d 0a0a 2020 2020 6465 6620 5f64  ces]..    def _d
-00013690: 6572 6976 6174 6976 6528 7365 6c66 2c20  erivative(self, 
-000136a0: 7661 722c 2073 6565 6e29 3a0a 2020 2020  var, seen):.    
-000136b0: 2020 2020 7265 7475 726e 205f 7461 6b65      return _take
-000136c0: 2864 6572 6976 6174 6976 6528 7365 6c66  (derivative(self
-000136d0: 2e66 756e 632c 2076 6172 2c20 7365 656e  .func, var, seen
-000136e0: 292c 2073 656c 662e 696e 6469 6365 732c  ), self.indices,
-000136f0: 2073 656c 662e 6675 6e63 2e6e 6469 6d2d   self.func.ndim-
-00013700: 3129 0a0a 2020 2020 6465 6620 5f74 616b  1)..    def _tak
-00013710: 6528 7365 6c66 2c20 696e 6465 782c 2061  e(self, index, a
-00013720: 7869 7329 3a0a 2020 2020 2020 2020 6966  xis):.        if
-00013730: 2061 7869 7320 3e3d 2073 656c 662e 6675   axis >= self.fu
-00013740: 6e63 2e6e 6469 6d2d 313a 0a20 2020 2020  nc.ndim-1:.     
-00013750: 2020 2020 2020 2072 6574 7572 6e20 5461         return Ta
-00013760: 6b65 2873 656c 662e 6675 6e63 2c20 5f74  ke(self.func, _t
-00013770: 616b 6528 7365 6c66 2e69 6e64 6963 6573  ake(self.indices
-00013780: 2c20 696e 6465 782c 2061 7869 732d 7365  , index, axis-se
-00013790: 6c66 2e66 756e 632e 6e64 696d 2b31 2929  lf.func.ndim+1))
-000137a0: 0a20 2020 2020 2020 2074 7279 7461 6b65  .        trytake
-000137b0: 203d 2073 656c 662e 6675 6e63 2e5f 7461   = self.func._ta
-000137c0: 6b65 2869 6e64 6578 2c20 6178 6973 290a  ke(index, axis).
-000137d0: 2020 2020 2020 2020 6966 2074 7279 7461          if tryta
-000137e0: 6b65 2069 7320 6e6f 7420 4e6f 6e65 3a0a  ke is not None:.
-000137f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00013800: 726e 2054 616b 6528 7472 7974 616b 652c  rn Take(trytake,
-00013810: 2073 656c 662e 696e 6469 6365 7329 0a0a   self.indices)..
-00013820: 2020 2020 6465 6620 5f73 756d 2873 656c      def _sum(sel
-00013830: 662c 2061 7869 7329 3a0a 2020 2020 2020  f, axis):.      
-00013840: 2020 6966 2061 7869 7320 3c20 7365 6c66    if axis < self
-00013850: 2e66 756e 632e 6e64 696d 202d 2031 3a0a  .func.ndim - 1:.
-00013860: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00013870: 726e 2054 616b 6528 7375 6d28 7365 6c66  rn Take(sum(self
-00013880: 2e66 756e 632c 2061 7869 7329 2c20 7365  .func, axis), se
-00013890: 6c66 2e69 6e64 6963 6573 290a 0a20 2020  lf.indices)..   
-000138a0: 2064 6566 205f 696e 7462 6f75 6e64 735f   def _intbounds_
-000138b0: 696d 706c 2873 656c 6629 3a0a 2020 2020  impl(self):.    
-000138c0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000138d0: 6675 6e63 2e5f 696e 7462 6f75 6e64 730a  func._intbounds.
-000138e0: 0a0a 636c 6173 7320 506f 7765 7228 4172  ..class Power(Ar
-000138f0: 7261 7929 3a0a 0a20 2020 205f 5f73 6c6f  ray):..    __slo
-00013900: 7473 5f5f 203d 2027 6675 6e63 272c 2027  ts__ = 'func', '
-00013910: 706f 7765 7227 0a0a 2020 2020 4074 7970  power'..    @typ
-00013920: 6573 2e61 7070 6c79 5f61 6e6e 6f74 6174  es.apply_annotat
-00013930: 696f 6e73 0a20 2020 2064 6566 205f 5f69  ions.    def __i
-00013940: 6e69 745f 5f28 7365 6c66 2c20 6675 6e63  nit__(self, func
-00013950: 3a20 6173 6172 7261 792c 2070 6f77 6572  : asarray, power
-00013960: 3a20 6173 6172 7261 7929 3a0a 2020 2020  : asarray):.    
-00013970: 2020 2020 6173 7365 7274 2065 7175 616c      assert equal
-00013980: 7368 6170 6528 6675 6e63 2e73 6861 7065  shape(func.shape
-00013990: 2c20 706f 7765 722e 7368 6170 6529 2061  , power.shape) a
-000139a0: 6e64 2066 756e 632e 6474 7970 6520 3d3d  nd func.dtype ==
-000139b0: 2070 6f77 6572 2e64 7479 7065 2021 3d20   power.dtype != 
-000139c0: 626f 6f6c 2c20 2750 6f77 6572 287b 7d2c  bool, 'Power({},
-000139d0: 207b 7d29 272e 666f 726d 6174 2866 756e   {})'.format(fun
-000139e0: 632c 2070 6f77 6572 290a 2020 2020 2020  c, power).      
-000139f0: 2020 6966 2070 6f77 6572 2e64 7479 7065    if power.dtype
-00013a00: 203d 3d20 696e 743a 0a20 2020 2020 2020   == int:.       
-00013a10: 2020 2020 2061 7373 6572 7420 706f 7765       assert powe
-00013a20: 722e 5f69 6e74 626f 756e 6473 5b30 5d20  r._intbounds[0] 
-00013a30: 3e3d 2030 0a20 2020 2020 2020 2073 656c  >= 0.        sel
-00013a40: 662e 6675 6e63 203d 2066 756e 630a 2020  f.func = func.  
-00013a50: 2020 2020 2020 7365 6c66 2e70 6f77 6572        self.power
-00013a60: 203d 2070 6f77 6572 0a20 2020 2020 2020   = power.       
-00013a70: 2073 7570 6572 2829 2e5f 5f69 6e69 745f   super().__init_
-00013a80: 5f28 6172 6773 3d5b 6675 6e63 2c20 706f  _(args=[func, po
-00013a90: 7765 725d 2c20 7368 6170 653d 6675 6e63  wer], shape=func
-00013aa0: 2e73 6861 7065 2c20 6474 7970 653d 6675  .shape, dtype=fu
-00013ab0: 6e63 2e64 7479 7065 290a 0a20 2020 2064  nc.dtype)..    d
-00013ac0: 6566 205f 7369 6d70 6c69 6669 6564 2873  ef _simplified(s
-00013ad0: 656c 6629 3a0a 2020 2020 2020 2020 6966  elf):.        if
-00013ae0: 2069 737a 6572 6f28 7365 6c66 2e70 6f77   iszero(self.pow
-00013af0: 6572 293a 0a20 2020 2020 2020 2020 2020  er):.           
-00013b00: 2072 6574 7572 6e20 6f6e 6573 5f6c 696b   return ones_lik
-00013b10: 6528 7365 6c66 290a 2020 2020 2020 2020  e(self).        
-00013b20: 7020 3d20 7365 6c66 2e70 6f77 6572 2e5f  p = self.power._
-00013b30: 636f 6e73 745f 756e 6966 6f72 6d0a 2020  const_uniform.  
-00013b40: 2020 2020 2020 6966 2070 203d 3d20 313a        if p == 1:
+000005d0: 6275 675f 666c 6167 732c 205f 7574 696c  bug_flags, _util
+000005e0: 2061 7320 7574 696c 2c20 7479 7065 732c   as util, types,
+000005f0: 206e 756d 6572 6963 2c20 6361 6368 652c   numeric, cache,
+00000600: 2077 6172 6e69 6e67 732c 2070 6172 616c   warnings, paral
+00000610: 6c65 6c2c 2073 7061 7273 650a 6672 6f6d  lel, sparse.from
+00000620: 202e 5f62 6163 6b70 6f72 7473 2069 6d70   ._backports imp
+00000630: 6f72 7420 6361 6368 6564 5f70 726f 7065  ort cached_prope
+00000640: 7274 790a 6672 6f6d 202e 5f67 7261 7068  rty.from ._graph
+00000650: 2069 6d70 6f72 7420 4e6f 6465 2c20 5265   import Node, Re
+00000660: 6775 6c61 724e 6f64 652c 2044 7570 6c69  gularNode, Dupli
+00000670: 6361 7465 644c 6561 664e 6f64 652c 2049  catedLeafNode, I
+00000680: 6e76 6973 6962 6c65 4e6f 6465 2c20 5375  nvisibleNode, Su
+00000690: 6267 7261 7068 0a69 6d70 6f72 7420 6e75  bgraph.import nu
+000006a0: 7469 6c73 5f70 6f6c 7920 6173 2070 6f6c  tils_poly as pol
+000006b0: 790a 696d 706f 7274 206e 756d 7079 0a69  y.import numpy.i
+000006c0: 6d70 6f72 7420 7379 730a 696d 706f 7274  mport sys.import
+000006d0: 2069 7465 7274 6f6f 6c73 0a69 6d70 6f72   itertools.impor
+000006e0: 7420 6675 6e63 746f 6f6c 730a 696d 706f  t functools.impo
+000006f0: 7274 206f 7065 7261 746f 720a 696d 706f  rt operator.impo
+00000700: 7274 2069 6e73 7065 6374 0a69 6d70 6f72  rt inspect.impor
+00000710: 7420 6e75 6d62 6572 730a 696d 706f 7274  t numbers.import
+00000720: 2062 7569 6c74 696e 730a 696d 706f 7274   builtins.import
+00000730: 2072 650a 696d 706f 7274 2074 7970 6573   re.import types
+00000740: 2061 7320 6275 696c 7469 6e5f 7479 7065   as builtin_type
+00000750: 730a 696d 706f 7274 2061 6263 0a69 6d70  s.import abc.imp
+00000760: 6f72 7420 636f 6c6c 6563 7469 6f6e 732e  ort collections.
+00000770: 6162 630a 696d 706f 7274 206d 6174 680a  abc.import math.
+00000780: 696d 706f 7274 2074 7265 656c 6f67 2061  import treelog a
+00000790: 7320 6c6f 670a 696d 706f 7274 2077 6561  s log.import wea
+000007a0: 6b72 6566 0a69 6d70 6f72 7420 7469 6d65  kref.import time
+000007b0: 0a69 6d70 6f72 7420 636f 6e74 6578 746c  .import contextl
+000007c0: 6962 0a69 6d70 6f72 7420 7375 6270 726f  ib.import subpro
+000007d0: 6365 7373 0a69 6d70 6f72 7420 6f73 0a0a  cess.import os..
+000007e0: 6772 6170 6876 697a 203d 206f 732e 656e  graphviz = os.en
+000007f0: 7669 726f 6e2e 6765 7428 274e 5554 494c  viron.get('NUTIL
+00000800: 535f 4752 4150 4856 495a 2729 0a0a 6973  S_GRAPHVIZ')..is
+00000810: 6576 616c 7561 626c 6520 3d20 6c61 6d62  evaluable = lamb
+00000820: 6461 2061 7267 3a20 6973 696e 7374 616e  da arg: isinstan
+00000830: 6365 2861 7267 2c20 4576 616c 7561 626c  ce(arg, Evaluabl
+00000840: 6529 0a0a 0a64 6566 2073 696d 706c 6966  e)...def simplif
+00000850: 6965 6428 7661 6c75 653a 2027 4576 616c  ied(value: 'Eval
+00000860: 7561 626c 6527 293a 0a20 2020 2061 7373  uable'):.    ass
+00000870: 6572 7420 6973 696e 7374 616e 6365 2876  ert isinstance(v
+00000880: 616c 7565 2c20 4576 616c 7561 626c 6529  alue, Evaluable)
+00000890: 2c20 6627 7661 6c75 653d 7b76 616c 7565  , f'value={value
+000008a0: 2172 7d27 0a20 2020 2072 6574 7572 6e20  !r}'.    return 
+000008b0: 7661 6c75 652e 7369 6d70 6c69 6669 6564  value.simplified
+000008c0: 0a0a 0a5f 7479 7065 5f6f 7264 6572 203d  ..._type_order =
+000008d0: 2062 6f6f 6c2c 2069 6e74 2c20 666c 6f61   bool, int, floa
+000008e0: 742c 2063 6f6d 706c 6578 0a61 7364 7479  t, complex.asdty
+000008f0: 7065 203d 206c 616d 6264 6120 6172 673a  pe = lambda arg:
+00000900: 2061 7267 2069 6620 616e 7928 6172 6720   arg if any(arg 
+00000910: 6973 2064 7479 7065 2066 6f72 2064 7479  is dtype for dty
+00000920: 7065 2069 6e20 5f74 7970 655f 6f72 6465  pe in _type_orde
+00000930: 7229 2065 6c73 6520 7b27 6627 3a20 666c  r) else {'f': fl
+00000940: 6f61 742c 2027 6927 3a20 696e 742c 2027  oat, 'i': int, '
+00000950: 6227 3a20 626f 6f6c 2c20 2763 273a 2063  b': bool, 'c': c
+00000960: 6f6d 706c 6578 7d5b 6e75 6d70 792e 6474  omplex}[numpy.dt
+00000970: 7970 6528 6172 6729 2e6b 696e 645d 0a44  ype(arg).kind].D
+00000980: 7479 7065 203d 2074 7970 696e 672e 556e  type = typing.Un
+00000990: 696f 6e5b 5f74 7970 655f 6f72 6465 725d  ion[_type_order]
+000009a0: 0a0a 0a64 6566 2061 7361 7272 6179 2861  ...def asarray(a
+000009b0: 7267 293a 0a20 2020 2069 6620 6861 7361  rg):.    if hasa
+000009c0: 7474 7228 7479 7065 2861 7267 292c 2027  ttr(type(arg), '
+000009d0: 6173 5f65 7661 6c75 6162 6c65 5f61 7272  as_evaluable_arr
+000009e0: 6179 2729 3a0a 2020 2020 2020 2020 7265  ay'):.        re
+000009f0: 7475 726e 2061 7267 2e61 735f 6576 616c  turn arg.as_eval
+00000a00: 7561 626c 655f 6172 7261 790a 2020 2020  uable_array.    
+00000a10: 6966 205f 636f 6e74 6169 6e73 6172 7261  if _containsarra
+00000a20: 7928 6172 6729 3a0a 2020 2020 2020 2020  y(arg):.        
+00000a30: 7265 7475 726e 2073 7461 636b 2861 7267  return stack(arg
+00000a40: 2c20 6178 6973 3d30 290a 2020 2020 656c  , axis=0).    el
+00000a50: 7365 3a0a 2020 2020 2020 2020 7265 7475  se:.        retu
+00000a60: 726e 2063 6f6e 7374 616e 7428 6172 6729  rn constant(arg)
+00000a70: 0a0a 0a64 6566 205f 6973 696e 6465 7828  ...def _isindex(
+00000a80: 6172 6729 3a0a 2020 2020 7265 7475 726e  arg):.    return
+00000a90: 2069 7369 6e73 7461 6e63 6528 6172 672c   isinstance(arg,
+00000aa0: 2041 7272 6179 2920 616e 6420 6172 672e   Array) and arg.
+00000ab0: 6e64 696d 203d 3d20 3020 616e 6420 6172  ndim == 0 and ar
+00000ac0: 672e 6474 7970 6520 3d3d 2069 6e74 2061  g.dtype == int a
+00000ad0: 6e64 2061 7267 2e5f 696e 7462 6f75 6e64  nd arg._intbound
+00000ae0: 735b 305d 203e 3d20 300a 0a0a 6465 6620  s[0] >= 0...def 
+00000af0: 5f65 7175 616c 735f 7363 616c 6172 5f63  _equals_scalar_c
+00000b00: 6f6e 7374 616e 7428 6172 673a 2027 4172  onstant(arg: 'Ar
+00000b10: 7261 7927 2c20 7661 6c75 653a 2044 7479  ray', value: Dty
+00000b20: 7065 293a 0a20 2020 2061 7373 6572 7420  pe):.    assert 
+00000b30: 6973 696e 7374 616e 6365 2861 7267 2c20  isinstance(arg, 
+00000b40: 4172 7261 7929 2061 6e64 2061 7267 2e6e  Array) and arg.n
+00000b50: 6469 6d20 3d3d 2030 2c20 6627 6172 673d  dim == 0, f'arg=
+00000b60: 7b61 7267 2172 7d27 0a20 2020 2061 7373  {arg!r}'.    ass
+00000b70: 6572 7420 6172 672e 6474 7970 6520 3d3d  ert arg.dtype ==
+00000b80: 2074 7970 6528 7661 6c75 6529 2c20 6627   type(value), f'
+00000b90: 6172 672e 6474 7970 653d 7b61 7267 2e64  arg.dtype={arg.d
+00000ba0: 7479 7065 7d2c 2074 7970 6528 7661 6c75  type}, type(valu
+00000bb0: 6529 3d7b 7479 7065 2876 616c 7565 297d  e)={type(value)}
+00000bc0: 270a 2020 2020 7265 7475 726e 2061 7267  '.    return arg
+00000bd0: 2e69 7363 6f6e 7374 616e 7420 616e 6420  .isconstant and 
+00000be0: 6172 672e 6576 616c 2829 203d 3d20 7661  arg.eval() == va
+00000bf0: 6c75 650a 0a0a 6465 6620 5f65 7175 616c  lue...def _equal
+00000c00: 735f 7369 6d70 6c69 6669 6564 2861 7267  s_simplified(arg
+00000c10: 313a 2027 4172 7261 7927 2c20 6172 6732  1: 'Array', arg2
+00000c20: 3a20 2741 7272 6179 2729 3a0a 2020 2020  : 'Array'):.    
+00000c30: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+00000c40: 6528 6172 6731 2c20 4172 7261 7929 2c20  e(arg1, Array), 
+00000c50: 6627 6172 6731 3d7b 6172 6731 2172 7d27  f'arg1={arg1!r}'
+00000c60: 0a20 2020 2061 7373 6572 7420 6973 696e  .    assert isin
+00000c70: 7374 616e 6365 2861 7267 322c 2041 7272  stance(arg2, Arr
+00000c80: 6179 292c 2066 2761 7267 323d 7b61 7267  ay), f'arg2={arg
+00000c90: 3221 727d 270a 2020 2020 6966 2061 7267  2!r}'.    if arg
+00000ca0: 3120 6973 2061 7267 323a 0a20 2020 2020  1 is arg2:.     
+00000cb0: 2020 2072 6574 7572 6e20 5472 7565 0a20     return True. 
+00000cc0: 2020 2061 7373 6572 7420 6571 7561 6c73     assert equals
+00000cd0: 6861 7065 2861 7267 312e 7368 6170 652c  hape(arg1.shape,
+00000ce0: 2061 7267 322e 7368 6170 6529 2061 6e64   arg2.shape) and
+00000cf0: 2061 7267 312e 6474 7970 6520 3d3d 2061   arg1.dtype == a
+00000d00: 7267 322e 6474 7970 652c 2066 2761 7267  rg2.dtype, f'arg
+00000d10: 313d 7b61 7267 3121 727d 2c20 6172 6732  1={arg1!r}, arg2
+00000d20: 3d7b 6172 6732 2172 7d27 0a20 2020 2061  ={arg2!r}'.    a
+00000d30: 7267 3120 3d20 6172 6731 2e73 696d 706c  rg1 = arg1.simpl
+00000d40: 6966 6965 640a 2020 2020 6172 6732 203d  ified.    arg2 =
+00000d50: 2061 7267 322e 7369 6d70 6c69 6669 6564   arg2.simplified
+00000d60: 0a20 2020 2069 6620 6172 6731 2069 7320  .    if arg1 is 
+00000d70: 6172 6732 3a0a 2020 2020 2020 2020 7265  arg2:.        re
+00000d80: 7475 726e 2054 7275 650a 2020 2020 6966  turn True.    if
+00000d90: 2061 7267 312e 6172 6775 6d65 6e74 7320   arg1.arguments 
+00000da0: 213d 2061 7267 322e 6172 6775 6d65 6e74  != arg2.argument
+00000db0: 733a 0a20 2020 2020 2020 2072 6574 7572  s:.        retur
+00000dc0: 6e20 4661 6c73 650a 2020 2020 6966 2061  n False.    if a
+00000dd0: 7267 312e 6973 636f 6e73 7461 6e74 3a20  rg1.isconstant: 
+00000de0: 2320 696d 706c 6965 7320 6172 6732 2e69  # implies arg2.i
+00000df0: 7363 6f6e 7374 616e 740a 2020 2020 2020  sconstant.      
+00000e00: 2020 7265 7475 726e 206e 756d 7079 2e61    return numpy.a
+00000e10: 6c6c 2861 7267 312e 6576 616c 2829 203d  ll(arg1.eval() =
+00000e20: 3d20 6172 6732 2e65 7661 6c28 2929 0a0a  = arg2.eval())..
+00000e30: 0a64 6566 2065 7175 616c 7368 6170 6528  .def equalshape(
+00000e40: 4e3a 2074 7970 696e 672e 5475 706c 655b  N: typing.Tuple[
+00000e50: 2741 7272 6179 272c 202e 2e2e 5d2c 204d  'Array', ...], M
+00000e60: 3a20 7479 7069 6e67 2e54 7570 6c65 5b27  : typing.Tuple['
+00000e70: 4172 7261 7927 2c20 2e2e 2e5d 293a 0a20  Array', ...]):. 
+00000e80: 2020 2027 2727 436f 6d70 6172 6520 7477     '''Compare tw
+00000e90: 6f20 6172 7261 7920 7368 6170 6573 2e0a  o array shapes..
+00000ea0: 0a20 2020 2052 6574 7572 6e73 2060 5472  .    Returns `Tr
+00000eb0: 7565 6020 6966 2061 6c6c 2069 6e64 6963  ue` if all indic
+00000ec0: 6573 2061 7265 2063 6572 7461 696e 6c79  es are certainly
+00000ed0: 2065 7175 616c 2c20 6046 616c 7365 6020   equal, `False` 
+00000ee0: 6966 2061 6e79 2069 6e64 6963 6573 2061  if any indices a
+00000ef0: 7265 0a20 2020 2063 6572 7461 696e 6c79  re.    certainly
+00000f00: 206e 6f74 2065 7175 616c 2c20 6f72 2060   not equal, or `
+00000f10: 4e6f 6e65 6020 6966 2065 7175 616c 6974  None` if equalit
+00000f20: 7920 6361 6e6e 6f74 2062 6520 6465 7465  y cannot be dete
+00000f30: 726d 696e 6564 2061 7420 636f 6d70 696c  rmined at compil
+00000f40: 650a 2020 2020 7469 6d65 2e0a 2020 2020  e.    time..    
+00000f50: 2727 270a 0a20 2020 2061 7373 6572 7420  '''..    assert 
+00000f60: 6973 696e 7374 616e 6365 284e 2c20 7475  isinstance(N, tu
+00000f70: 706c 6529 2061 6e64 2061 6c6c 285f 6973  ple) and all(_is
+00000f80: 696e 6465 7828 6e29 2066 6f72 206e 2069  index(n) for n i
+00000f90: 6e20 4e29 2c20 6627 4e3d 7b4e 2172 7d27  n N), f'N={N!r}'
+00000fa0: 0a20 2020 2061 7373 6572 7420 6973 696e  .    assert isin
+00000fb0: 7374 616e 6365 284d 2c20 7475 706c 6529  stance(M, tuple)
+00000fc0: 2061 6e64 2061 6c6c 285f 6973 696e 6465   and all(_isinde
+00000fd0: 7828 6e29 2066 6f72 206e 2069 6e20 4d29  x(n) for n in M)
+00000fe0: 2c20 6627 4d3d 7b4d 2172 7d27 0a20 2020  , f'M={M!r}'.   
+00000ff0: 2069 6620 4e20 3d3d 204d 3a0a 2020 2020   if N == M:.    
+00001000: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
+00001010: 2020 2020 6966 206c 656e 284e 2920 213d      if len(N) !=
+00001020: 206c 656e 284d 293a 0a20 2020 2020 2020   len(M):.       
+00001030: 2072 6574 7572 6e20 4661 6c73 650a 2020   return False.  
+00001040: 2020 7265 7476 616c 203d 2054 7275 650a    retval = True.
+00001050: 2020 2020 666f 7220 6571 2069 6e20 6d61      for eq in ma
+00001060: 7028 5f65 7175 616c 735f 7369 6d70 6c69  p(_equals_simpli
+00001070: 6669 6564 2c20 4e2c 204d 293a 0a20 2020  fied, N, M):.   
+00001080: 2020 2020 2069 6620 6571 203d 3d20 4661       if eq == Fa
+00001090: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000010a0: 2072 6574 7572 6e20 4661 6c73 650a 2020   return False.  
+000010b0: 2020 2020 2020 6966 2065 7120 3d3d 204e        if eq == N
+000010c0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+000010d0: 2072 6574 7661 6c20 3d20 4e6f 6e65 0a20   retval = None. 
+000010e0: 2020 2072 6574 7572 6e20 7265 7476 616c     return retval
+000010f0: 0a0a 0a63 6c61 7373 2045 7870 656e 7369  ...class Expensi
+00001100: 7665 4576 616c 7561 7469 6f6e 5761 726e  veEvaluationWarn
+00001110: 696e 6728 7761 726e 696e 6773 2e4e 7574  ing(warnings.Nut
+00001120: 696c 7349 6e65 6666 6963 6965 6e63 7957  ilsInefficiencyW
+00001130: 6172 6e69 6e67 293a 0a20 2020 2070 6173  arning):.    pas
+00001140: 730a 0a0a 6465 6620 7265 706c 6163 6528  s...def replace(
+00001150: 6675 6e63 3d4e 6f6e 652c 2064 6570 7468  func=None, depth
+00001160: 6669 7273 743d 4661 6c73 652c 2072 6563  first=False, rec
+00001170: 7572 7369 7665 3d46 616c 7365 2c20 6c72  ursive=False, lr
+00001180: 753d 3429 3a0a 2020 2020 2727 2764 6563  u=4):.    '''dec
+00001190: 6f72 6174 6f72 2066 6f72 2064 6565 7020  orator for deep 
+000011a0: 6f62 6a65 6374 2072 6570 6c61 6365 6d65  object replaceme
+000011b0: 6e74 0a0a 2020 2020 4765 6e65 7261 7465  nt..    Generate
+000011c0: 7320 6120 6465 6570 2072 6570 6c61 6365  s a deep replace
+000011d0: 6d65 6e74 206d 6574 686f 6420 666f 7220  ment method for 
+000011e0: 6765 6e65 7261 6c20 6f62 6a65 6374 7320  general objects 
+000011f0: 6261 7365 6420 6f6e 2061 2063 616c 6c61  based on a calla
+00001200: 626c 650a 2020 2020 7468 6174 2069 7320  ble.    that is 
+00001210: 6170 706c 6965 6420 2872 6563 7572 7369  applied (recursi
+00001220: 7665 6c79 2920 6f6e 2069 6e64 6976 6964  vely) on individ
+00001230: 7561 6c20 636f 6e73 7472 7563 746f 7220  ual constructor 
+00001240: 6172 6775 6d65 6e74 732e 0a0a 2020 2020  arguments...    
+00001250: 4172 6773 0a20 2020 202d 2d2d 2d0a 2020  Args.    ----.  
+00001260: 2020 6675 6e63 0a20 2020 2020 2020 2043    func.        C
+00001270: 616c 6c61 626c 6520 7768 6963 6820 6d61  allable which ma
+00001280: 7073 2061 6e20 6f62 6a65 6374 206f 6e74  ps an object ont
+00001290: 6f20 6120 6e65 7720 6f62 6a65 6374 2c20  o a new object, 
+000012a0: 6f72 2060 4e6f 6e65 6020 6966 206e 6f0a  or `None` if no.
+000012b0: 2020 2020 2020 2020 7265 706c 6163 656d          replacem
+000012c0: 656e 7420 6973 206d 6164 652e 2049 7420  ent is made. It 
+000012d0: 6d75 7374 2068 6176 6520 6f6e 6520 706f  must have one po
+000012e0: 7369 7469 6f6e 616c 2061 7267 756d 656e  sitional argumen
+000012f0: 7420 666f 7220 7468 6520 6f62 6a65 6374  t for the object
+00001300: 2c0a 2020 2020 2020 2020 616e 6420 6d61  ,.        and ma
+00001310: 7920 6861 7665 2061 6e79 206e 756d 6265  y have any numbe
+00001320: 7220 6f66 2061 6464 6974 696f 6e61 6c20  r of additional 
+00001330: 706f 7369 7469 6f6e 616c 2061 6e64 2f6f  positional and/o
+00001340: 7220 6b65 7977 6f72 640a 2020 2020 2020  r keyword.      
+00001350: 2020 6172 6775 6d65 6e74 732e 0a20 2020    arguments..   
+00001360: 2064 6570 7468 6669 7273 7420 3a20 3a63   depthfirst : :c
+00001370: 6c61 7373 3a60 626f 6f6c 600a 2020 2020  lass:`bool`.    
+00001380: 2020 2020 4966 2060 5472 7565 602c 2064      If `True`, d
+00001390: 6563 6f6d 706f 7365 2065 6163 6820 6f62  ecompose each ob
+000013a0: 6a65 6374 2061 7320 6661 7220 6120 706f  ject as far a po
+000013b0: 7373 6962 6c65 2c20 7468 656e 2061 7070  ssible, then app
+000013c0: 6c79 2060 6675 6e63 6020 746f 0a20 2020  ly `func` to.   
+000013d0: 2020 2020 2061 6c6c 2061 7267 756d 656e       all argumen
+000013e0: 7473 2061 7320 7468 6520 6f62 6a65 6374  ts as the object
+000013f0: 7320 6172 6520 7265 636f 6e73 7472 7563  s are reconstruc
+00001400: 7465 642e 204f 7468 6572 7769 7365 2061  ted. Otherwise a
+00001410: 7070 6c79 2060 6675 6e63 600a 2020 2020  pply `func`.    
+00001420: 2020 2020 6469 7265 6374 6c79 206f 6e20      directly on 
+00001430: 6561 6368 206e 6577 206f 626a 6563 7420  each new object 
+00001440: 7468 6174 2069 7320 656e 636f 756e 7465  that is encounte
+00001450: 7265 6420 696e 2074 6865 2064 6563 6f6d  red in the decom
+00001460: 706f 7369 7469 6f6e 2c0a 2020 2020 2020  position,.      
+00001470: 2020 7072 6f63 6564 696e 6720 6f6e 6c79    proceding only
+00001480: 2069 6620 7468 6520 7265 7475 726e 2076   if the return v
+00001490: 616c 7565 2069 7320 604e 6f6e 6560 2e0a  alue is `None`..
+000014a0: 2020 2020 7265 6375 7273 6976 6520 3a20      recursive : 
+000014b0: 3a63 6c61 7373 3a60 626f 6f6c 600a 2020  :class:`bool`.  
+000014c0: 2020 2020 2020 4966 2060 5472 7565 602c        If `True`,
+000014d0: 2072 6570 6561 7420 7265 706c 6163 656d   repeat replacem
+000014e0: 656e 7420 666f 7220 616e 7920 6f62 6a65  ent for any obje
+000014f0: 6374 2072 6574 7572 6e65 6420 6279 2060  ct returned by `
+00001500: 6675 6e63 6020 756e 7469 6c20 6974 0a20  func` until it. 
+00001510: 2020 2020 2020 2072 6574 7572 6e73 2060         returns `
+00001520: 4e6f 6e65 602e 204f 7468 6572 7769 7365  None`. Otherwise
+00001530: 2070 6572 666f 726d 2061 2073 696e 676c   perform a singl
+00001540: 652c 206e 6f6e 2d72 6563 7572 7369 7665  e, non-recursive
+00001550: 2073 7765 6570 2e0a 2020 2020 6c72 7520   sweep..    lru 
+00001560: 3a20 3a63 6c61 7373 3a60 696e 7460 0a20  : :class:`int`. 
+00001570: 2020 2020 2020 204d 6178 696d 756d 2073         Maximum s
+00001580: 697a 6520 6f66 2074 6865 206c 6561 7374  ize of the least
+00001590: 2d72 6563 656e 746c 792d 7573 6564 2063  -recently-used c
+000015a0: 6163 6865 2e20 4120 7065 7273 6973 7465  ache. A persiste
+000015b0: 6e74 2077 6561 6b2d 6b65 790a 2020 2020  nt weak-key.    
+000015c0: 2020 2020 6469 6374 696f 6e61 7279 2069      dictionary i
+000015d0: 7320 6d61 696e 7461 696e 6564 2066 6f72  s maintained for
+000015e0: 2065 7665 7279 2075 6e69 7175 6520 7365   every unique se
+000015f0: 7420 6f66 2066 756e 6374 696f 6e20 6172  t of function ar
+00001600: 6775 6d65 6e74 732e 2057 6865 6e0a 2020  guments. When.  
+00001610: 2020 2020 2020 7468 6520 7369 7a65 206f        the size o
+00001620: 6620 606c 7275 6020 6973 2072 6561 6368  f `lru` is reach
+00001630: 6564 2c20 7468 6520 6c65 6173 7420 7265  ed, the least re
+00001640: 6365 6e74 6c79 2075 7365 6420 6361 6368  cently used cach
+00001650: 6520 6973 2064 726f 7070 6564 2e0a 0a20  e is dropped... 
+00001660: 2020 2052 6574 7572 6e73 0a20 2020 202d     Returns.    -
+00001670: 2d2d 2d2d 2d2d 0a20 2020 203a 616e 793a  ------.    :any:
+00001680: 6063 616c 6c61 626c 6560 0a20 2020 2020  `callable`.     
+00001690: 2020 2054 6865 206d 6574 686f 6420 7468     The method th
+000016a0: 6174 2073 6561 7263 6865 7320 7468 6520  at searches the 
+000016b0: 6f62 6a65 6374 2074 6f20 7065 7266 6f72  object to perfor
+000016c0: 6d20 7468 6520 7265 706c 6163 656d 656e  m the replacemen
+000016d0: 7473 2e0a 2020 2020 2727 270a 0a20 2020  ts..    '''..   
+000016e0: 2069 6620 6675 6e63 2069 7320 4e6f 6e65   if func is None
+000016f0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00001700: 2066 756e 6374 6f6f 6c73 2e70 6172 7469   functools.parti
+00001710: 616c 2872 6570 6c61 6365 2c20 6465 7074  al(replace, dept
+00001720: 6866 6972 7374 3d64 6570 7468 6669 7273  hfirst=depthfirs
+00001730: 742c 2072 6563 7572 7369 7665 3d72 6563  t, recursive=rec
+00001740: 7572 7369 7665 2c20 6c72 753d 6c72 7529  ursive, lru=lru)
+00001750: 0a0a 2020 2020 7369 676e 6174 7572 6520  ..    signature 
+00001760: 3d20 696e 7370 6563 742e 7369 676e 6174  = inspect.signat
+00001770: 7572 6528 6675 6e63 290a 2020 2020 6172  ure(func).    ar
+00001780: 6775 6d65 6e74 7320 3d20 5b5d 2020 2320  guments = []  # 
+00001790: 6c69 7374 206f 6620 7061 7374 2066 756e  list of past fun
+000017a0: 6374 696f 6e20 6172 6775 6d65 6e74 732c  ction arguments,
+000017b0: 206c 6561 7374 2072 6563 656e 746c 7920   least recently 
+000017c0: 7573 6564 206c 6173 740a 2020 2020 6361  used last.    ca
+000017d0: 6368 6573 203d 205b 5d20 2023 206c 6973  ches = []  # lis
+000017e0: 7420 6f66 2077 6561 6b2d 6b65 7920 6469  t of weak-key di
+000017f0: 6374 696f 6e61 7269 6573 206d 6174 6368  ctionaries match
+00001800: 696e 6720 6172 6775 6d65 6e74 7320 2861  ing arguments (a
+00001810: 626f 7665 290a 0a20 2020 2072 656d 656d  bove)..    remem
+00001820: 6265 7220 3d20 6f62 6a65 6374 2829 2020  ber = object()  
+00001830: 2320 746f 6b65 6e20 746f 2073 6967 6e61  # token to signa
+00001840: 6c20 7468 6174 2072 7374 6163 6b5b 2d31  l that rstack[-1
+00001850: 5d20 6361 6e20 6265 2063 6163 6865 6420  ] can be cached 
+00001860: 6173 2074 6865 2072 6570 6c61 6365 6d65  as the replaceme
+00001870: 6e74 206f 6620 6673 7461 636b 5b2d 315d  nt of fstack[-1]
+00001880: 0a20 2020 2072 6563 7265 6174 6520 3d20  .    recreate = 
+00001890: 6f62 6a65 6374 2829 2020 2320 746f 6b65  object()  # toke
+000018a0: 6e20 746f 2073 6967 6e61 6c20 7468 6174  n to signal that
+000018b0: 2061 6c6c 2061 7267 756d 656e 7473 2066   all arguments f
+000018c0: 6f72 206f 626a 6563 7420 7265 6372 6561  or object recrea
+000018d0: 7469 6f6e 2061 7265 2072 6561 6479 206f  tion are ready o
+000018e0: 6e20 7273 7461 636b 0a20 2020 2070 656e  n rstack.    pen
+000018f0: 6469 6e67 203d 206f 626a 6563 7428 2920  ding = object() 
+00001900: 2023 2074 6f6b 656e 2074 6f20 686f 6c64   # token to hold
+00001910: 2074 6865 2070 6c61 6365 206f 6620 6120   the place of a 
+00001920: 6361 6368 6162 6c65 206f 626a 6563 7420  cachable object 
+00001930: 7065 6e64 696e 6720 6372 6561 7469 6f6e  pending creation
+00001940: 0a20 2020 2069 6465 6e74 6974 7920 3d20  .    identity = 
+00001950: 6f62 6a65 6374 2829 2020 2320 746f 6b65  object()  # toke
+00001960: 6e20 746f 2068 6f6c 6420 7468 6520 706c  n to hold the pl
+00001970: 6163 6520 6f66 2074 6865 2063 6163 6865  ace of the cache
+00001980: 2076 616c 7565 2069 6e20 6361 7365 2069   value in case i
+00001990: 7420 6d61 7463 6865 7320 6b65 792c 2074  t matches key, t
+000019a0: 6f20 6176 6f69 6420 6369 7263 756c 6172  o avoid circular
+000019b0: 2072 6566 6572 656e 6365 730a 0a20 2020   references..   
+000019c0: 2040 6675 6e63 746f 6f6c 732e 7772 6170   @functools.wrap
+000019d0: 7328 6675 6e63 290a 2020 2020 6465 6620  s(func).    def 
+000019e0: 7772 6170 7065 6428 7461 7267 6574 2c20  wrapped(target, 
+000019f0: 2a66 756e 6361 7267 732c 202a 2a66 756e  *funcargs, **fun
+00001a00: 636b 7761 7267 7329 3a0a 0a20 2020 2020  ckwargs):..     
+00001a10: 2020 2023 2072 6574 7269 6576 6520 6f72     # retrieve or
+00001a20: 2063 7265 6174 6520 6120 7765 616b 2d6b   create a weak-k
+00001a30: 6579 2064 6963 7469 6f6e 6172 790a 2020  ey dictionary.  
+00001a40: 2020 2020 2020 626f 756e 6420 3d20 7369        bound = si
+00001a50: 676e 6174 7572 652e 6269 6e64 284e 6f6e  gnature.bind(Non
+00001a60: 652c 202a 6675 6e63 6172 6773 2c20 2a2a  e, *funcargs, **
+00001a70: 6675 6e63 6b77 6172 6773 290a 2020 2020  funckwargs).    
+00001a80: 2020 2020 626f 756e 642e 6170 706c 795f      bound.apply_
+00001a90: 6465 6661 756c 7473 2829 0a20 2020 2020  defaults().     
+00001aa0: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+00001ab0: 2020 2020 696e 6465 7820 3d20 6172 6775      index = argu
+00001ac0: 6d65 6e74 732e 696e 6465 7828 626f 756e  ments.index(boun
+00001ad0: 642e 6172 6775 6d65 6e74 7329 2020 2320  d.arguments)  # 
+00001ae0: 6279 2075 7369 6e67 2069 6e64 6578 2c20  by using index, 
+00001af0: 6172 6775 6d65 6e74 7320 6e65 6564 206e  arguments need n
+00001b00: 6f74 2062 6520 6861 7368 6162 6c65 0a20  ot be hashable. 
+00001b10: 2020 2020 2020 2065 7863 6570 7420 5661         except Va
+00001b20: 6c75 6545 7272 6f72 3a0a 2020 2020 2020  lueError:.      
+00001b30: 2020 2020 2020 696e 6465 7820 3d20 2d31        index = -1
+00001b40: 0a20 2020 2020 2020 2020 2020 2063 6163  .            cac
+00001b50: 6865 203d 2077 6561 6b72 6566 2e57 6561  he = weakref.Wea
+00001b60: 6b4b 6579 4469 6374 696f 6e61 7279 2829  kKeyDictionary()
+00001b70: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00001b80: 2020 2020 2020 2020 2020 2063 6163 6865             cache
+00001b90: 203d 2063 6163 6865 735b 696e 6465 785d   = caches[index]
+00001ba0: 0a20 2020 2020 2020 2069 6620 696e 6465  .        if inde
+00001bb0: 7820 213d 2030 3a20 2023 2066 756e 6374  x != 0:  # funct
+00001bc0: 696f 6e20 6172 6775 6d65 6e74 7320 6172  ion arguments ar
+00001bd0: 6520 6e6f 7420 7468 6520 6d6f 7374 2072  e not the most r
+00001be0: 6563 656e 7420 2870 6f73 7369 626c 7920  ecent (possibly 
+00001bf0: 6e65 7729 0a20 2020 2020 2020 2020 2020  new).           
+00001c00: 2069 6620 696e 6465 7820 3e20 3020 6f72   if index > 0 or
+00001c10: 206c 656e 2861 7267 756d 656e 7473 2920   len(arguments) 
+00001c20: 3e3d 206c 7275 3a0a 2020 2020 2020 2020  >= lru:.        
+00001c30: 2020 2020 2020 2020 6361 6368 6573 2e70          caches.p
+00001c40: 6f70 2869 6e64 6578 2920 2023 2070 6f70  op(index)  # pop
+00001c50: 206d 6174 6368 696e 6720 286f 7220 6f6c   matching (or ol
+00001c60: 6465 7374 2920 6974 656d 0a20 2020 2020  dest) item.     
+00001c70: 2020 2020 2020 2020 2020 2061 7267 756d             argum
+00001c80: 656e 7473 2e70 6f70 2869 6e64 6578 290a  ents.pop(index).
+00001c90: 2020 2020 2020 2020 2020 2020 6361 6368              cach
+00001ca0: 6573 2e69 6e73 6572 7428 302c 2063 6163  es.insert(0, cac
+00001cb0: 6865 2920 2023 2069 6e73 6572 7420 706f  he)  # insert po
+00001cc0: 7070 6564 2028 6f72 206e 6577 2920 6974  pped (or new) it
+00001cd0: 656d 2074 6f20 6672 6f6e 740a 2020 2020  em to front.    
+00001ce0: 2020 2020 2020 2020 6172 6775 6d65 6e74          argument
+00001cf0: 732e 696e 7365 7274 2830 2c20 626f 756e  s.insert(0, boun
+00001d00: 642e 6172 6775 6d65 6e74 7329 0a0a 2020  d.arguments)..  
+00001d10: 2020 2020 2020 6673 7461 636b 203d 205b        fstack = [
+00001d20: 7461 7267 6574 5d20 2023 2073 7461 636b  target]  # stack
+00001d30: 206f 6620 756e 7072 6f63 6573 7365 6420   of unprocessed 
+00001d40: 6f62 6a65 6374 7320 616e 6420 636f 6d6d  objects and comm
+00001d50: 616e 6420 746f 6b65 6e73 0a20 2020 2020  and tokens.     
+00001d60: 2020 2072 7374 6163 6b20 3d20 5b5d 2020     rstack = []  
+00001d70: 2320 7374 6163 6b20 6f66 2070 726f 6365  # stack of proce
+00001d80: 7373 6564 206f 626a 6563 7473 0a20 2020  ssed objects.   
+00001d90: 2020 2020 205f 7374 6163 6b20 3d20 6673       _stack = fs
+00001da0: 7461 636b 2069 6620 7265 6375 7273 6976  tack if recursiv
+00001db0: 6520 656c 7365 2072 7374 6163 6b0a 0a20  e else rstack.. 
+00001dc0: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+00001dd0: 2020 2020 2020 2020 7768 696c 6520 6673          while fs
+00001de0: 7461 636b 3a0a 2020 2020 2020 2020 2020  tack:.          
+00001df0: 2020 2020 2020 6f62 6a20 3d20 6673 7461        obj = fsta
+00001e00: 636b 2e70 6f70 2829 0a0a 2020 2020 2020  ck.pop()..      
+00001e10: 2020 2020 2020 2020 2020 6966 206f 626a            if obj
+00001e20: 2069 7320 7265 6372 6561 7465 3a0a 2020   is recreate:.  
+00001e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001e40: 2020 6172 6773 203d 205b 7273 7461 636b    args = [rstack
+00001e50: 2e70 6f70 2829 2066 6f72 206f 626a 2069  .pop() for obj i
+00001e60: 6e20 7261 6e67 6528 6673 7461 636b 2e70  n range(fstack.p
+00001e70: 6f70 2829 295d 0a20 2020 2020 2020 2020  op())].         
+00001e80: 2020 2020 2020 2020 2020 2066 203d 2066             f = f
+00001e90: 7374 6163 6b2e 706f 7028 290a 2020 2020  stack.pop().    
+00001ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001eb0: 7220 3d20 6628 2a61 7267 7329 0a20 2020  r = f(*args).   
+00001ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001ed0: 2069 6620 6465 7074 6866 6972 7374 3a0a   if depthfirst:.
+00001ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001ef0: 2020 2020 2020 2020 6e65 7772 203d 2066          newr = f
+00001f00: 756e 6328 722c 202a 6675 6e63 6172 6773  unc(r, *funcargs
+00001f10: 2c20 2a2a 6675 6e63 6b77 6172 6773 290a  , **funckwargs).
+00001f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001f30: 2020 2020 2020 2020 6966 206e 6577 7220          if newr 
+00001f40: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+00001f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001f60: 2020 2020 2020 2020 205f 7374 6163 6b2e           _stack.
+00001f70: 6170 7065 6e64 286e 6577 7229 0a20 2020  append(newr).   
+00001f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001f90: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
+00001fa0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00001fb0: 2020 2020 2020 7273 7461 636b 2e61 7070        rstack.app
+00001fc0: 656e 6428 7229 0a20 2020 2020 2020 2020  end(r).         
+00001fd0: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+00001fe0: 6e75 650a 0a20 2020 2020 2020 2020 2020  nue..           
+00001ff0: 2020 2020 2069 6620 6f62 6a20 6973 2072       if obj is r
+00002000: 656d 656d 6265 723a 0a20 2020 2020 2020  emember:.       
+00002010: 2020 2020 2020 2020 2020 2020 206f 626a               obj
+00002020: 203d 2066 7374 6163 6b2e 706f 7028 290a   = fstack.pop().
+00002030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002040: 2020 2020 6361 6368 655b 6f62 6a5d 203d      cache[obj] =
+00002050: 2072 7374 6163 6b5b 2d31 5d20 6966 2072   rstack[-1] if r
+00002060: 7374 6163 6b5b 2d31 5d20 6973 206e 6f74  stack[-1] is not
+00002070: 206f 626a 2065 6c73 6520 6964 656e 7469   obj else identi
+00002080: 7479 0a20 2020 2020 2020 2020 2020 2020  ty.             
+00002090: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+000020a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000020b0: 2069 6620 6f62 6a2e 5f5f 636c 6173 735f   if obj.__class_
+000020c0: 5f20 696e 2028 7475 706c 652c 206c 6973  _ in (tuple, lis
+000020d0: 742c 2064 6963 742c 2073 6574 2c20 6672  t, dict, set, fr
+000020e0: 6f7a 656e 7365 7429 3a0a 2020 2020 2020  ozenset):.      
+000020f0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00002100: 206e 6f74 206f 626a 3a0a 2020 2020 2020   not obj:.      
+00002110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002120: 2020 7273 7461 636b 2e61 7070 656e 6428    rstack.append(
+00002130: 6f62 6a29 2020 2320 7368 6f72 7463 7574  obj)  # shortcut
+00002140: 2074 6f20 6176 6f69 6420 7265 6372 6561   to avoid recrea
+00002150: 7469 6f6e 206f 6620 656d 7074 7920 636f  tion of empty co
+00002160: 6e74 6169 6e65 720a 2020 2020 2020 2020  ntainer.        
+00002170: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00002180: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00002190: 2020 2020 2020 2020 2020 6673 7461 636b            fstack
+000021a0: 2e61 7070 656e 6428 6c61 6d62 6461 202a  .append(lambda *
+000021b0: 782c 2054 3d74 7970 6528 6f62 6a29 3a20  x, T=type(obj): 
+000021c0: 5428 7829 290a 2020 2020 2020 2020 2020  T(x)).          
+000021d0: 2020 2020 2020 2020 2020 2020 2020 6673                fs
+000021e0: 7461 636b 2e61 7070 656e 6428 6c65 6e28  tack.append(len(
+000021f0: 6f62 6a29 290a 2020 2020 2020 2020 2020  obj)).          
+00002200: 2020 2020 2020 2020 2020 2020 2020 6673                fs
+00002210: 7461 636b 2e61 7070 656e 6428 7265 6372  tack.append(recr
+00002220: 6561 7465 290a 2020 2020 2020 2020 2020  eate).          
+00002230: 2020 2020 2020 2020 2020 2020 2020 6673                fs
+00002240: 7461 636b 2e65 7874 656e 6428 6f62 6a20  tack.extend(obj 
+00002250: 6966 206e 6f74 2069 7369 6e73 7461 6e63  if not isinstanc
+00002260: 6528 6f62 6a2c 2064 6963 7429 2065 6c73  e(obj, dict) els
+00002270: 6520 6f62 6a2e 6974 656d 7328 2929 0a20  e obj.items()). 
+00002280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002290: 2020 2063 6f6e 7469 6e75 650a 0a20 2020     continue..   
+000022a0: 2020 2020 2020 2020 2020 2020 2074 7279               try
+000022b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000022c0: 2020 2020 2020 7220 3d20 6361 6368 655b        r = cache[
+000022d0: 6f62 6a5d 0a20 2020 2020 2020 2020 2020  obj].           
+000022e0: 2020 2020 2065 7863 6570 7420 4b65 7945       except KeyE
+000022f0: 7272 6f72 3a20 2023 206f 626a 6563 7420  rror:  # object 
+00002300: 6361 6e20 6265 2077 6561 6b6c 7920 6361  can be weakly ca
+00002310: 6368 6564 2c20 6275 7420 6973 6e27 740a  ched, but isn't.
+00002320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002330: 2020 2020 6361 6368 655b 6f62 6a5d 203d      cache[obj] =
+00002340: 2070 656e 6469 6e67 0a20 2020 2020 2020   pending.       
+00002350: 2020 2020 2020 2020 2020 2020 2066 7374               fst
+00002360: 6163 6b2e 6170 7065 6e64 286f 626a 290a  ack.append(obj).
+00002370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002380: 2020 2020 6673 7461 636b 2e61 7070 656e      fstack.appen
+00002390: 6428 7265 6d65 6d62 6572 290a 2020 2020  d(remember).    
+000023a0: 2020 2020 2020 2020 2020 2020 6578 6365              exce
+000023b0: 7074 2054 7970 6545 7272 6f72 3a20 2023  pt TypeError:  #
+000023c0: 206f 626a 6563 7420 6361 6e6e 6f74 2062   object cannot b
+000023d0: 6520 7265 6665 7265 6e63 6564 206f 7220  e referenced or 
+000023e0: 6973 206e 6f74 2068 6173 6861 626c 650a  is not hashable.
+000023f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002400: 2020 2020 7061 7373 0a20 2020 2020 2020      pass.       
+00002410: 2020 2020 2020 2020 2065 6c73 653a 2020           else:  
+00002420: 2320 6f62 6a65 6374 2069 7320 696e 2063  # object is in c
+00002430: 6163 6865 0a20 2020 2020 2020 2020 2020  ache.           
+00002440: 2020 2020 2020 2020 2069 6620 7220 6973           if r is
+00002450: 2070 656e 6469 6e67 3a0a 2020 2020 2020   pending:.      
+00002460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002470: 2020 7065 6e64 696e 675f 6f62 6a73 203d    pending_objs =
+00002480: 2074 7570 6c65 286b 2066 6f72 206b 2c20   tuple(k for k, 
+00002490: 7620 696e 2063 6163 6865 2e69 7465 6d73  v in cache.items
+000024a0: 2829 2069 6620 7620 6973 2070 656e 6469  () if v is pendi
+000024b0: 6e67 290a 2020 2020 2020 2020 2020 2020  ng).            
+000024c0: 2020 2020 2020 2020 2020 2020 696e 6465              inde
+000024d0: 7820 3d20 7065 6e64 696e 675f 6f62 6a73  x = pending_objs
+000024e0: 2e69 6e64 6578 286f 626a 290a 2020 2020  .index(obj).    
+000024f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002500: 2020 2020 7261 6973 6520 4578 6365 7074      raise Except
+00002510: 696f 6e28 277b 7d40 7265 706c 6163 6520  ion('{}@replace 
+00002520: 6361 7567 6874 2069 6e20 6120 6369 7263  caught in a circ
+00002530: 756c 6172 2064 6570 656e 6465 6e63 655c  ular dependence\
+00002540: 6e27 2e66 6f72 6d61 7428 6675 6e63 2e5f  n'.format(func._
+00002550: 5f6e 616d 655f 5f29 202b 2054 7570 6c65  _name__) + Tuple
+00002560: 2870 656e 6469 6e67 5f6f 626a 735b 696e  (pending_objs[in
+00002570: 6465 783a 5d29 2e61 7363 6969 7472 6565  dex:]).asciitree
+00002580: 2829 2e73 706c 6974 2827 5c6e 272c 2031  ().split('\n', 1
+00002590: 295b 315d 290a 2020 2020 2020 2020 2020  )[1]).          
+000025a0: 2020 2020 2020 2020 2020 7273 7461 636b            rstack
+000025b0: 2e61 7070 656e 6428 7220 6966 2072 2069  .append(r if r i
+000025c0: 7320 6e6f 7420 6964 656e 7469 7479 2065  s not identity e
+000025d0: 6c73 6520 6f62 6a29 0a20 2020 2020 2020  lse obj).       
+000025e0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+000025f0: 7469 6e75 650a 0a20 2020 2020 2020 2020  tinue..         
+00002600: 2020 2020 2020 2069 6620 6e6f 7420 6465         if not de
+00002610: 7074 6866 6972 7374 3a0a 2020 2020 2020  pthfirst:.      
+00002620: 2020 2020 2020 2020 2020 2020 2020 6e65                ne
+00002630: 7772 203d 2066 756e 6328 6f62 6a2c 202a  wr = func(obj, *
+00002640: 6675 6e63 6172 6773 2c20 2a2a 6675 6e63  funcargs, **func
+00002650: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
+00002660: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00002670: 6577 7220 6973 206e 6f74 204e 6f6e 653a  ewr is not None:
+00002680: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002690: 2020 2020 2020 2020 205f 7374 6163 6b2e           _stack.
+000026a0: 6170 7065 6e64 286e 6577 7229 0a20 2020  append(newr).   
+000026b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000026c0: 2020 2020 2063 6f6e 7469 6e75 650a 0a20       continue.. 
+000026d0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+000026e0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+000026f0: 2020 2020 2020 2020 662c 2061 7267 7320          f, args 
+00002700: 3d20 6f62 6a2e 5f5f 7265 6475 6365 5f5f  = obj.__reduce__
+00002710: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+00002720: 2020 2065 7863 6570 743a 2020 2320 6f62     except:  # ob
+00002730: 6a20 6361 6e6e 6f74 2062 6520 7265 6475  j cannot be redu
+00002740: 6365 6420 696e 746f 2061 2063 6f6e 7374  ced into a const
+00002750: 7275 6374 6f72 2061 6e64 2069 7473 2061  ructor and its a
+00002760: 7267 756d 656e 7473 0a20 2020 2020 2020  rguments.       
+00002770: 2020 2020 2020 2020 2020 2020 2072 7374               rst
+00002780: 6163 6b2e 6170 7065 6e64 286f 626a 290a  ack.append(obj).
+00002790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000027a0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+000027b0: 2020 2020 2020 2020 2020 6673 7461 636b            fstack
+000027c0: 2e61 7070 656e 6428 6629 0a20 2020 2020  .append(f).     
+000027d0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+000027e0: 7374 6163 6b2e 6170 7065 6e64 286c 656e  stack.append(len
+000027f0: 2861 7267 7329 290a 2020 2020 2020 2020  (args)).        
+00002800: 2020 2020 2020 2020 2020 2020 6673 7461              fsta
+00002810: 636b 2e61 7070 656e 6428 7265 6372 6561  ck.append(recrea
+00002820: 7465 290a 2020 2020 2020 2020 2020 2020  te).            
+00002830: 2020 2020 2020 2020 6673 7461 636b 2e65          fstack.e
+00002840: 7874 656e 6428 6172 6773 290a 0a20 2020  xtend(args)..   
+00002850: 2020 2020 2020 2020 2061 7373 6572 7420           assert 
+00002860: 6c65 6e28 7273 7461 636b 2920 3d3d 2031  len(rstack) == 1
+00002870: 0a0a 2020 2020 2020 2020 6669 6e61 6c6c  ..        finall
+00002880: 793a 0a20 2020 2020 2020 2020 2020 2077  y:.            w
+00002890: 6869 6c65 2066 7374 6163 6b3a 0a20 2020  hile fstack:.   
+000028a0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+000028b0: 6673 7461 636b 2e70 6f70 2829 2069 7320  fstack.pop() is 
+000028c0: 7265 6d65 6d62 6572 3a0a 2020 2020 2020  remember:.      
+000028d0: 2020 2020 2020 2020 2020 2020 2020 6173                as
+000028e0: 7365 7274 2063 6163 6865 2e70 6f70 2866  sert cache.pop(f
+000028f0: 7374 6163 6b2e 706f 7028 2929 2069 7320  stack.pop()) is 
+00002900: 7065 6e64 696e 670a 0a20 2020 2020 2020  pending..       
+00002910: 2072 6574 7572 6e20 7273 7461 636b 5b30   return rstack[0
+00002920: 5d0a 0a20 2020 2072 6574 7572 6e20 7772  ]..    return wr
+00002930: 6170 7065 640a 0a0a 636c 6173 7320 4576  apped...class Ev
+00002940: 616c 7561 626c 6528 7479 7065 732e 5369  aluable(types.Si
+00002950: 6e67 6c65 746f 6e29 3a0a 2020 2020 2742  ngleton):.    'B
+00002960: 6173 6520 636c 6173 7327 0a0a 2020 2020  ase class'..    
+00002970: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
+00002980: 662c 2061 7267 733a 2074 7970 696e 672e  f, args: typing.
+00002990: 5475 706c 655b 2745 7661 6c75 6162 6c65  Tuple['Evaluable
+000029a0: 272c 202e 2e2e 5d29 3a0a 2020 2020 2020  ', ...]):.      
+000029b0: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+000029c0: 6e63 6528 6172 6773 2c20 7475 706c 6529  nce(args, tuple)
+000029d0: 2061 6e64 2061 6c6c 2869 7369 6e73 7461   and all(isinsta
+000029e0: 6e63 6528 6172 672c 2045 7661 6c75 6162  nce(arg, Evaluab
+000029f0: 6c65 2920 666f 7220 6172 6720 696e 2061  le) for arg in a
+00002a00: 7267 7329 2c20 6627 6172 6773 3d7b 6172  rgs), f'args={ar
+00002a10: 6773 2172 7d27 0a20 2020 2020 2020 2073  gs!r}'.        s
+00002a20: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
+00002a30: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+00002a40: 5f61 7267 7320 3d20 6172 6773 0a0a 2020  _args = args..  
+00002a50: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
+00002a60: 2020 2020 6465 6620 6576 616c 6628 2a61      def evalf(*a
+00002a70: 7267 7329 3a0a 2020 2020 2020 2020 7261  rgs):.        ra
+00002a80: 6973 6520 4e6f 7449 6d70 6c65 6d65 6e74  ise NotImplement
+00002a90: 6564 4572 726f 7228 2745 7661 6c75 6162  edError('Evaluab
+00002aa0: 6c65 2064 6572 6976 6174 6976 6573 2073  le derivatives s
+00002ab0: 686f 756c 6420 696d 706c 656d 656e 7420  hould implement 
+00002ac0: 7468 6520 6576 616c 6620 6d65 7468 6f64  the evalf method
+00002ad0: 2729 0a0a 2020 2020 6465 6620 6576 616c  ')..    def eval
+00002ae0: 665f 7769 7468 7469 6d65 7328 7365 6c66  f_withtimes(self
+00002af0: 2c20 7469 6d65 732c 202a 6172 6773 293a  , times, *args):
+00002b00: 0a20 2020 2020 2020 2077 6974 6820 7469  .        with ti
+00002b10: 6d65 735b 7365 6c66 5d3a 0a20 2020 2020  mes[self]:.     
+00002b20: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00002b30: 6c66 2e65 7661 6c66 282a 6172 6773 290a  lf.evalf(*args).
+00002b40: 0a20 2020 2040 6361 6368 6564 5f70 726f  .    @cached_pro
+00002b50: 7065 7274 790a 2020 2020 6465 6620 6465  perty.    def de
+00002b60: 7065 6e64 656e 6369 6573 2873 656c 6629  pendencies(self)
+00002b70: 3a0a 2020 2020 2020 2020 2727 2763 6f6c  :.        '''col
+00002b80: 6c65 6374 696f 6e20 6f66 2061 6c6c 2066  lection of all f
+00002b90: 756e 6374 696f 6e20 6172 6775 6d65 6e74  unction argument
+00002ba0: 7327 2727 0a20 2020 2020 2020 2064 6570  s'''.        dep
+00002bb0: 7320 3d20 7b7d 0a20 2020 2020 2020 2066  s = {}.        f
+00002bc0: 6f72 2066 756e 6320 696e 2073 656c 662e  or func in self.
+00002bd0: 5f5f 6172 6773 3a0a 2020 2020 2020 2020  __args:.        
+00002be0: 2020 2020 6675 6e63 6465 7073 203d 2066      funcdeps = f
+00002bf0: 756e 632e 6465 7065 6e64 656e 6369 6573  unc.dependencies
+00002c00: 0a20 2020 2020 2020 2020 2020 2064 6570  .            dep
+00002c10: 732e 7570 6461 7465 2866 756e 6364 6570  s.update(funcdep
+00002c20: 7329 0a20 2020 2020 2020 2020 2020 2064  s).            d
+00002c30: 6570 735b 6675 6e63 5d20 3d20 6c65 6e28  eps[func] = len(
+00002c40: 6675 6e63 6465 7073 290a 2020 2020 2020  funcdeps).      
+00002c50: 2020 7265 7475 726e 2074 7970 6573 2e66    return types.f
+00002c60: 726f 7a65 6e64 6963 7428 6465 7073 290a  rozendict(deps).
+00002c70: 0a20 2020 2040 6361 6368 6564 5f70 726f  .    @cached_pro
+00002c80: 7065 7274 790a 2020 2020 6465 6620 6172  perty.    def ar
+00002c90: 6775 6d65 6e74 7328 7365 6c66 293a 0a20  guments(self):. 
+00002ca0: 2020 2020 2020 2027 6120 6672 6f7a 656e         'a frozen
+00002cb0: 7365 7420 6f66 2061 6c6c 2061 7267 756d  set of all argum
+00002cc0: 656e 7473 206f 6620 7468 6973 2065 7661  ents of this eva
+00002cd0: 6c75 6162 6c65 270a 2020 2020 2020 2020  luable'.        
+00002ce0: 7265 7475 726e 2066 726f 7a65 6e73 6574  return frozenset
+00002cf0: 2829 2e75 6e69 6f6e 282a 2863 6869 6c64  ().union(*(child
+00002d00: 2e61 7267 756d 656e 7473 2066 6f72 2063  .arguments for c
+00002d10: 6869 6c64 2069 6e20 7365 6c66 2e5f 5f61  hild in self.__a
+00002d20: 7267 7329 290a 0a20 2020 2040 7072 6f70  rgs))..    @prop
+00002d30: 6572 7479 0a20 2020 2064 6566 2069 7363  erty.    def isc
+00002d40: 6f6e 7374 616e 7428 7365 6c66 293a 0a20  onstant(self):. 
+00002d50: 2020 2020 2020 2072 6574 7572 6e20 4556         return EV
+00002d60: 414c 4152 4753 206e 6f74 2069 6e20 7365  ALARGS not in se
+00002d70: 6c66 2e64 6570 656e 6465 6e63 6965 7320  lf.dependencies 
+00002d80: 616e 6420 6e6f 7420 7365 6c66 2e61 7267  and not self.arg
+00002d90: 756d 656e 7473 0a0a 2020 2020 4063 6163  uments..    @cac
+00002da0: 6865 645f 7072 6f70 6572 7479 0a20 2020  hed_property.   
+00002db0: 2064 6566 206f 7264 6572 6564 6465 7073   def ordereddeps
+00002dc0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00002dd0: 2727 2763 6f6c 6c65 6374 696f 6e20 6f66  '''collection of
+00002de0: 2061 6c6c 2066 756e 6374 696f 6e20 6172   all function ar
+00002df0: 6775 6d65 6e74 7320 7375 6368 2074 6861  guments such tha
+00002e00: 7420 7468 6520 6172 6775 6d65 6e74 7320  t the arguments 
+00002e10: 746f 0a20 2020 2020 2020 2064 6570 656e  to.        depen
+00002e20: 6465 6e63 6965 735b 695d 2063 616e 2062  dencies[i] can b
+00002e30: 6520 666f 756e 6420 696e 2064 6570 656e  e found in depen
+00002e40: 6465 6e63 6965 735b 3a69 5d27 2727 0a20  dencies[:i]'''. 
+00002e50: 2020 2020 2020 2064 6570 7320 3d20 7365         deps = se
+00002e60: 6c66 2e64 6570 656e 6465 6e63 6965 732e  lf.dependencies.
+00002e70: 636f 7079 2829 0a20 2020 2020 2020 2064  copy().        d
+00002e80: 6570 732e 706f 7028 4556 414c 4152 4753  eps.pop(EVALARGS
+00002e90: 2c20 4e6f 6e65 290a 2020 2020 2020 2020  , None).        
+00002ea0: 7265 7475 726e 2074 7570 6c65 285b 4556  return tuple([EV
+00002eb0: 414c 4152 4753 5d20 2b20 736f 7274 6564  ALARGS] + sorted
+00002ec0: 2864 6570 732c 206b 6579 3d64 6570 732e  (deps, key=deps.
+00002ed0: 5f5f 6765 7469 7465 6d5f 5f29 290a 0a20  __getitem__)).. 
+00002ee0: 2020 2040 6361 6368 6564 5f70 726f 7065     @cached_prope
+00002ef0: 7274 790a 2020 2020 6465 6620 6465 7065  rty.    def depe
+00002f00: 6e64 656e 6379 7472 6565 2873 656c 6629  ndencytree(self)
+00002f10: 3a0a 2020 2020 2020 2020 2727 276c 6f6f  :.        '''loo
+00002f20: 6b75 7020 7461 626c 6520 6f66 2066 756e  kup table of fun
+00002f30: 6374 696f 6e20 6172 6775 6d65 6e74 7320  ction arguments 
+00002f40: 696e 746f 206f 7264 6572 6564 6465 7073  into ordereddeps
+00002f50: 2c20 7375 6368 2074 6861 740a 2020 2020  , such that.    
+00002f60: 2020 2020 6f72 6465 7265 6464 6570 735b      ordereddeps[
+00002f70: 695d 2e5f 5f61 7267 735b 6a5d 203d 3d20  i].__args[j] == 
+00002f80: 6f72 6465 7265 6464 6570 735b 6465 7065  ordereddeps[depe
+00002f90: 6e64 656e 6379 7472 6565 5b69 5d5b 6a5d  ndencytree[i][j]
+00002fa0: 5d2c 2061 6e64 0a20 2020 2020 2020 2073  ], and.        s
+00002fb0: 656c 662e 5f5f 6172 6773 5b6a 5d20 3d3d  elf.__args[j] ==
+00002fc0: 206f 7264 6572 6564 6465 7073 5b64 6570   ordereddeps[dep
+00002fd0: 656e 6465 6e63 7974 7265 655b 2d31 5d5b  endencytree[-1][
+00002fe0: 6a5d 5d27 2727 0a20 2020 2020 2020 2061  j]]'''.        a
+00002ff0: 7267 7320 3d20 7365 6c66 2e6f 7264 6572  rgs = self.order
+00003000: 6564 6465 7073 0a20 2020 2020 2020 2072  eddeps.        r
+00003010: 6574 7572 6e20 7475 706c 6528 7475 706c  eturn tuple(tupl
+00003020: 6528 6d61 7028 6172 6773 2e69 6e64 6578  e(map(args.index
+00003030: 2c20 6675 6e63 2e5f 5f61 7267 7329 2920  , func.__args)) 
+00003040: 666f 7220 6675 6e63 2069 6e20 6172 6773  for func in args
+00003050: 2b28 7365 6c66 2c29 290a 0a20 2020 2040  +(self,))..    @
+00003060: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00003070: 2073 6572 6961 6c69 7a65 6428 7365 6c66   serialized(self
+00003080: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00003090: 6e20 7a69 7028 7365 6c66 2e6f 7264 6572  n zip(self.order
+000030a0: 6564 6465 7073 5b31 3a5d 2b28 7365 6c66  eddeps[1:]+(self
+000030b0: 2c29 2c20 7365 6c66 2e64 6570 656e 6465  ,), self.depende
+000030c0: 6e63 7974 7265 655b 313a 5d29 0a0a 2020  ncytree[1:])..  
+000030d0: 2020 2320 5468 6973 2070 726f 7065 7274    # This propert
+000030e0: 7920 6973 2061 2064 6572 6976 6174 696f  y is a derivatio
+000030f0: 6e20 6f66 2060 6f72 6465 7265 6464 6570  n of `ordereddep
+00003100: 735b 313a 5d60 2077 6865 7265 2074 6865  s[1:]` where the
+00003110: 2060 4576 616c 7561 626c 6560 0a20 2020   `Evaluable`.   
+00003120: 2023 2069 6e73 7461 6e63 6573 2061 7265   # instances are
+00003130: 206d 6170 7065 6420 746f 2074 6865 2060   mapped to the `
+00003140: 6576 616c 6660 206d 6574 686f 6473 206f  evalf` methods o
+00003150: 6620 7468 6520 696e 7374 616e 6365 732e  f the instances.
+00003160: 2041 7373 6572 7469 6e67 0a20 2020 2023   Asserting.    #
+00003170: 2074 6861 7420 6675 6e63 7469 6f6e 7320   that functions 
+00003180: 6172 6520 696d 6d75 7461 626c 6520 6973  are immutable is
+00003190: 2064 6966 6669 6375 6c74 2061 6e64 2063   difficult and c
+000031a0: 7572 7265 6e74 6c79 0a20 2020 2023 2060  urrently.    # `
+000031b0: 7479 7065 732e 5f69 7369 6d6d 7574 6162  types._isimmutab
+000031c0: 6c65 6020 6d61 726b 7320 616c 6c20 6675  le` marks all fu
+000031d0: 6e63 7469 6f6e 7320 6173 206d 7574 6162  nctions as mutab
+000031e0: 6c65 2e20 5369 6e63 6520 7468 650a 2020  le. Since the.  
+000031f0: 2020 2320 6074 7970 6573 2e43 6163 6865    # `types.Cache
+00003200: 4d65 7461 6020 6d61 6368 696e 6572 7920  Meta` machinery 
+00003210: 6173 7365 7274 7320 696d 6d75 7461 6269  asserts immutabi
+00003220: 6c69 7479 206f 6620 7468 6520 7072 6f70  lity of the prop
+00003230: 6572 7479 2c20 7765 2068 6176 650a 2020  erty, we have.  
+00003240: 2020 2320 746f 2072 6573 6f72 7420 746f    # to resort to
+00003250: 2061 2072 6567 756c 6172 2060 6675 6e63   a regular `func
+00003260: 746f 6f6c 732e 6361 6368 6564 5f70 726f  tools.cached_pro
+00003270: 7065 7274 7960 2e20 4e65 7665 7274 6865  perty`. Neverthe
+00003280: 6c65 7373 2c20 7468 6973 0a20 2020 2023  less, this.    #
+00003290: 2070 726f 7065 7274 7920 7368 6f75 6c64   property should
+000032a0: 2062 6520 7472 6561 7465 6420 6173 2069   be treated as i
+000032b0: 6620 6974 2069 7320 696d 6d75 7461 626c  f it is immutabl
+000032c0: 652e 0a20 2020 2040 6361 6368 6564 5f70  e..    @cached_p
+000032d0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+000032e0: 5f73 6572 6961 6c69 7a65 645f 6576 616c  _serialized_eval
+000032f0: 665f 6865 6164 2873 656c 6629 3a0a 2020  f_head(self):.  
+00003300: 2020 2020 2020 7265 7475 726e 2074 7570        return tup
+00003310: 6c65 286f 702e 6576 616c 6620 666f 7220  le(op.evalf for 
+00003320: 6f70 2069 6e20 7365 6c66 2e6f 7264 6572  op in self.order
+00003330: 6564 6465 7073 5b31 3a5d 290a 0a20 2020  eddeps[1:])..   
+00003340: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+00003350: 6566 205f 7365 7269 616c 697a 6564 5f65  ef _serialized_e
+00003360: 7661 6c66 2873 656c 6629 3a0a 2020 2020  valf(self):.    
+00003370: 2020 2020 7265 7475 726e 207a 6970 2869      return zip(i
+00003380: 7465 7274 6f6f 6c73 2e63 6861 696e 2873  tertools.chain(s
+00003390: 656c 662e 5f73 6572 6961 6c69 7a65 645f  elf._serialized_
+000033a0: 6576 616c 665f 6865 6164 2c20 2873 656c  evalf_head, (sel
+000033b0: 662e 6576 616c 662c 2929 2c20 7365 6c66  f.evalf,)), self
+000033c0: 2e64 6570 656e 6465 6e63 7974 7265 655b  .dependencytree[
+000033d0: 313a 5d29 0a0a 2020 2020 6465 6620 5f6e  1:])..    def _n
+000033e0: 6f64 6528 7365 6c66 2c20 6361 6368 652c  ode(self, cache,
+000033f0: 2073 7562 6772 6170 682c 2074 696d 6573   subgraph, times
+00003400: 293a 0a20 2020 2020 2020 2069 6620 7365  ):.        if se
+00003410: 6c66 2069 6e20 6361 6368 653a 0a20 2020  lf in cache:.   
+00003420: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00003430: 6361 6368 655b 7365 6c66 5d0a 2020 2020  cache[self].    
+00003440: 2020 2020 6172 6773 203d 2074 7570 6c65      args = tuple
+00003450: 2861 7267 2e5f 6e6f 6465 2863 6163 6865  (arg._node(cache
+00003460: 2c20 7375 6267 7261 7068 2c20 7469 6d65  , subgraph, time
+00003470: 7329 2066 6f72 2061 7267 2069 6e20 7365  s) for arg in se
+00003480: 6c66 2e5f 5f61 7267 7329 0a20 2020 2020  lf.__args).     
+00003490: 2020 206c 6162 656c 203d 2027 5c6e 272e     label = '\n'.
+000034a0: 6a6f 696e 2866 696c 7465 7228 4e6f 6e65  join(filter(None
+000034b0: 2c20 2874 7970 6528 7365 6c66 292e 5f5f  , (type(self).__
+000034c0: 6e61 6d65 5f5f 2c20 7365 6c66 2e5f 6e6f  name__, self._no
+000034d0: 6465 5f64 6574 6169 6c73 2929 290a 2020  de_details))).  
+000034e0: 2020 2020 2020 6361 6368 655b 7365 6c66        cache[self
+000034f0: 5d20 3d20 6e6f 6465 203d 2052 6567 756c  ] = node = Regul
+00003500: 6172 4e6f 6465 286c 6162 656c 2c20 6172  arNode(label, ar
+00003510: 6773 2c20 7b7d 2c20 2874 7970 6528 7365  gs, {}, (type(se
+00003520: 6c66 292e 5f5f 6e61 6d65 5f5f 2c20 7469  lf).__name__, ti
+00003530: 6d65 735b 7365 6c66 5d29 2c20 7375 6267  mes[self]), subg
+00003540: 7261 7068 290a 2020 2020 2020 2020 7265  raph).        re
+00003550: 7475 726e 206e 6f64 650a 0a20 2020 2040  turn node..    @
+00003560: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00003570: 205f 6e6f 6465 5f64 6574 6169 6c73 2873   _node_details(s
+00003580: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00003590: 7475 726e 2027 270a 0a20 2020 2064 6566  turn ''..    def
+000035a0: 2061 7363 6969 7472 6565 2873 656c 662c   asciitree(self,
+000035b0: 2072 6963 686f 7574 7075 743d 4661 6c73   richoutput=Fals
+000035c0: 6529 3a0a 2020 2020 2020 2020 2773 7472  e):.        'str
+000035d0: 696e 6720 7265 7072 6573 656e 7461 7469  ing representati
+000035e0: 6f6e 270a 0a20 2020 2020 2020 2072 6574  on'..        ret
+000035f0: 7572 6e20 7365 6c66 2e5f 6e6f 6465 287b  urn self._node({
+00003600: 7d2c 204e 6f6e 652c 2063 6f6c 6c65 6374  }, None, collect
+00003610: 696f 6e73 2e64 6566 6175 6c74 6469 6374  ions.defaultdict
+00003620: 285f 5374 6174 7329 292e 6765 6e65 7261  (_Stats)).genera
+00003630: 7465 5f61 7363 6969 7472 6565 2872 6963  te_asciitree(ric
+00003640: 686f 7574 7075 7429 0a0a 2020 2020 6465  houtput)..    de
+00003650: 6620 5f5f 7374 725f 5f28 7365 6c66 293a  f __str__(self):
+00003660: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00003670: 7365 6c66 2e5f 5f63 6c61 7373 5f5f 2e5f  self.__class__._
+00003680: 5f6e 616d 655f 5f0a 0a20 2020 2064 6566  _name__..    def
+00003690: 2065 7661 6c28 7365 6c66 2c20 2a2a 6576   eval(self, **ev
+000036a0: 616c 6172 6773 293a 0a20 2020 2020 2020  alargs):.       
+000036b0: 2027 2727 4576 616c 7561 7465 2066 756e   '''Evaluate fun
+000036c0: 6374 696f 6e20 6f6e 2061 2073 7065 6369  ction on a speci
+000036d0: 6669 6564 2065 6c65 6d65 6e74 2c20 706f  fied element, po
+000036e0: 696e 7420 7365 742e 2727 270a 0a20 2020  int set.'''..   
+000036f0: 2020 2020 2076 616c 7565 7320 3d20 5b65       values = [e
+00003700: 7661 6c61 7267 735d 0a20 2020 2020 2020  valargs].       
+00003710: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+00003720: 2020 7661 6c75 6573 2e65 7874 656e 6428    values.extend(
+00003730: 6f70 5f65 7661 6c66 282a 5b76 616c 7565  op_evalf(*[value
+00003740: 735b 695d 2066 6f72 2069 2069 6e20 696e  s[i] for i in in
+00003750: 6469 6365 735d 2920 666f 7220 6f70 5f65  dices]) for op_e
+00003760: 7661 6c66 2c20 696e 6469 6365 7320 696e  valf, indices in
+00003770: 2073 656c 662e 5f73 6572 6961 6c69 7a65   self._serialize
+00003780: 645f 6576 616c 6629 0a20 2020 2020 2020  d_evalf).       
+00003790: 2065 7863 6570 7420 4b65 7962 6f61 7264   except Keyboard
+000037a0: 496e 7465 7272 7570 743a 0a20 2020 2020  Interrupt:.     
+000037b0: 2020 2020 2020 2072 6169 7365 0a20 2020         raise.   
+000037c0: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
+000037d0: 7074 696f 6e20 6173 2065 3a0a 2020 2020  ption as e:.    
+000037e0: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
+000037f0: 7228 7365 6c66 2e5f 666f 726d 6174 5f73  r(self._format_s
+00003800: 7461 636b 2876 616c 7565 732c 2065 2929  tack(values, e))
+00003810: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00003820: 7365 0a20 2020 2020 2020 2065 6c73 653a  se.        else:
+00003830: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00003840: 7572 6e20 7661 6c75 6573 5b2d 315d 0a0a  urn values[-1]..
+00003850: 2020 2020 6465 6620 6576 616c 5f77 6974      def eval_wit
+00003860: 6874 696d 6573 2873 656c 662c 2074 696d  htimes(self, tim
+00003870: 6573 2c20 2a2a 6576 616c 6172 6773 293a  es, **evalargs):
+00003880: 0a20 2020 2020 2020 2027 2727 4576 616c  .        '''Eval
+00003890: 7561 7465 2066 756e 6374 696f 6e20 6f6e  uate function on
+000038a0: 2061 2073 7065 6369 6669 6564 2065 6c65   a specified ele
+000038b0: 6d65 6e74 2c20 706f 696e 7420 7365 7420  ment, point set 
+000038c0: 7768 696c 6520 6d65 6173 7572 6520 7469  while measure ti
+000038d0: 6d65 206f 6620 6561 6368 2073 7465 702e  me of each step.
+000038e0: 2727 270a 0a20 2020 2020 2020 2076 616c  '''..        val
+000038f0: 7565 7320 3d20 5b65 7661 6c61 7267 735d  ues = [evalargs]
+00003900: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
+00003910: 2020 2020 2020 2020 2020 7661 6c75 6573            values
+00003920: 2e65 7874 656e 6428 6f70 2e65 7661 6c66  .extend(op.evalf
+00003930: 5f77 6974 6874 696d 6573 2874 696d 6573  _withtimes(times
+00003940: 2c20 2a5b 7661 6c75 6573 5b69 5d20 666f  , *[values[i] fo
+00003950: 7220 6920 696e 2069 6e64 6963 6573 5d29  r i in indices])
+00003960: 2066 6f72 206f 702c 2069 6e64 6963 6573   for op, indices
+00003970: 2069 6e20 7365 6c66 2e73 6572 6961 6c69   in self.seriali
+00003980: 7a65 6429 0a20 2020 2020 2020 2065 7863  zed).        exc
+00003990: 6570 7420 4b65 7962 6f61 7264 496e 7465  ept KeyboardInte
+000039a0: 7272 7570 743a 0a20 2020 2020 2020 2020  rrupt:.         
+000039b0: 2020 2072 6169 7365 0a20 2020 2020 2020     raise.       
+000039c0: 2065 7863 6570 7420 4578 6365 7074 696f   except Exceptio
+000039d0: 6e20 6173 2065 3a0a 2020 2020 2020 2020  n as e:.        
+000039e0: 2020 2020 6c6f 672e 6572 726f 7228 7365      log.error(se
+000039f0: 6c66 2e5f 666f 726d 6174 5f73 7461 636b  lf._format_stack
+00003a00: 2876 616c 7565 732c 2065 2929 0a20 2020  (values, e)).   
+00003a10: 2020 2020 2020 2020 2072 6169 7365 0a20           raise. 
+00003a20: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00003a30: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00003a40: 7661 6c75 6573 5b2d 315d 0a0a 2020 2020  values[-1]..    
+00003a50: 4063 6f6e 7465 7874 6c69 622e 636f 6e74  @contextlib.cont
+00003a60: 6578 746d 616e 6167 6572 0a20 2020 2064  extmanager.    d
+00003a70: 6566 2073 6573 7369 6f6e 2873 656c 662c  ef session(self,
+00003a80: 2067 7261 7068 7669 7a29 3a0a 2020 2020   graphviz):.    
+00003a90: 2020 2020 6966 2067 7261 7068 7669 7a20      if graphviz 
+00003aa0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+00003ab0: 2020 2020 2079 6965 6c64 2073 656c 662e       yield self.
+00003ac0: 6576 616c 0a20 2020 2020 2020 2020 2020  eval.           
+00003ad0: 2072 6574 7572 6e0a 2020 2020 2020 2020   return.        
+00003ae0: 7374 6174 7320 3d20 636f 6c6c 6563 7469  stats = collecti
+00003af0: 6f6e 732e 6465 6661 756c 7464 6963 7428  ons.defaultdict(
+00003b00: 5f53 7461 7473 290a 0a20 2020 2020 2020  _Stats)..       
+00003b10: 2064 6566 2065 7661 6c28 2a2a 6172 6773   def eval(**args
+00003b20: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+00003b30: 6574 7572 6e20 7365 6c66 2e65 7661 6c5f  eturn self.eval_
+00003b40: 7769 7468 7469 6d65 7328 7374 6174 732c  withtimes(stats,
+00003b50: 202a 2a61 7267 7329 0a20 2020 2020 2020   **args).       
+00003b60: 2077 6974 6820 6c6f 672e 636f 6e74 6578   with log.contex
+00003b70: 7428 2765 7661 6c27 293a 0a20 2020 2020  t('eval'):.     
+00003b80: 2020 2020 2020 2079 6965 6c64 2065 7661         yield eva
+00003b90: 6c0a 2020 2020 2020 2020 2020 2020 6e6f  l.            no
+00003ba0: 6465 203d 2073 656c 662e 5f6e 6f64 6528  de = self._node(
+00003bb0: 7b7d 2c20 4e6f 6e65 2c20 7374 6174 7329  {}, None, stats)
+00003bc0: 0a20 2020 2020 2020 2020 2020 206d 6178  .            max
+00003bd0: 7469 6d65 203d 2062 7569 6c74 696e 732e  time = builtins.
+00003be0: 6d61 7828 6e2e 6d65 7461 6461 7461 5b31  max(n.metadata[1
+00003bf0: 5d2e 7469 6d65 2066 6f72 206e 2069 6e20  ].time for n in 
+00003c00: 6e6f 6465 2e77 616c 6b28 7365 7428 2929  node.walk(set())
+00003c10: 290a 2020 2020 2020 2020 2020 2020 746f  ).            to
+00003c20: 7474 696d 6520 3d20 6275 696c 7469 6e73  ttime = builtins
+00003c30: 2e73 756d 286e 2e6d 6574 6164 6174 615b  .sum(n.metadata[
+00003c40: 315d 2e74 696d 6520 666f 7220 6e20 696e  1].time for n in
+00003c50: 206e 6f64 652e 7761 6c6b 2873 6574 2829   node.walk(set()
+00003c60: 2929 0a20 2020 2020 2020 2020 2020 2061  )).            a
+00003c70: 6767 7374 6174 7320 3d20 7475 706c 6528  ggstats = tuple(
+00003c80: 286b 6579 2c20 6275 696c 7469 6e73 2e73  (key, builtins.s
+00003c90: 756d 2876 2e74 696d 6520 666f 7220 7620  um(v.time for v 
+00003ca0: 696e 2076 616c 7565 7329 2c20 6275 696c  in values), buil
+00003cb0: 7469 6e73 2e73 756d 2876 2e6e 6361 6c6c  tins.sum(v.ncall
+00003cc0: 7320 666f 7220 7620 696e 2076 616c 7565  s for v in value
+00003cd0: 7329 2920 666f 7220 6b65 792c 2076 616c  s)) for key, val
+00003ce0: 7565 7320 696e 2075 7469 6c2e 6761 7468  ues in util.gath
+00003cf0: 6572 286e 2e6d 6574 6164 6174 6120 666f  er(n.metadata fo
+00003d00: 7220 6e20 696e 206e 6f64 652e 7761 6c6b  r n in node.walk
+00003d10: 2873 6574 2829 2929 290a 2020 2020 2020  (set()))).      
+00003d20: 2020 2020 2020 6669 6c6c 5f63 6f6c 6f72        fill_color
+00003d30: 203d 2028 6c61 6d62 6461 206e 6f64 653a   = (lambda node:
+00003d40: 2027 302c 7b3a 2e32 667d 2c31 272e 666f   '0,{:.2f},1'.fo
+00003d50: 726d 6174 286e 6f64 652e 6d65 7461 6461  rmat(node.metada
+00003d60: 7461 5b31 5d2e 7469 6d65 2f6d 6178 7469  ta[1].time/maxti
+00003d70: 6d65 2929 2069 6620 6d61 7874 696d 6520  me)) if maxtime 
+00003d80: 656c 7365 204e 6f6e 650a 2020 2020 2020  else None.      
+00003d90: 2020 2020 2020 6e6f 6465 2e65 7870 6f72        node.expor
+00003da0: 745f 6772 6170 6876 697a 2866 696c 6c5f  t_graphviz(fill_
+00003db0: 636f 6c6f 723d 6669 6c6c 5f63 6f6c 6f72  color=fill_color
+00003dc0: 2c20 646f 745f 7061 7468 3d67 7261 7068  , dot_path=graph
+00003dd0: 7669 7a29 0a20 2020 2020 2020 2020 2020  viz).           
+00003de0: 206c 6f67 2e69 6e66 6f28 2774 6f74 616c   log.info('total
+00003df0: 2074 696d 653a 207b 3a2e 3066 7d6d 735c   time: {:.0f}ms\
+00003e00: 6e27 2e66 6f72 6d61 7428 746f 7474 696d  n'.format(tottim
+00003e10: 652f 3165 3629 202b 2027 5c6e 272e 6a6f  e/1e6) + '\n'.jo
+00003e20: 696e 2827 7b3a 342e 3066 7d20 7b7d 2028  in('{:4.0f} {} (
+00003e30: 7b7d 2063 616c 6c73 2c20 6176 6720 7b3a  {} calls, avg {:
+00003e40: 2e33 667d 2070 6572 2063 616c 6c29 272e  .3f} per call)'.
+00003e50: 666f 726d 6174 2874 202f 2031 6536 2c20  format(t / 1e6, 
+00003e60: 6b2c 206e 2c20 7420 2f20 2831 6536 2a6e  k, n, t / (1e6*n
+00003e70: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+00003e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003ec0: 2066 6f72 206b 2c20 742c 206e 2069 6e20   for k, t, n in 
+00003ed0: 736f 7274 6564 2861 6767 7374 6174 732c  sorted(aggstats,
+00003ee0: 2072 6576 6572 7365 3d54 7275 652c 206b   reverse=True, k
+00003ef0: 6579 3d6c 616d 6264 6120 6974 656d 3a20  ey=lambda item: 
+00003f00: 6974 656d 5b31 5d29 2069 6620 6e29 290a  item[1]) if n)).
+00003f10: 0a20 2020 2064 6566 205f 6974 6572 5f73  .    def _iter_s
+00003f20: 7461 636b 2873 656c 6629 3a0a 2020 2020  tack(self):.    
+00003f30: 2020 2020 7969 656c 6420 2725 3020 3d20      yield '%0 = 
+00003f40: 4556 414c 4152 4753 270a 2020 2020 2020  EVALARGS'.      
+00003f50: 2020 666f 7220 692c 2028 6f70 2c20 696e    for i, (op, in
+00003f60: 6469 6365 7329 2069 6e20 656e 756d 6572  dices) in enumer
+00003f70: 6174 6528 7365 6c66 2e73 6572 6961 6c69  ate(self.seriali
+00003f80: 7a65 642c 2073 7461 7274 3d31 293a 0a20  zed, start=1):. 
+00003f90: 2020 2020 2020 2020 2020 2073 203d 205b             s = [
+00003fa0: 6627 257b 697d 203d 207b 6f70 7d27 5d0a  f'%{i} = {op}'].
+00003fb0: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+00003fc0: 6e64 6963 6573 3a0a 2020 2020 2020 2020  ndices:.        
+00003fd0: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+00003fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003ff0: 2073 6967 203d 2069 6e73 7065 6374 2e73   sig = inspect.s
+00004000: 6967 6e61 7475 7265 286f 702e 6576 616c  ignature(op.eval
+00004010: 6629 0a20 2020 2020 2020 2020 2020 2020  f).             
+00004020: 2020 2065 7863 6570 7420 5661 6c75 6545     except ValueE
+00004030: 7272 6f72 3a0a 2020 2020 2020 2020 2020  rror:.          
+00004040: 2020 2020 2020 2020 2020 732e 6578 7465            s.exte
+00004050: 6e64 2866 2725 7b69 7d27 2066 6f72 2069  nd(f'%{i}' for i
+00004060: 2069 6e20 696e 6469 6365 7329 0a20 2020   in indices).   
+00004070: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00004080: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00004090: 2020 2020 2020 2073 2e65 7874 656e 6428         s.extend(
+000040a0: 6627 7b70 6172 616d 7d3d 257b 697d 2720  f'{param}=%{i}' 
+000040b0: 666f 7220 7061 7261 6d2c 2069 2069 6e20  for param, i in 
+000040c0: 7a69 7028 7369 672e 7061 7261 6d65 7465  zip(sig.paramete
+000040d0: 7273 2c20 696e 6469 6365 7329 290a 2020  rs, indices)).  
+000040e0: 2020 2020 2020 2020 2020 7969 656c 6420            yield 
+000040f0: 2720 272e 6a6f 696e 2873 290a 0a20 2020  ' '.join(s)..   
+00004100: 2064 6566 205f 666f 726d 6174 5f73 7461   def _format_sta
+00004110: 636b 2873 656c 662c 2076 616c 7565 732c  ck(self, values,
+00004120: 2065 293a 0a20 2020 2020 2020 206c 696e   e):.        lin
+00004130: 6573 203d 205b 6627 6576 616c 7561 7469  es = [f'evaluati
+00004140: 6f6e 2066 6169 6c65 6420 696e 2073 7465  on failed in ste
+00004150: 7020 7b6c 656e 2876 616c 7565 7329 7d2f  p {len(values)}/
+00004160: 7b6c 656e 2873 656c 662e 6465 7065 6e64  {len(self.depend
+00004170: 656e 6369 6573 292b 317d 275d 0a20 2020  encies)+1}'].   
+00004180: 2020 2020 2073 7461 636b 203d 2073 656c       stack = sel
+00004190: 662e 5f69 7465 725f 7374 6163 6b28 290a  f._iter_stack().
+000041a0: 2020 2020 2020 2020 666f 7220 762c 206f          for v, o
+000041b0: 7020 696e 207a 6970 2876 616c 7565 732c  p in zip(values,
+000041c0: 2073 7461 636b 293a 2023 204e 4f54 4520   stack): # NOTE 
+000041d0: 7661 6c75 6573 206d 7573 7420 636f 6d65  values must come
+000041e0: 2066 6972 7374 2074 6f20 6176 6f69 6420   first to avoid 
+000041f0: 706f 7070 696e 6720 6e65 7874 2069 7465  popping next ite
+00004200: 6d20 6672 6f6d 2073 7461 636b 0a20 2020  m from stack.   
+00004210: 2020 2020 2020 2020 2073 203d 2066 277b           s = f'{
+00004220: 7479 7065 2876 292e 5f5f 6e61 6d65 5f5f  type(v).__name__
+00004230: 7d27 0a20 2020 2020 2020 2020 2020 2069  }'.            i
+00004240: 6620 6e75 6d65 7269 632e 6973 6172 7261  f numeric.isarra
+00004250: 7928 7629 3a0a 2020 2020 2020 2020 2020  y(v):.          
+00004260: 2020 2020 2020 7320 2b3d 2066 273c 7b76        s += f'<{v
+00004270: 2e64 7479 7065 2e6b 696e 647d 3a7b 222c  .dtype.kind}:{",
+00004280: 222e 6a6f 696e 2873 7472 286e 2920 666f  ".join(str(n) fo
+00004290: 7220 6e20 696e 2076 2e73 6861 7065 297d  r n in v.shape)}
+000042a0: 3e27 0a20 2020 2020 2020 2020 2020 206c  >'.            l
+000042b0: 696e 6573 2e61 7070 656e 6428 6627 7b6f  ines.append(f'{o
+000042c0: 707d 202d 2d3e 207b 737d 2729 0a20 2020  p} --> {s}').   
+000042d0: 2020 2020 206c 696e 6573 2e61 7070 656e       lines.appen
+000042e0: 6428 6627 7b6e 6578 7428 7374 6163 6b29  d(f'{next(stack)
+000042f0: 7d20 2d2d 3e20 7b65 7d27 290a 2020 2020  } --> {e}').    
+00004300: 2020 2020 7265 7475 726e 2027 5c6e 2020      return '\n  
+00004310: 272e 6a6f 696e 286c 696e 6573 290a 0a20  '.join(lines).. 
+00004320: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00004330: 2040 7265 706c 6163 6528 6465 7074 6866   @replace(depthf
+00004340: 6972 7374 3d54 7275 652c 2072 6563 7572  irst=True, recur
+00004350: 7369 7665 3d54 7275 6529 0a20 2020 2064  sive=True).    d
+00004360: 6566 2073 696d 706c 6966 6965 6428 6f62  ef simplified(ob
+00004370: 6a29 3a0a 2020 2020 2020 2020 6966 2069  j):.        if i
+00004380: 7369 6e73 7461 6e63 6528 6f62 6a2c 2045  sinstance(obj, E
+00004390: 7661 6c75 6162 6c65 293a 0a20 2020 2020  valuable):.     
+000043a0: 2020 2020 2020 2072 6574 7661 6c20 3d20         retval = 
+000043b0: 6f62 6a2e 5f73 696d 706c 6966 6965 6428  obj._simplified(
+000043c0: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
+000043d0: 2072 6574 7661 6c20 6973 206e 6f74 204e   retval is not N
+000043e0: 6f6e 6520 616e 6420 6973 696e 7374 616e  one and isinstan
+000043f0: 6365 286f 626a 2c20 4172 7261 7929 3a0a  ce(obj, Array):.
+00004400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004410: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+00004420: 6528 7265 7476 616c 2c20 4172 7261 7929  e(retval, Array)
+00004430: 2061 6e64 2065 7175 616c 7368 6170 6528   and equalshape(
+00004440: 7265 7476 616c 2e73 6861 7065 2c20 6f62  retval.shape, ob
+00004450: 6a2e 7368 6170 6529 2061 6e64 2072 6574  j.shape) and ret
+00004460: 7661 6c2e 6474 7970 6520 3d3d 206f 626a  val.dtype == obj
+00004470: 2e64 7479 7065 2c20 277b 7d20 2d2d 7369  .dtype, '{} --si
+00004480: 6d70 6c69 6679 2d2d 3e20 7b7d 272e 666f  mplify--> {}'.fo
+00004490: 726d 6174 286f 626a 2c20 7265 7476 616c  rmat(obj, retval
+000044a0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+000044b0: 7475 726e 2072 6574 7661 6c0a 0a20 2020  turn retval..   
+000044c0: 2064 6566 205f 7369 6d70 6c69 6669 6564   def _simplified
+000044d0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+000044e0: 7265 7475 726e 0a0a 2020 2020 4063 6163  return..    @cac
+000044f0: 6865 645f 7072 6f70 6572 7479 0a20 2020  hed_property.   
+00004500: 2064 6566 206f 7074 696d 697a 6564 5f66   def optimized_f
+00004510: 6f72 5f6e 756d 7079 2873 656c 6629 3a0a  or_numpy(self):.
+00004520: 2020 2020 2020 2020 7265 7476 616c 203d          retval =
+00004530: 2073 656c 662e 7369 6d70 6c69 6669 6564   self.simplified
+00004540: 2e5f 6f70 7469 6d69 7a65 645f 666f 725f  ._optimized_for_
+00004550: 6e75 6d70 7931 2829 206f 7220 7365 6c66  numpy1() or self
+00004560: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00004570: 7265 7476 616c 2e5f 636f 6d62 696e 655f  retval._combine_
+00004580: 6c6f 6f70 5f63 6f6e 6361 7465 6e61 7465  loop_concatenate
+00004590: 7328 6672 6f7a 656e 7365 7428 2929 0a0a  s(frozenset())..
+000045a0: 2020 2020 4072 6570 6c61 6365 2864 6570      @replace(dep
+000045b0: 7468 6669 7273 743d 5472 7565 2c20 7265  thfirst=True, re
+000045c0: 6375 7273 6976 653d 5472 7565 290a 2020  cursive=True).  
+000045d0: 2020 6465 6620 5f6f 7074 696d 697a 6564    def _optimized
+000045e0: 5f66 6f72 5f6e 756d 7079 3128 6f62 6a29  _for_numpy1(obj)
+000045f0: 3a0a 2020 2020 2020 2020 6966 2069 7369  :.        if isi
+00004600: 6e73 7461 6e63 6528 6f62 6a2c 2045 7661  nstance(obj, Eva
+00004610: 6c75 6162 6c65 293a 0a20 2020 2020 2020  luable):.       
+00004620: 2020 2020 2072 6574 7661 6c20 3d20 6f62       retval = ob
+00004630: 6a2e 5f73 696d 706c 6966 6965 6428 2920  j._simplified() 
+00004640: 6f72 206f 626a 2e5f 6f70 7469 6d69 7a65  or obj._optimize
+00004650: 645f 666f 725f 6e75 6d70 7928 290a 2020  d_for_numpy().  
+00004660: 2020 2020 2020 2020 2020 6966 2072 6574            if ret
+00004670: 7661 6c20 6973 206e 6f74 204e 6f6e 6520  val is not None 
+00004680: 616e 6420 6973 696e 7374 616e 6365 286f  and isinstance(o
+00004690: 626a 2c20 4172 7261 7929 3a0a 2020 2020  bj, Array):.    
+000046a0: 2020 2020 2020 2020 2020 2020 6173 7365              asse
+000046b0: 7274 2069 7369 6e73 7461 6e63 6528 7265  rt isinstance(re
+000046c0: 7476 616c 2c20 4172 7261 7929 2061 6e64  tval, Array) and
+000046d0: 2065 7175 616c 7368 6170 6528 7265 7476   equalshape(retv
+000046e0: 616c 2e73 6861 7065 2c20 6f62 6a2e 7368  al.shape, obj.sh
+000046f0: 6170 6529 2c20 277b 307d 2e5f 6f70 7469  ape), '{0}._opti
+00004700: 6d69 7a65 645f 666f 725f 6e75 6d70 7920  mized_for_numpy 
+00004710: 6f72 207b 307d 2e5f 7369 6d70 6c69 6669  or {0}._simplifi
+00004720: 6564 2072 6573 756c 7465 6420 696e 2073  ed resulted in s
+00004730: 6861 7065 2063 6861 6e67 6527 2e66 6f72  hape change'.for
+00004740: 6d61 7428 7479 7065 286f 626a 292e 5f5f  mat(type(obj).__
+00004750: 6e61 6d65 5f5f 290a 2020 2020 2020 2020  name__).        
+00004760: 2020 2020 7265 7475 726e 2072 6574 7661      return retva
+00004770: 6c0a 0a20 2020 2064 6566 205f 6f70 7469  l..    def _opti
+00004780: 6d69 7a65 645f 666f 725f 6e75 6d70 7928  mized_for_numpy(
+00004790: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+000047a0: 6574 7572 6e0a 0a20 2020 2040 6361 6368  eturn..    @cach
+000047b0: 6564 5f70 726f 7065 7274 790a 2020 2020  ed_property.    
+000047c0: 6465 6620 5f6c 6f6f 705f 636f 6e63 6174  def _loop_concat
+000047d0: 656e 6174 655f 6465 7073 2873 656c 6629  enate_deps(self)
+000047e0: 3a0a 2020 2020 2020 2020 6465 7073 203d  :.        deps =
+000047f0: 205b 5d0a 2020 2020 2020 2020 666f 7220   [].        for 
+00004800: 6172 6720 696e 2073 656c 662e 5f5f 6172  arg in self.__ar
+00004810: 6773 3a0a 2020 2020 2020 2020 2020 2020  gs:.            
+00004820: 6465 7073 202b 3d20 5b64 6570 2066 6f72  deps += [dep for
+00004830: 2064 6570 2069 6e20 6172 672e 5f6c 6f6f   dep in arg._loo
+00004840: 705f 636f 6e63 6174 656e 6174 655f 6465  p_concatenate_de
+00004850: 7073 2069 6620 6465 7020 6e6f 7420 696e  ps if dep not in
+00004860: 2064 6570 735d 0a20 2020 2020 2020 2072   deps].        r
+00004870: 6574 7572 6e20 7475 706c 6528 6465 7073  eturn tuple(deps
+00004880: 290a 0a20 2020 2064 6566 205f 636f 6d62  )..    def _comb
+00004890: 696e 655f 6c6f 6f70 5f63 6f6e 6361 7465  ine_loop_concate
+000048a0: 6e61 7465 7328 7365 6c66 2c20 6f75 7465  nates(self, oute
+000048b0: 725f 6578 636c 7564 6529 3a0a 2020 2020  r_exclude):.    
+000048c0: 2020 2020 7768 696c 6520 5472 7565 3a0a      while True:.
+000048d0: 2020 2020 2020 2020 2020 2020 6578 636c              excl
+000048e0: 7564 6520 3d20 7365 7428 6f75 7465 725f  ude = set(outer_
+000048f0: 6578 636c 7564 6529 0a20 2020 2020 2020  exclude).       
+00004900: 2020 2020 2063 6f6d 6269 6e65 203d 207b       combine = {
+00004910: 7d0a 2020 2020 2020 2020 2020 2020 2320  }.            # 
+00004920: 436f 6c6c 6563 7420 616c 6c20 746f 702d  Collect all top-
+00004930: 6c65 7665 6c20 604c 6f6f 7043 6f6e 6361  level `LoopConca
+00004940: 7465 6e61 7465 6020 696e 7374 616e 6365  tenate` instance
+00004950: 7320 696e 2060 636f 6d62 696e 6560 2061  s in `combine` a
+00004960: 6e64 2061 6c6c 0a20 2020 2020 2020 2020  nd all.         
+00004970: 2020 2023 2074 6865 6972 2064 6570 656e     # their depen
+00004980: 6465 6e74 2060 4c6f 6f70 436f 6e63 6174  dent `LoopConcat
+00004990: 656e 6174 6560 2069 6e73 7461 6e63 6573  enate` instances
+000049a0: 2069 6e20 6065 7863 6c75 6465 602e 0a20   in `exclude`.. 
+000049b0: 2020 2020 2020 2020 2020 2066 6f72 206c             for l
+000049c0: 6320 696e 2073 656c 662e 5f6c 6f6f 705f  c in self._loop_
+000049d0: 636f 6e63 6174 656e 6174 655f 6465 7073  concatenate_deps
+000049e0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000049f0: 2020 6c63 7320 3d20 636f 6d62 696e 652e    lcs = combine.
+00004a00: 7365 7464 6566 6175 6c74 286c 632e 696e  setdefault(lc.in
+00004a10: 6465 782c 205b 5d29 0a20 2020 2020 2020  dex, []).       
+00004a20: 2020 2020 2020 2020 2069 6620 6c63 206e           if lc n
+00004a30: 6f74 2069 6e20 6c63 733a 0a20 2020 2020  ot in lcs:.     
+00004a40: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00004a50: 6373 2e61 7070 656e 6428 6c63 290a 2020  cs.append(lc).  
+00004a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004a70: 2020 6578 636c 7564 652e 7570 6461 7465    exclude.update
+00004a80: 2873 6574 286c 632e 5f6c 6f6f 705f 636f  (set(lc._loop_co
+00004a90: 6e63 6174 656e 6174 655f 6465 7073 2920  ncatenate_deps) 
+00004aa0: 2d20 7b6c 637d 290a 2020 2020 2020 2020  - {lc}).        
+00004ab0: 2020 2020 2320 436f 6d62 696e 6520 746f      # Combine to
+00004ac0: 702d 6c65 7665 6c20 604c 6f6f 7043 6f6e  p-level `LoopCon
+00004ad0: 6361 7465 6e61 7465 6020 696e 7374 616e  catenate` instan
+00004ae0: 6365 7320 6578 636c 7564 696e 6720 7468  ces excluding th
+00004af0: 6f73 6520 696e 0a20 2020 2020 2020 2020  ose in.         
+00004b00: 2020 2023 2060 6578 636c 7564 6560 2e0a     # `exclude`..
+00004b10: 2020 2020 2020 2020 2020 2020 7265 706c              repl
+00004b20: 6163 656d 656e 7473 203d 207b 7d0a 2020  acements = {}.  
+00004b30: 2020 2020 2020 2020 2020 666f 7220 696e            for in
+00004b40: 6465 782c 206c 6373 2069 6e20 636f 6d62  dex, lcs in comb
+00004b50: 696e 652e 6974 656d 7328 293a 0a20 2020  ine.items():.   
+00004b60: 2020 2020 2020 2020 2020 2020 206c 6373               lcs
+00004b70: 203d 205b 6c63 2066 6f72 206c 6320 696e   = [lc for lc in
+00004b80: 206c 6373 2069 6620 6c63 206e 6f74 2069   lcs if lc not i
+00004b90: 6e20 6578 636c 7564 655d 0a20 2020 2020  n exclude].     
+00004ba0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+00004bb0: 7420 6c63 733a 0a20 2020 2020 2020 2020  t lcs:.         
+00004bc0: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+00004bd0: 6e75 650a 2020 2020 2020 2020 2020 2020  nue.            
+00004be0: 2020 2020 2320 5765 2772 6520 6578 7472      # We're extr
+00004bf0: 6163 7469 6e67 2064 6174 6120 6672 6f6d  acting data from
+00004c00: 2060 4c6f 6f70 436f 6e63 6174 656e 6174   `LoopConcatenat
+00004c10: 6560 2069 6e20 6661 766f 7220 6f66 2075  e` in favor of u
+00004c20: 7369 6e67 0a20 2020 2020 2020 2020 2020  sing.           
+00004c30: 2020 2020 2023 2060 6c6f 6f70 5f63 6f6e       # `loop_con
+00004c40: 6361 7465 6e61 7465 5f63 6f6d 6269 6e65  catenate_combine
+00004c50: 6428 6c63 732c 202e 2e2e 2960 2062 6563  d(lcs, ...)` bec
+00004c60: 6175 7365 2074 6865 206c 6174 6572 2072  ause the later r
+00004c70: 6571 7569 7265 730a 2020 2020 2020 2020  equires.        
+00004c80: 2020 2020 2020 2020 2320 7265 6170 706c          # reappl
+00004c90: 7969 6e67 2073 696d 706c 6966 6963 6174  ying simplificat
+00004ca0: 696f 6e73 2074 6861 7420 6172 6520 616c  ions that are al
+00004cb0: 7265 6164 7920 6170 706c 6965 6420 696e  ready applied in
+00004cc0: 2074 6865 2066 6f72 6d65 722e 0a20 2020   the former..   
+00004cd0: 2020 2020 2020 2020 2020 2020 2023 2046               # F
+00004ce0: 6f72 2065 7861 6d70 6c65 2c20 696e 2060  or example, in `
+00004cf0: 6c6f 6f70 5f63 6f6e 6361 7465 6e61 7465  loop_concatenate
+00004d00: 5f63 6f6d 6269 6e65 6460 2074 6865 206f  _combined` the o
+00004d10: 6666 7365 7473 2028 7573 6564 2062 790a  ffsets (used by.
+00004d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d30: 2320 7374 6172 742c 2073 746f 7020 616e  # start, stop an
+00004d40: 6420 7468 6520 636f 6e63 6174 656e 6174  d the concatenat
+00004d50: 696f 6e20 6c65 6e67 7468 2920 6172 6520  ion length) are 
+00004d60: 666f 726d 6564 2062 790a 2020 2020 2020  formed by.      
+00004d70: 2020 2020 2020 2020 2020 2320 606c 6f6f            # `loo
+00004d80: 705f 636f 6e63 6174 656e 6174 6560 2d69  p_concatenate`-i
+00004d90: 6e67 2060 6675 6e63 2e73 6861 7065 5b2d  ng `func.shape[-
+00004da0: 315d 602e 2049 6620 7468 6520 7368 6170  1]`. If the shap
+00004db0: 6520 6973 2063 6f6e 7374 616e 742c 0a20  e is constant,. 
+00004dc0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00004dd0: 2074 6869 7320 6361 6e20 6265 2073 696d   this can be sim
+00004de0: 706c 6966 6965 6420 746f 2061 2060 5261  plified to a `Ra
+00004df0: 6e67 6560 2e0a 2020 2020 2020 2020 2020  nge`..          
+00004e00: 2020 2020 2020 6461 7461 203d 2054 7570        data = Tup
+00004e10: 6c65 2874 7570 6c65 2854 7570 6c65 286c  le(tuple(Tuple(l
+00004e20: 632e 6675 6e63 6461 7461 2920 666f 7220  c.funcdata) for 
+00004e30: 6c63 2069 6e20 6c63 7329 290a 2020 2020  lc in lcs)).    
+00004e40: 2020 2020 2020 2020 2020 2020 2320 436f              # Co
+00004e50: 6d62 696e 6520 604c 6f6f 7043 6f6e 6361  mbine `LoopConca
+00004e60: 7465 6e61 7465 6020 696e 7374 616e 6365  tenate` instance
+00004e70: 7320 696e 2060 6461 7461 6020 6578 636c  s in `data` excl
+00004e80: 7564 696e 670a 2020 2020 2020 2020 2020  uding.          
+00004e90: 2020 2020 2020 2320 606f 7574 6572 5f65        # `outer_e
+00004ea0: 7863 6c75 6465 6020 616e 6420 7468 6f73  xclude` and thos
+00004eb0: 6520 7468 6174 2077 696c 6c20 6265 2070  e that will be p
+00004ec0: 726f 6365 7373 6564 2069 6e20 6120 7375  rocessed in a su
+00004ed0: 6273 6571 7565 6e74 206c 6f6f 700a 2020  bsequent loop.  
+00004ee0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00004ef0: 2874 6865 2072 656d 6169 6e64 6572 206f  (the remainder o
+00004f00: 6620 6065 7863 6c75 6465 6029 2e20 5468  f `exclude`). Th
+00004f10: 6520 6c61 7474 6572 2063 6f6e 7369 7374  e latter consist
+00004f20: 7320 6f66 206c 6f6f 7073 2074 6861 7420  s of loops that 
+00004f30: 6172 650a 2020 2020 2020 2020 2020 2020  are.            
+00004f40: 2020 2020 2320 696e 7661 7269 616e 7420      # invariant 
+00004f50: 772e 722e 742e 2074 6865 2063 7572 7265  w.r.t. the curre
+00004f60: 6e74 206c 6f6f 7020 6069 6e64 6578 602e  nt loop `index`.
+00004f70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004f80: 2064 6174 6120 3d20 6461 7461 2e5f 636f   data = data._co
+00004f90: 6d62 696e 655f 6c6f 6f70 5f63 6f6e 6361  mbine_loop_conca
+00004fa0: 7465 6e61 7465 7328 6578 636c 7564 6529  tenates(exclude)
+00004fb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004fc0: 2063 6f6d 6269 6e65 6420 3d20 4c6f 6f70   combined = Loop
+00004fd0: 436f 6e63 6174 656e 6174 6543 6f6d 6269  ConcatenateCombi
+00004fe0: 6e65 6428 7475 706c 6528 6d61 7028 7475  ned(tuple(map(tu
+00004ff0: 706c 652c 2064 6174 6129 292c 2069 6e64  ple, data)), ind
+00005000: 6578 2e5f 6e61 6d65 2c20 696e 6465 782e  ex._name, index.
+00005010: 6c65 6e67 7468 290a 2020 2020 2020 2020  length).        
+00005020: 2020 2020 2020 2020 666f 7220 692c 206c          for i, l
+00005030: 6320 696e 2065 6e75 6d65 7261 7465 286c  c in enumerate(l
+00005040: 6373 293a 0a20 2020 2020 2020 2020 2020  cs):.           
+00005050: 2020 2020 2020 2020 2069 6e74 626f 756e           intboun
+00005060: 6473 203d 2064 6963 7428 7a69 7028 2827  ds = dict(zip(('
+00005070: 5f6c 6f77 6572 272c 2027 5f75 7070 6572  _lower', '_upper
+00005080: 2729 2c20 6c63 2e5f 696e 7462 6f75 6e64  '), lc._intbound
+00005090: 7329 2920 6966 206c 632e 6474 7970 6520  s)) if lc.dtype 
+000050a0: 3d3d 2069 6e74 2065 6c73 6520 7b7d 0a20  == int else {}. 
+000050b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000050c0: 2020 2072 6570 6c61 6365 6d65 6e74 735b     replacements[
+000050d0: 6c63 5d20 3d20 4172 7261 7946 726f 6d54  lc] = ArrayFromT
+000050e0: 7570 6c65 2863 6f6d 6269 6e65 642c 2069  uple(combined, i
+000050f0: 2c20 6c63 2e73 6861 7065 2c20 6c63 2e64  , lc.shape, lc.d
+00005100: 7479 7065 2c20 2a2a 696e 7462 6f75 6e64  type, **intbound
+00005110: 7329 0a20 2020 2020 2020 2020 2020 2069  s).            i
+00005120: 6620 7265 706c 6163 656d 656e 7473 3a0a  f replacements:.
+00005130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005140: 7365 6c66 203d 2072 6570 6c61 6365 286c  self = replace(l
+00005150: 616d 6264 6120 6b65 793a 2072 6570 6c61  ambda key: repla
+00005160: 6365 6d65 6e74 732e 6765 7428 6b65 7929  cements.get(key)
+00005170: 2069 6620 6973 696e 7374 616e 6365 286b   if isinstance(k
+00005180: 6579 2c20 4c6f 6f70 436f 6e63 6174 656e  ey, LoopConcaten
+00005190: 6174 6529 2065 6c73 6520 4e6f 6e65 2c20  ate) else None, 
+000051a0: 7265 6375 7273 6976 653d 4661 6c73 652c  recursive=False,
+000051b0: 2064 6570 7468 6669 7273 743d 4661 6c73   depthfirst=Fals
+000051c0: 6529 2873 656c 6629 0a20 2020 2020 2020  e)(self).       
+000051d0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000051e0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000051f0: 6e20 7365 6c66 0a0a 0a63 6c61 7373 2045  n self...class E
+00005200: 5641 4c41 5247 5328 4576 616c 7561 626c  VALARGS(Evaluabl
+00005210: 6529 3a0a 2020 2020 6465 6620 5f5f 696e  e):.    def __in
+00005220: 6974 5f5f 2873 656c 6629 3a0a 2020 2020  it__(self):.    
+00005230: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
+00005240: 6974 5f5f 2861 7267 733d 2829 290a 0a20  it__(args=()).. 
+00005250: 2020 2064 6566 205f 6e6f 6465 2873 656c     def _node(sel
+00005260: 662c 2063 6163 6865 2c20 7375 6267 7261  f, cache, subgra
+00005270: 7068 2c20 7469 6d65 7329 3a0a 2020 2020  ph, times):.    
+00005280: 2020 2020 7265 7475 726e 2049 6e76 6973      return Invis
+00005290: 6962 6c65 4e6f 6465 2828 7479 7065 2873  ibleNode((type(s
+000052a0: 656c 6629 2e5f 5f6e 616d 655f 5f2c 205f  elf).__name__, _
+000052b0: 5374 6174 7328 2929 290a 0a0a 4556 414c  Stats()))...EVAL
+000052c0: 4152 4753 203d 2045 5641 4c41 5247 5328  ARGS = EVALARGS(
+000052d0: 290a 0a0a 636c 6173 7320 4576 616c 7561  )...class Evalua
+000052e0: 626c 6543 6f6e 7374 616e 7428 4576 616c  bleConstant(Eval
+000052f0: 7561 626c 6529 3a0a 2020 2020 2727 2745  uable):.    '''E
+00005300: 7661 6c75 6174 6520 746f 2074 6865 2067  valuate to the g
+00005310: 6976 656e 2063 6f6e 7374 616e 7420 7661  iven constant va
+00005320: 6c75 652e 0a0a 2020 2020 5061 7261 6d65  lue...    Parame
+00005330: 7465 7273 0a20 2020 202d 2d2d 2d2d 2d2d  ters.    -------
+00005340: 2d2d 2d0a 2020 2020 7661 6c75 650a 2020  ---.    value.  
+00005350: 2020 2020 2020 5468 6520 7265 7475 726e        The return
+00005360: 2076 616c 7565 206f 6620 6060 6576 616c   value of ``eval
+00005370: 6060 2e0a 2020 2020 2727 270a 0a20 2020  ``..    '''..   
+00005380: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
+00005390: 6c66 2c20 7661 6c75 6529 3a0a 2020 2020  lf, value):.    
+000053a0: 2020 2020 7365 6c66 2e76 616c 7565 203d      self.value =
+000053b0: 2076 616c 7565 0a20 2020 2020 2020 2073   value.        s
+000053c0: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
+000053d0: 2829 290a 0a20 2020 2064 6566 2065 7661  ())..    def eva
+000053e0: 6c66 2873 656c 6629 3a0a 2020 2020 2020  lf(self):.      
+000053f0: 2020 7265 7475 726e 2073 656c 662e 7661    return self.va
+00005400: 6c75 650a 0a20 2020 2040 7072 6f70 6572  lue..    @proper
+00005410: 7479 0a20 2020 2064 6566 205f 6e6f 6465  ty.    def _node
+00005420: 5f64 6574 6169 6c73 2873 656c 6629 3a0a  _details(self):.
+00005430: 2020 2020 2020 2020 7320 3d20 7265 7072          s = repr
+00005440: 2873 656c 662e 7661 6c75 6529 0a20 2020  (self.value).   
+00005450: 2020 2020 2069 6620 275c 6e27 2069 6e20       if '\n' in 
+00005460: 733a 0a20 2020 2020 2020 2020 2020 2073  s:.            s
+00005470: 203d 2073 2e73 706c 6974 2827 5c6e 272c   = s.split('\n',
+00005480: 2031 295b 305d 202b 2027 2e2e 2e27 0a20   1)[0] + '...'. 
+00005490: 2020 2020 2020 2069 6620 6c65 6e28 7329         if len(s)
+000054a0: 203e 2032 303a 0a20 2020 2020 2020 2020   > 20:.         
+000054b0: 2020 2073 203d 2073 5b3a 3137 5d20 2b20     s = s[:17] + 
+000054c0: 272e 2e2e 270a 2020 2020 2020 2020 7265  '...'.        re
+000054d0: 7475 726e 2073 0a0a 0a63 6c61 7373 2054  turn s...class T
+000054e0: 7570 6c65 2845 7661 6c75 6162 6c65 293a  uple(Evaluable):
+000054f0: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
+00005500: 5f5f 2873 656c 662c 2069 7465 6d73 293a  __(self, items):
+00005510: 0a20 2020 2020 2020 2073 656c 662e 6974  .        self.it
+00005520: 656d 7320 3d20 6974 656d 730a 2020 2020  ems = items.    
+00005530: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
+00005540: 6974 5f5f 2869 7465 6d73 290a 0a20 2020  it__(items)..   
+00005550: 2040 7374 6174 6963 6d65 7468 6f64 0a20   @staticmethod. 
+00005560: 2020 2064 6566 2065 7661 6c66 282a 6974     def evalf(*it
+00005570: 656d 7329 3a0a 2020 2020 2020 2020 7265  ems):.        re
+00005580: 7475 726e 2069 7465 6d73 0a0a 2020 2020  turn items..    
+00005590: 6465 6620 5f5f 6974 6572 5f5f 2873 656c  def __iter__(sel
+000055a0: 6629 3a0a 2020 2020 2020 2020 2769 7465  f):.        'ite
+000055b0: 7261 7465 270a 0a20 2020 2020 2020 2072  rate'..        r
+000055c0: 6574 7572 6e20 6974 6572 2873 656c 662e  eturn iter(self.
+000055d0: 6974 656d 7329 0a0a 2020 2020 6465 6620  items)..    def 
+000055e0: 5f5f 6c65 6e5f 5f28 7365 6c66 293a 0a20  __len__(self):. 
+000055f0: 2020 2020 2020 2027 6c65 6e67 7468 270a         'length'.
+00005600: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00005610: 6c65 6e28 7365 6c66 2e69 7465 6d73 290a  len(self.items).
+00005620: 0a20 2020 2064 6566 205f 5f67 6574 6974  .    def __getit
+00005630: 656d 5f5f 2873 656c 662c 2069 7465 6d29  em__(self, item)
+00005640: 3a0a 2020 2020 2020 2020 2767 6574 2069  :.        'get i
+00005650: 7465 6d27 0a0a 2020 2020 2020 2020 7265  tem'..        re
+00005660: 7475 726e 2073 656c 662e 6974 656d 735b  turn self.items[
+00005670: 6974 656d 5d0a 0a20 2020 2064 6566 205f  item]..    def _
+00005680: 5f61 6464 5f5f 2873 656c 662c 206f 7468  _add__(self, oth
+00005690: 6572 293a 0a20 2020 2020 2020 2027 6164  er):.        'ad
+000056a0: 6427 0a0a 2020 2020 2020 2020 7265 7475  d'..        retu
+000056b0: 726e 2054 7570 6c65 2873 656c 662e 6974  rn Tuple(self.it
+000056c0: 656d 7320 2b20 7475 706c 6528 6f74 6865  ems + tuple(othe
+000056d0: 7229 290a 0a20 2020 2064 6566 205f 5f72  r))..    def __r
+000056e0: 6164 645f 5f28 7365 6c66 2c20 6f74 6865  add__(self, othe
+000056f0: 7229 3a0a 2020 2020 2020 2020 2761 6464  r):.        'add
+00005700: 270a 0a20 2020 2020 2020 2072 6574 7572  '..        retur
+00005710: 6e20 5475 706c 6528 7475 706c 6528 6f74  n Tuple(tuple(ot
+00005720: 6865 7229 202b 2073 656c 662e 6974 656d  her) + self.item
+00005730: 7329 0a0a 0a23 2041 5252 4159 4655 4e43  s)...# ARRAYFUNC
+00005740: 0a23 0a23 2054 6865 206d 6169 6e20 6576  .#.# The main ev
+00005750: 616c 7561 626c 652e 2043 6c6f 7365 6c79  aluable. Closely
+00005760: 206d 696d 6963 7320 6120 6e75 6d70 7920   mimics a numpy 
+00005770: 6172 7261 792e 0a0a 0a64 6566 2061 6464  array....def add
+00005780: 2861 7267 302c 202a 6172 6773 293a 0a20  (arg0, *args):. 
+00005790: 2020 2066 6f72 2061 7267 3120 696e 2061     for arg1 in a
+000057a0: 7267 733a 0a20 2020 2020 2020 2061 7267  rgs:.        arg
+000057b0: 3020 3d20 4164 6428 7479 7065 732e 6672  0 = Add(types.fr
+000057c0: 6f7a 656e 6d75 6c74 6973 6574 285f 6e75  ozenmultiset(_nu
+000057d0: 6d70 795f 616c 6967 6e28 6172 6730 2c20  mpy_align(arg0, 
+000057e0: 6172 6731 2929 290a 2020 2020 7265 7475  arg1))).    retu
+000057f0: 726e 2061 7267 300a 0a0a 6465 6620 6d75  rn arg0...def mu
+00005800: 6c74 6970 6c79 2861 7267 302c 202a 6172  ltiply(arg0, *ar
+00005810: 6773 293a 0a20 2020 2066 6f72 2061 7267  gs):.    for arg
+00005820: 3120 696e 2061 7267 733a 0a20 2020 2020  1 in args:.     
+00005830: 2020 2061 7267 3020 3d20 4d75 6c74 6970     arg0 = Multip
+00005840: 6c79 2874 7970 6573 2e66 726f 7a65 6e6d  ly(types.frozenm
+00005850: 756c 7469 7365 7428 5f6e 756d 7079 5f61  ultiset(_numpy_a
+00005860: 6c69 676e 2861 7267 302c 2061 7267 3129  lign(arg0, arg1)
+00005870: 2929 0a20 2020 2072 6574 7572 6e20 6172  )).    return ar
+00005880: 6730 0a0a 0a64 6566 2073 756d 2861 7267  g0...def sum(arg
+00005890: 2c20 6178 6973 3d4e 6f6e 6529 3a0a 2020  , axis=None):.  
+000058a0: 2020 2727 2753 756d 2061 7272 6179 2065    '''Sum array e
+000058b0: 6c65 6d65 6e74 7320 6f76 6572 2061 2067  lements over a g
+000058c0: 6976 656e 2061 7869 732e 2727 270a 0a20  iven axis.'''.. 
+000058d0: 2020 2069 6620 6178 6973 2069 7320 4e6f     if axis is No
+000058e0: 6e65 3a0a 2020 2020 2020 2020 7265 7475  ne:.        retu
+000058f0: 726e 2053 756d 2861 7267 290a 2020 2020  rn Sum(arg).    
+00005900: 6178 6573 203d 2028 6178 6973 2c29 2069  axes = (axis,) i
+00005910: 6620 6e75 6d65 7269 632e 6973 696e 7428  f numeric.isint(
+00005920: 6178 6973 2920 656c 7365 2061 7869 730a  axis) else axis.
+00005930: 2020 2020 7375 6d6d 6564 203d 2054 7261      summed = Tra
+00005940: 6e73 706f 7365 2e74 6f5f 656e 6428 6172  nspose.to_end(ar
+00005950: 672c 202a 6178 6573 290a 2020 2020 666f  g, *axes).    fo
+00005960: 7220 6920 696e 2072 616e 6765 286c 656e  r i in range(len
+00005970: 2861 7865 7329 293a 0a20 2020 2020 2020  (axes)):.       
+00005980: 2073 756d 6d65 6420 3d20 5375 6d28 7375   summed = Sum(su
+00005990: 6d6d 6564 290a 2020 2020 7265 7475 726e  mmed).    return
+000059a0: 2073 756d 6d65 640a 0a0a 6465 6620 7072   summed...def pr
+000059b0: 6f64 7563 7428 6172 672c 2061 7869 7329  oduct(arg, axis)
+000059c0: 3a0a 2020 2020 7265 7475 726e 2050 726f  :.    return Pro
+000059d0: 6475 6374 2854 7261 6e73 706f 7365 2e74  duct(Transpose.t
+000059e0: 6f5f 656e 6428 6172 672c 2061 7869 7329  o_end(arg, axis)
+000059f0: 290a 0a0a 6465 6620 706f 7765 7228 6172  )...def power(ar
+00005a00: 672c 206e 293a 0a20 2020 2061 7267 2c20  g, n):.    arg, 
+00005a10: 6e20 3d20 5f6e 756d 7079 5f61 6c69 676e  n = _numpy_align
+00005a20: 2861 7267 2c20 6e29 0a20 2020 2072 6574  (arg, n).    ret
+00005a30: 7572 6e20 506f 7765 7228 6172 672c 206e  urn Power(arg, n
+00005a40: 290a 0a0a 6465 6620 646f 7428 612c 2062  )...def dot(a, b
+00005a50: 2c20 6178 6573 293a 0a20 2020 2027 2727  , axes):.    '''
+00005a60: 0a20 2020 2043 6f6e 7472 6163 7420 6060  .    Contract ``
+00005a70: 6160 6020 616e 6420 6060 6260 6020 616c  a`` and ``b`` al
+00005a80: 6f6e 6720 6060 6178 6573 6060 2e0a 2020  ong ``axes``..  
+00005a90: 2020 2727 270a 0a20 2020 2072 6574 7572    '''..    retur
+00005aa0: 6e20 6d75 6c74 6970 6c79 2861 2c20 6229  n multiply(a, b)
+00005ab0: 2e73 756d 2861 7865 7329 0a0a 0a64 6566  .sum(axes)...def
+00005ac0: 2063 6f6e 6a75 6761 7465 2861 7267 293a   conjugate(arg):
+00005ad0: 0a20 2020 2061 7267 203d 2061 7361 7272  .    arg = asarr
+00005ae0: 6179 2861 7267 290a 2020 2020 6966 2061  ay(arg).    if a
+00005af0: 7267 2e64 7479 7065 203d 3d20 636f 6d70  rg.dtype == comp
+00005b00: 6c65 783a 0a20 2020 2020 2020 2072 6574  lex:.        ret
+00005b10: 7572 6e20 436f 6e6a 7567 6174 6528 6172  urn Conjugate(ar
+00005b20: 6729 0a20 2020 2065 6c73 653a 0a20 2020  g).    else:.   
+00005b30: 2020 2020 2072 6574 7572 6e20 6172 670a       return arg.
+00005b40: 0a0a 636f 6e6a 7567 6174 650a 0a0a 6465  ..conjugate...de
+00005b50: 6620 7265 616c 2861 7267 293a 0a20 2020  f real(arg):.   
+00005b60: 2061 7267 203d 2061 7361 7272 6179 2861   arg = asarray(a
+00005b70: 7267 290a 2020 2020 6966 2061 7267 2e64  rg).    if arg.d
+00005b80: 7479 7065 203d 3d20 636f 6d70 6c65 783a  type == complex:
+00005b90: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00005ba0: 5265 616c 2861 7267 290a 2020 2020 656c  Real(arg).    el
+00005bb0: 7365 3a0a 2020 2020 2020 2020 7265 7475  se:.        retu
+00005bc0: 726e 2061 7267 0a0a 0a64 6566 2069 6d61  rn arg...def ima
+00005bd0: 6728 6172 6729 3a0a 2020 2020 6172 6720  g(arg):.    arg 
+00005be0: 3d20 6173 6172 7261 7928 6172 6729 0a20  = asarray(arg). 
+00005bf0: 2020 2069 6620 6172 672e 6474 7970 6520     if arg.dtype 
+00005c00: 3d3d 2063 6f6d 706c 6578 3a0a 2020 2020  == complex:.    
+00005c10: 2020 2020 7265 7475 726e 2049 6d61 6728      return Imag(
+00005c20: 6172 6729 0a20 2020 2065 6c73 653a 0a20  arg).    else:. 
+00005c30: 2020 2020 2020 2072 6574 7572 6e20 7a65         return ze
+00005c40: 726f 735f 6c69 6b65 2861 7267 290a 0a0a  ros_like(arg)...
+00005c50: 6465 6620 7472 616e 7370 6f73 6528 6172  def transpose(ar
+00005c60: 672c 2074 7261 6e73 3d4e 6f6e 6529 3a0a  g, trans=None):.
+00005c70: 2020 2020 6172 6720 3d20 6173 6172 7261      arg = asarra
+00005c80: 7928 6172 6729 0a20 2020 2069 6620 7472  y(arg).    if tr
+00005c90: 616e 7320 6973 204e 6f6e 653a 0a20 2020  ans is None:.   
+00005ca0: 2020 2020 206e 6f72 6d74 7261 6e73 203d       normtrans =
+00005cb0: 2074 7570 6c65 2872 616e 6765 2861 7267   tuple(range(arg
+00005cc0: 2e6e 6469 6d2d 312c 202d 312c 202d 3129  .ndim-1, -1, -1)
+00005cd0: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
+00005ce0: 2020 2020 6e6f 726d 7472 616e 7320 3d20      normtrans = 
+00005cf0: 7475 706c 6528 6e75 6d65 7269 632e 6e6f  tuple(numeric.no
+00005d00: 726d 6469 6d28 6172 672e 6e64 696d 2c20  rmdim(arg.ndim, 
+00005d10: 7368 292e 5f5f 696e 6465 785f 5f28 2920  sh).__index__() 
+00005d20: 666f 7220 7368 2069 6e20 7472 616e 7329  for sh in trans)
+00005d30: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+00005d40: 736f 7274 6564 286e 6f72 6d74 7261 6e73  sorted(normtrans
+00005d50: 2920 3d3d 206c 6973 7428 7261 6e67 6528  ) == list(range(
+00005d60: 6172 672e 6e64 696d 2929 0a20 2020 2072  arg.ndim)).    r
+00005d70: 6574 7572 6e20 5472 616e 7370 6f73 6528  eturn Transpose(
+00005d80: 6172 672c 206e 6f72 6d74 7261 6e73 290a  arg, normtrans).
+00005d90: 0a0a 6465 6620 7377 6170 6178 6573 2861  ..def swapaxes(a
+00005da0: 7267 2c20 6178 6973 312c 2061 7869 7332  rg, axis1, axis2
+00005db0: 293a 0a20 2020 2061 7267 203d 2061 7361  ):.    arg = asa
+00005dc0: 7272 6179 2861 7267 290a 2020 2020 7472  rray(arg).    tr
+00005dd0: 616e 7320 3d20 6e75 6d70 792e 6172 616e  ans = numpy.aran
+00005de0: 6765 2861 7267 2e6e 6469 6d29 0a20 2020  ge(arg.ndim).   
+00005df0: 2074 7261 6e73 5b61 7869 7331 5d2c 2074   trans[axis1], t
+00005e00: 7261 6e73 5b61 7869 7332 5d20 3d20 7472  rans[axis2] = tr
+00005e10: 616e 735b 6178 6973 325d 2c20 7472 616e  ans[axis2], tran
+00005e20: 735b 6178 6973 315d 0a20 2020 2072 6574  s[axis1].    ret
+00005e30: 7572 6e20 7472 616e 7370 6f73 6528 6172  urn transpose(ar
+00005e40: 672c 2074 7261 6e73 290a 0a0a 6465 6620  g, trans)...def 
+00005e50: 616c 6967 6e28 6172 672c 2077 6865 7265  align(arg, where
+00005e60: 2c20 7368 6170 6529 3a0a 2020 2020 2727  , shape):.    ''
+00005e70: 2741 6c69 676e 2061 7272 6179 2074 6f20  'Align array to 
+00005e80: 7461 7267 6574 2073 6861 7065 2e0a 0a20  target shape... 
+00005e90: 2020 2054 6865 2061 6c69 676e 206f 7065     The align ope
+00005ea0: 7261 7469 6f6e 2063 616e 2062 6520 636f  ration can be co
+00005eb0: 6e73 6964 6572 6564 2074 6865 206f 7070  nsidered the opp
+00005ec0: 6f73 6974 6520 6f66 2074 7261 6e73 706f  osite of transpo
+00005ed0: 7365 3a20 696e 7374 6561 6420 6f66 0a20  se: instead of. 
+00005ee0: 2020 2073 7065 6369 6679 696e 6720 666f     specifying fo
+00005ef0: 7220 6561 6368 2061 7869 7320 6f66 2074  r each axis of t
+00005f00: 6865 2072 6574 7572 6e20 7661 6c75 6520  he return value 
+00005f10: 7468 6520 6f72 6967 696e 616c 2070 6f73  the original pos
+00005f20: 6974 696f 6e20 696e 2074 6865 0a20 2020  ition in the.   
+00005f30: 2061 7267 756d 656e 742c 2061 6c69 676e   argument, align
+00005f40: 2073 7065 6369 6669 6573 2066 6f72 2065   specifies for e
+00005f50: 6163 6820 6178 6973 206f 6620 7468 6520  ach axis of the 
+00005f60: 6172 6775 6d65 6e74 2074 6865 206e 6577  argument the new
+00005f70: 2070 6f73 6974 696f 6e20 696e 0a20 2020   position in.   
+00005f80: 2074 6865 2072 6574 7572 6e20 7661 6c75   the return valu
+00005f90: 652e 2049 6e20 6164 6469 7469 6f6e 2c20  e. In addition, 
+00005fa0: 7468 6520 7265 7475 726e 2076 616c 7565  the return value
+00005fb0: 206d 6179 2062 6520 6f66 2068 6967 6865   may be of highe
+00005fc0: 7220 6469 6d65 6e73 696f 6e2c 0a20 2020  r dimension,.   
+00005fd0: 2077 6974 6820 6e65 7720 6178 6573 2062   with new axes b
+00005fe0: 6569 6e67 2069 6e73 6572 7465 6420 6163  eing inserted ac
+00005ff0: 636f 7264 696e 6720 746f 2074 6865 2060  cording to the `
+00006000: 6073 6861 7065 6060 2061 7267 756d 656e  `shape`` argumen
+00006010: 742e 0a0a 2020 2020 4172 6773 0a20 2020  t...    Args.   
+00006020: 202d 2d2d 2d0a 2020 2020 6172 6720 3a20   ----.    arg : 
+00006030: 3a63 6c61 7373 3a60 4172 7261 7960 0a20  :class:`Array`. 
+00006040: 2020 2020 2020 204f 7269 6769 6e61 6c20         Original 
+00006050: 6172 7261 792e 0a20 2020 2077 6865 7265  array..    where
+00006060: 203a 203a 636c 6173 733a 6074 7570 6c65   : :class:`tuple
+00006070: 6020 6f66 2069 6e74 6567 6572 730a 2020  ` of integers.  
+00006080: 2020 2020 2020 4e65 7720 6178 6973 2070        New axis p
+00006090: 6f73 6974 696f 6e73 2e0a 2020 2020 7368  ositions..    sh
+000060a0: 6170 6520 3a20 3a63 6c61 7373 3a60 7475  ape : :class:`tu
+000060b0: 706c 6560 0a20 2020 2020 2020 2053 6861  ple`.        Sha
+000060c0: 7065 206f 6620 7468 6520 616c 6967 6e65  pe of the aligne
+000060d0: 6420 6172 7261 792e 0a0a 2020 2020 5265  d array...    Re
+000060e0: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
+000060f0: 2d0a 2020 2020 3a63 6c61 7373 3a60 4172  -.    :class:`Ar
+00006100: 7261 7960 0a20 2020 2020 2020 2054 6865  ray`.        The
+00006110: 2061 6c69 676e 6564 2061 7272 6179 2e0a   aligned array..
+00006120: 2020 2020 2727 270a 0a20 2020 2077 6865      '''..    whe
+00006130: 7265 203d 206c 6973 7428 7768 6572 6529  re = list(where)
+00006140: 0a20 2020 2066 6f72 2069 2c20 6c65 6e67  .    for i, leng
+00006150: 7468 2069 6e20 656e 756d 6572 6174 6528  th in enumerate(
+00006160: 7368 6170 6529 3a0a 2020 2020 2020 2020  shape):.        
+00006170: 6966 2069 206e 6f74 2069 6e20 7768 6572  if i not in wher
+00006180: 653a 0a20 2020 2020 2020 2020 2020 2061  e:.            a
+00006190: 7267 203d 2049 6e73 6572 7441 7869 7328  rg = InsertAxis(
+000061a0: 6172 672c 206c 656e 6774 6829 0a20 2020  arg, length).   
+000061b0: 2020 2020 2020 2020 2077 6865 7265 2e61           where.a
+000061c0: 7070 656e 6428 6929 0a20 2020 2069 6620  ppend(i).    if 
+000061d0: 7768 6572 6520 213d 206c 6973 7428 7261  where != list(ra
+000061e0: 6e67 6528 6c65 6e28 7368 6170 6529 2929  nge(len(shape)))
+000061f0: 3a0a 2020 2020 2020 2020 6172 6720 3d20  :.        arg = 
+00006200: 5472 616e 7370 6f73 652e 696e 7628 6172  Transpose.inv(ar
+00006210: 672c 2077 6865 7265 290a 2020 2020 6173  g, where).    as
+00006220: 7365 7274 2065 7175 616c 7368 6170 6528  sert equalshape(
+00006230: 6172 672e 7368 6170 652c 2073 6861 7065  arg.shape, shape
+00006240: 292c 2066 2761 7267 2e73 6861 7065 3d7b  ), f'arg.shape={
+00006250: 6172 672e 7368 6170 6521 727d 2c20 7368  arg.shape!r}, sh
+00006260: 6170 653d 7b73 6861 7065 2172 7d27 0a20  ape={shape!r}'. 
+00006270: 2020 2072 6574 7572 6e20 6172 670a 0a0a     return arg...
+00006280: 6465 6620 756e 616c 6967 6e28 2a61 7267  def unalign(*arg
+00006290: 732c 206e 6178 6573 3a20 696e 7420 3d20  s, naxes: int = 
+000062a0: 4e6f 6e65 293a 0a20 2020 2027 2727 5265  None):.    '''Re
+000062b0: 6d6f 7665 2028 6a6f 696e 7429 2069 6e73  move (joint) ins
+000062c0: 6572 7465 6420 6178 6573 2e0a 0a20 2020  erted axes...   
+000062d0: 2047 6976 656e 206f 6e65 206f 7220 6d6f   Given one or mo
+000062e0: 7265 2061 7272 6179 2061 7267 756d 656e  re array argumen
+000062f0: 7473 2c20 7265 7475 726e 2074 6865 2073  ts, return the s
+00006300: 686f 7274 6573 7420 636f 6d6d 6f6e 2061  hortest common a
+00006310: 7869 7320 7665 6374 6f72 0a20 2020 2061  xis vector.    a
+00006320: 6c6f 6e67 2077 6974 6820 6675 6e63 7469  long with functi
+00006330: 6f6e 2061 7267 756d 656e 7473 2073 7563  on arguments suc
+00006340: 6820 7468 6174 2074 6865 206f 7269 6769  h that the origi
+00006350: 6e61 6c20 6172 7261 7973 2063 616e 2062  nal arrays can b
+00006360: 650a 2020 2020 7265 636f 7665 7265 6420  e.    recovered 
+00006370: 6279 203a 6675 6e63 3a60 616c 6967 6e60  by :func:`align`
+00006380: 2e20 4178 6573 2062 6579 6f6e 6420 7468  . Axes beyond th
+00006390: 6520 6669 7273 7420 6060 6e61 7865 7360  e first ``naxes`
+000063a0: 6020 6172 6520 6e6f 740a 2020 2020 636f  ` are not.    co
+000063b0: 6e73 6964 6572 6564 2066 6f72 2072 656d  nsidered for rem
+000063c0: 6f76 616c 2c20 6b65 6570 2074 6865 6972  oval, keep their
+000063d0: 2070 6f73 6974 696f 6e20 2861 7320 7365   position (as se
+000063e0: 656e 2066 726f 6d20 7468 6520 7269 6768  en from the righ
+000063f0: 7429 2c20 616e 640a 2020 2020 6172 6520  t), and.    are 
+00006400: 6e6f 7420 7061 7274 206f 6620 7468 6520  not part of the 
+00006410: 636f 6d6d 6f6e 2061 7869 7320 7665 6374  common axis vect
+00006420: 6f72 2e20 5468 6f73 6520 6178 6573 2073  or. Those axes s
+00006430: 686f 756c 6420 6265 2061 6464 6564 2074  hould be added t
+00006440: 6f20 7468 650a 2020 2020 6178 6973 2076  o the.    axis v
+00006450: 6563 746f 7220 6265 666f 7265 2063 616c  ector before cal
+00006460: 6c69 6e67 203a 6675 6e63 3a60 616c 6967  ling :func:`alig
+00006470: 6e60 2e0a 0a20 2020 2049 6620 6060 6e61  n`...    If ``na
+00006480: 7865 7360 6020 6973 2060 604e 6f6e 6560  xes`` is ``None`
+00006490: 6020 2874 6865 2064 6566 6175 6c74 292c  ` (the default),
+000064a0: 2061 6c6c 2061 7267 756d 656e 7473 206d   all arguments m
+000064b0: 7573 7420 6861 7665 2074 6865 2073 616d  ust have the sam
+000064c0: 650a 2020 2020 6e75 6d62 6572 206f 6620  e.    number of 
+000064d0: 6178 6573 2061 6e64 2060 606e 6178 6573  axes and ``naxes
+000064e0: 6060 2069 7320 7365 7420 746f 2074 6869  `` is set to thi
+000064f0: 7320 6e75 6d62 6572 2e0a 2020 2020 2727  s number..    ''
+00006500: 270a 0a20 2020 2061 7373 6572 7420 6172  '..    assert ar
+00006510: 6773 0a20 2020 2069 6620 6c65 6e28 6172  gs.    if len(ar
+00006520: 6773 2920 3d3d 2031 2061 6e64 206e 6178  gs) == 1 and nax
+00006530: 6573 2069 7320 4e6f 6e65 3a0a 2020 2020  es is None:.    
+00006540: 2020 2020 7265 7475 726e 2061 7267 735b      return args[
+00006550: 305d 2e5f 756e 616c 6967 6e65 640a 2020  0]._unaligned.  
+00006560: 2020 6966 206e 6178 6573 2069 7320 4e6f    if naxes is No
+00006570: 6e65 3a0a 2020 2020 2020 2020 6966 2061  ne:.        if a
+00006580: 6e79 2861 7267 2e6e 6469 6d20 213d 2061  ny(arg.ndim != a
+00006590: 7267 735b 305d 2e6e 6469 6d20 666f 7220  rgs[0].ndim for 
+000065a0: 6172 6720 696e 2061 7267 735b 313a 5d29  arg in args[1:])
+000065b0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+000065c0: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
+000065d0: 7661 7279 696e 6720 6469 6d65 6e73 696f  varying dimensio
+000065e0: 6e73 2069 6e20 756e 616c 6967 6e27 290a  ns in unalign').
+000065f0: 2020 2020 2020 2020 6e61 7865 7320 3d20          naxes = 
+00006600: 6172 6773 5b30 5d2e 6e64 696d 0a20 2020  args[0].ndim.   
+00006610: 2065 6c69 6620 616e 7928 6172 672e 6e64   elif any(arg.nd
+00006620: 696d 203c 206e 6178 6573 2066 6f72 2061  im < naxes for a
+00006630: 7267 2069 6e20 6172 6773 293a 0a20 2020  rg in args):.   
+00006640: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00006650: 4572 726f 7228 276f 6e65 206f 7220 6d6f  Error('one or mo
+00006660: 7265 2061 7267 756d 656e 7473 2068 6176  re arguments hav
+00006670: 6520 6665 7765 7220 6178 6573 2074 6861  e fewer axes tha
+00006680: 6e20 6578 7065 6374 6564 2729 0a20 2020  n expected').   
+00006690: 206e 6f6e 696e 7320 3d20 6675 6e63 746f   nonins = functo
+000066a0: 6f6c 732e 7265 6475 6365 286f 7065 7261  ols.reduce(opera
+000066b0: 746f 722e 6f72 5f2c 205b 7365 7428 6172  tor.or_, [set(ar
+000066c0: 672e 5f75 6e61 6c69 676e 6564 5b31 5d29  g._unaligned[1])
+000066d0: 2066 6f72 2061 7267 2069 6e20 6172 6773   for arg in args
+000066e0: 5d29 2026 2073 6574 2872 616e 6765 286e  ]) & set(range(n
+000066f0: 6178 6573 2929 0a20 2020 2069 6620 6c65  axes)).    if le
+00006700: 6e28 6e6f 6e69 6e73 2920 3d3d 206e 6178  n(nonins) == nax
+00006710: 6573 3a0a 2020 2020 2020 2020 7265 7475  es:.        retu
+00006720: 726e 2028 2a61 7267 732c 2074 7570 6c65  rn (*args, tuple
+00006730: 2872 616e 6765 286e 6178 6573 2929 290a  (range(naxes))).
+00006740: 2020 2020 7265 7420 3d20 5b5d 0a20 2020      ret = [].   
+00006750: 2066 6f72 2061 7267 2069 6e20 6172 6773   for arg in args
+00006760: 3a0a 2020 2020 2020 2020 756e 616c 6967  :.        unalig
+00006770: 6e65 642c 2077 6865 7265 203d 2061 7267  ned, where = arg
+00006780: 2e5f 756e 616c 6967 6e65 640a 2020 2020  ._unaligned.    
+00006790: 2020 2020 6b65 6570 203d 2074 7570 6c65      keep = tuple
+000067a0: 2872 616e 6765 286e 6178 6573 2c20 6172  (range(naxes, ar
+000067b0: 672e 6e64 696d 2929 0a20 2020 2020 2020  g.ndim)).       
+000067c0: 2066 6f72 2069 2069 6e20 736f 7274 6564   for i in sorted
+000067d0: 2828 6e6f 6e69 6e73 207c 2073 6574 286b  ((nonins | set(k
+000067e0: 6565 7029 2920 2d20 7365 7428 7768 6572  eep)) - set(wher
+000067f0: 6529 293a 0a20 2020 2020 2020 2020 2020  e)):.           
+00006800: 2075 6e61 6c69 676e 6564 203d 2049 6e73   unaligned = Ins
+00006810: 6572 7441 7869 7328 756e 616c 6967 6e65  ertAxis(unaligne
+00006820: 642c 2061 7267 2e73 6861 7065 5b69 5d29  d, arg.shape[i])
+00006830: 0a20 2020 2020 2020 2020 2020 2077 6865  .            whe
+00006840: 7265 202b 3d20 692c 0a20 2020 2020 2020  re += i,.       
+00006850: 2069 6620 6e6f 7420 7265 743a 2020 2320   if not ret:  # 
+00006860: 6669 7273 7420 6172 6775 6d65 6e74 0a20  first argument. 
+00006870: 2020 2020 2020 2020 2020 2063 6f6d 6d6f             commo
+00006880: 6e77 6865 7265 203d 2074 7570 6c65 2869  nwhere = tuple(i
+00006890: 2066 6f72 2069 2069 6e20 7768 6572 6520   for i in where 
+000068a0: 6966 2069 203c 206e 6178 6573 290a 2020  if i < naxes).  
+000068b0: 2020 2020 2020 6966 2077 6865 7265 2021        if where !
+000068c0: 3d20 636f 6d6d 6f6e 7768 6572 6520 2b20  = commonwhere + 
+000068d0: 6b65 6570 3a0a 2020 2020 2020 2020 2020  keep:.          
+000068e0: 2020 756e 616c 6967 6e65 6420 3d20 5472    unaligned = Tr
+000068f0: 616e 7370 6f73 6528 756e 616c 6967 6e65  anspose(unaligne
+00006900: 642c 2074 7570 6c65 2877 6865 7265 2e69  d, tuple(where.i
+00006910: 6e64 6578 286e 2920 666f 7220 6e20 696e  ndex(n) for n in
+00006920: 2063 6f6d 6d6f 6e77 6865 7265 202b 206b   commonwhere + k
+00006930: 6565 7029 290a 2020 2020 2020 2020 7265  eep)).        re
+00006940: 742e 6170 7065 6e64 2875 6e61 6c69 676e  t.append(unalign
+00006950: 6564 290a 2020 2020 7265 7475 726e 2028  ed).    return (
+00006960: 2a72 6574 2c20 636f 6d6d 6f6e 7768 6572  *ret, commonwher
+00006970: 6529 0a0a 2320 4152 5241 5953 0a0a 0a5f  e)..# ARRAYS..._
+00006980: 4172 7261 794d 6574 6120 3d20 7479 7065  ArrayMeta = type
+00006990: 2845 7661 6c75 6162 6c65 290a 0a69 6620  (Evaluable)..if 
+000069a0: 6465 6275 675f 666c 6167 732e 7370 6172  debug_flags.spar
+000069b0: 7365 3a0a 2020 2020 6465 6620 5f63 6875  se:.    def _chu
+000069c0: 6e6b 6564 5f61 7373 7061 7273 655f 6368  nked_assparse_ch
+000069d0: 6563 6b65 7228 6f72 6967 293a 0a20 2020  ecker(orig):.   
+000069e0: 2020 2020 2061 7373 6572 7420 6973 696e       assert isin
+000069f0: 7374 616e 6365 286f 7269 672c 2063 6163  stance(orig, cac
+00006a00: 6865 645f 7072 6f70 6572 7479 290a 0a20  hed_property).. 
+00006a10: 2020 2020 2020 2040 6361 6368 6564 5f70         @cached_p
+00006a20: 726f 7065 7274 790a 2020 2020 2020 2020  roperty.        
+00006a30: 6465 6620 5f61 7373 7061 7273 6528 7365  def _assparse(se
+00006a40: 6c66 293a 0a20 2020 2020 2020 2020 2020  lf):.           
+00006a50: 2063 6875 6e6b 7320 3d20 6f72 6967 2e66   chunks = orig.f
+00006a60: 756e 6328 7365 6c66 290a 2020 2020 2020  unc(self).      
+00006a70: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+00006a80: 6e73 7461 6e63 6528 6368 756e 6b73 2c20  nstance(chunks, 
+00006a90: 7475 706c 6529 0a20 2020 2020 2020 2020  tuple).         
+00006aa0: 2020 2061 7373 6572 7420 616c 6c28 6973     assert all(is
+00006ab0: 696e 7374 616e 6365 2863 6875 6e6b 2c20  instance(chunk, 
+00006ac0: 7475 706c 6529 2066 6f72 2063 6875 6e6b  tuple) for chunk
+00006ad0: 2069 6e20 6368 756e 6b73 290a 2020 2020   in chunks).    
+00006ae0: 2020 2020 2020 2020 6173 7365 7274 2061          assert a
+00006af0: 6c6c 2861 6c6c 2869 7369 6e73 7461 6e63  ll(all(isinstanc
+00006b00: 6528 6974 656d 2c20 4172 7261 7929 2066  e(item, Array) f
+00006b10: 6f72 2069 7465 6d20 696e 2063 6875 6e6b  or item in chunk
+00006b20: 2920 666f 7220 6368 756e 6b20 696e 2063  ) for chunk in c
+00006b30: 6875 6e6b 7329 0a20 2020 2020 2020 2020  hunks).         
+00006b40: 2020 2069 6620 7365 6c66 2e6e 6469 6d3a     if self.ndim:
+00006b50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006b60: 2066 6f72 202a 696e 6469 6365 732c 2076   for *indices, v
+00006b70: 616c 7565 7320 696e 2063 6875 6e6b 733a  alues in chunks:
+00006b80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006b90: 2020 2020 2061 7373 6572 7420 6c65 6e28       assert len(
+00006ba0: 696e 6469 6365 7329 203d 3d20 7365 6c66  indices) == self
+00006bb0: 2e6e 6469 6d0a 2020 2020 2020 2020 2020  .ndim.          
+00006bc0: 2020 2020 2020 2020 2020 6173 7365 7274            assert
+00006bd0: 2061 6c6c 2869 6478 2e64 7479 7065 203d   all(idx.dtype =
+00006be0: 3d20 696e 7420 666f 7220 6964 7820 696e  = int for idx in
+00006bf0: 2069 6e64 6963 6573 290a 2020 2020 2020   indices).      
+00006c00: 2020 2020 2020 2020 2020 2020 2020 6173                as
+00006c10: 7365 7274 2061 6c6c 2865 7175 616c 7368  sert all(equalsh
+00006c20: 6170 6528 6964 782e 7368 6170 652c 2076  ape(idx.shape, v
+00006c30: 616c 7565 732e 7368 6170 6529 2066 6f72  alues.shape) for
+00006c40: 2069 6478 2069 6e20 696e 6469 6365 7329   idx in indices)
+00006c50: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
+00006c60: 6620 6368 756e 6b73 3a0a 2020 2020 2020  f chunks:.      
+00006c70: 2020 2020 2020 2020 2020 6173 7365 7274            assert
+00006c80: 206c 656e 2863 6875 6e6b 7329 203d 3d20   len(chunks) == 
+00006c90: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
+00006ca0: 2020 6368 756e 6b2c 203d 2063 6875 6e6b    chunk, = chunk
+00006cb0: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+00006cc0: 2020 6173 7365 7274 206c 656e 2863 6875    assert len(chu
+00006cd0: 6e6b 2920 3d3d 2031 0a20 2020 2020 2020  nk) == 1.       
+00006ce0: 2020 2020 2020 2020 2076 616c 7565 732c           values,
+00006cf0: 203d 2063 6875 6e6b 0a20 2020 2020 2020   = chunk.       
+00006d00: 2020 2020 2020 2020 2061 7373 6572 7420           assert 
+00006d10: 7661 6c75 6573 2e73 6861 7065 203d 3d20  values.shape == 
+00006d20: 2829 0a20 2020 2020 2020 2020 2020 2072  ().            r
+00006d30: 6574 7572 6e20 6368 756e 6b73 0a20 2020  eturn chunks.   
+00006d40: 2020 2020 2072 6574 7572 6e20 5f61 7373       return _ass
+00006d50: 7061 7273 650a 0a20 2020 2063 6c61 7373  parse..    class
+00006d60: 205f 4172 7261 794d 6574 6128 5f41 7272   _ArrayMeta(_Arr
+00006d70: 6179 4d65 7461 293a 0a20 2020 2020 2020  ayMeta):.       
+00006d80: 2064 6566 205f 5f6e 6577 5f5f 286d 636c   def __new__(mcl
+00006d90: 732c 206e 616d 652c 2062 6173 6573 2c20  s, name, bases, 
+00006da0: 6e61 6d65 7370 6163 6529 3a0a 2020 2020  namespace):.    
+00006db0: 2020 2020 2020 2020 6966 2027 5f61 7373          if '_ass
+00006dc0: 7061 7273 6527 2069 6e20 6e61 6d65 7370  parse' in namesp
+00006dd0: 6163 653a 0a20 2020 2020 2020 2020 2020  ace:.           
+00006de0: 2020 2020 206e 616d 6573 7061 6365 5b27       namespace['
+00006df0: 5f61 7373 7061 7273 6527 5d20 3d20 5f63  _assparse'] = _c
+00006e00: 6875 6e6b 6564 5f61 7373 7061 7273 655f  hunked_assparse_
+00006e10: 6368 6563 6b65 7228 6e61 6d65 7370 6163  checker(namespac
+00006e20: 655b 275f 6173 7370 6172 7365 275d 290a  e['_assparse']).
+00006e30: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00006e40: 726e 2073 7570 6572 2829 2e5f 5f6e 6577  rn super().__new
+00006e50: 5f5f 286d 636c 732c 206e 616d 652c 2062  __(mcls, name, b
+00006e60: 6173 6573 2c20 6e61 6d65 7370 6163 6529  ases, namespace)
+00006e70: 0a0a 6966 2064 6562 7567 5f66 6c61 6773  ..if debug_flags
+00006e80: 2e65 7661 6c66 3a0a 2020 2020 636c 6173  .evalf:.    clas
+00006e90: 7320 5f65 7661 6c66 5f63 6865 636b 6572  s _evalf_checker
+00006ea0: 3a0a 2020 2020 2020 2020 6465 6620 5f5f  :.        def __
+00006eb0: 696e 6974 5f5f 2873 656c 662c 206f 7269  init__(self, ori
+00006ec0: 6729 3a0a 2020 2020 2020 2020 2020 2020  g):.            
+00006ed0: 7365 6c66 2e6f 7269 6720 3d20 6f72 6967  self.orig = orig
+00006ee0: 0a0a 2020 2020 2020 2020 6465 6620 5f5f  ..        def __
+00006ef0: 7365 745f 6e61 6d65 5f5f 2873 656c 662c  set_name__(self,
+00006f00: 206f 776e 6572 2c20 6e61 6d65 293a 0a20   owner, name):. 
+00006f10: 2020 2020 2020 2020 2020 2069 6620 6861             if ha
+00006f20: 7361 7474 7228 7365 6c66 2e6f 7269 672c  sattr(self.orig,
+00006f30: 2027 5f5f 7365 745f 6e61 6d65 5f5f 2729   '__set_name__')
+00006f40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00006f50: 2020 7365 6c66 2e6f 7269 672e 5f5f 7365    self.orig.__se
+00006f60: 745f 6e61 6d65 5f5f 286f 776e 6572 2c20  t_name__(owner, 
+00006f70: 6e61 6d65 290a 0a20 2020 2020 2020 2064  name)..        d
+00006f80: 6566 205f 5f67 6574 5f5f 2873 656c 662c  ef __get__(self,
+00006f90: 2069 6e73 7461 6e63 652c 206f 776e 6572   instance, owner
+00006fa0: 293a 0a20 2020 2020 2020 2020 2020 2065  ):.            e
+00006fb0: 7661 6c66 203d 2073 656c 662e 6f72 6967  valf = self.orig
+00006fc0: 2e5f 5f67 6574 5f5f 2869 6e73 7461 6e63  .__get__(instanc
+00006fd0: 652c 206f 776e 6572 290a 0a20 2020 2020  e, owner)..     
+00006fe0: 2020 2020 2020 2040 6675 6e63 746f 6f6c         @functool
+00006ff0: 732e 7772 6170 7328 6576 616c 6629 0a20  s.wraps(evalf). 
+00007000: 2020 2020 2020 2020 2020 2064 6566 2065             def e
+00007010: 7661 6c66 5f77 6974 685f 6368 6563 6b28  valf_with_check(
+00007020: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
+00007030: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00007040: 2020 7265 7320 3d20 6576 616c 6628 2a61    res = evalf(*a
+00007050: 7267 732c 202a 2a6b 7761 7267 7329 0a20  rgs, **kwargs). 
+00007060: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+00007070: 7373 6572 7420 6e6f 7420 6861 7361 7474  ssert not hasatt
+00007080: 7228 696e 7374 616e 6365 2c20 2764 7479  r(instance, 'dty
+00007090: 7065 2729 206f 7220 6173 6474 7970 6528  pe') or asdtype(
+000070a0: 7265 732e 6474 7970 6529 203d 3d20 696e  res.dtype) == in
+000070b0: 7374 616e 6365 2e64 7479 7065 2c20 2828  stance.dtype, ((
+000070c0: 696e 7374 616e 6365 2e64 7479 7065 2c20  instance.dtype, 
+000070d0: 7265 732e 6474 7970 6529 2c20 696e 7374  res.dtype), inst
+000070e0: 616e 6365 2c20 7265 7329 0a20 2020 2020  ance, res).     
+000070f0: 2020 2020 2020 2020 2020 2061 7373 6572             asser
+00007100: 7420 6e6f 7420 6861 7361 7474 7228 696e  t not hasattr(in
+00007110: 7374 616e 6365 2c20 276e 6469 6d27 2920  stance, 'ndim') 
+00007120: 6f72 2072 6573 2e6e 6469 6d20 3d3d 2069  or res.ndim == i
+00007130: 6e73 7461 6e63 652e 6e64 696d 0a20 2020  nstance.ndim.   
+00007140: 2020 2020 2020 2020 2020 2020 2061 7373               ass
+00007150: 6572 7420 6e6f 7420 6861 7361 7474 7228  ert not hasattr(
+00007160: 696e 7374 616e 6365 2c20 2773 6861 7065  instance, 'shape
+00007170: 2729 206f 7220 616c 6c28 6d20 3d3d 206e  ') or all(m == n
+00007180: 2066 6f72 206d 2c20 6e20 696e 207a 6970   for m, n in zip
+00007190: 2872 6573 2e73 6861 7065 2c20 696e 7374  (res.shape, inst
+000071a0: 616e 6365 2e73 6861 7065 2920 6966 2069  ance.shape) if i
+000071b0: 7369 6e73 7461 6e63 6528 6e2c 2069 6e74  sinstance(n, int
+000071c0: 2929 2c20 2773 6861 7065 206d 6973 6d61  )), 'shape misma
+000071d0: 7463 6827 0a20 2020 2020 2020 2020 2020  tch'.           
+000071e0: 2020 2020 2072 6574 7572 6e20 7265 730a       return res.
+000071f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00007200: 726e 2065 7661 6c66 5f77 6974 685f 6368  rn evalf_with_ch
+00007210: 6563 6b0a 0a20 2020 2063 6c61 7373 205f  eck..    class _
+00007220: 4172 7261 794d 6574 6128 5f41 7272 6179  ArrayMeta(_Array
+00007230: 4d65 7461 293a 0a20 2020 2020 2020 2064  Meta):.        d
+00007240: 6566 205f 5f6e 6577 5f5f 286d 636c 732c  ef __new__(mcls,
+00007250: 206e 616d 652c 2062 6173 6573 2c20 6e61   name, bases, na
+00007260: 6d65 7370 6163 6529 3a0a 2020 2020 2020  mespace):.      
+00007270: 2020 2020 2020 6966 2027 6576 616c 6627        if 'evalf'
+00007280: 2069 6e20 6e61 6d65 7370 6163 653a 0a20   in namespace:. 
+00007290: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+000072a0: 616d 6573 7061 6365 5b27 6576 616c 6627  amespace['evalf'
+000072b0: 5d20 3d20 5f65 7661 6c66 5f63 6865 636b  ] = _evalf_check
+000072c0: 6572 286e 616d 6573 7061 6365 5b27 6576  er(namespace['ev
+000072d0: 616c 6627 5d29 0a20 2020 2020 2020 2020  alf']).         
+000072e0: 2020 2072 6574 7572 6e20 7375 7065 7228     return super(
+000072f0: 292e 5f5f 6e65 775f 5f28 6d63 6c73 2c20  ).__new__(mcls, 
+00007300: 6e61 6d65 2c20 6261 7365 732c 206e 616d  name, bases, nam
+00007310: 6573 7061 6365 290a 0a0a 636c 6173 7320  espace)...class 
+00007320: 4173 4576 616c 7561 626c 6541 7272 6179  AsEvaluableArray
+00007330: 2850 726f 746f 636f 6c29 3a0a 2020 2020  (Protocol):.    
+00007340: 2750 726f 746f 636f 6c20 666f 7220 636f  'Protocol for co
+00007350: 6e76 6572 7369 6f6e 2069 6e74 6f20 616e  nversion into an
+00007360: 203a 636c 6173 733a 6041 7272 6179 602e   :class:`Array`.
+00007370: 270a 0a20 2020 2040 7072 6f70 6572 7479  '..    @property
+00007380: 0a20 2020 2064 6566 2061 735f 6576 616c  .    def as_eval
+00007390: 7561 626c 655f 6172 7261 7928 7365 6c66  uable_array(self
+000073a0: 2920 2d3e 2027 4172 7261 7927 3a0a 2020  ) -> 'Array':.  
+000073b0: 2020 2020 2020 274c 6f77 6572 2074 6869        'Lower thi
+000073c0: 7320 6f62 6a65 6374 2074 6f20 6120 3a63  s object to a :c
+000073d0: 6c61 7373 3a60 6e75 7469 6c73 2e65 7661  lass:`nutils.eva
+000073e0: 6c75 6162 6c65 2e41 7272 6179 602e 270a  luable.Array`.'.
+000073f0: 0a0a 636c 6173 7320 4172 7261 7928 4576  ..class Array(Ev
+00007400: 616c 7561 626c 652c 206d 6574 6163 6c61  aluable, metacla
+00007410: 7373 3d5f 4172 7261 794d 6574 6129 3a0a  ss=_ArrayMeta):.
+00007420: 2020 2020 2727 270a 2020 2020 4261 7365      '''.    Base
+00007430: 2063 6c61 7373 2066 6f72 2061 7272 6179   class for array
+00007440: 2076 616c 7565 6420 6675 6e63 7469 6f6e   valued function
+00007450: 732e 0a0a 2020 2020 4174 7472 6962 7574  s...    Attribut
+00007460: 6573 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  es.    ---------
+00007470: 2d0a 2020 2020 7368 6170 6520 3a20 3a63  -.    shape : :c
+00007480: 6c61 7373 3a60 7475 706c 6560 206f 6620  lass:`tuple` of 
+00007490: 3a63 6c61 7373 3a60 696e 7460 5c5c 730a  :class:`int`\\s.
+000074a0: 2020 2020 2020 2020 5468 6520 7368 6170          The shap
+000074b0: 6520 6f66 2074 6869 7320 6172 7261 7920  e of this array 
+000074c0: 6675 6e63 7469 6f6e 2e0a 2020 2020 6e64  function..    nd
+000074d0: 696d 203a 203a 636c 6173 733a 6069 6e74  im : :class:`int
+000074e0: 600a 2020 2020 2020 2020 5468 6520 6e75  `.        The nu
+000074f0: 6d62 6572 206f 6620 6469 6d65 6e73 696f  mber of dimensio
+00007500: 6e73 206f 6620 7468 6973 2061 7272 6179  ns of this array
+00007510: 2061 7272 6179 2066 756e 6374 696f 6e2e   array function.
+00007520: 2020 4571 7561 6c20 746f 0a20 2020 2020    Equal to.     
+00007530: 2020 2060 606c 656e 2873 6861 7065 2960     ``len(shape)`
+00007540: 602e 0a20 2020 2064 7479 7065 203a 203a  `..    dtype : :
+00007550: 636c 6173 733a 6069 6e74 602c 203a 636c  class:`int`, :cl
+00007560: 6173 733a 6066 6c6f 6174 600a 2020 2020  ass:`float`.    
+00007570: 2020 2020 5468 6520 6474 7970 6520 6f66      The dtype of
+00007580: 2074 6865 2061 7272 6179 2065 6c65 6d65   the array eleme
+00007590: 6e74 732e 0a20 2020 2027 2727 0a0a 2020  nts..    '''..  
+000075a0: 2020 5f5f 6172 7261 795f 7072 696f 7269    __array_priori
+000075b0: 7479 5f5f 203d 2031 2e20 2023 2068 7474  ty__ = 1.  # htt
+000075c0: 703a 2f2f 7374 6163 6b6f 7665 7266 6c6f  p://stackoverflo
+000075d0: 772e 636f 6d2f 7175 6573 7469 6f6e 732f  w.com/questions/
+000075e0: 3730 3432 3439 362f 6e75 6d70 792d 636f  7042496/numpy-co
+000075f0: 6572 6369 6f6e 2d70 726f 626c 656d 2d66  ercion-problem-f
+00007600: 6f72 2d6c 6566 742d 7369 6465 642d 6269  or-left-sided-bi
+00007610: 6e61 7279 2d6f 7065 7261 746f 722f 3730  nary-operator/70
+00007620: 3537 3533 3023 3730 3537 3533 300a 0a20  57530#7057530.. 
+00007630: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
+00007640: 7365 6c66 2c20 6172 6773 2c20 7368 6170  self, args, shap
+00007650: 653a 2074 7970 696e 672e 5475 706c 655b  e: typing.Tuple[
+00007660: 2741 7272 6179 272c 202e 2e2e 5d2c 2064  'Array', ...], d
+00007670: 7479 7065 3a20 4474 7970 6529 3a0a 2020  type: Dtype):.  
+00007680: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+00007690: 6e73 7461 6e63 6528 7368 6170 652c 2074  nstance(shape, t
+000076a0: 7570 6c65 2920 616e 6420 616c 6c28 5f69  uple) and all(_i
+000076b0: 7369 6e64 6578 286e 2920 666f 7220 6e20  sindex(n) for n 
+000076c0: 696e 2073 6861 7065 292c 2066 2773 6861  in shape), f'sha
+000076d0: 7065 3d7b 7368 6170 6521 727d 270a 2020  pe={shape!r}'.  
+000076e0: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+000076f0: 6e73 7461 6e63 6528 6474 7970 652c 2074  nstance(dtype, t
+00007700: 7970 6529 2061 6e64 2064 7479 7065 2069  ype) and dtype i
+00007710: 6e20 5f74 7970 655f 6f72 6465 722c 2066  n _type_order, f
+00007720: 2764 7479 7065 3d7b 6474 7970 6521 727d  'dtype={dtype!r}
+00007730: 270a 2020 2020 2020 2020 7365 6c66 2e73  '.        self.s
+00007740: 6861 7065 203d 2073 6861 7065 0a20 2020  hape = shape.   
+00007750: 2020 2020 2073 656c 662e 6474 7970 6520       self.dtype 
+00007760: 3d20 6474 7970 650a 2020 2020 2020 2020  = dtype.        
+00007770: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+00007780: 2861 7267 733d 6172 6773 290a 0a20 2020  (args=args)..   
+00007790: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+000077a0: 6566 206e 6469 6d28 7365 6c66 293a 0a20  ef ndim(self):. 
+000077b0: 2020 2020 2020 2072 6574 7572 6e20 6c65         return le
+000077c0: 6e28 7365 6c66 2e73 6861 7065 290a 0a20  n(self.shape).. 
+000077d0: 2020 2064 6566 205f 5f67 6574 6974 656d     def __getitem
+000077e0: 5f5f 2873 656c 662c 2069 7465 6d29 3a0a  __(self, item):.
+000077f0: 2020 2020 2020 2020 6966 206e 6f74 2069          if not i
+00007800: 7369 6e73 7461 6e63 6528 6974 656d 2c20  sinstance(item, 
+00007810: 7475 706c 6529 3a0a 2020 2020 2020 2020  tuple):.        
+00007820: 2020 2020 6974 656d 203d 2069 7465 6d2c      item = item,
+00007830: 0a20 2020 2020 2020 2069 6620 2e2e 2e20  .        if ... 
+00007840: 696e 2069 7465 6d3a 0a20 2020 2020 2020  in item:.       
+00007850: 2020 2020 2069 656c 6c20 3d20 6974 656d       iell = item
+00007860: 2e69 6e64 6578 282e 2e2e 290a 2020 2020  .index(...).    
+00007870: 2020 2020 2020 2020 6966 202e 2e2e 2069          if ... i
+00007880: 6e20 6974 656d 5b69 656c 6c2b 313a 5d3a  n item[iell+1:]:
+00007890: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000078a0: 2072 6169 7365 2049 6e64 6578 4572 726f   raise IndexErro
+000078b0: 7228 2761 6e20 696e 6465 7820 6361 6e20  r('an index can 
+000078c0: 6861 7665 206f 6e6c 7920 6120 7369 6e67  have only a sing
+000078d0: 6c65 2065 6c6c 6970 7369 7327 290a 2020  le ellipsis').  
+000078e0: 2020 2020 2020 2020 2020 2320 7265 706c            # repl
+000078f0: 6163 6520 656c 6c69 7073 6973 2062 7920  ace ellipsis by 
+00007900: 7468 6520 6170 7072 6f70 7269 6174 6520  the appropriate 
+00007910: 6e75 6d62 6572 206f 6620 736c 6963 6528  number of slice(
+00007920: 4e6f 6e65 290a 2020 2020 2020 2020 2020  None).          
+00007930: 2020 6974 656d 203d 2069 7465 6d5b 3a69    item = item[:i
+00007940: 656c 6c5d 202b 2028 736c 6963 6528 4e6f  ell] + (slice(No
+00007950: 6e65 292c 292a 2873 656c 662e 6e64 696d  ne),)*(self.ndim
+00007960: 2d6c 656e 2869 7465 6d29 2b31 2920 2b20  -len(item)+1) + 
+00007970: 6974 656d 5b69 656c 6c2b 313a 5d0a 2020  item[iell+1:].  
+00007980: 2020 2020 2020 6966 206c 656e 2869 7465        if len(ite
+00007990: 6d29 203e 2073 656c 662e 6e64 696d 3a0a  m) > self.ndim:.
+000079a0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+000079b0: 6520 496e 6465 7845 7272 6f72 2827 746f  e IndexError('to
+000079c0: 6f20 6d61 6e79 2069 6e64 6963 6573 2066  o many indices f
+000079d0: 6f72 2061 7272 6179 2729 0a20 2020 2020  or array').     
+000079e0: 2020 2061 7272 6179 203d 2073 656c 660a     array = self.
+000079f0: 2020 2020 2020 2020 666f 7220 6178 6973          for axis
+00007a00: 2c20 6974 2069 6e20 7265 7665 7273 6564  , it in reversed
+00007a10: 2874 7570 6c65 2865 6e75 6d65 7261 7465  (tuple(enumerate
+00007a20: 2869 7465 6d29 2929 3a0a 2020 2020 2020  (item))):.      
+00007a30: 2020 2020 2020 6172 7261 7920 3d20 6765        array = ge
+00007a40: 7428 6172 7261 792c 2061 7869 732c 2069  t(array, axis, i
+00007a50: 7465 6d3d 636f 6e73 7461 6e74 2869 7429  tem=constant(it)
+00007a60: 2920 6966 206e 756d 6572 6963 2e69 7369  ) if numeric.isi
+00007a70: 6e74 2869 7429 205c 0a20 2020 2020 2020  nt(it) \.       
+00007a80: 2020 2020 2020 2020 2065 6c73 6520 5f74           else _t
+00007a90: 616b 6573 6c69 6365 2861 7272 6179 2c20  akeslice(array, 
+00007aa0: 6974 2c20 6178 6973 2920 6966 2069 7369  it, axis) if isi
+00007ab0: 6e73 7461 6e63 6528 6974 2c20 736c 6963  nstance(it, slic
+00007ac0: 6529 205c 0a20 2020 2020 2020 2020 2020  e) \.           
+00007ad0: 2020 2020 2065 6c73 6520 7461 6b65 2861       else take(a
+00007ae0: 7272 6179 2c20 6974 2c20 6178 6973 290a  rray, it, axis).
+00007af0: 2020 2020 2020 2020 7265 7475 726e 2061          return a
+00007b00: 7272 6179 0a0a 2020 2020 6465 6620 5f5f  rray..    def __
+00007b10: 626f 6f6c 5f5f 2873 656c 6629 3a0a 2020  bool__(self):.  
+00007b20: 2020 2020 2020 7265 7475 726e 2054 7275        return Tru
+00007b30: 650a 0a20 2020 2064 6566 205f 5f6c 656e  e..    def __len
+00007b40: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
+00007b50: 2020 6966 2073 656c 662e 6e64 696d 203d    if self.ndim =
+00007b60: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
+00007b70: 2072 6169 7365 2054 7970 6545 7272 6f72   raise TypeError
+00007b80: 2827 6c65 6e28 2920 6f66 2075 6e73 697a  ('len() of unsiz
+00007b90: 6564 206f 626a 6563 7427 290a 2020 2020  ed object').    
+00007ba0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00007bb0: 7368 6170 655b 305d 0a0a 2020 2020 6465  shape[0]..    de
+00007bc0: 6620 5f5f 696e 6465 785f 5f28 7365 6c66  f __index__(self
+00007bd0: 293a 0a20 2020 2020 2020 2074 7279 3a0a  ):.        try:.
+00007be0: 2020 2020 2020 2020 2020 2020 696e 6465              inde
+00007bf0: 7820 3d20 7365 6c66 2e5f 5f69 6e64 6578  x = self.__index
+00007c00: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
+00007c10: 4174 7472 6962 7574 6545 7272 6f72 3a0a  AttributeError:.
+00007c20: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+00007c30: 656c 662e 6e64 696d 206f 7220 7365 6c66  elf.ndim or self
+00007c40: 2e64 7479 7065 206e 6f74 2069 6e20 2869  .dtype not in (i
+00007c50: 6e74 2c20 626f 6f6c 2920 6f72 206e 6f74  nt, bool) or not
+00007c60: 2073 656c 662e 6973 636f 6e73 7461 6e74   self.isconstant
+00007c70: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00007c80: 2020 7261 6973 6520 5479 7065 4572 726f    raise TypeErro
+00007c90: 7228 2763 616e 6e6f 7420 636f 6e76 6572  r('cannot conver
+00007ca0: 7420 7b21 727d 2074 6f20 696e 7427 2e66  t {!r} to int'.f
+00007cb0: 6f72 6d61 7428 7365 6c66 2929 0a20 2020  ormat(self)).   
+00007cc0: 2020 2020 2020 2020 2069 6e64 6578 203d           index =
+00007cd0: 2073 656c 662e 5f5f 696e 6465 7820 3d20   self.__index = 
+00007ce0: 696e 7428 7365 6c66 2e73 696d 706c 6966  int(self.simplif
+00007cf0: 6965 642e 6576 616c 2829 290a 2020 2020  ied.eval()).    
+00007d00: 2020 2020 7265 7475 726e 2069 6e64 6578      return index
+00007d10: 0a0a 2020 2020 5420 3d20 7072 6f70 6572  ..    T = proper
+00007d20: 7479 286c 616d 6264 6120 7365 6c66 3a20  ty(lambda self: 
+00007d30: 7472 616e 7370 6f73 6528 7365 6c66 2929  transpose(self))
+00007d40: 0a0a 2020 2020 5f5f 6164 645f 5f20 3d20  ..    __add__ = 
+00007d50: 5f5f 7261 6464 5f5f 203d 2061 6464 0a20  __radd__ = add. 
+00007d60: 2020 205f 5f73 7562 5f5f 203d 206c 616d     __sub__ = lam
+00007d70: 6264 6120 7365 6c66 2c20 6f74 6865 723a  bda self, other:
+00007d80: 2073 7562 7472 6163 7428 7365 6c66 2c20   subtract(self, 
+00007d90: 6f74 6865 7229 0a20 2020 205f 5f72 7375  other).    __rsu
+00007da0: 625f 5f20 3d20 6c61 6d62 6461 2073 656c  b__ = lambda sel
+00007db0: 662c 206f 7468 6572 3a20 7375 6274 7261  f, other: subtra
+00007dc0: 6374 286f 7468 6572 2c20 7365 6c66 290a  ct(other, self).
+00007dd0: 2020 2020 5f5f 6d75 6c5f 5f20 3d20 5f5f      __mul__ = __
+00007de0: 726d 756c 5f5f 203d 206d 756c 7469 706c  rmul__ = multipl
+00007df0: 790a 2020 2020 5f5f 7472 7565 6469 765f  y.    __truediv_
+00007e00: 5f20 3d20 6c61 6d62 6461 2073 656c 662c  _ = lambda self,
+00007e10: 206f 7468 6572 3a20 6469 7669 6465 2873   other: divide(s
+00007e20: 656c 662c 206f 7468 6572 290a 2020 2020  elf, other).    
+00007e30: 5f5f 7274 7275 6564 6976 5f5f 203d 206c  __rtruediv__ = l
+00007e40: 616d 6264 6120 7365 6c66 2c20 6f74 6865  ambda self, othe
+00007e50: 723a 2064 6976 6964 6528 6f74 6865 722c  r: divide(other,
+00007e60: 2073 656c 6629 0a20 2020 205f 5f70 6f73   self).    __pos
+00007e70: 5f5f 203d 206c 616d 6264 6120 7365 6c66  __ = lambda self
+00007e80: 3a20 7365 6c66 0a20 2020 205f 5f6e 6567  : self.    __neg
+00007e90: 5f5f 203d 206c 616d 6264 6120 7365 6c66  __ = lambda self
+00007ea0: 3a20 6e65 6761 7469 7665 2873 656c 6629  : negative(self)
+00007eb0: 0a20 2020 205f 5f70 6f77 5f5f 203d 2070  .    __pow__ = p
+00007ec0: 6f77 6572 0a20 2020 205f 5f61 6273 5f5f  ower.    __abs__
+00007ed0: 203d 206c 616d 6264 6120 7365 6c66 3a20   = lambda self: 
+00007ee0: 6162 7328 7365 6c66 290a 2020 2020 5f5f  abs(self).    __
+00007ef0: 6d6f 645f 5f20 3d20 6c61 6d62 6461 2073  mod__ = lambda s
+00007f00: 656c 662c 206f 7468 6572 3a20 6d6f 6428  elf, other: mod(
+00007f10: 7365 6c66 2c20 6f74 6865 7229 0a20 2020  self, other).   
+00007f20: 205f 5f69 6e74 5f5f 203d 205f 5f69 6e64   __int__ = __ind
+00007f30: 6578 5f5f 0a20 2020 205f 5f73 7472 5f5f  ex__.    __str__
+00007f40: 203d 205f 5f72 6570 725f 5f20 3d20 6c61   = __repr__ = la
+00007f50: 6d62 6461 2073 656c 663a 2027 7b7d 2e7b  mbda self: '{}.{
+00007f60: 7d3c 7b7d 3e27 2e66 6f72 6d61 7428 7479  }<{}>'.format(ty
+00007f70: 7065 2873 656c 6629 2e5f 5f6d 6f64 756c  pe(self).__modul
+00007f80: 655f 5f2c 2074 7970 6528 7365 6c66 292e  e__, type(self).
+00007f90: 5f5f 6e61 6d65 5f5f 2c20 7365 6c66 2e5f  __name__, self._
+00007fa0: 7368 6170 655f 7374 7228 666f 726d 3d73  shape_str(form=s
+00007fb0: 7472 2929 0a0a 2020 2020 6465 6620 5f73  tr))..    def _s
+00007fc0: 6861 7065 5f73 7472 2873 656c 662c 2066  hape_str(self, f
+00007fd0: 6f72 6d29 3a0a 2020 2020 2020 2020 6474  orm):.        dt
+00007fe0: 7970 6520 3d20 7365 6c66 2e64 7479 7065  ype = self.dtype
+00007ff0: 2e5f 5f6e 616d 655f 5f5b 305d 2069 6620  .__name__[0] if 
+00008000: 6861 7361 7474 7228 7365 6c66 2c20 2764  hasattr(self, 'd
+00008010: 7479 7065 2729 2065 6c73 6520 273f 270a  type') else '?'.
+00008020: 2020 2020 2020 2020 7368 6170 6520 3d20          shape = 
+00008030: 5b73 7472 286e 2e5f 5f69 6e64 6578 5f5f  [str(n.__index__
+00008040: 2829 2920 6966 206e 2e69 7363 6f6e 7374  ()) if n.isconst
+00008050: 616e 7420 656c 7365 2027 3f27 2066 6f72  ant else '?' for
+00008060: 206e 2069 6e20 7365 6c66 2e73 6861 7065   n in self.shape
+00008070: 5d0a 2020 2020 2020 2020 666f 7220 6920  ].        for i 
+00008080: 696e 2073 6574 2872 616e 6765 2873 656c  in set(range(sel
+00008090: 662e 6e64 696d 2929 202d 2073 6574 2873  f.ndim)) - set(s
+000080a0: 656c 662e 5f75 6e61 6c69 676e 6564 5b31  elf._unaligned[1
+000080b0: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
+000080c0: 7368 6170 655b 695d 203d 2066 2728 7b73  shape[i] = f'({s
+000080d0: 6861 7065 5b69 5d7d 2927 0a20 2020 2020  hape[i]})'.     
+000080e0: 2020 2066 6f72 2069 2c20 5f20 696e 2073     for i, _ in s
+000080f0: 656c 662e 5f69 6e66 6c61 7469 6f6e 733a  elf._inflations:
+00008100: 0a20 2020 2020 2020 2020 2020 2073 6861  .            sha
+00008110: 7065 5b69 5d20 3d20 6627 7e7b 7368 6170  pe[i] = f'~{shap
+00008120: 655b 695d 7d27 0a20 2020 2020 2020 2066  e[i]}'.        f
+00008130: 6f72 2061 7865 7320 696e 2073 656c 662e  or axes in self.
+00008140: 5f64 6961 676f 6e61 6c73 3a0a 2020 2020  _diagonals:.    
+00008150: 2020 2020 2020 2020 666f 7220 6920 696e          for i in
+00008160: 2061 7865 733a 0a20 2020 2020 2020 2020   axes:.         
+00008170: 2020 2020 2020 2073 6861 7065 5b69 5d20         shape[i] 
+00008180: 3d20 6627 7b73 6861 7065 5b69 5d7d 2f27  = f'{shape[i]}/'
+00008190: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000081a0: 6627 7b64 7479 7065 7d3a 7b22 2c22 2e6a  f'{dtype}:{",".j
+000081b0: 6f69 6e28 7368 6170 6529 7d27 0a0a 2020  oin(shape)}'..  
+000081c0: 2020 7375 6d20 3d20 7375 6d0a 2020 2020    sum = sum.    
+000081d0: 7072 6f64 203d 2070 726f 6475 6374 0a20  prod = product. 
+000081e0: 2020 2064 6f74 203d 2064 6f74 0a20 2020     dot = dot.   
+000081f0: 2073 7761 7061 7865 7320 3d20 7377 6170   swapaxes = swap
+00008200: 6178 6573 0a20 2020 2074 7261 6e73 706f  axes.    transpo
+00008210: 7365 203d 2074 7261 6e73 706f 7365 0a20  se = transpose. 
+00008220: 2020 2063 686f 6f73 6520 3d20 6c61 6d62     choose = lamb
+00008230: 6461 2073 656c 662c 2063 686f 6963 6573  da self, choices
+00008240: 3a20 4368 6f6f 7365 2873 656c 662c 202a  : Choose(self, *
+00008250: 6368 6f69 6365 7329 0a20 2020 2063 6f6e  choices).    con
+00008260: 6a75 6761 7465 203d 2063 6f6e 6a75 6761  jugate = conjuga
+00008270: 7465 0a0a 2020 2020 4070 726f 7065 7274  te..    @propert
+00008280: 790a 2020 2020 6465 6620 7265 616c 2873  y.    def real(s
+00008290: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+000082a0: 7475 726e 2072 6561 6c28 7365 6c66 290a  turn real(self).
+000082b0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+000082c0: 2020 2064 6566 2069 6d61 6728 7365 6c66     def imag(self
+000082d0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+000082e0: 6e20 696d 6167 2873 656c 6629 0a0a 2020  n imag(self)..  
+000082f0: 2020 4063 6163 6865 645f 7072 6f70 6572    @cached_proper
+00008300: 7479 0a20 2020 2064 6566 205f 6173 7370  ty.    def _assp
+00008310: 6172 7365 2873 656c 6629 3a0a 2020 2020  arse(self):.    
+00008320: 2020 2020 2320 436f 6e76 6572 7420 746f      # Convert to
+00008330: 2061 2073 6571 7565 6e63 6520 6f66 2073   a sequence of s
+00008340: 7061 7273 6520 434f 4f20 6172 7261 7973  parse COO arrays
+00008350: 2e20 5468 6520 7265 7475 726e 6564 2064  . The returned d
+00008360: 6174 6120 6973 2061 2074 7570 6c65 0a20  ata is a tuple. 
+00008370: 2020 2020 2020 2023 206f 6620 6028 2a69         # of `(*i
+00008380: 6e64 6963 6573 2c20 7661 6c75 6573 2960  ndices, values)`
+00008390: 2074 7570 6c65 732c 2077 6865 7265 2060   tuples, where `
+000083a0: 7661 6c75 6573 6020 6973 2061 6e20 6041  values` is an `A
+000083b0: 7272 6179 6020 7769 7468 2074 6865 0a20  rray` with the. 
+000083c0: 2020 2020 2020 2023 2073 616d 6520 6474         # same dt
+000083d0: 7970 6520 6173 2060 7365 6c66 602c 2062  ype as `self`, b
+000083e0: 7574 2074 6869 7320 6973 206e 6f74 2065  ut this is not e
+000083f0: 6e66 6f72 6365 6420 7965 742c 2061 6e64  nforced yet, and
+00008400: 2065 6163 6820 696e 6465 7820 696e 0a20   each index in. 
+00008410: 2020 2020 2020 2023 2060 696e 6469 6365         # `indice
+00008420: 7360 2069 7320 616e 2060 4172 7261 7960  s` is an `Array`
+00008430: 2077 6974 6820 6474 7970 6520 6069 6e74   with dtype `int
+00008440: 6020 616e 6420 7468 6520 6578 6163 7420  ` and the exact 
+00008450: 7361 6d65 2073 6861 7065 2061 730a 2020  same shape as.  
+00008460: 2020 2020 2020 2320 6076 616c 7565 7360        # `values`
+00008470: 2e20 5468 6520 6c65 6e67 7468 206f 6620  . The length of 
+00008480: 6069 6e64 6963 6573 6020 6571 7561 6c73  `indices` equals
+00008490: 2060 7365 6c66 2e6e 6469 6d60 2e20 496e   `self.ndim`. In
+000084a0: 2061 6464 6974 696f 6e2c 2069 660a 2020   addition, if.  
+000084b0: 2020 2020 2020 2320 6073 656c 6660 2069        # `self` i
+000084c0: 7320 3064 2074 6865 206c 656e 6774 6820  s 0d the length 
+000084d0: 6f66 2060 7365 6c66 2e5f 6173 7370 6172  of `self._asspar
+000084e0: 7365 6020 6973 2061 7420 6d6f 7374 206f  se` is at most o
+000084f0: 6e65 2061 6e64 2074 6865 0a20 2020 2020  ne and the.     
+00008500: 2020 2023 2060 7661 6c75 6573 6020 6172     # `values` ar
+00008510: 7261 7920 6d75 7374 2062 6520 3064 2061  ray must be 0d a
+00008520: 7320 7765 6c6c 2e0a 2020 2020 2020 2020  s well..        
+00008530: 230a 2020 2020 2020 2020 2320 5468 6520  #.        # The 
+00008540: 7370 6172 7365 2064 6174 6120 6361 6e20  sparse data can 
+00008550: 6265 2072 6561 7373 656d 626c 6564 2061  be reassembled a
+00008560: 6674 6572 2065 7661 6c75 6174 696f 6e20  fter evaluation 
+00008570: 6279 0a20 2020 2020 2020 2023 0a20 2020  by.        #.   
+00008580: 2020 2020 2023 2020 2020 2064 656e 7365       #     dense
+00008590: 203d 206e 756d 7079 2e7a 6572 6f73 2873   = numpy.zeros(s
+000085a0: 656c 662e 7368 6170 6529 0a20 2020 2020  elf.shape).     
+000085b0: 2020 2023 2020 2020 2066 6f72 2049 302c     #     for I0,
+000085c0: 2e2e 2e2c 496b 2c56 2069 6e20 7365 6c66  ...,Ik,V in self
+000085d0: 2e5f 6173 7370 6172 7365 3a0a 2020 2020  ._assparse:.    
+000085e0: 2020 2020 2320 2020 2020 2020 666f 7220      #       for 
+000085f0: 6930 2c2e 2e2e 2c69 6b2c 7620 696e 207a  i0,...,ik,v in z
+00008600: 6970 2849 302e 6576 616c 2829 2e72 6176  ip(I0.eval().rav
+00008610: 656c 2829 2c2e 2e2e 2c49 6b2e 6576 616c  el(),...,Ik.eval
+00008620: 2829 2e72 6176 656c 2829 2c56 2e65 7661  ().ravel(),V.eva
+00008630: 6c28 292e 7261 7665 6c28 2929 3a0a 2020  l().ravel()):.  
+00008640: 2020 2020 2020 2320 2020 2020 2020 2020        #         
+00008650: 6465 6e73 655b 6930 2c2e 2e2e 2c69 6b5d  dense[i0,...,ik]
+00008660: 203d 2076 0a0a 2020 2020 2020 2020 696e   = v..        in
+00008670: 6469 6365 7320 3d20 5b70 7265 7065 6e64  dices = [prepend
+00008680: 6178 6573 2861 7070 656e 6461 7865 7328  axes(appendaxes(
+00008690: 5261 6e67 6528 6c65 6e67 7468 292c 2073  Range(length), s
+000086a0: 656c 662e 7368 6170 655b 692b 313a 5d29  elf.shape[i+1:])
+000086b0: 2c20 7365 6c66 2e73 6861 7065 5b3a 695d  , self.shape[:i]
+000086c0: 2920 666f 7220 692c 206c 656e 6774 6820  ) for i, length 
+000086d0: 696e 2065 6e75 6d65 7261 7465 2873 656c  in enumerate(sel
+000086e0: 662e 7368 6170 6529 5d0a 2020 2020 2020  f.shape)].      
+000086f0: 2020 7265 7475 726e 2028 2a69 6e64 6963    return (*indic
+00008700: 6573 2c20 7365 6c66 292c 0a0a 2020 2020  es, self),..    
+00008710: 6465 6620 5f6e 6f64 6528 7365 6c66 2c20  def _node(self, 
+00008720: 6361 6368 652c 2073 7562 6772 6170 682c  cache, subgraph,
+00008730: 2074 696d 6573 293a 0a20 2020 2020 2020   times):.       
+00008740: 2069 6620 7365 6c66 2069 6e20 6361 6368   if self in cach
+00008750: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+00008760: 6574 7572 6e20 6361 6368 655b 7365 6c66  eturn cache[self
+00008770: 5d0a 2020 2020 2020 2020 6172 6773 203d  ].        args =
+00008780: 2074 7570 6c65 2861 7267 2e5f 6e6f 6465   tuple(arg._node
+00008790: 2863 6163 6865 2c20 7375 6267 7261 7068  (cache, subgraph
+000087a0: 2c20 7469 6d65 7329 2066 6f72 2061 7267  , times) for arg
+000087b0: 2069 6e20 7365 6c66 2e5f 4576 616c 7561   in self._Evalua
+000087c0: 626c 655f 5f61 7267 7329 0a20 2020 2020  ble__args).     
+000087d0: 2020 2062 6f75 6e64 7320 3d20 275b 7b7d     bounds = '[{}
+000087e0: 2c7b 7d5d 272e 666f 726d 6174 282a 7365  ,{}]'.format(*se
+000087f0: 6c66 2e5f 696e 7462 6f75 6e64 7329 2069  lf._intbounds) i
+00008800: 6620 7365 6c66 2e64 7479 7065 203d 3d20  f self.dtype == 
+00008810: 696e 7420 656c 7365 204e 6f6e 650a 2020  int else None.  
+00008820: 2020 2020 2020 6c61 6265 6c20 3d20 275c        label = '\
+00008830: 6e27 2e6a 6f69 6e28 6669 6c74 6572 284e  n'.join(filter(N
+00008840: 6f6e 652c 2028 7479 7065 2873 656c 6629  one, (type(self)
+00008850: 2e5f 5f6e 616d 655f 5f2c 2073 656c 662e  .__name__, self.
+00008860: 5f6e 6f64 655f 6465 7461 696c 732c 2073  _node_details, s
+00008870: 656c 662e 5f73 6861 7065 5f73 7472 2866  elf._shape_str(f
+00008880: 6f72 6d3d 7265 7072 292c 2062 6f75 6e64  orm=repr), bound
+00008890: 7329 2929 0a20 2020 2020 2020 2063 6163  s))).        cac
+000088a0: 6865 5b73 656c 665d 203d 206e 6f64 6520  he[self] = node 
+000088b0: 3d20 5265 6775 6c61 724e 6f64 6528 6c61  = RegularNode(la
+000088c0: 6265 6c2c 2061 7267 732c 207b 7d2c 2028  bel, args, {}, (
+000088d0: 7479 7065 2873 656c 6629 2e5f 5f6e 616d  type(self).__nam
+000088e0: 655f 5f2c 2074 696d 6573 5b73 656c 665d  e__, times[self]
+000088f0: 292c 2073 7562 6772 6170 6829 0a20 2020  ), subgraph).   
+00008900: 2020 2020 2072 6574 7572 6e20 6e6f 6465       return node
+00008910: 0a0a 2020 2020 2320 7369 6d70 6c69 6669  ..    # simplifi
+00008920: 6361 7469 6f6e 730a 2020 2020 5f6d 756c  cations.    _mul
+00008930: 7469 706c 7920 3d20 6c61 6d62 6461 2073  tiply = lambda s
+00008940: 656c 662c 206f 7468 6572 3a20 4e6f 6e65  elf, other: None
+00008950: 0a20 2020 205f 7472 616e 7370 6f73 6520  .    _transpose 
+00008960: 3d20 6c61 6d62 6461 2073 656c 662c 2061  = lambda self, a
+00008970: 7865 733a 204e 6f6e 650a 2020 2020 5f69  xes: None.    _i
+00008980: 6e73 6572 7461 7869 7320 3d20 6c61 6d62  nsertaxis = lamb
+00008990: 6461 2073 656c 662c 2061 7869 732c 206c  da self, axis, l
+000089a0: 656e 6774 683a 204e 6f6e 650a 2020 2020  ength: None.    
+000089b0: 5f70 6f77 6572 203d 206c 616d 6264 6120  _power = lambda 
+000089c0: 7365 6c66 2c20 6e3a 204e 6f6e 650a 2020  self, n: None.  
+000089d0: 2020 5f61 6464 203d 206c 616d 6264 6120    _add = lambda 
+000089e0: 7365 6c66 2c20 6f74 6865 723a 204e 6f6e  self, other: Non
+000089f0: 650a 2020 2020 5f73 756d 203d 206c 616d  e.    _sum = lam
+00008a00: 6264 6120 7365 6c66 2c20 6178 6973 3a20  bda self, axis: 
+00008a10: 4e6f 6e65 0a20 2020 205f 7461 6b65 203d  None.    _take =
+00008a20: 206c 616d 6264 6120 7365 6c66 2c20 696e   lambda self, in
+00008a30: 6465 782c 2061 7869 733a 204e 6f6e 650a  dex, axis: None.
+00008a40: 2020 2020 5f72 7461 6b65 203d 206c 616d      _rtake = lam
+00008a50: 6264 6120 7365 6c66 2c20 696e 6465 782c  bda self, index,
+00008a60: 2061 7869 733a 204e 6f6e 650a 2020 2020   axis: None.    
+00008a70: 5f64 6574 6572 6d69 6e61 6e74 203d 206c  _determinant = l
+00008a80: 616d 6264 6120 7365 6c66 2c20 6178 6973  ambda self, axis
+00008a90: 312c 2061 7869 7332 3a20 4e6f 6e65 0a20  1, axis2: None. 
+00008aa0: 2020 205f 696e 7665 7273 6520 3d20 6c61     _inverse = la
+00008ab0: 6d62 6461 2073 656c 662c 2061 7869 7331  mbda self, axis1
+00008ac0: 2c20 6178 6973 323a 204e 6f6e 650a 2020  , axis2: None.  
+00008ad0: 2020 5f74 616b 6564 6961 6720 3d20 6c61    _takediag = la
+00008ae0: 6d62 6461 2073 656c 662c 2061 7869 7331  mbda self, axis1
+00008af0: 2c20 6178 6973 323a 204e 6f6e 650a 2020  , axis2: None.  
+00008b00: 2020 5f64 6961 676f 6e61 6c69 7a65 203d    _diagonalize =
+00008b10: 206c 616d 6264 6120 7365 6c66 2c20 6178   lambda self, ax
+00008b20: 6973 3a20 4e6f 6e65 0a20 2020 205f 7072  is: None.    _pr
+00008b30: 6f64 7563 7420 3d20 6c61 6d62 6461 2073  oduct = lambda s
+00008b40: 656c 663a 204e 6f6e 650a 2020 2020 5f73  elf: None.    _s
+00008b50: 6967 6e20 3d20 6c61 6d62 6461 2073 656c  ign = lambda sel
+00008b60: 663a 204e 6f6e 650a 2020 2020 5f65 6967  f: None.    _eig
+00008b70: 203d 206c 616d 6264 6120 7365 6c66 2c20   = lambda self, 
+00008b80: 7379 6d6d 6574 7269 633a 204e 6f6e 650a  symmetric: None.
+00008b90: 2020 2020 5f69 6e66 6c61 7465 203d 206c      _inflate = l
+00008ba0: 616d 6264 6120 7365 6c66 2c20 646f 666d  ambda self, dofm
+00008bb0: 6170 2c20 6c65 6e67 7468 2c20 6178 6973  ap, length, axis
+00008bc0: 3a20 4e6f 6e65 0a20 2020 205f 7269 6e66  : None.    _rinf
+00008bd0: 6c61 7465 203d 206c 616d 6264 6120 7365  late = lambda se
+00008be0: 6c66 2c20 6675 6e63 2c20 6c65 6e67 7468  lf, func, length
+00008bf0: 2c20 6178 6973 3a20 4e6f 6e65 0a20 2020  , axis: None.   
+00008c00: 205f 756e 7261 7665 6c20 3d20 6c61 6d62   _unravel = lamb
+00008c10: 6461 2073 656c 662c 2061 7869 732c 2073  da self, axis, s
+00008c20: 6861 7065 3a20 4e6f 6e65 0a20 2020 205f  hape: None.    _
+00008c30: 7261 7665 6c20 3d20 6c61 6d62 6461 2073  ravel = lambda s
+00008c40: 656c 662c 2061 7869 733a 204e 6f6e 650a  elf, axis: None.
+00008c50: 2020 2020 5f6c 6f6f 7073 756d 203d 206c      _loopsum = l
+00008c60: 616d 6264 6120 7365 6c66 2c20 6c6f 6f70  ambda self, loop
+00008c70: 5f69 6e64 6578 3a20 4e6f 6e65 2020 2320  _index: None  # 
+00008c80: 4e4f 5445 3a20 7479 7065 206f 6620 606c  NOTE: type of `l
+00008c90: 6f6f 705f 696e 6465 7860 2069 7320 605f  oop_index` is `_
+00008ca0: 4c6f 6f70 496e 6465 7860 0a20 2020 205f  LoopIndex`.    _
+00008cb0: 7265 616c 203d 206c 616d 6264 6120 7365  real = lambda se
+00008cc0: 6c66 3a20 4e6f 6e65 0a20 2020 205f 696d  lf: None.    _im
+00008cd0: 6167 203d 206c 616d 6264 6120 7365 6c66  ag = lambda self
+00008ce0: 3a20 4e6f 6e65 0a20 2020 205f 636f 6e6a  : None.    _conj
+00008cf0: 7567 6174 6520 3d20 6c61 6d62 6461 2073  ugate = lambda s
+00008d00: 656c 663a 204e 6f6e 650a 0a20 2020 2040  elf: None..    @
+00008d10: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00008d20: 205f 756e 616c 6967 6e65 6428 7365 6c66   _unaligned(self
+00008d30: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00008d40: 6e20 7365 6c66 2c20 7475 706c 6528 7261  n self, tuple(ra
+00008d50: 6e67 6528 7365 6c66 2e6e 6469 6d29 290a  nge(self.ndim)).
+00008d60: 0a20 2020 205f 6469 6167 6f6e 616c 7320  .    _diagonals 
+00008d70: 3d20 2829 0a20 2020 205f 696e 666c 6174  = ().    _inflat
+00008d80: 696f 6e73 203d 2028 290a 0a20 2020 2064  ions = ()..    d
+00008d90: 6566 205f 6465 7269 7661 7469 7665 2873  ef _derivative(s
+00008da0: 656c 662c 2076 6172 2c20 7365 656e 293a  elf, var, seen):
+00008db0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00008dc0: 2e64 7479 7065 2069 6e20 2862 6f6f 6c2c  .dtype in (bool,
+00008dd0: 2069 6e74 2920 6f72 2076 6172 206e 6f74   int) or var not
+00008de0: 2069 6e20 7365 6c66 2e61 7267 756d 656e   in self.argumen
+00008df0: 7473 3a0a 2020 2020 2020 2020 2020 2020  ts:.            
+00008e00: 7265 7475 726e 205a 6572 6f73 2873 656c  return Zeros(sel
+00008e10: 662e 7368 6170 6520 2b20 7661 722e 7368  f.shape + var.sh
+00008e20: 6170 652c 2064 7479 7065 3d73 656c 662e  ape, dtype=self.
+00008e30: 6474 7970 6529 0a20 2020 2020 2020 2072  dtype).        r
+00008e40: 6169 7365 204e 6f74 496d 706c 656d 656e  aise NotImplemen
+00008e50: 7465 6445 7272 6f72 2827 6465 7269 7661  tedError('deriva
+00008e60: 7469 7665 206e 6f74 2064 6566 696e 6564  tive not defined
+00008e70: 2066 6f72 207b 7d27 2e66 6f72 6d61 7428   for {}'.format(
+00008e80: 7365 6c66 2e5f 5f63 6c61 7373 5f5f 2e5f  self.__class__._
+00008e90: 5f6e 616d 655f 5f29 290a 0a20 2020 2040  _name__))..    @
+00008ea0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00008eb0: 2061 735f 6576 616c 7561 626c 655f 6172   as_evaluable_ar
+00008ec0: 7261 7928 7365 6c66 293a 0a20 2020 2020  ray(self):.     
+00008ed0: 2020 2027 7265 7475 726e 2073 656c 6627     'return self'
+00008ee0: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+00008ef0: 2073 656c 660a 0a20 2020 2040 6361 6368   self..    @cach
+00008f00: 6564 5f70 726f 7065 7274 790a 2020 2020  ed_property.    
+00008f10: 6465 6620 5f69 6e74 626f 756e 6473 2873  def _intbounds(s
+00008f20: 656c 6629 3a0a 2020 2020 2020 2020 2320  elf):.        # 
+00008f30: 696e 636c 7573 6976 6520 6c6f 7765 7220  inclusive lower 
+00008f40: 616e 6420 7570 7065 7220 626f 756e 6473  and upper bounds
+00008f50: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00008f60: 2e6e 6469 6d20 3d3d 2030 2061 6e64 2073  .ndim == 0 and s
+00008f70: 656c 662e 6474 7970 6520 3d3d 2069 6e74  elf.dtype == int
+00008f80: 2061 6e64 2073 656c 662e 6973 636f 6e73   and self.iscons
+00008f90: 7461 6e74 3a0a 2020 2020 2020 2020 2020  tant:.          
+00008fa0: 2020 7661 6c75 6520 3d20 7365 6c66 2e5f    value = self._
+00008fb0: 5f69 6e64 6578 5f5f 2829 0a20 2020 2020  _index__().     
+00008fc0: 2020 2020 2020 2072 6574 7572 6e20 7661         return va
+00008fd0: 6c75 652c 2076 616c 7565 0a20 2020 2020  lue, value.     
+00008fe0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00008ff0: 2020 2020 206c 6f77 6572 2c20 7570 7065       lower, uppe
+00009000: 7220 3d20 7365 6c66 2e5f 696e 7462 6f75  r = self._intbou
+00009010: 6e64 735f 696d 706c 2829 0a20 2020 2020  nds_impl().     
+00009020: 2020 2020 2020 2061 7373 6572 7420 6973         assert is
+00009030: 696e 7374 616e 6365 286c 6f77 6572 2c20  instance(lower, 
+00009040: 696e 7429 206f 7220 6c6f 7765 7220 3d3d  int) or lower ==
+00009050: 2066 6c6f 6174 2827 2d69 6e66 2729 206f   float('-inf') o
+00009060: 7220 6c6f 7765 7220 3d3d 2066 6c6f 6174  r lower == float
+00009070: 2827 696e 6627 290a 2020 2020 2020 2020  ('inf').        
+00009080: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
+00009090: 7461 6e63 6528 7570 7065 722c 2069 6e74  tance(upper, int
+000090a0: 2920 6f72 2075 7070 6572 203d 3d20 666c  ) or upper == fl
+000090b0: 6f61 7428 272d 696e 6627 2920 6f72 2075  oat('-inf') or u
+000090c0: 7070 6572 203d 3d20 666c 6f61 7428 2769  pper == float('i
+000090d0: 6e66 2729 0a20 2020 2020 2020 2020 2020  nf').           
+000090e0: 2061 7373 6572 7420 6c6f 7765 7220 3c3d   assert lower <=
+000090f0: 2075 7070 6572 0a20 2020 2020 2020 2020   upper.         
+00009100: 2020 2072 6574 7572 6e20 6c6f 7765 722c     return lower,
+00009110: 2075 7070 6572 0a0a 2020 2020 6465 6620   upper..    def 
+00009120: 5f69 6e74 626f 756e 6473 5f69 6d70 6c28  _intbounds_impl(
+00009130: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+00009140: 6574 7572 6e20 666c 6f61 7428 272d 696e  eturn float('-in
+00009150: 6627 292c 2066 6c6f 6174 2827 696e 6627  f'), float('inf'
+00009160: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
+00009170: 0a20 2020 2064 6566 205f 636f 6e73 745f  .    def _const_
+00009180: 756e 6966 6f72 6d28 7365 6c66 293a 0a20  uniform(self):. 
+00009190: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
+000091a0: 7479 7065 203d 3d20 696e 743a 0a20 2020  type == int:.   
+000091b0: 2020 2020 2020 2020 206c 6f77 6572 2c20           lower, 
+000091c0: 7570 7065 7220 3d20 7365 6c66 2e5f 696e  upper = self._in
+000091d0: 7462 6f75 6e64 730a 2020 2020 2020 2020  tbounds.        
+000091e0: 2020 2020 7265 7475 726e 206c 6f77 6572      return lower
+000091f0: 2069 6620 6c6f 7765 7220 3d3d 2075 7070   if lower == upp
+00009200: 6572 2065 6c73 6520 4e6f 6e65 0a0a 0a63  er else None...c
+00009210: 6c61 7373 204e 506f 696e 7473 2841 7272  lass NPoints(Arr
+00009220: 6179 293a 0a20 2020 2027 5468 6520 6c65  ay):.    'The le
+00009230: 6e67 7468 206f 6620 7468 6520 706f 696e  ngth of the poin
+00009240: 7473 2061 7869 732e 270a 0a20 2020 2064  ts axis.'..    d
+00009250: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+00009260: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
+00009270: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
+00009280: 3d28 4556 414c 4152 4753 2c29 2c20 7368  =(EVALARGS,), sh
+00009290: 6170 653d 2829 2c20 6474 7970 653d 696e  ape=(), dtype=in
+000092a0: 7429 0a0a 2020 2020 4073 7461 7469 636d  t)..    @staticm
+000092b0: 6574 686f 640a 2020 2020 6465 6620 6576  ethod.    def ev
+000092c0: 616c 6628 6576 616c 6172 6773 293a 0a20  alf(evalargs):. 
+000092d0: 2020 2020 2020 2070 6f69 6e74 7320 3d20         points = 
+000092e0: 6576 616c 6172 6773 5b27 5f70 6f69 6e74  evalargs['_point
+000092f0: 7327 5d2e 636f 6f72 6473 0a20 2020 2020  s'].coords.     
+00009300: 2020 2072 6574 7572 6e20 7479 7065 732e     return types.
+00009310: 6672 6f7a 656e 6172 7261 7928 706f 696e  frozenarray(poin
+00009320: 7473 2e73 6861 7065 5b30 5d29 0a0a 2020  ts.shape[0])..  
+00009330: 2020 6465 6620 5f69 6e74 626f 756e 6473    def _intbounds
+00009340: 5f69 6d70 6c28 7365 6c66 293a 0a20 2020  _impl(self):.   
+00009350: 2020 2020 2072 6574 7572 6e20 302c 2066       return 0, f
+00009360: 6c6f 6174 2827 696e 6627 290a 0a0a 636c  loat('inf')...cl
+00009370: 6173 7320 506f 696e 7473 2841 7272 6179  ass Points(Array
+00009380: 293a 0a0a 2020 2020 6465 6620 5f5f 696e  ):..    def __in
+00009390: 6974 5f5f 2873 656c 662c 206e 706f 696e  it__(self, npoin
+000093a0: 7473 2c20 6e64 696d 293a 0a20 2020 2020  ts, ndim):.     
+000093b0: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
+000093c0: 745f 5f28 6172 6773 3d28 4556 414c 4152  t__(args=(EVALAR
+000093d0: 4753 2c29 2c20 7368 6170 653d 286e 706f  GS,), shape=(npo
+000093e0: 696e 7473 2c20 6e64 696d 292c 2064 7479  ints, ndim), dty
+000093f0: 7065 3d66 6c6f 6174 290a 0a20 2020 2040  pe=float)..    @
+00009400: 7374 6174 6963 6d65 7468 6f64 0a20 2020  staticmethod.   
+00009410: 2064 6566 2065 7661 6c66 2865 7661 6c61   def evalf(evala
+00009420: 7267 7329 3a0a 2020 2020 2020 2020 7265  rgs):.        re
+00009430: 7475 726e 2065 7661 6c61 7267 735b 275f  turn evalargs['_
+00009440: 706f 696e 7473 275d 2e63 6f6f 7264 730a  points'].coords.
+00009450: 0a0a 636c 6173 7320 5765 6967 6874 7328  ..class Weights(
+00009460: 4172 7261 7929 3a0a 0a20 2020 2064 6566  Array):..    def
+00009470: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+00009480: 6e70 6f69 6e74 7329 3a0a 2020 2020 2020  npoints):.      
+00009490: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
+000094a0: 5f5f 2861 7267 733d 2845 5641 4c41 5247  __(args=(EVALARG
+000094b0: 532c 292c 2073 6861 7065 3d28 6e70 6f69  S,), shape=(npoi
+000094c0: 6e74 732c 292c 2064 7479 7065 3d66 6c6f  nts,), dtype=flo
+000094d0: 6174 290a 0a20 2020 2040 7374 6174 6963  at)..    @static
+000094e0: 6d65 7468 6f64 0a20 2020 2064 6566 2065  method.    def e
+000094f0: 7661 6c66 2865 7661 6c61 7267 7329 3a0a  valf(evalargs):.
+00009500: 2020 2020 2020 2020 7765 6967 6874 7320          weights 
+00009510: 3d20 6576 616c 6172 6773 5b27 5f70 6f69  = evalargs['_poi
+00009520: 6e74 7327 5d2e 7765 6967 6874 730a 2020  nts'].weights.  
+00009530: 2020 2020 2020 6173 7365 7274 206e 756d        assert num
+00009540: 6572 6963 2e69 7361 7272 6179 2877 6569  eric.isarray(wei
+00009550: 6768 7473 2920 616e 6420 7765 6967 6874  ghts) and weight
+00009560: 732e 6e64 696d 203d 3d20 310a 2020 2020  s.ndim == 1.    
+00009570: 2020 2020 7265 7475 726e 2077 6569 6768      return weigh
+00009580: 7473 0a0a 0a63 6c61 7373 204f 7274 686f  ts...class Ortho
+00009590: 6e6f 726d 616c 2841 7272 6179 293a 0a20  normal(Array):. 
+000095a0: 2020 2027 6d61 6b65 2061 2076 6563 746f     'make a vecto
+000095b0: 7220 6f72 7468 6f6e 6f72 6d61 6c20 746f  r orthonormal to
+000095c0: 2061 2073 7562 7370 6163 6527 0a0a 2020   a subspace'..  
+000095d0: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+000095e0: 656c 662c 2062 6173 6973 3a20 4172 7261  elf, basis: Arra
+000095f0: 792c 2076 6563 746f 723a 2041 7272 6179  y, vector: Array
+00009600: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+00009610: 7420 6973 696e 7374 616e 6365 2862 6173  t isinstance(bas
+00009620: 6973 2c20 4172 7261 7929 2061 6e64 2062  is, Array) and b
+00009630: 6173 6973 2e6e 6469 6d20 3e3d 2032 2061  asis.ndim >= 2 a
+00009640: 6e64 2062 6173 6973 2e64 7479 7065 2021  nd basis.dtype !
+00009650: 3d20 636f 6d70 6c65 782c 2066 2762 6173  = complex, f'bas
+00009660: 6973 3d7b 6261 7369 7321 727d 270a 2020  is={basis!r}'.  
+00009670: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+00009680: 6e73 7461 6e63 6528 7665 6374 6f72 2c20  nstance(vector, 
+00009690: 4172 7261 7929 2061 6e64 2076 6563 746f  Array) and vecto
+000096a0: 722e 6e64 696d 203e 3d20 3120 616e 6420  r.ndim >= 1 and 
+000096b0: 7665 6374 6f72 2e64 7479 7065 2021 3d20  vector.dtype != 
+000096c0: 636f 6d70 6c65 782c 2066 2776 6563 746f  complex, f'vecto
+000096d0: 723d 7b76 6563 746f 7221 727d 270a 2020  r={vector!r}'.  
+000096e0: 2020 2020 2020 6173 7365 7274 2065 7175        assert equ
+000096f0: 616c 7368 6170 6528 6261 7369 732e 7368  alshape(basis.sh
+00009700: 6170 655b 3a2d 315d 2c20 7665 6374 6f72  ape[:-1], vector
+00009710: 2e73 6861 7065 290a 2020 2020 2020 2020  .shape).        
+00009720: 7365 6c66 2e5f 6261 7369 7320 3d20 6261  self._basis = ba
+00009730: 7369 730a 2020 2020 2020 2020 7365 6c66  sis.        self
+00009740: 2e5f 7665 6374 6f72 203d 2076 6563 746f  ._vector = vecto
+00009750: 720a 2020 2020 2020 2020 7375 7065 7228  r.        super(
+00009760: 292e 5f5f 696e 6974 5f5f 2861 7267 733d  ).__init__(args=
+00009770: 2862 6173 6973 2c20 7665 6374 6f72 292c  (basis, vector),
+00009780: 2073 6861 7065 3d76 6563 746f 722e 7368   shape=vector.sh
+00009790: 6170 652c 2064 7479 7065 3d66 6c6f 6174  ape, dtype=float
+000097a0: 290a 0a20 2020 2064 6566 205f 7369 6d70  )..    def _simp
+000097b0: 6c69 6669 6564 2873 656c 6629 3a0a 2020  lified(self):.  
+000097c0: 2020 2020 2020 6966 205f 6571 7561 6c73        if _equals
+000097d0: 5f73 6361 6c61 725f 636f 6e73 7461 6e74  _scalar_constant
+000097e0: 2873 656c 662e 7368 6170 655b 2d31 5d2c  (self.shape[-1],
+000097f0: 2031 293a 0a20 2020 2020 2020 2020 2020   1):.           
+00009800: 2072 6574 7572 6e20 5369 676e 2873 656c   return Sign(sel
+00009810: 662e 5f76 6563 746f 7229 0a20 2020 2020  f._vector).     
+00009820: 2020 2062 6173 6973 2c20 7665 6374 6f72     basis, vector
+00009830: 2c20 7768 6572 6520 3d20 756e 616c 6967  , where = unalig
+00009840: 6e28 7365 6c66 2e5f 6261 7369 732c 2073  n(self._basis, s
+00009850: 656c 662e 5f76 6563 746f 722c 206e 6178  elf._vector, nax
+00009860: 6573 3d73 656c 662e 6e64 696d 202d 2031  es=self.ndim - 1
+00009870: 290a 2020 2020 2020 2020 6966 206c 656e  ).        if len
+00009880: 2877 6865 7265 2920 3c20 7365 6c66 2e6e  (where) < self.n
+00009890: 6469 6d20 2d20 313a 0a20 2020 2020 2020  dim - 1:.       
+000098a0: 2020 2020 2072 6574 7572 6e20 616c 6967       return alig
+000098b0: 6e28 4f72 7468 6f6e 6f72 6d61 6c28 6261  n(Orthonormal(ba
+000098c0: 7369 732c 2076 6563 746f 7229 2c20 282a  sis, vector), (*
+000098d0: 7768 6572 652c 2073 656c 662e 6e64 696d  where, self.ndim
+000098e0: 202d 2031 292c 2073 656c 662e 7368 6170   - 1), self.shap
+000098f0: 6529 0a0a 2020 2020 4073 7461 7469 636d  e)..    @staticm
+00009900: 6574 686f 640a 2020 2020 6465 6620 6576  ethod.    def ev
+00009910: 616c 6628 472c 206e 293a 0a20 2020 2020  alf(G, n):.     
+00009920: 2020 2047 4720 3d20 6e75 6d70 792e 6569     GG = numpy.ei
+00009930: 6e73 756d 2827 2e2e 2e6b 692c 2e2e 2e6b  nsum('...ki,...k
+00009940: 6a2d 3e2e 2e2e 696a 272c 2047 2c20 4729  j->...ij', G, G)
+00009950: 0a20 2020 2020 2020 2076 3120 3d20 6e75  .        v1 = nu
+00009960: 6d70 792e 6569 6e73 756d 2827 2e2e 2e69  mpy.einsum('...i
+00009970: 6a2c 2e2e 2e69 2d3e 2e2e 2e6a 272c 2047  j,...i->...j', G
+00009980: 2c20 6e29 0a20 2020 2020 2020 2076 3220  , n).        v2 
+00009990: 3d20 6e75 6d70 792e 6c69 6e61 6c67 2e73  = numpy.linalg.s
+000099a0: 6f6c 7665 2847 472c 2076 3129 0a20 2020  olve(GG, v1).   
+000099b0: 2020 2020 2076 3320 3d20 6e75 6d70 792e       v3 = numpy.
+000099c0: 6569 6e73 756d 2827 2e2e 2e69 6a2c 2e2e  einsum('...ij,..
+000099d0: 2e6a 2d3e 2e2e 2e69 272c 2047 2c20 7632  .j->...i', G, v2
+000099e0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+000099f0: 206e 756d 6572 6963 2e6e 6f72 6d61 6c69   numeric.normali
+00009a00: 7a65 286e 202d 2076 3329 0a0a 2020 2020  ze(n - v3)..    
+00009a10: 6465 6620 5f64 6572 6976 6174 6976 6528  def _derivative(
+00009a20: 7365 6c66 2c20 7661 722c 2073 6565 6e29  self, var, seen)
+00009a30: 3a0a 2020 2020 2020 2020 6966 205f 6571  :.        if _eq
+00009a40: 7561 6c73 5f73 6361 6c61 725f 636f 6e73  uals_scalar_cons
+00009a50: 7461 6e74 2873 656c 662e 7368 6170 655b  tant(self.shape[
+00009a60: 2d31 5d2c 2031 293a 0a20 2020 2020 2020  -1], 1):.       
+00009a70: 2020 2020 2072 6574 7572 6e20 7a65 726f       return zero
+00009a80: 7328 7365 6c66 2e73 6861 7065 202b 2076  s(self.shape + v
+00009a90: 6172 2e73 6861 7065 290a 0a20 2020 2020  ar.shape)..     
+00009aa0: 2020 2023 2064 6566 696e 6974 696f 6e73     # definitions
+00009ab0: 3a0a 2020 2020 2020 2020 230a 2020 2020  :.        #.    
+00009ac0: 2020 2020 2320 5020 3a3d 2049 202d 2047      # P := I - G
+00009ad0: 2028 475e 5420 4729 5e2d 3120 475e 5420   (G^T G)^-1 G^T 
+00009ae0: 286f 7274 686f 676f 6e61 6c20 7072 6f6a  (orthogonal proj
+00009af0: 6563 746f 7229 0a20 2020 2020 2020 2023  ector).        #
+00009b00: 206e 203a 3d20 5020 7620 286f 7274 686f   n := P v (ortho
+00009b10: 676f 6e61 6c20 7072 6f6a 6563 7469 6f6e  gonal projection
+00009b20: 206f 6620 7629 0a20 2020 2020 2020 2023   of v).        #
+00009b30: 204e 203a 3d20 6e20 2f20 7c6e 7c20 2873   N := n / |n| (s
+00009b40: 656c 663a 206f 7274 686f 6e6f 726d 616c  elf: orthonormal
+00009b50: 2070 726f 6a65 6374 696f 6e20 6f66 2076   projection of v
+00009b60: 290a 2020 2020 2020 2020 230a 2020 2020  ).        #.    
+00009b70: 2020 2020 2320 6964 656e 7469 7469 6573      # identities
+00009b80: 3a0a 2020 2020 2020 2020 230a 2020 2020  :.        #.    
+00009b90: 2020 2020 2320 2020 505e 5420 3d20 5020      #   P^T = P 
+00009ba0: 2020 2020 2020 2020 204e 5e54 204e 203d           N^T N =
+00009bb0: 2031 0a20 2020 2020 2020 2023 2020 2050   1.        #   P
+00009bc0: 2050 203d 2050 2020 2020 2020 2020 2020   P = P          
+00009bd0: 5020 4e20 3d20 4e0a 2020 2020 2020 2020  P N = N.        
+00009be0: 2320 2020 5020 4720 3d20 5020 5120 3d20  #   P G = P Q = 
+00009bf0: 3020 2020 2047 5e54 204e 203d 2051 5e54  0    G^T N = Q^T
+00009c00: 204e 203d 2030 0a20 2020 2020 2020 2023   N = 0.        #
+00009c10: 0a20 2020 2020 2020 2023 2064 6572 6976  .        # deriv
+00009c20: 6174 6976 6573 3a0a 2020 2020 2020 2020  atives:.        
+00009c30: 230a 2020 2020 2020 2020 2320 5027 203d  #.        # P' =
+00009c40: 2051 2050 202b 2050 2051 5e54 2077 6865   Q P + P Q^T whe
+00009c50: 7265 2051 203a 3d20 2d47 2028 475e 5420  re Q := -G (G^T 
+00009c60: 4729 5e2d 3120 4727 5e54 0a20 2020 2020  G)^-1 G'^T.     
+00009c70: 2020 2023 206e 2720 3d20 5027 2076 202b     # n' = P' v +
+00009c80: 2050 2076 270a 2020 2020 2020 2020 2320   P v'.        # 
+00009c90: 2020 203d 2051 206e 202b 2050 2028 515e     = Q n + P (Q^
+00009ca0: 5420 7620 2b20 7627 290a 2020 2020 2020  T v + v').      
+00009cb0: 2020 2320 4e27 203d 2028 4920 2d20 4e20    # N' = (I - N 
+00009cc0: 4e5e 5429 206e 2720 2f20 7c6e 7c0a 2020  N^T) n' / |n|.  
+00009cd0: 2020 2020 2020 2320 2020 203d 2028 4920        #    = (I 
+00009ce0: 2d20 4e20 4e5e 5429 2028 5120 6e20 2f20  - N N^T) (Q n / 
+00009cf0: 7c6e 7c20 2b20 5020 2851 5e54 2076 202b  |n| + P (Q^T v +
+00009d00: 2076 2729 202f 207c 6e7c 290a 2020 2020   v') / |n|).    
+00009d10: 2020 2020 2320 2020 203d 2051 204e 202b      #    = Q N +
+00009d20: 2028 5020 2d20 4e20 4e5e 5429 2028 515e   (P - N N^T) (Q^
+00009d30: 5420 7620 2b20 7627 2920 2f20 7c6e 7c0a  T v + v') / |n|.
+00009d40: 0a20 2020 2020 2020 2047 203d 2073 656c  .        G = sel
+00009d50: 662e 5f62 6173 6973 0a20 2020 2020 2020  f._basis.       
+00009d60: 2069 6e76 4747 203d 2069 6e76 6572 7365   invGG = inverse
+00009d70: 2865 696e 7375 6d28 2741 6b69 2c41 6b6a  (einsum('Aki,Akj
+00009d80: 2d3e 4169 6a27 2c20 472c 2047 2929 0a0a  ->Aij', G, G))..
+00009d90: 2020 2020 2020 2020 5120 3d20 2d65 696e          Q = -ein
+00009da0: 7375 6d28 2741 696d 2c41 6d6e 2c41 6a6e  sum('Aim,Amn,Ajn
+00009db0: 422d 3e41 696a 4227 2c20 472c 2069 6e76  B->AijB', G, inv
+00009dc0: 4747 2c20 6465 7269 7661 7469 7665 2847  GG, derivative(G
+00009dd0: 2c20 7661 722c 2073 6565 6e29 290a 2020  , var, seen)).  
+00009de0: 2020 2020 2020 514e 203d 2065 696e 7375        QN = einsu
+00009df0: 6d28 2741 692c 416a 6942 2d3e 416a 4227  m('Ai,AjiB->AjB'
+00009e00: 2c20 7365 6c66 2c20 5129 0a0a 2020 2020  , self, Q)..    
+00009e10: 2020 2020 6966 205f 6571 7561 6c73 5f73      if _equals_s
+00009e20: 696d 706c 6966 6965 6428 472e 7368 6170  implified(G.shap
+00009e30: 655b 2d31 5d2c 2047 2e73 6861 7065 5b2d  e[-1], G.shape[-
+00009e40: 325d 202d 2031 293a 2023 2064 696d 286b  2] - 1): # dim(k
+00009e50: 6572 6e28 4729 2920 3d20 310a 2020 2020  ern(G)) = 1.    
+00009e60: 2020 2020 2020 2020 2320 496e 2074 6869          # In thi
+00009e70: 7320 7369 7475 6174 696f 6e2c 2073 696e  s situation, sin
+00009e80: 6365 204e 2069 7320 6120 6261 7369 7320  ce N is a basis 
+00009e90: 666f 7220 7468 6520 6b65 726e 656c 206f  for the kernel o
+00009ea0: 6620 472c 2077 650a 2020 2020 2020 2020  f G, we.        
+00009eb0: 2020 2020 2320 6861 7665 2074 6865 2069      # have the i
+00009ec0: 6465 6e74 6974 7920 5020 3d3d 204e 204e  dentity P == N N
+00009ed0: 5e54 2077 6869 6368 2063 616e 6365 6c73  ^T which cancels
+00009ee0: 2074 6865 2065 6e74 6972 6520 7365 636f   the entire seco
+00009ef0: 6e64 2074 6572 6d0a 2020 2020 2020 2020  nd term.        
+00009f00: 2020 2020 2320 6f66 204e 2720 616c 6f6e      # of N' alon
+00009f10: 6720 7769 7468 2061 6e79 2072 6566 6572  g with any refer
+00009f20: 656e 6365 2074 6f20 7627 2c20 7265 6475  ence to v', redu
+00009f30: 6369 6e67 2069 7420 746f 204e 2720 3d20  cing it to N' = 
+00009f40: 5120 4e2e 0a20 2020 2020 2020 2020 2020  Q N..           
+00009f50: 2072 6574 7572 6e20 514e 0a0a 2020 2020   return QN..    
+00009f60: 2020 2020 7620 3d20 7365 6c66 2e5f 7665      v = self._ve
+00009f70: 6374 6f72 0a20 2020 2020 2020 2050 203d  ctor.        P =
+00009f80: 2044 6961 676f 6e61 6c69 7a65 286f 6e65   Diagonalize(one
+00009f90: 7328 7365 6c66 2e73 6861 7065 2929 202d  s(self.shape)) -
+00009fa0: 2065 696e 7375 6d28 2741 696d 2c41 6d6e   einsum('Aim,Amn
+00009fb0: 2c41 6a6e 2d3e 4169 6a27 2c20 472c 2069  ,Ajn->Aij', G, i
+00009fc0: 6e76 4747 2c20 4729 0a20 2020 2020 2020  nvGG, G).       
+00009fd0: 205a 203d 2050 202d 2065 696e 7375 6d28   Z = P - einsum(
+00009fe0: 2741 692c 416a 2d3e 4169 6a27 2c20 7365  'Ai,Aj->Aij', se
+00009ff0: 6c66 2c20 7365 6c66 2920 2320 5020 2d20  lf, self) # P - 
+0000a000: 4e20 4e5e 540a 0a20 2020 2020 2020 2072  N N^T..        r
+0000a010: 6574 7572 6e20 514e 202b 2065 696e 7375  eturn QN + einsu
+0000a020: 6d28 2741 2c41 6942 2d3e 4169 4227 2c0a  m('A,AiB->AiB',.
+0000a030: 2020 2020 2020 2020 2020 2020 706f 7765              powe
+0000a040: 7228 6569 6e73 756d 2827 4169 2c41 696a  r(einsum('Ai,Aij
+0000a050: 2c41 6a2d 3e41 272c 2076 2c20 502c 2076  ,Aj->A', v, P, v
+0000a060: 292c 202d 2e35 292c 0a20 2020 2020 2020  ), -.5),.       
+0000a070: 2020 2020 2065 696e 7375 6d28 2741 696a       einsum('Aij
+0000a080: 2c41 6a42 2d3e 4169 4227 2c20 5a2c 2065  ,AjB->AiB', Z, e
+0000a090: 696e 7375 6d28 2741 692c 4169 6a42 2d3e  insum('Ai,AijB->
+0000a0a0: 416a 4227 2c20 762c 2051 2920 2b20 6465  AjB', v, Q) + de
+0000a0b0: 7269 7661 7469 7665 2876 2c20 7661 722c  rivative(v, var,
+0000a0c0: 2073 6565 6e29 2929 0a0a 0a63 6c61 7373   seen)))...class
+0000a0d0: 2043 6f6e 7374 616e 7428 4172 7261 7929   Constant(Array)
+0000a0e0: 3a0a 0a20 2020 2064 6566 205f 5f69 6e69  :..    def __ini
+0000a0f0: 745f 5f28 7365 6c66 2c20 7661 6c75 653a  t__(self, value:
+0000a100: 2074 7970 6573 2e61 7272 6179 6461 7461   types.arraydata
+0000a110: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+0000a120: 7420 6973 696e 7374 616e 6365 2876 616c  t isinstance(val
+0000a130: 7565 2c20 7479 7065 732e 6172 7261 7964  ue, types.arrayd
+0000a140: 6174 6129 2c20 6627 7661 6c75 653d 7b76  ata), f'value={v
+0000a150: 616c 7565 2172 7d27 0a20 2020 2020 2020  alue!r}'.       
+0000a160: 2073 656c 662e 7661 6c75 6520 3d20 6e75   self.value = nu
+0000a170: 6d70 792e 6173 6172 7261 7928 7661 6c75  mpy.asarray(valu
+0000a180: 6529 0a20 2020 2020 2020 2073 7570 6572  e).        super
+0000a190: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
+0000a1a0: 3d28 292c 2073 6861 7065 3d74 7570 6c65  =(), shape=tuple
+0000a1b0: 2863 6f6e 7374 616e 7428 6e29 2066 6f72  (constant(n) for
+0000a1c0: 206e 2069 6e20 7661 6c75 652e 7368 6170   n in value.shap
+0000a1d0: 6529 2c20 6474 7970 653d 7661 6c75 652e  e), dtype=value.
+0000a1e0: 6474 7970 6529 0a0a 2020 2020 6465 6620  dtype)..    def 
+0000a1f0: 5f73 696d 706c 6966 6965 6428 7365 6c66  _simplified(self
+0000a200: 293a 0a20 2020 2020 2020 2069 6620 6e6f  ):.        if no
+0000a210: 7420 7365 6c66 2e76 616c 7565 2e61 6e79  t self.value.any
+0000a220: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+0000a230: 7265 7475 726e 207a 6572 6f73 5f6c 696b  return zeros_lik
+0000a240: 6528 7365 6c66 290a 2020 2020 2020 2020  e(self).        
+0000a250: 6966 2073 656c 662e 6e64 696d 203d 3d20  if self.ndim == 
+0000a260: 3120 616e 6420 7365 6c66 2e64 7479 7065  1 and self.dtype
+0000a270: 203d 3d20 696e 7420 616e 6420 6e75 6d70   == int and nump
+0000a280: 792e 616c 6c28 7365 6c66 2e76 616c 7565  y.all(self.value
+0000a290: 203d 3d20 6e75 6d70 792e 6172 616e 6765   == numpy.arange
+0000a2a0: 2873 656c 662e 7661 6c75 652e 7368 6170  (self.value.shap
+0000a2b0: 655b 305d 2929 3a0a 2020 2020 2020 2020  e[0])):.        
+0000a2c0: 2020 2020 7265 7475 726e 2052 616e 6765      return Range
+0000a2d0: 2873 656c 662e 7368 6170 655b 305d 290a  (self.shape[0]).
+0000a2e0: 2020 2020 2020 2020 666f 7220 692c 2073          for i, s
+0000a2f0: 6820 696e 2065 6e75 6d65 7261 7465 2873  h in enumerate(s
+0000a300: 656c 662e 7368 6170 6529 3a0a 2020 2020  elf.shape):.    
+0000a310: 2020 2020 2020 2020 2320 4669 6e64 2061          # Find a
+0000a320: 6e64 2072 6570 6c61 6365 2069 6e76 6172  nd replace invar
+0000a330: 6961 6e74 2061 7865 7320 7769 7468 2049  iant axes with I
+0000a340: 6e73 6572 7441 7869 732e 2053 696e 6365  nsertAxis. Since
+0000a350: 2060 7365 6c66 2e76 616c 7565 2e61 6e79   `self.value.any
+0000a360: 2829 600a 2020 2020 2020 2020 2020 2020  ()`.            
+0000a370: 2320 6973 2046 616c 7365 2066 6f72 2061  # is False for a
+0000a380: 7272 6179 7320 7769 7468 2061 207a 6572  rrays with a zer
+0000a390: 6f2d 6c65 6e67 7468 2061 7869 732c 2077  o-length axis, w
+0000a3a0: 6520 6361 6e20 6172 7269 7665 2068 6572  e can arrive her
+0000a3b0: 6520 6f6e 6c79 2069 6620 616c 6c0a 2020  e only if all.  
+0000a3c0: 2020 2020 2020 2020 2020 2320 6178 6573            # axes
+0000a3d0: 2068 6176 6520 6174 206c 6561 7374 206c   have at least l
+0000a3e0: 656e 6774 6820 6f6e 652c 2068 656e 6365  ength one, hence
+0000a3f0: 2074 6865 2066 6f6c 6c6f 7769 6e67 2073   the following s
+0000a400: 7461 7465 6d65 6e74 2073 686f 756c 6420  tatement should 
+0000a410: 776f 726b 2e0a 2020 2020 2020 2020 2020  work..          
+0000a420: 2020 6669 7273 742c 202a 6f74 6865 7273    first, *others
+0000a430: 203d 206e 756d 7079 2e72 6f6c 6c61 7869   = numpy.rollaxi
+0000a440: 7328 7365 6c66 2e76 616c 7565 2c20 6929  s(self.value, i)
+0000a450: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000a460: 616c 6c28 6e75 6d70 792e 6571 7561 6c28  all(numpy.equal(
+0000a470: 6669 7273 742c 206f 7468 6572 292e 616c  first, other).al
+0000a480: 6c28 2920 666f 7220 6f74 6865 7220 696e  l() for other in
+0000a490: 206f 7468 6572 7329 3a0a 2020 2020 2020   others):.      
+0000a4a0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000a4b0: 2069 6e73 6572 7461 7869 7328 636f 6e73   insertaxis(cons
+0000a4c0: 7461 6e74 2866 6972 7374 292c 2069 2c20  tant(first), i, 
+0000a4d0: 7368 290a 0a20 2020 2064 6566 2065 7661  sh)..    def eva
+0000a4e0: 6c66 2873 656c 6629 3a0a 2020 2020 2020  lf(self):.      
+0000a4f0: 2020 7265 7475 726e 2073 656c 662e 7661    return self.va
+0000a500: 6c75 650a 0a20 2020 2064 6566 205f 6e6f  lue..    def _no
+0000a510: 6465 2873 656c 662c 2063 6163 6865 2c20  de(self, cache, 
+0000a520: 7375 6267 7261 7068 2c20 7469 6d65 7329  subgraph, times)
+0000a530: 3a0a 2020 2020 2020 2020 6966 2073 656c  :.        if sel
+0000a540: 662e 6e64 696d 3a0a 2020 2020 2020 2020  f.ndim:.        
+0000a550: 2020 2020 7265 7475 726e 2073 7570 6572      return super
+0000a560: 2829 2e5f 6e6f 6465 2863 6163 6865 2c20  ()._node(cache, 
+0000a570: 7375 6267 7261 7068 2c20 7469 6d65 7329  subgraph, times)
+0000a580: 0a20 2020 2020 2020 2065 6c69 6620 7365  .        elif se
+0000a590: 6c66 2069 6e20 6361 6368 653a 0a20 2020  lf in cache:.   
+0000a5a0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000a5b0: 6361 6368 655b 7365 6c66 5d0a 2020 2020  cache[self].    
+0000a5c0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000a5d0: 2020 2020 2020 6c61 6265 6c20 3d20 277b        label = '{
+0000a5e0: 7d27 2e66 6f72 6d61 7428 7365 6c66 2e76  }'.format(self.v
+0000a5f0: 616c 7565 5b28 295d 290a 2020 2020 2020  alue[()]).      
+0000a600: 2020 2020 2020 6966 206c 656e 286c 6162        if len(lab
+0000a610: 656c 2920 3e20 393a 0a20 2020 2020 2020  el) > 9:.       
+0000a620: 2020 2020 2020 2020 206c 6162 656c 203d           label =
+0000a630: 2027 7e7b 3a2e 3265 7d27 2e66 6f72 6d61   '~{:.2e}'.forma
+0000a640: 7428 7365 6c66 2e76 616c 7565 5b28 295d  t(self.value[()]
+0000a650: 290a 2020 2020 2020 2020 2020 2020 6361  ).            ca
+0000a660: 6368 655b 7365 6c66 5d20 3d20 6e6f 6465  che[self] = node
+0000a670: 203d 2044 7570 6c69 6361 7465 644c 6561   = DuplicatedLea
+0000a680: 664e 6f64 6528 6c61 6265 6c2c 2028 7479  fNode(label, (ty
+0000a690: 7065 2873 656c 6629 2e5f 5f6e 616d 655f  pe(self).__name_
+0000a6a0: 5f2c 2074 696d 6573 5b73 656c 665d 2929  _, times[self]))
+0000a6b0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000a6c0: 7572 6e20 6e6f 6465 0a0a 2020 2020 4063  urn node..    @c
+0000a6d0: 6163 6865 645f 7072 6f70 6572 7479 0a20  ached_property. 
+0000a6e0: 2020 2064 6566 205f 6973 756e 6974 2873     def _isunit(s
+0000a6f0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0000a700: 7475 726e 206e 756d 7079 2e65 7175 616c  turn numpy.equal
+0000a710: 2873 656c 662e 7661 6c75 652c 2031 292e  (self.value, 1).
+0000a720: 616c 6c28 290a 0a20 2020 2064 6566 205f  all()..    def _
+0000a730: 7472 616e 7370 6f73 6528 7365 6c66 2c20  transpose(self, 
+0000a740: 6178 6573 293a 0a20 2020 2020 2020 2072  axes):.        r
+0000a750: 6574 7572 6e20 636f 6e73 7461 6e74 2873  eturn constant(s
+0000a760: 656c 662e 7661 6c75 652e 7472 616e 7370  elf.value.transp
+0000a770: 6f73 6528 6178 6573 2929 0a0a 2020 2020  ose(axes))..    
+0000a780: 6465 6620 5f73 756d 2873 656c 662c 2061  def _sum(self, a
+0000a790: 7869 7329 3a0a 2020 2020 2020 2020 7265  xis):.        re
+0000a7a0: 7475 726e 2063 6f6e 7374 616e 7428 6e75  turn constant(nu
+0000a7b0: 6d70 792e 7375 6d28 7365 6c66 2e76 616c  mpy.sum(self.val
+0000a7c0: 7565 2c20 6178 6973 2929 0a0a 2020 2020  ue, axis))..    
+0000a7d0: 6465 6620 5f61 6464 2873 656c 662c 206f  def _add(self, o
+0000a7e0: 7468 6572 293a 0a20 2020 2020 2020 2069  ther):.        i
+0000a7f0: 6620 6973 696e 7374 616e 6365 286f 7468  f isinstance(oth
+0000a800: 6572 2c20 436f 6e73 7461 6e74 293a 0a20  er, Constant):. 
+0000a810: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000a820: 6e20 636f 6e73 7461 6e74 286e 756d 7079  n constant(numpy
+0000a830: 2e61 6464 2873 656c 662e 7661 6c75 652c  .add(self.value,
+0000a840: 206f 7468 6572 2e76 616c 7565 2929 0a0a   other.value))..
+0000a850: 2020 2020 6465 6620 5f69 6e76 6572 7365      def _inverse
+0000a860: 2873 656c 662c 2061 7869 7331 2c20 6178  (self, axis1, ax
+0000a870: 6973 3229 3a0a 2020 2020 2020 2020 6173  is2):.        as
+0000a880: 7365 7274 2030 203c 3d20 6178 6973 3120  sert 0 <= axis1 
+0000a890: 3c20 6178 6973 3220 3c20 7365 6c66 2e6e  < axis2 < self.n
+0000a8a0: 6469 6d0a 2020 2020 2020 2020 6178 6573  dim.        axes
+0000a8b0: 203d 2028 2a72 616e 6765 2861 7869 7331   = (*range(axis1
+0000a8c0: 292c 202a 7261 6e67 6528 6178 6973 312b  ), *range(axis1+
+0000a8d0: 312c 2061 7869 7332 292c 202a 7261 6e67  1, axis2), *rang
+0000a8e0: 6528 6178 6973 322b 312c 2073 656c 662e  e(axis2+1, self.
+0000a8f0: 6e64 696d 292c 2061 7869 7331 2c20 6178  ndim), axis1, ax
+0000a900: 6973 3229 0a20 2020 2020 2020 2076 616c  is2).        val
+0000a910: 7565 203d 206e 756d 7079 2e74 7261 6e73  ue = numpy.trans
+0000a920: 706f 7365 2873 656c 662e 7661 6c75 652c  pose(self.value,
+0000a930: 2061 7865 7329 0a20 2020 2020 2020 2072   axes).        r
+0000a940: 6574 7572 6e20 636f 6e73 7461 6e74 286e  eturn constant(n
+0000a950: 756d 7079 2e74 7261 6e73 706f 7365 286e  umpy.transpose(n
+0000a960: 756d 7079 2e6c 696e 616c 672e 696e 7628  umpy.linalg.inv(
+0000a970: 7661 6c75 6529 2c20 6e75 6d70 792e 6172  value), numpy.ar
+0000a980: 6773 6f72 7428 6178 6573 2929 290a 0a20  gsort(axes))).. 
+0000a990: 2020 2064 6566 205f 7072 6f64 7563 7428     def _product(
+0000a9a0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+0000a9b0: 6574 7572 6e20 636f 6e73 7461 6e74 2873  eturn constant(s
+0000a9c0: 656c 662e 7661 6c75 652e 7072 6f64 282d  elf.value.prod(-
+0000a9d0: 3129 290a 0a20 2020 2064 6566 205f 6d75  1))..    def _mu
+0000a9e0: 6c74 6970 6c79 2873 656c 662c 206f 7468  ltiply(self, oth
+0000a9f0: 6572 293a 0a20 2020 2020 2020 2069 6620  er):.        if 
+0000aa00: 7365 6c66 2e5f 6973 756e 6974 3a0a 2020  self._isunit:.  
+0000aa10: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000aa20: 206f 7468 6572 0a20 2020 2020 2020 2069   other.        i
+0000aa30: 6620 6973 696e 7374 616e 6365 286f 7468  f isinstance(oth
+0000aa40: 6572 2c20 436f 6e73 7461 6e74 293a 0a20  er, Constant):. 
+0000aa50: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000aa60: 6e20 636f 6e73 7461 6e74 286e 756d 7079  n constant(numpy
+0000aa70: 2e6d 756c 7469 706c 7928 7365 6c66 2e76  .multiply(self.v
+0000aa80: 616c 7565 2c20 6f74 6865 722e 7661 6c75  alue, other.valu
+0000aa90: 6529 290a 0a20 2020 2064 6566 205f 7461  e))..    def _ta
+0000aaa0: 6b65 6469 6167 2873 656c 662c 2061 7869  kediag(self, axi
+0000aab0: 7331 2c20 6178 6973 3229 3a0a 2020 2020  s1, axis2):.    
+0000aac0: 2020 2020 6173 7365 7274 2061 7869 7331      assert axis1
+0000aad0: 203c 2061 7869 7332 0a20 2020 2020 2020   < axis2.       
+0000aae0: 2072 6574 7572 6e20 636f 6e73 7461 6e74   return constant
+0000aaf0: 286e 756d 7079 2e65 696e 7375 6d28 272e  (numpy.einsum('.
+0000ab00: 2e2e 6b6b 2d3e 2e2e 2e6b 272c 206e 756d  ..kk->...k', num
+0000ab10: 7079 2e74 7261 6e73 706f 7365 2873 656c  py.transpose(sel
+0000ab20: 662e 7661 6c75 652c 0a20 2020 2020 2020  f.value,.       
+0000ab30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab60: 2020 2020 2020 2020 2020 2020 206c 6973               lis
+0000ab70: 7428 7261 6e67 6528 6178 6973 3129 2920  t(range(axis1)) 
+0000ab80: 2b20 6c69 7374 2872 616e 6765 2861 7869  + list(range(axi
+0000ab90: 7331 2b31 2c20 6178 6973 3229 2920 2b20  s1+1, axis2)) + 
+0000aba0: 6c69 7374 2872 616e 6765 2861 7869 7332  list(range(axis2
+0000abb0: 2b31 2c20 7365 6c66 2e6e 6469 6d29 2920  +1, self.ndim)) 
+0000abc0: 2b20 5b61 7869 7331 2c20 6178 6973 325d  + [axis1, axis2]
+0000abd0: 2929 290a 0a20 2020 2064 6566 205f 7461  )))..    def _ta
+0000abe0: 6b65 2873 656c 662c 2069 6e64 6578 2c20  ke(self, index, 
+0000abf0: 6178 6973 293a 0a20 2020 2020 2020 2069  axis):.        i
+0000ac00: 6620 696e 6465 782e 6973 636f 6e73 7461  f index.isconsta
+0000ac10: 6e74 3a0a 2020 2020 2020 2020 2020 2020  nt:.            
+0000ac20: 696e 6465 785f 203d 2069 6e64 6578 2e65  index_ = index.e
+0000ac30: 7661 6c28 290a 2020 2020 2020 2020 2020  val().          
+0000ac40: 2020 7265 7475 726e 2063 6f6e 7374 616e    return constan
+0000ac50: 7428 7365 6c66 2e76 616c 7565 2e74 616b  t(self.value.tak
+0000ac60: 6528 696e 6465 785f 2c20 6178 6973 2929  e(index_, axis))
+0000ac70: 0a0a 2020 2020 6465 6620 5f70 6f77 6572  ..    def _power
+0000ac80: 2873 656c 662c 206e 293a 0a20 2020 2020  (self, n):.     
+0000ac90: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+0000aca0: 286e 2c20 436f 6e73 7461 6e74 293a 0a20  (n, Constant):. 
+0000acb0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000acc0: 6e20 636f 6e73 7461 6e74 286e 756d 7079  n constant(numpy
+0000acd0: 2e70 6f77 6572 2873 656c 662e 7661 6c75  .power(self.valu
+0000ace0: 652c 206e 2e76 616c 7565 2929 0a0a 2020  e, n.value))..  
+0000acf0: 2020 6465 6620 5f65 6967 2873 656c 662c    def _eig(self,
+0000ad00: 2073 796d 6d65 7472 6963 293a 0a20 2020   symmetric):.   
+0000ad10: 2020 2020 2065 6967 7661 6c2c 2065 6967       eigval, eig
+0000ad20: 7665 6320 3d20 286e 756d 7079 2e6c 696e  vec = (numpy.lin
+0000ad30: 616c 672e 6569 6768 2069 6620 7379 6d6d  alg.eigh if symm
+0000ad40: 6574 7269 6320 656c 7365 206e 756d 7079  etric else numpy
+0000ad50: 2e6c 696e 616c 672e 6569 6729 2873 656c  .linalg.eig)(sel
+0000ad60: 662e 7661 6c75 6529 0a20 2020 2020 2020  f.value).       
+0000ad70: 2069 6620 6e6f 7420 7379 6d6d 6574 7269   if not symmetri
+0000ad80: 633a 0a20 2020 2020 2020 2020 2020 2065  c:.            e
+0000ad90: 6967 7661 6c20 3d20 6569 6776 616c 2e61  igval = eigval.a
+0000ada0: 7374 7970 6528 636f 6d70 6c65 782c 2063  stype(complex, c
+0000adb0: 6f70 793d 4661 6c73 6529 0a20 2020 2020  opy=False).     
+0000adc0: 2020 2020 2020 2065 6967 7665 6320 3d20         eigvec = 
+0000add0: 6569 6776 6563 2e61 7374 7970 6528 636f  eigvec.astype(co
+0000ade0: 6d70 6c65 782c 2063 6f70 793d 4661 6c73  mplex, copy=Fals
+0000adf0: 6529 0a20 2020 2020 2020 2072 6574 7572  e).        retur
+0000ae00: 6e20 5475 706c 6528 2863 6f6e 7374 616e  n Tuple((constan
+0000ae10: 7428 6569 6776 616c 292c 2063 6f6e 7374  t(eigval), const
+0000ae20: 616e 7428 6569 6776 6563 2929 290a 0a20  ant(eigvec))).. 
+0000ae30: 2020 2064 6566 205f 7369 676e 2873 656c     def _sign(sel
+0000ae40: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+0000ae50: 726e 2063 6f6e 7374 616e 7428 6e75 6d70  rn constant(nump
+0000ae60: 792e 7369 676e 2873 656c 662e 7661 6c75  y.sign(self.valu
+0000ae70: 6529 290a 0a20 2020 2064 6566 205f 756e  e))..    def _un
+0000ae80: 7261 7665 6c28 7365 6c66 2c20 6178 6973  ravel(self, axis
+0000ae90: 2c20 7368 6170 6529 3a0a 2020 2020 2020  , shape):.      
+0000aea0: 2020 7368 6170 6520 3d20 7365 6c66 2e76    shape = self.v
+0000aeb0: 616c 7565 2e73 6861 7065 5b3a 6178 6973  alue.shape[:axis
+0000aec0: 5d20 2b20 7368 6170 6520 2b20 7365 6c66  ] + shape + self
+0000aed0: 2e76 616c 7565 2e73 6861 7065 5b61 7869  .value.shape[axi
+0000aee0: 732b 313a 5d0a 2020 2020 2020 2020 7265  s+1:].        re
+0000aef0: 7475 726e 2063 6f6e 7374 616e 7428 7365  turn constant(se
+0000af00: 6c66 2e76 616c 7565 2e72 6573 6861 7065  lf.value.reshape
+0000af10: 2873 6861 7065 2929 0a0a 2020 2020 6465  (shape))..    de
+0000af20: 6620 5f64 6574 6572 6d69 6e61 6e74 2873  f _determinant(s
+0000af30: 656c 662c 2061 7869 7331 2c20 6178 6973  elf, axis1, axis
+0000af40: 3229 3a0a 2020 2020 2020 2020 7661 6c75  2):.        valu
+0000af50: 6520 3d20 6e75 6d70 792e 7472 616e 7370  e = numpy.transp
+0000af60: 6f73 6528 7365 6c66 2e76 616c 7565 2c20  ose(self.value, 
+0000af70: 7475 706c 6528 6920 666f 7220 6920 696e  tuple(i for i in
+0000af80: 2072 616e 6765 2873 656c 662e 6e64 696d   range(self.ndim
+0000af90: 2920 6966 2069 2021 3d20 6178 6973 3120  ) if i != axis1 
+0000afa0: 616e 6420 6920 213d 2061 7869 7332 2920  and i != axis2) 
+0000afb0: 2b20 2861 7869 7331 2c20 6178 6973 3229  + (axis1, axis2)
+0000afc0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0000afd0: 2063 6f6e 7374 616e 7428 6e75 6d70 792e   constant(numpy.
+0000afe0: 6c69 6e61 6c67 2e64 6574 2876 616c 7565  linalg.det(value
+0000aff0: 2929 0a0a 2020 2020 6465 6620 5f69 6e74  ))..    def _int
+0000b000: 626f 756e 6473 5f69 6d70 6c28 7365 6c66  bounds_impl(self
+0000b010: 293a 0a20 2020 2020 2020 2069 6620 7365  ):.        if se
+0000b020: 6c66 2e64 7479 7065 203d 3d20 696e 7420  lf.dtype == int 
+0000b030: 616e 6420 7365 6c66 2e76 616c 7565 2e73  and self.value.s
+0000b040: 697a 653a 0a20 2020 2020 2020 2020 2020  ize:.           
+0000b050: 2072 6574 7572 6e20 696e 7428 7365 6c66   return int(self
+0000b060: 2e76 616c 7565 2e6d 696e 2829 292c 2069  .value.min()), i
+0000b070: 6e74 2873 656c 662e 7661 6c75 652e 6d61  nt(self.value.ma
+0000b080: 7828 2929 0a20 2020 2020 2020 2065 6c73  x()).        els
+0000b090: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+0000b0a0: 6574 7572 6e20 7375 7065 7228 292e 5f69  eturn super()._i
+0000b0b0: 6e74 626f 756e 6473 5f69 6d70 6c28 290a  ntbounds_impl().
+0000b0c0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+0000b0d0: 2020 2064 6566 205f 636f 6e73 745f 756e     def _const_un
+0000b0e0: 6966 6f72 6d28 7365 6c66 293a 0a20 2020  iform(self):.   
+0000b0f0: 2020 2020 2069 6620 7365 6c66 2e6e 6469       if self.ndi
+0000b100: 6d20 3d3d 2030 3a0a 2020 2020 2020 2020  m == 0:.        
+0000b110: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0000b120: 6474 7970 6528 7365 6c66 2e76 616c 7565  dtype(self.value
+0000b130: 5b28 295d 290a 0a0a 636c 6173 7320 496e  [()])...class In
+0000b140: 7365 7274 4178 6973 2841 7272 6179 293a  sertAxis(Array):
+0000b150: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
+0000b160: 5f5f 2873 656c 662c 2066 756e 633a 2041  __(self, func: A
+0000b170: 7272 6179 2c20 6c65 6e67 7468 3a20 4172  rray, length: Ar
+0000b180: 7261 7929 3a0a 2020 2020 2020 2020 6173  ray):.        as
+0000b190: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
+0000b1a0: 6675 6e63 2c20 4172 7261 7929 2c20 6627  func, Array), f'
+0000b1b0: 6675 6e63 3d7b 6675 6e63 2172 7d27 0a20  func={func!r}'. 
+0000b1c0: 2020 2020 2020 2061 7373 6572 7420 5f69         assert _i
+0000b1d0: 7369 6e64 6578 286c 656e 6774 6829 2c20  sindex(length), 
+0000b1e0: 6627 6c65 6e67 7468 3d7b 6c65 6e67 7468  f'length={length
+0000b1f0: 2172 7d27 0a20 2020 2020 2020 2073 656c  !r}'.        sel
+0000b200: 662e 6675 6e63 203d 2066 756e 630a 2020  f.func = func.  
+0000b210: 2020 2020 2020 7365 6c66 2e6c 656e 6774        self.lengt
+0000b220: 6820 3d20 6c65 6e67 7468 0a20 2020 2020  h = length.     
+0000b230: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
+0000b240: 745f 5f28 6172 6773 3d28 6675 6e63 2c20  t__(args=(func, 
+0000b250: 6c65 6e67 7468 292c 2073 6861 7065 3d28  length), shape=(
+0000b260: 2a66 756e 632e 7368 6170 652c 206c 656e  *func.shape, len
+0000b270: 6774 6829 2c20 6474 7970 653d 6675 6e63  gth), dtype=func
+0000b280: 2e64 7479 7065 290a 0a20 2020 2040 7072  .dtype)..    @pr
+0000b290: 6f70 6572 7479 0a20 2020 2064 6566 205f  operty.    def _
+0000b2a0: 6469 6167 6f6e 616c 7328 7365 6c66 293a  diagonals(self):
+0000b2b0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000b2c0: 7365 6c66 2e66 756e 632e 5f64 6961 676f  self.func._diago
+0000b2d0: 6e61 6c73 0a0a 2020 2020 4063 6163 6865  nals..    @cache
+0000b2e0: 645f 7072 6f70 6572 7479 0a20 2020 2064  d_property.    d
+0000b2f0: 6566 205f 696e 666c 6174 696f 6e73 2873  ef _inflations(s
+0000b300: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0000b310: 7475 726e 2074 7570 6c65 2828 6178 6973  turn tuple((axis
+0000b320: 2c20 7479 7065 732e 6672 6f7a 656e 6469  , types.frozendi
+0000b330: 6374 2828 646f 666d 6170 2c20 496e 7365  ct((dofmap, Inse
+0000b340: 7274 4178 6973 2866 756e 632c 2073 656c  rtAxis(func, sel
+0000b350: 662e 6c65 6e67 7468 2929 2066 6f72 2064  f.length)) for d
+0000b360: 6f66 6d61 702c 2066 756e 6320 696e 2070  ofmap, func in p
+0000b370: 6172 7473 2e69 7465 6d73 2829 2929 2066  arts.items())) f
+0000b380: 6f72 2061 7869 732c 2070 6172 7473 2069  or axis, parts i
+0000b390: 6e20 7365 6c66 2e66 756e 632e 5f69 6e66  n self.func._inf
+0000b3a0: 6c61 7469 6f6e 7329 0a0a 2020 2020 4063  lations)..    @c
+0000b3b0: 6163 6865 645f 7072 6f70 6572 7479 0a20  ached_property. 
+0000b3c0: 2020 2064 6566 205f 756e 616c 6967 6e65     def _unaligne
+0000b3d0: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
+0000b3e0: 2072 6574 7572 6e20 7365 6c66 2e66 756e   return self.fun
+0000b3f0: 632e 5f75 6e61 6c69 676e 6564 0a0a 2020  c._unaligned..  
+0000b400: 2020 6465 6620 5f73 696d 706c 6966 6965    def _simplifie
+0000b410: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
+0000b420: 2069 6620 5f65 7175 616c 735f 7363 616c   if _equals_scal
+0000b430: 6172 5f63 6f6e 7374 616e 7428 7365 6c66  ar_constant(self
+0000b440: 2e6c 656e 6774 682c 2030 293a 0a20 2020  .length, 0):.   
+0000b450: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000b460: 7a65 726f 735f 6c69 6b65 2873 656c 6629  zeros_like(self)
+0000b470: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000b480: 7365 6c66 2e66 756e 632e 5f69 6e73 6572  self.func._inser
+0000b490: 7461 7869 7328 7365 6c66 2e6e 6469 6d2d  taxis(self.ndim-
+0000b4a0: 312c 2073 656c 662e 6c65 6e67 7468 290a  1, self.length).
+0000b4b0: 0a20 2020 2040 7374 6174 6963 6d65 7468  .    @staticmeth
+0000b4c0: 6f64 0a20 2020 2064 6566 2065 7661 6c66  od.    def evalf
+0000b4d0: 2866 756e 632c 206c 656e 6774 6829 3a0a  (func, length):.
+0000b4e0: 2020 2020 2020 2020 6966 206c 656e 6774          if lengt
+0000b4f0: 6820 3d3d 2031 3a0a 2020 2020 2020 2020  h == 1:.        
+0000b500: 2020 2020 7265 7475 726e 2066 756e 635b      return func[
+0000b510: 2e2e 2e2c 206e 756d 7079 2e6e 6577 6178  ..., numpy.newax
+0000b520: 6973 5d0a 2020 2020 2020 2020 7472 793a  is].        try:
+0000b530: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000b540: 7572 6e20 6e75 6d70 792e 6e64 6172 7261  urn numpy.ndarra
+0000b550: 7928 6275 6666 6572 3d66 756e 632c 2064  y(buffer=func, d
+0000b560: 7479 7065 3d66 756e 632e 6474 7970 652c  type=func.dtype,
+0000b570: 2073 6861 7065 3d28 2a66 756e 632e 7368   shape=(*func.sh
+0000b580: 6170 652c 206c 656e 6774 6829 2c20 7374  ape, length), st
+0000b590: 7269 6465 733d 282a 6675 6e63 2e73 7472  rides=(*func.str
+0000b5a0: 6964 6573 2c20 3029 290a 2020 2020 2020  ides, 0)).      
+0000b5b0: 2020 6578 6365 7074 2056 616c 7565 4572    except ValueEr
+0000b5c0: 726f 723a 2020 2320 6e6f 6e2d 636f 6e74  ror:  # non-cont
+0000b5d0: 6967 756f 7573 2064 6174 610a 2020 2020  iguous data.    
+0000b5e0: 2020 2020 2020 2020 7265 7475 726e 206e          return n
+0000b5f0: 756d 7079 2e72 6570 6561 7428 6675 6e63  umpy.repeat(func
+0000b600: 5b2e 2e2e 2c20 6e75 6d70 792e 6e65 7761  [..., numpy.newa
+0000b610: 7869 735d 2c20 6c65 6e67 7468 2c20 2d31  xis], length, -1
+0000b620: 290a 0a20 2020 2064 6566 205f 6465 7269  )..    def _deri
+0000b630: 7661 7469 7665 2873 656c 662c 2076 6172  vative(self, var
+0000b640: 2c20 7365 656e 293a 0a20 2020 2020 2020  , seen):.       
+0000b650: 2072 6574 7572 6e20 696e 7365 7274 6178   return insertax
+0000b660: 6973 2864 6572 6976 6174 6976 6528 7365  is(derivative(se
+0000b670: 6c66 2e66 756e 632c 2076 6172 2c20 7365  lf.func, var, se
+0000b680: 656e 292c 2073 656c 662e 6e64 696d 2d31  en), self.ndim-1
+0000b690: 2c20 7365 6c66 2e6c 656e 6774 6829 0a0a  , self.length)..
+0000b6a0: 2020 2020 6465 6620 5f73 756d 2873 656c      def _sum(sel
+0000b6b0: 662c 2069 293a 0a20 2020 2020 2020 2069  f, i):.        i
+0000b6c0: 6620 6920 3d3d 2073 656c 662e 6e64 696d  f i == self.ndim
+0000b6d0: 202d 2031 3a0a 2020 2020 2020 2020 2020   - 1:.          
+0000b6e0: 2020 7265 7475 726e 2073 656c 662e 6675    return self.fu
+0000b6f0: 6e63 202a 2073 656c 662e 6c65 6e67 7468  nc * self.length
+0000b700: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000b710: 496e 7365 7274 4178 6973 2873 756d 2873  InsertAxis(sum(s
+0000b720: 656c 662e 6675 6e63 2c20 6929 2c20 7365  elf.func, i), se
+0000b730: 6c66 2e6c 656e 6774 6829 0a0a 2020 2020  lf.length)..    
+0000b740: 6465 6620 5f70 726f 6475 6374 2873 656c  def _product(sel
+0000b750: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+0000b760: 726e 2073 656c 662e 6675 6e63 2a2a 7365  rn self.func**se
+0000b770: 6c66 2e6c 656e 6774 680a 0a20 2020 2064  lf.length..    d
+0000b780: 6566 205f 706f 7765 7228 7365 6c66 2c20  ef _power(self, 
+0000b790: 6e29 3a0a 2020 2020 2020 2020 756e 616c  n):.        unal
+0000b7a0: 6967 6e65 6431 2c20 756e 616c 6967 6e65  igned1, unaligne
+0000b7b0: 6432 2c20 7768 6572 6520 3d20 756e 616c  d2, where = unal
+0000b7c0: 6967 6e28 7365 6c66 2c20 6e29 0a20 2020  ign(self, n).   
+0000b7d0: 2020 2020 2069 6620 6c65 6e28 7768 6572       if len(wher
+0000b7e0: 6529 2021 3d20 7365 6c66 2e6e 6469 6d3a  e) != self.ndim:
+0000b7f0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000b800: 7572 6e20 616c 6967 6e28 756e 616c 6967  urn align(unalig
+0000b810: 6e65 6431 202a 2a20 756e 616c 6967 6e65  ned1 ** unaligne
+0000b820: 6432 2c20 7768 6572 652c 2073 656c 662e  d2, where, self.
+0000b830: 7368 6170 6529 0a0a 2020 2020 6465 6620  shape)..    def 
+0000b840: 5f61 6464 2873 656c 662c 206f 7468 6572  _add(self, other
+0000b850: 293a 0a20 2020 2020 2020 2075 6e61 6c69  ):.        unali
+0000b860: 676e 6564 312c 2075 6e61 6c69 676e 6564  gned1, unaligned
+0000b870: 322c 2077 6865 7265 203d 2075 6e61 6c69  2, where = unali
+0000b880: 676e 2873 656c 662c 206f 7468 6572 290a  gn(self, other).
+0000b890: 2020 2020 2020 2020 6966 206c 656e 2877          if len(w
+0000b8a0: 6865 7265 2920 213d 2073 656c 662e 6e64  here) != self.nd
+0000b8b0: 696d 3a0a 2020 2020 2020 2020 2020 2020  im:.            
+0000b8c0: 7265 7475 726e 2061 6c69 676e 2875 6e61  return align(una
+0000b8d0: 6c69 676e 6564 3120 2b20 756e 616c 6967  ligned1 + unalig
+0000b8e0: 6e65 6432 2c20 7768 6572 652c 2073 656c  ned2, where, sel
+0000b8f0: 662e 7368 6170 6529 0a0a 2020 2020 6465  f.shape)..    de
+0000b900: 6620 5f6d 756c 7469 706c 7928 7365 6c66  f _multiply(self
+0000b910: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+0000b920: 2020 756e 616c 6967 6e65 6431 2c20 756e    unaligned1, un
+0000b930: 616c 6967 6e65 6432 2c20 7768 6572 6520  aligned2, where 
+0000b940: 3d20 756e 616c 6967 6e28 7365 6c66 2c20  = unalign(self, 
+0000b950: 6f74 6865 7229 0a20 2020 2020 2020 2069  other).        i
+0000b960: 6620 6c65 6e28 7768 6572 6529 2021 3d20  f len(where) != 
+0000b970: 7365 6c66 2e6e 6469 6d3a 0a20 2020 2020  self.ndim:.     
+0000b980: 2020 2020 2020 2072 6574 7572 6e20 616c         return al
+0000b990: 6967 6e28 756e 616c 6967 6e65 6431 202a  ign(unaligned1 *
+0000b9a0: 2075 6e61 6c69 676e 6564 322c 2077 6865   unaligned2, whe
+0000b9b0: 7265 2c20 7365 6c66 2e73 6861 7065 290a  re, self.shape).
+0000b9c0: 0a20 2020 2064 6566 205f 6469 6167 6f6e  .    def _diagon
+0000b9d0: 616c 697a 6528 7365 6c66 2c20 6178 6973  alize(self, axis
+0000b9e0: 293a 0a20 2020 2020 2020 2069 6620 6178  ):.        if ax
+0000b9f0: 6973 203c 2073 656c 662e 6e64 696d 202d  is < self.ndim -
+0000ba00: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+0000ba10: 7265 7475 726e 2069 6e73 6572 7461 7869  return insertaxi
+0000ba20: 7328 6469 6167 6f6e 616c 697a 6528 7365  s(diagonalize(se
+0000ba30: 6c66 2e66 756e 632c 2061 7869 732c 2073  lf.func, axis, s
+0000ba40: 656c 662e 6e64 696d 202d 2031 292c 2073  elf.ndim - 1), s
+0000ba50: 656c 662e 6e64 696d 202d 2031 2c20 7365  elf.ndim - 1, se
+0000ba60: 6c66 2e6c 656e 6774 6829 0a0a 2020 2020  lf.length)..    
+0000ba70: 6465 6620 5f69 6e66 6c61 7465 2873 656c  def _inflate(sel
+0000ba80: 662c 2064 6f66 6d61 702c 206c 656e 6774  f, dofmap, lengt
+0000ba90: 682c 2061 7869 7329 3a0a 2020 2020 2020  h, axis):.      
+0000baa0: 2020 6966 2061 7869 7320 2b20 646f 666d    if axis + dofm
+0000bab0: 6170 2e6e 6469 6d20 3c20 7365 6c66 2e6e  ap.ndim < self.n
+0000bac0: 6469 6d3a 0a20 2020 2020 2020 2020 2020  dim:.           
+0000bad0: 2072 6574 7572 6e20 496e 7365 7274 4178   return InsertAx
+0000bae0: 6973 285f 696e 666c 6174 6528 7365 6c66  is(_inflate(self
+0000baf0: 2e66 756e 632c 2064 6f66 6d61 702c 206c  .func, dofmap, l
+0000bb00: 656e 6774 682c 2061 7869 7329 2c20 7365  ength, axis), se
+0000bb10: 6c66 2e6c 656e 6774 6829 0a20 2020 2020  lf.length).     
+0000bb20: 2020 2065 6c69 6620 6178 6973 203d 3d20     elif axis == 
+0000bb30: 7365 6c66 2e6e 6469 6d3a 0a20 2020 2020  self.ndim:.     
+0000bb40: 2020 2020 2020 2072 6574 7572 6e20 696e         return in
+0000bb50: 7365 7274 6178 6973 2849 6e66 6c61 7465  sertaxis(Inflate
+0000bb60: 2873 656c 662e 6675 6e63 2c20 646f 666d  (self.func, dofm
+0000bb70: 6170 2c20 6c65 6e67 7468 292c 2073 656c  ap, length), sel
+0000bb80: 662e 6e64 696d 202d 2031 2c20 7365 6c66  f.ndim - 1, self
+0000bb90: 2e6c 656e 6774 6829 0a0a 2020 2020 6465  .length)..    de
+0000bba0: 6620 5f69 6e73 6572 7461 7869 7328 7365  f _insertaxis(se
+0000bbb0: 6c66 2c20 6178 6973 2c20 6c65 6e67 7468  lf, axis, length
+0000bbc0: 293a 0a20 2020 2020 2020 2069 6620 6178  ):.        if ax
+0000bbd0: 6973 203d 3d20 7365 6c66 2e6e 6469 6d20  is == self.ndim 
+0000bbe0: 2d20 313a 0a20 2020 2020 2020 2020 2020  - 1:.           
+0000bbf0: 2072 6574 7572 6e20 496e 7365 7274 4178   return InsertAx
+0000bc00: 6973 2849 6e73 6572 7441 7869 7328 7365  is(InsertAxis(se
+0000bc10: 6c66 2e66 756e 632c 206c 656e 6774 6829  lf.func, length)
+0000bc20: 2c20 7365 6c66 2e6c 656e 6774 6829 0a0a  , self.length)..
+0000bc30: 2020 2020 6465 6620 5f74 616b 6528 7365      def _take(se
+0000bc40: 6c66 2c20 696e 6465 782c 2061 7869 7329  lf, index, axis)
+0000bc50: 3a0a 2020 2020 2020 2020 6966 2061 7869  :.        if axi
+0000bc60: 7320 3d3d 2073 656c 662e 6e64 696d 202d  s == self.ndim -
+0000bc70: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+0000bc80: 7265 7475 726e 2061 7070 656e 6461 7865  return appendaxe
+0000bc90: 7328 7365 6c66 2e66 756e 632c 2069 6e64  s(self.func, ind
+0000bca0: 6578 2e73 6861 7065 290a 2020 2020 2020  ex.shape).      
+0000bcb0: 2020 7265 7475 726e 2049 6e73 6572 7441    return InsertA
+0000bcc0: 7869 7328 5f74 616b 6528 7365 6c66 2e66  xis(_take(self.f
+0000bcd0: 756e 632c 2069 6e64 6578 2c20 6178 6973  unc, index, axis
+0000bce0: 292c 2073 656c 662e 6c65 6e67 7468 290a  ), self.length).
+0000bcf0: 0a20 2020 2064 6566 205f 7461 6b65 6469  .    def _takedi
+0000bd00: 6167 2873 656c 662c 2061 7869 7331 2c20  ag(self, axis1, 
+0000bd10: 6178 6973 3229 3a0a 2020 2020 2020 2020  axis2):.        
+0000bd20: 6173 7365 7274 2061 7869 7331 203c 2061  assert axis1 < a
+0000bd30: 7869 7332 0a20 2020 2020 2020 2069 6620  xis2.        if 
+0000bd40: 6178 6973 3220 3d3d 2073 656c 662e 6e64  axis2 == self.nd
+0000bd50: 696d 2d31 3a0a 2020 2020 2020 2020 2020  im-1:.          
+0000bd60: 2020 7265 7475 726e 2054 7261 6e73 706f    return Transpo
+0000bd70: 7365 2e74 6f5f 656e 6428 7365 6c66 2e66  se.to_end(self.f
+0000bd80: 756e 632c 2061 7869 7331 290a 2020 2020  unc, axis1).    
+0000bd90: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000bda0: 2020 2020 2020 7265 7475 726e 2069 6e73        return ins
+0000bdb0: 6572 7461 7869 7328 5f74 616b 6564 6961  ertaxis(_takedia
+0000bdc0: 6728 7365 6c66 2e66 756e 632c 2061 7869  g(self.func, axi
+0000bdd0: 7331 2c20 6178 6973 3229 2c20 7365 6c66  s1, axis2), self
+0000bde0: 2e6e 6469 6d2d 332c 2073 656c 662e 6c65  .ndim-3, self.le
+0000bdf0: 6e67 7468 290a 0a20 2020 2064 6566 205f  ngth)..    def _
+0000be00: 756e 7261 7665 6c28 7365 6c66 2c20 6178  unravel(self, ax
+0000be10: 6973 2c20 7368 6170 6529 3a0a 2020 2020  is, shape):.    
+0000be20: 2020 2020 6966 2061 7869 7320 3d3d 2073      if axis == s
+0000be30: 656c 662e 6e64 696d 202d 2031 3a0a 2020  elf.ndim - 1:.  
+0000be40: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000be50: 2049 6e73 6572 7441 7869 7328 496e 7365   InsertAxis(Inse
+0000be60: 7274 4178 6973 2873 656c 662e 6675 6e63  rtAxis(self.func
+0000be70: 2c20 7368 6170 655b 305d 292c 2073 6861  , shape[0]), sha
+0000be80: 7065 5b31 5d29 0a20 2020 2020 2020 2065  pe[1]).        e
+0000be90: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000bea0: 2072 6574 7572 6e20 496e 7365 7274 4178   return InsertAx
+0000beb0: 6973 2875 6e72 6176 656c 2873 656c 662e  is(unravel(self.
+0000bec0: 6675 6e63 2c20 6178 6973 2c20 7368 6170  func, axis, shap
+0000bed0: 6529 2c20 7365 6c66 2e6c 656e 6774 6829  e), self.length)
+0000bee0: 0a0a 2020 2020 6465 6620 5f73 6967 6e28  ..    def _sign(
+0000bef0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+0000bf00: 6574 7572 6e20 496e 7365 7274 4178 6973  eturn InsertAxis
+0000bf10: 2853 6967 6e28 7365 6c66 2e66 756e 6329  (Sign(self.func)
+0000bf20: 2c20 7365 6c66 2e6c 656e 6774 6829 0a0a  , self.length)..
+0000bf30: 2020 2020 6465 6620 5f64 6574 6572 6d69      def _determi
+0000bf40: 6e61 6e74 2873 656c 662c 2061 7869 7331  nant(self, axis1
+0000bf50: 2c20 6178 6973 3229 3a0a 2020 2020 2020  , axis2):.      
+0000bf60: 2020 6966 2061 7869 7331 203c 2073 656c    if axis1 < sel
+0000bf70: 662e 6e64 696d 2d31 2061 6e64 2061 7869  f.ndim-1 and axi
+0000bf80: 7332 203c 2073 656c 662e 6e64 696d 2d31  s2 < self.ndim-1
+0000bf90: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000bfa0: 7475 726e 2049 6e73 6572 7441 7869 7328  turn InsertAxis(
+0000bfb0: 6465 7465 726d 696e 616e 7428 7365 6c66  determinant(self
+0000bfc0: 2e66 756e 632c 2028 6178 6973 312c 2061  .func, (axis1, a
+0000bfd0: 7869 7332 2929 2c20 7365 6c66 2e6c 656e  xis2)), self.len
+0000bfe0: 6774 6829 0a0a 2020 2020 6465 6620 5f69  gth)..    def _i
+0000bff0: 6e76 6572 7365 2873 656c 662c 2061 7869  nverse(self, axi
+0000c000: 7331 2c20 6178 6973 3229 3a0a 2020 2020  s1, axis2):.    
+0000c010: 2020 2020 6966 2061 7869 7331 203c 2073      if axis1 < s
+0000c020: 656c 662e 6e64 696d 2d31 2061 6e64 2061  elf.ndim-1 and a
+0000c030: 7869 7332 203c 2073 656c 662e 6e64 696d  xis2 < self.ndim
+0000c040: 2d31 3a0a 2020 2020 2020 2020 2020 2020  -1:.            
+0000c050: 7265 7475 726e 2049 6e73 6572 7441 7869  return InsertAxi
+0000c060: 7328 696e 7665 7273 6528 7365 6c66 2e66  s(inverse(self.f
+0000c070: 756e 632c 2028 6178 6973 312c 2061 7869  unc, (axis1, axi
+0000c080: 7332 2929 2c20 7365 6c66 2e6c 656e 6774  s2)), self.lengt
+0000c090: 6829 0a0a 2020 2020 6465 6620 5f6c 6f6f  h)..    def _loo
+0000c0a0: 7073 756d 2873 656c 662c 2069 6e64 6578  psum(self, index
+0000c0b0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0000c0c0: 6e20 496e 7365 7274 4178 6973 286c 6f6f  n InsertAxis(loo
+0000c0d0: 705f 7375 6d28 7365 6c66 2e66 756e 632c  p_sum(self.func,
+0000c0e0: 2069 6e64 6578 292c 2073 656c 662e 6c65   index), self.le
+0000c0f0: 6e67 7468 290a 0a20 2020 2040 6361 6368  ngth)..    @cach
+0000c100: 6564 5f70 726f 7065 7274 790a 2020 2020  ed_property.    
+0000c110: 6465 6620 5f61 7373 7061 7273 6528 7365  def _assparse(se
+0000c120: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+0000c130: 7572 6e20 7475 706c 6528 282a 2849 6e73  urn tuple((*(Ins
+0000c140: 6572 7441 7869 7328 6964 782c 2073 656c  ertAxis(idx, sel
+0000c150: 662e 6c65 6e67 7468 2920 666f 7220 6964  f.length) for id
+0000c160: 7820 696e 2069 6e64 6963 6573 292c 2070  x in indices), p
+0000c170: 7265 7065 6e64 6178 6573 2852 616e 6765  rependaxes(Range
+0000c180: 2873 656c 662e 6c65 6e67 7468 292c 2076  (self.length), v
+0000c190: 616c 7565 732e 7368 6170 6529 2c20 496e  alues.shape), In
+0000c1a0: 7365 7274 4178 6973 2876 616c 7565 732c  sertAxis(values,
+0000c1b0: 2073 656c 662e 6c65 6e67 7468 2929 2066   self.length)) f
+0000c1c0: 6f72 202a 696e 6469 6365 732c 2076 616c  or *indices, val
+0000c1d0: 7565 7320 696e 2073 656c 662e 6675 6e63  ues in self.func
+0000c1e0: 2e5f 6173 7370 6172 7365 290a 0a20 2020  ._assparse)..   
+0000c1f0: 2064 6566 205f 696e 7462 6f75 6e64 735f   def _intbounds_
+0000c200: 696d 706c 2873 656c 6629 3a0a 2020 2020  impl(self):.    
+0000c210: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0000c220: 6675 6e63 2e5f 696e 7462 6f75 6e64 730a  func._intbounds.
+0000c230: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+0000c240: 2020 2064 6566 205f 636f 6e73 745f 756e     def _const_un
+0000c250: 6966 6f72 6d28 7365 6c66 293a 0a20 2020  iform(self):.   
+0000c260: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0000c270: 2e66 756e 632e 5f63 6f6e 7374 5f75 6e69  .func._const_uni
+0000c280: 666f 726d 0a0a 0a63 6c61 7373 2054 7261  form...class Tra
+0000c290: 6e73 706f 7365 2841 7272 6179 293a 0a0a  nspose(Array):..
+0000c2a0: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
+0000c2b0: 0a20 2020 2064 6566 205f 6d6b 5f61 7865  .    def _mk_axe
+0000c2c0: 7328 636c 732c 206e 6469 6d2c 2061 7865  s(cls, ndim, axe
+0000c2d0: 732c 2069 6e76 6572 743d 4661 6c73 6529  s, invert=False)
+0000c2e0: 3a0a 2020 2020 2020 2020 6178 6573 203d  :.        axes =
+0000c2f0: 205b 6e75 6d65 7269 632e 6e6f 726d 6469   [numeric.normdi
+0000c300: 6d28 6e64 696d 2c20 6178 6973 2920 666f  m(ndim, axis) fo
+0000c310: 7220 6178 6973 2069 6e20 6178 6573 5d0a  r axis in axes].
+0000c320: 2020 2020 2020 2020 6966 2061 6c6c 2861          if all(a
+0000c330: 203d 3d20 6220 666f 7220 612c 2062 2069   == b for a, b i
+0000c340: 6e20 656e 756d 6572 6174 6528 6178 6573  n enumerate(axes
+0000c350: 2c20 7374 6172 743d 6e64 696d 2d6c 656e  , start=ndim-len
+0000c360: 2861 7865 7329 2929 3a0a 2020 2020 2020  (axes))):.      
+0000c370: 2020 2020 2020 7265 7475 726e 0a20 2020        return.   
+0000c380: 2020 2020 2074 7261 6e73 203d 205b 6920       trans = [i 
+0000c390: 666f 7220 6920 696e 2072 616e 6765 286e  for i in range(n
+0000c3a0: 6469 6d29 2069 6620 6920 6e6f 7420 696e  dim) if i not in
+0000c3b0: 2061 7865 735d 0a20 2020 2020 2020 2074   axes].        t
+0000c3c0: 7261 6e73 2e65 7874 656e 6428 6178 6573  rans.extend(axes
+0000c3d0: 290a 2020 2020 2020 2020 6966 206c 656e  ).        if len
+0000c3e0: 2874 7261 6e73 2920 213d 206e 6469 6d3a  (trans) != ndim:
+0000c3f0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+0000c400: 7365 2045 7863 6570 7469 6f6e 2827 6475  se Exception('du
+0000c410: 706c 6963 6174 6520 6178 6573 2729 0a20  plicate axes'). 
+0000c420: 2020 2020 2020 2072 6574 7572 6e20 7475         return tu
+0000c430: 706c 6528 7472 616e 7329 0a0a 2020 2020  ple(trans)..    
+0000c440: 4063 6c61 7373 6d65 7468 6f64 0a20 2020  @classmethod.   
+0000c450: 2064 6566 2066 726f 6d5f 656e 6428 636c   def from_end(cl
+0000c460: 732c 2061 7272 6179 2c20 2a61 7865 7329  s, array, *axes)
+0000c470: 3a0a 2020 2020 2020 2020 7472 616e 7320  :.        trans 
+0000c480: 3d20 636c 732e 5f6d 6b5f 6178 6573 2861  = cls._mk_axes(a
+0000c490: 7272 6179 2e6e 6469 6d2c 2061 7865 7329  rray.ndim, axes)
+0000c4a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000c4b0: 636c 732e 696e 7628 6172 7261 792c 2074  cls.inv(array, t
+0000c4c0: 7261 6e73 2920 6966 2074 7261 6e73 2065  rans) if trans e
+0000c4d0: 6c73 6520 6172 7261 790a 0a20 2020 2040  lse array..    @
+0000c4e0: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
+0000c4f0: 6465 6620 746f 5f65 6e64 2863 6c73 2c20  def to_end(cls, 
+0000c500: 6172 7261 792c 202a 6178 6573 293a 0a20  array, *axes):. 
+0000c510: 2020 2020 2020 2074 7261 6e73 203d 2063         trans = c
+0000c520: 6c73 2e5f 6d6b 5f61 7865 7328 6172 7261  ls._mk_axes(arra
+0000c530: 792e 6e64 696d 2c20 6178 6573 290a 2020  y.ndim, axes).  
+0000c540: 2020 2020 2020 7265 7475 726e 2063 6c73        return cls
+0000c550: 2861 7272 6179 2c20 7472 616e 7329 2069  (array, trans) i
+0000c560: 6620 7472 616e 7320 656c 7365 2061 7272  f trans else arr
+0000c570: 6179 0a0a 2020 2020 4063 6c61 7373 6d65  ay..    @classme
+0000c580: 7468 6f64 0a20 2020 2064 6566 2069 6e76  thod.    def inv
+0000c590: 2863 6c73 2c20 6675 6e63 2c20 6178 6573  (cls, func, axes
+0000c5a0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0000c5b0: 6e20 636c 7328 6675 6e63 2c20 7475 706c  n cls(func, tupl
+0000c5c0: 6528 6e2e 5f5f 696e 6465 785f 5f28 2920  e(n.__index__() 
+0000c5d0: 666f 7220 6e20 696e 206e 756d 7079 2e61  for n in numpy.a
+0000c5e0: 7267 736f 7274 2861 7865 7329 2929 0a0a  rgsort(axes)))..
+0000c5f0: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+0000c600: 2873 656c 662c 2066 756e 633a 2041 7272  (self, func: Arr
+0000c610: 6179 2c20 6178 6573 3a20 7479 7069 6e67  ay, axes: typing
+0000c620: 2e54 7570 6c65 5b69 6e74 2c20 2e2e 2e5d  .Tuple[int, ...]
+0000c630: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+0000c640: 7420 6973 696e 7374 616e 6365 2866 756e  t isinstance(fun
+0000c650: 632c 2041 7272 6179 292c 2066 2766 756e  c, Array), f'fun
+0000c660: 633d 7b66 756e 6321 727d 270a 2020 2020  c={func!r}'.    
+0000c670: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
+0000c680: 7461 6e63 6528 6178 6573 2c20 7475 706c  tance(axes, tupl
+0000c690: 6529 2061 6e64 2061 6c6c 2869 7369 6e73  e) and all(isins
+0000c6a0: 7461 6e63 6528 6178 6973 2c20 696e 7429  tance(axis, int)
+0000c6b0: 2066 6f72 2061 7869 7320 696e 2061 7865   for axis in axe
+0000c6c0: 7329 2c20 6627 6178 6573 3d7b 6178 6573  s), f'axes={axes
+0000c6d0: 2172 7d27 0a20 2020 2020 2020 2061 7373  !r}'.        ass
+0000c6e0: 6572 7420 736f 7274 6564 2861 7865 7329  ert sorted(axes)
+0000c6f0: 203d 3d20 6c69 7374 2872 616e 6765 2866   == list(range(f
+0000c700: 756e 632e 6e64 696d 2929 0a20 2020 2020  unc.ndim)).     
+0000c710: 2020 2073 656c 662e 6675 6e63 203d 2066     self.func = f
+0000c720: 756e 630a 2020 2020 2020 2020 7365 6c66  unc.        self
+0000c730: 2e61 7865 7320 3d20 6178 6573 0a20 2020  .axes = axes.   
+0000c740: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
+0000c750: 6e69 745f 5f28 6172 6773 3d28 6675 6e63  nit__(args=(func
+0000c760: 2c29 2c20 7368 6170 653d 7475 706c 6528  ,), shape=tuple(
+0000c770: 6675 6e63 2e73 6861 7065 5b6e 5d20 666f  func.shape[n] fo
+0000c780: 7220 6e20 696e 2061 7865 7329 2c20 6474  r n in axes), dt
+0000c790: 7970 653d 6675 6e63 2e64 7479 7065 290a  ype=func.dtype).
+0000c7a0: 0a20 2020 2040 6361 6368 6564 5f70 726f  .    @cached_pro
+0000c7b0: 7065 7274 790a 2020 2020 6465 6620 5f64  perty.    def _d
+0000c7c0: 6961 676f 6e61 6c73 2873 656c 6629 3a0a  iagonals(self):.
+0000c7d0: 2020 2020 2020 2020 7265 7475 726e 2074          return t
+0000c7e0: 7570 6c65 2866 726f 7a65 6e73 6574 2873  uple(frozenset(s
+0000c7f0: 656c 662e 5f69 6e76 6178 6573 5b69 5d20  elf._invaxes[i] 
+0000c800: 666f 7220 6920 696e 2061 7865 7329 2066  for i in axes) f
+0000c810: 6f72 2061 7865 7320 696e 2073 656c 662e  or axes in self.
+0000c820: 6675 6e63 2e5f 6469 6167 6f6e 616c 7329  func._diagonals)
+0000c830: 0a0a 2020 2020 4063 6163 6865 645f 7072  ..    @cached_pr
+0000c840: 6f70 6572 7479 0a20 2020 2064 6566 205f  operty.    def _
+0000c850: 696e 666c 6174 696f 6e73 2873 656c 6629  inflations(self)
+0000c860: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+0000c870: 2074 7570 6c65 2828 7365 6c66 2e5f 696e   tuple((self._in
+0000c880: 7661 7865 735b 6178 6973 5d2c 2074 7970  vaxes[axis], typ
+0000c890: 6573 2e66 726f 7a65 6e64 6963 7428 2864  es.frozendict((d
+0000c8a0: 6f66 6d61 702c 2054 7261 6e73 706f 7365  ofmap, Transpose
+0000c8b0: 2866 756e 632c 2073 656c 662e 5f61 7865  (func, self._axe
+0000c8c0: 735f 666f 7228 646f 666d 6170 2e6e 6469  s_for(dofmap.ndi
+0000c8d0: 6d2c 2073 656c 662e 5f69 6e76 6178 6573  m, self._invaxes
+0000c8e0: 5b61 7869 735d 2929 2920 666f 7220 646f  [axis]))) for do
+0000c8f0: 666d 6170 2c20 6675 6e63 2069 6e20 7061  fmap, func in pa
+0000c900: 7274 732e 6974 656d 7328 2929 2920 666f  rts.items())) fo
+0000c910: 7220 6178 6973 2c20 7061 7274 7320 696e  r axis, parts in
+0000c920: 2073 656c 662e 6675 6e63 2e5f 696e 666c   self.func._infl
+0000c930: 6174 696f 6e73 290a 0a20 2020 2040 6361  ations)..    @ca
+0000c940: 6368 6564 5f70 726f 7065 7274 790a 2020  ched_property.  
+0000c950: 2020 6465 6620 5f75 6e61 6c69 676e 6564    def _unaligned
+0000c960: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0000c970: 756e 616c 6967 6e65 642c 2077 6865 7265  unaligned, where
+0000c980: 203d 2075 6e61 6c69 676e 2873 656c 662e   = unalign(self.
+0000c990: 6675 6e63 290a 2020 2020 2020 2020 7265  func).        re
+0000c9a0: 7475 726e 2075 6e61 6c69 676e 6564 2c20  turn unaligned, 
+0000c9b0: 7475 706c 6528 7365 6c66 2e5f 696e 7661  tuple(self._inva
+0000c9c0: 7865 735b 695d 2066 6f72 2069 2069 6e20  xes[i] for i in 
+0000c9d0: 7768 6572 6529 0a0a 2020 2020 4063 6163  where)..    @cac
+0000c9e0: 6865 645f 7072 6f70 6572 7479 0a20 2020  hed_property.   
+0000c9f0: 2064 6566 205f 696e 7661 7865 7328 7365   def _invaxes(se
+0000ca00: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+0000ca10: 7572 6e20 7475 706c 6528 6e2e 5f5f 696e  urn tuple(n.__in
+0000ca20: 6465 785f 5f28 2920 666f 7220 6e20 696e  dex__() for n in
+0000ca30: 206e 756d 7079 2e61 7267 736f 7274 2873   numpy.argsort(s
+0000ca40: 656c 662e 6178 6573 2929 0a0a 2020 2020  elf.axes))..    
+0000ca50: 6465 6620 5f73 696d 706c 6966 6965 6428  def _simplified(
+0000ca60: 7365 6c66 293a 0a20 2020 2020 2020 2069  self):.        i
+0000ca70: 6620 7365 6c66 2e61 7865 7320 3d3d 2074  f self.axes == t
+0000ca80: 7570 6c65 2872 616e 6765 2873 656c 662e  uple(range(self.
+0000ca90: 6e64 696d 2929 3a0a 2020 2020 2020 2020  ndim)):.        
+0000caa0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0000cab0: 6675 6e63 0a20 2020 2020 2020 2072 6574  func.        ret
+0000cac0: 7572 6e20 7365 6c66 2e66 756e 632e 5f74  urn self.func._t
+0000cad0: 7261 6e73 706f 7365 2873 656c 662e 6178  ranspose(self.ax
+0000cae0: 6573 290a 0a20 2020 2064 6566 2065 7661  es)..    def eva
+0000caf0: 6c66 2873 656c 662c 2061 7272 293a 0a20  lf(self, arr):. 
+0000cb00: 2020 2020 2020 2072 6574 7572 6e20 6172         return ar
+0000cb10: 722e 7472 616e 7370 6f73 6528 7365 6c66  r.transpose(self
+0000cb20: 2e61 7865 7329 0a0a 2020 2020 4070 726f  .axes)..    @pro
+0000cb30: 7065 7274 790a 2020 2020 6465 6620 5f6e  perty.    def _n
+0000cb40: 6f64 655f 6465 7461 696c 7328 7365 6c66  ode_details(self
+0000cb50: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0000cb60: 6e20 272c 272e 6a6f 696e 286d 6170 2873  n ','.join(map(s
+0000cb70: 7472 2c20 7365 6c66 2e61 7865 7329 290a  tr, self.axes)).
+0000cb80: 0a20 2020 2064 6566 205f 7472 616e 7370  .    def _transp
+0000cb90: 6f73 6528 7365 6c66 2c20 6178 6573 293a  ose(self, axes):
+0000cba0: 0a20 2020 2020 2020 2069 6620 6178 6573  .        if axes
+0000cbb0: 203d 3d20 7365 6c66 2e5f 696e 7661 7865   == self._invaxe
+0000cbc0: 733a 0a20 2020 2020 2020 2020 2020 2023  s:.            #
+0000cbd0: 204e 4f54 453a 2057 6869 6c65 2077 6520   NOTE: While we 
+0000cbe0: 636f 756c 6420 6c65 6176 6520 7468 6973  could leave this
+0000cbf0: 2070 6172 7469 6375 6c61 7220 7369 6d70   particular simp
+0000cc00: 6c69 6669 6361 7469 6f6e 2074 6f20 6265  lification to be
+0000cc10: 2064 6561 6c74 0a20 2020 2020 2020 2020   dealt.         
+0000cc20: 2020 2023 2077 6974 6820 6279 2054 7261     # with by Tra
+0000cc30: 6e73 706f 7365 2c20 7468 6520 6265 6e65  nspose, the bene
+0000cc40: 6669 7420 6f66 2068 616e 646c 696e 6720  fit of handling 
+0000cc50: 6974 2064 6972 6563 746c 7920 6973 2074  it directly is t
+0000cc60: 6861 7420 5f61 6464 2061 6e64 0a20 2020  hat _add and.   
+0000cc70: 2020 2020 2020 2020 2023 205f 6d75 6c74           # _mult
+0000cc80: 6970 6c79 2063 616e 2072 656c 7920 6f6e  iply can rely on
+0000cc90: 205f 7472 616e 7370 6f73 6520 666f 7220   _transpose for 
+0000cca0: 7468 6520 7269 6768 7420 6861 6e64 2073  the right hand s
+0000ccb0: 6964 6520 7769 7468 6f75 7420 6861 7669  ide without havi
+0000ccc0: 6e67 0a20 2020 2020 2020 2020 2020 2023  ng.            #
+0000ccd0: 2074 6f20 7365 7061 7261 7465 6c79 2061   to separately a
+0000cce0: 6363 6f75 6e74 2066 6f72 2074 6865 2074  ccount for the t
+0000ccf0: 7269 7669 616c 2063 6173 652e 0a20 2020  rivial case..   
+0000cd00: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000cd10: 7365 6c66 2e66 756e 630a 2020 2020 2020  self.func.      
+0000cd20: 2020 6e65 7761 7865 7320 3d20 7475 706c    newaxes = tupl
+0000cd30: 6528 7365 6c66 2e61 7865 735b 695d 2066  e(self.axes[i] f
+0000cd40: 6f72 2069 2069 6e20 6178 6573 290a 2020  or i in axes).  
+0000cd50: 2020 2020 2020 7265 7475 726e 2054 7261        return Tra
+0000cd60: 6e73 706f 7365 2873 656c 662e 6675 6e63  nspose(self.func
+0000cd70: 2c20 6e65 7761 7865 7329 0a0a 2020 2020  , newaxes)..    
+0000cd80: 6465 6620 5f74 616b 6564 6961 6728 7365  def _takediag(se
+0000cd90: 6c66 2c20 6178 6973 312c 2061 7869 7332  lf, axis1, axis2
+0000cda0: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+0000cdb0: 7420 6178 6973 3120 3c20 6178 6973 320a  t axis1 < axis2.
+0000cdc0: 2020 2020 2020 2020 6f72 6967 312c 206f          orig1, o
+0000cdd0: 7269 6732 203d 2073 6f72 7465 6428 7365  rig2 = sorted(se
+0000cde0: 6c66 2e61 7865 735b 6178 6973 5d20 666f  lf.axes[axis] fo
+0000cdf0: 7220 6178 6973 2069 6e20 5b61 7869 7331  r axis in [axis1
+0000ce00: 2c20 6178 6973 325d 290a 2020 2020 2020  , axis2]).      
+0000ce10: 2020 6966 206f 7269 6731 203d 3d20 7365    if orig1 == se
+0000ce20: 6c66 2e6e 6469 6d2d 323a 0a20 2020 2020  lf.ndim-2:.     
+0000ce30: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
+0000ce40: 616e 7370 6f73 6528 5461 6b65 4469 6167  anspose(TakeDiag
+0000ce50: 2873 656c 662e 6675 6e63 292c 2028 2a73  (self.func), (*s
+0000ce60: 656c 662e 6178 6573 5b3a 6178 6973 315d  elf.axes[:axis1]
+0000ce70: 2c20 2a73 656c 662e 6178 6573 5b61 7869  , *self.axes[axi
+0000ce80: 7331 2b31 3a61 7869 7332 5d2c 202a 7365  s1+1:axis2], *se
+0000ce90: 6c66 2e61 7865 735b 6178 6973 322b 313a  lf.axes[axis2+1:
+0000cea0: 5d2c 2073 656c 662e 6e64 696d 2d32 2929  ], self.ndim-2))
+0000ceb0: 0a20 2020 2020 2020 2074 7279 7461 6b65  .        trytake
+0000cec0: 6469 6167 203d 2073 656c 662e 6675 6e63  diag = self.func
+0000ced0: 2e5f 7461 6b65 6469 6167 286f 7269 6731  ._takediag(orig1
+0000cee0: 2c20 6f72 6967 3229 0a20 2020 2020 2020  , orig2).       
+0000cef0: 2069 6620 7472 7974 616b 6564 6961 6720   if trytakediag 
+0000cf00: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+0000cf10: 2020 2020 2020 2020 2065 7863 6c75 6465           exclude
+0000cf20: 5f6f 7269 6720 3d20 5b61 782d 2861 7820  _orig = [ax-(ax 
+0000cf30: 3e20 6f72 6967 3129 2d28 6178 203e 206f  > orig1)-(ax > o
+0000cf40: 7269 6732 2920 666f 7220 6178 2069 6e20  rig2) for ax in 
+0000cf50: 7365 6c66 2e61 7865 735b 3a61 7869 7331  self.axes[:axis1
+0000cf60: 5d20 2b20 7365 6c66 2e61 7865 735b 6178  ] + self.axes[ax
+0000cf70: 6973 312b 313a 6178 6973 325d 202b 2073  is1+1:axis2] + s
+0000cf80: 656c 662e 6178 6573 5b61 7869 7332 2b31  elf.axes[axis2+1
+0000cf90: 3a5d 5d0a 2020 2020 2020 2020 2020 2020  :]].            
+0000cfa0: 7265 7475 726e 2054 7261 6e73 706f 7365  return Transpose
+0000cfb0: 2874 7279 7461 6b65 6469 6167 2c20 282a  (trytakediag, (*
+0000cfc0: 6578 636c 7564 655f 6f72 6967 2c20 7365  exclude_orig, se
+0000cfd0: 6c66 2e6e 6469 6d2d 3229 290a 0a20 2020  lf.ndim-2))..   
+0000cfe0: 2064 6566 205f 7375 6d28 7365 6c66 2c20   def _sum(self, 
+0000cff0: 6929 3a0a 2020 2020 2020 2020 6178 6973  i):.        axis
+0000d000: 203d 2073 656c 662e 6178 6573 5b69 5d0a   = self.axes[i].
+0000d010: 2020 2020 2020 2020 7472 7973 756d 203d          trysum =
+0000d020: 2073 656c 662e 6675 6e63 2e5f 7375 6d28   self.func._sum(
+0000d030: 6178 6973 290a 2020 2020 2020 2020 6966  axis).        if
+0000d040: 2074 7279 7375 6d20 6973 206e 6f74 204e   trysum is not N
+0000d050: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0000d060: 2061 7865 7320 3d20 7475 706c 6528 6178   axes = tuple(ax
+0000d070: 2d28 6178 203e 2061 7869 7329 2066 6f72  -(ax > axis) for
+0000d080: 2061 7820 696e 2073 656c 662e 6178 6573   ax in self.axes
+0000d090: 2069 6620 6178 2021 3d20 6178 6973 290a   if ax != axis).
+0000d0a0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000d0b0: 726e 2054 7261 6e73 706f 7365 2874 7279  rn Transpose(try
+0000d0c0: 7375 6d2c 2061 7865 7329 0a20 2020 2020  sum, axes).     
+0000d0d0: 2020 2069 6620 6178 6973 203d 3d20 7365     if axis == se
+0000d0e0: 6c66 2e6e 6469 6d20 2d20 313a 0a20 2020  lf.ndim - 1:.   
+0000d0f0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000d100: 5472 616e 7370 6f73 6528 5375 6d28 7365  Transpose(Sum(se
+0000d110: 6c66 2e66 756e 6329 2c20 7365 6c66 2e5f  lf.func), self._
+0000d120: 6178 6573 5f66 6f72 2830 2c20 6929 290a  axes_for(0, i)).
+0000d130: 0a20 2020 2064 6566 205f 6465 7269 7661  .    def _deriva
+0000d140: 7469 7665 2873 656c 662c 2076 6172 2c20  tive(self, var, 
+0000d150: 7365 656e 293a 0a20 2020 2020 2020 2072  seen):.        r
+0000d160: 6574 7572 6e20 7472 616e 7370 6f73 6528  eturn transpose(
+0000d170: 6465 7269 7661 7469 7665 2873 656c 662e  derivative(self.
+0000d180: 6675 6e63 2c20 7661 722c 2073 6565 6e29  func, var, seen)
+0000d190: 2c20 7365 6c66 2e61 7865 732b 7475 706c  , self.axes+tupl
+0000d1a0: 6528 7261 6e67 6528 7365 6c66 2e6e 6469  e(range(self.ndi
+0000d1b0: 6d2c 2073 656c 662e 6e64 696d 2b76 6172  m, self.ndim+var
+0000d1c0: 2e6e 6469 6d29 2929 0a0a 2020 2020 6465  .ndim)))..    de
+0000d1d0: 6620 5f6d 756c 7469 706c 7928 7365 6c66  f _multiply(self
+0000d1e0: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+0000d1f0: 2020 6f74 6865 725f 7472 616e 7320 3d20    other_trans = 
+0000d200: 6f74 6865 722e 5f74 7261 6e73 706f 7365  other._transpose
+0000d210: 2873 656c 662e 5f69 6e76 6178 6573 290a  (self._invaxes).
+0000d220: 2020 2020 2020 2020 6966 206f 7468 6572          if other
+0000d230: 5f74 7261 6e73 2069 7320 6e6f 7420 4e6f  _trans is not No
+0000d240: 6e65 2061 6e64 206e 6f74 2069 7369 6e73  ne and not isins
+0000d250: 7461 6e63 6528 6f74 6865 725f 7472 616e  tance(other_tran
+0000d260: 732c 2054 7261 6e73 706f 7365 293a 0a20  s, Transpose):. 
+0000d270: 2020 2020 2020 2020 2020 2023 2054 6865             # The
+0000d280: 2073 6563 6f6e 6420 636c 6175 7365 2069   second clause i
+0000d290: 7320 746f 2061 766f 6964 2069 6e66 696e  s to avoid infin
+0000d2a0: 6974 6520 7265 6375 7273 696f 6e73 3b20  ite recursions; 
+0000d2b0: 7365 650a 2020 2020 2020 2020 2020 2020  see.            
+0000d2c0: 2320 7465 7374 732e 7465 7374 5f65 7661  # tests.test_eva
+0000d2d0: 6c75 6162 6c65 2e73 696d 706c 6966 792e  luable.simplify.
+0000d2e0: 7465 7374 5f6d 756c 7469 706c 795f 7472  test_multiply_tr
+0000d2f0: 616e 7370 6f73 652e 0a20 2020 2020 2020  anspose..       
+0000d300: 2020 2020 2072 6574 7572 6e20 5472 616e       return Tran
+0000d310: 7370 6f73 6528 6d75 6c74 6970 6c79 2873  spose(multiply(s
+0000d320: 656c 662e 6675 6e63 2c20 6f74 6865 725f  elf.func, other_
+0000d330: 7472 616e 7329 2c20 7365 6c66 2e61 7865  trans), self.axe
+0000d340: 7329 0a20 2020 2020 2020 2074 7279 6d75  s).        trymu
+0000d350: 6c74 6970 6c79 203d 2073 656c 662e 6675  ltiply = self.fu
+0000d360: 6e63 2e5f 6d75 6c74 6970 6c79 2854 7261  nc._multiply(Tra
+0000d370: 6e73 706f 7365 286f 7468 6572 2c20 7365  nspose(other, se
+0000d380: 6c66 2e5f 696e 7661 7865 7329 290a 2020  lf._invaxes)).  
+0000d390: 2020 2020 2020 6966 2074 7279 6d75 6c74        if trymult
+0000d3a0: 6970 6c79 2069 7320 6e6f 7420 4e6f 6e65  iply is not None
+0000d3b0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000d3c0: 7475 726e 2054 7261 6e73 706f 7365 2874  turn Transpose(t
+0000d3d0: 7279 6d75 6c74 6970 6c79 2c20 7365 6c66  rymultiply, self
+0000d3e0: 2e61 7865 7329 0a0a 2020 2020 6465 6620  .axes)..    def 
+0000d3f0: 5f61 6464 2873 656c 662c 206f 7468 6572  _add(self, other
+0000d400: 293a 0a20 2020 2020 2020 206f 7468 6572  ):.        other
+0000d410: 5f74 7261 6e73 203d 206f 7468 6572 2e5f  _trans = other._
+0000d420: 7472 616e 7370 6f73 6528 7365 6c66 2e5f  transpose(self._
+0000d430: 696e 7661 7865 7329 0a20 2020 2020 2020  invaxes).       
+0000d440: 2069 6620 6f74 6865 725f 7472 616e 7320   if other_trans 
+0000d450: 6973 206e 6f74 204e 6f6e 6520 616e 6420  is not None and 
+0000d460: 6e6f 7420 6973 696e 7374 616e 6365 286f  not isinstance(o
+0000d470: 7468 6572 5f74 7261 6e73 2c20 5472 616e  ther_trans, Tran
+0000d480: 7370 6f73 6529 3a0a 2020 2020 2020 2020  spose):.        
+0000d490: 2020 2020 2320 5468 6520 7365 636f 6e64      # The second
+0000d4a0: 2063 6c61 7573 6520 6973 2074 6f20 6176   clause is to av
+0000d4b0: 6f69 6420 696e 6669 6e69 7465 2072 6563  oid infinite rec
+0000d4c0: 7572 7369 6f6e 730a 2020 2020 2020 2020  ursions.        
+0000d4d0: 2020 2020 7265 7475 726e 2054 7261 6e73      return Trans
+0000d4e0: 706f 7365 2873 656c 662e 6675 6e63 202b  pose(self.func +
+0000d4f0: 206f 7468 6572 5f74 7261 6e73 2c20 7365   other_trans, se
+0000d500: 6c66 2e61 7865 7329 0a20 2020 2020 2020  lf.axes).       
+0000d510: 2074 7279 6164 6420 3d20 7365 6c66 2e66   tryadd = self.f
+0000d520: 756e 632e 5f61 6464 2854 7261 6e73 706f  unc._add(Transpo
+0000d530: 7365 286f 7468 6572 2c20 7365 6c66 2e5f  se(other, self._
+0000d540: 696e 7661 7865 7329 290a 2020 2020 2020  invaxes)).      
+0000d550: 2020 6966 2074 7279 6164 6420 6973 206e    if tryadd is n
+0000d560: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+0000d570: 2020 2020 2072 6574 7572 6e20 5472 616e       return Tran
+0000d580: 7370 6f73 6528 7472 7961 6464 2c20 7365  spose(tryadd, se
+0000d590: 6c66 2e61 7865 7329 0a0a 2020 2020 6465  lf.axes)..    de
+0000d5a0: 6620 5f74 616b 6528 7365 6c66 2c20 696e  f _take(self, in
+0000d5b0: 6469 6365 732c 2061 7869 7329 3a0a 2020  dices, axis):.  
+0000d5c0: 2020 2020 2020 7472 7974 616b 6520 3d20        trytake = 
+0000d5d0: 7365 6c66 2e66 756e 632e 5f74 616b 6528  self.func._take(
+0000d5e0: 696e 6469 6365 732c 2073 656c 662e 6178  indices, self.ax
+0000d5f0: 6573 5b61 7869 735d 290a 2020 2020 2020  es[axis]).      
+0000d600: 2020 6966 2074 7279 7461 6b65 2069 7320    if trytake is 
+0000d610: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+0000d620: 2020 2020 2020 7265 7475 726e 2054 7261        return Tra
+0000d630: 6e73 706f 7365 2874 7279 7461 6b65 2c20  nspose(trytake, 
+0000d640: 7365 6c66 2e5f 6178 6573 5f66 6f72 2869  self._axes_for(i
+0000d650: 6e64 6963 6573 2e6e 6469 6d2c 2061 7869  ndices.ndim, axi
+0000d660: 7329 290a 2020 2020 2020 2020 6966 2073  s)).        if s
+0000d670: 656c 662e 6178 6573 5b61 7869 735d 203d  elf.axes[axis] =
+0000d680: 3d20 7365 6c66 2e6e 6469 6d20 2d20 313a  = self.ndim - 1:
+0000d690: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000d6a0: 7572 6e20 5472 616e 7370 6f73 6528 5461  urn Transpose(Ta
+0000d6b0: 6b65 2873 656c 662e 6675 6e63 2c20 696e  ke(self.func, in
+0000d6c0: 6469 6365 7329 2c20 7365 6c66 2e5f 6178  dices), self._ax
+0000d6d0: 6573 5f66 6f72 2869 6e64 6963 6573 2e6e  es_for(indices.n
+0000d6e0: 6469 6d2c 2061 7869 7329 290a 0a20 2020  dim, axis))..   
+0000d6f0: 2064 6566 205f 6178 6573 5f66 6f72 2873   def _axes_for(s
+0000d700: 656c 662c 206e 6469 6d2c 2061 7869 7329  elf, ndim, axis)
+0000d710: 3a0a 2020 2020 2020 2020 6675 6e63 6178  :.        funcax
+0000d720: 6973 203d 2073 656c 662e 6178 6573 5b61  is = self.axes[a
+0000d730: 7869 735d 0a20 2020 2020 2020 2061 7865  xis].        axe
+0000d740: 7320 3d20 5b61 782b 2861 7820 3e20 6675  s = [ax+(ax > fu
+0000d750: 6e63 6178 6973 292a 286e 6469 6d2d 3129  ncaxis)*(ndim-1)
+0000d760: 2066 6f72 2061 7820 696e 2073 656c 662e   for ax in self.
+0000d770: 6178 6573 2069 6620 6178 2021 3d20 6675  axes if ax != fu
+0000d780: 6e63 6178 6973 5d0a 2020 2020 2020 2020  ncaxis].        
+0000d790: 6178 6573 5b61 7869 733a 6178 6973 5d20  axes[axis:axis] 
+0000d7a0: 3d20 7261 6e67 6528 6675 6e63 6178 6973  = range(funcaxis
+0000d7b0: 2c20 6675 6e63 6178 6973 202b 206e 6469  , funcaxis + ndi
+0000d7c0: 6d29 0a20 2020 2020 2020 2072 6574 7572  m).        retur
+0000d7d0: 6e20 7475 706c 6528 6178 6573 290a 0a20  n tuple(axes).. 
+0000d7e0: 2020 2064 6566 205f 706f 7765 7228 7365     def _power(se
+0000d7f0: 6c66 2c20 6e29 3a0a 2020 2020 2020 2020  lf, n):.        
+0000d800: 6e5f 7472 616e 7320 3d20 5472 616e 7370  n_trans = Transp
+0000d810: 6f73 6528 6e2c 2073 656c 662e 5f69 6e76  ose(n, self._inv
+0000d820: 6178 6573 290a 2020 2020 2020 2020 7265  axes).        re
+0000d830: 7475 726e 2054 7261 6e73 706f 7365 2850  turn Transpose(P
+0000d840: 6f77 6572 2873 656c 662e 6675 6e63 2c20  ower(self.func, 
+0000d850: 6e5f 7472 616e 7329 2c20 7365 6c66 2e61  n_trans), self.a
+0000d860: 7865 7329 0a0a 2020 2020 6465 6620 5f73  xes)..    def _s
+0000d870: 6967 6e28 7365 6c66 293a 0a20 2020 2020  ign(self):.     
+0000d880: 2020 2072 6574 7572 6e20 5472 616e 7370     return Transp
+0000d890: 6f73 6528 5369 676e 2873 656c 662e 6675  ose(Sign(self.fu
+0000d8a0: 6e63 292c 2073 656c 662e 6178 6573 290a  nc), self.axes).
+0000d8b0: 0a20 2020 2064 6566 205f 756e 7261 7665  .    def _unrave
+0000d8c0: 6c28 7365 6c66 2c20 6178 6973 2c20 7368  l(self, axis, sh
+0000d8d0: 6170 6529 3a0a 2020 2020 2020 2020 6f72  ape):.        or
+0000d8e0: 6967 5f61 7869 7320 3d20 7365 6c66 2e61  ig_axis = self.a
+0000d8f0: 7865 735b 6178 6973 5d0a 2020 2020 2020  xes[axis].      
+0000d900: 2020 7472 7975 6e72 6176 656c 203d 2073    tryunravel = s
+0000d910: 656c 662e 6675 6e63 2e5f 756e 7261 7665  elf.func._unrave
+0000d920: 6c28 6f72 6967 5f61 7869 732c 2073 6861  l(orig_axis, sha
+0000d930: 7065 290a 2020 2020 2020 2020 6966 2074  pe).        if t
+0000d940: 7279 756e 7261 7665 6c20 6973 206e 6f74  ryunravel is not
+0000d950: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0000d960: 2020 2061 7865 7320 3d20 5b61 7820 2b20     axes = [ax + 
+0000d970: 2861 7820 3e20 6f72 6967 5f61 7869 7329  (ax > orig_axis)
+0000d980: 2066 6f72 2061 7820 696e 2073 656c 662e   for ax in self.
+0000d990: 6178 6573 5d0a 2020 2020 2020 2020 2020  axes].          
+0000d9a0: 2020 6178 6573 2e69 6e73 6572 7428 6178    axes.insert(ax
+0000d9b0: 6973 2b31 2c20 6f72 6967 5f61 7869 732b  is+1, orig_axis+
+0000d9c0: 3129 0a20 2020 2020 2020 2020 2020 2072  1).            r
+0000d9d0: 6574 7572 6e20 5472 616e 7370 6f73 6528  eturn Transpose(
+0000d9e0: 7472 7975 6e72 6176 656c 2c20 7475 706c  tryunravel, tupl
+0000d9f0: 6528 6178 6573 2929 0a0a 2020 2020 6465  e(axes))..    de
+0000da00: 6620 5f70 726f 6475 6374 2873 656c 6629  f _product(self)
+0000da10: 3a0a 2020 2020 2020 2020 6966 2073 656c  :.        if sel
+0000da20: 662e 6178 6573 5b2d 315d 203d 3d20 7365  f.axes[-1] == se
+0000da30: 6c66 2e6e 6469 6d2d 313a 0a20 2020 2020  lf.ndim-1:.     
+0000da40: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
+0000da50: 616e 7370 6f73 6528 5072 6f64 7563 7428  anspose(Product(
+0000da60: 7365 6c66 2e66 756e 6329 2c20 7365 6c66  self.func), self
+0000da70: 2e61 7865 735b 3a2d 315d 290a 0a20 2020  .axes[:-1])..   
+0000da80: 2064 6566 205f 6465 7465 726d 696e 616e   def _determinan
+0000da90: 7428 7365 6c66 2c20 6178 6973 312c 2061  t(self, axis1, a
+0000daa0: 7869 7332 293a 0a20 2020 2020 2020 206f  xis2):.        o
+0000dab0: 7269 6731 2c20 6f72 6967 3220 3d20 7365  rig1, orig2 = se
+0000dac0: 6c66 2e61 7865 735b 6178 6973 315d 2c20  lf.axes[axis1], 
+0000dad0: 7365 6c66 2e61 7865 735b 6178 6973 325d  self.axes[axis2]
+0000dae0: 0a20 2020 2020 2020 2074 7279 6465 7420  .        trydet 
+0000daf0: 3d20 7365 6c66 2e66 756e 632e 5f64 6574  = self.func._det
+0000db00: 6572 6d69 6e61 6e74 286f 7269 6731 2c20  erminant(orig1, 
+0000db10: 6f72 6967 3229 0a20 2020 2020 2020 2069  orig2).        i
+0000db20: 6620 7472 7964 6574 3a0a 2020 2020 2020  f trydet:.      
+0000db30: 2020 2020 2020 6178 6573 203d 2074 7570        axes = tup
+0000db40: 6c65 2861 782d 2861 7820 3e20 6f72 6967  le(ax-(ax > orig
+0000db50: 3129 2d28 6178 203e 206f 7269 6732 2920  1)-(ax > orig2) 
+0000db60: 666f 7220 6178 2069 6e20 7365 6c66 2e61  for ax in self.a
+0000db70: 7865 7320 6966 2061 7820 213d 206f 7269  xes if ax != ori
+0000db80: 6731 2061 6e64 2061 7820 213d 206f 7269  g1 and ax != ori
+0000db90: 6732 290a 2020 2020 2020 2020 2020 2020  g2).            
+0000dba0: 7265 7475 726e 2054 7261 6e73 706f 7365  return Transpose
+0000dbb0: 2874 7279 6465 742c 2061 7865 7329 0a0a  (trydet, axes)..
+0000dbc0: 2020 2020 6465 6620 5f69 6e76 6572 7365      def _inverse
+0000dbd0: 2873 656c 662c 2061 7869 7331 2c20 6178  (self, axis1, ax
+0000dbe0: 6973 3229 3a0a 2020 2020 2020 2020 7472  is2):.        tr
+0000dbf0: 7969 6e76 203d 2073 656c 662e 6675 6e63  yinv = self.func
+0000dc00: 2e5f 696e 7665 7273 6528 7365 6c66 2e61  ._inverse(self.a
+0000dc10: 7865 735b 6178 6973 315d 2c20 7365 6c66  xes[axis1], self
+0000dc20: 2e61 7865 735b 6178 6973 325d 290a 2020  .axes[axis2]).  
+0000dc30: 2020 2020 2020 6966 2074 7279 696e 763a        if tryinv:
+0000dc40: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000dc50: 7572 6e20 5472 616e 7370 6f73 6528 7472  urn Transpose(tr
+0000dc60: 7969 6e76 2c20 7365 6c66 2e61 7865 7329  yinv, self.axes)
+0000dc70: 0a0a 2020 2020 6465 6620 5f72 6176 656c  ..    def _ravel
+0000dc80: 2873 656c 662c 2061 7869 7329 3a0a 2020  (self, axis):.  
+0000dc90: 2020 2020 2020 6966 2073 656c 662e 6178        if self.ax
+0000dca0: 6573 5b61 7869 735d 203d 3d20 7365 6c66  es[axis] == self
+0000dcb0: 2e6e 6469 6d2d 3220 616e 6420 7365 6c66  .ndim-2 and self
+0000dcc0: 2e61 7865 735b 6178 6973 2b31 5d20 3d3d  .axes[axis+1] ==
+0000dcd0: 2073 656c 662e 6e64 696d 2d31 3a0a 2020   self.ndim-1:.  
+0000dce0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000dcf0: 2054 7261 6e73 706f 7365 2852 6176 656c   Transpose(Ravel
+0000dd00: 2873 656c 662e 6675 6e63 292c 2073 656c  (self.func), sel
+0000dd10: 662e 6178 6573 5b3a 2d31 5d29 0a0a 2020  f.axes[:-1])..  
+0000dd20: 2020 6465 6620 5f69 6e66 6c61 7465 2873    def _inflate(s
+0000dd30: 656c 662c 2064 6f66 6d61 702c 206c 656e  elf, dofmap, len
+0000dd40: 6774 682c 2061 7869 7329 3a0a 2020 2020  gth, axis):.    
+0000dd50: 2020 2020 6920 3d20 7365 6c66 2e61 7865      i = self.axe
+0000dd60: 735b 6178 6973 5d20 6966 2064 6f66 6d61  s[axis] if dofma
+0000dd70: 702e 6e64 696d 2065 6c73 6520 7365 6c66  p.ndim else self
+0000dd80: 2e66 756e 632e 6e64 696d 0a20 2020 2020  .func.ndim.     
+0000dd90: 2020 2069 6620 7365 6c66 2e61 7865 735b     if self.axes[
+0000dda0: 6178 6973 3a61 7869 732b 646f 666d 6170  axis:axis+dofmap
+0000ddb0: 2e6e 6469 6d5d 203d 3d20 7475 706c 6528  .ndim] == tuple(
+0000ddc0: 7261 6e67 6528 692c 2069 2b64 6f66 6d61  range(i, i+dofma
+0000ddd0: 702e 6e64 696d 2929 3a0a 2020 2020 2020  p.ndim)):.      
+0000dde0: 2020 2020 2020 7472 7969 6e66 6c61 7465        tryinflate
+0000ddf0: 203d 2073 656c 662e 6675 6e63 2e5f 696e   = self.func._in
+0000de00: 666c 6174 6528 646f 666d 6170 2c20 6c65  flate(dofmap, le
+0000de10: 6e67 7468 2c20 6929 0a20 2020 2020 2020  ngth, i).       
+0000de20: 2020 2020 2069 6620 7472 7969 6e66 6c61       if tryinfla
+0000de30: 7465 2069 7320 6e6f 7420 4e6f 6e65 3a0a  te is not None:.
+0000de40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de50: 6178 6573 203d 205b 6178 2d28 6178 203e  axes = [ax-(ax >
+0000de60: 2069 292a 2864 6f66 6d61 702e 6e64 696d   i)*(dofmap.ndim
+0000de70: 2d31 2920 666f 7220 6178 2069 6e20 7365  -1) for ax in se
+0000de80: 6c66 2e61 7865 735d 0a20 2020 2020 2020  lf.axes].       
+0000de90: 2020 2020 2020 2020 2061 7865 735b 6178           axes[ax
+0000dea0: 6973 3a61 7869 732b 646f 666d 6170 2e6e  is:axis+dofmap.n
+0000deb0: 6469 6d5d 203d 2069 2c0a 2020 2020 2020  dim] = i,.      
+0000dec0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000ded0: 2054 7261 6e73 706f 7365 2874 7279 696e   Transpose(tryin
+0000dee0: 666c 6174 652c 2074 7570 6c65 2861 7865  flate, tuple(axe
+0000def0: 7329 290a 0a20 2020 2064 6566 205f 6469  s))..    def _di
+0000df00: 6167 6f6e 616c 697a 6528 7365 6c66 2c20  agonalize(self, 
+0000df10: 6178 6973 293a 0a20 2020 2020 2020 2074  axis):.        t
+0000df20: 7279 6469 6167 6f6e 616c 697a 6520 3d20  rydiagonalize = 
+0000df30: 7365 6c66 2e66 756e 632e 5f64 6961 676f  self.func._diago
+0000df40: 6e61 6c69 7a65 2873 656c 662e 6178 6573  nalize(self.axes
+0000df50: 5b61 7869 735d 290a 2020 2020 2020 2020  [axis]).        
+0000df60: 6966 2074 7279 6469 6167 6f6e 616c 697a  if trydiagonaliz
+0000df70: 6520 6973 206e 6f74 204e 6f6e 653a 0a20  e is not None:. 
+0000df80: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000df90: 6e20 5472 616e 7370 6f73 6528 7472 7964  n Transpose(tryd
+0000dfa0: 6961 676f 6e61 6c69 7a65 2c20 7365 6c66  iagonalize, self
+0000dfb0: 2e61 7865 7320 2b20 2873 656c 662e 6e64  .axes + (self.nd
+0000dfc0: 696d 2c29 290a 0a20 2020 2064 6566 205f  im,))..    def _
+0000dfd0: 696e 7365 7274 6178 6973 2873 656c 662c  insertaxis(self,
+0000dfe0: 2061 7869 732c 206c 656e 6774 6829 3a0a   axis, length):.
+0000dff0: 2020 2020 2020 2020 7265 7475 726e 2054          return T
+0000e000: 7261 6e73 706f 7365 2849 6e73 6572 7441  ranspose(InsertA
+0000e010: 7869 7328 7365 6c66 2e66 756e 632c 206c  xis(self.func, l
+0000e020: 656e 6774 6829 2c20 7365 6c66 2e61 7865  ength), self.axe
+0000e030: 735b 3a61 7869 735d 202b 2028 7365 6c66  s[:axis] + (self
+0000e040: 2e6e 6469 6d2c 2920 2b20 7365 6c66 2e61  .ndim,) + self.a
+0000e050: 7865 735b 6178 6973 3a5d 290a 0a20 2020  xes[axis:])..   
+0000e060: 2064 6566 205f 6c6f 6f70 7375 6d28 7365   def _loopsum(se
+0000e070: 6c66 2c20 696e 6465 7829 3a0a 2020 2020  lf, index):.    
+0000e080: 2020 2020 7265 7475 726e 2054 7261 6e73      return Trans
+0000e090: 706f 7365 286c 6f6f 705f 7375 6d28 7365  pose(loop_sum(se
+0000e0a0: 6c66 2e66 756e 632c 2069 6e64 6578 292c  lf.func, index),
+0000e0b0: 2073 656c 662e 6178 6573 290a 0a20 2020   self.axes)..   
+0000e0c0: 2040 6361 6368 6564 5f70 726f 7065 7274   @cached_propert
+0000e0d0: 790a 2020 2020 6465 6620 5f61 7373 7061  y.    def _asspa
+0000e0e0: 7273 6528 7365 6c66 293a 0a20 2020 2020  rse(self):.     
+0000e0f0: 2020 2072 6574 7572 6e20 7475 706c 6528     return tuple(
+0000e100: 282a 2869 6e64 6963 6573 5b69 5d20 666f  (*(indices[i] fo
+0000e110: 7220 6920 696e 2073 656c 662e 6178 6573  r i in self.axes
+0000e120: 292c 2076 616c 7565 7329 2066 6f72 202a  ), values) for *
+0000e130: 696e 6469 6365 732c 2076 616c 7565 7320  indices, values 
+0000e140: 696e 2073 656c 662e 6675 6e63 2e5f 6173  in self.func._as
+0000e150: 7370 6172 7365 290a 0a20 2020 2064 6566  sparse)..    def
+0000e160: 205f 696e 7462 6f75 6e64 735f 696d 706c   _intbounds_impl
+0000e170: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0000e180: 7265 7475 726e 2073 656c 662e 6675 6e63  return self.func
+0000e190: 2e5f 696e 7462 6f75 6e64 730a 0a20 2020  ._intbounds..   
+0000e1a0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+0000e1b0: 6566 205f 636f 6e73 745f 756e 6966 6f72  ef _const_unifor
+0000e1c0: 6d28 7365 6c66 293a 0a20 2020 2020 2020  m(self):.       
+0000e1d0: 2072 6574 7572 6e20 7365 6c66 2e66 756e   return self.fun
+0000e1e0: 632e 5f63 6f6e 7374 5f75 6e69 666f 726d  c._const_uniform
+0000e1f0: 0a0a 0a63 6c61 7373 2050 726f 6475 6374  ...class Product
+0000e200: 2841 7272 6179 293a 0a0a 2020 2020 6465  (Array):..    de
+0000e210: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
+0000e220: 2066 756e 633a 2041 7272 6179 293a 0a20   func: Array):. 
+0000e230: 2020 2020 2020 2061 7373 6572 7420 6973         assert is
+0000e240: 696e 7374 616e 6365 2866 756e 632c 2041  instance(func, A
+0000e250: 7272 6179 2920 616e 6420 6675 6e63 2e64  rray) and func.d
+0000e260: 7479 7065 2021 3d20 626f 6f6c 2c20 6627  type != bool, f'
+0000e270: 6675 6e63 3d7b 6675 6e63 2172 7d27 0a20  func={func!r}'. 
+0000e280: 2020 2020 2020 2073 656c 662e 6675 6e63         self.func
+0000e290: 203d 2066 756e 630a 2020 2020 2020 2020   = func.        
+0000e2a0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+0000e2b0: 2861 7267 733d 2866 756e 632c 292c 2073  (args=(func,), s
+0000e2c0: 6861 7065 3d66 756e 632e 7368 6170 655b  hape=func.shape[
+0000e2d0: 3a2d 315d 2c20 6474 7970 653d 6675 6e63  :-1], dtype=func
+0000e2e0: 2e64 7479 7065 290a 0a20 2020 2064 6566  .dtype)..    def
+0000e2f0: 205f 7369 6d70 6c69 6669 6564 2873 656c   _simplified(sel
+0000e300: 6629 3a0a 2020 2020 2020 2020 6966 205f  f):.        if _
+0000e310: 6571 7561 6c73 5f73 6361 6c61 725f 636f  equals_scalar_co
+0000e320: 6e73 7461 6e74 2873 656c 662e 6675 6e63  nstant(self.func
+0000e330: 2e73 6861 7065 5b2d 315d 2c20 3129 3a0a  .shape[-1], 1):.
+0000e340: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000e350: 726e 2067 6574 2873 656c 662e 6675 6e63  rn get(self.func
+0000e360: 2c20 7365 6c66 2e6e 6469 6d2c 2063 6f6e  , self.ndim, con
+0000e370: 7374 616e 7428 3029 290a 2020 2020 2020  stant(0)).      
+0000e380: 2020 7265 7475 726e 2073 656c 662e 6675    return self.fu
+0000e390: 6e63 2e5f 7072 6f64 7563 7428 290a 0a20  nc._product().. 
+0000e3a0: 2020 2040 7374 6174 6963 6d65 7468 6f64     @staticmethod
+0000e3b0: 0a20 2020 2064 6566 2065 7661 6c66 2861  .    def evalf(a
+0000e3c0: 7272 293a 0a20 2020 2020 2020 2072 6574  rr):.        ret
+0000e3d0: 7572 6e20 6e75 6d70 792e 7072 6f64 7563  urn numpy.produc
+0000e3e0: 7428 6172 722c 2061 7869 733d 2d31 290a  t(arr, axis=-1).
+0000e3f0: 0a20 2020 2064 6566 205f 6465 7269 7661  .    def _deriva
+0000e400: 7469 7665 2873 656c 662c 2076 6172 2c20  tive(self, var, 
+0000e410: 7365 656e 293a 0a20 2020 2020 2020 2067  seen):.        g
+0000e420: 7261 6420 3d20 6465 7269 7661 7469 7665  rad = derivative
+0000e430: 2873 656c 662e 6675 6e63 2c20 7661 722c  (self.func, var,
+0000e440: 2073 6565 6e29 0a20 2020 2020 2020 2066   seen).        f
+0000e450: 756e 6373 203d 2050 726f 6475 6374 2869  uncs = Product(i
+0000e460: 6e73 6572 7461 7869 7328 7365 6c66 2e66  nsertaxis(self.f
+0000e470: 756e 632c 202d 322c 2073 656c 662e 6675  unc, -2, self.fu
+0000e480: 6e63 2e73 6861 7065 5b2d 315d 2920 2b20  nc.shape[-1]) + 
+0000e490: 4469 6167 6f6e 616c 697a 6528 3120 2d20  Diagonalize(1 - 
+0000e4a0: 7365 6c66 2e66 756e 6329 2920 2023 2072  self.func))  # r
+0000e4b0: 6570 6c61 6365 2064 6961 676f 6e61 6c20  eplace diagonal 
+0000e4c0: 656e 7472 6965 7320 6279 2031 0a20 2020  entries by 1.   
+0000e4d0: 2020 2020 2072 6574 7572 6e20 6569 6e73       return eins
+0000e4e0: 756d 2827 4169 2c41 6942 2d3e 4142 272c  um('Ai,AiB->AB',
+0000e4f0: 2066 756e 6373 2c20 6772 6164 290a 0a20   funcs, grad).. 
+0000e500: 2020 2064 6566 205f 7461 6b65 2873 656c     def _take(sel
+0000e510: 662c 2069 6e64 6963 6573 2c20 6178 6973  f, indices, axis
+0000e520: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0000e530: 6e20 5072 6f64 7563 7428 5f74 616b 6528  n Product(_take(
+0000e540: 7365 6c66 2e66 756e 632c 2069 6e64 6963  self.func, indic
+0000e550: 6573 2c20 6178 6973 2929 0a0a 2020 2020  es, axis))..    
+0000e560: 6465 6620 5f74 616b 6564 6961 6728 7365  def _takediag(se
+0000e570: 6c66 2c20 6178 6973 312c 2061 7869 7332  lf, axis1, axis2
+0000e580: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0000e590: 6e20 7072 6f64 7563 7428 5f74 616b 6564  n product(_taked
+0000e5a0: 6961 6728 7365 6c66 2e66 756e 632c 2061  iag(self.func, a
+0000e5b0: 7869 7331 2c20 6178 6973 3229 2c20 7365  xis1, axis2), se
+0000e5c0: 6c66 2e6e 6469 6d2d 3229 0a0a 0a63 6c61  lf.ndim-2)...cla
+0000e5d0: 7373 2049 6e76 6572 7365 2841 7272 6179  ss Inverse(Array
+0000e5e0: 293a 0a20 2020 2027 2727 0a20 2020 204d  ):.    '''.    M
+0000e5f0: 6174 7269 7820 696e 7665 7273 6520 6f66  atrix inverse of
+0000e600: 2060 6066 756e 6360 6020 6f76 6572 2074   ``func`` over t
+0000e610: 6865 206c 6173 7420 7477 6f20 6178 6573  he last two axes
+0000e620: 2e20 2041 6c6c 206f 7468 6572 2061 7865  .  All other axe
+0000e630: 7320 6172 650a 2020 2020 7472 6561 7465  s are.    treate
+0000e640: 6420 656c 656d 656e 742d 7769 7365 2e0a  d element-wise..
+0000e650: 2020 2020 2727 270a 0a20 2020 2064 6566      '''..    def
+0000e660: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+0000e670: 6675 6e63 3a20 4172 7261 7929 3a0a 2020  func: Array):.  
+0000e680: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+0000e690: 6e73 7461 6e63 6528 6675 6e63 2c20 4172  nstance(func, Ar
+0000e6a0: 7261 7929 2061 6e64 2066 756e 632e 6e64  ray) and func.nd
+0000e6b0: 696d 203e 3d20 3220 616e 6420 5f65 7175  im >= 2 and _equ
+0000e6c0: 616c 735f 7369 6d70 6c69 6669 6564 2866  als_simplified(f
+0000e6d0: 756e 632e 7368 6170 655b 2d31 5d2c 2066  unc.shape[-1], f
+0000e6e0: 756e 632e 7368 6170 655b 2d32 5d29 2c20  unc.shape[-2]), 
+0000e6f0: 6627 6675 6e63 3d7b 6675 6e63 2172 7d27  f'func={func!r}'
+0000e700: 0a20 2020 2020 2020 2073 656c 662e 6675  .        self.fu
+0000e710: 6e63 203d 2066 756e 630a 2020 2020 2020  nc = func.      
+0000e720: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
+0000e730: 5f5f 2861 7267 733d 2866 756e 632c 292c  __(args=(func,),
+0000e740: 2073 6861 7065 3d66 756e 632e 7368 6170   shape=func.shap
+0000e750: 652c 2064 7479 7065 3d63 6f6d 706c 6578  e, dtype=complex
+0000e760: 2069 6620 6675 6e63 2e64 7479 7065 203d   if func.dtype =
+0000e770: 3d20 636f 6d70 6c65 7820 656c 7365 2066  = complex else f
+0000e780: 6c6f 6174 290a 0a20 2020 2064 6566 205f  loat)..    def _
+0000e790: 7369 6d70 6c69 6669 6564 2873 656c 6629  simplified(self)
+0000e7a0: 3a0a 2020 2020 2020 2020 7265 7375 6c74  :.        result
+0000e7b0: 203d 2073 656c 662e 6675 6e63 2e5f 696e   = self.func._in
+0000e7c0: 7665 7273 6528 7365 6c66 2e6e 6469 6d2d  verse(self.ndim-
+0000e7d0: 322c 2073 656c 662e 6e64 696d 2d31 290a  2, self.ndim-1).
+0000e7e0: 2020 2020 2020 2020 6966 2072 6573 756c          if resul
+0000e7f0: 7420 6973 206e 6f74 204e 6f6e 653a 0a20  t is not None:. 
+0000e800: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000e810: 6e20 7265 7375 6c74 0a20 2020 2020 2020  n result.       
+0000e820: 2069 6620 5f65 7175 616c 735f 7363 616c   if _equals_scal
+0000e830: 6172 5f63 6f6e 7374 616e 7428 7365 6c66  ar_constant(self
+0000e840: 2e66 756e 632e 7368 6170 655b 2d31 5d2c  .func.shape[-1],
+0000e850: 2031 293a 0a20 2020 2020 2020 2020 2020   1):.           
+0000e860: 2072 6574 7572 6e20 7265 6369 7072 6f63   return reciproc
+0000e870: 616c 2873 656c 662e 6675 6e63 290a 0a20  al(self.func).. 
+0000e880: 2020 2065 7661 6c66 203d 2073 7461 7469     evalf = stati
+0000e890: 636d 6574 686f 6428 6e75 6d65 7269 632e  cmethod(numeric.
+0000e8a0: 696e 7629 0a0a 2020 2020 6465 6620 5f64  inv)..    def _d
+0000e8b0: 6572 6976 6174 6976 6528 7365 6c66 2c20  erivative(self, 
+0000e8c0: 7661 722c 2073 6565 6e29 3a0a 2020 2020  var, seen):.    
+0000e8d0: 2020 2020 7265 7475 726e 202d 6569 6e73      return -eins
+0000e8e0: 756d 2827 4169 6a2c 416a 6b42 2c41 6b6c  um('Aij,AjkB,Akl
+0000e8f0: 2d3e 4169 6c42 272c 2073 656c 662c 2064  ->AilB', self, d
+0000e900: 6572 6976 6174 6976 6528 7365 6c66 2e66  erivative(self.f
+0000e910: 756e 632c 2076 6172 2c20 7365 656e 292c  unc, var, seen),
+0000e920: 2073 656c 6629 0a0a 2020 2020 6465 6620   self)..    def 
+0000e930: 5f65 6967 2873 656c 662c 2073 796d 6d65  _eig(self, symme
+0000e940: 7472 6963 293a 0a20 2020 2020 2020 2065  tric):.        e
+0000e950: 6967 7661 6c2c 2065 6967 7665 6320 3d20  igval, eigvec = 
+0000e960: 4569 6728 7365 6c66 2e66 756e 632c 2073  Eig(self.func, s
+0000e970: 796d 6d65 7472 6963 290a 2020 2020 2020  ymmetric).      
+0000e980: 2020 7265 7475 726e 2054 7570 6c65 2828    return Tuple((
+0000e990: 7265 6369 7072 6f63 616c 2865 6967 7661  reciprocal(eigva
+0000e9a0: 6c29 2c20 6569 6776 6563 2929 0a0a 2020  l), eigvec))..  
+0000e9b0: 2020 6465 6620 5f64 6574 6572 6d69 6e61    def _determina
+0000e9c0: 6e74 2873 656c 662c 2061 7869 7331 2c20  nt(self, axis1, 
+0000e9d0: 6178 6973 3229 3a0a 2020 2020 2020 2020  axis2):.        
+0000e9e0: 6966 2073 6f72 7465 6428 5b61 7869 7331  if sorted([axis1
+0000e9f0: 2c20 6178 6973 325d 2920 3d3d 205b 7365  , axis2]) == [se
+0000ea00: 6c66 2e6e 6469 6d2d 322c 2073 656c 662e  lf.ndim-2, self.
+0000ea10: 6e64 696d 2d31 5d3a 0a20 2020 2020 2020  ndim-1]:.       
+0000ea20: 2020 2020 2072 6574 7572 6e20 7265 6369       return reci
+0000ea30: 7072 6f63 616c 2844 6574 6572 6d69 6e61  procal(Determina
+0000ea40: 6e74 2873 656c 662e 6675 6e63 2929 0a0a  nt(self.func))..
+0000ea50: 2020 2020 6465 6620 5f74 616b 6528 7365      def _take(se
+0000ea60: 6c66 2c20 696e 6469 6365 732c 2061 7869  lf, indices, axi
+0000ea70: 7329 3a0a 2020 2020 2020 2020 6966 2061  s):.        if a
+0000ea80: 7869 7320 3c20 7365 6c66 2e6e 6469 6d20  xis < self.ndim 
+0000ea90: 2d20 323a 0a20 2020 2020 2020 2020 2020  - 2:.           
+0000eaa0: 2072 6574 7572 6e20 496e 7665 7273 6528   return Inverse(
+0000eab0: 5f74 616b 6528 7365 6c66 2e66 756e 632c  _take(self.func,
+0000eac0: 2069 6e64 6963 6573 2c20 6178 6973 2929   indices, axis))
+0000ead0: 0a0a 2020 2020 6465 6620 5f74 616b 6564  ..    def _taked
+0000eae0: 6961 6728 7365 6c66 2c20 6178 6973 312c  iag(self, axis1,
+0000eaf0: 2061 7869 7332 293a 0a20 2020 2020 2020   axis2):.       
+0000eb00: 2061 7373 6572 7420 6178 6973 3120 3c20   assert axis1 < 
+0000eb10: 6178 6973 320a 2020 2020 2020 2020 6966  axis2.        if
+0000eb20: 2061 7869 7332 203c 2073 656c 662e 6e64   axis2 < self.nd
+0000eb30: 696d 2d32 3a0a 2020 2020 2020 2020 2020  im-2:.          
+0000eb40: 2020 7265 7475 726e 2069 6e76 6572 7365    return inverse
+0000eb50: 285f 7461 6b65 6469 6167 2873 656c 662e  (_takediag(self.
+0000eb60: 6675 6e63 2c20 6178 6973 312c 2061 7869  func, axis1, axi
+0000eb70: 7332 292c 2028 7365 6c66 2e6e 6469 6d2d  s2), (self.ndim-
+0000eb80: 342c 2073 656c 662e 6e64 696d 2d33 2929  4, self.ndim-3))
+0000eb90: 0a0a 2020 2020 6465 6620 5f75 6e72 6176  ..    def _unrav
+0000eba0: 656c 2873 656c 662c 2061 7869 732c 2073  el(self, axis, s
+0000ebb0: 6861 7065 293a 0a20 2020 2020 2020 2069  hape):.        i
+0000ebc0: 6620 6178 6973 203c 2073 656c 662e 6e64  f axis < self.nd
+0000ebd0: 696d 2d32 3a0a 2020 2020 2020 2020 2020  im-2:.          
+0000ebe0: 2020 7265 7475 726e 2049 6e76 6572 7365    return Inverse
+0000ebf0: 2875 6e72 6176 656c 2873 656c 662e 6675  (unravel(self.fu
+0000ec00: 6e63 2c20 6178 6973 2c20 7368 6170 6529  nc, axis, shape)
+0000ec10: 290a 0a0a 636c 6173 7320 4465 7465 726d  )...class Determ
+0000ec20: 696e 616e 7428 4172 7261 7929 3a0a 0a20  inant(Array):.. 
+0000ec30: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
+0000ec40: 7365 6c66 2c20 6675 6e63 3a20 4172 7261  self, func: Arra
+0000ec50: 7929 3a0a 2020 2020 2020 2020 6173 7365  y):.        asse
+0000ec60: 7274 2069 7361 7272 6179 2866 756e 6329  rt isarray(func)
+0000ec70: 2061 6e64 2066 756e 632e 6e64 696d 203e   and func.ndim >
+0000ec80: 3d20 3220 616e 6420 5f65 7175 616c 735f  = 2 and _equals_
+0000ec90: 7369 6d70 6c69 6669 6564 2866 756e 632e  simplified(func.
+0000eca0: 7368 6170 655b 2d31 5d2c 2066 756e 632e  shape[-1], func.
+0000ecb0: 7368 6170 655b 2d32 5d29 0a20 2020 2020  shape[-2]).     
+0000ecc0: 2020 2073 656c 662e 6675 6e63 203d 2066     self.func = f
+0000ecd0: 756e 630a 2020 2020 2020 2020 7375 7065  unc.        supe
+0000ece0: 7228 292e 5f5f 696e 6974 5f5f 2861 7267  r().__init__(arg
+0000ecf0: 733d 2866 756e 632c 292c 2073 6861 7065  s=(func,), shape
+0000ed00: 3d66 756e 632e 7368 6170 655b 3a2d 325d  =func.shape[:-2]
+0000ed10: 2c20 6474 7970 653d 636f 6d70 6c65 7820  , dtype=complex 
+0000ed20: 6966 2066 756e 632e 6474 7970 6520 3d3d  if func.dtype ==
+0000ed30: 2063 6f6d 706c 6578 2065 6c73 6520 666c   complex else fl
+0000ed40: 6f61 7429 0a0a 2020 2020 6465 6620 5f73  oat)..    def _s
+0000ed50: 696d 706c 6966 6965 6428 7365 6c66 293a  implified(self):
+0000ed60: 0a20 2020 2020 2020 2072 6573 756c 7420  .        result 
+0000ed70: 3d20 7365 6c66 2e66 756e 632e 5f64 6574  = self.func._det
+0000ed80: 6572 6d69 6e61 6e74 2873 656c 662e 6e64  erminant(self.nd
+0000ed90: 696d 2c20 7365 6c66 2e6e 6469 6d2b 3129  im, self.ndim+1)
+0000eda0: 0a20 2020 2020 2020 2069 6620 7265 7375  .        if resu
+0000edb0: 6c74 2069 7320 6e6f 7420 4e6f 6e65 3a0a  lt is not None:.
+0000edc0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000edd0: 726e 2072 6573 756c 740a 2020 2020 2020  rn result.      
+0000ede0: 2020 6966 205f 6571 7561 6c73 5f73 6361    if _equals_sca
+0000edf0: 6c61 725f 636f 6e73 7461 6e74 2873 656c  lar_constant(sel
+0000ee00: 662e 6675 6e63 2e73 6861 7065 5b2d 315d  f.func.shape[-1]
+0000ee10: 2c20 3129 3a0a 2020 2020 2020 2020 2020  , 1):.          
+0000ee20: 2020 7265 7475 726e 2054 616b 6528 5461    return Take(Ta
+0000ee30: 6b65 2873 656c 662e 6675 6e63 2c20 7a65  ke(self.func, ze
+0000ee40: 726f 7328 2829 2c20 696e 7429 292c 207a  ros((), int)), z
+0000ee50: 6572 6f73 2828 292c 2069 6e74 2929 0a0a  eros((), int))..
+0000ee60: 2020 2020 6576 616c 6620 3d20 7374 6174      evalf = stat
+0000ee70: 6963 6d65 7468 6f64 286e 756d 7079 2e6c  icmethod(numpy.l
+0000ee80: 696e 616c 672e 6465 7429 0a0a 2020 2020  inalg.det)..    
+0000ee90: 6465 6620 5f64 6572 6976 6174 6976 6528  def _derivative(
+0000eea0: 7365 6c66 2c20 7661 722c 2073 6565 6e29  self, var, seen)
+0000eeb0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+0000eec0: 2065 696e 7375 6d28 2741 2c41 6a69 2c41   einsum('A,Aji,A
+0000eed0: 696a 422d 3e41 4227 2c20 7365 6c66 2c20  ijB->AB', self, 
+0000eee0: 696e 7665 7273 6528 7365 6c66 2e66 756e  inverse(self.fun
+0000eef0: 6329 2c20 6465 7269 7661 7469 7665 2873  c), derivative(s
+0000ef00: 656c 662e 6675 6e63 2c20 7661 722c 2073  elf.func, var, s
+0000ef10: 6565 6e29 290a 0a20 2020 2064 6566 205f  een))..    def _
+0000ef20: 7461 6b65 2873 656c 662c 2069 6e64 6578  take(self, index
+0000ef30: 2c20 6178 6973 293a 0a20 2020 2020 2020  , axis):.       
+0000ef40: 2072 6574 7572 6e20 4465 7465 726d 696e   return Determin
+0000ef50: 616e 7428 5f74 616b 6528 7365 6c66 2e66  ant(_take(self.f
+0000ef60: 756e 632c 2069 6e64 6578 2c20 6178 6973  unc, index, axis
+0000ef70: 2929 0a0a 2020 2020 6465 6620 5f74 616b  ))..    def _tak
+0000ef80: 6564 6961 6728 7365 6c66 2c20 6178 6973  ediag(self, axis
+0000ef90: 312c 2061 7869 7332 293a 0a20 2020 2020  1, axis2):.     
+0000efa0: 2020 2072 6574 7572 6e20 6465 7465 726d     return determ
+0000efb0: 696e 616e 7428 5f74 616b 6564 6961 6728  inant(_takediag(
+0000efc0: 7365 6c66 2e66 756e 632c 2061 7869 7331  self.func, axis1
+0000efd0: 2c20 6178 6973 3229 2c20 2873 656c 662e  , axis2), (self.
+0000efe0: 6e64 696d 2d32 2c20 7365 6c66 2e6e 6469  ndim-2, self.ndi
+0000eff0: 6d2d 3129 290a 0a0a 636c 6173 7320 4d75  m-1))...class Mu
+0000f000: 6c74 6970 6c79 2841 7272 6179 293a 0a0a  ltiply(Array):..
+0000f010: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+0000f020: 2873 656c 662c 2066 756e 6373 3a20 7479  (self, funcs: ty
+0000f030: 7065 732e 6672 6f7a 656e 6d75 6c74 6973  pes.frozenmultis
+0000f040: 6574 293a 0a20 2020 2020 2020 2061 7373  et):.        ass
+0000f050: 6572 7420 6973 696e 7374 616e 6365 2866  ert isinstance(f
+0000f060: 756e 6373 2c20 7479 7065 732e 6672 6f7a  uncs, types.froz
+0000f070: 656e 6d75 6c74 6973 6574 292c 2066 2766  enmultiset), f'f
+0000f080: 756e 6373 3d7b 6675 6e63 7321 727d 270a  uncs={funcs!r}'.
+0000f090: 2020 2020 2020 2020 7365 6c66 2e66 756e          self.fun
+0000f0a0: 6373 203d 2066 756e 6373 0a20 2020 2020  cs = funcs.     
+0000f0b0: 2020 2066 756e 6331 2c20 6675 6e63 3220     func1, func2 
+0000f0c0: 3d20 6675 6e63 730a 2020 2020 2020 2020  = funcs.        
+0000f0d0: 6173 7365 7274 2065 7175 616c 7368 6170  assert equalshap
+0000f0e0: 6528 6675 6e63 312e 7368 6170 652c 2066  e(func1.shape, f
+0000f0f0: 756e 6332 2e73 6861 7065 2920 616e 6420  unc2.shape) and 
+0000f100: 6675 6e63 312e 6474 7970 6520 3d3d 2066  func1.dtype == f
+0000f110: 756e 6332 2e64 7479 7065 2021 3d20 626f  unc2.dtype != bo
+0000f120: 6f6c 2c20 274d 756c 7469 706c 7928 7b7d  ol, 'Multiply({}
+0000f130: 2c20 7b7d 2927 2e66 6f72 6d61 7428 6675  , {})'.format(fu
+0000f140: 6e63 312c 2066 756e 6332 290a 2020 2020  nc1, func2).    
+0000f150: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
+0000f160: 6974 5f5f 2861 7267 733d 7475 706c 6528  it__(args=tuple(
+0000f170: 7365 6c66 2e66 756e 6373 292c 2073 6861  self.funcs), sha
+0000f180: 7065 3d66 756e 6331 2e73 6861 7065 2c20  pe=func1.shape, 
+0000f190: 6474 7970 653d 6675 6e63 312e 6474 7970  dtype=func1.dtyp
+0000f1a0: 6529 0a0a 2020 2020 4070 726f 7065 7274  e)..    @propert
+0000f1b0: 790a 2020 2020 6465 6620 5f66 6163 746f  y.    def _facto
+0000f1c0: 7273 2873 656c 6629 3a0a 2020 2020 2020  rs(self):.      
+0000f1d0: 2020 666f 7220 6675 6e63 2069 6e20 7365    for func in se
+0000f1e0: 6c66 2e66 756e 6373 3a0a 2020 2020 2020  lf.funcs:.      
+0000f1f0: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+0000f200: 6e63 6528 6675 6e63 2c20 4d75 6c74 6970  nce(func, Multip
+0000f210: 6c79 293a 0a20 2020 2020 2020 2020 2020  ly):.           
+0000f220: 2020 2020 2079 6965 6c64 2066 726f 6d20       yield from 
+0000f230: 6675 6e63 2e5f 6661 6374 6f72 730a 2020  func._factors.  
+0000f240: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000f250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f260: 7969 656c 6420 6675 6e63 0a0a 2020 2020  yield func..    
+0000f270: 6465 6620 5f73 696d 706c 6966 6965 6428  def _simplified(
+0000f280: 7365 6c66 293a 0a20 2020 2020 2020 2066  self):.        f
+0000f290: 6163 746f 7273 203d 2074 7570 6c65 2873  actors = tuple(s
+0000f2a0: 656c 662e 5f66 6163 746f 7273 290a 2020  elf._factors).  
+0000f2b0: 2020 2020 2020 666f 7220 6a2c 2066 6a20        for j, fj 
+0000f2c0: 696e 2065 6e75 6d65 7261 7465 2866 6163  in enumerate(fac
+0000f2d0: 746f 7273 293a 0a20 2020 2020 2020 2020  tors):.         
+0000f2e0: 2020 2069 6620 666a 2e5f 636f 6e73 745f     if fj._const_
+0000f2f0: 756e 6966 6f72 6d20 3d3d 2031 3a0a 2020  uniform == 1:.  
+0000f300: 2020 2020 2020 2020 2020 2020 2020 7265                re
+0000f310: 7475 726e 206d 756c 7469 706c 7928 2a66  turn multiply(*f
+0000f320: 6163 746f 7273 5b3a 6a5d 2c20 2a66 6163  actors[:j], *fac
+0000f330: 746f 7273 5b6a 2b31 3a5d 290a 2020 2020  tors[j+1:]).    
+0000f340: 2020 2020 2020 2020 666f 7220 692c 2070          for i, p
+0000f350: 6172 7473 2069 6e20 666a 2e5f 696e 666c  arts in fj._infl
+0000f360: 6174 696f 6e73 3a0a 2020 2020 2020 2020  ations:.        
+0000f370: 2020 2020 2020 2020 7265 7475 726e 2075          return u
+0000f380: 7469 6c2e 7375 6d28 5f69 6e66 6c61 7465  til.sum(_inflate
+0000f390: 286d 756c 7469 706c 7928 662c 202a 285f  (multiply(f, *(_
+0000f3a0: 7461 6b65 2866 692c 2064 6f66 6d61 702c  take(fi, dofmap,
+0000f3b0: 2069 2920 666f 7220 6669 2069 6e20 6661   i) for fi in fa
+0000f3c0: 6374 6f72 735b 3a6a 5d20 2b20 6661 6374  ctors[:j] + fact
+0000f3d0: 6f72 735b 6a2b 313a 5d29 292c 2064 6f66  ors[j+1:])), dof
+0000f3e0: 6d61 702c 2073 656c 662e 7368 6170 655b  map, self.shape[
+0000f3f0: 695d 2c20 6929 2066 6f72 2064 6f66 6d61  i], i) for dofma
+0000f400: 702c 2066 2069 6e20 7061 7274 732e 6974  p, f in parts.it
+0000f410: 656d 7328 2929 0a20 2020 2020 2020 2020  ems()).         
+0000f420: 2020 2066 6f72 2061 7869 7331 2c20 6178     for axis1, ax
+0000f430: 6973 322c 202a 6f74 6865 7220 696e 206d  is2, *other in m
+0000f440: 6170 2873 6f72 7465 642c 2066 6a2e 5f64  ap(sorted, fj._d
+0000f450: 6961 676f 6e61 6c73 293a 0a20 2020 2020  iagonals):.     
+0000f460: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000f470: 6e20 6469 6167 6f6e 616c 697a 6528 6d75  n diagonalize(mu
+0000f480: 6c74 6970 6c79 282a 2874 616b 6564 6961  ltiply(*(takedia
+0000f490: 6728 662c 2061 7869 7331 2c20 6178 6973  g(f, axis1, axis
+0000f4a0: 3229 2066 6f72 2066 2069 6e20 6661 6374  2) for f in fact
+0000f4b0: 6f72 7329 292c 2061 7869 7331 2c20 6178  ors)), axis1, ax
+0000f4c0: 6973 3229 0a20 2020 2020 2020 2020 2020  is2).           
+0000f4d0: 2066 6f72 2069 2c20 6669 2069 6e20 656e   for i, fi in en
+0000f4e0: 756d 6572 6174 6528 6661 6374 6f72 735b  umerate(factors[
+0000f4f0: 3a6a 5d29 3a0a 2020 2020 2020 2020 2020  :j]):.          
+0000f500: 2020 2020 2020 756e 616c 6967 6e65 6431        unaligned1
+0000f510: 2c20 756e 616c 6967 6e65 6432 2c20 7768  , unaligned2, wh
+0000f520: 6572 6520 3d20 756e 616c 6967 6e28 6669  ere = unalign(fi
+0000f530: 2c20 666a 290a 2020 2020 2020 2020 2020  , fj).          
+0000f540: 2020 2020 2020 6669 6a20 3d20 616c 6967        fij = alig
+0000f550: 6e28 756e 616c 6967 6e65 6431 202a 2075  n(unaligned1 * u
+0000f560: 6e61 6c69 676e 6564 322c 2077 6865 7265  naligned2, where
+0000f570: 2c20 7365 6c66 2e73 6861 7065 2920 6966  , self.shape) if
+0000f580: 206c 656e 2877 6865 7265 2920 213d 2073   len(where) != s
+0000f590: 656c 662e 6e64 696d 205c 0a20 2020 2020  elf.ndim \.     
+0000f5a0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000f5b0: 6c73 6520 6669 2e5f 6d75 6c74 6970 6c79  lse fi._multiply
+0000f5c0: 2866 6a29 206f 7220 666a 2e5f 6d75 6c74  (fj) or fj._mult
+0000f5d0: 6970 6c79 2866 6929 0a20 2020 2020 2020  iply(fi).       
+0000f5e0: 2020 2020 2020 2020 2069 6620 6669 6a3a           if fij:
+0000f5f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f600: 2020 2020 2072 6574 7572 6e20 6d75 6c74       return mult
+0000f610: 6970 6c79 282a 6661 6374 6f72 735b 3a69  iply(*factors[:i
+0000f620: 5d2c 202a 6661 6374 6f72 735b 692b 313a  ], *factors[i+1:
+0000f630: 6a5d 2c20 2a66 6163 746f 7273 5b6a 2b31  j], *factors[j+1
+0000f640: 3a5d 2c20 6669 6a29 0a0a 2020 2020 6465  :], fij)..    de
+0000f650: 6620 5f6f 7074 696d 697a 6564 5f66 6f72  f _optimized_for
+0000f660: 5f6e 756d 7079 2873 656c 6629 3a0a 2020  _numpy(self):.  
+0000f670: 2020 2020 2020 6661 6374 6f72 7320 3d20        factors = 
+0000f680: 7475 706c 6528 7365 6c66 2e5f 6661 6374  tuple(self._fact
+0000f690: 6f72 7329 0a20 2020 2020 2020 2066 6f72  ors).        for
+0000f6a0: 2069 2c20 6669 2069 6e20 656e 756d 6572   i, fi in enumer
+0000f6b0: 6174 6528 6661 6374 6f72 7329 3a0a 2020  ate(factors):.  
+0000f6c0: 2020 2020 2020 2020 2020 6966 2066 692e            if fi.
+0000f6d0: 6474 7970 6520 213d 2062 6f6f 6c20 616e  dtype != bool an
+0000f6e0: 6420 6669 2e5f 636f 6e73 745f 756e 6966  d fi._const_unif
+0000f6f0: 6f72 6d20 3d3d 202d 313a 0a20 2020 2020  orm == -1:.     
+0000f700: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000f710: 6e20 4e65 6761 7469 7665 286d 756c 7469  n Negative(multi
+0000f720: 706c 7928 2a66 6163 746f 7273 5b3a 695d  ply(*factors[:i]
+0000f730: 2c20 2a66 6163 746f 7273 5b69 2b31 3a5d  , *factors[i+1:]
+0000f740: 2929 0a20 2020 2020 2020 2020 2020 2069  )).            i
+0000f750: 6620 6669 2e64 7479 7065 2021 3d20 636f  f fi.dtype != co
+0000f760: 6d70 6c65 7820 616e 6420 5369 676e 2866  mplex and Sign(f
+0000f770: 6929 2069 6e20 6661 6374 6f72 733a 0a20  i) in factors:. 
+0000f780: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000f790: 2c20 6a20 3d20 736f 7274 6564 285b 692c  , j = sorted([i,
+0000f7a0: 2066 6163 746f 7273 2e69 6e64 6578 2853   factors.index(S
+0000f7b0: 6967 6e28 6669 2929 5d29 0a20 2020 2020  ign(fi))]).     
+0000f7c0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000f7d0: 6e20 6d75 6c74 6970 6c79 282a 6661 6374  n multiply(*fact
+0000f7e0: 6f72 735b 3a69 5d2c 202a 6661 6374 6f72  ors[:i], *factor
+0000f7f0: 735b 692b 313a 6a5d 2c20 2a66 6163 746f  s[i+1:j], *facto
+0000f800: 7273 5b6a 2b31 3a5d 2c20 4162 736f 6c75  rs[j+1:], Absolu
+0000f810: 7465 2866 6929 290a 2020 2020 2020 2020  te(fi)).        
+0000f820: 6966 2073 656c 662e 6e64 696d 3a0a 2020  if self.ndim:.  
+0000f830: 2020 2020 2020 2020 2020 6172 6773 2c20            args, 
+0000f840: 6172 6773 5f69 6478 203d 207a 6970 282a  args_idx = zip(*
+0000f850: 6d61 7028 756e 616c 6967 6e2c 2066 6163  map(unalign, fac
+0000f860: 746f 7273 2929 0a20 2020 2020 2020 2020  tors)).         
+0000f870: 2020 2072 6574 7572 6e20 4569 6e73 756d     return Einsum
+0000f880: 2861 7267 732c 2061 7267 735f 6964 782c  (args, args_idx,
+0000f890: 2074 7570 6c65 2872 616e 6765 2873 656c   tuple(range(sel
+0000f8a0: 662e 6e64 696d 2929 290a 0a20 2020 2065  f.ndim)))..    e
+0000f8b0: 7661 6c66 203d 2073 7461 7469 636d 6574  valf = staticmet
+0000f8c0: 686f 6428 6e75 6d70 792e 6d75 6c74 6970  hod(numpy.multip
+0000f8d0: 6c79 290a 0a20 2020 2064 6566 205f 7375  ly)..    def _su
+0000f8e0: 6d28 7365 6c66 2c20 6178 6973 293a 0a20  m(self, axis):. 
+0000f8f0: 2020 2020 2020 2066 6163 746f 7273 203d         factors =
+0000f900: 2074 7570 6c65 2873 656c 662e 5f66 6163   tuple(self._fac
+0000f910: 746f 7273 290a 2020 2020 2020 2020 666f  tors).        fo
+0000f920: 7220 692c 2066 6920 696e 2065 6e75 6d65  r i, fi in enume
+0000f930: 7261 7465 2866 6163 746f 7273 293a 0a20  rate(factors):. 
+0000f940: 2020 2020 2020 2020 2020 2075 6e61 6c69             unali
+0000f950: 676e 6564 2c20 7768 6572 6520 3d20 756e  gned, where = un
+0000f960: 616c 6967 6e28 6669 290a 2020 2020 2020  align(fi).      
+0000f970: 2020 2020 2020 6966 2061 7869 7320 6e6f        if axis no
+0000f980: 7420 696e 2077 6865 7265 3a0a 2020 2020  t in where:.    
+0000f990: 2020 2020 2020 2020 2020 2020 7375 6d6d              summ
+0000f9a0: 6564 203d 2073 756d 286d 756c 7469 706c  ed = sum(multipl
+0000f9b0: 7928 2a66 6163 746f 7273 5b3a 695d 2c20  y(*factors[:i], 
+0000f9c0: 2a66 6163 746f 7273 5b69 2b31 3a5d 292c  *factors[i+1:]),
+0000f9d0: 2061 7869 7329 0a20 2020 2020 2020 2020   axis).         
+0000f9e0: 2020 2020 2020 2072 6574 7572 6e20 7375         return su
+0000f9f0: 6d6d 6564 202a 2061 6c69 676e 2875 6e61  mmed * align(una
+0000fa00: 6c69 676e 6564 2c20 5b69 2d28 6920 3e20  ligned, [i-(i > 
+0000fa10: 6178 6973 2920 666f 7220 6920 696e 2077  axis) for i in w
+0000fa20: 6865 7265 5d2c 2073 756d 6d65 642e 7368  here], summed.sh
+0000fa30: 6170 6529 0a0a 2020 2020 6465 6620 5f61  ape)..    def _a
+0000fa40: 6464 2873 656c 662c 206f 7468 6572 293a  dd(self, other):
+0000fa50: 0a20 2020 2020 2020 2066 6163 746f 7273  .        factors
+0000fa60: 203d 206c 6973 7428 7365 6c66 2e5f 6661   = list(self._fa
+0000fa70: 6374 6f72 7329 0a20 2020 2020 2020 206f  ctors).        o
+0000fa80: 7468 6572 5f66 6163 746f 7273 203d 205b  ther_factors = [
+0000fa90: 5d0a 2020 2020 2020 2020 636f 6d6d 6f6e  ].        common
+0000faa0: 203d 205b 5d0a 2020 2020 2020 2020 666f   = [].        fo
+0000fab0: 7220 6620 696e 206f 7468 6572 2e5f 6661  r f in other._fa
+0000fac0: 6374 6f72 7320 6966 2069 7369 6e73 7461  ctors if isinsta
+0000fad0: 6e63 6528 6f74 6865 722c 204d 756c 7469  nce(other, Multi
+0000fae0: 706c 7929 2065 6c73 6520 5b6f 7468 6572  ply) else [other
+0000faf0: 5d3a 0a20 2020 2020 2020 2020 2020 2069  ]:.            i
+0000fb00: 6620 6620 696e 2066 6163 746f 7273 3a0a  f f in factors:.
+0000fb10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fb20: 6661 6374 6f72 732e 7265 6d6f 7665 2866  factors.remove(f
+0000fb30: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000fb40: 2020 636f 6d6d 6f6e 2e61 7070 656e 6428    common.append(
+0000fb50: 6629 0a20 2020 2020 2020 2020 2020 2065  f).            e
+0000fb60: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000fb70: 2020 2020 206f 7468 6572 5f66 6163 746f       other_facto
+0000fb80: 7273 2e61 7070 656e 6428 6629 0a20 2020  rs.append(f).   
+0000fb90: 2020 2020 2069 6620 6e6f 7420 636f 6d6d       if not comm
+0000fba0: 6f6e 3a0a 2020 2020 2020 2020 2020 2020  on:.            
+0000fbb0: 7265 7475 726e 0a20 2020 2020 2020 2069  return.        i
+0000fbc0: 6620 6661 6374 6f72 7320 616e 6420 6f74  f factors and ot
+0000fbd0: 6865 725f 6661 6374 6f72 733a 0a20 2020  her_factors:.   
+0000fbe0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000fbf0: 6d75 6c74 6970 6c79 282a 636f 6d6d 6f6e  multiply(*common
+0000fc00: 2920 2a20 6164 6428 6d75 6c74 6970 6c79  ) * add(multiply
+0000fc10: 282a 6661 6374 6f72 7329 2c20 6d75 6c74  (*factors), mult
+0000fc20: 6970 6c79 282a 6f74 6865 725f 6661 6374  iply(*other_fact
+0000fc30: 6f72 7329 290a 2020 2020 2020 2020 6e7a  ors)).        nz
+0000fc40: 203d 2066 6163 746f 7273 206f 7220 6f74   = factors or ot
+0000fc50: 6865 725f 6661 6374 6f72 730a 2020 2020  her_factors.    
+0000fc60: 2020 2020 6966 206e 6f74 206e 7a3a 2023      if not nz: #
+0000fc70: 2073 656c 6620 6571 7561 6c73 206f 7468   self equals oth
+0000fc80: 6572 2028 7570 2074 6f20 6661 6374 6f72  er (up to factor
+0000fc90: 206f 7264 6572 696e 6729 0a20 2020 2020   ordering).     
+0000fca0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000fcb0: 6c66 202a 2032 0a20 2020 2020 2020 2069  lf * 2.        i
+0000fcc0: 6620 6c65 6e28 6e7a 2920 3d3d 2031 2061  f len(nz) == 1 a
+0000fcd0: 6e64 2074 7570 6c65 286e 7a29 5b30 5d2e  nd tuple(nz)[0].
+0000fce0: 5f63 6f6e 7374 5f75 6e69 666f 726d 203d  _const_uniform =
+0000fcf0: 3d20 2d31 3a0a 2020 2020 2020 2020 2020  = -1:.          
+0000fd00: 2020 2320 5369 6e63 6520 7468 6520 7375    # Since the su
+0000fd10: 6274 7261 6374 696f 6e20 7820 2d20 7920  btraction x - y 
+0000fd20: 6973 2073 746f 7265 6420 6173 2078 202b  is stored as x +
+0000fd30: 202d 3120 2a20 792c 2074 6869 7320 6861   -1 * y, this ha
+0000fd40: 6e64 6c65 730a 2020 2020 2020 2020 2020  ndles.          
+0000fd50: 2020 2320 7468 6520 7369 6d70 6c69 6669    # the simplifi
+0000fd60: 6361 7469 6f6e 206f 6620 7820 2d20 7820  cation of x - x 
+0000fd70: 746f 2030 2e20 5768 696c 6520 7765 2063  to 0. While we c
+0000fd80: 6f75 6c64 2061 6c74 6572 6e61 7469 7665  ould alternative
+0000fd90: 6c79 0a20 2020 2020 2020 2020 2020 2023  ly.            #
+0000fda0: 2073 696d 706c 6966 7920 616c 6c20 7820   simplify all x 
+0000fdb0: 2b20 6120 2a20 7820 746f 2028 6120 2b20  + a * x to (a + 
+0000fdc0: 3129 202a 2078 2c20 6361 7074 7572 696e  1) * x, capturin
+0000fdd0: 6720 6120 3d3d 202d 3120 6173 2061 0a20  g a == -1 as a. 
+0000fde0: 2020 2020 2020 2020 2020 2023 2073 7065             # spe
+0000fdf0: 6369 616c 2063 6173 6520 7669 6120 436f  cial case via Co
+0000fe00: 6e73 7461 6e74 2e5f 6164 642c 2069 7420  nstant._add, it 
+0000fe10: 6973 206e 6f74 206f 6276 696f 7573 2074  is not obvious t
+0000fe20: 6861 7420 7468 6973 2069 7320 696e 0a20  hat this is in. 
+0000fe30: 2020 2020 2020 2020 2020 2023 2061 6c6c             # all
+0000fe40: 2073 6974 7561 7469 6f6e 7320 616e 2069   situations an i
+0000fe50: 6d70 726f 7665 6d65 6e74 2e0a 2020 2020  mprovement..    
+0000fe60: 2020 2020 2020 2020 7265 7475 726e 207a          return z
+0000fe70: 6572 6f73 5f6c 696b 6528 7365 6c66 290a  eros_like(self).
+0000fe80: 0a20 2020 2064 6566 205f 6465 7465 726d  .    def _determ
+0000fe90: 696e 616e 7428 7365 6c66 2c20 6178 6973  inant(self, axis
+0000fea0: 312c 2061 7869 7332 293a 0a20 2020 2020  1, axis2):.     
+0000feb0: 2020 2061 7869 7331 2c20 6178 6973 3220     axis1, axis2 
+0000fec0: 3d20 736f 7274 6564 285b 6178 6973 312c  = sorted([axis1,
+0000fed0: 2061 7869 7332 5d29 0a20 2020 2020 2020   axis2]).       
+0000fee0: 2066 6163 746f 7273 203d 2074 7570 6c65   factors = tuple
+0000fef0: 2873 656c 662e 5f66 6163 746f 7273 290a  (self._factors).
+0000ff00: 2020 2020 2020 2020 6966 2061 6c6c 285f          if all(_
+0000ff10: 6571 7561 6c73 5f73 6361 6c61 725f 636f  equals_scalar_co
+0000ff20: 6e73 7461 6e74 2873 656c 662e 7368 6170  nstant(self.shap
+0000ff30: 655b 6178 6973 5d2c 2031 2920 666f 7220  e[axis], 1) for 
+0000ff40: 6178 6973 2069 6e20 2861 7869 7331 2c20  axis in (axis1, 
+0000ff50: 6178 6973 3229 293a 0a20 2020 2020 2020  axis2)):.       
+0000ff60: 2020 2020 2072 6574 7572 6e20 6d75 6c74       return mult
+0000ff70: 6970 6c79 282a 5b64 6574 6572 6d69 6e61  iply(*[determina
+0000ff80: 6e74 2866 2c20 2861 7869 7331 2c20 6178  nt(f, (axis1, ax
+0000ff90: 6973 3229 2920 666f 7220 6620 696e 2066  is2)) for f in f
+0000ffa0: 6163 746f 7273 5d29 0a20 2020 2020 2020  actors]).       
+0000ffb0: 2066 6f72 2069 2c20 6669 2069 6e20 656e   for i, fi in en
+0000ffc0: 756d 6572 6174 6528 6661 6374 6f72 7329  umerate(factors)
+0000ffd0: 3a0a 2020 2020 2020 2020 2020 2020 756e  :.            un
+0000ffe0: 616c 6967 6e65 642c 2077 6865 7265 203d  aligned, where =
+0000fff0: 2075 6e61 6c69 676e 2866 6929 0a20 2020   unalign(fi).   
+00010000: 2020 2020 2020 2020 2069 6620 6178 6973           if axis
+00010010: 3120 6e6f 7420 696e 2077 6865 7265 2061  1 not in where a
+00010020: 6e64 2061 7869 7332 206e 6f74 2069 6e20  nd axis2 not in 
+00010030: 7768 6572 653a 0a20 2020 2020 2020 2020  where:.         
+00010040: 2020 2020 2020 2064 6574 203d 2064 6574         det = det
+00010050: 6572 6d69 6e61 6e74 286d 756c 7469 706c  erminant(multipl
+00010060: 7928 2a66 6163 746f 7273 5b3a 695d 2c20  y(*factors[:i], 
+00010070: 2a66 6163 746f 7273 5b69 2b31 3a5d 292c  *factors[i+1:]),
+00010080: 2028 6178 6973 312c 2061 7869 7332 2929   (axis1, axis2))
+00010090: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000100a0: 2073 6361 6c65 203d 2061 6c69 676e 2875   scale = align(u
+000100b0: 6e61 6c69 676e 6564 2a2a 7365 6c66 2e73  naligned**self.s
+000100c0: 6861 7065 5b61 7869 7331 5d2c 205b 692d  hape[axis1], [i-
+000100d0: 2869 203e 2061 7869 7331 292d 2869 203e  (i > axis1)-(i >
+000100e0: 2061 7869 7332 2920 666f 7220 6920 696e   axis2) for i in
+000100f0: 2077 6865 7265 2069 6620 6920 6e6f 7420   where if i not 
+00010100: 696e 2028 6178 6973 312c 2061 7869 7332  in (axis1, axis2
+00010110: 295d 2c20 6465 742e 7368 6170 6529 0a20  )], det.shape). 
+00010120: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00010130: 6574 7572 6e20 6465 7420 2a20 7363 616c  eturn det * scal
+00010140: 650a 0a20 2020 2064 6566 205f 7072 6f64  e..    def _prod
+00010150: 7563 7428 7365 6c66 293a 0a20 2020 2020  uct(self):.     
+00010160: 2020 2072 6574 7572 6e20 6d75 6c74 6970     return multip
+00010170: 6c79 282a 5b50 726f 6475 6374 2866 2920  ly(*[Product(f) 
+00010180: 666f 7220 6620 696e 2073 656c 662e 5f66  for f in self._f
+00010190: 6163 746f 7273 5d29 0a0a 2020 2020 6465  actors])..    de
+000101a0: 6620 5f64 6572 6976 6174 6976 6528 7365  f _derivative(se
+000101b0: 6c66 2c20 7661 722c 2073 6565 6e29 3a0a  lf, var, seen):.
+000101c0: 2020 2020 2020 2020 6675 6e63 312c 2066          func1, f
+000101d0: 756e 6332 203d 2073 656c 662e 6675 6e63  unc2 = self.func
+000101e0: 730a 2020 2020 2020 2020 7265 7475 726e  s.        return
+000101f0: 2065 696e 7375 6d28 2741 2c41 422d 3e41   einsum('A,AB->A
+00010200: 4227 2c20 6675 6e63 312c 2064 6572 6976  B', func1, deriv
+00010210: 6174 6976 6528 6675 6e63 322c 2076 6172  ative(func2, var
+00010220: 2c20 7365 656e 2929 205c 0a20 2020 2020  , seen)) \.     
+00010230: 2020 2020 2020 202b 2065 696e 7375 6d28         + einsum(
+00010240: 2741 2c41 422d 3e41 4227 2c20 6675 6e63  'A,AB->AB', func
+00010250: 322c 2064 6572 6976 6174 6976 6528 6675  2, derivative(fu
+00010260: 6e63 312c 2076 6172 2c20 7365 656e 2929  nc1, var, seen))
+00010270: 0a0a 2020 2020 6465 6620 5f74 616b 6564  ..    def _taked
+00010280: 6961 6728 7365 6c66 2c20 6178 6973 312c  iag(self, axis1,
+00010290: 2061 7869 7332 293a 0a20 2020 2020 2020   axis2):.       
+000102a0: 2072 6574 7572 6e20 6d75 6c74 6970 6c79   return multiply
+000102b0: 282a 5b5f 7461 6b65 6469 6167 2866 2c20  (*[_takediag(f, 
+000102c0: 6178 6973 312c 2061 7869 7332 2920 666f  axis1, axis2) fo
+000102d0: 7220 6620 696e 2073 656c 662e 5f66 6163  r f in self._fac
+000102e0: 746f 7273 5d29 0a0a 2020 2020 6465 6620  tors])..    def 
+000102f0: 5f74 616b 6528 7365 6c66 2c20 696e 6465  _take(self, inde
+00010300: 782c 2061 7869 7329 3a0a 2020 2020 2020  x, axis):.      
+00010310: 2020 7265 7475 726e 206d 756c 7469 706c    return multipl
+00010320: 7928 2a5b 5f74 616b 6528 662c 2069 6e64  y(*[_take(f, ind
+00010330: 6578 2c20 6178 6973 2920 666f 7220 6620  ex, axis) for f 
+00010340: 696e 2073 656c 662e 5f66 6163 746f 7273  in self._factors
+00010350: 5d29 0a0a 2020 2020 6465 6620 5f73 6967  ])..    def _sig
+00010360: 6e28 7365 6c66 293a 0a20 2020 2020 2020  n(self):.       
+00010370: 2072 6574 7572 6e20 6d75 6c74 6970 6c79   return multiply
+00010380: 282a 5b53 6967 6e28 6629 2066 6f72 2066  (*[Sign(f) for f
+00010390: 2069 6e20 7365 6c66 2e5f 6661 6374 6f72   in self._factor
+000103a0: 735d 290a 0a20 2020 2064 6566 205f 756e  s])..    def _un
+000103b0: 7261 7665 6c28 7365 6c66 2c20 6178 6973  ravel(self, axis
+000103c0: 2c20 7368 6170 6529 3a0a 2020 2020 2020  , shape):.      
+000103d0: 2020 7265 7475 726e 206d 756c 7469 706c    return multipl
+000103e0: 7928 2a5b 756e 7261 7665 6c28 662c 2061  y(*[unravel(f, a
+000103f0: 7869 732c 2073 6861 7065 2920 666f 7220  xis, shape) for 
+00010400: 6620 696e 2073 656c 662e 5f66 6163 746f  f in self._facto
+00010410: 7273 5d29 0a0a 2020 2020 6465 6620 5f69  rs])..    def _i
+00010420: 6e76 6572 7365 2873 656c 662c 2061 7869  nverse(self, axi
+00010430: 7331 2c20 6178 6973 3229 3a0a 2020 2020  s1, axis2):.    
+00010440: 2020 2020 6661 6374 6f72 7320 3d20 7475      factors = tu
+00010450: 706c 6528 7365 6c66 2e5f 6661 6374 6f72  ple(self._factor
+00010460: 7329 0a20 2020 2020 2020 2066 6f72 2069  s).        for i
+00010470: 2c20 6669 2069 6e20 656e 756d 6572 6174  , fi in enumerat
+00010480: 6528 6661 6374 6f72 7329 3a0a 2020 2020  e(factors):.    
+00010490: 2020 2020 2020 2020 6966 2073 6574 2875          if set(u
+000104a0: 6e61 6c69 676e 2866 6929 5b31 5d29 2e69  nalign(fi)[1]).i
+000104b0: 7364 6973 6a6f 696e 7428 2861 7869 7331  sdisjoint((axis1
+000104c0: 2c20 6178 6973 3229 293a 0a20 2020 2020  , axis2)):.     
+000104d0: 2020 2020 2020 2020 2020 2069 6e76 203d             inv =
+000104e0: 2069 6e76 6572 7365 286d 756c 7469 706c   inverse(multipl
+000104f0: 7928 2a66 6163 746f 7273 5b3a 695d 2c20  y(*factors[:i], 
+00010500: 2a66 6163 746f 7273 5b69 2b31 3a5d 292c  *factors[i+1:]),
+00010510: 2028 6178 6973 312c 2061 7869 7332 2929   (axis1, axis2))
+00010520: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010530: 2072 6574 7572 6e20 6469 7669 6465 2869   return divide(i
+00010540: 6e76 2c20 6669 290a 0a20 2020 2040 6361  nv, fi)..    @ca
+00010550: 6368 6564 5f70 726f 7065 7274 790a 2020  ched_property.  
+00010560: 2020 6465 6620 5f61 7373 7061 7273 6528    def _assparse(
+00010570: 7365 6c66 293a 0a20 2020 2020 2020 2023  self):.        #
+00010580: 2046 6972 7374 2077 6520 636f 6c6c 6563   First we collec
+00010590: 7420 7468 6520 636c 7573 7465 7273 206f  t the clusters o
+000105a0: 6620 6661 6374 6f72 7320 7468 6174 2068  f factors that h
+000105b0: 6176 6520 6e6f 2072 6561 6c20 2869 2e65  ave no real (i.e
+000105c0: 2e20 6e6f 740a 2020 2020 2020 2020 2320  . not.        # 
+000105d0: 696e 7365 7274 6564 2920 6178 6573 2069  inserted) axes i
+000105e0: 6e20 636f 6d6d 6f6e 2077 6974 6820 7468  n common with th
+000105f0: 6520 6f74 6865 7220 636c 7573 7465 7273  e other clusters
+00010600: 2c20 616e 6420 7374 6f72 6520 7468 656d  , and store them
+00010610: 2069 6e0a 2020 2020 2020 2020 2320 756e   in.        # un
+00010620: 696e 7365 7274 6564 2066 6f72 6d2e 0a20  inserted form.. 
+00010630: 2020 2020 2020 2063 6c75 7374 6572 7320         clusters 
+00010640: 3d20 5b5d 0a20 2020 2020 2020 2066 6f72  = [].        for
+00010650: 2066 2069 6e20 7365 6c66 2e5f 6661 6374   f in self._fact
+00010660: 6f72 733a 0a20 2020 2020 2020 2020 2020  ors:.           
+00010670: 2075 6e69 6e73 6572 7465 642c 2077 6865   uninserted, whe
+00010680: 7265 203d 2075 6e61 6c69 676e 2866 290a  re = unalign(f).
+00010690: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+000106a0: 6920 696e 2072 6576 6572 7365 6428 7261  i in reversed(ra
+000106b0: 6e67 6528 6c65 6e28 636c 7573 7465 7273  nge(len(clusters
+000106c0: 2929 293a 0a20 2020 2020 2020 2020 2020  ))):.           
+000106d0: 2020 2020 2069 6620 7365 7428 7768 6572       if set(wher
+000106e0: 6529 2026 2073 6574 2863 6c75 7374 6572  e) & set(cluster
+000106f0: 735b 695d 5b31 5d29 3a0a 2020 2020 2020  s[i][1]):.      
+00010700: 2020 2020 2020 2020 2020 2020 2020 7720                w 
+00010710: 3d20 7768 6572 650a 2020 2020 2020 2020  = where.        
+00010720: 2020 2020 2020 2020 2020 2020 756e 696e              unin
+00010730: 735f 2c20 775f 203d 2063 6c75 7374 6572  s_, w_ = cluster
+00010740: 732e 706f 7028 6929 0a20 2020 2020 2020  s.pop(i).       
+00010750: 2020 2020 2020 2020 2020 2020 2077 6865               whe
+00010760: 7265 203d 206e 756d 7079 2e75 6e69 6f6e  re = numpy.union
+00010770: 3164 2877 2c20 775f 290a 2020 2020 2020  1d(w, w_).      
+00010780: 2020 2020 2020 2020 2020 2020 2020 7368                sh
+00010790: 6170 6520 3d20 7475 706c 6528 7365 6c66  ape = tuple(self
+000107a0: 2e73 6861 7065 5b69 5d20 666f 7220 6920  .shape[i] for i 
+000107b0: 696e 2077 6865 7265 290a 2020 2020 2020  in where).      
+000107c0: 2020 2020 2020 2020 2020 2020 2020 756e                un
+000107d0: 696e 7365 7274 6564 203d 2061 6c69 676e  inserted = align
+000107e0: 2875 6e69 6e73 6572 7465 642c 206e 756d  (uninserted, num
+000107f0: 7079 2e73 6561 7263 6873 6f72 7465 6428  py.searchsorted(
+00010800: 7768 6572 652c 2077 292c 2073 6861 7065  where, w), shape
+00010810: 2920 2a20 616c 6967 6e28 756e 696e 735f  ) * align(unins_
+00010820: 2c20 6e75 6d70 792e 7365 6172 6368 736f  , numpy.searchso
+00010830: 7274 6564 2877 6865 7265 2c20 775f 292c  rted(where, w_),
+00010840: 2073 6861 7065 290a 2020 2020 2020 2020   shape).        
+00010850: 2020 2020 636c 7573 7465 7273 2e61 7070      clusters.app
+00010860: 656e 6428 2875 6e69 6e73 6572 7465 642c  end((uninserted,
+00010870: 2077 6865 7265 2929 0a20 2020 2020 2020   where)).       
+00010880: 2023 2049 6620 7468 6572 6520 6973 206f   # If there is o
+00010890: 6e6c 7920 6f6e 6520 636c 7573 7465 7220  nly one cluster 
+000108a0: 7765 2066 616c 6c20 6261 636b 206f 6e20  we fall back on 
+000108b0: 7468 6520 6465 6661 756c 740a 2020 2020  the default.    
+000108c0: 2020 2020 2320 696d 706c 656d 656e 7461      # implementa
+000108d0: 7469 6f6e 2e0a 2020 2020 2020 2020 6966  tion..        if
+000108e0: 206c 656e 2863 6c75 7374 6572 7329 203d   len(clusters) =
+000108f0: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
+00010900: 2072 6574 7572 6e20 7375 7065 7228 292e   return super().
+00010910: 5f61 7373 7061 7273 650a 2020 2020 2020  _assparse.      
+00010920: 2020 2320 4966 2074 6865 7265 2061 7265    # If there are
+00010930: 2074 776f 206f 7220 6d6f 7265 2063 6c75   two or more clu
+00010940: 7374 6572 7320 7765 2077 7269 7465 2074  sters we write t
+00010950: 6865 2070 726f 6475 6374 206f 6620 6164  he product of ad
+00010960: 6469 7469 6f6e 730a 2020 2020 2020 2020  ditions.        
+00010970: 2320 6173 2061 6e20 6164 6469 7469 6f6e  # as an addition
+00010980: 206f 6620 7072 6f64 7563 7473 2e0a 2020   of products..  
+00010990: 2020 2020 2020 756e 696e 7365 7274 6564        uninserted
+000109a0: 732c 2077 6865 7265 7320 3d20 7a69 7028  s, wheres = zip(
+000109b0: 2a63 6c75 7374 6572 7329 0a20 2020 2020  *clusters).     
+000109c0: 2020 2073 7061 7273 6520 3d20 5b5d 0a20     sparse = []. 
+000109d0: 2020 2020 2020 2066 6f72 2069 7465 6d73         for items
+000109e0: 2069 6e20 6974 6572 746f 6f6c 732e 7072   in itertools.pr
+000109f0: 6f64 7563 7428 2a5b 752e 5f61 7373 7061  oduct(*[u._asspa
+00010a00: 7273 6520 666f 7220 7520 696e 2075 6e69  rse for u in uni
+00010a10: 6e73 6572 7465 6473 5d29 3a0a 2020 2020  nserteds]):.    
+00010a20: 2020 2020 2020 2020 7368 6170 6520 3d20          shape = 
+00010a30: 7574 696c 2e73 756d 2866 2e73 6861 7065  util.sum(f.shape
+00010a40: 2066 6f72 202a 696e 642c 2066 2069 6e20   for *ind, f in 
+00010a50: 6974 656d 7329 0a20 2020 2020 2020 2020  items).         
+00010a60: 2020 2069 6e64 6963 6573 203d 205b 4e6f     indices = [No
+00010a70: 6e65 5d20 2a20 7365 6c66 2e6e 6469 6d0a  ne] * self.ndim.
+00010a80: 2020 2020 2020 2020 2020 2020 6661 6374              fact
+00010a90: 6f72 7320 3d20 5b5d 0a20 2020 2020 2020  ors = [].       
+00010aa0: 2020 2020 2061 203d 2030 0a20 2020 2020       a = 0.     
+00010ab0: 2020 2020 2020 2066 6f72 2077 6865 7265         for where
+00010ac0: 2c20 282a 696e 642c 2066 2920 696e 207a  , (*ind, f) in z
+00010ad0: 6970 2877 6865 7265 732c 2069 7465 6d73  ip(wheres, items
+00010ae0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00010af0: 2020 2062 203d 2061 202b 2066 2e6e 6469     b = a + f.ndi
+00010b00: 6d0a 2020 2020 2020 2020 2020 2020 2020  m.              
+00010b10: 2020 7220 3d20 6e75 6d70 792e 6172 616e    r = numpy.aran
+00010b20: 6765 2861 2c20 6229 0a20 2020 2020 2020  ge(a, b).       
+00010b30: 2020 2020 2020 2020 2066 6f72 2069 2c20           for i, 
+00010b40: 696e 6469 2069 6e20 7a69 7028 7768 6572  indi in zip(wher
+00010b50: 652c 2069 6e64 293a 0a20 2020 2020 2020  e, ind):.       
+00010b60: 2020 2020 2020 2020 2020 2020 2069 6e64               ind
+00010b70: 6963 6573 5b69 5d20 3d20 616c 6967 6e28  ices[i] = align(
+00010b80: 696e 6469 2c20 722c 2073 6861 7065 290a  indi, r, shape).
+00010b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010ba0: 6661 6374 6f72 732e 6170 7065 6e64 2861  factors.append(a
+00010bb0: 6c69 676e 2866 2c20 722c 2073 6861 7065  lign(f, r, shape
+00010bc0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+00010bd0: 2020 2061 203d 2062 0a20 2020 2020 2020     a = b.       
+00010be0: 2020 2020 2073 7061 7273 652e 6170 7065       sparse.appe
+00010bf0: 6e64 2828 2a69 6e64 6963 6573 2c20 6d75  nd((*indices, mu
+00010c00: 6c74 6970 6c79 282a 6661 6374 6f72 7329  ltiply(*factors)
+00010c10: 2929 0a20 2020 2020 2020 2072 6574 7572  )).        retur
+00010c20: 6e20 7475 706c 6528 7370 6172 7365 290a  n tuple(sparse).
+00010c30: 0a20 2020 2064 6566 205f 696e 7462 6f75  .    def _intbou
+00010c40: 6e64 735f 696d 706c 2873 656c 6629 3a0a  nds_impl(self):.
+00010c50: 2020 2020 2020 2020 6675 6e63 312c 2066          func1, f
+00010c60: 756e 6332 203d 2073 656c 662e 6675 6e63  unc2 = self.func
+00010c70: 730a 2020 2020 2020 2020 6578 7472 656d  s.        extrem
+00010c80: 6120 3d20 5b62 3120 616e 6420 6232 2061  a = [b1 and b2 a
+00010c90: 6e64 2062 3120 2a20 6232 2066 6f72 2062  nd b1 * b2 for b
+00010ca0: 3120 696e 2066 756e 6331 2e5f 696e 7462  1 in func1._intb
+00010cb0: 6f75 6e64 7320 666f 7220 6232 2069 6e20  ounds for b2 in 
+00010cc0: 6675 6e63 322e 5f69 6e74 626f 756e 6473  func2._intbounds
+00010cd0: 5d0a 2020 2020 2020 2020 7265 7475 726e  ].        return
+00010ce0: 206d 696e 2865 7874 7265 6d61 292c 206d   min(extrema), m
+00010cf0: 6178 2865 7874 7265 6d61 290a 0a0a 636c  ax(extrema)...cl
+00010d00: 6173 7320 4164 6428 4172 7261 7929 3a0a  ass Add(Array):.
+00010d10: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+00010d20: 5f28 7365 6c66 2c20 6675 6e63 733a 2074  _(self, funcs: t
+00010d30: 7970 6573 2e66 726f 7a65 6e6d 756c 7469  ypes.frozenmulti
+00010d40: 7365 7429 3a0a 2020 2020 2020 2020 6173  set):.        as
+00010d50: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
+00010d60: 6675 6e63 732c 2074 7970 6573 2e66 726f  funcs, types.fro
+00010d70: 7a65 6e6d 756c 7469 7365 7429 2061 6e64  zenmultiset) and
+00010d80: 206c 656e 2866 756e 6373 2920 3d3d 2032   len(funcs) == 2
+00010d90: 2c20 6627 6675 6e63 733d 7b66 756e 6373  , f'funcs={funcs
+00010da0: 2172 7d27 0a20 2020 2020 2020 2073 656c  !r}'.        sel
+00010db0: 662e 6675 6e63 7320 3d20 6675 6e63 730a  f.funcs = funcs.
+00010dc0: 2020 2020 2020 2020 6675 6e63 312c 2066          func1, f
+00010dd0: 756e 6332 203d 2066 756e 6373 0a20 2020  unc2 = funcs.   
+00010de0: 2020 2020 2061 7373 6572 7420 6571 7561       assert equa
+00010df0: 6c73 6861 7065 2866 756e 6331 2e73 6861  lshape(func1.sha
+00010e00: 7065 2c20 6675 6e63 322e 7368 6170 6529  pe, func2.shape)
+00010e10: 2061 6e64 2066 756e 6331 2e64 7479 7065   and func1.dtype
+00010e20: 203d 3d20 6675 6e63 322e 6474 7970 6520   == func2.dtype 
+00010e30: 213d 2062 6f6f 6c2c 2027 4164 6428 7b7d  != bool, 'Add({}
+00010e40: 2c20 7b7d 2927 2e66 6f72 6d61 7428 6675  , {})'.format(fu
+00010e50: 6e63 312c 2066 756e 6332 290a 2020 2020  nc1, func2).    
+00010e60: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
+00010e70: 6974 5f5f 2861 7267 733d 7475 706c 6528  it__(args=tuple(
+00010e80: 7365 6c66 2e66 756e 6373 292c 2073 6861  self.funcs), sha
+00010e90: 7065 3d66 756e 6331 2e73 6861 7065 2c20  pe=func1.shape, 
+00010ea0: 6474 7970 653d 6675 6e63 312e 6474 7970  dtype=func1.dtyp
+00010eb0: 6529 0a0a 2020 2020 4063 6163 6865 645f  e)..    @cached_
+00010ec0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00010ed0: 205f 696e 666c 6174 696f 6e73 2873 656c   _inflations(sel
+00010ee0: 6629 3a0a 2020 2020 2020 2020 6675 6e63  f):.        func
+00010ef0: 312c 2066 756e 6332 203d 2073 656c 662e  1, func2 = self.
+00010f00: 6675 6e63 730a 2020 2020 2020 2020 6675  funcs.        fu
+00010f10: 6e63 325f 696e 666c 6174 696f 6e73 203d  nc2_inflations =
+00010f20: 2064 6963 7428 6675 6e63 322e 5f69 6e66   dict(func2._inf
+00010f30: 6c61 7469 6f6e 7329 0a20 2020 2020 2020  lations).       
+00010f40: 2069 6e66 6c61 7469 6f6e 7320 3d20 5b5d   inflations = []
+00010f50: 0a20 2020 2020 2020 2066 6f72 2061 7869  .        for axi
+00010f60: 732c 2070 6172 7473 3120 696e 2066 756e  s, parts1 in fun
+00010f70: 6331 2e5f 696e 666c 6174 696f 6e73 3a0a  c1._inflations:.
+00010f80: 2020 2020 2020 2020 2020 2020 6966 2061              if a
+00010f90: 7869 7320 6e6f 7420 696e 2066 756e 6332  xis not in func2
+00010fa0: 5f69 6e66 6c61 7469 6f6e 733a 0a20 2020  _inflations:.   
+00010fb0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+00010fc0: 7469 6e75 650a 2020 2020 2020 2020 2020  tinue.          
+00010fd0: 2020 7061 7274 7332 203d 2066 756e 6332    parts2 = func2
+00010fe0: 5f69 6e66 6c61 7469 6f6e 735b 6178 6973  _inflations[axis
+00010ff0: 5d0a 2020 2020 2020 2020 2020 2020 646f  ].            do
+00011000: 666d 6170 7320 3d20 7365 7428 7061 7274  fmaps = set(part
+00011010: 7331 2920 7c20 7365 7428 7061 7274 7332  s1) | set(parts2
+00011020: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
+00011030: 2028 6c65 6e28 7061 7274 7331 2920 3c20   (len(parts1) < 
+00011040: 6c65 6e28 646f 666d 6170 7329 2061 6e64  len(dofmaps) and
+00011050: 206c 656e 2870 6172 7473 3229 203c 206c   len(parts2) < l
+00011060: 656e 2864 6f66 6d61 7073 2920 2023 206e  en(dofmaps)  # n
+00011070: 6569 7468 6572 2073 6574 2069 7320 6120  either set is a 
+00011080: 7375 6273 6574 206f 6620 7468 6520 6f74  subset of the ot
+00011090: 6865 723b 2074 6f74 616c 206d 6179 2062  her; total may b
+000110a0: 6520 6465 6e73 650a 2020 2020 2020 2020  e dense.        
+000110b0: 2020 2020 2020 2020 2020 2020 616e 6420              and 
+000110c0: 7365 6c66 2e73 6861 7065 5b61 7869 735d  self.shape[axis]
+000110d0: 2e69 7363 6f6e 7374 616e 7420 616e 6420  .isconstant and 
+000110e0: 616c 6c28 646f 666d 6170 2e69 7363 6f6e  all(dofmap.iscon
+000110f0: 7374 616e 7420 666f 7220 646f 666d 6170  stant for dofmap
+00011100: 2069 6e20 646f 666d 6170 7329 293a 0a20   in dofmaps)):. 
+00011110: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00011120: 6173 6b20 3d20 6e75 6d70 792e 7a65 726f  ask = numpy.zero
+00011130: 7328 696e 7428 7365 6c66 2e73 6861 7065  s(int(self.shape
+00011140: 5b61 7869 735d 292c 2064 7479 7065 3d62  [axis]), dtype=b
+00011150: 6f6f 6c29 0a20 2020 2020 2020 2020 2020  ool).           
+00011160: 2020 2020 2066 6f72 2064 6f66 6d61 7020       for dofmap 
+00011170: 696e 2064 6f66 6d61 7073 3a0a 2020 2020  in dofmaps:.    
+00011180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011190: 6d61 736b 5b64 6f66 6d61 702e 6576 616c  mask[dofmap.eval
+000111a0: 2829 5d20 3d20 5472 7565 0a20 2020 2020  ()] = True.     
+000111b0: 2020 2020 2020 2020 2020 2069 6620 6d61             if ma
+000111c0: 736b 2e61 6c6c 2829 3a20 2023 2061 7869  sk.all():  # axi
+000111d0: 7320 6164 6473 2075 7020 746f 2064 656e  s adds up to den
+000111e0: 7365 0a20 2020 2020 2020 2020 2020 2020  se.             
+000111f0: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+00011200: 2020 2020 2020 2020 2020 2020 696e 666c              infl
+00011210: 6174 696f 6e73 2e61 7070 656e 6428 2861  ations.append((a
+00011220: 7869 732c 2074 7970 6573 2e66 726f 7a65  xis, types.froze
+00011230: 6e64 6963 7428 2864 6f66 6d61 702c 2075  ndict((dofmap, u
+00011240: 7469 6c2e 7375 6d28 7061 7274 735b 646f  til.sum(parts[do
+00011250: 666d 6170 5d20 666f 7220 7061 7274 7320  fmap] for parts 
+00011260: 696e 2028 7061 7274 7331 2c20 7061 7274  in (parts1, part
+00011270: 7332 2920 6966 2064 6f66 6d61 7020 696e  s2) if dofmap in
+00011280: 2070 6172 7473 2929 2066 6f72 2064 6f66   parts)) for dof
+00011290: 6d61 7020 696e 2064 6f66 6d61 7073 2929  map in dofmaps))
+000112a0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+000112b0: 2074 7570 6c65 2869 6e66 6c61 7469 6f6e   tuple(inflation
+000112c0: 7329 0a0a 2020 2020 4070 726f 7065 7274  s)..    @propert
+000112d0: 790a 2020 2020 6465 6620 5f74 6572 6d73  y.    def _terms
+000112e0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+000112f0: 666f 7220 6675 6e63 2069 6e20 7365 6c66  for func in self
+00011300: 2e66 756e 6373 3a0a 2020 2020 2020 2020  .funcs:.        
+00011310: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+00011320: 6528 6675 6e63 2c20 4164 6429 3a0a 2020  e(func, Add):.  
+00011330: 2020 2020 2020 2020 2020 2020 2020 7969                yi
+00011340: 656c 6420 6672 6f6d 2066 756e 632e 5f74  eld from func._t
+00011350: 6572 6d73 0a20 2020 2020 2020 2020 2020  erms.           
+00011360: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00011370: 2020 2020 2020 2079 6965 6c64 2066 756e         yield fun
+00011380: 630a 0a20 2020 2064 6566 205f 7369 6d70  c..    def _simp
+00011390: 6c69 6669 6564 2873 656c 6629 3a0a 2020  lified(self):.  
+000113a0: 2020 2020 2020 7465 726d 7320 3d20 7475        terms = tu
+000113b0: 706c 6528 7365 6c66 2e5f 7465 726d 7329  ple(self._terms)
+000113c0: 0a20 2020 2020 2020 2066 6f72 206a 2c20  .        for j, 
+000113d0: 666a 2069 6e20 656e 756d 6572 6174 6528  fj in enumerate(
+000113e0: 7465 726d 7329 3a0a 2020 2020 2020 2020  terms):.        
+000113f0: 2020 2020 666f 7220 692c 2066 6920 696e      for i, fi in
+00011400: 2065 6e75 6d65 7261 7465 2874 6572 6d73   enumerate(terms
+00011410: 5b3a 6a5d 293a 0a20 2020 2020 2020 2020  [:j]):.         
+00011420: 2020 2020 2020 2064 6961 6773 203d 205b         diags = [
+00011430: 736f 7274 6564 2861 7865 7369 2026 2061  sorted(axesi & a
+00011440: 7865 736a 295b 3a32 5d20 666f 7220 6178  xesj)[:2] for ax
+00011450: 6573 6920 696e 2066 692e 5f64 6961 676f  esi in fi._diago
+00011460: 6e61 6c73 2066 6f72 2061 7865 736a 2069  nals for axesj i
+00011470: 6e20 666a 2e5f 6469 6167 6f6e 616c 7320  n fj._diagonals 
+00011480: 6966 206c 656e 2861 7865 7369 2026 2061  if len(axesi & a
+00011490: 7865 736a 2920 3e3d 2032 5d0a 2020 2020  xesj) >= 2].    
+000114a0: 2020 2020 2020 2020 2020 2020 756e 616c              unal
+000114b0: 6967 6e65 6431 2c20 756e 616c 6967 6e65  igned1, unaligne
+000114c0: 6432 2c20 7768 6572 6520 3d20 756e 616c  d2, where = unal
+000114d0: 6967 6e28 6669 2c20 666a 290a 2020 2020  ign(fi, fj).    
+000114e0: 2020 2020 2020 2020 2020 2020 6669 6a20              fij 
+000114f0: 3d20 6469 6167 6f6e 616c 697a 6528 7461  = diagonalize(ta
+00011500: 6b65 6469 6167 2866 692c 202a 6469 6167  kediag(fi, *diag
+00011510: 735b 305d 2920 2b20 7461 6b65 6469 6167  s[0]) + takediag
+00011520: 2866 6a2c 202a 6469 6167 735b 305d 292c  (fj, *diags[0]),
+00011530: 202a 6469 6167 735b 305d 2920 6966 2064   *diags[0]) if d
+00011540: 6961 6773 205c 0a20 2020 2020 2020 2020  iags \.         
+00011550: 2020 2020 2020 2020 2020 2065 6c73 6520             else 
+00011560: 616c 6967 6e28 756e 616c 6967 6e65 6431  align(unaligned1
+00011570: 202b 2075 6e61 6c69 676e 6564 322c 2077   + unaligned2, w
+00011580: 6865 7265 2c20 7365 6c66 2e73 6861 7065  here, self.shape
+00011590: 2920 6966 206c 656e 2877 6865 7265 2920  ) if len(where) 
+000115a0: 213d 2073 656c 662e 6e64 696d 205c 0a20  != self.ndim \. 
+000115b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000115c0: 2020 2065 6c73 6520 6669 2e5f 6164 6428     else fi._add(
+000115d0: 666a 2920 6f72 2066 6a2e 5f61 6464 2866  fj) or fj._add(f
+000115e0: 6929 0a20 2020 2020 2020 2020 2020 2020  i).             
+000115f0: 2020 2069 6620 6669 6a3a 0a20 2020 2020     if fij:.     
+00011600: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00011610: 6574 7572 6e20 6164 6428 2a74 6572 6d73  eturn add(*terms
+00011620: 5b3a 695d 2c20 2a74 6572 6d73 5b69 2b31  [:i], *terms[i+1
+00011630: 3a6a 5d2c 202a 7465 726d 735b 6a2b 313a  :j], *terms[j+1:
+00011640: 5d2c 2066 696a 290a 2020 2020 2020 2020  ], fij).        
+00011650: 2320 4e4f 5445 3a20 5768 696c 6520 6974  # NOTE: While it
+00011660: 2069 7320 7465 6d70 7469 6e67 2074 6f20   is tempting to 
+00011670: 7573 6520 7468 6520 5f69 6e66 6c61 7469  use the _inflati
+00011680: 6f6e 7320 6174 7472 6962 7574 6520 746f  ons attribute to
+00011690: 2070 7573 680a 2020 2020 2020 2020 2320   push.        # 
+000116a0: 6164 6469 7469 6f6e 7320 7468 726f 7567  additions throug
+000116b0: 6820 636f 6d6d 6f6e 2069 6e66 6c61 7469  h common inflati
+000116c0: 6f6e 732c 2064 6f69 6e67 2073 6f20 6d61  ons, doing so ma
+000116d0: 7920 7265 7375 6c74 2069 6e20 696e 6669  y result in infi
+000116e0: 6e69 7465 0a20 2020 2020 2020 2023 2072  nite.        # r
+000116f0: 6563 7572 7369 6f6e 2069 6e20 6361 7365  ecursion in case
+00011700: 2074 776f 206f 7220 6d6f 7265 2061 7865   two or more axe
+00011710: 7320 6172 6520 696e 666c 6174 6564 2e20  s are inflated. 
+00011720: 5468 6973 206d 6563 6861 6e69 736d 2069  This mechanism i
+00011730: 730a 2020 2020 2020 2020 2320 696c 6c75  s.        # illu
+00011740: 7374 7261 7465 6420 696e 2074 6865 2066  strated in the f
+00011750: 6f6c 6c6f 7769 6e67 2073 6368 656d 6174  ollowing schemat
+00011760: 6963 2c20 696e 2077 6869 6368 203c 493e  ic, in which <I>
+00011770: 2061 6e64 203c 4a3e 2072 6570 7265 7365   and <J> represe
+00011780: 6e74 0a20 2020 2020 2020 2023 2069 6e66  nt.        # inf
+00011790: 6c61 7469 6f6e 7320 616c 6f6e 6720 6178  lations along ax
+000117a0: 6973 2031 2061 6e64 203c 4b3e 2061 6e64  is 1 and <K> and
+000117b0: 203c 4c3e 2069 6e66 6c61 7469 6f6e 7320   <L> inflations 
+000117c0: 616c 6f6e 6720 6178 6973 2032 3a0a 2020  along axis 2:.  
+000117d0: 2020 2020 2020 230a 2020 2020 2020 2020        #.        
+000117e0: 2320 2020 2020 2020 2041 2020 2042 2020  #        A   B  
+000117f0: 2043 2020 2044 2020 2045 2020 2046 2020   C   D   E   F  
+00011800: 2047 2020 2048 0a20 2020 2020 2020 2023   G   H.        #
+00011810: 2020 2020 2020 203c 493e 203c 4a3e 203c         <I> <J> <
+00011820: 493e 203c 4a3e 203c 493e 203c 4a3e 203c  I> <J> <I> <J> <
+00011830: 493e 203c 4a3e 0a20 2020 2020 2020 2023  I> <J>.        #
+00011840: 2020 2e2d 2d20 2020 205c 2b2f 2020 2020    .--    \+/    
+00011850: 205c 2b2f 2020 2020 205c 2b2f 2020 2020   \+/     \+/    
+00011860: 205c 2b2f 2020 203c 2d2d 2e0a 2020 2020   \+/   <--..    
+00011870: 2020 2020 2320 207c 2020 2020 2020 205c      #  |       \
+00011880: 5f5f 3c4b 3e5f 5f2f 2020 2020 2020 205c  __<K>__/       \
+00011890: 5f5f 3c4c 3e5f 5f2f 2020 2020 2020 207c  __<L>__/       |
+000118a0: 0a20 2020 2020 2020 2023 2020 7c20 2020  .        #  |   
+000118b0: 2020 2020 2020 2020 5c5f 5f5f 5f5f 5f5f          \_______
+000118c0: 2b5f 5f5f 5f5f 5f5f 2f20 2020 2020 2020  +_______/       
+000118d0: 2020 2020 7c0a 2020 2020 2020 2020 2320      |.        # 
+000118e0: 207c 2020 2020 2020 2020 2020 2020 2020   |              
+000118f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011900: 2020 2020 2020 2020 207c 0a20 2020 2020           |.     
+00011910: 2020 2023 2020 7c20 2020 2020 4120 2020     #  |     A   
+00011920: 4520 2020 4320 2020 4720 2020 4220 2020  E   C   G   B   
+00011930: 4620 2020 4420 2020 4820 2020 2020 7c0a  F   D   H     |.
+00011940: 2020 2020 2020 2020 2320 207c 2020 2020          #  |    
+00011950: 3c4b 3e20 3c4c 3e20 3c4b 3e20 3c4c 3e20  <K> <L> <K> <L> 
+00011960: 3c4b 3e20 3c4c 3e20 3c4b 3e20 3c4c 3e20  <K> <L> <K> <L> 
+00011970: 2020 207c 0a20 2020 2020 2020 2023 2020     |.        #  
+00011980: 272d 2d3e 2020 205c 2b2f 2020 2020 205c  '-->   \+/     \
+00011990: 2b2f 2020 2020 205c 2b2f 2020 2020 205c  +/     \+/     \
+000119a0: 2b2f 2020 2020 2d2d 270a 2020 2020 2020  +/    --'.      
+000119b0: 2020 2320 2020 2020 2020 2020 205c 5f5f    #          \__
+000119c0: 3c49 3e5f 5f2f 2020 2020 2020 205c 5f5f  <I>__/       \__
+000119d0: 3c4a 3e5f 5f2f 0a20 2020 2020 2020 2023  <J>__/.        #
+000119e0: 2020 2020 2020 2020 2020 2020 2020 5c5f                \_
+000119f0: 5f5f 5f5f 5f5f 2b5f 5f5f 5f5f 5f5f 2f0a  ______+_______/.
+00011a00: 2020 2020 2020 2020 230a 2020 2020 2020          #.      
+00011a10: 2020 2320 5765 2069 6e73 7465 6164 2072    # We instead r
+00011a20: 656c 7920 6f6e 2049 6e66 6c61 7465 2e5f  ely on Inflate._
+00011a30: 6164 6420 746f 2068 616e 646c 6520 7468  add to handle th
+00011a40: 6973 2073 6974 7561 7469 6f6e 2e0a 0a20  is situation... 
+00011a50: 2020 2065 7661 6c66 203d 2073 7461 7469     evalf = stati
+00011a60: 636d 6574 686f 6428 6e75 6d70 792e 6164  cmethod(numpy.ad
+00011a70: 6429 0a0a 2020 2020 6465 6620 5f73 756d  d)..    def _sum
+00011a80: 2873 656c 662c 2061 7869 7329 3a0a 2020  (self, axis):.  
+00011a90: 2020 2020 2020 7265 7475 726e 2061 6464        return add
+00011aa0: 282a 5b73 756d 2866 2c20 6178 6973 2920  (*[sum(f, axis) 
+00011ab0: 666f 7220 6620 696e 2073 656c 662e 5f74  for f in self._t
+00011ac0: 6572 6d73 5d29 0a0a 2020 2020 6465 6620  erms])..    def 
+00011ad0: 5f64 6572 6976 6174 6976 6528 7365 6c66  _derivative(self
+00011ae0: 2c20 7661 722c 2073 6565 6e29 3a0a 2020  , var, seen):.  
+00011af0: 2020 2020 2020 7265 7475 726e 2061 6464        return add
+00011b00: 282a 5b64 6572 6976 6174 6976 6528 662c  (*[derivative(f,
+00011b10: 2076 6172 2c20 7365 656e 2920 666f 7220   var, seen) for 
+00011b20: 6620 696e 2073 656c 662e 5f74 6572 6d73  f in self._terms
+00011b30: 5d29 0a0a 2020 2020 6465 6620 5f74 616b  ])..    def _tak
+00011b40: 6564 6961 6728 7365 6c66 2c20 6178 6973  ediag(self, axis
+00011b50: 312c 2061 7869 7332 293a 0a20 2020 2020  1, axis2):.     
+00011b60: 2020 2072 6574 7572 6e20 6164 6428 2a5b     return add(*[
+00011b70: 5f74 616b 6564 6961 6728 662c 2061 7869  _takediag(f, axi
+00011b80: 7331 2c20 6178 6973 3229 2066 6f72 2066  s1, axis2) for f
+00011b90: 2069 6e20 7365 6c66 2e5f 7465 726d 735d   in self._terms]
+00011ba0: 290a 0a20 2020 2064 6566 205f 7461 6b65  )..    def _take
+00011bb0: 2873 656c 662c 2069 6e64 6578 2c20 6178  (self, index, ax
+00011bc0: 6973 293a 0a20 2020 2020 2020 2072 6574  is):.        ret
+00011bd0: 7572 6e20 6164 6428 2a5b 5f74 616b 6528  urn add(*[_take(
+00011be0: 662c 2069 6e64 6578 2c20 6178 6973 2920  f, index, axis) 
+00011bf0: 666f 7220 6620 696e 2073 656c 662e 5f74  for f in self._t
+00011c00: 6572 6d73 5d29 0a0a 2020 2020 6465 6620  erms])..    def 
+00011c10: 5f75 6e72 6176 656c 2873 656c 662c 2061  _unravel(self, a
+00011c20: 7869 732c 2073 6861 7065 293a 0a20 2020  xis, shape):.   
+00011c30: 2020 2020 2072 6574 7572 6e20 6164 6428       return add(
+00011c40: 2a5b 756e 7261 7665 6c28 662c 2061 7869  *[unravel(f, axi
+00011c50: 732c 2073 6861 7065 2920 666f 7220 6620  s, shape) for f 
+00011c60: 696e 2073 656c 662e 5f74 6572 6d73 5d29  in self._terms])
+00011c70: 0a0a 2020 2020 6465 6620 5f6c 6f6f 7073  ..    def _loops
+00011c80: 756d 2873 656c 662c 2069 6e64 6578 293a  um(self, index):
+00011c90: 0a20 2020 2020 2020 2064 6570 203d 205b  .        dep = [
+00011ca0: 5d0a 2020 2020 2020 2020 696e 6465 7020  ].        indep 
+00011cb0: 3d20 5b5d 0a20 2020 2020 2020 2066 6f72  = [].        for
+00011cc0: 2066 2069 6e20 7365 6c66 2e5f 7465 726d   f in self._term
+00011cd0: 733a 0a20 2020 2020 2020 2020 2020 2028  s:.            (
+00011ce0: 6465 7020 6966 2069 6e64 6578 2069 6e20  dep if index in 
+00011cf0: 662e 6172 6775 6d65 6e74 7320 656c 7365  f.arguments else
+00011d00: 2069 6e64 6570 292e 6170 7065 6e64 2866   indep).append(f
+00011d10: 290a 2020 2020 2020 2020 6966 2069 6e64  ).        if ind
+00011d20: 6570 3a0a 2020 2020 2020 2020 2020 2020  ep:.            
+00011d30: 7265 7475 726e 2061 6464 282a 696e 6465  return add(*inde
+00011d40: 7029 202a 2069 6e64 6578 2e6c 656e 6774  p) * index.lengt
+00011d50: 6820 2b20 6c6f 6f70 5f73 756d 2861 6464  h + loop_sum(add
+00011d60: 282a 6465 7029 2c20 696e 6465 7829 0a0a  (*dep), index)..
+00011d70: 2020 2020 6465 6620 5f6d 756c 7469 706c      def _multipl
+00011d80: 7928 7365 6c66 2c20 6f74 6865 7229 3a0a  y(self, other):.
+00011d90: 2020 2020 2020 2020 665f 6f74 6865 7220          f_other 
+00011da0: 3d20 5b66 2e5f 6d75 6c74 6970 6c79 286f  = [f._multiply(o
+00011db0: 7468 6572 2920 6f72 206f 7468 6572 2e5f  ther) or other._
+00011dc0: 6d75 6c74 6970 6c79 2866 2920 6f72 2028  multiply(f) or (
+00011dd0: 662e 5f69 6e66 6c61 7469 6f6e 7320 6f72  f._inflations or
+00011de0: 2066 2e5f 6469 6167 6f6e 616c 7329 2061   f._diagonals) a
+00011df0: 6e64 2066 202a 206f 7468 6572 2066 6f72  nd f * other for
+00011e00: 2066 2069 6e20 7365 6c66 2e5f 7465 726d   f in self._term
+00011e10: 735d 0a20 2020 2020 2020 2069 6620 616c  s].        if al
+00011e20: 6c28 665f 6f74 6865 7229 3a0a 2020 2020  l(f_other):.    
+00011e30: 2020 2020 2020 2020 2320 4e4f 5445 3a20          # NOTE: 
+00011e40: 4173 2074 6869 7320 6f70 6572 6174 696f  As this operatio
+00011e50: 6e20 6973 2074 6865 2070 7265 6369 7365  n is the precise
+00011e60: 206f 7070 6f73 6974 6520 6f66 204d 756c   opposite of Mul
+00011e70: 7469 706c 792e 5f61 6464 2c20 7468 6572  tiply._add, ther
+00011e80: 650a 2020 2020 2020 2020 2020 2020 2320  e.            # 
+00011e90: 6170 7065 6172 7320 746f 2062 6520 6120  appears to be a 
+00011ea0: 6772 6561 7420 7269 736b 206f 6620 7265  great risk of re
+00011eb0: 6375 7273 696f 6e2e 2048 6f77 6576 6572  cursion. However
+00011ec0: 2c20 7369 6e63 6520 626f 7468 2066 6163  , since both fac
+00011ed0: 746f 7273 0a20 2020 2020 2020 2020 2020  tors.           
+00011ee0: 2023 2061 7265 2073 7061 7273 652c 2077   # are sparse, w
+00011ef0: 6520 6361 6e20 6265 2063 6572 7461 696e  e can be certain
+00011f00: 2074 6861 7420 7375 6273 6571 7565 6e74   that subsequent
+00011f10: 2073 696d 7069 6669 6361 7469 6f6e 7320   simpifications 
+00011f20: 7769 6c6c 0a20 2020 2020 2020 2020 2020  will.           
+00011f30: 2023 2069 7272 6576 6572 7369 626c 7920   # irreversibly 
+00011f40: 7072 6f63 6573 7320 7468 6520 6e65 7720  process the new 
+00011f50: 7465 726d 7320 6265 666f 7265 2072 6561  terms before rea
+00011f60: 6368 696e 6720 7468 6973 2070 6f69 6e74  ching this point
+00011f70: 2e0a 2020 2020 2020 2020 2020 2020 7265  ..            re
+00011f80: 7475 726e 2061 6464 282a 665f 6f74 6865  turn add(*f_othe
+00011f90: 7229 0a0a 2020 2020 4063 6163 6865 645f  r)..    @cached_
+00011fa0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00011fb0: 205f 6173 7370 6172 7365 2873 656c 6629   _assparse(self)
+00011fc0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00011fd0: 205f 6761 7468 6572 7370 6172 7365 6368   _gathersparsech
+00011fe0: 756e 6b73 2869 7465 7274 6f6f 6c73 2e63  unks(itertools.c
+00011ff0: 6861 696e 282a 5b66 2e5f 6173 7370 6172  hain(*[f._asspar
+00012000: 7365 2066 6f72 2066 2069 6e20 7365 6c66  se for f in self
+00012010: 2e5f 7465 726d 735d 2929 0a0a 2020 2020  ._terms]))..    
+00012020: 6465 6620 5f69 6e74 626f 756e 6473 5f69  def _intbounds_i
+00012030: 6d70 6c28 7365 6c66 293a 0a20 2020 2020  mpl(self):.     
+00012040: 2020 206c 6f77 6572 732c 2075 7070 6572     lowers, upper
+00012050: 7320 3d20 7a69 7028 2a5b 662e 5f69 6e74  s = zip(*[f._int
+00012060: 626f 756e 6473 2066 6f72 2066 2069 6e20  bounds for f in 
+00012070: 7365 6c66 2e5f 7465 726d 735d 290a 2020  self._terms]).  
+00012080: 2020 2020 2020 7265 7475 726e 2062 7569        return bui
+00012090: 6c74 696e 732e 7375 6d28 6c6f 7765 7273  ltins.sum(lowers
+000120a0: 292c 2062 7569 6c74 696e 732e 7375 6d28  ), builtins.sum(
+000120b0: 7570 7065 7273 290a 0a0a 636c 6173 7320  uppers)...class 
+000120c0: 4569 6e73 756d 2841 7272 6179 293a 0a0a  Einsum(Array):..
+000120d0: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+000120e0: 2873 656c 662c 2061 7267 733a 2074 7970  (self, args: typ
+000120f0: 696e 672e 5475 706c 655b 4172 7261 792c  ing.Tuple[Array,
+00012100: 202e 2e2e 5d2c 2061 7267 735f 6964 783a   ...], args_idx:
+00012110: 2074 7970 696e 672e 5475 706c 655b 7479   typing.Tuple[ty
+00012120: 7069 6e67 2e54 7570 6c65 5b69 6e74 2c20  ping.Tuple[int, 
+00012130: 2e2e 2e5d 2c20 2e2e 2e5d 2c20 6f75 745f  ...], ...], out_
+00012140: 6964 783a 2074 7970 696e 672e 5475 706c  idx: typing.Tupl
+00012150: 655b 696e 742c 202e 2e2e 5d29 3a0a 2020  e[int, ...]):.  
+00012160: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+00012170: 6e73 7461 6e63 6528 6172 6773 2c20 7475  nstance(args, tu
+00012180: 706c 6529 2061 6e64 2061 6c6c 2869 7369  ple) and all(isi
+00012190: 6e73 7461 6e63 6528 6172 672c 2041 7272  nstance(arg, Arr
+000121a0: 6179 2920 666f 7220 6172 6720 696e 2061  ay) for arg in a
+000121b0: 7267 7329 2c20 6627 6172 673d 7b61 7267  rgs), f'arg={arg
+000121c0: 2172 7d27 0a20 2020 2020 2020 2061 7373  !r}'.        ass
+000121d0: 6572 7420 6973 696e 7374 616e 6365 2861  ert isinstance(a
+000121e0: 7267 735f 6964 782c 2074 7570 6c65 2920  rgs_idx, tuple) 
+000121f0: 616e 6420 616c 6c28 6973 696e 7374 616e  and all(isinstan
+00012200: 6365 2861 7267 5f69 6478 2c20 7475 706c  ce(arg_idx, tupl
+00012210: 6529 2061 6e64 2061 6c6c 2869 7369 6e73  e) and all(isins
+00012220: 7461 6e63 6528 6e2c 2069 6e74 2920 666f  tance(n, int) fo
+00012230: 7220 6e20 696e 2061 7267 5f69 6478 2920  r n in arg_idx) 
+00012240: 666f 7220 6172 675f 6964 7820 696e 2061  for arg_idx in a
+00012250: 7267 735f 6964 7829 2c20 6627 6172 6773  rgs_idx), f'args
+00012260: 5f69 6478 3d7b 6172 6773 5f69 6478 2172  _idx={args_idx!r
+00012270: 7d27 0a20 2020 2020 2020 2061 7373 6572  }'.        asser
+00012280: 7420 6973 696e 7374 616e 6365 286f 7574  t isinstance(out
+00012290: 5f69 6478 2c20 7475 706c 6529 2061 6e64  _idx, tuple) and
+000122a0: 2061 6c6c 2869 7369 6e73 7461 6e63 6528   all(isinstance(
+000122b0: 6e2c 2069 6e74 2920 666f 7220 6e20 696e  n, int) for n in
+000122c0: 206f 7574 5f69 6478 2920 616e 6420 6c65   out_idx) and le
+000122d0: 6e28 6f75 745f 6964 7829 203d 3d20 6c65  n(out_idx) == le
+000122e0: 6e28 7365 7428 6f75 745f 6964 7829 292c  n(set(out_idx)),
+000122f0: 2066 276f 7574 5f69 6478 3d7b 6f75 745f   f'out_idx={out_
+00012300: 6964 7821 727d 270a 2020 2020 2020 2020  idx!r}'.        
+00012310: 6173 7365 7274 206c 656e 2861 7267 735f  assert len(args_
+00012320: 6964 7829 203d 3d20 6c65 6e28 6172 6773  idx) == len(args
+00012330: 2920 616e 6420 616c 6c28 6c65 6e28 6964  ) and all(len(id
+00012340: 7829 203d 3d20 6172 672e 6e64 696d 2066  x) == arg.ndim f
+00012350: 6f72 2069 6478 2c20 6172 6720 696e 207a  or idx, arg in z
+00012360: 6970 2861 7267 735f 6964 782c 2061 7267  ip(args_idx, arg
+00012370: 7329 292c 2066 276c 656e 2861 7267 735f  s)), f'len(args_
+00012380: 6964 7829 3d7b 6c65 6e28 6172 6773 5f69  idx)={len(args_i
+00012390: 6478 297d 2c20 6c65 6e28 6172 6773 293d  dx)}, len(args)=
+000123a0: 7b6c 656e 2861 7267 7329 7d27 0a20 2020  {len(args)}'.   
+000123b0: 2020 2020 2064 7479 7065 203d 2061 7267       dtype = arg
+000123c0: 735b 305d 2e64 7479 7065 0a20 2020 2020  s[0].dtype.     
+000123d0: 2020 2069 6620 6474 7970 6520 3d3d 2062     if dtype == b
+000123e0: 6f6f 6c20 6f72 2061 6e79 2861 7267 2e64  ool or any(arg.d
+000123f0: 7479 7065 2021 3d20 6474 7970 6520 666f  type != dtype fo
+00012400: 7220 6172 6720 696e 2061 7267 735b 313a  r arg in args[1:
+00012410: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
+00012420: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+00012430: 2827 496e 636f 6e73 6973 7465 6e74 206f  ('Inconsistent o
+00012440: 7220 696e 7661 6c69 6420 6474 7970 6573  r invalid dtypes
+00012450: 2e27 290a 2020 2020 2020 2020 6c65 6e67  .').        leng
+00012460: 7468 7320 3d20 7b7d 0a20 2020 2020 2020  ths = {}.       
+00012470: 2066 6f72 2069 6478 2c20 6172 6720 696e   for idx, arg in
+00012480: 207a 6970 2861 7267 735f 6964 782c 2061   zip(args_idx, a
+00012490: 7267 7329 3a0a 2020 2020 2020 2020 2020  rgs):.          
+000124a0: 2020 666f 7220 692c 206c 656e 6774 6820    for i, length 
+000124b0: 696e 207a 6970 2869 6478 2c20 6172 672e  in zip(idx, arg.
+000124c0: 7368 6170 6529 3a0a 2020 2020 2020 2020  shape):.        
+000124d0: 2020 2020 2020 2020 6966 2069 206e 6f74          if i not
+000124e0: 2069 6e20 6c65 6e67 7468 733a 0a20 2020   in lengths:.   
+000124f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012500: 206c 656e 6774 6873 5b69 5d20 3d20 6c65   lengths[i] = le
+00012510: 6e67 7468 0a20 2020 2020 2020 2020 2020  ngth.           
+00012520: 2020 2020 2065 6c69 6620 6e6f 7420 5f65       elif not _e
+00012530: 7175 616c 735f 7369 6d70 6c69 6669 6564  quals_simplified
+00012540: 286c 656e 6774 6873 5b69 5d2c 206c 656e  (lengths[i], len
+00012550: 6774 6829 3a0a 2020 2020 2020 2020 2020  gth):.          
+00012560: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00012570: 5661 6c75 6545 7272 6f72 2827 4178 6573  ValueError('Axes
+00012580: 2077 6974 6820 696e 6465 7820 7b7d 2068   with index {} h
+00012590: 6176 6520 6469 6666 6572 656e 7420 6c65  ave different le
+000125a0: 6e67 7468 732e 272e 666f 726d 6174 2869  ngths.'.format(i
+000125b0: 2929 0a20 2020 2020 2020 2074 7279 3a0a  )).        try:.
+000125c0: 2020 2020 2020 2020 2020 2020 7368 6170              shap
+000125d0: 6520 3d20 7475 706c 6528 6c65 6e67 7468  e = tuple(length
+000125e0: 735b 695d 2066 6f72 2069 2069 6e20 6f75  s[i] for i in ou
+000125f0: 745f 6964 7829 0a20 2020 2020 2020 2065  t_idx).        e
+00012600: 7863 6570 7420 4b65 7945 7272 6f72 3a0a  xcept KeyError:.
+00012610: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00012620: 6520 5661 6c75 6545 7272 6f72 2827 4f75  e ValueError('Ou
+00012630: 7470 7574 2061 7869 7320 7b7d 2069 7320  tput axis {} is 
+00012640: 6e6f 7420 6c69 7374 6564 2069 6e20 616e  not listed in an
+00012650: 7920 6f66 2074 6865 2061 7267 756d 656e  y of the argumen
+00012660: 7473 2e27 2e66 6f72 6d61 7428 272c 2027  ts.'.format(', '
+00012670: 2e6a 6f69 6e28 6920 666f 7220 6920 696e  .join(i for i in
+00012680: 206f 7574 5f69 6478 2069 6620 6920 6e6f   out_idx if i no
+00012690: 7420 696e 206c 656e 6774 6873 2929 290a  t in lengths))).
+000126a0: 2020 2020 2020 2020 7365 6c66 2e61 7267          self.arg
+000126b0: 7320 3d20 6172 6773 0a20 2020 2020 2020  s = args.       
+000126c0: 2073 656c 662e 6172 6773 5f69 6478 203d   self.args_idx =
+000126d0: 2061 7267 735f 6964 780a 2020 2020 2020   args_idx.      
+000126e0: 2020 7365 6c66 2e6f 7574 5f69 6478 203d    self.out_idx =
+000126f0: 206f 7574 5f69 6478 0a20 2020 2020 2020   out_idx.       
+00012700: 2073 656c 662e 5f65 696e 7375 6d66 6d74   self._einsumfmt
+00012710: 203d 2027 2c27 2e6a 6f69 6e28 2727 2e6a   = ','.join(''.j
+00012720: 6f69 6e28 6368 7228 3937 2b69 2920 666f  oin(chr(97+i) fo
+00012730: 7220 6920 696e 2069 6478 2920 666f 7220  r i in idx) for 
+00012740: 6964 7820 696e 2061 7267 735f 6964 7829  idx in args_idx)
+00012750: 202b 2027 2d3e 2720 2b20 2727 2e6a 6f69   + '->' + ''.joi
+00012760: 6e28 6368 7228 3937 2b69 2920 666f 7220  n(chr(97+i) for 
+00012770: 6920 696e 206f 7574 5f69 6478 290a 2020  i in out_idx).  
+00012780: 2020 2020 2020 7365 6c66 2e5f 6861 735f        self._has_
+00012790: 7375 6d6d 6564 5f61 7865 7320 3d20 6c65  summed_axes = le
+000127a0: 6e28 6c65 6e67 7468 7329 203e 206c 656e  n(lengths) > len
+000127b0: 286f 7574 5f69 6478 290a 2020 2020 2020  (out_idx).      
+000127c0: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
+000127d0: 5f5f 2861 7267 733d 7365 6c66 2e61 7267  __(args=self.arg
+000127e0: 732c 2073 6861 7065 3d73 6861 7065 2c20  s, shape=shape, 
+000127f0: 6474 7970 653d 6474 7970 6529 0a0a 2020  dtype=dtype)..  
+00012800: 2020 6465 6620 6576 616c 6628 7365 6c66    def evalf(self
+00012810: 2c20 2a61 7267 7329 3a0a 2020 2020 2020  , *args):.      
+00012820: 2020 6966 2073 656c 662e 5f68 6173 5f73    if self._has_s
+00012830: 756d 6d65 645f 6178 6573 3a0a 2020 2020  ummed_axes:.    
+00012840: 2020 2020 2020 2020 6172 6773 203d 2074          args = t
+00012850: 7570 6c65 286e 756d 7079 2e61 7361 7272  uple(numpy.asarr
+00012860: 6179 2861 7267 2c20 6f72 6465 723d 2746  ay(arg, order='F
+00012870: 2729 2066 6f72 2061 7267 2069 6e20 6172  ') for arg in ar
+00012880: 6773 290a 2020 2020 2020 2020 7265 7475  gs).        retu
+00012890: 726e 206e 756d 7079 2e63 6f72 652e 6d75  rn numpy.core.mu
+000128a0: 6c74 6961 7272 6179 2e63 5f65 696e 7375  ltiarray.c_einsu
+000128b0: 6d28 7365 6c66 2e5f 6569 6e73 756d 666d  m(self._einsumfm
+000128c0: 742c 202a 6172 6773 290a 0a20 2020 2040  t, *args)..    @
+000128d0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+000128e0: 205f 6e6f 6465 5f64 6574 6169 6c73 2873   _node_details(s
+000128f0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00012900: 7475 726e 2073 656c 662e 5f65 696e 7375  turn self._einsu
+00012910: 6d66 6d74 0a0a 2020 2020 6465 6620 5f73  mfmt..    def _s
+00012920: 696d 706c 6966 6965 6428 7365 6c66 293a  implified(self):
+00012930: 0a20 2020 2020 2020 2066 6f72 2069 2c20  .        for i, 
+00012940: 6172 6720 696e 2065 6e75 6d65 7261 7465  arg in enumerate
+00012950: 2873 656c 662e 6172 6773 293a 0a20 2020  (self.args):.   
+00012960: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
+00012970: 7374 616e 6365 2861 7267 2c20 5472 616e  stance(arg, Tran
+00012980: 7370 6f73 6529 3a20 2023 2061 6273 6f72  spose):  # absor
+00012990: 6220 6054 7261 6e73 706f 7365 600a 2020  b `Transpose`.  
+000129a0: 2020 2020 2020 2020 2020 2020 2020 6964                id
+000129b0: 7820 3d20 7475 706c 6528 6d61 7028 7365  x = tuple(map(se
+000129c0: 6c66 2e61 7267 735f 6964 785b 695d 2e5f  lf.args_idx[i]._
+000129d0: 5f67 6574 6974 656d 5f5f 2c20 6e75 6d70  _getitem__, nump
+000129e0: 792e 6172 6773 6f72 7428 6172 672e 6178  y.argsort(arg.ax
+000129f0: 6573 2929 290a 2020 2020 2020 2020 2020  es))).          
+00012a00: 2020 2020 2020 7265 7475 726e 2045 696e        return Ein
+00012a10: 7375 6d28 7365 6c66 2e61 7267 735b 3a69  sum(self.args[:i
+00012a20: 5d2b 2861 7267 2e66 756e 632c 292b 7365  ]+(arg.func,)+se
+00012a30: 6c66 2e61 7267 735b 692b 313a 5d2c 2073  lf.args[i+1:], s
+00012a40: 656c 662e 6172 6773 5f69 6478 5b3a 695d  elf.args_idx[:i]
+00012a50: 2b28 6964 782c 292b 7365 6c66 2e61 7267  +(idx,)+self.arg
+00012a60: 735f 6964 785b 692b 313a 5d2c 2073 656c  s_idx[i+1:], sel
+00012a70: 662e 6f75 745f 6964 7829 0a0a 2020 2020  f.out_idx)..    
+00012a80: 6465 6620 5f73 756d 2873 656c 662c 2061  def _sum(self, a
+00012a90: 7869 7329 3a0a 2020 2020 2020 2020 6966  xis):.        if
+00012aa0: 206e 6f74 2028 3020 3c3d 2061 7869 7320   not (0 <= axis 
+00012ab0: 3c20 7365 6c66 2e6e 6469 6d29 3a0a 2020  < self.ndim):.  
+00012ac0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00012ad0: 496e 6465 7845 7272 6f72 2827 4178 6973  IndexError('Axis
+00012ae0: 206f 7574 206f 6620 7261 6e67 652e 2729   out of range.')
+00012af0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00012b00: 4569 6e73 756d 2873 656c 662e 6172 6773  Einsum(self.args
+00012b10: 2c20 7365 6c66 2e61 7267 735f 6964 782c  , self.args_idx,
+00012b20: 2073 656c 662e 6f75 745f 6964 785b 3a61   self.out_idx[:a
+00012b30: 7869 735d 202b 2073 656c 662e 6f75 745f  xis] + self.out_
+00012b40: 6964 785b 6178 6973 2b31 3a5d 290a 0a20  idx[axis+1:]).. 
+00012b50: 2020 2064 6566 205f 7461 6b65 6469 6167     def _takediag
+00012b60: 2873 656c 662c 2061 7869 7331 2c20 6178  (self, axis1, ax
+00012b70: 6973 3229 3a0a 2020 2020 2020 2020 6966  is2):.        if
+00012b80: 206e 6f74 2028 3020 3c3d 2061 7869 7331   not (0 <= axis1
+00012b90: 203c 2061 7869 7332 203c 2073 656c 662e   < axis2 < self.
+00012ba0: 6e64 696d 293a 0a20 2020 2020 2020 2020  ndim):.         
+00012bb0: 2020 2072 6169 7365 2049 6e64 6578 4572     raise IndexEr
+00012bc0: 726f 7228 2741 7869 7320 6f75 7420 6f66  ror('Axis out of
+00012bd0: 2072 616e 6765 2e27 290a 2020 2020 2020   range.').      
+00012be0: 2020 696b 6565 702c 2069 726d 203d 2073    ikeep, irm = s
+00012bf0: 656c 662e 6f75 745f 6964 785b 6178 6973  elf.out_idx[axis
+00012c00: 315d 2c20 7365 6c66 2e6f 7574 5f69 6478  1], self.out_idx
+00012c10: 5b61 7869 7332 5d0a 2020 2020 2020 2020  [axis2].        
+00012c20: 6172 6773 5f69 6478 203d 2074 7570 6c65  args_idx = tuple
+00012c30: 2874 7570 6c65 2869 6b65 6570 2069 6620  (tuple(ikeep if 
+00012c40: 6920 3d3d 2069 726d 2065 6c73 6520 6920  i == irm else i 
+00012c50: 666f 7220 6920 696e 2069 6478 2920 666f  for i in idx) fo
+00012c60: 7220 6964 7820 696e 2073 656c 662e 6172  r idx in self.ar
+00012c70: 6773 5f69 6478 290a 2020 2020 2020 2020  gs_idx).        
+00012c80: 7265 7475 726e 2045 696e 7375 6d28 7365  return Einsum(se
+00012c90: 6c66 2e61 7267 732c 2061 7267 735f 6964  lf.args, args_id
+00012ca0: 782c 2073 656c 662e 6f75 745f 6964 785b  x, self.out_idx[
+00012cb0: 3a61 7869 7331 5d20 2b20 7365 6c66 2e6f  :axis1] + self.o
+00012cc0: 7574 5f69 6478 5b61 7869 7331 2b31 3a61  ut_idx[axis1+1:a
+00012cd0: 7869 7332 5d20 2b20 7365 6c66 2e6f 7574  xis2] + self.out
+00012ce0: 5f69 6478 5b61 7869 7332 2b31 3a5d 202b  _idx[axis2+1:] +
+00012cf0: 2028 696b 6565 702c 2929 0a0a 0a63 6c61   (ikeep,))...cla
+00012d00: 7373 2053 756d 2841 7272 6179 293a 0a0a  ss Sum(Array):..
+00012d10: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+00012d20: 2873 656c 662c 2066 756e 633a 2041 7272  (self, func: Arr
+00012d30: 6179 293a 0a20 2020 2020 2020 2061 7373  ay):.        ass
+00012d40: 6572 7420 6973 696e 7374 616e 6365 2866  ert isinstance(f
+00012d50: 756e 632c 2041 7272 6179 292c 2066 2766  unc, Array), f'f
+00012d60: 756e 633d 7b66 756e 6321 727d 270a 2020  unc={func!r}'.  
+00012d70: 2020 2020 2020 6173 7365 7274 2066 756e        assert fun
+00012d80: 632e 6474 7970 6520 213d 2062 6f6f 6c2c  c.dtype != bool,
+00012d90: 2027 5375 6d28 7b7d 2927 2e66 6f72 6d61   'Sum({})'.forma
+00012da0: 7428 6675 6e63 290a 2020 2020 2020 2020  t(func).        
+00012db0: 7365 6c66 2e66 756e 6320 3d20 6675 6e63  self.func = func
+00012dc0: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
+00012dd0: 2e5f 5f69 6e69 745f 5f28 6172 6773 3d28  .__init__(args=(
+00012de0: 6675 6e63 2c29 2c20 7368 6170 653d 6675  func,), shape=fu
+00012df0: 6e63 2e73 6861 7065 5b3a 2d31 5d2c 2064  nc.shape[:-1], d
+00012e00: 7479 7065 3d66 756e 632e 6474 7970 6529  type=func.dtype)
+00012e10: 0a0a 2020 2020 6465 6620 5f73 696d 706c  ..    def _simpl
+00012e20: 6966 6965 6428 7365 6c66 293a 0a20 2020  ified(self):.   
+00012e30: 2020 2020 2069 6620 5f65 7175 616c 735f       if _equals_
+00012e40: 7363 616c 6172 5f63 6f6e 7374 616e 7428  scalar_constant(
+00012e50: 7365 6c66 2e66 756e 632e 7368 6170 655b  self.func.shape[
+00012e60: 2d31 5d2c 2031 293a 0a20 2020 2020 2020  -1], 1):.       
+00012e70: 2020 2020 2072 6574 7572 6e20 5461 6b65       return Take
+00012e80: 2873 656c 662e 6675 6e63 2c20 636f 6e73  (self.func, cons
+00012e90: 7461 6e74 2830 2929 0a20 2020 2020 2020  tant(0)).       
+00012ea0: 2072 6574 7572 6e20 7365 6c66 2e66 756e   return self.fun
+00012eb0: 632e 5f73 756d 2873 656c 662e 6e64 696d  c._sum(self.ndim
+00012ec0: 290a 0a20 2020 2040 7374 6174 6963 6d65  )..    @staticme
+00012ed0: 7468 6f64 0a20 2020 2064 6566 2065 7661  thod.    def eva
+00012ee0: 6c66 2861 7272 293a 0a20 2020 2020 2020  lf(arr):.       
+00012ef0: 2072 6574 7572 6e20 6e75 6d70 792e 7375   return numpy.su
+00012f00: 6d28 6172 722c 202d 3129 0a0a 2020 2020  m(arr, -1)..    
+00012f10: 6465 6620 5f73 756d 2873 656c 662c 2061  def _sum(self, a
+00012f20: 7869 7329 3a0a 2020 2020 2020 2020 7472  xis):.        tr
+00012f30: 7973 756d 203d 2073 656c 662e 6675 6e63  ysum = self.func
+00012f40: 2e5f 7375 6d28 6178 6973 290a 2020 2020  ._sum(axis).    
+00012f50: 2020 2020 6966 2074 7279 7375 6d20 6973      if trysum is
+00012f60: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00012f70: 2020 2020 2020 2072 6574 7572 6e20 5375         return Su
+00012f80: 6d28 7472 7973 756d 290a 0a20 2020 2064  m(trysum)..    d
+00012f90: 6566 205f 6465 7269 7661 7469 7665 2873  ef _derivative(s
+00012fa0: 656c 662c 2076 6172 2c20 7365 656e 293a  elf, var, seen):
+00012fb0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00012fc0: 7375 6d28 6465 7269 7661 7469 7665 2873  sum(derivative(s
+00012fd0: 656c 662e 6675 6e63 2c20 7661 722c 2073  elf.func, var, s
+00012fe0: 6565 6e29 2c20 7365 6c66 2e6e 6469 6d29  een), self.ndim)
+00012ff0: 0a0a 2020 2020 4063 6163 6865 645f 7072  ..    @cached_pr
+00013000: 6f70 6572 7479 0a20 2020 2064 6566 205f  operty.    def _
+00013010: 6173 7370 6172 7365 2873 656c 6629 3a0a  assparse(self):.
+00013020: 2020 2020 2020 2020 6368 756e 6b73 203d          chunks =
+00013030: 205b 5d0a 2020 2020 2020 2020 666f 7220   [].        for 
+00013040: 2a69 6e64 6963 6573 2c20 5f72 6d69 6478  *indices, _rmidx
+00013050: 2c20 7661 6c75 6573 2069 6e20 7365 6c66  , values in self
+00013060: 2e66 756e 632e 5f61 7373 7061 7273 653a  .func._assparse:
+00013070: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00013080: 7365 6c66 2e6e 6469 6d20 3d3d 2030 3a0a  self.ndim == 0:.
+00013090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000130a0: 6e73 756d 203d 2076 616c 7565 732e 6e64  nsum = values.nd
+000130b0: 696d 0a20 2020 2020 2020 2020 2020 2065  im.            e
+000130c0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000130d0: 2020 2020 202a 696e 6469 6365 732c 2077       *indices, w
+000130e0: 6865 7265 203d 2075 6e61 6c69 676e 282a  here = unalign(*
+000130f0: 696e 6469 6365 7329 0a20 2020 2020 2020  indices).       
+00013100: 2020 2020 2020 2020 2076 616c 7565 7320           values 
+00013110: 3d20 7472 616e 7370 6f73 6528 7661 6c75  = transpose(valu
+00013120: 6573 2c20 7768 6572 6520 2b20 7475 706c  es, where + tupl
+00013130: 6528 6920 666f 7220 6920 696e 2072 616e  e(i for i in ran
+00013140: 6765 2876 616c 7565 732e 6e64 696d 2920  ge(values.ndim) 
+00013150: 6966 2069 206e 6f74 2069 6e20 7768 6572  if i not in wher
+00013160: 6529 290a 2020 2020 2020 2020 2020 2020  e)).            
+00013170: 2020 2020 6e73 756d 203d 2076 616c 7565      nsum = value
+00013180: 732e 6e64 696d 202d 206c 656e 2877 6865  s.ndim - len(whe
+00013190: 7265 290a 2020 2020 2020 2020 2020 2020  re).            
+000131a0: 666f 7220 6920 696e 2072 616e 6765 286e  for i in range(n
+000131b0: 7375 6d29 3a0a 2020 2020 2020 2020 2020  sum):.          
+000131c0: 2020 2020 2020 7661 6c75 6573 203d 2053        values = S
+000131d0: 756d 2876 616c 7565 7329 0a20 2020 2020  um(values).     
+000131e0: 2020 2020 2020 2063 6875 6e6b 732e 6170         chunks.ap
+000131f0: 7065 6e64 2828 2a69 6e64 6963 6573 2c20  pend((*indices, 
+00013200: 7661 6c75 6573 2929 0a20 2020 2020 2020  values)).       
+00013210: 2072 6574 7572 6e20 5f67 6174 6865 7273   return _gathers
+00013220: 7061 7273 6563 6875 6e6b 7328 6368 756e  parsechunks(chun
+00013230: 6b73 290a 0a20 2020 2064 6566 205f 696e  ks)..    def _in
+00013240: 7462 6f75 6e64 735f 696d 706c 2873 656c  tbounds_impl(sel
+00013250: 6629 3a0a 2020 2020 2020 2020 6c6f 7765  f):.        lowe
+00013260: 725f 6675 6e63 2c20 7570 7065 725f 6675  r_func, upper_fu
+00013270: 6e63 203d 2073 656c 662e 6675 6e63 2e5f  nc = self.func._
+00013280: 696e 7462 6f75 6e64 730a 2020 2020 2020  intbounds.      
+00013290: 2020 6c6f 7765 725f 6c65 6e67 7468 2c20    lower_length, 
+000132a0: 7570 7065 725f 6c65 6e67 7468 203d 2073  upper_length = s
+000132b0: 656c 662e 6675 6e63 2e73 6861 7065 5b2d  elf.func.shape[-
+000132c0: 315d 2e5f 696e 7462 6f75 6e64 730a 2020  1]._intbounds.  
+000132d0: 2020 2020 2020 6966 2075 7070 6572 5f6c        if upper_l
+000132e0: 656e 6774 6820 3d3d 2030 3a0a 2020 2020  ength == 0:.    
+000132f0: 2020 2020 2020 2020 7265 7475 726e 2030          return 0
+00013300: 2c20 300a 2020 2020 2020 2020 656c 6966  , 0.        elif
+00013310: 206c 6f77 6572 5f6c 656e 6774 6820 3d3d   lower_length ==
+00013320: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00013330: 7265 7475 726e 206d 696e 2830 2c20 6c6f  return min(0, lo
+00013340: 7765 725f 6675 6e63 202a 2075 7070 6572  wer_func * upper
+00013350: 5f6c 656e 6774 6829 2c20 6d61 7828 302c  _length), max(0,
+00013360: 2075 7070 6572 5f66 756e 6320 2a20 7570   upper_func * up
+00013370: 7065 725f 6c65 6e67 7468 290a 2020 2020  per_length).    
+00013380: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00013390: 2020 2020 2020 7265 7475 726e 206d 696e        return min
+000133a0: 286c 6f77 6572 5f66 756e 6320 2a20 6c6f  (lower_func * lo
+000133b0: 7765 725f 6c65 6e67 7468 2c20 6c6f 7765  wer_length, lowe
+000133c0: 725f 6675 6e63 202a 2075 7070 6572 5f6c  r_func * upper_l
+000133d0: 656e 6774 6829 2c20 6d61 7828 7570 7065  ength), max(uppe
+000133e0: 725f 6675 6e63 202a 206c 6f77 6572 5f6c  r_func * lower_l
+000133f0: 656e 6774 682c 2075 7070 6572 5f66 756e  ength, upper_fun
+00013400: 6320 2a20 7570 7065 725f 6c65 6e67 7468  c * upper_length
+00013410: 290a 0a0a 636c 6173 7320 5461 6b65 4469  )...class TakeDi
+00013420: 6167 2841 7272 6179 293a 0a0a 2020 2020  ag(Array):..    
+00013430: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
+00013440: 662c 2066 756e 633a 2041 7272 6179 293a  f, func: Array):
+00013450: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+00013460: 6973 696e 7374 616e 6365 2866 756e 632c  isinstance(func,
+00013470: 2041 7272 6179 2920 616e 6420 6675 6e63   Array) and func
+00013480: 2e6e 6469 6d20 3e3d 2032 2061 6e64 205f  .ndim >= 2 and _
+00013490: 6571 7561 6c73 5f73 696d 706c 6966 6965  equals_simplifie
+000134a0: 6428 2a66 756e 632e 7368 6170 655b 2d32  d(*func.shape[-2
+000134b0: 3a5d 292c 2066 2766 756e 633d 7b66 756e  :]), f'func={fun
+000134c0: 6321 727d 270a 2020 2020 2020 2020 7365  c!r}'.        se
+000134d0: 6c66 2e66 756e 6320 3d20 6675 6e63 0a20  lf.func = func. 
+000134e0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+000134f0: 5f69 6e69 745f 5f28 6172 6773 3d28 6675  _init__(args=(fu
+00013500: 6e63 2c29 2c20 7368 6170 653d 6675 6e63  nc,), shape=func
+00013510: 2e73 6861 7065 5b3a 2d31 5d2c 2064 7479  .shape[:-1], dty
+00013520: 7065 3d66 756e 632e 6474 7970 6529 0a0a  pe=func.dtype)..
+00013530: 2020 2020 6465 6620 5f73 696d 706c 6966      def _simplif
+00013540: 6965 6428 7365 6c66 293a 0a20 2020 2020  ied(self):.     
+00013550: 2020 2069 6620 5f65 7175 616c 735f 7363     if _equals_sc
+00013560: 616c 6172 5f63 6f6e 7374 616e 7428 7365  alar_constant(se
+00013570: 6c66 2e73 6861 7065 5b2d 315d 2c20 3129  lf.shape[-1], 1)
+00013580: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00013590: 7475 726e 2054 616b 6528 7365 6c66 2e66  turn Take(self.f
+000135a0: 756e 632c 2063 6f6e 7374 616e 7428 3029  unc, constant(0)
+000135b0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+000135c0: 2073 656c 662e 6675 6e63 2e5f 7461 6b65   self.func._take
+000135d0: 6469 6167 2873 656c 662e 6e64 696d 2d31  diag(self.ndim-1
+000135e0: 2c20 7365 6c66 2e6e 6469 6d29 0a0a 2020  , self.ndim)..  
+000135f0: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
+00013600: 2020 2020 6465 6620 6576 616c 6628 6172      def evalf(ar
+00013610: 7229 3a0a 2020 2020 2020 2020 7265 7475  r):.        retu
+00013620: 726e 206e 756d 7079 2e65 696e 7375 6d28  rn numpy.einsum(
+00013630: 272e 2e2e 6b6b 2d3e 2e2e 2e6b 272c 2061  '...kk->...k', a
+00013640: 7272 2c20 6f70 7469 6d69 7a65 3d46 616c  rr, optimize=Fal
+00013650: 7365 290a 0a20 2020 2064 6566 205f 6465  se)..    def _de
+00013660: 7269 7661 7469 7665 2873 656c 662c 2076  rivative(self, v
+00013670: 6172 2c20 7365 656e 293a 0a20 2020 2020  ar, seen):.     
+00013680: 2020 2072 6574 7572 6e20 7461 6b65 6469     return takedi
+00013690: 6167 2864 6572 6976 6174 6976 6528 7365  ag(derivative(se
+000136a0: 6c66 2e66 756e 632c 2076 6172 2c20 7365  lf.func, var, se
+000136b0: 656e 292c 2073 656c 662e 6e64 696d 2d31  en), self.ndim-1
+000136c0: 2c20 7365 6c66 2e6e 6469 6d29 0a0a 2020  , self.ndim)..  
+000136d0: 2020 6465 6620 5f74 616b 6528 7365 6c66    def _take(self
+000136e0: 2c20 696e 6465 782c 2061 7869 7329 3a0a  , index, axis):.
+000136f0: 2020 2020 2020 2020 6966 2061 7869 7320          if axis 
+00013700: 3c20 7365 6c66 2e6e 6469 6d20 2d20 313a  < self.ndim - 1:
+00013710: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00013720: 7572 6e20 5461 6b65 4469 6167 285f 7461  urn TakeDiag(_ta
+00013730: 6b65 2873 656c 662e 6675 6e63 2c20 696e  ke(self.func, in
+00013740: 6465 782c 2061 7869 7329 290a 2020 2020  dex, axis)).    
+00013750: 2020 2020 6675 6e63 203d 205f 7461 6b65      func = _take
+00013760: 2854 616b 6528 7365 6c66 2e66 756e 632c  (Take(self.func,
+00013770: 2069 6e64 6578 292c 2069 6e64 6578 2c20   index), index, 
+00013780: 7365 6c66 2e6e 6469 6d2d 3129 0a20 2020  self.ndim-1).   
+00013790: 2020 2020 2066 6f72 2069 2069 6e20 7265       for i in re
+000137a0: 7665 7273 6564 2872 616e 6765 2873 656c  versed(range(sel
+000137b0: 662e 6e64 696d 2d31 2c20 7365 6c66 2e6e  f.ndim-1, self.n
+000137c0: 6469 6d2d 312b 696e 6465 782e 6e64 696d  dim-1+index.ndim
+000137d0: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
+000137e0: 6675 6e63 203d 2074 616b 6564 6961 6728  func = takediag(
+000137f0: 6675 6e63 2c20 692c 2069 2b69 6e64 6578  func, i, i+index
+00013800: 2e6e 6469 6d29 0a20 2020 2020 2020 2072  .ndim).        r
+00013810: 6574 7572 6e20 6675 6e63 0a0a 2020 2020  eturn func..    
+00013820: 6465 6620 5f73 756d 2873 656c 662c 2061  def _sum(self, a
+00013830: 7869 7329 3a0a 2020 2020 2020 2020 6966  xis):.        if
+00013840: 2061 7869 7320 213d 2073 656c 662e 6e64   axis != self.nd
+00013850: 696d 202d 2031 3a0a 2020 2020 2020 2020  im - 1:.        
+00013860: 2020 2020 7265 7475 726e 2054 616b 6544      return TakeD
+00013870: 6961 6728 7375 6d28 7365 6c66 2e66 756e  iag(sum(self.fun
+00013880: 632c 2061 7869 7329 290a 0a20 2020 2064  c, axis))..    d
+00013890: 6566 205f 696e 7462 6f75 6e64 735f 696d  ef _intbounds_im
+000138a0: 706c 2873 656c 6629 3a0a 2020 2020 2020  pl(self):.      
+000138b0: 2020 7265 7475 726e 2073 656c 662e 6675    return self.fu
+000138c0: 6e63 2e5f 696e 7462 6f75 6e64 730a 0a0a  nc._intbounds...
+000138d0: 636c 6173 7320 5461 6b65 2841 7272 6179  class Take(Array
+000138e0: 293a 0a0a 2020 2020 6465 6620 5f5f 696e  ):..    def __in
+000138f0: 6974 5f5f 2873 656c 662c 2066 756e 633a  it__(self, func:
+00013900: 2041 7272 6179 2c20 696e 6469 6365 733a   Array, indices:
+00013910: 2041 7272 6179 293a 0a20 2020 2020 2020   Array):.       
+00013920: 2061 7373 6572 7420 6973 696e 7374 616e   assert isinstan
+00013930: 6365 2866 756e 632c 2041 7272 6179 2920  ce(func, Array) 
+00013940: 616e 6420 6675 6e63 2e6e 6469 6d20 3e20  and func.ndim > 
+00013950: 302c 2066 2766 756e 633d 7b66 756e 6321  0, f'func={func!
+00013960: 727d 270a 2020 2020 2020 2020 6173 7365  r}'.        asse
+00013970: 7274 2069 7369 6e73 7461 6e63 6528 696e  rt isinstance(in
+00013980: 6469 6365 732c 2041 7272 6179 2920 616e  dices, Array) an
+00013990: 6420 696e 6469 6365 732e 6474 7970 6520  d indices.dtype 
+000139a0: 3d3d 2069 6e74 2c20 6627 696e 6469 6365  == int, f'indice
+000139b0: 733d 7b69 6e64 6963 6573 2172 7d27 0a20  s={indices!r}'. 
+000139c0: 2020 2020 2020 2073 656c 662e 6675 6e63         self.func
+000139d0: 203d 2066 756e 630a 2020 2020 2020 2020   = func.        
+000139e0: 7365 6c66 2e69 6e64 6963 6573 203d 2069  self.indices = i
+000139f0: 6e64 6963 6573 0a20 2020 2020 2020 2073  ndices.        s
+00013a00: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
+00013a10: 6172 6773 3d28 6675 6e63 2c20 696e 6469  args=(func, indi
+00013a20: 6365 7329 2c20 7368 6170 653d 6675 6e63  ces), shape=func
+00013a30: 2e73 6861 7065 5b3a 2d31 5d2b 696e 6469  .shape[:-1]+indi
+00013a40: 6365 732e 7368 6170 652c 2064 7479 7065  ces.shape, dtype
+00013a50: 3d66 756e 632e 6474 7970 6529 0a0a 2020  =func.dtype)..  
+00013a60: 2020 6465 6620 5f73 696d 706c 6966 6965    def _simplifie
+00013a70: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
+00013a80: 2069 6620 616e 7928 6973 7a65 726f 286e   if any(iszero(n
+00013a90: 2920 666f 7220 6e20 696e 2073 656c 662e  ) for n in self.
+00013aa0: 696e 6469 6365 732e 7368 6170 6529 3a0a  indices.shape):.
+00013ab0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00013ac0: 726e 207a 6572 6f73 5f6c 696b 6528 7365  rn zeros_like(se
+00013ad0: 6c66 290a 2020 2020 2020 2020 756e 616c  lf).        unal
+00013ae0: 6967 6e65 642c 2077 6865 7265 203d 2075  igned, where = u
+00013af0: 6e61 6c69 676e 2873 656c 662e 696e 6469  nalign(self.indi
+00013b00: 6365 7329 0a20 2020 2020 2020 2069 6620  ces).        if 
+00013b10: 6c65 6e28 7768 6572 6529 203c 2073 656c  len(where) < sel
+00013b20: 662e 696e 6469 6365 732e 6e64 696d 3a0a  f.indices.ndim:.
+00013b30: 2020 2020 2020 2020 2020 2020 6e20 3d20              n = 
+00013b40: 7365 6c66 2e66 756e 632e 6e64 696d 2d31  self.func.ndim-1
 00013b50: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00013b60: 7572 6e20 7365 6c66 2e66 756e 630a 2020  urn self.func.  
-00013b70: 2020 2020 2020 656c 6966 2070 203d 3d20        elif p == 
-00013b80: 323a 0a20 2020 2020 2020 2020 2020 2072  2:.            r
-00013b90: 6574 7572 6e20 7365 6c66 2e66 756e 6320  eturn self.func 
-00013ba0: 2a20 7365 6c66 2e66 756e 630a 2020 2020  * self.func.    
-00013bb0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00013bc0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00013bd0: 662e 6675 6e63 2e5f 706f 7765 7228 7365  f.func._power(se
-00013be0: 6c66 2e70 6f77 6572 290a 0a20 2020 2064  lf.power)..    d
-00013bf0: 6566 205f 6f70 7469 6d69 7a65 645f 666f  ef _optimized_fo
-00013c00: 725f 6e75 6d70 7928 7365 6c66 293a 0a20  r_numpy(self):. 
-00013c10: 2020 2020 2020 2070 203d 2073 656c 662e         p = self.
-00013c20: 706f 7765 722e 5f63 6f6e 7374 5f75 6e69  power._const_uni
-00013c30: 666f 726d 0a20 2020 2020 2020 2069 6620  form.        if 
-00013c40: 7020 3d3d 202d 313a 0a20 2020 2020 2020  p == -1:.       
-00013c50: 2020 2020 2072 6574 7572 6e20 5265 6369       return Reci
-00013c60: 7072 6f63 616c 2873 656c 662e 6675 6e63  procal(self.func
-00013c70: 290a 2020 2020 2020 2020 656c 6966 2070  ).        elif p
-00013c80: 203d 3d20 2d32 3a0a 2020 2020 2020 2020   == -2:.        
-00013c90: 2020 2020 7265 7475 726e 2052 6563 6970      return Recip
-00013ca0: 726f 6361 6c28 7365 6c66 2e66 756e 6320  rocal(self.func 
-00013cb0: 2a20 7365 6c66 2e66 756e 6329 0a20 2020  * self.func).   
-00013cc0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00013cd0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00013ce0: 6c66 2e5f 7369 6d70 6c69 6669 6564 2829  lf._simplified()
-00013cf0: 0a0a 2020 2020 6465 6620 6576 616c 6628  ..    def evalf(
-00013d00: 7365 6c66 2c20 6261 7365 2c20 6578 7029  self, base, exp)
-00013d10: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00013d20: 206e 756d 7079 2e70 6f77 6572 2862 6173   numpy.power(bas
-00013d30: 652c 2065 7870 290a 0a20 2020 2064 6566  e, exp)..    def
-00013d40: 205f 6465 7269 7661 7469 7665 2873 656c   _derivative(sel
-00013d50: 662c 2076 6172 2c20 7365 656e 293a 0a20  f, var, seen):. 
-00013d60: 2020 2020 2020 2069 6620 7365 6c66 2e70         if self.p
-00013d70: 6f77 6572 2e69 7363 6f6e 7374 616e 743a  ower.isconstant:
-00013d80: 0a20 2020 2020 2020 2020 2020 2070 203d  .            p =
-00013d90: 2073 656c 662e 706f 7765 722e 6576 616c   self.power.eval
-00013da0: 2829 0a20 2020 2020 2020 2020 2020 2072  ().            r
-00013db0: 6574 7572 6e20 6569 6e73 756d 2827 412c  eturn einsum('A,
-00013dc0: 412c 4142 2d3e 4142 272c 2070 2c20 706f  A,AB->AB', p, po
-00013dd0: 7765 7228 7365 6c66 2e66 756e 632c 2070  wer(self.func, p
-00013de0: 202d 2028 7020 213d 2030 2929 2c20 6465   - (p != 0)), de
-00013df0: 7269 7661 7469 7665 2873 656c 662e 6675  rivative(self.fu
-00013e00: 6e63 2c20 7661 722c 2073 6565 6e29 290a  nc, var, seen)).
-00013e10: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00013e20: 6474 7970 6520 3d3d 2063 6f6d 706c 6578  dtype == complex
-00013e30: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-00013e40: 6973 6520 4e6f 7449 6d70 6c65 6d65 6e74  ise NotImplement
-00013e50: 6564 4572 726f 7228 2754 6865 2063 6f6d  edError('The com
-00013e60: 706c 6578 2064 6572 6976 6174 6976 6520  plex derivative 
-00013e70: 6973 206e 6f74 2069 6d70 6c65 6d65 6e74  is not implement
-00013e80: 6564 2e27 290a 2020 2020 2020 2020 2320  ed.').        # 
-00013e90: 7365 6c66 203d 2066 756e 632a 2a70 6f77  self = func**pow
-00013ea0: 6572 0a20 2020 2020 2020 2023 206c 6e20  er.        # ln 
-00013eb0: 7365 6c66 203d 2070 6f77 6572 202a 206c  self = power * l
-00013ec0: 6e20 6675 6e63 0a20 2020 2020 2020 2023  n func.        #
-00013ed0: 2073 656c 6660 202f 2073 656c 6620 3d20   self` / self = 
-00013ee0: 706f 7765 7260 202a 206c 6e20 6675 6e63  power` * ln func
-00013ef0: 202b 2070 6f77 6572 202a 2066 756e 6360   + power * func`
-00013f00: 202f 2066 756e 630a 2020 2020 2020 2020   / func.        
-00013f10: 2320 7365 6c66 6020 3d20 706f 7765 7260  # self` = power`
-00013f20: 202a 206c 6e20 6675 6e63 202a 2073 656c   * ln func * sel
-00013f30: 6620 2b20 706f 7765 7220 2a20 6675 6e63  f + power * func
-00013f40: 6020 2a20 6675 6e63 2a2a 2870 6f77 6572  ` * func**(power
-00013f50: 2d31 290a 2020 2020 2020 2020 7265 7475  -1).        retu
-00013f60: 726e 2065 696e 7375 6d28 2741 2c41 2c41  rn einsum('A,A,A
-00013f70: 422d 3e41 4227 2c20 7365 6c66 2e70 6f77  B->AB', self.pow
-00013f80: 6572 2c20 706f 7765 7228 7365 6c66 2e66  er, power(self.f
-00013f90: 756e 632c 2073 656c 662e 706f 7765 7220  unc, self.power 
-00013fa0: 2d20 3129 2c20 6465 7269 7661 7469 7665  - 1), derivative
-00013fb0: 2873 656c 662e 6675 6e63 2c20 7661 722c  (self.func, var,
-00013fc0: 2073 6565 6e29 2920 5c0a 2020 2020 2020   seen)) \.      
-00013fd0: 2020 2020 2020 2b20 6569 6e73 756d 2827        + einsum('
-00013fe0: 412c 412c 4142 2d3e 4142 272c 206c 6e28  A,A,AB->AB', ln(
-00013ff0: 7365 6c66 2e66 756e 6329 2c20 7365 6c66  self.func), self
-00014000: 2c20 6465 7269 7661 7469 7665 2873 656c  , derivative(sel
-00014010: 662e 706f 7765 722c 2076 6172 2c20 7365  f.power, var, se
-00014020: 656e 2929 0a0a 2020 2020 6465 6620 5f70  en))..    def _p
-00014030: 6f77 6572 2873 656c 662c 206e 293a 0a20  ower(self, n):. 
-00014040: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
-00014050: 7479 7065 203d 3d20 636f 6d70 6c65 7820  type == complex 
-00014060: 6f72 206e 2e64 7479 7065 203d 3d20 636f  or n.dtype == co
-00014070: 6d70 6c65 783a 0a20 2020 2020 2020 2020  mplex:.         
-00014080: 2020 2072 6574 7572 6e0a 2020 2020 2020     return.      
-00014090: 2020 6675 6e63 203d 2073 656c 662e 6675    func = self.fu
-000140a0: 6e63 0a20 2020 2020 2020 206e 6577 706f  nc.        newpo
-000140b0: 7765 7220 3d20 4d75 6c74 6970 6c79 285b  wer = Multiply([
-000140c0: 7365 6c66 2e70 6f77 6572 2c20 6e5d 290a  self.power, n]).
-000140d0: 2020 2020 2020 2020 6966 2069 737a 6572          if iszer
-000140e0: 6f28 7365 6c66 2e70 6f77 6572 2025 2032  o(self.power % 2
-000140f0: 2920 616e 6420 6e6f 7420 6973 7a65 726f  ) and not iszero
-00014100: 286e 6577 706f 7765 7220 2520 3229 3a0a  (newpower % 2):.
-00014110: 2020 2020 2020 2020 2020 2020 6675 6e63              func
-00014120: 203d 2061 6273 2866 756e 6329 0a20 2020   = abs(func).   
-00014130: 2020 2020 2072 6574 7572 6e20 506f 7765       return Powe
-00014140: 7228 6675 6e63 2c20 6e65 7770 6f77 6572  r(func, newpower
-00014150: 290a 0a20 2020 2064 6566 205f 7461 6b65  )..    def _take
-00014160: 6469 6167 2873 656c 662c 2061 7869 7331  diag(self, axis1
-00014170: 2c20 6178 6973 3229 3a0a 2020 2020 2020  , axis2):.      
-00014180: 2020 7265 7475 726e 2050 6f77 6572 285f    return Power(_
-00014190: 7461 6b65 6469 6167 2873 656c 662e 6675  takediag(self.fu
-000141a0: 6e63 2c20 6178 6973 312c 2061 7869 7332  nc, axis1, axis2
-000141b0: 292c 205f 7461 6b65 6469 6167 2873 656c  ), _takediag(sel
-000141c0: 662e 706f 7765 722c 2061 7869 7331 2c20  f.power, axis1, 
-000141d0: 6178 6973 3229 290a 0a20 2020 2064 6566  axis2))..    def
-000141e0: 205f 7461 6b65 2873 656c 662c 2069 6e64   _take(self, ind
-000141f0: 6578 2c20 6178 6973 293a 0a20 2020 2020  ex, axis):.     
-00014200: 2020 2072 6574 7572 6e20 506f 7765 7228     return Power(
-00014210: 5f74 616b 6528 7365 6c66 2e66 756e 632c  _take(self.func,
-00014220: 2069 6e64 6578 2c20 6178 6973 292c 205f   index, axis), _
-00014230: 7461 6b65 2873 656c 662e 706f 7765 722c  take(self.power,
-00014240: 2069 6e64 6578 2c20 6178 6973 2929 0a0a   index, axis))..
-00014250: 2020 2020 6465 6620 5f75 6e72 6176 656c      def _unravel
-00014260: 2873 656c 662c 2061 7869 732c 2073 6861  (self, axis, sha
-00014270: 7065 293a 0a20 2020 2020 2020 2072 6574  pe):.        ret
-00014280: 7572 6e20 506f 7765 7228 756e 7261 7665  urn Power(unrave
-00014290: 6c28 7365 6c66 2e66 756e 632c 2061 7869  l(self.func, axi
-000142a0: 732c 2073 6861 7065 292c 2075 6e72 6176  s, shape), unrav
-000142b0: 656c 2873 656c 662e 706f 7765 722c 2061  el(self.power, a
-000142c0: 7869 732c 2073 6861 7065 2929 0a0a 0a63  xis, shape))...c
-000142d0: 6c61 7373 2050 6f69 6e74 7769 7365 2841  lass Pointwise(A
-000142e0: 7272 6179 293a 0a20 2020 2027 2727 0a20  rray):.    '''. 
-000142f0: 2020 2041 6273 7472 6163 7420 6261 7365     Abstract base
-00014300: 2063 6c61 7373 2066 6f72 2070 6f69 6e74   class for point
-00014310: 7769 7365 2061 7272 6179 2066 756e 6374  wise array funct
-00014320: 696f 6e73 2e0a 2020 2020 2727 270a 0a20  ions..    '''.. 
-00014330: 2020 205f 5f73 6c6f 7473 5f5f 203d 2027     __slots__ = '
-00014340: 6172 6773 272c 0a0a 2020 2020 6465 7269  args',..    deri
-00014350: 7620 3d20 4e6f 6e65 0a20 2020 2063 6f6d  v = None.    com
-00014360: 706c 6578 5f64 6572 6976 203d 204e 6f6e  plex_deriv = Non
-00014370: 650a 0a20 2020 2040 7479 7065 732e 6170  e..    @types.ap
-00014380: 706c 795f 616e 6e6f 7461 7469 6f6e 730a  ply_annotations.
-00014390: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
-000143a0: 2873 656c 662c 202a 6172 6773 3a20 6173  (self, *args: as
-000143b0: 6172 7261 7973 293a 0a20 2020 2020 2020  arrays):.       
-000143c0: 2072 6574 7661 6c20 3d20 7365 6c66 2e65   retval = self.e
-000143d0: 7661 6c66 282a 5b6e 756d 7079 2e6f 6e65  valf(*[numpy.one
-000143e0: 7328 2829 2c20 6474 7970 653d 6172 672e  s((), dtype=arg.
-000143f0: 6474 7970 6529 2066 6f72 2061 7267 2069  dtype) for arg i
-00014400: 6e20 6172 6773 5d29 0a20 2020 2020 2020  n args]).       
-00014410: 2073 6861 7065 3020 3d20 6172 6773 5b30   shape0 = args[0
-00014420: 5d2e 7368 6170 650a 2020 2020 2020 2020  ].shape.        
-00014430: 6173 7365 7274 2061 6c6c 2865 7175 616c  assert all(equal
-00014440: 7368 6170 6528 6172 672e 7368 6170 652c  shape(arg.shape,
-00014450: 2073 6861 7065 3029 2066 6f72 2061 7267   shape0) for arg
-00014460: 2069 6e20 6172 6773 5b31 3a5d 292c 2027   in args[1:]), '
-00014470: 706f 696e 7477 6973 6520 6172 6775 6d65  pointwise argume
-00014480: 6e74 7320 6861 7665 2069 6e63 6f6e 7369  nts have inconsi
-00014490: 7374 656e 7420 7368 6170 6573 270a 2020  stent shapes'.  
-000144a0: 2020 2020 2020 7365 6c66 2e61 7267 7320        self.args 
-000144b0: 3d20 6172 6773 0a20 2020 2020 2020 2073  = args.        s
-000144c0: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
-000144d0: 6172 6773 3d61 7267 732c 2073 6861 7065  args=args, shape
-000144e0: 3d73 6861 7065 302c 2064 7479 7065 3d72  =shape0, dtype=r
-000144f0: 6574 7661 6c2e 6474 7970 6529 0a0a 2020  etval.dtype)..  
-00014500: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
-00014510: 2020 2064 6566 206f 7574 6572 2863 6c73     def outer(cls
-00014520: 2c20 2a61 7267 7329 3a0a 2020 2020 2020  , *args):.      
-00014530: 2020 2727 2741 6c74 6572 6e61 7469 7665    '''Alternative
-00014540: 2063 6f6e 7374 7275 6374 6f72 2074 6861   constructor tha
-00014550: 7420 6f75 7465 722d 616c 6967 6e73 2074  t outer-aligns t
-00014560: 6865 2061 7267 756d 656e 7473 2e0a 0a20  he arguments... 
-00014570: 2020 2020 2020 2054 6865 206f 7574 7075         The outpu
-00014580: 7420 7368 6170 6520 6f66 2074 6869 7320  t shape of this 
-00014590: 706f 696e 7477 6973 6520 6675 6e63 7469  pointwise functi
-000145a0: 6f6e 2069 7320 7468 6520 7375 6d20 6f66  on is the sum of
-000145b0: 2061 6c6c 2073 6861 7065 7320 6f66 2069   all shapes of i
-000145c0: 7473 0a20 2020 2020 2020 2061 7267 756d  ts.        argum
-000145d0: 656e 7473 2e20 5768 656e 2063 616c 6c65  ents. When calle
-000145e0: 6420 7769 7468 206d 756c 7469 706c 6520  d with multiple 
-000145f0: 6172 6775 6d65 6e74 732c 2074 6865 2066  arguments, the f
-00014600: 6972 7374 2061 7267 756d 656e 7420 7769  irst argument wi
-00014610: 6c6c 2062 650a 2020 2020 2020 2020 6170  ll be.        ap
-00014620: 7065 6e64 6564 2077 6974 6820 7369 6e67  pended with sing
-00014630: 6c65 746f 6e20 6178 6573 2074 6f20 6d61  leton axes to ma
-00014640: 7463 6820 7468 6520 6f75 7470 7574 2073  tch the output s
-00014650: 6861 7065 2c20 7468 6520 7365 636f 6e64  hape, the second
-00014660: 2061 7267 756d 656e 740a 2020 2020 2020   argument.      
-00014670: 2020 7769 6c6c 2062 6520 7072 6570 656e    will be prepen
-00014680: 6465 6420 7769 7468 2061 7320 6d61 6e79  ded with as many
-00014690: 2073 696e 676c 6574 6f6e 2061 7865 7320   singleton axes 
-000146a0: 6173 2074 6865 2064 696d 656e 7369 6f6e  as the dimension
-000146b0: 206f 6620 7468 650a 2020 2020 2020 2020   of the.        
-000146c0: 6f72 6967 696e 616c 2066 6972 7374 2061  original first a
-000146d0: 7267 756d 656e 7420 616e 6420 6170 7065  rgument and appe
-000146e0: 6e64 6564 2074 6f20 6d61 7463 6820 7468  nded to match th
-000146f0: 6520 6f75 7470 7574 2073 6861 7065 2c20  e output shape, 
-00014700: 616e 6420 736f 0a20 2020 2020 2020 2066  and so.        f
-00014710: 6f72 7468 2061 6e64 2073 6f20 6f6e 2e0a  orth and so on..
-00014720: 2020 2020 2020 2020 2727 270a 0a20 2020          '''..   
-00014730: 2020 2020 2061 7267 7320 3d20 7475 706c       args = tupl
-00014740: 6528 6d61 7028 6173 6172 7261 792c 2061  e(map(asarray, a
-00014750: 7267 7329 290a 2020 2020 2020 2020 7368  rgs)).        sh
-00014760: 6170 6520 3d20 6275 696c 7469 6e73 2e73  ape = builtins.s
-00014770: 756d 2828 6172 672e 7368 6170 6520 666f  um((arg.shape fo
-00014780: 7220 6172 6720 696e 2061 7267 7329 2c20  r arg in args), 
-00014790: 2829 290a 2020 2020 2020 2020 6f66 6673  ()).        offs
-000147a0: 6574 7320 3d20 6e75 6d70 792e 6375 6d73  ets = numpy.cums
-000147b0: 756d 285b 305d 2b5b 6172 672e 6e64 696d  um([0]+[arg.ndim
-000147c0: 2066 6f72 2061 7267 2069 6e20 6172 6773   for arg in args
-000147d0: 5d29 0a20 2020 2020 2020 2072 6574 7572  ]).        retur
-000147e0: 6e20 636c 7328 2a28 7072 6570 656e 6461  n cls(*(prependa
-000147f0: 7865 7328 6170 7065 6e64 6178 6573 2861  xes(appendaxes(a
-00014800: 7267 2c20 7368 6170 655b 723a 5d29 2c20  rg, shape[r:]), 
-00014810: 7368 6170 655b 3a6c 5d29 2066 6f72 2061  shape[:l]) for a
-00014820: 7267 2c20 6c2c 2072 2069 6e20 7a69 7028  rg, l, r in zip(
-00014830: 6172 6773 2c20 6f66 6673 6574 735b 3a2d  args, offsets[:-
-00014840: 315d 2c20 6f66 6673 6574 735b 313a 5d29  1], offsets[1:])
-00014850: 2929 0a0a 2020 2020 6465 6620 5f73 696d  ))..    def _sim
-00014860: 706c 6966 6965 6428 7365 6c66 293a 0a20  plified(self):. 
-00014870: 2020 2020 2020 2069 6620 6c65 6e28 7365         if len(se
-00014880: 6c66 2e61 7267 7329 203d 3d20 3120 616e  lf.args) == 1 an
-00014890: 6420 6973 696e 7374 616e 6365 2873 656c  d isinstance(sel
-000148a0: 662e 6172 6773 5b30 5d2c 2054 7261 6e73  f.args[0], Trans
-000148b0: 706f 7365 293a 0a20 2020 2020 2020 2020  pose):.         
-000148c0: 2020 2061 7267 2c20 3d20 7365 6c66 2e61     arg, = self.a
-000148d0: 7267 730a 2020 2020 2020 2020 2020 2020  rgs.            
-000148e0: 7265 7475 726e 2054 7261 6e73 706f 7365  return Transpose
-000148f0: 2873 656c 662e 5f5f 636c 6173 735f 5f28  (self.__class__(
-00014900: 6172 672e 6675 6e63 292c 2061 7267 2e61  arg.func), arg.a
-00014910: 7865 7329 0a20 2020 2020 2020 202a 756e  xes).        *un
-00014920: 696e 7365 7274 6564 2c20 7768 6572 6520  inserted, where 
-00014930: 3d20 756e 616c 6967 6e28 2a73 656c 662e  = unalign(*self.
-00014940: 6172 6773 290a 2020 2020 2020 2020 6966  args).        if
-00014950: 206c 656e 2877 6865 7265 2920 213d 2073   len(where) != s
-00014960: 656c 662e 6e64 696d 3a0a 2020 2020 2020  elf.ndim:.      
-00014970: 2020 2020 2020 7265 7475 726e 2061 6c69        return ali
-00014980: 676e 2873 656c 662e 5f5f 636c 6173 735f  gn(self.__class_
-00014990: 5f28 2a75 6e69 6e73 6572 7465 6429 2c20  _(*uninserted), 
-000149a0: 7768 6572 652c 2073 656c 662e 7368 6170  where, self.shap
-000149b0: 6529 0a0a 2020 2020 6465 6620 5f6f 7074  e)..    def _opt
-000149c0: 696d 697a 6564 5f66 6f72 5f6e 756d 7079  imized_for_numpy
-000149d0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-000149e0: 6966 2073 656c 662e 6973 636f 6e73 7461  if self.isconsta
-000149f0: 6e74 3a0a 2020 2020 2020 2020 2020 2020  nt:.            
-00014a00: 7265 7476 616c 203d 2073 656c 662e 6576  retval = self.ev
-00014a10: 616c 2829 0a20 2020 2020 2020 2020 2020  al().           
-00014a20: 2072 6574 7572 6e20 436f 6e73 7461 6e74   return Constant
-00014a30: 2872 6574 7661 6c29 0a0a 2020 2020 6465  (retval)..    de
-00014a40: 6620 5f64 6572 6976 6174 6976 6528 7365  f _derivative(se
-00014a50: 6c66 2c20 7661 722c 2073 6565 6e29 3a0a  lf, var, seen):.
-00014a60: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00014a70: 636f 6d70 6c65 785f 6465 7269 7620 6973  complex_deriv is
-00014a80: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
-00014a90: 2020 2020 2020 2072 6574 7572 6e20 7574         return ut
-00014aa0: 696c 2e73 756d 2865 696e 7375 6d28 2741  il.sum(einsum('A
-00014ab0: 2c41 422d 3e41 4227 2c20 6465 7269 7628  ,AB->AB', deriv(
-00014ac0: 2a73 656c 662e 6172 6773 292c 2064 6572  *self.args), der
-00014ad0: 6976 6174 6976 6528 6172 672c 2076 6172  ivative(arg, var
-00014ae0: 2c20 7365 656e 2929 2066 6f72 2061 7267  , seen)) for arg
-00014af0: 2c20 6465 7269 7620 696e 207a 6970 2873  , deriv in zip(s
-00014b00: 656c 662e 6172 6773 2c20 7365 6c66 2e63  elf.args, self.c
-00014b10: 6f6d 706c 6578 5f64 6572 6976 2929 0a20  omplex_deriv)). 
-00014b20: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-00014b30: 2e64 7479 7065 203d 3d20 636f 6d70 6c65  .dtype == comple
-00014b40: 7820 6f72 2076 6172 2e64 7479 7065 203d  x or var.dtype =
-00014b50: 3d20 636f 6d70 6c65 783a 0a20 2020 2020  = complex:.     
-00014b60: 2020 2020 2020 2072 6169 7365 204e 6f74         raise Not
-00014b70: 496d 706c 656d 656e 7465 6445 7272 6f72  ImplementedError
-00014b80: 2827 5468 6520 636f 6d70 6c65 7820 6465  ('The complex de
-00014b90: 7269 7661 7469 7665 2069 7320 6e6f 7420  rivative is not 
-00014ba0: 696d 706c 656d 656e 7465 642e 2729 0a20  implemented.'). 
-00014bb0: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-00014bc0: 2e64 6572 6976 2069 7320 6e6f 7420 4e6f  .deriv is not No
-00014bd0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00014be0: 7265 7475 726e 2075 7469 6c2e 7375 6d28  return util.sum(
-00014bf0: 6569 6e73 756d 2827 412c 4142 2d3e 4142  einsum('A,AB->AB
-00014c00: 272c 2064 6572 6976 282a 7365 6c66 2e61  ', deriv(*self.a
-00014c10: 7267 7329 2c20 6465 7269 7661 7469 7665  rgs), derivative
-00014c20: 2861 7267 2c20 7661 722c 2073 6565 6e29  (arg, var, seen)
-00014c30: 2920 666f 7220 6172 672c 2064 6572 6976  ) for arg, deriv
-00014c40: 2069 6e20 7a69 7028 7365 6c66 2e61 7267   in zip(self.arg
-00014c50: 732c 2073 656c 662e 6465 7269 7629 290a  s, self.deriv)).
-00014c60: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00014c70: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00014c80: 2073 7570 6572 2829 2e5f 6465 7269 7661   super()._deriva
-00014c90: 7469 7665 2876 6172 2c20 7365 656e 290a  tive(var, seen).
-00014ca0: 0a20 2020 2064 6566 205f 7461 6b65 6469  .    def _takedi
-00014cb0: 6167 2873 656c 662c 2061 7869 7331 2c20  ag(self, axis1, 
-00014cc0: 6178 6973 3229 3a0a 2020 2020 2020 2020  axis2):.        
-00014cd0: 7265 7475 726e 2073 656c 662e 5f5f 636c  return self.__cl
-00014ce0: 6173 735f 5f28 2a5b 5f74 616b 6564 6961  ass__(*[_takedia
-00014cf0: 6728 6172 672c 2061 7869 7331 2c20 6178  g(arg, axis1, ax
-00014d00: 6973 3229 2066 6f72 2061 7267 2069 6e20  is2) for arg in 
-00014d10: 7365 6c66 2e61 7267 735d 290a 0a20 2020  self.args])..   
-00014d20: 2064 6566 205f 7461 6b65 2873 656c 662c   def _take(self,
-00014d30: 2069 6e64 6578 2c20 6178 6973 293a 0a20   index, axis):. 
-00014d40: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00014d50: 6c66 2e5f 5f63 6c61 7373 5f5f 282a 5b5f  lf.__class__(*[_
-00014d60: 7461 6b65 2861 7267 2c20 696e 6465 782c  take(arg, index,
-00014d70: 2061 7869 7329 2066 6f72 2061 7267 2069   axis) for arg i
-00014d80: 6e20 7365 6c66 2e61 7267 735d 290a 0a20  n self.args]).. 
-00014d90: 2020 2064 6566 205f 756e 7261 7665 6c28     def _unravel(
-00014da0: 7365 6c66 2c20 6178 6973 2c20 7368 6170  self, axis, shap
-00014db0: 6529 3a0a 2020 2020 2020 2020 7265 7475  e):.        retu
-00014dc0: 726e 2073 656c 662e 5f5f 636c 6173 735f  rn self.__class_
-00014dd0: 5f28 2a5b 756e 7261 7665 6c28 6172 672c  _(*[unravel(arg,
-00014de0: 2061 7869 732c 2073 6861 7065 2920 666f   axis, shape) fo
-00014df0: 7220 6172 6720 696e 2073 656c 662e 6172  r arg in self.ar
-00014e00: 6773 5d29 0a0a 0a63 6c61 7373 2052 6563  gs])...class Rec
-00014e10: 6970 726f 6361 6c28 506f 696e 7477 6973  iprocal(Pointwis
-00014e20: 6529 3a0a 2020 2020 5f5f 736c 6f74 735f  e):.    __slots_
-00014e30: 5f20 3d20 2829 0a20 2020 2065 7661 6c66  _ = ().    evalf
-00014e40: 203d 206e 756d 7079 2e72 6563 6970 726f   = numpy.recipro
-00014e50: 6361 6c0a 0a0a 636c 6173 7320 4e65 6761  cal...class Nega
-00014e60: 7469 7665 2850 6f69 6e74 7769 7365 293a  tive(Pointwise):
-00014e70: 0a20 2020 205f 5f73 6c6f 7473 5f5f 203d  .    __slots__ =
-00014e80: 2028 290a 2020 2020 6576 616c 6620 3d20   ().    evalf = 
-00014e90: 6e75 6d70 792e 6e65 6761 7469 7665 0a0a  numpy.negative..
-00014ea0: 2020 2020 6465 6620 5f69 6e74 626f 756e      def _intboun
-00014eb0: 6473 5f69 6d70 6c28 7365 6c66 293a 0a20  ds_impl(self):. 
-00014ec0: 2020 2020 2020 206c 6f77 6572 2c20 7570         lower, up
-00014ed0: 7065 7220 3d20 7365 6c66 2e61 7267 735b  per = self.args[
-00014ee0: 305d 2e5f 696e 7462 6f75 6e64 730a 2020  0]._intbounds.  
-00014ef0: 2020 2020 2020 7265 7475 726e 202d 7570        return -up
-00014f00: 7065 722c 202d 6c6f 7765 720a 0a0a 636c  per, -lower...cl
-00014f10: 6173 7320 466c 6f6f 7244 6976 6964 6528  ass FloorDivide(
-00014f20: 506f 696e 7477 6973 6529 3a0a 2020 2020  Pointwise):.    
-00014f30: 5f5f 736c 6f74 735f 5f20 3d20 2829 0a20  __slots__ = (). 
-00014f40: 2020 2065 7661 6c66 203d 206e 756d 7079     evalf = numpy
-00014f50: 2e66 6c6f 6f72 5f64 6976 6964 650a 0a0a  .floor_divide...
-00014f60: 636c 6173 7320 4162 736f 6c75 7465 2850  class Absolute(P
-00014f70: 6f69 6e74 7769 7365 293a 0a20 2020 205f  ointwise):.    _
-00014f80: 5f73 6c6f 7473 5f5f 203d 2028 290a 2020  _slots__ = ().  
-00014f90: 2020 6576 616c 6620 3d20 6e75 6d70 792e    evalf = numpy.
-00014fa0: 6162 736f 6c75 7465 0a0a 2020 2020 6465  absolute..    de
-00014fb0: 6620 5f69 6e74 626f 756e 6473 5f69 6d70  f _intbounds_imp
-00014fc0: 6c28 7365 6c66 293a 0a20 2020 2020 2020  l(self):.       
-00014fd0: 206c 6f77 6572 2c20 7570 7065 7220 3d20   lower, upper = 
-00014fe0: 7365 6c66 2e61 7267 735b 305d 2e5f 696e  self.args[0]._in
-00014ff0: 7462 6f75 6e64 730a 2020 2020 2020 2020  tbounds.        
-00015000: 6578 7472 656d 6120 3d20 6275 696c 7469  extrema = builti
-00015010: 6e73 2e61 6273 286c 6f77 6572 292c 2062  ns.abs(lower), b
-00015020: 7569 6c74 696e 732e 6162 7328 7570 7065  uiltins.abs(uppe
-00015030: 7229 0a20 2020 2020 2020 2069 6620 6c6f  r).        if lo
-00015040: 7765 7220 3c3d 2030 2061 6e64 2075 7070  wer <= 0 and upp
-00015050: 6572 203e 3d20 303a 0a20 2020 2020 2020  er >= 0:.       
-00015060: 2020 2020 2072 6574 7572 6e20 302c 206d       return 0, m
-00015070: 6178 2865 7874 7265 6d61 290a 2020 2020  ax(extrema).    
-00015080: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00015090: 2020 2020 2020 7265 7475 726e 206d 696e        return min
-000150a0: 2865 7874 7265 6d61 292c 206d 6178 2865  (extrema), max(e
-000150b0: 7874 7265 6d61 290a 0a0a 636c 6173 7320  xtrema)...class 
-000150c0: 436f 7328 506f 696e 7477 6973 6529 3a0a  Cos(Pointwise):.
-000150d0: 2020 2020 2743 6f73 696e 652c 2065 6c65      'Cosine, ele
-000150e0: 6d65 6e74 2d77 6973 652e 270a 2020 2020  ment-wise.'.    
-000150f0: 5f5f 736c 6f74 735f 5f20 3d20 2829 0a20  __slots__ = (). 
-00015100: 2020 2065 7661 6c66 203d 206e 756d 7079     evalf = numpy
-00015110: 2e63 6f73 0a20 2020 2063 6f6d 706c 6578  .cos.    complex
-00015120: 5f64 6572 6976 203d 206c 616d 6264 6120  _deriv = lambda 
-00015130: 783a 202d 5369 6e28 7829 2c0a 0a0a 636c  x: -Sin(x),...cl
-00015140: 6173 7320 5369 6e28 506f 696e 7477 6973  ass Sin(Pointwis
-00015150: 6529 3a0a 2020 2020 2753 696e 652c 2065  e):.    'Sine, e
-00015160: 6c65 6d65 6e74 2d77 6973 652e 270a 2020  lement-wise.'.  
-00015170: 2020 5f5f 736c 6f74 735f 5f20 3d20 2829    __slots__ = ()
-00015180: 0a20 2020 2065 7661 6c66 203d 206e 756d  .    evalf = num
-00015190: 7079 2e73 696e 0a20 2020 2063 6f6d 706c  py.sin.    compl
-000151a0: 6578 5f64 6572 6976 203d 2043 6f73 2c0a  ex_deriv = Cos,.
-000151b0: 0a0a 636c 6173 7320 5461 6e28 506f 696e  ..class Tan(Poin
-000151c0: 7477 6973 6529 3a0a 2020 2020 2754 616e  twise):.    'Tan
-000151d0: 6765 6e74 2c20 656c 656d 656e 742d 7769  gent, element-wi
-000151e0: 7365 2e27 0a20 2020 205f 5f73 6c6f 7473  se.'.    __slots
-000151f0: 5f5f 203d 2028 290a 2020 2020 6576 616c  __ = ().    eval
-00015200: 6620 3d20 6e75 6d70 792e 7461 6e0a 2020  f = numpy.tan.  
-00015210: 2020 636f 6d70 6c65 785f 6465 7269 7620    complex_deriv 
-00015220: 3d20 6c61 6d62 6461 2078 3a20 436f 7328  = lambda x: Cos(
-00015230: 7829 2a2a 2d32 2c0a 0a0a 636c 6173 7320  x)**-2,...class 
-00015240: 4172 6353 696e 2850 6f69 6e74 7769 7365  ArcSin(Pointwise
-00015250: 293a 0a20 2020 2027 496e 7665 7273 6520  ):.    'Inverse 
-00015260: 7369 6e65 2c20 656c 656d 656e 742d 7769  sine, element-wi
-00015270: 7365 2e27 0a20 2020 205f 5f73 6c6f 7473  se.'.    __slots
-00015280: 5f5f 203d 2028 290a 2020 2020 6576 616c  __ = ().    eval
-00015290: 6620 3d20 6e75 6d70 792e 6172 6373 696e  f = numpy.arcsin
-000152a0: 0a20 2020 2063 6f6d 706c 6578 5f64 6572  .    complex_der
-000152b0: 6976 203d 206c 616d 6264 6120 783a 2072  iv = lambda x: r
-000152c0: 6563 6970 726f 6361 6c28 7371 7274 2831  eciprocal(sqrt(1
-000152d0: 2d78 2a2a 3229 292c 0a0a 0a63 6c61 7373  -x**2)),...class
-000152e0: 2041 7263 436f 7328 506f 696e 7477 6973   ArcCos(Pointwis
-000152f0: 6529 3a0a 2020 2020 2749 6e76 6572 7365  e):.    'Inverse
-00015300: 2063 6f73 696e 652c 2065 6c65 6d65 6e74   cosine, element
-00015310: 2d77 6973 652e 270a 2020 2020 5f5f 736c  -wise.'.    __sl
-00015320: 6f74 735f 5f20 3d20 2829 0a20 2020 2065  ots__ = ().    e
-00015330: 7661 6c66 203d 206e 756d 7079 2e61 7263  valf = numpy.arc
-00015340: 636f 730a 2020 2020 636f 6d70 6c65 785f  cos.    complex_
-00015350: 6465 7269 7620 3d20 6c61 6d62 6461 2078  deriv = lambda x
-00015360: 3a20 2d72 6563 6970 726f 6361 6c28 7371  : -reciprocal(sq
-00015370: 7274 2831 2d78 2a2a 3229 292c 0a0a 0a63  rt(1-x**2)),...c
-00015380: 6c61 7373 2041 7263 5461 6e28 506f 696e  lass ArcTan(Poin
-00015390: 7477 6973 6529 3a0a 2020 2020 2749 6e76  twise):.    'Inv
-000153a0: 6572 7365 2074 616e 6765 6e74 2c20 656c  erse tangent, el
-000153b0: 656d 656e 742d 7769 7365 2e27 0a20 2020  ement-wise.'.   
-000153c0: 205f 5f73 6c6f 7473 5f5f 203d 2028 290a   __slots__ = ().
-000153d0: 2020 2020 6576 616c 6620 3d20 6e75 6d70      evalf = nump
-000153e0: 792e 6172 6374 616e 0a20 2020 2063 6f6d  y.arctan.    com
-000153f0: 706c 6578 5f64 6572 6976 203d 206c 616d  plex_deriv = lam
-00015400: 6264 6120 783a 2072 6563 6970 726f 6361  bda x: reciproca
-00015410: 6c28 312b 782a 2a32 292c 0a0a 0a63 6c61  l(1+x**2),...cla
-00015420: 7373 2043 6f73 4828 506f 696e 7477 6973  ss CosH(Pointwis
-00015430: 6529 3a0a 2020 2020 2748 7970 6572 626f  e):.    'Hyperbo
-00015440: 6c69 6320 636f 7369 6e65 2c20 656c 656d  lic cosine, elem
-00015450: 656e 742d 7769 7365 2e27 0a20 2020 205f  ent-wise.'.    _
-00015460: 5f73 6c6f 7473 5f5f 203d 2028 290a 2020  _slots__ = ().  
-00015470: 2020 6576 616c 6620 3d20 6e75 6d70 792e    evalf = numpy.
-00015480: 636f 7368 0a20 2020 2063 6f6d 706c 6578  cosh.    complex
-00015490: 5f64 6572 6976 203d 206c 616d 6264 6120  _deriv = lambda 
-000154a0: 783a 2053 696e 4828 7829 2c0a 0a0a 636c  x: SinH(x),...cl
-000154b0: 6173 7320 5369 6e48 2850 6f69 6e74 7769  ass SinH(Pointwi
-000154c0: 7365 293a 0a20 2020 2027 4879 7065 7262  se):.    'Hyperb
-000154d0: 6f6c 6963 2073 696e 652c 2065 6c65 6d65  olic sine, eleme
-000154e0: 6e74 2d77 6973 652e 270a 2020 2020 5f5f  nt-wise.'.    __
-000154f0: 736c 6f74 735f 5f20 3d20 2829 0a20 2020  slots__ = ().   
-00015500: 2065 7661 6c66 203d 206e 756d 7079 2e73   evalf = numpy.s
-00015510: 696e 680a 2020 2020 636f 6d70 6c65 785f  inh.    complex_
-00015520: 6465 7269 7620 3d20 436f 7348 2c0a 0a0a  deriv = CosH,...
-00015530: 636c 6173 7320 5461 6e48 2850 6f69 6e74  class TanH(Point
-00015540: 7769 7365 293a 0a20 2020 2027 4879 7065  wise):.    'Hype
-00015550: 7262 6f6c 6963 2074 616e 6765 6e74 2c20  rbolic tangent, 
-00015560: 656c 656d 656e 742d 7769 7365 2e27 0a20  element-wise.'. 
-00015570: 2020 205f 5f73 6c6f 7473 5f5f 203d 2028     __slots__ = (
-00015580: 290a 2020 2020 6576 616c 6620 3d20 6e75  ).    evalf = nu
-00015590: 6d70 792e 7461 6e68 0a20 2020 2063 6f6d  mpy.tanh.    com
-000155a0: 706c 6578 5f64 6572 6976 203d 206c 616d  plex_deriv = lam
-000155b0: 6264 6120 783a 2031 202d 2054 616e 4828  bda x: 1 - TanH(
-000155c0: 7829 2a2a 322c 0a0a 0a63 6c61 7373 2041  x)**2,...class A
-000155d0: 7263 5461 6e48 2850 6f69 6e74 7769 7365  rcTanH(Pointwise
-000155e0: 293a 0a20 2020 2027 496e 7665 7273 6520  ):.    'Inverse 
-000155f0: 7461 6e67 656e 742c 2065 6c65 6d65 6e74  tangent, element
-00015600: 2d77 6973 652e 270a 2020 2020 5f5f 736c  -wise.'.    __sl
-00015610: 6f74 735f 5f20 3d20 2829 0a20 2020 2065  ots__ = ().    e
-00015620: 7661 6c66 203d 206e 756d 7079 2e61 7263  valf = numpy.arc
-00015630: 7461 6e68 0a20 2020 2063 6f6d 706c 6578  tanh.    complex
-00015640: 5f64 6572 6976 203d 206c 616d 6264 6120  _deriv = lambda 
-00015650: 783a 2072 6563 6970 726f 6361 6c28 312d  x: reciprocal(1-
-00015660: 782a 2a32 292c 0a0a 0a63 6c61 7373 2045  x**2),...class E
-00015670: 7870 2850 6f69 6e74 7769 7365 293a 0a20  xp(Pointwise):. 
-00015680: 2020 205f 5f73 6c6f 7473 5f5f 203d 2028     __slots__ = (
-00015690: 290a 2020 2020 6576 616c 6620 3d20 6e75  ).    evalf = nu
-000156a0: 6d70 792e 6578 700a 2020 2020 636f 6d70  mpy.exp.    comp
-000156b0: 6c65 785f 6465 7269 7620 3d20 6c61 6d62  lex_deriv = lamb
-000156c0: 6461 2078 3a20 4578 7028 7829 2c0a 0a0a  da x: Exp(x),...
-000156d0: 636c 6173 7320 4c6f 6728 506f 696e 7477  class Log(Pointw
-000156e0: 6973 6529 3a0a 2020 2020 5f5f 736c 6f74  ise):.    __slot
-000156f0: 735f 5f20 3d20 2829 0a20 2020 2065 7661  s__ = ().    eva
-00015700: 6c66 203d 206e 756d 7079 2e6c 6f67 0a20  lf = numpy.log. 
-00015710: 2020 2063 6f6d 706c 6578 5f64 6572 6976     complex_deriv
-00015720: 203d 206c 616d 6264 6120 783a 2072 6563   = lambda x: rec
-00015730: 6970 726f 6361 6c28 7829 2c0a 0a0a 636c  iprocal(x),...cl
-00015740: 6173 7320 4d6f 6428 506f 696e 7477 6973  ass Mod(Pointwis
-00015750: 6529 3a0a 2020 2020 5f5f 736c 6f74 735f  e):.    __slots_
-00015760: 5f20 3d20 2829 0a20 2020 2065 7661 6c66  _ = ().    evalf
-00015770: 203d 206e 756d 7079 2e6d 6f64 0a0a 2020   = numpy.mod..  
-00015780: 2020 6465 6620 5f69 6e74 626f 756e 6473    def _intbounds
-00015790: 5f69 6d70 6c28 7365 6c66 293a 0a20 2020  _impl(self):.   
-000157a0: 2020 2020 2064 6976 6964 656e 642c 2064       dividend, d
-000157b0: 6976 6973 6f72 203d 2073 656c 662e 6172  ivisor = self.ar
-000157c0: 6773 0a20 2020 2020 2020 206c 6f77 6572  gs.        lower
-000157d0: 5f64 6976 6973 6f72 2c20 7570 7065 725f  _divisor, upper_
-000157e0: 6469 7669 736f 7220 3d20 6469 7669 736f  divisor = diviso
-000157f0: 722e 5f69 6e74 626f 756e 6473 0a20 2020  r._intbounds.   
-00015800: 2020 2020 2069 6620 6c6f 7765 725f 6469       if lower_di
-00015810: 7669 736f 7220 3e20 303a 0a20 2020 2020  visor > 0:.     
-00015820: 2020 2020 2020 206c 6f77 6572 5f64 6976         lower_div
-00015830: 6964 656e 642c 2075 7070 6572 5f64 6976  idend, upper_div
-00015840: 6964 656e 6420 3d20 6469 7669 6465 6e64  idend = dividend
-00015850: 2e5f 696e 7462 6f75 6e64 730a 2020 2020  ._intbounds.    
-00015860: 2020 2020 2020 2020 6966 2030 203c 3d20          if 0 <= 
-00015870: 6c6f 7765 725f 6469 7669 6465 6e64 2061  lower_dividend a
-00015880: 6e64 2075 7070 6572 5f64 6976 6964 656e  nd upper_dividen
-00015890: 6420 3c20 6c6f 7765 725f 6469 7669 736f  d < lower_diviso
-000158a0: 723a 0a20 2020 2020 2020 2020 2020 2020  r:.             
-000158b0: 2020 2072 6574 7572 6e20 6c6f 7765 725f     return lower_
-000158c0: 6469 7669 6465 6e64 2c20 7570 7065 725f  dividend, upper_
-000158d0: 6469 7669 6465 6e64 0a20 2020 2020 2020  dividend.       
-000158e0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-000158f0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00015900: 6e20 302c 2075 7070 6572 5f64 6976 6973  n 0, upper_divis
-00015910: 6f72 202d 2031 0a20 2020 2020 2020 2065  or - 1.        e
-00015920: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00015930: 2072 6574 7572 6e20 7375 7065 7228 292e   return super().
-00015940: 5f69 6e74 626f 756e 6473 5f69 6d70 6c28  _intbounds_impl(
-00015950: 290a 0a20 2020 2064 6566 205f 7369 6d70  )..    def _simp
-00015960: 6c69 6669 6564 2873 656c 6629 3a0a 2020  lified(self):.  
-00015970: 2020 2020 2020 6469 7669 6465 6e64 2c20        dividend, 
-00015980: 6469 7669 736f 7220 3d20 7365 6c66 2e61  divisor = self.a
-00015990: 7267 730a 2020 2020 2020 2020 6c6f 7765  rgs.        lowe
-000159a0: 725f 6469 7669 736f 722c 2075 7070 6572  r_divisor, upper
-000159b0: 5f64 6976 6973 6f72 203d 2064 6976 6973  _divisor = divis
-000159c0: 6f72 2e5f 696e 7462 6f75 6e64 730a 2020  or._intbounds.  
-000159d0: 2020 2020 2020 6966 206c 6f77 6572 5f64        if lower_d
-000159e0: 6976 6973 6f72 203e 2030 3a0a 2020 2020  ivisor > 0:.    
-000159f0: 2020 2020 2020 2020 6c6f 7765 725f 6469          lower_di
-00015a00: 7669 6465 6e64 2c20 7570 7065 725f 6469  vidend, upper_di
-00015a10: 7669 6465 6e64 203d 2064 6976 6964 656e  vidend = dividen
-00015a20: 642e 5f69 6e74 626f 756e 6473 0a20 2020  d._intbounds.   
-00015a30: 2020 2020 2020 2020 2069 6620 3020 3c3d           if 0 <=
-00015a40: 206c 6f77 6572 5f64 6976 6964 656e 6420   lower_dividend 
-00015a50: 616e 6420 7570 7065 725f 6469 7669 6465  and upper_divide
-00015a60: 6e64 203c 206c 6f77 6572 5f64 6976 6973  nd < lower_divis
-00015a70: 6f72 3a0a 2020 2020 2020 2020 2020 2020  or:.            
-00015a80: 2020 2020 7265 7475 726e 2064 6976 6964      return divid
-00015a90: 656e 640a 0a0a 636c 6173 7320 4172 6354  end...class ArcT
-00015aa0: 616e 3228 506f 696e 7477 6973 6529 3a0a  an2(Pointwise):.
-00015ab0: 2020 2020 5f5f 736c 6f74 735f 5f20 3d20      __slots__ = 
-00015ac0: 2829 0a20 2020 2065 7661 6c66 203d 206e  ().    evalf = n
-00015ad0: 756d 7079 2e61 7263 7461 6e32 0a20 2020  umpy.arctan2.   
-00015ae0: 2064 6572 6976 203d 206c 616d 6264 6120   deriv = lambda 
-00015af0: 782c 2079 3a20 7920 2f20 2878 2a2a 3220  x, y: y / (x**2 
-00015b00: 2b20 792a 2a32 292c 206c 616d 6264 6120  + y**2), lambda 
-00015b10: 782c 2079 3a20 2d78 202f 2028 782a 2a32  x, y: -x / (x**2
-00015b20: 202b 2079 2a2a 3229 0a0a 2020 2020 4074   + y**2)..    @t
-00015b30: 7970 6573 2e61 7070 6c79 5f61 6e6e 6f74  ypes.apply_annot
-00015b40: 6174 696f 6e73 0a20 2020 2064 6566 205f  ations.    def _
-00015b50: 5f69 6e69 745f 5f28 7365 6c66 2c20 206c  _init__(self,  l
-00015b60: 6566 743a 2061 7361 7272 6179 2c20 7269  eft: asarray, ri
-00015b70: 6768 743a 2061 7361 7272 6179 293a 0a20  ght: asarray):. 
-00015b80: 2020 2020 2020 2069 6620 6c65 6674 2e64         if left.d
-00015b90: 7479 7065 203d 3d20 636f 6d70 6c65 7820  type == complex 
-00015ba0: 6f72 2072 6967 6874 2e64 7479 7065 203d  or right.dtype =
-00015bb0: 3d20 636f 6d70 6c65 783a 0a20 2020 2020  = complex:.     
-00015bc0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-00015bd0: 7565 4572 726f 7228 2761 7263 7461 6e32  ueError('arctan2
-00015be0: 2069 7320 6e6f 7420 6465 6669 6e65 6420   is not defined 
-00015bf0: 666f 7220 636f 6d70 6c65 7820 6e75 6d62  for complex numb
-00015c00: 6572 7327 290a 2020 2020 2020 2020 7375  ers').        su
-00015c10: 7065 7228 292e 5f5f 696e 6974 5f5f 286c  per().__init__(l
-00015c20: 6566 742c 2072 6967 6874 290a 0a0a 636c  eft, right)...cl
-00015c30: 6173 7320 4772 6561 7465 7228 506f 696e  ass Greater(Poin
-00015c40: 7477 6973 6529 3a0a 2020 2020 5f5f 736c  twise):.    __sl
-00015c50: 6f74 735f 5f20 3d20 2829 0a20 2020 2065  ots__ = ().    e
-00015c60: 7661 6c66 203d 206e 756d 7079 2e67 7265  valf = numpy.gre
-00015c70: 6174 6572 0a0a 2020 2020 4074 7970 6573  ater..    @types
-00015c80: 2e61 7070 6c79 5f61 6e6e 6f74 6174 696f  .apply_annotatio
-00015c90: 6e73 0a20 2020 2064 6566 205f 5f69 6e69  ns.    def __ini
-00015ca0: 745f 5f28 7365 6c66 2c20 206c 6566 743a  t__(self,  left:
-00015cb0: 2061 7361 7272 6179 2c20 7269 6768 743a   asarray, right:
-00015cc0: 2061 7361 7272 6179 293a 0a20 2020 2020   asarray):.     
-00015cd0: 2020 2069 6620 6c65 6674 2e64 7479 7065     if left.dtype
-00015ce0: 203d 3d20 636f 6d70 6c65 7820 6f72 2072   == complex or r
-00015cf0: 6967 6874 2e64 7479 7065 203d 3d20 636f  ight.dtype == co
-00015d00: 6d70 6c65 783a 0a20 2020 2020 2020 2020  mplex:.         
-00015d10: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00015d20: 726f 7228 2743 6f6d 706c 6578 206e 756d  ror('Complex num
-00015d30: 6265 7273 2068 6176 6520 6e6f 2074 6f74  bers have no tot
-00015d40: 616c 206f 7264 6572 2e27 290a 2020 2020  al order.').    
-00015d50: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
-00015d60: 6974 5f5f 286c 6566 742c 2072 6967 6874  it__(left, right
-00015d70: 290a 0a0a 636c 6173 7320 4571 7561 6c28  )...class Equal(
-00015d80: 506f 696e 7477 6973 6529 3a0a 2020 2020  Pointwise):.    
-00015d90: 5f5f 736c 6f74 735f 5f20 3d20 2829 0a20  __slots__ = (). 
-00015da0: 2020 2065 7661 6c66 203d 206e 756d 7079     evalf = numpy
-00015db0: 2e65 7175 616c 0a0a 0a63 6c61 7373 204c  .equal...class L
-00015dc0: 6573 7328 506f 696e 7477 6973 6529 3a0a  ess(Pointwise):.
-00015dd0: 2020 2020 5f5f 736c 6f74 735f 5f20 3d20      __slots__ = 
-00015de0: 2829 0a20 2020 2065 7661 6c66 203d 206e  ().    evalf = n
-00015df0: 756d 7079 2e6c 6573 730a 0a20 2020 2040  umpy.less..    @
-00015e00: 7479 7065 732e 6170 706c 795f 616e 6e6f  types.apply_anno
-00015e10: 7461 7469 6f6e 730a 2020 2020 6465 6620  tations.    def 
-00015e20: 5f5f 696e 6974 5f5f 2873 656c 662c 2020  __init__(self,  
-00015e30: 6c65 6674 3a20 6173 6172 7261 792c 2072  left: asarray, r
-00015e40: 6967 6874 3a20 6173 6172 7261 7929 3a0a  ight: asarray):.
-00015e50: 2020 2020 2020 2020 6966 206c 6566 742e          if left.
-00015e60: 6474 7970 6520 3d3d 2063 6f6d 706c 6578  dtype == complex
-00015e70: 206f 7220 7269 6768 742e 6474 7970 6520   or right.dtype 
-00015e80: 3d3d 2063 6f6d 706c 6578 3a0a 2020 2020  == complex:.    
-00015e90: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-00015ea0: 6c75 6545 7272 6f72 2827 436f 6d70 6c65  lueError('Comple
-00015eb0: 7820 6e75 6d62 6572 7320 6861 7665 206e  x numbers have n
-00015ec0: 6f20 746f 7461 6c20 6f72 6465 722e 2729  o total order.')
-00015ed0: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
-00015ee0: 2e5f 5f69 6e69 745f 5f28 6c65 6674 2c20  .__init__(left, 
-00015ef0: 7269 6768 7429 0a0a 0a63 6c61 7373 204d  right)...class M
-00015f00: 696e 696d 756d 2850 6f69 6e74 7769 7365  inimum(Pointwise
-00015f10: 293a 0a20 2020 205f 5f73 6c6f 7473 5f5f  ):.    __slots__
-00015f20: 203d 2028 290a 2020 2020 6576 616c 6620   = ().    evalf 
-00015f30: 3d20 6e75 6d70 792e 6d69 6e69 6d75 6d0a  = numpy.minimum.
-00015f40: 2020 2020 6465 7269 7620 3d20 6c61 6d62      deriv = lamb
-00015f50: 6461 2078 2c20 793a 202e 3520 2d20 2e35  da x, y: .5 - .5
-00015f60: 202a 2053 6967 6e28 7820 2d20 7929 2c20   * Sign(x - y), 
-00015f70: 6c61 6d62 6461 2078 2c20 793a 202e 3520  lambda x, y: .5 
-00015f80: 2b20 2e35 202a 2053 6967 6e28 7820 2d20  + .5 * Sign(x - 
-00015f90: 7929 0a0a 2020 2020 4074 7970 6573 2e61  y)..    @types.a
-00015fa0: 7070 6c79 5f61 6e6e 6f74 6174 696f 6e73  pply_annotations
-00015fb0: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-00015fc0: 5f28 7365 6c66 2c20 206c 6566 743a 2061  _(self,  left: a
-00015fd0: 7361 7272 6179 2c20 7269 6768 743a 2061  sarray, right: a
-00015fe0: 7361 7272 6179 293a 0a20 2020 2020 2020  sarray):.       
-00015ff0: 2069 6620 6c65 6674 2e64 7479 7065 203d   if left.dtype =
-00016000: 3d20 636f 6d70 6c65 7820 6f72 2072 6967  = complex or rig
-00016010: 6874 2e64 7479 7065 203d 3d20 636f 6d70  ht.dtype == comp
-00016020: 6c65 783a 0a20 2020 2020 2020 2020 2020  lex:.           
-00016030: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00016040: 7228 2743 6f6d 706c 6578 206e 756d 6265  r('Complex numbe
-00016050: 7273 2068 6176 6520 6e6f 2074 6f74 616c  rs have no total
-00016060: 206f 7264 6572 2e27 290a 2020 2020 2020   order.').      
-00016070: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-00016080: 5f5f 286c 6566 742c 2072 6967 6874 290a  __(left, right).
-00016090: 0a20 2020 2064 6566 205f 7369 6d70 6c69  .    def _simpli
-000160a0: 6669 6564 2873 656c 6629 3a0a 2020 2020  fied(self):.    
-000160b0: 2020 2020 6966 2073 656c 662e 6474 7970      if self.dtyp
-000160c0: 6520 3d3d 2069 6e74 3a0a 2020 2020 2020  e == int:.      
-000160d0: 2020 2020 2020 6c6f 7765 7231 2c20 7570        lower1, up
-000160e0: 7065 7231 203d 2073 656c 662e 6172 6773  per1 = self.args
-000160f0: 5b30 5d2e 5f69 6e74 626f 756e 6473 0a20  [0]._intbounds. 
-00016100: 2020 2020 2020 2020 2020 206c 6f77 6572             lower
-00016110: 322c 2075 7070 6572 3220 3d20 7365 6c66  2, upper2 = self
-00016120: 2e61 7267 735b 315d 2e5f 696e 7462 6f75  .args[1]._intbou
-00016130: 6e64 730a 2020 2020 2020 2020 2020 2020  nds.            
-00016140: 6966 2075 7070 6572 3120 3c3d 206c 6f77  if upper1 <= low
-00016150: 6572 323a 0a20 2020 2020 2020 2020 2020  er2:.           
-00016160: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00016170: 2e61 7267 735b 305d 0a20 2020 2020 2020  .args[0].       
-00016180: 2020 2020 2065 6c69 6620 7570 7065 7232       elif upper2
-00016190: 203c 3d20 6c6f 7765 7231 3a0a 2020 2020   <= lower1:.    
-000161a0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000161b0: 726e 2073 656c 662e 6172 6773 5b31 5d0a  rn self.args[1].
-000161c0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-000161d0: 7570 6572 2829 2e5f 7369 6d70 6c69 6669  uper()._simplifi
-000161e0: 6564 2829 0a0a 2020 2020 6465 6620 5f69  ed()..    def _i
-000161f0: 6e74 626f 756e 6473 5f69 6d70 6c28 7365  ntbounds_impl(se
-00016200: 6c66 293a 0a20 2020 2020 2020 206c 6f77  lf):.        low
-00016210: 6572 312c 2075 7070 6572 3120 3d20 7365  er1, upper1 = se
-00016220: 6c66 2e61 7267 735b 305d 2e5f 696e 7462  lf.args[0]._intb
-00016230: 6f75 6e64 730a 2020 2020 2020 2020 6c6f  ounds.        lo
-00016240: 7765 7232 2c20 7570 7065 7232 203d 2073  wer2, upper2 = s
-00016250: 656c 662e 6172 6773 5b31 5d2e 5f69 6e74  elf.args[1]._int
-00016260: 626f 756e 6473 0a20 2020 2020 2020 2072  bounds.        r
-00016270: 6574 7572 6e20 6d69 6e28 6c6f 7765 7231  eturn min(lower1
-00016280: 2c20 6c6f 7765 7232 292c 206d 696e 2875  , lower2), min(u
-00016290: 7070 6572 312c 2075 7070 6572 3229 0a0a  pper1, upper2)..
-000162a0: 0a63 6c61 7373 204d 6178 696d 756d 2850  .class Maximum(P
-000162b0: 6f69 6e74 7769 7365 293a 0a20 2020 205f  ointwise):.    _
-000162c0: 5f73 6c6f 7473 5f5f 203d 2028 290a 2020  _slots__ = ().  
-000162d0: 2020 6576 616c 6620 3d20 6e75 6d70 792e    evalf = numpy.
-000162e0: 6d61 7869 6d75 6d0a 2020 2020 6465 7269  maximum.    deri
-000162f0: 7620 3d20 6c61 6d62 6461 2078 2c20 793a  v = lambda x, y:
-00016300: 202e 3520 2b20 2e35 202a 2053 6967 6e28   .5 + .5 * Sign(
-00016310: 7820 2d20 7929 2c20 6c61 6d62 6461 2078  x - y), lambda x
-00016320: 2c20 793a 202e 3520 2d20 2e35 202a 2053  , y: .5 - .5 * S
-00016330: 6967 6e28 7820 2d20 7929 0a0a 2020 2020  ign(x - y)..    
-00016340: 4074 7970 6573 2e61 7070 6c79 5f61 6e6e  @types.apply_ann
-00016350: 6f74 6174 696f 6e73 0a20 2020 2064 6566  otations.    def
-00016360: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
-00016370: 206c 6566 743a 2061 7361 7272 6179 2c20   left: asarray, 
-00016380: 7269 6768 743a 2061 7361 7272 6179 293a  right: asarray):
-00016390: 0a20 2020 2020 2020 2069 6620 6c65 6674  .        if left
-000163a0: 2e64 7479 7065 203d 3d20 636f 6d70 6c65  .dtype == comple
-000163b0: 7820 6f72 2072 6967 6874 2e64 7479 7065  x or right.dtype
-000163c0: 203d 3d20 636f 6d70 6c65 783a 0a20 2020   == complex:.   
-000163d0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-000163e0: 616c 7565 4572 726f 7228 2743 6f6d 706c  alueError('Compl
-000163f0: 6578 206e 756d 6265 7273 2068 6176 6520  ex numbers have 
-00016400: 6e6f 2074 6f74 616c 206f 7264 6572 2e27  no total order.'
-00016410: 290a 2020 2020 2020 2020 7375 7065 7228  ).        super(
-00016420: 292e 5f5f 696e 6974 5f5f 286c 6566 742c  ).__init__(left,
-00016430: 2072 6967 6874 290a 0a20 2020 2064 6566   right)..    def
-00016440: 205f 7369 6d70 6c69 6669 6564 2873 656c   _simplified(sel
-00016450: 6629 3a0a 2020 2020 2020 2020 6966 2073  f):.        if s
-00016460: 656c 662e 6474 7970 6520 3d3d 2069 6e74  elf.dtype == int
-00016470: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
-00016480: 7765 7231 2c20 7570 7065 7231 203d 2073  wer1, upper1 = s
-00016490: 656c 662e 6172 6773 5b30 5d2e 5f69 6e74  elf.args[0]._int
-000164a0: 626f 756e 6473 0a20 2020 2020 2020 2020  bounds.         
-000164b0: 2020 206c 6f77 6572 322c 2075 7070 6572     lower2, upper
-000164c0: 3220 3d20 7365 6c66 2e61 7267 735b 315d  2 = self.args[1]
-000164d0: 2e5f 696e 7462 6f75 6e64 730a 2020 2020  ._intbounds.    
-000164e0: 2020 2020 2020 2020 6966 2075 7070 6572          if upper
-000164f0: 3220 3c3d 206c 6f77 6572 313a 0a20 2020  2 <= lower1:.   
-00016500: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00016510: 7572 6e20 7365 6c66 2e61 7267 735b 305d  urn self.args[0]
-00016520: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-00016530: 6620 7570 7065 7231 203c 3d20 6c6f 7765  f upper1 <= lowe
-00016540: 7232 3a0a 2020 2020 2020 2020 2020 2020  r2:.            
-00016550: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00016560: 6172 6773 5b31 5d0a 2020 2020 2020 2020  args[1].        
-00016570: 7265 7475 726e 2073 7570 6572 2829 2e5f  return super()._
-00016580: 7369 6d70 6c69 6669 6564 2829 0a0a 2020  simplified()..  
-00016590: 2020 6465 6620 5f69 6e74 626f 756e 6473    def _intbounds
-000165a0: 5f69 6d70 6c28 7365 6c66 293a 0a20 2020  _impl(self):.   
-000165b0: 2020 2020 206c 6f77 6572 312c 2075 7070       lower1, upp
-000165c0: 6572 3120 3d20 7365 6c66 2e61 7267 735b  er1 = self.args[
-000165d0: 305d 2e5f 696e 7462 6f75 6e64 730a 2020  0]._intbounds.  
-000165e0: 2020 2020 2020 6c6f 7765 7232 2c20 7570        lower2, up
-000165f0: 7065 7232 203d 2073 656c 662e 6172 6773  per2 = self.args
-00016600: 5b31 5d2e 5f69 6e74 626f 756e 6473 0a20  [1]._intbounds. 
-00016610: 2020 2020 2020 2072 6574 7572 6e20 6d61         return ma
-00016620: 7828 6c6f 7765 7231 2c20 6c6f 7765 7232  x(lower1, lower2
-00016630: 292c 206d 6178 2875 7070 6572 312c 2075  ), max(upper1, u
-00016640: 7070 6572 3229 0a0a 0a63 6c61 7373 2043  pper2)...class C
-00016650: 6f6e 6a75 6761 7465 2850 6f69 6e74 7769  onjugate(Pointwi
-00016660: 7365 293a 0a20 2020 205f 5f73 6c6f 7473  se):.    __slots
-00016670: 5f5f 203d 2028 290a 0a20 2020 2040 7479  __ = ()..    @ty
-00016680: 7065 732e 6170 706c 795f 616e 6e6f 7461  pes.apply_annota
-00016690: 7469 6f6e 730a 2020 2020 6465 6620 5f5f  tions.    def __
-000166a0: 696e 6974 5f5f 2873 656c 662c 2061 7267  init__(self, arg
-000166b0: 3a20 6173 6172 7261 7929 3a0a 2020 2020  : asarray):.    
-000166c0: 2020 2020 6173 7365 7274 2061 7267 2e64      assert arg.d
-000166d0: 7479 7065 203d 3d20 636f 6d70 6c65 780a  type == complex.
-000166e0: 2020 2020 2020 2020 7375 7065 7228 292e          super().
-000166f0: 5f5f 696e 6974 5f5f 2861 7267 290a 0a20  __init__(arg).. 
-00016700: 2020 2064 6566 2065 7661 6c66 2873 656c     def evalf(sel
-00016710: 662c 2061 7267 293a 0a20 2020 2020 2020  f, arg):.       
-00016720: 2072 6574 7572 6e20 6e75 6d70 792e 636f   return numpy.co
-00016730: 6e6a 7567 6174 6528 6172 6729 0a0a 2020  njugate(arg)..  
-00016740: 2020 6465 6620 5f73 696d 706c 6966 6965    def _simplifie
-00016750: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
-00016760: 2072 6574 7661 6c20 3d20 7365 6c66 2e61   retval = self.a
-00016770: 7267 735b 305d 2e5f 636f 6e6a 7567 6174  rgs[0]._conjugat
-00016780: 6528 290a 2020 2020 2020 2020 6966 2072  e().        if r
-00016790: 6574 7661 6c20 6973 206e 6f74 204e 6f6e  etval is not Non
-000167a0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-000167b0: 6574 7572 6e20 7265 7476 616c 0a20 2020  eturn retval.   
-000167c0: 2020 2020 2072 6574 7572 6e20 7375 7065       return supe
-000167d0: 7228 292e 5f73 696d 706c 6966 6965 6428  r()._simplified(
-000167e0: 290a 0a0a 636c 6173 7320 5265 616c 2850  )...class Real(P
-000167f0: 6f69 6e74 7769 7365 293a 0a20 2020 205f  ointwise):.    _
-00016800: 5f73 6c6f 7473 5f5f 203d 2028 290a 0a20  _slots__ = ().. 
-00016810: 2020 2040 7479 7065 732e 6170 706c 795f     @types.apply_
-00016820: 616e 6e6f 7461 7469 6f6e 730a 2020 2020  annotations.    
-00016830: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00016840: 662c 2061 7267 3a20 6173 6172 7261 7929  f, arg: asarray)
-00016850: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
-00016860: 2061 7267 2e64 7479 7065 203d 3d20 636f   arg.dtype == co
-00016870: 6d70 6c65 780a 2020 2020 2020 2020 7375  mplex.        su
-00016880: 7065 7228 292e 5f5f 696e 6974 5f5f 2861  per().__init__(a
-00016890: 7267 290a 0a20 2020 2064 6566 2065 7661  rg)..    def eva
-000168a0: 6c66 2873 656c 662c 2061 7267 293a 0a20  lf(self, arg):. 
-000168b0: 2020 2020 2020 2072 6574 7572 6e20 6e75         return nu
-000168c0: 6d70 792e 7265 616c 2861 7267 290a 0a20  mpy.real(arg).. 
-000168d0: 2020 2064 6566 205f 7369 6d70 6c69 6669     def _simplifi
-000168e0: 6564 2873 656c 6629 3a0a 2020 2020 2020  ed(self):.      
-000168f0: 2020 7265 7476 616c 203d 2073 656c 662e    retval = self.
-00016900: 6172 6773 5b30 5d2e 5f72 6561 6c28 290a  args[0]._real().
-00016910: 2020 2020 2020 2020 6966 2072 6574 7661          if retva
-00016920: 6c20 6973 206e 6f74 204e 6f6e 653a 0a20  l is not None:. 
-00016930: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00016940: 6e20 7265 7476 616c 0a20 2020 2020 2020  n retval.       
-00016950: 2072 6574 7572 6e20 7375 7065 7228 292e   return super().
-00016960: 5f73 696d 706c 6966 6965 6428 290a 0a0a  _simplified()...
-00016970: 636c 6173 7320 496d 6167 2850 6f69 6e74  class Imag(Point
-00016980: 7769 7365 293a 0a20 2020 205f 5f73 6c6f  wise):.    __slo
-00016990: 7473 5f5f 203d 2028 290a 0a20 2020 2040  ts__ = ()..    @
-000169a0: 7479 7065 732e 6170 706c 795f 616e 6e6f  types.apply_anno
-000169b0: 7461 7469 6f6e 730a 2020 2020 6465 6620  tations.    def 
-000169c0: 5f5f 696e 6974 5f5f 2873 656c 662c 2061  __init__(self, a
-000169d0: 7267 3a20 6173 6172 7261 7929 3a0a 2020  rg: asarray):.  
-000169e0: 2020 2020 2020 6173 7365 7274 2061 7267        assert arg
-000169f0: 2e64 7479 7065 203d 3d20 636f 6d70 6c65  .dtype == comple
-00016a00: 780a 2020 2020 2020 2020 7375 7065 7228  x.        super(
-00016a10: 292e 5f5f 696e 6974 5f5f 2861 7267 290a  ).__init__(arg).
-00016a20: 0a20 2020 2064 6566 2065 7661 6c66 2873  .    def evalf(s
-00016a30: 656c 662c 2061 7267 293a 0a20 2020 2020  elf, arg):.     
-00016a40: 2020 2072 6574 7572 6e20 6e75 6d70 792e     return numpy.
-00016a50: 696d 6167 2861 7267 290a 0a20 2020 2064  imag(arg)..    d
-00016a60: 6566 205f 7369 6d70 6c69 6669 6564 2873  ef _simplified(s
-00016a70: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-00016a80: 7476 616c 203d 2073 656c 662e 6172 6773  tval = self.args
-00016a90: 5b30 5d2e 5f69 6d61 6728 290a 2020 2020  [0]._imag().    
-00016aa0: 2020 2020 6966 2072 6574 7661 6c20 6973      if retval is
-00016ab0: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
-00016ac0: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
-00016ad0: 7476 616c 0a20 2020 2020 2020 2072 6574  tval.        ret
-00016ae0: 7572 6e20 7375 7065 7228 292e 5f73 696d  urn super()._sim
-00016af0: 706c 6966 6965 6428 290a 0a0a 636c 6173  plified()...clas
-00016b00: 7320 4361 7374 2850 6f69 6e74 7769 7365  s Cast(Pointwise
-00016b10: 293a 0a0a 2020 2020 4074 7970 6573 2e61  ):..    @types.a
-00016b20: 7070 6c79 5f61 6e6e 6f74 6174 696f 6e73  pply_annotations
-00016b30: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-00016b40: 5f28 7365 6c66 2c20 6172 673a 2061 7361  _(self, arg: asa
-00016b50: 7272 6179 293a 0a20 2020 2020 2020 2069  rray):.        i
-00016b60: 6620 6172 672e 6474 7970 6520 213d 2073  f arg.dtype != s
-00016b70: 656c 662e 6672 6f6d 5f74 7970 653a 0a20  elf.from_type:. 
-00016b80: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00016b90: 2054 7970 6545 7272 6f72 2827 4578 7065   TypeError('Expe
-00016ba0: 6374 6564 2061 6e20 6172 7261 7920 7769  cted an array wi
-00016bb0: 7468 2064 7479 7065 207b 7d20 6275 7420  th dtype {} but 
-00016bc0: 676f 7420 7b7d 2e27 2e66 6f72 6d61 7428  got {}.'.format(
-00016bd0: 7365 6c66 2e66 726f 6d5f 7479 7065 2e5f  self.from_type._
-00016be0: 5f6e 616d 655f 5f2c 2061 7267 2e64 7479  _name__, arg.dty
-00016bf0: 7065 2e5f 5f6e 616d 655f 5f29 290a 2020  pe.__name__)).  
-00016c00: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
-00016c10: 696e 6974 5f5f 2861 7267 290a 0a20 2020  init__(arg)..   
-00016c20: 2064 6566 2065 7661 6c66 2873 656c 662c   def evalf(self,
-00016c30: 2061 7267 293a 0a20 2020 2020 2020 2072   arg):.        r
-00016c40: 6574 7572 6e20 6e75 6d70 792e 6172 7261  eturn numpy.arra
-00016c50: 7928 6172 672c 2064 7479 7065 3d73 656c  y(arg, dtype=sel
-00016c60: 662e 746f 5f74 7970 6529 0a0a 2020 2020  f.to_type)..    
-00016c70: 6465 6620 5f73 696d 706c 6966 6965 6428  def _simplified(
-00016c80: 7365 6c66 293a 0a20 2020 2020 2020 2061  self):.        a
-00016c90: 7267 2c20 3d20 7365 6c66 2e61 7267 730a  rg, = self.args.
-00016ca0: 2020 2020 2020 2020 6966 2069 737a 6572          if iszer
-00016cb0: 6f28 6172 6729 3a0a 2020 2020 2020 2020  o(arg):.        
-00016cc0: 2020 2020 7265 7475 726e 207a 6572 6f73      return zeros
-00016cd0: 5f6c 696b 6528 7365 6c66 290a 2020 2020  _like(self).    
-00016ce0: 2020 2020 666f 7220 6178 6973 2c20 7061      for axis, pa
-00016cf0: 7274 7320 696e 2061 7267 2e5f 696e 666c  rts in arg._infl
-00016d00: 6174 696f 6e73 3a0a 2020 2020 2020 2020  ations:.        
-00016d10: 2020 2020 7265 7475 726e 2075 7469 6c2e      return util.
-00016d20: 7375 6d28 5f69 6e66 6c61 7465 2873 656c  sum(_inflate(sel
-00016d30: 662e 5f5f 636c 6173 735f 5f28 6675 6e63  f.__class__(func
-00016d40: 292c 2064 6f66 6d61 702c 2073 656c 662e  ), dofmap, self.
-00016d50: 7368 6170 655b 6178 6973 5d2c 2061 7869  shape[axis], axi
-00016d60: 7329 2066 6f72 2064 6f66 6d61 702c 2066  s) for dofmap, f
-00016d70: 756e 6320 696e 2070 6172 7473 2e69 7465  unc in parts.ite
-00016d80: 6d73 2829 290a 2020 2020 2020 2020 7265  ms()).        re
-00016d90: 7475 726e 2073 7570 6572 2829 2e5f 7369  turn super()._si
-00016da0: 6d70 6c69 6669 6564 2829 0a0a 2020 2020  mplified()..    
-00016db0: 6465 6620 5f69 6e74 626f 756e 6473 5f69  def _intbounds_i
-00016dc0: 6d70 6c28 7365 6c66 293a 0a20 2020 2020  mpl(self):.     
-00016dd0: 2020 2069 6620 7365 6c66 2e61 7267 735b     if self.args[
-00016de0: 305d 2e64 7479 7065 203d 3d20 626f 6f6c  0].dtype == bool
-00016df0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00016e00: 7475 726e 2030 2c20 310a 2020 2020 2020  turn 0, 1.      
-00016e10: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00016e20: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00016e30: 6172 6773 5b30 5d2e 5f69 6e74 626f 756e  args[0]._intboun
-00016e40: 6473 0a0a 2020 2020 4070 726f 7065 7274  ds..    @propert
-00016e50: 790a 2020 2020 6465 6620 5f63 6f6e 7374  y.    def _const
-00016e60: 5f75 6e69 666f 726d 2873 656c 6629 3a0a  _uniform(self):.
-00016e70: 2020 2020 2020 2020 7661 6c75 6520 3d20          value = 
-00016e80: 7365 6c66 2e61 7267 735b 305d 2e5f 636f  self.args[0]._co
-00016e90: 6e73 745f 756e 6966 6f72 6d0a 2020 2020  nst_uniform.    
-00016ea0: 2020 2020 6966 2076 616c 7565 2069 7320      if value is 
-00016eb0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-00016ec0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00016ed0: 662e 746f 5f74 7970 6528 7661 6c75 6529  f.to_type(value)
-00016ee0: 0a0a 0a63 6c61 7373 2042 6f6f 6c54 6f49  ...class BoolToI
-00016ef0: 6e74 2843 6173 7429 3a0a 2020 2020 6672  nt(Cast):.    fr
-00016f00: 6f6d 5f74 7970 6520 3d20 626f 6f6c 0a20  om_type = bool. 
-00016f10: 2020 2074 6f5f 7479 7065 203d 2069 6e74     to_type = int
-00016f20: 0a0a 0a63 6c61 7373 2049 6e74 546f 466c  ...class IntToFl
-00016f30: 6f61 7428 4361 7374 293a 0a20 2020 2066  oat(Cast):.    f
-00016f40: 726f 6d5f 7479 7065 203d 2069 6e74 0a20  rom_type = int. 
-00016f50: 2020 2074 6f5f 7479 7065 203d 2066 6c6f     to_type = flo
-00016f60: 6174 0a0a 2020 2020 6465 6620 5f61 6464  at..    def _add
-00016f70: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
-00016f80: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-00016f90: 616e 6365 286f 7468 6572 2c20 5f5f 636c  ance(other, __cl
-00016fa0: 6173 735f 5f29 3a0a 2020 2020 2020 2020  ass__):.        
-00016fb0: 2020 2020 7265 7475 726e 205f 5f63 6c61      return __cla
-00016fc0: 7373 5f5f 2873 656c 662e 6172 6773 5b30  ss__(self.args[0
-00016fd0: 5d20 2b20 6f74 6865 722e 6172 6773 5b30  ] + other.args[0
-00016fe0: 5d29 0a0a 2020 2020 6465 6620 5f6d 756c  ])..    def _mul
-00016ff0: 7469 706c 7928 7365 6c66 2c20 6f74 6865  tiply(self, othe
-00017000: 7229 3a0a 2020 2020 2020 2020 6966 2069  r):.        if i
-00017010: 7369 6e73 7461 6e63 6528 6f74 6865 722c  sinstance(other,
-00017020: 205f 5f63 6c61 7373 5f5f 293a 0a20 2020   __class__):.   
-00017030: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00017040: 5f5f 636c 6173 735f 5f28 7365 6c66 2e61  __class__(self.a
-00017050: 7267 735b 305d 202a 206f 7468 6572 2e61  rgs[0] * other.a
-00017060: 7267 735b 305d 290a 0a20 2020 2064 6566  rgs[0])..    def
-00017070: 205f 7375 6d28 7365 6c66 2c20 6178 6973   _sum(self, axis
-00017080: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-00017090: 6e20 5f5f 636c 6173 735f 5f28 7375 6d28  n __class__(sum(
-000170a0: 7365 6c66 2e61 7267 735b 305d 2c20 6178  self.args[0], ax
-000170b0: 6973 2929 0a0a 2020 2020 6465 6620 5f70  is))..    def _p
-000170c0: 726f 6475 6374 2873 656c 6629 3a0a 2020  roduct(self):.  
-000170d0: 2020 2020 2020 7265 7475 726e 205f 5f63        return __c
-000170e0: 6c61 7373 5f5f 2870 726f 6475 6374 2873  lass__(product(s
-000170f0: 656c 662e 6172 6773 5b30 5d2c 202d 3129  elf.args[0], -1)
-00017100: 290a 0a20 2020 2064 6566 205f 7369 676e  )..    def _sign
-00017110: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00017120: 6173 7365 7274 2073 656c 662e 6474 7970  assert self.dtyp
-00017130: 6520 213d 2063 6f6d 706c 6578 0a20 2020  e != complex.   
-00017140: 2020 2020 2072 6574 7572 6e20 5f5f 636c       return __cl
-00017150: 6173 735f 5f28 7369 676e 2873 656c 662e  ass__(sign(self.
-00017160: 6172 6773 5b30 5d29 290a 0a20 2020 2064  args[0]))..    d
-00017170: 6566 205f 6465 7269 7661 7469 7665 2873  ef _derivative(s
-00017180: 656c 662c 2076 6172 2c20 7365 656e 293a  elf, var, seen):
-00017190: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000171a0: 5a65 726f 7328 7365 6c66 2e73 6861 7065  Zeros(self.shape
-000171b0: 202b 2076 6172 2e73 6861 7065 2c20 6474   + var.shape, dt
-000171c0: 7970 653d 7365 6c66 2e64 7479 7065 290a  ype=self.dtype).
-000171d0: 0a0a 636c 6173 7320 466c 6f61 7454 6f43  ..class FloatToC
-000171e0: 6f6d 706c 6578 2843 6173 7429 3a0a 2020  omplex(Cast):.  
-000171f0: 2020 6672 6f6d 5f74 7970 6520 3d20 666c    from_type = fl
-00017200: 6f61 740a 2020 2020 746f 5f74 7970 6520  oat.    to_type 
-00017210: 3d20 636f 6d70 6c65 780a 0a20 2020 2064  = complex..    d
-00017220: 6566 205f 6164 6428 7365 6c66 2c20 6f74  ef _add(self, ot
-00017230: 6865 7229 3a0a 2020 2020 2020 2020 6966  her):.        if
-00017240: 2069 7369 6e73 7461 6e63 6528 6f74 6865   isinstance(othe
-00017250: 722c 205f 5f63 6c61 7373 5f5f 293a 0a20  r, __class__):. 
-00017260: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00017270: 6e20 5f5f 636c 6173 735f 5f28 7365 6c66  n __class__(self
-00017280: 2e61 7267 735b 305d 202b 206f 7468 6572  .args[0] + other
-00017290: 2e61 7267 735b 305d 290a 0a20 2020 2064  .args[0])..    d
-000172a0: 6566 205f 6d75 6c74 6970 6c79 2873 656c  ef _multiply(sel
-000172b0: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
-000172c0: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-000172d0: 286f 7468 6572 2c20 5f5f 636c 6173 735f  (other, __class_
-000172e0: 5f29 3a0a 2020 2020 2020 2020 2020 2020  _):.            
-000172f0: 7265 7475 726e 205f 5f63 6c61 7373 5f5f  return __class__
-00017300: 2873 656c 662e 6172 6773 5b30 5d20 2a20  (self.args[0] * 
-00017310: 6f74 6865 722e 6172 6773 5b30 5d29 0a0a  other.args[0])..
-00017320: 2020 2020 6465 6620 5f73 756d 2873 656c      def _sum(sel
-00017330: 662c 2061 7869 7329 3a0a 2020 2020 2020  f, axis):.      
-00017340: 2020 7265 7475 726e 205f 5f63 6c61 7373    return __class
-00017350: 5f5f 2873 756d 2873 656c 662e 6172 6773  __(sum(self.args
-00017360: 5b30 5d2c 2061 7869 7329 290a 0a20 2020  [0], axis))..   
-00017370: 2064 6566 205f 7072 6f64 7563 7428 7365   def _product(se
-00017380: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-00017390: 7572 6e20 5f5f 636c 6173 735f 5f28 7072  urn __class__(pr
-000173a0: 6f64 7563 7428 7365 6c66 2e61 7267 735b  oduct(self.args[
-000173b0: 305d 2c20 2d31 2929 0a0a 2020 2020 6465  0], -1))..    de
-000173c0: 6620 5f72 6561 6c28 7365 6c66 293a 0a20  f _real(self):. 
-000173d0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-000173e0: 6c66 2e61 7267 735b 305d 0a0a 2020 2020  lf.args[0]..    
-000173f0: 6465 6620 5f69 6d61 6728 7365 6c66 293a  def _imag(self):
-00017400: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00017410: 7a65 726f 735f 6c69 6b65 2873 656c 662e  zeros_like(self.
-00017420: 6172 6773 5b30 5d29 0a0a 2020 2020 6465  args[0])..    de
-00017430: 6620 5f63 6f6e 6a75 6761 7465 2873 656c  f _conjugate(sel
-00017440: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
-00017450: 726e 2073 656c 660a 0a20 2020 2064 6566  rn self..    def
-00017460: 205f 6465 7269 7661 7469 7665 2873 656c   _derivative(sel
-00017470: 662c 2076 6172 2c20 7365 656e 293a 0a20  f, var, seen):. 
-00017480: 2020 2020 2020 2069 6620 7661 722e 6474         if var.dt
-00017490: 7970 6520 3d3d 2063 6f6d 706c 6578 3a0a  ype == complex:.
-000174a0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-000174b0: 6520 5661 6c75 6545 7272 6f72 2827 5468  e ValueError('Th
-000174c0: 6520 636f 6d70 6c65 7820 6465 7269 7661  e complex deriva
-000174d0: 7469 7665 2064 6f65 7320 6e6f 7420 6578  tive does not ex
-000174e0: 6973 742e 2729 0a20 2020 2020 2020 2061  ist.').        a
-000174f0: 7267 2c20 3d20 7365 6c66 2e61 7267 730a  rg, = self.args.
-00017500: 2020 2020 2020 2020 7265 7475 726e 2046          return F
-00017510: 6c6f 6174 546f 436f 6d70 6c65 7828 6465  loatToComplex(de
-00017520: 7269 7661 7469 7665 2861 7267 2c20 7661  rivative(arg, va
-00017530: 722c 2073 6565 6e29 290a 0a0a 6465 6620  r, seen))...def 
-00017540: 6173 7479 7065 2861 7267 2c20 6474 7970  astype(arg, dtyp
-00017550: 6529 3a0a 2020 2020 6172 6720 3d20 6173  e):.    arg = as
-00017560: 6172 7261 7928 6172 6729 0a20 2020 2069  array(arg).    i
-00017570: 203d 205f 7479 7065 5f6f 7264 6572 2e69   = _type_order.i
-00017580: 6e64 6578 2861 7267 2e64 7479 7065 290a  ndex(arg.dtype).
-00017590: 2020 2020 6a20 3d20 5f74 7970 655f 6f72      j = _type_or
-000175a0: 6465 722e 696e 6465 7828 6474 7970 6529  der.index(dtype)
-000175b0: 0a20 2020 2069 6620 6920 3e20 6a3a 0a20  .    if i > j:. 
-000175c0: 2020 2020 2020 2072 6169 7365 2054 7970         raise Typ
-000175d0: 6545 7272 6f72 2827 446f 776e 6361 7374  eError('Downcast
-000175e0: 696e 6720 6973 2066 6f72 6269 6464 656e  ing is forbidden
-000175f0: 2e27 290a 2020 2020 666f 7220 6361 7374  .').    for cast
-00017600: 2069 6e20 2842 6f6f 6c54 6f49 6e74 2c20   in (BoolToInt, 
-00017610: 496e 7454 6f46 6c6f 6174 2c20 466c 6f61  IntToFloat, Floa
-00017620: 7454 6f43 6f6d 706c 6578 295b 693a 6a5d  tToComplex)[i:j]
-00017630: 3a0a 2020 2020 2020 2020 6172 6720 3d20  :.        arg = 
-00017640: 6361 7374 2861 7267 290a 2020 2020 7265  cast(arg).    re
-00017650: 7475 726e 2061 7267 0a0a 0a63 6c61 7373  turn arg...class
-00017660: 2053 6967 6e28 4172 7261 7929 3a0a 0a20   Sign(Array):.. 
-00017670: 2020 205f 5f73 6c6f 7473 5f5f 203d 2027     __slots__ = '
-00017680: 6675 6e63 272c 0a0a 2020 2020 4074 7970  func',..    @typ
-00017690: 6573 2e61 7070 6c79 5f61 6e6e 6f74 6174  es.apply_annotat
-000176a0: 696f 6e73 0a20 2020 2064 6566 205f 5f69  ions.    def __i
-000176b0: 6e69 745f 5f28 7365 6c66 2c20 6675 6e63  nit__(self, func
-000176c0: 3a20 6173 6172 7261 7929 3a0a 2020 2020  : asarray):.    
-000176d0: 2020 2020 6173 7365 7274 2066 756e 632e      assert func.
-000176e0: 6474 7970 6520 213d 2063 6f6d 706c 6578  dtype != complex
-000176f0: 0a20 2020 2020 2020 2073 656c 662e 6675  .        self.fu
-00017700: 6e63 203d 2066 756e 630a 2020 2020 2020  nc = func.      
-00017710: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-00017720: 5f5f 2861 7267 733d 5b66 756e 635d 2c20  __(args=[func], 
-00017730: 7368 6170 653d 6675 6e63 2e73 6861 7065  shape=func.shape
-00017740: 2c20 6474 7970 653d 6675 6e63 2e64 7479  , dtype=func.dty
-00017750: 7065 290a 0a20 2020 2064 6566 205f 7369  pe)..    def _si
-00017760: 6d70 6c69 6669 6564 2873 656c 6629 3a0a  mplified(self):.
-00017770: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00017780: 656c 662e 6675 6e63 2e5f 7369 676e 2829  elf.func._sign()
-00017790: 0a0a 2020 2020 6465 6620 6576 616c 6628  ..    def evalf(
-000177a0: 7365 6c66 2c20 6172 7229 3a0a 2020 2020  self, arr):.    
-000177b0: 2020 2020 7265 7475 726e 206e 756d 7079      return numpy
-000177c0: 2e73 6967 6e28 6172 7229 0a0a 2020 2020  .sign(arr)..    
-000177d0: 6465 6620 5f74 616b 6564 6961 6728 7365  def _takediag(se
-000177e0: 6c66 2c20 6178 6973 312c 2061 7869 7332  lf, axis1, axis2
-000177f0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-00017800: 6e20 5369 676e 285f 7461 6b65 6469 6167  n Sign(_takediag
-00017810: 2873 656c 662e 6675 6e63 2c20 6178 6973  (self.func, axis
-00017820: 312c 2061 7869 7332 2929 0a0a 2020 2020  1, axis2))..    
-00017830: 6465 6620 5f74 616b 6528 7365 6c66 2c20  def _take(self, 
-00017840: 696e 6465 782c 2061 7869 7329 3a0a 2020  index, axis):.  
-00017850: 2020 2020 2020 7265 7475 726e 2053 6967        return Sig
-00017860: 6e28 5f74 616b 6528 7365 6c66 2e66 756e  n(_take(self.fun
-00017870: 632c 2069 6e64 6578 2c20 6178 6973 2929  c, index, axis))
-00017880: 0a0a 2020 2020 6465 6620 5f73 6967 6e28  ..    def _sign(
-00017890: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-000178a0: 6574 7572 6e20 7365 6c66 0a0a 2020 2020  eturn self..    
-000178b0: 6465 6620 5f75 6e72 6176 656c 2873 656c  def _unravel(sel
-000178c0: 662c 2061 7869 732c 2073 6861 7065 293a  f, axis, shape):
-000178d0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000178e0: 5369 676e 2875 6e72 6176 656c 2873 656c  Sign(unravel(sel
-000178f0: 662e 6675 6e63 2c20 6178 6973 2c20 7368  f.func, axis, sh
-00017900: 6170 6529 290a 0a20 2020 2064 6566 205f  ape))..    def _
-00017910: 6465 7269 7661 7469 7665 2873 656c 662c  derivative(self,
-00017920: 2076 6172 2c20 7365 656e 293a 0a20 2020   var, seen):.   
-00017930: 2020 2020 2072 6574 7572 6e20 5a65 726f       return Zero
-00017940: 7328 7365 6c66 2e73 6861 7065 202b 2076  s(self.shape + v
-00017950: 6172 2e73 6861 7065 2c20 6474 7970 653d  ar.shape, dtype=
-00017960: 7365 6c66 2e64 7479 7065 290a 0a20 2020  self.dtype)..   
-00017970: 2064 6566 205f 696e 7462 6f75 6e64 735f   def _intbounds_
-00017980: 696d 706c 2873 656c 6629 3a0a 2020 2020  impl(self):.    
-00017990: 2020 2020 6c6f 7765 722c 2075 7070 6572      lower, upper
-000179a0: 203d 2073 656c 662e 6675 6e63 2e5f 696e   = self.func._in
-000179b0: 7462 6f75 6e64 730a 2020 2020 2020 2020  tbounds.        
-000179c0: 7265 7475 726e 2069 6e74 286e 756d 7079  return int(numpy
-000179d0: 2e73 6967 6e28 6c6f 7765 7229 292c 2069  .sign(lower)), i
-000179e0: 6e74 286e 756d 7079 2e73 6967 6e28 7570  nt(numpy.sign(up
-000179f0: 7065 7229 290a 0a0a 636c 6173 7320 5361  per))...class Sa
-00017a00: 6d70 6c65 6428 4172 7261 7929 3a0a 2020  mpled(Array):.  
-00017a10: 2020 2727 2742 6173 6973 2d6c 696b 6520    '''Basis-like 
-00017a20: 6964 656e 7469 7479 206f 7065 7261 746f  identity operato
-00017a30: 722e 0a0a 2020 2020 4261 7369 732d 6c69  r...    Basis-li
-00017a40: 6b65 2066 756e 6374 696f 6e20 7468 6174  ke function that
-00017a50: 2066 6f72 2065 7665 7279 2070 6f69 6e74   for every point
-00017a60: 2069 6e20 6120 7072 6564 6566 696e 6564   in a predefined
-00017a70: 2073 6574 2065 7661 6c75 6174 6573 2074   set evaluates t
-00017a80: 6f20 7468 650a 2020 2020 756e 6974 2076  o the.    unit v
-00017a90: 6563 746f 7220 636f 7272 6573 706f 6e64  ector correspond
-00017aa0: 696e 6720 746f 2069 7473 2069 6e64 6578  ing to its index
-00017ab0: 2e0a 0a20 2020 2041 7267 730a 2020 2020  ...    Args.    
-00017ac0: 2d2d 2d2d 0a20 2020 2070 6f69 6e74 7320  ----.    points 
-00017ad0: 3a20 3164 203a 636c 6173 733a 6041 7272  : 1d :class:`Arr
-00017ae0: 6179 600a 2020 2020 2020 2020 5072 6573  ay`.        Pres
-00017af0: 656e 7420 706f 696e 7420 636f 6f72 6469  ent point coordi
-00017b00: 6e61 7465 732e 0a20 2020 2065 7870 6563  nates..    expec
-00017b10: 7420 3a20 3264 203a 636c 6173 733a 6041  t : 2d :class:`A
-00017b20: 7272 6179 600a 2020 2020 2020 2020 456c  rray`.        El
-00017b30: 656d 656e 7477 6973 6520 636f 6e73 7461  ementwise consta
-00017b40: 6e74 2074 6861 7420 6576 616c 7561 7465  nt that evaluate
-00017b50: 7320 746f 2074 6865 2070 7265 6465 6669  s to the predefi
-00017b60: 6e65 6420 706f 696e 7420 636f 6f72 6469  ned point coordi
-00017b70: 6e61 7465 733b 0a20 2020 2020 2020 2075  nates;.        u
-00017b80: 7365 6420 666f 7220 6572 726f 7220 6368  sed for error ch
-00017b90: 6563 6b69 6e67 2061 6e64 2074 6f20 696e  ecking and to in
-00017ba0: 6865 7269 7420 7468 6520 7368 6170 652e  herit the shape.
-00017bb0: 0a20 2020 2027 2727 0a0a 2020 2020 5f5f  .    '''..    __
-00017bc0: 736c 6f74 735f 5f20 3d20 2829 0a0a 2020  slots__ = ()..  
-00017bd0: 2020 4074 7970 6573 2e61 7070 6c79 5f61    @types.apply_a
-00017be0: 6e6e 6f74 6174 696f 6e73 0a20 2020 2064  nnotations.    d
-00017bf0: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
-00017c00: 2c20 706f 696e 7473 3a20 6173 6172 7261  , points: asarra
-00017c10: 792c 2065 7870 6563 743a 2061 7361 7272  y, expect: asarr
-00017c20: 6179 293a 0a20 2020 2020 2020 2061 7373  ay):.        ass
-00017c30: 6572 7420 706f 696e 7473 2e6e 6469 6d20  ert points.ndim 
-00017c40: 3d3d 2032 0a20 2020 2020 2020 2073 7570  == 2.        sup
-00017c50: 6572 2829 2e5f 5f69 6e69 745f 5f28 6172  er().__init__(ar
-00017c60: 6773 3d5b 706f 696e 7473 2c20 6578 7065  gs=[points, expe
-00017c70: 6374 5d2c 2073 6861 7065 3d28 706f 696e  ct], shape=(poin
-00017c80: 7473 2e73 6861 7065 5b30 5d2c 2065 7870  ts.shape[0], exp
-00017c90: 6563 742e 7368 6170 655b 305d 292c 2064  ect.shape[0]), d
-00017ca0: 7479 7065 3d66 6c6f 6174 290a 0a20 2020  type=float)..   
-00017cb0: 2064 6566 2065 7661 6c66 2873 656c 662c   def evalf(self,
-00017cc0: 2070 6f69 6e74 732c 2065 7870 6563 7429   points, expect)
-00017cd0: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
-00017ce0: 206e 756d 7079 2e65 7175 616c 2870 6f69   numpy.equal(poi
-00017cf0: 6e74 732c 2065 7870 6563 7429 2e61 6c6c  nts, expect).all
-00017d00: 2829 2c20 2769 6c6c 6567 616c 2070 6f69  (), 'illegal poi
-00017d10: 6e74 2073 6574 270a 2020 2020 2020 2020  nt set'.        
-00017d20: 7265 7475 726e 206e 756d 7079 2e65 7965  return numpy.eye
-00017d30: 286c 656e 2870 6f69 6e74 7329 290a 0a0a  (len(points))...
-00017d40: 4074 7970 6573 2e61 7070 6c79 5f61 6e6e  @types.apply_ann
-00017d50: 6f74 6174 696f 6e73 0a64 6566 2045 6c65  otations.def Ele
-00017d60: 6d77 6973 6528 6461 7461 3a20 7479 7065  mwise(data: type
-00017d70: 732e 7475 706c 655b 7479 7065 732e 6172  s.tuple[types.ar
-00017d80: 7261 7964 6174 615d 2c20 696e 6465 783a  raydata], index:
-00017d90: 2061 7361 7272 6179 2c20 6474 7970 653a   asarray, dtype:
-00017da0: 2061 7364 7479 7065 293a 0a20 2020 2075   asdtype):.    u
-00017db0: 6e69 7175 652c 2069 6e64 6963 6573 203d  nique, indices =
-00017dc0: 2075 7469 6c2e 756e 6971 7565 2864 6174   util.unique(dat
-00017dd0: 6129 0a20 2020 2069 6620 6c65 6e28 756e  a).    if len(un
-00017de0: 6971 7565 2920 3d3d 2031 3a0a 2020 2020  ique) == 1:.    
-00017df0: 2020 2020 7265 7475 726e 2043 6f6e 7374      return Const
-00017e00: 616e 7428 756e 6971 7565 5b30 5d29 0a20  ant(unique[0]). 
-00017e10: 2020 2023 2043 7265 6174 6520 7368 6170     # Create shap
-00017e20: 6520 6672 6f6d 2064 6174 6120 616e 6420  e from data and 
-00017e30: 696e 6465 782c 2072 6174 6865 7220 7468  index, rather th
-00017e40: 616e 2075 6e69 7175 6520 616e 6420 7468  an unique and th
-00017e50: 6520 6d6f 6469 6669 6564 0a20 2020 2023  e modified.    #
-00017e60: 2069 6e64 6578 2c20 696e 206f 7264 6572   index, in order
-00017e70: 2074 6f20 6176 6f69 6420 706f 7465 6e74   to avoid potent
-00017e80: 6961 6c20 7368 6170 6520 696e 636f 6e73  ial shape incons
-00017e90: 6973 7465 6e63 6965 7320 6c61 7465 7220  istencies later 
-00017ea0: 6f6e 2e0a 2020 2020 7368 6170 6573 203d  on..    shapes =
-00017eb0: 206e 756d 7079 2e61 7272 6179 285b 642e   numpy.array([d.
-00017ec0: 7368 6170 6520 666f 7220 6420 696e 2064  shape for d in d
-00017ed0: 6174 615d 290a 2020 2020 7368 6170 6520  ata]).    shape 
-00017ee0: 3d20 5b54 616b 6528 732c 2069 6e64 6578  = [Take(s, index
-00017ef0: 2920 666f 7220 7320 696e 2073 6861 7065  ) for s in shape
-00017f00: 732e 545d 0a20 2020 2069 6620 6c65 6e28  s.T].    if len(
-00017f10: 756e 6971 7565 2920 3c20 6c65 6e28 6461  unique) < len(da
-00017f20: 7461 293a 0a20 2020 2020 2020 2069 6e64  ta):.        ind
-00017f30: 6578 203d 2054 616b 6528 696e 6469 6365  ex = Take(indice
-00017f40: 732c 2069 6e64 6578 290a 2020 2020 2320  s, index).    # 
-00017f50: 4d6f 7665 2061 6c6c 2061 7865 7320 7769  Move all axes wi
-00017f60: 7468 2063 6f6e 7374 616e 7420 7368 6170  th constant shap
-00017f70: 6520 746f 2074 6865 206c 6566 7420 616e  e to the left an
-00017f80: 6420 7261 7665 6c20 7468 6520 7265 6d61  d ravel the rema
-00017f90: 696e 6465 722e 0a20 2020 2069 735f 636f  inder..    is_co
-00017fa0: 6e73 7461 6e74 203d 206e 756d 7079 2e61  nstant = numpy.a
-00017fb0: 6c6c 2873 6861 7065 735b 313a 5d20 3d3d  ll(shapes[1:] ==
-00017fc0: 2073 6861 7065 735b 305d 2c20 6178 6973   shapes[0], axis
-00017fd0: 3d30 290a 2020 2020 6e63 6f6e 7374 616e  =0).    nconstan
-00017fe0: 7420 3d20 6973 5f63 6f6e 7374 616e 742e  t = is_constant.
-00017ff0: 7375 6d28 290a 2020 2020 7265 6f72 6465  sum().    reorde
-00018000: 7220 3d20 6e75 6d70 792e 6172 6773 6f72  r = numpy.argsor
-00018010: 7428 7e69 735f 636f 6e73 7461 6e74 290a  t(~is_constant).
-00018020: 2020 2020 7261 7665 6c65 6420 3d20 5b6e      raveled = [n
-00018030: 756d 7079 2e74 7261 6e73 706f 7365 2864  umpy.transpose(d
-00018040: 2c20 7265 6f72 6465 7229 2e72 6573 6861  , reorder).resha
-00018050: 7065 282a 7368 6170 6573 5b30 2c20 7265  pe(*shapes[0, re
-00018060: 6f72 6465 725b 3a6e 636f 6e73 7461 6e74  order[:nconstant
-00018070: 5d5d 2c20 2d31 2920 666f 7220 6420 696e  ]], -1) for d in
-00018080: 2075 6e69 7175 655d 0a20 2020 2023 2043   unique].    # C
-00018090: 6f6e 6361 7465 6e61 7465 2074 6865 2072  oncatenate the r
-000180a0: 6176 656c 6564 2061 7869 732c 2074 616b  aveled axis, tak
-000180b0: 6520 736c 6963 6573 2c20 756e 7261 7665  e slices, unrave
-000180c0: 6c20 616e 6420 7265 6f72 6465 7220 7468  l and reorder th
-000180d0: 6520 6178 6573 2074 6f0a 2020 2020 2320  e axes to.    # 
-000180e0: 7468 6520 6f72 6967 696e 616c 2070 6f73  the original pos
-000180f0: 6974 696f 6e2e 0a20 2020 2063 6f6e 6361  ition..    conca
-00018100: 7420 3d20 6e75 6d70 792e 636f 6e63 6174  t = numpy.concat
-00018110: 656e 6174 6528 7261 7665 6c65 642c 2061  enate(raveled, a
-00018120: 7869 733d 2d31 290a 2020 2020 6966 2069  xis=-1).    if i
-00018130: 735f 636f 6e73 7461 6e74 2e61 6c6c 2829  s_constant.all()
-00018140: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00018150: 2054 616b 6528 636f 6e63 6174 2c20 696e   Take(concat, in
-00018160: 6465 7829 0a20 2020 2076 6172 5f73 6861  dex).    var_sha
-00018170: 7065 203d 2074 7570 6c65 2873 6861 7065  pe = tuple(shape
-00018180: 5b69 5d20 666f 7220 6920 696e 2072 656f  [i] for i in reo
-00018190: 7264 6572 5b6e 636f 6e73 7461 6e74 3a5d  rder[nconstant:]
-000181a0: 290a 2020 2020 6375 6d70 726f 6420 3d20  ).    cumprod = 
-000181b0: 6c69 7374 2876 6172 5f73 6861 7065 290a  list(var_shape).
-000181c0: 2020 2020 666f 7220 6920 696e 2072 6576      for i in rev
-000181d0: 6572 7365 6428 7261 6e67 6528 6c65 6e28  ersed(range(len(
-000181e0: 7661 725f 7368 6170 6529 2d31 2929 3a0a  var_shape)-1)):.
-000181f0: 2020 2020 2020 2020 6375 6d70 726f 645b          cumprod[
-00018200: 695d 202a 3d20 6375 6d70 726f 645b 692b  i] *= cumprod[i+
-00018210: 315d 2020 2320 776f 726b 2062 6163 6b77  1]  # work backw
-00018220: 6172 6473 2073 6f20 7468 6174 2074 6865  ards so that the
-00018230: 2073 6861 7065 2063 6865 636b 206d 6174   shape check mat
-00018240: 6368 6573 2069 6e20 556e 7261 7665 6c0a  ches in Unravel.
-00018250: 2020 2020 6f66 6673 6574 7320 3d20 5f53      offsets = _S
-00018260: 697a 6573 546f 4f66 6673 6574 7328 6173  izesToOffsets(as
-00018270: 6172 7261 7928 5b64 2e73 6861 7065 5b2d  array([d.shape[-
-00018280: 315d 2066 6f72 2064 2069 6e20 7261 7665  1] for d in rave
-00018290: 6c65 645d 2929 0a20 2020 2065 6c65 6d77  led])).    elemw
-000182a0: 6973 6520 3d20 5461 6b65 2863 6f6e 6361  ise = Take(conca
-000182b0: 742c 2052 616e 6765 2863 756d 7072 6f64  t, Range(cumprod
-000182c0: 5b30 5d29 202b 2054 616b 6528 6f66 6673  [0]) + Take(offs
-000182d0: 6574 732c 2069 6e64 6578 2929 0a20 2020  ets, index)).   
-000182e0: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
-000182f0: 6c65 6e28 7661 725f 7368 6170 6529 2d31  len(var_shape)-1
-00018300: 293a 0a20 2020 2020 2020 2065 6c65 6d77  ):.        elemw
-00018310: 6973 6520 3d20 556e 7261 7665 6c28 656c  ise = Unravel(el
-00018320: 656d 7769 7365 2c20 7661 725f 7368 6170  emwise, var_shap
-00018330: 655b 695d 2c20 6375 6d70 726f 645b 692b  e[i], cumprod[i+
-00018340: 315d 290a 2020 2020 7265 7475 726e 2054  1]).    return T
-00018350: 7261 6e73 706f 7365 2865 6c65 6d77 6973  ranspose(elemwis
-00018360: 652c 2074 7570 6c65 286e 756d 7079 2e61  e, tuple(numpy.a
-00018370: 7267 736f 7274 2872 656f 7264 6572 2929  rgsort(reorder))
-00018380: 290a 0a0a 636c 6173 7320 4569 6728 4576  )...class Eig(Ev
-00018390: 616c 7561 626c 6529 3a0a 0a20 2020 205f  aluable):..    _
-000183a0: 5f73 6c6f 7473 5f5f 203d 2027 7379 6d6d  _slots__ = 'symm
-000183b0: 6574 7269 6327 2c20 2766 756e 6327 2c20  etric', 'func', 
-000183c0: 275f 775f 6474 7970 6527 2c20 275f 7674  '_w_dtype', '_vt
-000183d0: 5f64 7479 7065 270a 0a20 2020 2040 7479  _dtype'..    @ty
-000183e0: 7065 732e 6170 706c 795f 616e 6e6f 7461  pes.apply_annota
-000183f0: 7469 6f6e 730a 2020 2020 6465 6620 5f5f  tions.    def __
-00018400: 696e 6974 5f5f 2873 656c 662c 2066 756e  init__(self, fun
-00018410: 633a 2061 7361 7272 6179 2c20 7379 6d6d  c: asarray, symm
-00018420: 6574 7269 633a 2062 6f6f 6c20 3d20 4661  etric: bool = Fa
-00018430: 6c73 6529 3a0a 2020 2020 2020 2020 6173  lse):.        as
-00018440: 7365 7274 2066 756e 632e 6e64 696d 203e  sert func.ndim >
-00018450: 3d20 3220 616e 6420 6571 7561 6c69 6e64  = 2 and equalind
-00018460: 6578 2866 756e 632e 7368 6170 655b 2d31  ex(func.shape[-1
-00018470: 5d2c 2066 756e 632e 7368 6170 655b 2d32  ], func.shape[-2
-00018480: 5d29 0a20 2020 2020 2020 2073 656c 662e  ]).        self.
-00018490: 7379 6d6d 6574 7269 6320 3d20 7379 6d6d  symmetric = symm
-000184a0: 6574 7269 630a 2020 2020 2020 2020 7365  etric.        se
-000184b0: 6c66 2e66 756e 6320 3d20 6675 6e63 0a20  lf.func = func. 
-000184c0: 2020 2020 2020 2073 656c 662e 5f77 5f64         self._w_d
-000184d0: 7479 7065 203d 2066 6c6f 6174 2069 6620  type = float if 
-000184e0: 7379 6d6d 6574 7269 6320 656c 7365 2063  symmetric else c
-000184f0: 6f6d 706c 6578 0a20 2020 2020 2020 2073  omplex.        s
-00018500: 656c 662e 5f76 745f 6474 7970 6520 3d20  elf._vt_dtype = 
-00018510: 666c 6f61 7420 6966 2073 796d 6d65 7472  float if symmetr
-00018520: 6963 2061 6e64 2066 756e 632e 6474 7970  ic and func.dtyp
-00018530: 6520 213d 2063 6f6d 706c 6578 2065 6c73  e != complex els
-00018540: 6520 636f 6d70 6c65 780a 2020 2020 2020  e complex.      
-00018550: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-00018560: 5f5f 2861 7267 733d 5b66 756e 635d 290a  __(args=[func]).
-00018570: 0a20 2020 2064 6566 205f 5f6c 656e 5f5f  .    def __len__
-00018580: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00018590: 7265 7475 726e 2032 0a0a 2020 2020 6465  return 2..    de
-000185a0: 6620 5f5f 6974 6572 5f5f 2873 656c 6629  f __iter__(self)
-000185b0: 3a0a 2020 2020 2020 2020 7969 656c 6420  :.        yield 
-000185c0: 4172 7261 7946 726f 6d54 7570 6c65 2873  ArrayFromTuple(s
-000185d0: 656c 662c 2069 6e64 6578 3d30 2c20 7368  elf, index=0, sh
-000185e0: 6170 653d 7365 6c66 2e66 756e 632e 7368  ape=self.func.sh
-000185f0: 6170 655b 3a2d 315d 2c20 6474 7970 653d  ape[:-1], dtype=
-00018600: 7365 6c66 2e5f 775f 6474 7970 6529 0a20  self._w_dtype). 
-00018610: 2020 2020 2020 2079 6965 6c64 2041 7272         yield Arr
-00018620: 6179 4672 6f6d 5475 706c 6528 7365 6c66  ayFromTuple(self
-00018630: 2c20 696e 6465 783d 312c 2073 6861 7065  , index=1, shape
-00018640: 3d73 656c 662e 6675 6e63 2e73 6861 7065  =self.func.shape
-00018650: 2c20 6474 7970 653d 7365 6c66 2e5f 7674  , dtype=self._vt
-00018660: 5f64 7479 7065 290a 0a20 2020 2064 6566  _dtype)..    def
-00018670: 205f 7369 6d70 6c69 6669 6564 2873 656c   _simplified(sel
-00018680: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
-00018690: 726e 2073 656c 662e 6675 6e63 2e5f 6569  rn self.func._ei
-000186a0: 6728 7365 6c66 2e73 796d 6d65 7472 6963  g(self.symmetric
-000186b0: 290a 0a20 2020 2064 6566 2065 7661 6c66  )..    def evalf
-000186c0: 2873 656c 662c 2061 7272 293a 0a20 2020  (self, arr):.   
-000186d0: 2020 2020 2077 2c20 7674 203d 2028 6e75       w, vt = (nu
-000186e0: 6d70 792e 6c69 6e61 6c67 2e65 6967 6820  mpy.linalg.eigh 
-000186f0: 6966 2073 656c 662e 7379 6d6d 6574 7269  if self.symmetri
-00018700: 6320 656c 7365 206e 756d 7079 2e6c 696e  c else numpy.lin
-00018710: 616c 672e 6569 6729 2861 7272 290a 2020  alg.eig)(arr).  
-00018720: 2020 2020 2020 7720 3d20 772e 6173 7479        w = w.asty
-00018730: 7065 2873 656c 662e 5f77 5f64 7479 7065  pe(self._w_dtype
-00018740: 2c20 636f 7079 3d46 616c 7365 290a 2020  , copy=False).  
-00018750: 2020 2020 2020 7674 203d 2076 742e 6173        vt = vt.as
-00018760: 7479 7065 2873 656c 662e 5f76 745f 6474  type(self._vt_dt
-00018770: 7970 652c 2063 6f70 793d 4661 6c73 6529  ype, copy=False)
-00018780: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00018790: 2877 2c20 7674 290a 0a0a 636c 6173 7320  (w, vt)...class 
-000187a0: 4172 7261 7946 726f 6d54 7570 6c65 2841  ArrayFromTuple(A
-000187b0: 7272 6179 293a 0a0a 2020 2020 5f5f 736c  rray):..    __sl
-000187c0: 6f74 735f 5f20 3d20 2761 7272 6179 7327  ots__ = 'arrays'
-000187d0: 2c20 2769 6e64 6578 272c 2027 5f6c 6f77  , 'index', '_low
-000187e0: 6572 272c 2027 5f75 7070 6572 270a 0a20  er', '_upper'.. 
-000187f0: 2020 2040 7479 7065 732e 6170 706c 795f     @types.apply_
-00018800: 616e 6e6f 7461 7469 6f6e 730a 2020 2020  annotations.    
-00018810: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00018820: 662c 2061 7272 6179 733a 2073 7472 6963  f, arrays: stric
-00018830: 7465 7661 6c75 6162 6c65 2c20 696e 6465  tevaluable, inde
-00018840: 783a 2074 7970 6573 2e73 7472 6963 7469  x: types.stricti
-00018850: 6e74 2c20 7368 6170 653a 2061 7373 6861  nt, shape: assha
-00018860: 7065 2c20 6474 7970 653a 2061 7364 7479  pe, dtype: asdty
-00018870: 7065 2c20 2a2c 205f 6c6f 7765 723d 666c  pe, *, _lower=fl
-00018880: 6f61 7428 272d 696e 6627 292c 205f 7570  oat('-inf'), _up
-00018890: 7065 723d 666c 6f61 7428 2769 6e66 2729  per=float('inf')
-000188a0: 293a 0a20 2020 2020 2020 2073 656c 662e  ):.        self.
-000188b0: 6172 7261 7973 203d 2061 7272 6179 730a  arrays = arrays.
-000188c0: 2020 2020 2020 2020 7365 6c66 2e69 6e64          self.ind
-000188d0: 6578 203d 2069 6e64 6578 0a20 2020 2020  ex = index.     
-000188e0: 2020 2073 656c 662e 5f6c 6f77 6572 203d     self._lower =
-000188f0: 205f 6c6f 7765 720a 2020 2020 2020 2020   _lower.        
-00018900: 7365 6c66 2e5f 7570 7065 7220 3d20 5f75  self._upper = _u
-00018910: 7070 6572 0a20 2020 2020 2020 2073 7570  pper.        sup
-00018920: 6572 2829 2e5f 5f69 6e69 745f 5f28 6172  er().__init__(ar
-00018930: 6773 3d5b 6172 7261 7973 5d2c 2073 6861  gs=[arrays], sha
-00018940: 7065 3d73 6861 7065 2c20 6474 7970 653d  pe=shape, dtype=
-00018950: 6474 7970 6529 0a0a 2020 2020 6465 6620  dtype)..    def 
-00018960: 6576 616c 6628 7365 6c66 2c20 6172 7261  evalf(self, arra
-00018970: 7973 293a 0a20 2020 2020 2020 2061 7373  ys):.        ass
-00018980: 6572 7420 6973 696e 7374 616e 6365 2861  ert isinstance(a
-00018990: 7272 6179 732c 2074 7570 6c65 290a 2020  rrays, tuple).  
-000189a0: 2020 2020 2020 7265 7475 726e 2061 7272        return arr
-000189b0: 6179 735b 7365 6c66 2e69 6e64 6578 5d0a  ays[self.index].
-000189c0: 0a20 2020 2064 6566 205f 6e6f 6465 2873  .    def _node(s
-000189d0: 656c 662c 2063 6163 6865 2c20 7375 6267  elf, cache, subg
-000189e0: 7261 7068 2c20 7469 6d65 7329 3a0a 2020  raph, times):.  
-000189f0: 2020 2020 2020 6966 2073 656c 6620 696e        if self in
-00018a00: 2063 6163 6865 3a0a 2020 2020 2020 2020   cache:.        
-00018a10: 2020 2020 7265 7475 726e 2063 6163 6865      return cache
-00018a20: 5b73 656c 665d 0a20 2020 2020 2020 2065  [self].        e
-00018a30: 6c69 6620 6861 7361 7474 7228 7365 6c66  lif hasattr(self
-00018a40: 2e61 7272 6179 732c 2027 5f6e 6f64 655f  .arrays, '_node_
-00018a50: 7475 706c 6527 293a 0a20 2020 2020 2020  tuple'):.       
-00018a60: 2020 2020 2063 6163 6865 5b73 656c 665d       cache[self]
-00018a70: 203d 206e 6f64 6520 3d20 7365 6c66 2e61   = node = self.a
-00018a80: 7272 6179 732e 5f6e 6f64 655f 7475 706c  rrays._node_tupl
-00018a90: 6528 6361 6368 652c 2073 7562 6772 6170  e(cache, subgrap
-00018aa0: 682c 2074 696d 6573 295b 7365 6c66 2e69  h, times)[self.i
-00018ab0: 6e64 6578 5d0a 2020 2020 2020 2020 2020  ndex].          
-00018ac0: 2020 7265 7475 726e 206e 6f64 650a 2020    return node.  
-00018ad0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00018ae0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00018af0: 7570 6572 2829 2e5f 6e6f 6465 2863 6163  uper()._node(cac
-00018b00: 6865 2c20 7375 6267 7261 7068 2c20 7469  he, subgraph, ti
-00018b10: 6d65 7329 0a0a 2020 2020 6465 6620 5f69  mes)..    def _i
-00018b20: 6e74 626f 756e 6473 5f69 6d70 6c28 7365  ntbounds_impl(se
-00018b30: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-00018b40: 7572 6e20 7365 6c66 2e5f 6c6f 7765 722c  urn self._lower,
-00018b50: 2073 656c 662e 5f75 7070 6572 0a0a 0a63   self._upper...c
-00018b60: 6c61 7373 205a 6572 6f73 2841 7272 6179  lass Zeros(Array
-00018b70: 293a 0a20 2020 2027 7a65 726f 270a 0a20  ):.    'zero'.. 
-00018b80: 2020 205f 5f73 6c6f 7473 5f5f 203d 2028     __slots__ = (
-00018b90: 290a 2020 2020 5f5f 6361 6368 655f 5f20  ).    __cache__ 
-00018ba0: 3d20 275f 6173 7370 6172 7365 272c 2027  = '_assparse', '
-00018bb0: 5f75 6e61 6c69 676e 6564 270a 0a20 2020  _unaligned'..   
-00018bc0: 2040 7479 7065 732e 6170 706c 795f 616e   @types.apply_an
-00018bd0: 6e6f 7461 7469 6f6e 730a 2020 2020 6465  notations.    de
-00018be0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
-00018bf0: 2073 6861 7065 3a20 6173 7368 6170 652c   shape: asshape,
-00018c00: 2064 7479 7065 3a20 6173 6474 7970 6529   dtype: asdtype)
-00018c10: 3a0a 2020 2020 2020 2020 7375 7065 7228  :.        super(
-00018c20: 292e 5f5f 696e 6974 5f5f 2861 7267 733d  ).__init__(args=
-00018c30: 7368 6170 652c 2073 6861 7065 3d73 6861  shape, shape=sha
-00018c40: 7065 2c20 6474 7970 653d 6474 7970 6529  pe, dtype=dtype)
-00018c50: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-00018c60: 2020 2020 6465 6620 5f75 6e61 6c69 676e      def _unalign
-00018c70: 6564 2873 656c 6629 3a0a 2020 2020 2020  ed(self):.      
-00018c80: 2020 7265 7475 726e 205a 6572 6f73 2828    return Zeros((
-00018c90: 292c 2073 656c 662e 6474 7970 6529 2c20  ), self.dtype), 
-00018ca0: 2829 0a0a 2020 2020 6465 6620 6576 616c  ()..    def eval
-00018cb0: 6628 7365 6c66 2c20 2a73 6861 7065 293a  f(self, *shape):
-00018cc0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00018cd0: 6e75 6d70 792e 7a65 726f 7328 7368 6170  numpy.zeros(shap
-00018ce0: 652c 2064 7479 7065 3d73 656c 662e 6474  e, dtype=self.dt
-00018cf0: 7970 6529 0a0a 2020 2020 6465 6620 5f6e  ype)..    def _n
-00018d00: 6f64 6528 7365 6c66 2c20 6361 6368 652c  ode(self, cache,
-00018d10: 2073 7562 6772 6170 682c 2074 696d 6573   subgraph, times
-00018d20: 293a 0a20 2020 2020 2020 2069 6620 7365  ):.        if se
-00018d30: 6c66 2e6e 6469 6d3a 0a20 2020 2020 2020  lf.ndim:.       
-00018d40: 2020 2020 2072 6574 7572 6e20 7375 7065       return supe
-00018d50: 7228 292e 5f6e 6f64 6528 6361 6368 652c  r()._node(cache,
-00018d60: 2073 7562 6772 6170 682c 2074 696d 6573   subgraph, times
-00018d70: 290a 2020 2020 2020 2020 656c 6966 2073  ).        elif s
-00018d80: 656c 6620 696e 2063 6163 6865 3a0a 2020  elf in cache:.  
-00018d90: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00018da0: 2063 6163 6865 5b73 656c 665d 0a20 2020   cache[self].   
-00018db0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00018dc0: 2020 2020 2020 2063 6163 6865 5b73 656c         cache[sel
-00018dd0: 665d 203d 206e 6f64 6520 3d20 4475 706c  f] = node = Dupl
-00018de0: 6963 6174 6564 4c65 6166 4e6f 6465 2827  icatedLeafNode('
-00018df0: 3027 2c20 2874 7970 6528 7365 6c66 292e  0', (type(self).
-00018e00: 5f5f 6e61 6d65 5f5f 2c20 7469 6d65 735b  __name__, times[
-00018e10: 7365 6c66 5d29 290a 2020 2020 2020 2020  self])).        
-00018e20: 2020 2020 7265 7475 726e 206e 6f64 650a      return node.
-00018e30: 0a20 2020 2064 6566 205f 6164 6428 7365  .    def _add(se
-00018e40: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-00018e50: 2020 2020 7265 7475 726e 206f 7468 6572      return other
-00018e60: 0a0a 2020 2020 6465 6620 5f6d 756c 7469  ..    def _multi
-00018e70: 706c 7928 7365 6c66 2c20 6f74 6865 7229  ply(self, other)
-00018e80: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00018e90: 2073 656c 660a 0a20 2020 2064 6566 205f   self..    def _
-00018ea0: 6469 6167 6f6e 616c 697a 6528 7365 6c66  diagonalize(self
-00018eb0: 2c20 6178 6973 293a 0a20 2020 2020 2020  , axis):.       
-00018ec0: 2072 6574 7572 6e20 5a65 726f 7328 7365   return Zeros(se
-00018ed0: 6c66 2e73 6861 7065 2b28 7365 6c66 2e73  lf.shape+(self.s
-00018ee0: 6861 7065 5b61 7869 735d 2c29 2c20 6474  hape[axis],), dt
-00018ef0: 7970 653d 7365 6c66 2e64 7479 7065 290a  ype=self.dtype).
-00018f00: 0a20 2020 2064 6566 205f 7375 6d28 7365  .    def _sum(se
-00018f10: 6c66 2c20 6178 6973 293a 0a20 2020 2020  lf, axis):.     
-00018f20: 2020 2072 6574 7572 6e20 5a65 726f 7328     return Zeros(
-00018f30: 7365 6c66 2e73 6861 7065 5b3a 6178 6973  self.shape[:axis
-00018f40: 5d20 2b20 7365 6c66 2e73 6861 7065 5b61  ] + self.shape[a
-00018f50: 7869 732b 313a 5d2c 2064 7479 7065 3d69  xis+1:], dtype=i
-00018f60: 6e74 2069 6620 7365 6c66 2e64 7479 7065  nt if self.dtype
-00018f70: 203d 3d20 626f 6f6c 2065 6c73 6520 7365   == bool else se
-00018f80: 6c66 2e64 7479 7065 290a 0a20 2020 2064  lf.dtype)..    d
-00018f90: 6566 205f 7472 616e 7370 6f73 6528 7365  ef _transpose(se
-00018fa0: 6c66 2c20 6178 6573 293a 0a20 2020 2020  lf, axes):.     
-00018fb0: 2020 2073 6861 7065 203d 205b 7365 6c66     shape = [self
-00018fc0: 2e73 6861 7065 5b6e 5d20 666f 7220 6e20  .shape[n] for n 
-00018fd0: 696e 2061 7865 735d 0a20 2020 2020 2020  in axes].       
-00018fe0: 2072 6574 7572 6e20 5a65 726f 7328 7368   return Zeros(sh
-00018ff0: 6170 652c 2064 7479 7065 3d73 656c 662e  ape, dtype=self.
-00019000: 6474 7970 6529 0a0a 2020 2020 6465 6620  dtype)..    def 
-00019010: 5f69 6e73 6572 7461 7869 7328 7365 6c66  _insertaxis(self
-00019020: 2c20 6178 6973 2c20 6c65 6e67 7468 293a  , axis, length):
-00019030: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00019040: 5a65 726f 7328 7365 6c66 2e73 6861 7065  Zeros(self.shape
-00019050: 5b3a 6178 6973 5d2b 286c 656e 6774 682c  [:axis]+(length,
-00019060: 292b 7365 6c66 2e73 6861 7065 5b61 7869  )+self.shape[axi
-00019070: 733a 5d2c 2073 656c 662e 6474 7970 6529  s:], self.dtype)
-00019080: 0a0a 2020 2020 6465 6620 5f74 616b 6564  ..    def _taked
-00019090: 6961 6728 7365 6c66 2c20 6178 6973 312c  iag(self, axis1,
-000190a0: 2061 7869 7332 293a 0a20 2020 2020 2020   axis2):.       
-000190b0: 2072 6574 7572 6e20 5a65 726f 7328 7365   return Zeros(se
-000190c0: 6c66 2e73 6861 7065 5b3a 6178 6973 315d  lf.shape[:axis1]
-000190d0: 2b73 656c 662e 7368 6170 655b 6178 6973  +self.shape[axis
-000190e0: 312b 313a 6178 6973 325d 2b73 656c 662e  1+1:axis2]+self.
-000190f0: 7368 6170 655b 6178 6973 322b 313a 7365  shape[axis2+1:se
-00019100: 6c66 2e6e 6469 6d5d 2b28 7365 6c66 2e73  lf.ndim]+(self.s
-00019110: 6861 7065 5b61 7869 7331 5d2c 292c 2064  hape[axis1],), d
-00019120: 7479 7065 3d73 656c 662e 6474 7970 6529  type=self.dtype)
-00019130: 0a0a 2020 2020 6465 6620 5f74 616b 6528  ..    def _take(
-00019140: 7365 6c66 2c20 696e 6465 782c 2061 7869  self, index, axi
-00019150: 7329 3a0a 2020 2020 2020 2020 7265 7475  s):.        retu
-00019160: 726e 205a 6572 6f73 2873 656c 662e 7368  rn Zeros(self.sh
-00019170: 6170 655b 3a61 7869 735d 202b 2069 6e64  ape[:axis] + ind
-00019180: 6578 2e73 6861 7065 202b 2073 656c 662e  ex.shape + self.
-00019190: 7368 6170 655b 6178 6973 2b31 3a5d 2c20  shape[axis+1:], 
-000191a0: 6474 7970 653d 7365 6c66 2e64 7479 7065  dtype=self.dtype
-000191b0: 290a 0a20 2020 2064 6566 205f 696e 666c  )..    def _infl
-000191c0: 6174 6528 7365 6c66 2c20 646f 666d 6170  ate(self, dofmap
-000191d0: 2c20 6c65 6e67 7468 2c20 6178 6973 293a  , length, axis):
-000191e0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000191f0: 5a65 726f 7328 7365 6c66 2e73 6861 7065  Zeros(self.shape
-00019200: 5b3a 6178 6973 5d20 2b20 286c 656e 6774  [:axis] + (lengt
-00019210: 682c 2920 2b20 7365 6c66 2e73 6861 7065  h,) + self.shape
-00019220: 5b61 7869 732b 646f 666d 6170 2e6e 6469  [axis+dofmap.ndi
-00019230: 6d3a 5d2c 2064 7479 7065 3d73 656c 662e  m:], dtype=self.
-00019240: 6474 7970 6529 0a0a 2020 2020 6465 6620  dtype)..    def 
-00019250: 5f75 6e72 6176 656c 2873 656c 662c 2061  _unravel(self, a
-00019260: 7869 732c 2073 6861 7065 293a 0a20 2020  xis, shape):.   
-00019270: 2020 2020 2073 6861 7065 203d 2073 656c       shape = sel
-00019280: 662e 7368 6170 655b 3a61 7869 735d 202b  f.shape[:axis] +
-00019290: 2073 6861 7065 202b 2073 656c 662e 7368   shape + self.sh
-000192a0: 6170 655b 6178 6973 2b31 3a5d 0a20 2020  ape[axis+1:].   
-000192b0: 2020 2020 2072 6574 7572 6e20 5a65 726f       return Zero
-000192c0: 7328 7368 6170 652c 2064 7479 7065 3d73  s(shape, dtype=s
-000192d0: 656c 662e 6474 7970 6529 0a0a 2020 2020  elf.dtype)..    
-000192e0: 6465 6620 5f72 6176 656c 2873 656c 662c  def _ravel(self,
-000192f0: 2061 7869 7329 3a0a 2020 2020 2020 2020   axis):.        
-00019300: 7265 7475 726e 205a 6572 6f73 2873 656c  return Zeros(sel
-00019310: 662e 7368 6170 655b 3a61 7869 735d 202b  f.shape[:axis] +
-00019320: 2028 7365 6c66 2e73 6861 7065 5b61 7869   (self.shape[axi
-00019330: 735d 2a73 656c 662e 7368 6170 655b 6178  s]*self.shape[ax
-00019340: 6973 2b31 5d2c 2920 2b20 7365 6c66 2e73  is+1],) + self.s
-00019350: 6861 7065 5b61 7869 732b 323a 5d2c 2073  hape[axis+2:], s
-00019360: 656c 662e 6474 7970 6529 0a0a 2020 2020  elf.dtype)..    
-00019370: 6465 6620 5f64 6574 6572 6d69 6e61 6e74  def _determinant
-00019380: 2873 656c 662c 2061 7869 7331 2c20 6178  (self, axis1, ax
-00019390: 6973 3229 3a0a 2020 2020 2020 2020 7368  is2):.        sh
-000193a0: 6170 6520 3d20 6c69 7374 2873 656c 662e  ape = list(self.
-000193b0: 7368 6170 6529 0a20 2020 2020 2020 2061  shape).        a
-000193c0: 7373 6572 7420 6178 6973 3120 213d 2061  ssert axis1 != a
-000193d0: 7869 7332 0a20 2020 2020 2020 206c 656e  xis2.        len
-000193e0: 6774 682c 203d 2073 6574 286d 6170 2873  gth, = set(map(s
-000193f0: 6861 7065 2e70 6f70 2c20 736f 7274 6564  hape.pop, sorted
-00019400: 2828 6178 6973 312c 2061 7869 7332 292c  ((axis1, axis2),
-00019410: 2072 6576 6572 7365 3d54 7275 6529 2929   reverse=True)))
-00019420: 0a20 2020 2020 2020 2069 6620 6973 7a65  .        if isze
-00019430: 726f 286c 656e 6774 6829 3a0a 2020 2020  ro(length):.    
-00019440: 2020 2020 2020 2020 7265 7475 726e 206f          return o
-00019450: 6e65 7328 7368 6170 652c 2073 656c 662e  nes(shape, self.
-00019460: 6474 7970 6529 0a20 2020 2020 2020 2065  dtype).        e
-00019470: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00019480: 2072 6574 7572 6e20 5a65 726f 7328 7368   return Zeros(sh
-00019490: 6170 652c 2073 656c 662e 6474 7970 6529  ape, self.dtype)
-000194a0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-000194b0: 2020 2020 6465 6620 5f61 7373 7061 7273      def _asspars
-000194c0: 6528 7365 6c66 293a 0a20 2020 2020 2020  e(self):.       
-000194d0: 2072 6574 7572 6e20 2829 0a0a 2020 2020   return ()..    
-000194e0: 6465 6620 5f69 6e74 626f 756e 6473 5f69  def _intbounds_i
-000194f0: 6d70 6c28 7365 6c66 293a 0a20 2020 2020  mpl(self):.     
-00019500: 2020 2072 6574 7572 6e20 302c 2030 0a0a     return 0, 0..
-00019510: 0a63 6c61 7373 2049 6e66 6c61 7465 2841  .class Inflate(A
-00019520: 7272 6179 293a 0a0a 2020 2020 5f5f 736c  rray):..    __sl
-00019530: 6f74 735f 5f20 3d20 2766 756e 6327 2c20  ots__ = 'func', 
-00019540: 2764 6f66 6d61 7027 2c20 276c 656e 6774  'dofmap', 'lengt
-00019550: 6827 2c20 2777 6172 6e27 0a20 2020 205f  h', 'warn'.    _
-00019560: 5f63 6163 6865 5f5f 203d 2027 5f61 7373  _cache__ = '_ass
-00019570: 7061 7273 6527 2c20 275f 6469 6167 6f6e  parse', '_diagon
-00019580: 616c 7327 2c20 275f 696e 666c 6174 696f  als', '_inflatio
-00019590: 6e73 270a 0a20 2020 2040 7479 7065 732e  ns'..    @types.
-000195a0: 6170 706c 795f 616e 6e6f 7461 7469 6f6e  apply_annotation
-000195b0: 730a 2020 2020 6465 6620 5f5f 696e 6974  s.    def __init
-000195c0: 5f5f 2873 656c 662c 2066 756e 633a 2061  __(self, func: a
-000195d0: 7361 7272 6179 2c20 646f 666d 6170 3a20  sarray, dofmap: 
-000195e0: 6173 6172 7261 792c 206c 656e 6774 683a  asarray, length:
-000195f0: 2061 7369 6e64 6578 293a 0a20 2020 2020   asindex):.     
-00019600: 2020 2069 6620 6e6f 7420 6571 7561 6c73     if not equals
-00019610: 6861 7065 2866 756e 632e 7368 6170 655b  hape(func.shape[
-00019620: 6675 6e63 2e6e 6469 6d2d 646f 666d 6170  func.ndim-dofmap
-00019630: 2e6e 6469 6d3a 5d2c 2064 6f66 6d61 702e  .ndim:], dofmap.
-00019640: 7368 6170 6529 3a0a 2020 2020 2020 2020  shape):.        
-00019650: 2020 2020 7261 6973 6520 4578 6365 7074      raise Except
-00019660: 696f 6e28 2769 6e76 616c 6964 2064 6f66  ion('invalid dof
-00019670: 6d61 7027 290a 2020 2020 2020 2020 7365  map').        se
-00019680: 6c66 2e66 756e 6320 3d20 6675 6e63 0a20  lf.func = func. 
-00019690: 2020 2020 2020 2073 656c 662e 646f 666d         self.dofm
-000196a0: 6170 203d 2064 6f66 6d61 700a 2020 2020  ap = dofmap.    
-000196b0: 2020 2020 7365 6c66 2e6c 656e 6774 6820      self.length 
-000196c0: 3d20 6c65 6e67 7468 0a20 2020 2020 2020  = length.       
-000196d0: 2073 656c 662e 7761 726e 203d 206e 6f74   self.warn = not
-000196e0: 2064 6f66 6d61 702e 6973 636f 6e73 7461   dofmap.isconsta
-000196f0: 6e74 0a20 2020 2020 2020 2073 7570 6572  nt.        super
-00019700: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
-00019710: 3d5b 6675 6e63 2c20 646f 666d 6170 2c20  =[func, dofmap, 
-00019720: 6c65 6e67 7468 5d2c 2073 6861 7065 3d28  length], shape=(
-00019730: 2a66 756e 632e 7368 6170 655b 3a66 756e  *func.shape[:fun
-00019740: 632e 6e64 696d 2d64 6f66 6d61 702e 6e64  c.ndim-dofmap.nd
-00019750: 696d 5d2c 206c 656e 6774 6829 2c20 6474  im], length), dt
-00019760: 7970 653d 6675 6e63 2e64 7479 7065 290a  ype=func.dtype).
-00019770: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00019780: 2020 2064 6566 205f 6469 6167 6f6e 616c     def _diagonal
-00019790: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
-000197a0: 2072 6574 7572 6e20 7475 706c 6528 6178   return tuple(ax
-000197b0: 6573 2066 6f72 2061 7865 7320 696e 2073  es for axes in s
-000197c0: 656c 662e 6675 6e63 2e5f 6469 6167 6f6e  elf.func._diagon
-000197d0: 616c 7320 6966 2061 6c6c 2861 7869 7320  als if all(axis 
-000197e0: 3c20 7365 6c66 2e6e 6469 6d2d 3120 666f  < self.ndim-1 fo
-000197f0: 7220 6178 6973 2069 6e20 6178 6573 2929  r axis in axes))
-00019800: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-00019810: 2020 2020 6465 6620 5f69 6e66 6c61 7469      def _inflati
-00019820: 6f6e 7328 7365 6c66 293a 0a20 2020 2020  ons(self):.     
-00019830: 2020 2069 6e66 6c61 7469 6f6e 7320 3d20     inflations = 
-00019840: 5b28 7365 6c66 2e6e 6469 6d2d 312c 2074  [(self.ndim-1, t
-00019850: 7970 6573 2e66 726f 7a65 6e64 6963 7428  ypes.frozendict(
-00019860: 7b73 656c 662e 646f 666d 6170 3a20 7365  {self.dofmap: se
-00019870: 6c66 2e66 756e 637d 2929 5d0a 2020 2020  lf.func}))].    
-00019880: 2020 2020 666f 7220 6178 6973 2c20 7061      for axis, pa
-00019890: 7274 7320 696e 2073 656c 662e 6675 6e63  rts in self.func
-000198a0: 2e5f 696e 666c 6174 696f 6e73 3a0a 2020  ._inflations:.  
-000198b0: 2020 2020 2020 2020 2020 696e 666c 6174            inflat
-000198c0: 696f 6e73 2e61 7070 656e 6428 2861 7869  ions.append((axi
-000198d0: 732c 2074 7970 6573 2e66 726f 7a65 6e64  s, types.frozend
-000198e0: 6963 7428 2864 6f66 6d61 702c 2049 6e66  ict((dofmap, Inf
-000198f0: 6c61 7465 2866 756e 632c 2073 656c 662e  late(func, self.
-00019900: 646f 666d 6170 2c20 7365 6c66 2e6c 656e  dofmap, self.len
-00019910: 6774 6829 2920 666f 7220 646f 666d 6170  gth)) for dofmap
-00019920: 2c20 6675 6e63 2069 6e20 7061 7274 732e  , func in parts.
-00019930: 6974 656d 7328 2929 2929 0a20 2020 2020  items()))).     
-00019940: 2020 2072 6574 7572 6e20 7475 706c 6528     return tuple(
-00019950: 696e 666c 6174 696f 6e73 290a 0a20 2020  inflations)..   
-00019960: 2064 6566 205f 7369 6d70 6c69 6669 6564   def _simplified
-00019970: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00019980: 666f 7220 6178 6973 2069 6e20 7261 6e67  for axis in rang
-00019990: 6528 7365 6c66 2e64 6f66 6d61 702e 6e64  e(self.dofmap.nd
-000199a0: 696d 293a 0a20 2020 2020 2020 2020 2020  im):.           
-000199b0: 2069 6620 6571 7561 6c69 6e64 6578 2873   if equalindex(s
-000199c0: 656c 662e 646f 666d 6170 2e73 6861 7065  elf.dofmap.shape
-000199d0: 5b61 7869 735d 2c20 3129 3a0a 2020 2020  [axis], 1):.    
-000199e0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000199f0: 726e 2049 6e66 6c61 7465 285f 7461 6b65  rn Inflate(_take
-00019a00: 2873 656c 662e 6675 6e63 2c20 302c 2073  (self.func, 0, s
-00019a10: 656c 662e 6675 6e63 2e6e 6469 6d2d 7365  elf.func.ndim-se
-00019a20: 6c66 2e64 6f66 6d61 702e 6e64 696d 2b61  lf.dofmap.ndim+a
-00019a30: 7869 7329 2c20 5f74 616b 6528 7365 6c66  xis), _take(self
-00019a40: 2e64 6f66 6d61 702c 2030 2c20 6178 6973  .dofmap, 0, axis
-00019a50: 292c 2073 656c 662e 6c65 6e67 7468 290a  ), self.length).
-00019a60: 2020 2020 2020 2020 666f 7220 6178 6973          for axis
-00019a70: 2c20 7061 7274 7320 696e 2073 656c 662e  , parts in self.
-00019a80: 6675 6e63 2e5f 696e 666c 6174 696f 6e73  func._inflations
-00019a90: 3a0a 2020 2020 2020 2020 2020 2020 6920  :.            i 
-00019aa0: 3d20 6178 6973 202d 2028 7365 6c66 2e6e  = axis - (self.n
-00019ab0: 6469 6d2d 3129 0a20 2020 2020 2020 2020  dim-1).         
-00019ac0: 2020 2069 6620 6920 3e3d 2030 3a0a 2020     if i >= 0:.  
-00019ad0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00019ae0: 7475 726e 2075 7469 6c2e 7375 6d28 496e  turn util.sum(In
-00019af0: 666c 6174 6528 662c 205f 7461 6b65 2873  flate(f, _take(s
-00019b00: 656c 662e 646f 666d 6170 2c20 696e 642c  elf.dofmap, ind,
-00019b10: 2069 292c 2073 656c 662e 6c65 6e67 7468   i), self.length
-00019b20: 2920 666f 7220 696e 642c 2066 2069 6e20  ) for ind, f in 
-00019b30: 7061 7274 732e 6974 656d 7328 2929 0a20  parts.items()). 
-00019b40: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
-00019b50: 6f66 6d61 702e 6e64 696d 203d 3d20 3020  ofmap.ndim == 0 
-00019b60: 616e 6420 6571 7561 6c69 6e64 6578 2873  and equalindex(s
-00019b70: 656c 662e 646f 666d 6170 2c20 3029 2061  elf.dofmap, 0) a
-00019b80: 6e64 2065 7175 616c 696e 6465 7828 7365  nd equalindex(se
-00019b90: 6c66 2e6c 656e 6774 682c 2031 293a 0a20  lf.length, 1):. 
-00019ba0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00019bb0: 6e20 496e 7365 7274 4178 6973 2873 656c  n InsertAxis(sel
-00019bc0: 662e 6675 6e63 2c20 3129 0a20 2020 2020  f.func, 1).     
-00019bd0: 2020 2072 6574 7572 6e20 7365 6c66 2e66     return self.f
-00019be0: 756e 632e 5f69 6e66 6c61 7465 2873 656c  unc._inflate(sel
-00019bf0: 662e 646f 666d 6170 2c20 7365 6c66 2e6c  f.dofmap, self.l
-00019c00: 656e 6774 682c 2073 656c 662e 6e64 696d  ength, self.ndim
-00019c10: 2d31 2920 5c0a 2020 2020 2020 2020 2020  -1) \.          
-00019c20: 2020 6f72 2073 656c 662e 646f 666d 6170    or self.dofmap
-00019c30: 2e5f 7269 6e66 6c61 7465 2873 656c 662e  ._rinflate(self.
-00019c40: 6675 6e63 2c20 7365 6c66 2e6c 656e 6774  func, self.lengt
-00019c50: 682c 2073 656c 662e 6e64 696d 2d31 290a  h, self.ndim-1).
-00019c60: 0a20 2020 2064 6566 2065 7661 6c66 2873  .    def evalf(s
-00019c70: 656c 662c 2061 7272 6179 2c20 696e 6469  elf, array, indi
-00019c80: 6365 732c 206c 656e 6774 6829 3a0a 2020  ces, length):.  
-00019c90: 2020 2020 2020 6173 7365 7274 2069 6e64        assert ind
-00019ca0: 6963 6573 2e6e 6469 6d20 3d3d 2073 656c  ices.ndim == sel
-00019cb0: 662e 646f 666d 6170 2e6e 6469 6d0a 2020  f.dofmap.ndim.  
-00019cc0: 2020 2020 2020 6173 7365 7274 206c 656e        assert len
-00019cd0: 6774 682e 6e64 696d 203d 3d20 300a 2020  gth.ndim == 0.  
-00019ce0: 2020 2020 2020 6966 2073 656c 662e 7761        if self.wa
-00019cf0: 726e 2061 6e64 2069 6e74 286c 656e 6774  rn and int(lengt
-00019d00: 6829 203e 2069 6e64 6963 6573 2e73 697a  h) > indices.siz
-00019d10: 653a 0a20 2020 2020 2020 2020 2020 2077  e:.            w
-00019d20: 6172 6e69 6e67 732e 7761 726e 2827 7573  arnings.warn('us
-00019d30: 696e 6720 6578 706c 6963 6974 2069 6e66  ing explicit inf
-00019d40: 6c61 7469 6f6e 3b20 7468 6973 2069 7320  lation; this is 
-00019d50: 7573 7561 6c6c 7920 6120 6275 672e 272c  usually a bug.',
-00019d60: 2045 7870 656e 7369 7665 4576 616c 7561   ExpensiveEvalua
-00019d70: 7469 6f6e 5761 726e 696e 6729 0a20 2020  tionWarning).   
-00019d80: 2020 2020 2069 6e66 6c61 7465 6420 3d20       inflated = 
-00019d90: 6e75 6d70 792e 7a65 726f 7328 6172 7261  numpy.zeros(arra
-00019da0: 792e 7368 6170 655b 3a61 7272 6179 2e6e  y.shape[:array.n
-00019db0: 6469 6d2d 696e 6469 6365 732e 6e64 696d  dim-indices.ndim
-00019dc0: 5d20 2b20 286c 656e 6774 682c 292c 2064  ] + (length,), d
-00019dd0: 7479 7065 3d73 656c 662e 6474 7970 6529  type=self.dtype)
-00019de0: 0a20 2020 2020 2020 206e 756d 7079 2e61  .        numpy.a
-00019df0: 6464 2e61 7428 696e 666c 6174 6564 2c20  dd.at(inflated, 
-00019e00: 2873 6c69 6365 284e 6f6e 6529 2c29 2a28  (slice(None),)*(
-00019e10: 7365 6c66 2e6e 6469 6d2d 3129 2b28 696e  self.ndim-1)+(in
-00019e20: 6469 6365 732c 292c 2061 7272 6179 290a  dices,), array).
-00019e30: 2020 2020 2020 2020 7265 7475 726e 2069          return i
-00019e40: 6e66 6c61 7465 640a 0a20 2020 2064 6566  nflated..    def
-00019e50: 205f 696e 666c 6174 6528 7365 6c66 2c20   _inflate(self, 
-00019e60: 646f 666d 6170 2c20 6c65 6e67 7468 2c20  dofmap, length, 
-00019e70: 6178 6973 293a 0a20 2020 2020 2020 2069  axis):.        i
-00019e80: 6620 646f 666d 6170 2e6e 6469 6d20 3d3d  f dofmap.ndim ==
-00019e90: 2030 2061 6e64 2064 6f66 6d61 7020 3d3d   0 and dofmap ==
-00019ea0: 2073 656c 662e 646f 666d 6170 2061 6e64   self.dofmap and
-00019eb0: 206c 656e 6774 6820 3d3d 2073 656c 662e   length == self.
-00019ec0: 6c65 6e67 7468 3a0a 2020 2020 2020 2020  length:.        
-00019ed0: 2020 2020 7265 7475 726e 2064 6961 676f      return diago
-00019ee0: 6e61 6c69 7a65 2873 656c 662c 202d 312c  nalize(self, -1,
-00019ef0: 2061 7869 7329 0a0a 2020 2020 6465 6620   axis)..    def 
-00019f00: 5f64 6572 6976 6174 6976 6528 7365 6c66  _derivative(self
-00019f10: 2c20 7661 722c 2073 6565 6e29 3a0a 2020  , var, seen):.  
-00019f20: 2020 2020 2020 7265 7475 726e 205f 696e        return _in
-00019f30: 666c 6174 6528 6465 7269 7661 7469 7665  flate(derivative
-00019f40: 2873 656c 662e 6675 6e63 2c20 7661 722c  (self.func, var,
-00019f50: 2073 6565 6e29 2c20 7365 6c66 2e64 6f66   seen), self.dof
-00019f60: 6d61 702c 2073 656c 662e 6c65 6e67 7468  map, self.length
-00019f70: 2c20 7365 6c66 2e6e 6469 6d2d 3129 0a0a  , self.ndim-1)..
-00019f80: 2020 2020 6465 6620 5f6d 756c 7469 706c      def _multipl
-00019f90: 7928 7365 6c66 2c20 6f74 6865 7229 3a0a  y(self, other):.
-00019fa0: 2020 2020 2020 2020 7265 7475 726e 2049          return I
-00019fb0: 6e66 6c61 7465 284d 756c 7469 706c 7928  nflate(Multiply(
-00019fc0: 5b73 656c 662e 6675 6e63 2c20 5461 6b65  [self.func, Take
-00019fd0: 286f 7468 6572 2c20 7365 6c66 2e64 6f66  (other, self.dof
-00019fe0: 6d61 7029 5d29 2c20 7365 6c66 2e64 6f66  map)]), self.dof
-00019ff0: 6d61 702c 2073 656c 662e 6c65 6e67 7468  map, self.length
-0001a000: 290a 0a20 2020 2064 6566 205f 6164 6428  )..    def _add(
-0001a010: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-0001a020: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-0001a030: 6e63 6528 6f74 6865 722c 2049 6e66 6c61  nce(other, Infla
-0001a040: 7465 2920 616e 6420 7365 6c66 2e64 6f66  te) and self.dof
-0001a050: 6d61 7020 3d3d 206f 7468 6572 2e64 6f66  map == other.dof
-0001a060: 6d61 703a 0a20 2020 2020 2020 2020 2020  map:.           
-0001a070: 2072 6574 7572 6e20 496e 666c 6174 6528   return Inflate(
-0001a080: 4164 6428 5b73 656c 662e 6675 6e63 2c20  Add([self.func, 
-0001a090: 6f74 6865 722e 6675 6e63 5d29 2c20 7365  other.func]), se
-0001a0a0: 6c66 2e64 6f66 6d61 702c 2073 656c 662e  lf.dofmap, self.
-0001a0b0: 6c65 6e67 7468 290a 0a20 2020 2064 6566  length)..    def
-0001a0c0: 205f 7461 6b65 6469 6167 2873 656c 662c   _takediag(self,
-0001a0d0: 2061 7869 7331 2c20 6178 6973 3229 3a0a   axis1, axis2):.
-0001a0e0: 2020 2020 2020 2020 6173 7365 7274 2061          assert a
-0001a0f0: 7869 7331 203c 2061 7869 7332 0a20 2020  xis1 < axis2.   
-0001a100: 2020 2020 2069 6620 6178 6973 3220 3d3d       if axis2 ==
-0001a110: 2073 656c 662e 6e64 696d 2d31 3a0a 2020   self.ndim-1:.  
-0001a120: 2020 2020 2020 2020 2020 6675 6e63 203d            func =
-0001a130: 205f 7461 6b65 2873 656c 662e 6675 6e63   _take(self.func
-0001a140: 2c20 7365 6c66 2e64 6f66 6d61 702c 2061  , self.dofmap, a
-0001a150: 7869 7331 290a 2020 2020 2020 2020 2020  xis1).          
-0001a160: 2020 666f 7220 6920 696e 2072 616e 6765    for i in range
-0001a170: 2873 656c 662e 646f 666d 6170 2e6e 6469  (self.dofmap.ndi
-0001a180: 6d29 3a0a 2020 2020 2020 2020 2020 2020  m):.            
-0001a190: 2020 2020 6675 6e63 203d 205f 7461 6b65      func = _take
-0001a1a0: 6469 6167 2866 756e 632c 2061 7869 7331  diag(func, axis1
-0001a1b0: 2c20 6178 6973 322b 7365 6c66 2e64 6f66  , axis2+self.dof
-0001a1c0: 6d61 702e 6e64 696d 2d31 2d69 290a 2020  map.ndim-1-i).  
-0001a1d0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001a1e0: 2049 6e66 6c61 7465 2866 756e 632c 2073   Inflate(func, s
-0001a1f0: 656c 662e 646f 666d 6170 2c20 7365 6c66  elf.dofmap, self
-0001a200: 2e6c 656e 6774 6829 0a20 2020 2020 2020  .length).       
-0001a210: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0001a220: 2020 2072 6574 7572 6e20 5f69 6e66 6c61     return _infla
-0001a230: 7465 285f 7461 6b65 6469 6167 2873 656c  te(_takediag(sel
-0001a240: 662e 6675 6e63 2c20 6178 6973 312c 2061  f.func, axis1, a
-0001a250: 7869 7332 292c 2073 656c 662e 646f 666d  xis2), self.dofm
-0001a260: 6170 2c20 7365 6c66 2e6c 656e 6774 682c  ap, self.length,
-0001a270: 2073 656c 662e 6e64 696d 2d33 290a 0a20   self.ndim-3).. 
-0001a280: 2020 2064 6566 205f 7461 6b65 2873 656c     def _take(sel
-0001a290: 662c 2069 6e64 6578 2c20 6178 6973 293a  f, index, axis):
-0001a2a0: 0a20 2020 2020 2020 2069 6620 6178 6973  .        if axis
-0001a2b0: 2021 3d20 7365 6c66 2e6e 6469 6d2d 313a   != self.ndim-1:
-0001a2c0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0001a2d0: 7572 6e20 496e 666c 6174 6528 5f74 616b  urn Inflate(_tak
-0001a2e0: 6528 7365 6c66 2e66 756e 632c 2069 6e64  e(self.func, ind
-0001a2f0: 6578 2c20 6178 6973 292c 2073 656c 662e  ex, axis), self.
-0001a300: 646f 666d 6170 2c20 7365 6c66 2e6c 656e  dofmap, self.len
-0001a310: 6774 6829 0a20 2020 2020 2020 206e 6577  gth).        new
-0001a320: 696e 6465 782c 206e 6577 646f 666d 6170  index, newdofmap
-0001a330: 203d 2053 7761 7049 6e66 6c61 7465 5461   = SwapInflateTa
-0001a340: 6b65 2873 656c 662e 646f 666d 6170 2c20  ke(self.dofmap, 
-0001a350: 696e 6465 7829 0a20 2020 2020 2020 2069  index).        i
-0001a360: 6620 7365 6c66 2e64 6f66 6d61 702e 6e64  f self.dofmap.nd
-0001a370: 696d 3a0a 2020 2020 2020 2020 2020 2020  im:.            
-0001a380: 6675 6e63 203d 2073 656c 662e 6675 6e63  func = self.func
-0001a390: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0001a3a0: 2069 2069 6e20 7261 6e67 6528 7365 6c66   i in range(self
-0001a3b0: 2e64 6f66 6d61 702e 6e64 696d 2d31 293a  .dofmap.ndim-1):
-0001a3c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a3d0: 2066 756e 6320 3d20 5261 7665 6c28 6675   func = Ravel(fu
-0001a3e0: 6e63 290a 2020 2020 2020 2020 2020 2020  nc).            
-0001a3f0: 696e 7465 7273 6563 7469 6f6e 203d 2054  intersection = T
-0001a400: 616b 6528 6675 6e63 2c20 6e65 7769 6e64  ake(func, newind
-0001a410: 6578 290a 2020 2020 2020 2020 656c 7365  ex).        else
-0001a420: 3a20 2023 206b 726f 6e65 636b 6572 3b20  :  # kronecker; 
-0001a430: 6e65 7769 6e64 6578 2069 7320 616c 6c20  newindex is all 
-0001a440: 7a65 726f 7320 2862 7574 206f 6620 7661  zeros (but of va
-0001a450: 7279 696e 6720 6c65 6e67 7468 290a 2020  rying length).  
-0001a460: 2020 2020 2020 2020 2020 696e 7465 7273            inters
-0001a470: 6563 7469 6f6e 203d 2049 6e73 6572 7441  ection = InsertA
-0001a480: 7869 7328 7365 6c66 2e66 756e 632c 206e  xis(self.func, n
-0001a490: 6577 696e 6465 782e 7368 6170 655b 305d  ewindex.shape[0]
-0001a4a0: 290a 2020 2020 2020 2020 6966 2069 6e64  ).        if ind
-0001a4b0: 6578 2e6e 6469 6d3a 0a20 2020 2020 2020  ex.ndim:.       
-0001a4c0: 2020 2020 2073 7761 7070 6564 203d 2049       swapped = I
-0001a4d0: 6e66 6c61 7465 2869 6e74 6572 7365 6374  nflate(intersect
-0001a4e0: 696f 6e2c 206e 6577 646f 666d 6170 2c20  ion, newdofmap, 
-0001a4f0: 696e 6465 782e 7369 7a65 290a 2020 2020  index.size).    
-0001a500: 2020 2020 2020 2020 666f 7220 6920 696e          for i in
-0001a510: 2072 616e 6765 2869 6e64 6578 2e6e 6469   range(index.ndi
-0001a520: 6d2d 3129 3a0a 2020 2020 2020 2020 2020  m-1):.          
-0001a530: 2020 2020 2020 7377 6170 7065 6420 3d20        swapped = 
-0001a540: 556e 7261 7665 6c28 7377 6170 7065 642c  Unravel(swapped,
-0001a550: 2069 6e64 6578 2e73 6861 7065 5b69 5d2c   index.shape[i],
-0001a560: 2075 7469 6c2e 7072 6f64 7563 7428 696e   util.product(in
-0001a570: 6465 782e 7368 6170 655b 692b 313a 5d29  dex.shape[i+1:])
-0001a580: 290a 2020 2020 2020 2020 656c 7365 3a20  ).        else: 
-0001a590: 2023 2067 6574 3b20 6e65 7764 6f66 6d61   # get; newdofma
-0001a5a0: 7020 6973 2061 6c6c 207a 6572 6f73 2028  p is all zeros (
-0001a5b0: 6275 7420 6f66 2076 6172 7969 6e67 206c  but of varying l
-0001a5c0: 656e 6774 6829 0a20 2020 2020 2020 2020  ength).         
-0001a5d0: 2020 2073 7761 7070 6564 203d 2053 756d     swapped = Sum
-0001a5e0: 2869 6e74 6572 7365 6374 696f 6e29 0a20  (intersection). 
-0001a5f0: 2020 2020 2020 2072 6574 7572 6e20 7377         return sw
-0001a600: 6170 7065 640a 0a20 2020 2064 6566 205f  apped..    def _
-0001a610: 6469 6167 6f6e 616c 697a 6528 7365 6c66  diagonalize(self
-0001a620: 2c20 6178 6973 293a 0a20 2020 2020 2020  , axis):.       
-0001a630: 2069 6620 6178 6973 2021 3d20 7365 6c66   if axis != self
-0001a640: 2e6e 6469 6d2d 313a 0a20 2020 2020 2020  .ndim-1:.       
-0001a650: 2020 2020 2072 6574 7572 6e20 5f69 6e66       return _inf
-0001a660: 6c61 7465 2864 6961 676f 6e61 6c69 7a65  late(diagonalize
-0001a670: 2873 656c 662e 6675 6e63 2c20 6178 6973  (self.func, axis
-0001a680: 292c 2073 656c 662e 646f 666d 6170 2c20  ), self.dofmap, 
-0001a690: 7365 6c66 2e6c 656e 6774 682c 2073 656c  self.length, sel
-0001a6a0: 662e 6e64 696d 2d31 290a 0a20 2020 2064  f.ndim-1)..    d
-0001a6b0: 6566 205f 7375 6d28 7365 6c66 2c20 6178  ef _sum(self, ax
-0001a6c0: 6973 293a 0a20 2020 2020 2020 2069 6620  is):.        if 
-0001a6d0: 6178 6973 203d 3d20 7365 6c66 2e6e 6469  axis == self.ndi
-0001a6e0: 6d2d 313a 0a20 2020 2020 2020 2020 2020  m-1:.           
-0001a6f0: 2066 756e 6320 3d20 7365 6c66 2e66 756e   func = self.fun
-0001a700: 630a 2020 2020 2020 2020 2020 2020 666f  c.            fo
-0001a710: 7220 6920 696e 2072 616e 6765 2873 656c  r i in range(sel
-0001a720: 662e 646f 666d 6170 2e6e 6469 6d29 3a0a  f.dofmap.ndim):.
-0001a730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a740: 6675 6e63 203d 2053 756d 2866 756e 6329  func = Sum(func)
-0001a750: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0001a760: 7572 6e20 6675 6e63 0a20 2020 2020 2020  urn func.       
-0001a770: 2072 6574 7572 6e20 496e 666c 6174 6528   return Inflate(
-0001a780: 7375 6d28 7365 6c66 2e66 756e 632c 2061  sum(self.func, a
-0001a790: 7869 7329 2c20 7365 6c66 2e64 6f66 6d61  xis), self.dofma
-0001a7a0: 702c 2073 656c 662e 6c65 6e67 7468 290a  p, self.length).
-0001a7b0: 0a20 2020 2064 6566 205f 756e 7261 7665  .    def _unrave
-0001a7c0: 6c28 7365 6c66 2c20 6178 6973 2c20 7368  l(self, axis, sh
-0001a7d0: 6170 6529 3a0a 2020 2020 2020 2020 6966  ape):.        if
-0001a7e0: 2061 7869 7320 213d 2073 656c 662e 6e64   axis != self.nd
-0001a7f0: 696d 2d31 3a0a 2020 2020 2020 2020 2020  im-1:.          
-0001a800: 2020 7265 7475 726e 2049 6e66 6c61 7465    return Inflate
-0001a810: 2875 6e72 6176 656c 2873 656c 662e 6675  (unravel(self.fu
-0001a820: 6e63 2c20 6178 6973 2c20 7368 6170 6529  nc, axis, shape)
-0001a830: 2c20 7365 6c66 2e64 6f66 6d61 702c 2073  , self.dofmap, s
-0001a840: 656c 662e 6c65 6e67 7468 290a 0a20 2020  elf.length)..   
-0001a850: 2064 6566 205f 7369 676e 2873 656c 6629   def _sign(self)
-0001a860: 3a0a 2020 2020 2020 2020 6966 2073 656c  :.        if sel
-0001a870: 662e 646f 666d 6170 2e69 7363 6f6e 7374  f.dofmap.isconst
-0001a880: 616e 7420 616e 6420 5f69 7375 6e69 7175  ant and _isuniqu
-0001a890: 6528 7365 6c66 2e64 6f66 6d61 702e 6576  e(self.dofmap.ev
-0001a8a0: 616c 2829 293a 0a20 2020 2020 2020 2020  al()):.         
-0001a8b0: 2020 2072 6574 7572 6e20 496e 666c 6174     return Inflat
-0001a8c0: 6528 5369 676e 2873 656c 662e 6675 6e63  e(Sign(self.func
-0001a8d0: 292c 2073 656c 662e 646f 666d 6170 2c20  ), self.dofmap, 
-0001a8e0: 7365 6c66 2e6c 656e 6774 6829 0a0a 2020  self.length)..  
-0001a8f0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-0001a900: 6465 6620 5f61 7373 7061 7273 6528 7365  def _assparse(se
-0001a910: 6c66 293a 0a20 2020 2020 2020 2063 6875  lf):.        chu
-0001a920: 6e6b 7320 3d20 5b5d 0a20 2020 2020 2020  nks = [].       
-0001a930: 2066 6c61 745f 646f 666d 6170 203d 205f   flat_dofmap = _
-0001a940: 666c 6174 2873 656c 662e 646f 666d 6170  flat(self.dofmap
-0001a950: 290a 2020 2020 2020 2020 6b65 6570 5f64  ).        keep_d
-0001a960: 696d 203d 2073 656c 662e 6675 6e63 2e6e  im = self.func.n
-0001a970: 6469 6d20 2d20 7365 6c66 2e64 6f66 6d61  dim - self.dofma
-0001a980: 702e 6e64 696d 0a20 2020 2020 2020 2073  p.ndim.        s
-0001a990: 7472 6964 6573 203d 2028 312c 202a 6974  trides = (1, *it
-0001a9a0: 6572 746f 6f6c 732e 6163 6375 6d75 6c61  ertools.accumula
-0001a9b0: 7465 2873 656c 662e 646f 666d 6170 2e73  te(self.dofmap.s
-0001a9c0: 6861 7065 5b3a 303a 2d31 5d2c 206f 7065  hape[:0:-1], ope
-0001a9d0: 7261 746f 722e 6d75 6c29 295b 3a3a 2d31  rator.mul))[::-1
-0001a9e0: 5d0a 2020 2020 2020 2020 666f 7220 2a69  ].        for *i
-0001a9f0: 6e64 6963 6573 2c20 7661 6c75 6573 2069  ndices, values i
-0001aa00: 6e20 7365 6c66 2e66 756e 632e 5f61 7373  n self.func._ass
-0001aa10: 7061 7273 653a 0a20 2020 2020 2020 2020  parse:.         
-0001aa20: 2020 2069 6620 7365 6c66 2e64 6f66 6d61     if self.dofma
-0001aa30: 702e 6e64 696d 3a0a 2020 2020 2020 2020  p.ndim:.        
-0001aa40: 2020 2020 2020 2020 696e 666c 6174 655f          inflate_
-0001aa50: 696e 6469 6365 7320 3d20 5461 6b65 2866  indices = Take(f
-0001aa60: 6c61 745f 646f 666d 6170 2c20 6675 6e63  lat_dofmap, func
-0001aa70: 746f 6f6c 732e 7265 6475 6365 286f 7065  tools.reduce(ope
-0001aa80: 7261 746f 722e 6164 642c 206d 6170 286f  rator.add, map(o
-0001aa90: 7065 7261 746f 722e 6d75 6c2c 2069 6e64  perator.mul, ind
-0001aaa0: 6963 6573 5b6b 6565 705f 6469 6d3a 5d2c  ices[keep_dim:],
-0001aab0: 2073 7472 6964 6573 2929 290a 2020 2020   strides))).    
-0001aac0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0001aad0: 2020 2020 2020 2020 2020 2020 2020 696e                in
-0001aae0: 666c 6174 655f 696e 6469 6365 7320 3d20  flate_indices = 
-0001aaf0: 6170 7065 6e64 6178 6573 2873 656c 662e  appendaxes(self.
-0001ab00: 646f 666d 6170 2c20 7661 6c75 6573 2e73  dofmap, values.s
-0001ab10: 6861 7065 290a 2020 2020 2020 2020 2020  hape).          
-0001ab20: 2020 6368 756e 6b73 2e61 7070 656e 6428    chunks.append(
-0001ab30: 282a 696e 6469 6365 735b 3a6b 6565 705f  (*indices[:keep_
-0001ab40: 6469 6d5d 2c20 696e 666c 6174 655f 696e  dim], inflate_in
-0001ab50: 6469 6365 732c 2076 616c 7565 7329 290a  dices, values)).
-0001ab60: 2020 2020 2020 2020 7265 7475 726e 2074          return t
-0001ab70: 7570 6c65 2863 6875 6e6b 7329 0a0a 2020  uple(chunks)..  
-0001ab80: 2020 6465 6620 5f69 6e74 626f 756e 6473    def _intbounds
-0001ab90: 5f69 6d70 6c28 7365 6c66 293a 0a20 2020  _impl(self):.   
-0001aba0: 2020 2020 206c 6f77 6572 2c20 7570 7065       lower, uppe
-0001abb0: 7220 3d20 7365 6c66 2e66 756e 632e 5f69  r = self.func._i
-0001abc0: 6e74 626f 756e 6473 0a20 2020 2020 2020  ntbounds.       
-0001abd0: 2072 6574 7572 6e20 6d69 6e28 6c6f 7765   return min(lowe
-0001abe0: 722c 2030 292c 206d 6178 2875 7070 6572  r, 0), max(upper
-0001abf0: 2c20 3029 0a0a 0a63 6c61 7373 2053 7761  , 0)...class Swa
-0001ac00: 7049 6e66 6c61 7465 5461 6b65 2845 7661  pInflateTake(Eva
-0001ac10: 6c75 6162 6c65 293a 0a0a 2020 2020 6465  luable):..    de
-0001ac20: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
-0001ac30: 2069 6e66 6c61 7465 6964 782c 2074 616b   inflateidx, tak
-0001ac40: 6569 6478 293a 0a20 2020 2020 2020 2073  eidx):.        s
-0001ac50: 656c 662e 696e 666c 6174 6569 6478 203d  elf.inflateidx =
-0001ac60: 2069 6e66 6c61 7465 6964 780a 2020 2020   inflateidx.    
-0001ac70: 2020 2020 7365 6c66 2e74 616b 6569 6478      self.takeidx
-0001ac80: 203d 2074 616b 6569 6478 0a20 2020 2020   = takeidx.     
-0001ac90: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
-0001aca0: 745f 5f28 6172 6773 3d5b 696e 666c 6174  t__(args=[inflat
-0001acb0: 6569 6478 2c20 7461 6b65 6964 785d 290a  eidx, takeidx]).
-0001acc0: 0a20 2020 2064 6566 205f 5f69 7465 725f  .    def __iter_
-0001acd0: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
-0001ace0: 2073 6861 7065 203d 2041 7272 6179 4672   shape = ArrayFr
-0001acf0: 6f6d 5475 706c 6528 7365 6c66 2c20 696e  omTuple(self, in
-0001ad00: 6465 783d 322c 2073 6861 7065 3d28 292c  dex=2, shape=(),
-0001ad10: 2064 7479 7065 3d69 6e74 2c20 5f6c 6f77   dtype=int, _low
-0001ad20: 6572 3d30 292c 0a20 2020 2020 2020 2072  er=0),.        r
-0001ad30: 6574 7572 6e20 2841 7272 6179 4672 6f6d  eturn (ArrayFrom
-0001ad40: 5475 706c 6528 7365 6c66 2c20 696e 6465  Tuple(self, inde
-0001ad50: 783d 696e 6465 782c 2073 6861 7065 3d73  x=index, shape=s
-0001ad60: 6861 7065 2c20 6474 7970 653d 696e 742c  hape, dtype=int,
-0001ad70: 205f 6c6f 7765 723d 3029 2066 6f72 2069   _lower=0) for i
-0001ad80: 6e64 6578 2069 6e20 7261 6e67 6528 3229  ndex in range(2)
-0001ad90: 290a 0a20 2020 2064 6566 2065 7661 6c66  )..    def evalf
-0001ada0: 2873 656c 662c 2069 6e66 6c61 7465 6964  (self, inflateid
-0001adb0: 782c 2074 616b 6569 6478 293a 0a20 2020  x, takeidx):.   
-0001adc0: 2020 2020 2075 6e69 7175 6569 6e66 6c61       uniqueinfla
-0001add0: 7465 203d 205f 6973 756e 6971 7565 2869  te = _isunique(i
-0001ade0: 6e66 6c61 7465 6964 7829 0a20 2020 2020  nflateidx).     
-0001adf0: 2020 2075 6e69 7175 6574 616b 6520 3d20     uniquetake = 
-0001ae00: 5f69 7375 6e69 7175 6528 7461 6b65 6964  _isunique(takeid
-0001ae10: 7829 0a20 2020 2020 2020 2075 6e69 7175  x).        uniqu
-0001ae20: 6520 3d20 756e 6971 7565 696e 666c 6174  e = uniqueinflat
-0001ae30: 6520 616e 6420 756e 6971 7565 7461 6b65  e and uniquetake
-0001ae40: 0a20 2020 2020 2020 2023 2049 6620 626f  .        # If bo
-0001ae50: 7468 2069 6e64 6963 6573 2061 7265 2075  th indices are u
-0001ae60: 6e69 7175 6520 2869 2e65 2e20 7468 6579  nique (i.e. they
-0001ae70: 2064 6f20 6e6f 7420 636f 6e74 6169 6e20   do not contain 
-0001ae80: 6475 706c 6963 6174 6573 2920 7468 656e  duplicates) then
-0001ae90: 2074 6865 0a20 2020 2020 2020 2023 2074   the.        # t
-0001aea0: 616b 6520 616e 6420 696e 666c 6174 6520  ake and inflate 
-0001aeb0: 6f70 6572 6174 696f 6e73 2063 616e 2073  operations can s
-0001aec0: 696d 706c 7920 6265 2072 6573 7472 6963  imply be restric
-0001aed0: 7465 6420 746f 2074 6865 2069 6e74 6572  ted to the inter
-0001aee0: 7365 6374 696f 6e2c 0a20 2020 2020 2020  section,.       
-0001aef0: 2023 2077 6974 6820 7468 6520 7468 6520   # with the the 
-0001af00: 6c6f 6361 7469 6f6e 206f 6620 7468 6520  location of the 
-0001af10: 696e 7465 7273 6563 7469 6f6e 2069 6e20  intersection in 
-0001af20: 7468 6520 6f72 6967 696e 616c 2069 6e64  the original ind
-0001af30: 6578 2076 6563 746f 7273 0a20 2020 2020  ex vectors.     
-0001af40: 2020 2023 2062 6569 6e67 2074 6865 206e     # being the n
-0001af50: 6577 2069 6e64 6963 6573 2066 6f72 2074  ew indices for t
-0001af60: 6865 2073 7761 7070 6564 206f 7065 7261  he swapped opera
-0001af70: 7469 6f6e 732e 0a20 2020 2020 2020 2069  tions..        i
-0001af80: 6e74 6572 7365 6374 696f 6e2c 2073 7562  ntersection, sub
-0001af90: 696e 666c 6174 652c 2073 7562 7461 6b65  inflate, subtake
-0001afa0: 203d 206e 756d 7079 2e69 6e74 6572 7365   = numpy.interse
-0001afb0: 6374 3164 2869 6e66 6c61 7465 6964 782c  ct1d(inflateidx,
-0001afc0: 2074 616b 6569 6478 2c20 7265 7475 726e   takeidx, return
-0001afd0: 5f69 6e64 6963 6573 3d54 7275 652c 2061  _indices=True, a
-0001afe0: 7373 756d 655f 756e 6971 7565 3d75 6e69  ssume_unique=uni
-0001aff0: 7175 6529 0a20 2020 2020 2020 2069 6620  que).        if 
-0001b000: 756e 6971 7565 3a0a 2020 2020 2020 2020  unique:.        
-0001b010: 2020 2020 7265 7475 726e 2073 7562 696e      return subin
-0001b020: 666c 6174 652c 2073 7562 7461 6b65 2c20  flate, subtake, 
-0001b030: 6e75 6d70 792e 6172 7261 7928 6c65 6e28  numpy.array(len(
-0001b040: 696e 7465 7273 6563 7469 6f6e 2929 0a20  intersection)). 
-0001b050: 2020 2020 2020 2023 204f 7468 6572 7769         # Otherwi
-0001b060: 7365 2c20 7768 696c 6520 7374 696c 6c20  se, while still 
-0001b070: 6c69 6d69 7469 6e67 2074 6865 206f 7065  limiting the ope
-0001b080: 7261 7469 6f6e 7320 746f 2074 6865 2069  rations to the i
-0001b090: 6e74 6572 7365 6374 696f 6e2c 2077 650a  ntersection, we.
-0001b0a0: 2020 2020 2020 2020 2320 6e65 6564 2074          # need t
-0001b0b0: 6f20 6164 6420 7468 6520 6170 7072 6f70  o add the approp
-0001b0c0: 7269 6174 6520 6475 706c 6963 6174 696f  riate duplicatio
-0001b0d0: 6e73 206f 6e20 6569 7468 6572 2073 6964  ns on either sid
-0001b0e0: 652e 2054 6865 2065 6173 6965 7374 2077  e. The easiest w
-0001b0f0: 6179 0a20 2020 2020 2020 2023 2074 6f20  ay.        # to 
-0001b100: 646f 2074 6869 7320 6973 2074 6f20 666f  do this is to fo
-0001b110: 726d 2074 6865 2070 6572 6d75 7461 7469  rm the permutati
-0001b120: 6f6e 206d 6174 7269 7820 4120 666f 7220  on matrix A for 
-0001b130: 7461 6b65 2028 6d61 7920 636f 6e74 6169  take (may contai
-0001b140: 6e0a 2020 2020 2020 2020 2320 6d75 6c74  n.        # mult
-0001b150: 6970 6c65 2069 7465 6d73 2070 6572 2063  iple items per c
-0001b160: 6f6c 756d 6e29 2061 6e64 2042 2066 6f72  olumn) and B for
-0001b170: 2069 6e66 6c61 7465 2028 6d61 7920 636f   inflate (may co
-0001b180: 6e74 6169 6e20 7365 7665 7261 6c20 6974  ntain several it
-0001b190: 656d 730a 2020 2020 2020 2020 2320 7065  ems.        # pe
-0001b1a0: 7220 726f 7729 2061 6e64 2074 616b 6520  r row) and take 
-0001b1b0: 7468 6520 7072 6f64 7563 7420 4142 2066  the product AB f
-0001b1c0: 6f72 2074 6865 2063 6f6d 6269 6e65 6420  or the combined 
-0001b1d0: 6f70 6572 6174 696f 6e2e 2054 6f20 7468  operation. To th
-0001b1e0: 656e 0a20 2020 2020 2020 2023 2064 6563  en.        # dec
-0001b1f0: 6f6d 706f 7365 2041 4220 696e 746f 2074  ompose AB into t
-0001b200: 6865 2065 7175 6976 616c 656e 7420 7461  he equivalent ta
-0001b210: 6b65 2066 6f6c 6c6f 7765 6420 6279 2069  ke followed by i
-0001b220: 6e66 6c61 7465 2077 6520 6361 6e20 7369  nflate we can si
-0001b230: 6d70 6c79 0a20 2020 2020 2020 2023 2074  mply.        # t
-0001b240: 616b 6520 7468 6520 7477 6f20 696e 6465  ake the two inde
-0001b250: 7820 7665 6374 6f72 7320 6672 6f6d 2041  x vectors from A
-0001b260: 422e 6e6f 6e7a 6572 6f28 2920 616e 6420  B.nonzero() and 
-0001b270: 666f 726d 2043 4420 3d20 4142 2e20 5468  form CD = AB. Th
-0001b280: 650a 2020 2020 2020 2020 2320 616c 676f  e.        # algo
-0001b290: 7269 7468 6d20 6265 6c6f 7720 646f 6573  rithm below does
-0001b2a0: 2070 7265 6369 7365 6c79 2074 6869 7320   precisely this 
-0001b2b0: 7769 7468 6f75 7420 666f 726d 696e 6720  without forming 
-0001b2c0: 4142 2065 7870 6c69 6369 746c 792e 0a20  AB explicitly.. 
-0001b2d0: 2020 2020 2020 206e 6577 696e 666c 6174         newinflat
-0001b2e0: 6520 3d20 5b5d 0a20 2020 2020 2020 206e  e = [].        n
-0001b2f0: 6577 7461 6b65 203d 205b 5d0a 2020 2020  ewtake = [].    
-0001b300: 2020 2020 666f 7220 6b2c 206e 2069 6e20      for k, n in 
-0001b310: 656e 756d 6572 6174 6528 696e 7465 7273  enumerate(inters
-0001b320: 6563 7469 6f6e 293a 0a20 2020 2020 2020  ection):.       
-0001b330: 2020 2020 2066 6f72 2069 2069 6e20 5b73       for i in [s
-0001b340: 7562 7461 6b65 5b6b 5d5d 2069 6620 756e  ubtake[k]] if un
-0001b350: 6971 7565 7461 6b65 2065 6c73 6520 6e75  iquetake else nu
-0001b360: 6d70 792e 6571 7561 6c28 7461 6b65 6964  mpy.equal(takeid
-0001b370: 782e 7261 7665 6c28 292c 206e 292e 6e6f  x.ravel(), n).no
-0001b380: 6e7a 6572 6f28 295b 305d 3a0a 2020 2020  nzero()[0]:.    
-0001b390: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-0001b3a0: 6a20 696e 205b 7375 6269 6e66 6c61 7465  j in [subinflate
-0001b3b0: 5b6b 5d5d 2069 6620 756e 6971 7565 696e  [k]] if uniquein
-0001b3c0: 666c 6174 6520 656c 7365 206e 756d 7079  flate else numpy
-0001b3d0: 2e65 7175 616c 2869 6e66 6c61 7465 6964  .equal(inflateid
-0001b3e0: 782e 7261 7665 6c28 292c 206e 292e 6e6f  x.ravel(), n).no
-0001b3f0: 6e7a 6572 6f28 295b 305d 3a0a 2020 2020  nzero()[0]:.    
-0001b400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b410: 6e65 7769 6e66 6c61 7465 2e61 7070 656e  newinflate.appen
-0001b420: 6428 6929 0a20 2020 2020 2020 2020 2020  d(i).           
-0001b430: 2020 2020 2020 2020 206e 6577 7461 6b65           newtake
-0001b440: 2e61 7070 656e 6428 6a29 0a20 2020 2020  .append(j).     
-0001b450: 2020 2072 6574 7572 6e20 6e75 6d70 792e     return numpy.
-0001b460: 6172 7261 7928 6e65 7774 616b 652c 2064  array(newtake, d
-0001b470: 7479 7065 3d69 6e74 292c 206e 756d 7079  type=int), numpy
-0001b480: 2e61 7272 6179 286e 6577 696e 666c 6174  .array(newinflat
-0001b490: 652c 2064 7479 7065 3d69 6e74 292c 206e  e, dtype=int), n
-0001b4a0: 756d 7079 2e61 7272 6179 286c 656e 286e  umpy.array(len(n
-0001b4b0: 6577 7461 6b65 292c 2064 7479 7065 3d69  ewtake), dtype=i
-0001b4c0: 6e74 290a 0a0a 636c 6173 7320 4469 6167  nt)...class Diag
-0001b4d0: 6f6e 616c 697a 6528 4172 7261 7929 3a0a  onalize(Array):.
-0001b4e0: 0a20 2020 205f 5f73 6c6f 7473 5f5f 203d  .    __slots__ =
-0001b4f0: 2027 6675 6e63 270a 2020 2020 5f5f 6361   'func'.    __ca
-0001b500: 6368 655f 5f20 3d20 275f 6469 6167 6f6e  che__ = '_diagon
-0001b510: 616c 7327 0a0a 2020 2020 4074 7970 6573  als'..    @types
-0001b520: 2e61 7070 6c79 5f61 6e6e 6f74 6174 696f  .apply_annotatio
-0001b530: 6e73 0a20 2020 2064 6566 205f 5f69 6e69  ns.    def __ini
-0001b540: 745f 5f28 7365 6c66 2c20 6675 6e63 3a20  t__(self, func: 
-0001b550: 6173 6172 7261 7929 3a0a 2020 2020 2020  asarray):.      
-0001b560: 2020 6966 2066 756e 632e 6e64 696d 203d    if func.ndim =
-0001b570: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
-0001b580: 2072 6169 7365 2045 7863 6570 7469 6f6e   raise Exception
-0001b590: 2827 6361 6e6e 6f74 2064 6961 676f 6e61  ('cannot diagona
-0001b5a0: 6c69 7a65 2073 6361 6c61 7220 6675 6e63  lize scalar func
-0001b5b0: 7469 6f6e 2729 0a20 2020 2020 2020 2073  tion').        s
-0001b5c0: 656c 662e 6675 6e63 203d 2066 756e 630a  elf.func = func.
-0001b5d0: 2020 2020 2020 2020 7375 7065 7228 292e          super().
-0001b5e0: 5f5f 696e 6974 5f5f 2861 7267 733d 5b66  __init__(args=[f
-0001b5f0: 756e 635d 2c20 7368 6170 653d 282a 6675  unc], shape=(*fu
-0001b600: 6e63 2e73 6861 7065 2c20 6675 6e63 2e73  nc.shape, func.s
-0001b610: 6861 7065 5b2d 315d 292c 2064 7479 7065  hape[-1]), dtype
-0001b620: 3d66 756e 632e 6474 7970 6529 0a0a 2020  =func.dtype)..  
-0001b630: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-0001b640: 6465 6620 5f64 6961 676f 6e61 6c73 2873  def _diagonals(s
-0001b650: 656c 6629 3a0a 2020 2020 2020 2020 6469  elf):.        di
-0001b660: 6167 6f6e 616c 7320 3d20 5b66 726f 7a65  agonals = [froze
-0001b670: 6e73 6574 285b 7365 6c66 2e6e 6469 6d2d  nset([self.ndim-
-0001b680: 322c 2073 656c 662e 6e64 696d 2d31 5d29  2, self.ndim-1])
-0001b690: 5d0a 2020 2020 2020 2020 666f 7220 6178  ].        for ax
-0001b6a0: 6573 2069 6e20 7365 6c66 2e66 756e 632e  es in self.func.
-0001b6b0: 5f64 6961 676f 6e61 6c73 3a0a 2020 2020  _diagonals:.    
-0001b6c0: 2020 2020 2020 2020 6966 2061 7865 7320          if axes 
-0001b6d0: 2620 6469 6167 6f6e 616c 735b 305d 3a0a  & diagonals[0]:.
-0001b6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b6f0: 6469 6167 6f6e 616c 735b 305d 207c 3d20  diagonals[0] |= 
-0001b700: 6178 6573 0a20 2020 2020 2020 2020 2020  axes.           
-0001b710: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0001b720: 2020 2020 2020 2064 6961 676f 6e61 6c73         diagonals
-0001b730: 2e61 7070 656e 6428 6178 6573 290a 2020  .append(axes).  
-0001b740: 2020 2020 2020 7265 7475 726e 2074 7570        return tup
-0001b750: 6c65 2864 6961 676f 6e61 6c73 290a 0a20  le(diagonals).. 
-0001b760: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-0001b770: 2064 6566 205f 696e 666c 6174 696f 6e73   def _inflations
-0001b780: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0001b790: 7265 7475 726e 2074 7570 6c65 2828 6178  return tuple((ax
-0001b7a0: 6973 2c20 7479 7065 732e 6672 6f7a 656e  is, types.frozen
-0001b7b0: 6469 6374 2828 646f 666d 6170 2c20 4469  dict((dofmap, Di
-0001b7c0: 6167 6f6e 616c 697a 6528 6675 6e63 2929  agonalize(func))
-0001b7d0: 2066 6f72 2064 6f66 6d61 702c 2066 756e   for dofmap, fun
-0001b7e0: 6320 696e 2070 6172 7473 2e69 7465 6d73  c in parts.items
-0001b7f0: 2829 2929 0a20 2020 2020 2020 2020 2020  ())).           
-0001b800: 2020 2020 2020 2020 2020 666f 7220 6178            for ax
-0001b810: 6973 2c20 7061 7274 7320 696e 2073 656c  is, parts in sel
-0001b820: 662e 6675 6e63 2e5f 696e 666c 6174 696f  f.func._inflatio
-0001b830: 6e73 0a20 2020 2020 2020 2020 2020 2020  ns.             
-0001b840: 2020 2020 2020 2020 6966 2061 7869 7320          if axis 
-0001b850: 3c20 7365 6c66 2e6e 6469 6d2d 3229 0a0a  < self.ndim-2)..
-0001b860: 2020 2020 6465 6620 5f73 696d 706c 6966      def _simplif
-0001b870: 6965 6428 7365 6c66 293a 0a20 2020 2020  ied(self):.     
-0001b880: 2020 2069 6620 7365 6c66 2e73 6861 7065     if self.shape
-0001b890: 5b2d 315d 203d 3d20 313a 0a20 2020 2020  [-1] == 1:.     
-0001b8a0: 2020 2020 2020 2072 6574 7572 6e20 496e         return In
-0001b8b0: 7365 7274 4178 6973 2873 656c 662e 6675  sertAxis(self.fu
-0001b8c0: 6e63 2c20 3129 0a20 2020 2020 2020 2072  nc, 1).        r
-0001b8d0: 6574 7572 6e20 7365 6c66 2e66 756e 632e  eturn self.func.
-0001b8e0: 5f64 6961 676f 6e61 6c69 7a65 2873 656c  _diagonalize(sel
-0001b8f0: 662e 6e64 696d 2d32 290a 0a20 2020 2064  f.ndim-2)..    d
-0001b900: 6566 2065 7661 6c66 2873 656c 662c 2061  ef evalf(self, a
-0001b910: 7272 293a 0a20 2020 2020 2020 2072 6573  rr):.        res
-0001b920: 756c 7420 3d20 6e75 6d70 792e 7a65 726f  ult = numpy.zero
-0001b930: 7328 6172 722e 7368 6170 652b 2861 7272  s(arr.shape+(arr
-0001b940: 2e73 6861 7065 5b2d 315d 2c29 2c20 6474  .shape[-1],), dt
-0001b950: 7970 653d 6172 722e 6474 7970 652c 206f  ype=arr.dtype, o
-0001b960: 7264 6572 3d27 4627 290a 2020 2020 2020  rder='F').      
-0001b970: 2020 6469 6167 203d 206e 756d 7079 2e63    diag = numpy.c
-0001b980: 6f72 652e 6d75 6c74 6961 7272 6179 2e63  ore.multiarray.c
-0001b990: 5f65 696e 7375 6d28 272e 2e2e 6969 2d3e  _einsum('...ii->
-0001b9a0: 2e2e 2e69 272c 2072 6573 756c 7429 0a20  ...i', result). 
-0001b9b0: 2020 2020 2020 2064 6961 675b 3a5d 203d         diag[:] =
-0001b9c0: 2061 7272 0a20 2020 2020 2020 2072 6574   arr.        ret
-0001b9d0: 7572 6e20 7265 7375 6c74 0a0a 2020 2020  urn result..    
-0001b9e0: 6465 6620 5f64 6572 6976 6174 6976 6528  def _derivative(
-0001b9f0: 7365 6c66 2c20 7661 722c 2073 6565 6e29  self, var, seen)
-0001ba00: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-0001ba10: 2064 6961 676f 6e61 6c69 7a65 2864 6572   diagonalize(der
-0001ba20: 6976 6174 6976 6528 7365 6c66 2e66 756e  ivative(self.fun
-0001ba30: 632c 2076 6172 2c20 7365 656e 292c 2073  c, var, seen), s
-0001ba40: 656c 662e 6e64 696d 2d32 2c20 7365 6c66  elf.ndim-2, self
-0001ba50: 2e6e 6469 6d2d 3129 0a0a 2020 2020 6465  .ndim-1)..    de
-0001ba60: 6620 5f69 6e76 6572 7365 2873 656c 662c  f _inverse(self,
-0001ba70: 2061 7869 7331 2c20 6178 6973 3229 3a0a   axis1, axis2):.
-0001ba80: 2020 2020 2020 2020 6966 2073 6f72 7465          if sorte
-0001ba90: 6428 5b61 7869 7331 2c20 6178 6973 325d  d([axis1, axis2]
-0001baa0: 2920 3d3d 205b 7365 6c66 2e6e 6469 6d2d  ) == [self.ndim-
-0001bab0: 322c 2073 656c 662e 6e64 696d 2d31 5d3a  2, self.ndim-1]:
-0001bac0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0001bad0: 7572 6e20 4469 6167 6f6e 616c 697a 6528  urn Diagonalize(
-0001bae0: 7265 6369 7072 6f63 616c 2873 656c 662e  reciprocal(self.
-0001baf0: 6675 6e63 2929 0a0a 2020 2020 6465 6620  func))..    def 
-0001bb00: 5f64 6574 6572 6d69 6e61 6e74 2873 656c  _determinant(sel
-0001bb10: 662c 2061 7869 7331 2c20 6178 6973 3229  f, axis1, axis2)
-0001bb20: 3a0a 2020 2020 2020 2020 6966 2073 6f72  :.        if sor
-0001bb30: 7465 6428 5b61 7869 7331 2c20 6178 6973  ted([axis1, axis
-0001bb40: 325d 2920 3d3d 205b 7365 6c66 2e6e 6469  2]) == [self.ndi
-0001bb50: 6d2d 322c 2073 656c 662e 6e64 696d 2d31  m-2, self.ndim-1
-0001bb60: 5d3a 0a20 2020 2020 2020 2020 2020 2072  ]:.            r
-0001bb70: 6574 7572 6e20 5072 6f64 7563 7428 7365  eturn Product(se
-0001bb80: 6c66 2e66 756e 6329 0a20 2020 2020 2020  lf.func).       
-0001bb90: 2065 6c69 6620 6178 6973 3120 3c20 7365   elif axis1 < se
-0001bba0: 6c66 2e6e 6469 6d2d 3220 616e 6420 6178  lf.ndim-2 and ax
-0001bbb0: 6973 3220 3c20 7365 6c66 2e6e 6469 6d2d  is2 < self.ndim-
-0001bbc0: 323a 0a20 2020 2020 2020 2020 2020 2072  2:.            r
-0001bbd0: 6574 7572 6e20 4469 6167 6f6e 616c 697a  eturn Diagonaliz
-0001bbe0: 6528 6465 7465 726d 696e 616e 7428 7365  e(determinant(se
-0001bbf0: 6c66 2e66 756e 632c 2028 6178 6973 312c  lf.func, (axis1,
-0001bc00: 2061 7869 7332 2929 290a 0a20 2020 2064   axis2)))..    d
-0001bc10: 6566 205f 7375 6d28 7365 6c66 2c20 6178  ef _sum(self, ax
-0001bc20: 6973 293a 0a20 2020 2020 2020 2069 6620  is):.        if 
-0001bc30: 6178 6973 203e 3d20 7365 6c66 2e6e 6469  axis >= self.ndi
-0001bc40: 6d20 2d20 323a 0a20 2020 2020 2020 2020  m - 2:.         
-0001bc50: 2020 2072 6574 7572 6e20 7365 6c66 2e66     return self.f
-0001bc60: 756e 630a 2020 2020 2020 2020 7265 7475  unc.        retu
-0001bc70: 726e 2044 6961 676f 6e61 6c69 7a65 2873  rn Diagonalize(s
-0001bc80: 756d 2873 656c 662e 6675 6e63 2c20 6178  um(self.func, ax
-0001bc90: 6973 2929 0a0a 2020 2020 6465 6620 5f74  is))..    def _t
-0001bca0: 616b 6564 6961 6728 7365 6c66 2c20 6178  akediag(self, ax
-0001bcb0: 6973 312c 2061 7869 7332 293a 0a20 2020  is1, axis2):.   
-0001bcc0: 2020 2020 2069 6620 6178 6973 3120 3d3d       if axis1 ==
-0001bcd0: 2073 656c 662e 6e64 696d 2d32 3a20 2023   self.ndim-2:  #
-0001bce0: 2061 7869 7332 203d 3d20 7365 6c66 2e6e   axis2 == self.n
-0001bcf0: 6469 6d2d 310a 2020 2020 2020 2020 2020  dim-1.          
-0001bd00: 2020 7265 7475 726e 2073 656c 662e 6675    return self.fu
-0001bd10: 6e63 0a20 2020 2020 2020 2065 6c69 6620  nc.        elif 
-0001bd20: 6178 6973 3220 3e3d 2073 656c 662e 6e64  axis2 >= self.nd
-0001bd30: 696d 2d32 3a0a 2020 2020 2020 2020 2020  im-2:.          
-0001bd40: 2020 7265 7475 726e 2064 6961 676f 6e61    return diagona
-0001bd50: 6c69 7a65 285f 7461 6b65 6469 6167 2873  lize(_takediag(s
-0001bd60: 656c 662e 6675 6e63 2c20 6178 6973 312c  elf.func, axis1,
-0001bd70: 2073 656c 662e 6e64 696d 2d32 292c 2073   self.ndim-2), s
-0001bd80: 656c 662e 6e64 696d 2d33 2c20 7365 6c66  elf.ndim-3, self
-0001bd90: 2e6e 6469 6d2d 3229 0a20 2020 2020 2020  .ndim-2).       
-0001bda0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0001bdb0: 2020 2072 6574 7572 6e20 6469 6167 6f6e     return diagon
-0001bdc0: 616c 697a 6528 5f74 616b 6564 6961 6728  alize(_takediag(
-0001bdd0: 7365 6c66 2e66 756e 632c 2061 7869 7331  self.func, axis1
-0001bde0: 2c20 6178 6973 3229 2c20 7365 6c66 2e6e  , axis2), self.n
-0001bdf0: 6469 6d2d 342c 2073 656c 662e 6e64 696d  dim-4, self.ndim
-0001be00: 2d33 290a 0a20 2020 2064 6566 205f 7461  -3)..    def _ta
-0001be10: 6b65 2873 656c 662c 2069 6e64 6578 2c20  ke(self, index, 
-0001be20: 6178 6973 293a 0a20 2020 2020 2020 2069  axis):.        i
-0001be30: 6620 6178 6973 203c 2073 656c 662e 6e64  f axis < self.nd
-0001be40: 696d 202d 2032 3a0a 2020 2020 2020 2020  im - 2:.        
-0001be50: 2020 2020 7265 7475 726e 2044 6961 676f      return Diago
-0001be60: 6e61 6c69 7a65 285f 7461 6b65 2873 656c  nalize(_take(sel
-0001be70: 662e 6675 6e63 2c20 696e 6465 782c 2061  f.func, index, a
-0001be80: 7869 7329 290a 2020 2020 2020 2020 6675  xis)).        fu
-0001be90: 6e63 203d 205f 7461 6b65 2873 656c 662e  nc = _take(self.
-0001bea0: 6675 6e63 2c20 696e 6465 782c 2073 656c  func, index, sel
-0001beb0: 662e 6e64 696d 2d32 290a 2020 2020 2020  f.ndim-2).      
-0001bec0: 2020 666f 7220 6920 696e 2072 616e 6765    for i in range
-0001bed0: 2869 6e64 6578 2e6e 6469 6d29 3a0a 2020  (index.ndim):.  
-0001bee0: 2020 2020 2020 2020 2020 6675 6e63 203d            func =
-0001bef0: 2064 6961 676f 6e61 6c69 7a65 2866 756e   diagonalize(fun
-0001bf00: 632c 2073 656c 662e 6e64 696d 2d32 2b69  c, self.ndim-2+i
-0001bf10: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-0001bf20: 205f 696e 666c 6174 6528 6675 6e63 2c20   _inflate(func, 
-0001bf30: 696e 6465 782c 2073 656c 662e 6675 6e63  index, self.func
-0001bf40: 2e73 6861 7065 5b2d 315d 2c20 7365 6c66  .shape[-1], self
-0001bf50: 2e6e 6469 6d2d 3220 6966 2061 7869 7320  .ndim-2 if axis 
-0001bf60: 3d3d 2073 656c 662e 6e64 696d 2d31 2065  == self.ndim-1 e
-0001bf70: 6c73 6520 7365 6c66 2e6e 6469 6d2d 322b  lse self.ndim-2+
-0001bf80: 696e 6465 782e 6e64 696d 290a 0a20 2020  index.ndim)..   
-0001bf90: 2064 6566 205f 756e 7261 7665 6c28 7365   def _unravel(se
-0001bfa0: 6c66 2c20 6178 6973 2c20 7368 6170 6529  lf, axis, shape)
-0001bfb0: 3a0a 2020 2020 2020 2020 6966 2061 7869  :.        if axi
-0001bfc0: 7320 3e3d 2073 656c 662e 6e64 696d 202d  s >= self.ndim -
-0001bfd0: 2032 3a0a 2020 2020 2020 2020 2020 2020   2:.            
-0001bfe0: 6469 6167 203d 2064 6961 676f 6e61 6c69  diag = diagonali
-0001bff0: 7a65 2864 6961 676f 6e61 6c69 7a65 2855  ze(diagonalize(U
-0001c000: 6e72 6176 656c 2873 656c 662e 6675 6e63  nravel(self.func
-0001c010: 2c20 2a73 6861 7065 292c 2073 656c 662e  , *shape), self.
-0001c020: 6e64 696d 2d32 2c20 7365 6c66 2e6e 6469  ndim-2, self.ndi
-0001c030: 6d29 2c20 7365 6c66 2e6e 6469 6d2d 312c  m), self.ndim-1,
-0001c040: 2073 656c 662e 6e64 696d 2b31 290a 2020   self.ndim+1).  
-0001c050: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001c060: 2072 6176 656c 2864 6961 672c 2073 656c   ravel(diag, sel
-0001c070: 662e 6e64 696d 2069 6620 6178 6973 203d  f.ndim if axis =
-0001c080: 3d20 7365 6c66 2e6e 6469 6d2d 3220 656c  = self.ndim-2 el
-0001c090: 7365 2073 656c 662e 6e64 696d 2d32 290a  se self.ndim-2).
-0001c0a0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0001c0b0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001c0c0: 2044 6961 676f 6e61 6c69 7a65 2875 6e72   Diagonalize(unr
-0001c0d0: 6176 656c 2873 656c 662e 6675 6e63 2c20  avel(self.func, 
-0001c0e0: 6178 6973 2c20 7368 6170 6529 290a 0a20  axis, shape)).. 
-0001c0f0: 2020 2064 6566 205f 7369 676e 2873 656c     def _sign(sel
-0001c100: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
-0001c110: 726e 2044 6961 676f 6e61 6c69 7a65 2853  rn Diagonalize(S
-0001c120: 6967 6e28 7365 6c66 2e66 756e 6329 290a  ign(self.func)).
-0001c130: 0a20 2020 2064 6566 205f 7072 6f64 7563  .    def _produc
-0001c140: 7428 7365 6c66 293a 0a20 2020 2020 2020  t(self):.       
-0001c150: 2069 6620 6e75 6d65 7269 632e 6973 696e   if numeric.isin
-0001c160: 7428 7365 6c66 2e73 6861 7065 5b2d 315d  t(self.shape[-1]
-0001c170: 2920 616e 6420 7365 6c66 2e73 6861 7065  ) and self.shape
-0001c180: 5b2d 315d 203e 2031 3a0a 2020 2020 2020  [-1] > 1:.      
-0001c190: 2020 2020 2020 7265 7475 726e 205a 6572        return Zer
-0001c1a0: 6f73 2873 656c 662e 7368 6170 655b 3a2d  os(self.shape[:-
-0001c1b0: 315d 2c20 6474 7970 653d 7365 6c66 2e64  1], dtype=self.d
-0001c1c0: 7479 7065 290a 0a20 2020 2064 6566 205f  type)..    def _
-0001c1d0: 6c6f 6f70 7375 6d28 7365 6c66 2c20 696e  loopsum(self, in
-0001c1e0: 6465 7829 3a0a 2020 2020 2020 2020 7265  dex):.        re
-0001c1f0: 7475 726e 2044 6961 676f 6e61 6c69 7a65  turn Diagonalize
-0001c200: 286c 6f6f 705f 7375 6d28 7365 6c66 2e66  (loop_sum(self.f
-0001c210: 756e 632c 2069 6e64 6578 2929 0a0a 2020  unc, index))..  
-0001c220: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-0001c230: 6465 6620 5f61 7373 7061 7273 6528 7365  def _assparse(se
-0001c240: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-0001c250: 7572 6e20 7475 706c 6528 282a 696e 6469  urn tuple((*indi
-0001c260: 6365 732c 2069 6e64 6963 6573 5b2d 315d  ces, indices[-1]
-0001c270: 2c20 7661 6c75 6573 2920 666f 7220 2a69  , values) for *i
-0001c280: 6e64 6963 6573 2c20 7661 6c75 6573 2069  ndices, values i
-0001c290: 6e20 7365 6c66 2e66 756e 632e 5f61 7373  n self.func._ass
-0001c2a0: 7061 7273 6529 0a0a 0a63 6c61 7373 2047  parse)...class G
-0001c2b0: 7561 7264 2841 7272 6179 293a 0a20 2020  uard(Array):.   
-0001c2c0: 2027 6261 7220 616c 6c20 7369 6d70 6c69   'bar all simpli
-0001c2d0: 6669 6361 7469 6f6e 7327 0a0a 2020 2020  fications'..    
-0001c2e0: 5f5f 736c 6f74 735f 5f20 3d20 2766 756e  __slots__ = 'fun
-0001c2f0: 272c 0a0a 2020 2020 4074 7970 6573 2e61  ',..    @types.a
-0001c300: 7070 6c79 5f61 6e6e 6f74 6174 696f 6e73  pply_annotations
-0001c310: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-0001c320: 5f28 7365 6c66 2c20 6675 6e3a 2061 7361  _(self, fun: asa
-0001c330: 7272 6179 293a 0a20 2020 2020 2020 2073  rray):.        s
-0001c340: 656c 662e 6675 6e20 3d20 6675 6e0a 2020  elf.fun = fun.  
-0001c350: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
-0001c360: 696e 6974 5f5f 2861 7267 733d 5b66 756e  init__(args=[fun
-0001c370: 5d2c 2073 6861 7065 3d66 756e 2e73 6861  ], shape=fun.sha
-0001c380: 7065 2c20 6474 7970 653d 6675 6e2e 6474  pe, dtype=fun.dt
-0001c390: 7970 6529 0a0a 2020 2020 4070 726f 7065  ype)..    @prope
-0001c3a0: 7274 790a 2020 2020 6465 6620 6973 636f  rty.    def isco
-0001c3b0: 6e73 7461 6e74 2873 656c 6629 3a0a 2020  nstant(self):.  
-0001c3c0: 2020 2020 2020 7265 7475 726e 2046 616c        return Fal
-0001c3d0: 7365 2020 2320 6176 6f69 6420 7369 6d70  se  # avoid simp
-0001c3e0: 6c69 6669 6361 7469 6f6e 7320 6261 7365  lifications base
-0001c3f0: 6420 6f6e 2066 756e 2062 6569 6e67 2063  d on fun being c
-0001c400: 6f6e 7374 616e 740a 0a20 2020 2040 7374  onstant..    @st
-0001c410: 6174 6963 6d65 7468 6f64 0a20 2020 2064  aticmethod.    d
-0001c420: 6566 2065 7661 6c66 2864 6174 293a 0a20  ef evalf(dat):. 
-0001c430: 2020 2020 2020 2072 6574 7572 6e20 6461         return da
-0001c440: 740a 0a20 2020 2064 6566 205f 6465 7269  t..    def _deri
-0001c450: 7661 7469 7665 2873 656c 662c 2076 6172  vative(self, var
-0001c460: 2c20 7365 656e 293a 0a20 2020 2020 2020  , seen):.       
-0001c470: 2072 6574 7572 6e20 4775 6172 6428 6465   return Guard(de
-0001c480: 7269 7661 7469 7665 2873 656c 662e 6675  rivative(self.fu
-0001c490: 6e2c 2076 6172 2c20 7365 656e 2929 0a0a  n, var, seen))..
-0001c4a0: 0a63 6c61 7373 2046 696e 6428 4172 7261  .class Find(Arra
-0001c4b0: 7929 3a0a 2020 2020 2769 6e64 6963 6573  y):.    'indices
-0001c4c0: 206f 6620 626f 6f6c 6561 6e20 696e 6465   of boolean inde
-0001c4d0: 7820 7665 6374 6f72 270a 0a20 2020 205f  x vector'..    _
-0001c4e0: 5f73 6c6f 7473 5f5f 203d 2027 7768 6572  _slots__ = 'wher
-0001c4f0: 6527 2c0a 0a20 2020 2040 7479 7065 732e  e',..    @types.
-0001c500: 6170 706c 795f 616e 6e6f 7461 7469 6f6e  apply_annotation
-0001c510: 730a 2020 2020 6465 6620 5f5f 696e 6974  s.    def __init
-0001c520: 5f5f 2873 656c 662c 2077 6865 7265 3a20  __(self, where: 
-0001c530: 6173 6172 7261 7929 3a0a 2020 2020 2020  asarray):.      
-0001c540: 2020 6173 7365 7274 2069 7361 7272 6179    assert isarray
-0001c550: 2877 6865 7265 2920 616e 6420 7768 6572  (where) and wher
-0001c560: 652e 6e64 696d 203d 3d20 3120 616e 6420  e.ndim == 1 and 
-0001c570: 7768 6572 652e 6474 7970 6520 3d3d 2062  where.dtype == b
-0001c580: 6f6f 6c0a 2020 2020 2020 2020 7365 6c66  ool.        self
-0001c590: 2e77 6865 7265 203d 2077 6865 7265 0a20  .where = where. 
-0001c5a0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
-0001c5b0: 5f69 6e69 745f 5f28 6172 6773 3d5b 7768  _init__(args=[wh
-0001c5c0: 6572 655d 2c20 7368 6170 653d 5b53 756d  ere], shape=[Sum
-0001c5d0: 2842 6f6f 6c54 6f49 6e74 2877 6865 7265  (BoolToInt(where
-0001c5e0: 2929 5d2c 2064 7479 7065 3d69 6e74 290a  ))], dtype=int).
-0001c5f0: 0a20 2020 2064 6566 2065 7661 6c66 2873  .    def evalf(s
-0001c600: 656c 662c 2077 6865 7265 293a 0a20 2020  elf, where):.   
-0001c610: 2020 2020 2072 6574 7572 6e20 7768 6572       return wher
-0001c620: 652e 6e6f 6e7a 6572 6f28 295b 305d 0a0a  e.nonzero()[0]..
-0001c630: 2020 2020 6465 6620 5f73 696d 706c 6966      def _simplif
-0001c640: 6965 6428 7365 6c66 293a 0a20 2020 2020  ied(self):.     
-0001c650: 2020 2069 6620 7365 6c66 2e69 7363 6f6e     if self.iscon
-0001c660: 7374 616e 743a 0a20 2020 2020 2020 2020  stant:.         
-0001c670: 2020 2072 6574 7572 6e20 436f 6e73 7461     return Consta
-0001c680: 6e74 2873 656c 662e 6576 616c 2829 290a  nt(self.eval()).
-0001c690: 0a0a 636c 6173 7320 4465 7269 7661 7469  ..class Derivati
-0001c6a0: 7665 5461 7267 6574 4261 7365 2841 7272  veTargetBase(Arr
-0001c6b0: 6179 293a 0a20 2020 2027 6261 7365 2063  ay):.    'base c
-0001c6c0: 6c61 7373 2066 6f72 2064 6572 6976 6174  lass for derivat
-0001c6d0: 6976 6520 7461 7267 6574 7327 0a0a 2020  ive targets'..  
-0001c6e0: 2020 5f5f 736c 6f74 735f 5f20 3d20 2829    __slots__ = ()
-0001c6f0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-0001c700: 2020 2020 6465 6620 6973 636f 6e73 7461      def isconsta
-0001c710: 6e74 2873 656c 6629 3a0a 2020 2020 2020  nt(self):.      
-0001c720: 2020 7265 7475 726e 2046 616c 7365 0a0a    return False..
-0001c730: 0a63 6c61 7373 2057 6974 6844 6572 6976  .class WithDeriv
-0001c740: 6174 6976 6528 4172 7261 7929 3a0a 2020  ative(Array):.  
-0001c750: 2020 2727 2757 7261 7020 7468 6520 6769    '''Wrap the gi
-0001c760: 7665 6e20 6675 6e63 7469 6f6e 2061 6e64  ven function and
-0001c770: 2064 6566 696e 6520 7468 6520 6465 7269   define the deri
-0001c780: 7661 7469 7665 2074 6f20 6120 7461 7267  vative to a targ
-0001c790: 6574 2e0a 0a20 2020 2054 6865 2077 7261  et...    The wra
-0001c7a0: 7070 6572 2069 7320 7479 7069 6361 6c6c  pper is typicall
-0001c7b0: 7920 7573 6564 2074 6f67 6574 6865 7220  y used together 
-0001c7c0: 7769 7468 2061 2076 6972 7475 616c 2064  with a virtual d
-0001c7d0: 6572 6976 6174 6976 6520 7461 7267 6574  erivative target
-0001c7e0: 206c 696b 650a 2020 2020 3a63 6c61 7373   like.    :class
-0001c7f0: 3a60 4964 656e 7469 6669 6572 4465 7269  :`IdentifierDeri
-0001c800: 7661 7469 7665 5461 7267 6574 602e 2054  vativeTarget`. T
-0001c810: 6865 2077 7261 7070 6572 2069 7320 7265  he wrapper is re
-0001c820: 6d6f 7665 6420 696e 2074 6865 2073 696d  moved in the sim
-0001c830: 706c 6966 6965 640a 2020 2020 666f 726d  plified.    form
-0001c840: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
-0001c850: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
-0001c860: 0a20 2020 2066 756e 6320 3a20 3a63 6c61  .    func : :cla
-0001c870: 7373 3a60 4172 7261 7960 0a20 2020 2020  ss:`Array`.     
-0001c880: 2020 2054 6865 2066 756e 6374 696f 6e20     The function 
-0001c890: 746f 2077 7261 702e 0a20 2020 2076 6172  to wrap..    var
-0001c8a0: 203a 203a 636c 6173 733a 6044 6572 6976   : :class:`Deriv
-0001c8b0: 6174 6976 6554 6172 6765 7442 6173 6560  ativeTargetBase`
-0001c8c0: 0a20 2020 2020 2020 2054 6865 2064 6572  .        The der
-0001c8d0: 6976 6174 6976 6520 7461 7267 6574 2e0a  ivative target..
-0001c8e0: 2020 2020 6465 7269 7661 7469 7665 203a      derivative :
-0001c8f0: 203a 636c 6173 733a 6041 7272 6179 600a   :class:`Array`.
-0001c900: 2020 2020 2020 2020 5468 6520 6465 7269          The deri
-0001c910: 7661 7469 7665 2077 6974 6820 7368 6170  vative with shap
-0001c920: 6520 6060 6675 6e63 2e73 6861 7065 202b  e ``func.shape +
-0001c930: 2076 6172 2e73 6861 7065 6060 2e0a 0a20   var.shape``... 
-0001c940: 2020 2053 6565 2041 6c73 6f0a 2020 2020     See Also.    
-0001c950: 2d2d 2d2d 2d2d 2d2d 0a20 2020 203a 636c  --------.    :cl
-0001c960: 6173 733a 6049 6465 6e74 6966 6965 7244  ass:`IdentifierD
-0001c970: 6572 6976 6174 6976 6554 6172 6765 7460  erivativeTarget`
-0001c980: 203a 2061 2076 6972 7475 616c 2064 6572   : a virtual der
-0001c990: 6976 6174 6976 6520 7461 7267 6574 0a20  ivative target. 
-0001c9a0: 2020 2027 2727 0a0a 2020 2020 5f5f 736c     '''..    __sl
-0001c9b0: 6f74 735f 5f20 3d20 275f 6675 6e63 272c  ots__ = '_func',
-0001c9c0: 2027 5f76 6172 272c 2027 5f64 6572 6976   '_var', '_deriv
-0001c9d0: 270a 0a20 2020 2064 6566 205f 5f69 6e69  '..    def __ini
-0001c9e0: 745f 5f28 7365 6c66 2c20 6675 6e63 3a20  t__(self, func: 
-0001c9f0: 4172 7261 792c 2076 6172 3a20 4465 7269  Array, var: Deri
-0001ca00: 7661 7469 7665 5461 7267 6574 4261 7365  vativeTargetBase
-0001ca10: 2c20 6465 7269 7661 7469 7665 3a20 4172  , derivative: Ar
-0001ca20: 7261 7929 202d 3e20 4e6f 6e65 3a0a 2020  ray) -> None:.  
-0001ca30: 2020 2020 2020 7365 6c66 2e5f 6675 6e63        self._func
-0001ca40: 203d 2066 756e 630a 2020 2020 2020 2020   = func.        
-0001ca50: 7365 6c66 2e5f 7661 7220 3d20 7661 720a  self._var = var.
-0001ca60: 2020 2020 2020 2020 7365 6c66 2e5f 6465          self._de
-0001ca70: 7269 7620 3d20 6465 7269 7661 7469 7665  riv = derivative
-0001ca80: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
-0001ca90: 2e5f 5f69 6e69 745f 5f28 6172 6773 3d28  .__init__(args=(
-0001caa0: 6675 6e63 2c29 2c20 7368 6170 653d 6675  func,), shape=fu
-0001cab0: 6e63 2e73 6861 7065 2c20 6474 7970 653d  nc.shape, dtype=
-0001cac0: 6675 6e63 2e64 7479 7065 290a 0a20 2020  func.dtype)..   
-0001cad0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-0001cae0: 6566 2061 7267 756d 656e 7473 2873 656c  ef arguments(sel
-0001caf0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
-0001cb00: 726e 2073 656c 662e 5f66 756e 632e 6172  rn self._func.ar
-0001cb10: 6775 6d65 6e74 7320 7c20 7b73 656c 662e  guments | {self.
-0001cb20: 5f76 6172 7d0a 0a20 2020 2064 6566 2065  _var}..    def e
-0001cb30: 7661 6c66 2873 656c 662c 2066 756e 633a  valf(self, func:
-0001cb40: 206e 756d 7079 2e6e 6461 7272 6179 2920   numpy.ndarray) 
-0001cb50: 2d3e 206e 756d 7079 2e6e 6461 7272 6179  -> numpy.ndarray
-0001cb60: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-0001cb70: 2066 756e 630a 0a20 2020 2064 6566 205f   func..    def _
-0001cb80: 6465 7269 7661 7469 7665 2873 656c 662c  derivative(self,
-0001cb90: 2076 6172 3a20 4465 7269 7661 7469 7665   var: Derivative
-0001cba0: 5461 7267 6574 4261 7365 2c20 7365 656e  TargetBase, seen
-0001cbb0: 2920 2d3e 2041 7272 6179 3a0a 2020 2020  ) -> Array:.    
-0001cbc0: 2020 2020 6966 2076 6172 203d 3d20 7365      if var == se
-0001cbd0: 6c66 2e5f 7661 723a 0a20 2020 2020 2020  lf._var:.       
-0001cbe0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001cbf0: 2e5f 6465 7269 760a 2020 2020 2020 2020  ._deriv.        
-0001cc00: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0001cc10: 2020 7265 7475 726e 2064 6572 6976 6174    return derivat
-0001cc20: 6976 6528 7365 6c66 2e5f 6675 6e63 2c20  ive(self._func, 
-0001cc30: 7661 722c 2073 6565 6e29 0a0a 2020 2020  var, seen)..    
-0001cc40: 6465 6620 5f73 696d 706c 6966 6965 6428  def _simplified(
-0001cc50: 7365 6c66 2920 2d3e 2041 7272 6179 3a0a  self) -> Array:.
-0001cc60: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0001cc70: 656c 662e 5f66 756e 630a 0a0a 636c 6173  elf._func...clas
-0001cc80: 7320 4172 6775 6d65 6e74 2844 6572 6976  s Argument(Deriv
-0001cc90: 6174 6976 6554 6172 6765 7442 6173 6529  ativeTargetBase)
-0001cca0: 3a0a 2020 2020 2727 2741 7272 6179 2061  :.    '''Array a
-0001ccb0: 7267 756d 656e 742c 2074 6f20 6265 2073  rgument, to be s
-0001ccc0: 7562 7374 6974 7574 6564 2062 6566 6f72  ubstituted befor
-0001ccd0: 6520 6576 616c 7561 7469 6f6e 2e0a 0a20  e evaluation... 
-0001cce0: 2020 2054 6865 203a 636c 6173 733a 6041     The :class:`A
-0001ccf0: 7267 756d 656e 7460 2069 7320 616e 203a  rgument` is an :
-0001cd00: 636c 6173 733a 6041 7272 6179 6020 7769  class:`Array` wi
-0001cd10: 7468 2061 206b 6e6f 776e 2073 6861 7065  th a known shape
-0001cd20: 2c20 6275 7420 7768 6f73 650a 2020 2020  , but whose.    
-0001cd30: 7661 6c75 6573 2061 7265 2074 6f20 6265  values are to be
-0001cd40: 2064 6566 696e 6564 206c 6174 6572 2c20   defined later, 
-0001cd50: 6265 666f 7265 2065 7661 6c75 6174 696f  before evaluatio
-0001cd60: 6e2c 2065 2e67 2e20 7573 696e 670a 2020  n, e.g. using.  
-0001cd70: 2020 3a66 756e 633a 6072 6570 6c61 6365    :func:`replace
-0001cd80: 5f61 7267 756d 656e 7473 602e 0a0a 2020  _arguments`...  
-0001cd90: 2020 4974 2069 7320 706f 7373 6962 6c65    It is possible
-0001cda0: 2074 6f20 7461 6b65 2074 6865 2064 6572   to take the der
-0001cdb0: 6976 6174 6976 6520 6f66 2061 6e20 3a63  ivative of an :c
-0001cdc0: 6c61 7373 3a60 4172 7261 7960 2074 6f20  lass:`Array` to 
-0001cdd0: 616e 0a20 2020 203a 636c 6173 733a 6041  an.    :class:`A
-0001cde0: 7267 756d 656e 7460 3a0a 0a20 2020 203e  rgument`:..    >
-0001cdf0: 3e3e 2066 726f 6d20 6e75 7469 6c73 2069  >> from nutils i
-0001ce00: 6d70 6f72 7420 6576 616c 7561 626c 650a  mport evaluable.
-0001ce10: 2020 2020 3e3e 3e20 6120 3d20 6576 616c      >>> a = eval
-0001ce20: 7561 626c 652e 4172 6775 6d65 6e74 2827  uable.Argument('
-0001ce30: 7827 2c20 5b5d 290a 2020 2020 3e3e 3e20  x', []).    >>> 
-0001ce40: 6220 3d20 6576 616c 7561 626c 652e 4172  b = evaluable.Ar
-0001ce50: 6775 6d65 6e74 2827 7927 2c20 5b5d 290a  gument('y', []).
-0001ce60: 2020 2020 3e3e 3e20 6620 3d20 612a 2a33      >>> f = a**3
-0001ce70: 202b 2062 2a2a 320a 2020 2020 3e3e 3e20   + b**2.    >>> 
-0001ce80: 6576 616c 7561 626c 652e 6465 7269 7661  evaluable.deriva
-0001ce90: 7469 7665 2866 2c20 6129 2e73 696d 706c  tive(f, a).simpl
-0001cea0: 6966 6965 6420 3d3d 2028 332e 2a61 2a2a  ified == (3.*a**
-0001ceb0: 3229 2e73 696d 706c 6966 6965 640a 2020  2).simplified.  
-0001cec0: 2020 5472 7565 0a0a 2020 2020 4172 6773    True..    Args
-0001ced0: 0a20 2020 202d 2d2d 2d0a 2020 2020 6e61  .    ----.    na
-0001cee0: 6d65 203a 203a 636c 6173 733a 6073 7472  me : :class:`str
-0001cef0: 600a 2020 2020 2020 2020 5468 6520 4964  `.        The Id
-0001cf00: 656e 7469 6669 6572 206f 6620 7468 6973  entifier of this
-0001cf10: 2061 7267 756d 656e 742e 0a20 2020 2073   argument..    s
-0001cf20: 6861 7065 203a 203a 636c 6173 733a 6074  hape : :class:`t
-0001cf30: 7570 6c65 6020 6f66 203a 636c 6173 733a  uple` of :class:
-0001cf40: 6069 6e74 605c 5c73 0a20 2020 2020 2020  `int`\\s.       
-0001cf50: 2054 6865 2073 6861 7065 206f 6620 7468   The shape of th
-0001cf60: 6973 2061 7267 756d 656e 742e 0a20 2020  is argument..   
-0001cf70: 2027 2727 0a0a 2020 2020 5f5f 736c 6f74   '''..    __slot
-0001cf80: 735f 5f20 3d20 275f 6e61 6d65 270a 0a20  s__ = '_name'.. 
-0001cf90: 2020 2040 7479 7065 732e 6170 706c 795f     @types.apply_
-0001cfa0: 616e 6e6f 7461 7469 6f6e 730a 2020 2020  annotations.    
-0001cfb0: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-0001cfc0: 662c 206e 616d 653a 2074 7970 6573 2e73  f, name: types.s
-0001cfd0: 7472 6963 7473 7472 2c20 7368 6170 653a  trictstr, shape:
-0001cfe0: 2061 7373 6861 7065 2c20 6474 7970 653d   asshape, dtype=
-0001cff0: 666c 6f61 7429 3a0a 2020 2020 2020 2020  float):.        
-0001d000: 7365 6c66 2e5f 6e61 6d65 203d 206e 616d  self._name = nam
-0001d010: 650a 2020 2020 2020 2020 7375 7065 7228  e.        super(
-0001d020: 292e 5f5f 696e 6974 5f5f 2861 7267 733d  ).__init__(args=
-0001d030: 5b45 5641 4c41 5247 535d 2c20 7368 6170  [EVALARGS], shap
-0001d040: 653d 7368 6170 652c 2064 7479 7065 3d64  e=shape, dtype=d
-0001d050: 7479 7065 290a 0a20 2020 2064 6566 2065  type)..    def e
-0001d060: 7661 6c66 2873 656c 662c 2065 7661 6c61  valf(self, evala
-0001d070: 7267 7329 3a0a 2020 2020 2020 2020 7472  rgs):.        tr
-0001d080: 793a 0a20 2020 2020 2020 2020 2020 2076  y:.            v
-0001d090: 616c 7565 203d 2065 7661 6c61 7267 735b  alue = evalargs[
-0001d0a0: 7365 6c66 2e5f 6e61 6d65 5d0a 2020 2020  self._name].    
-0001d0b0: 2020 2020 6578 6365 7074 204b 6579 4572      except KeyEr
-0001d0c0: 726f 723a 0a20 2020 2020 2020 2020 2020  ror:.           
-0001d0d0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0001d0e0: 7228 2761 7267 756d 656e 7420 7b21 727d  r('argument {!r}
-0001d0f0: 206d 6973 7369 6e67 272e 666f 726d 6174   missing'.format
-0001d100: 2873 656c 662e 5f6e 616d 6529 290a 2020  (self._name)).  
-0001d110: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0001d120: 2020 2020 2020 2020 7661 6c75 6520 3d20          value = 
-0001d130: 6e75 6d70 792e 6173 6172 7261 7928 7661  numpy.asarray(va
-0001d140: 6c75 6529 0a20 2020 2020 2020 2020 2020  lue).           
-0001d150: 2061 7373 6572 7420 6571 7561 6c73 6861   assert equalsha
-0001d160: 7065 2876 616c 7565 2e73 6861 7065 2c20  pe(value.shape, 
-0001d170: 7365 6c66 2e73 6861 7065 290a 2020 2020  self.shape).    
-0001d180: 2020 2020 2020 2020 7661 6c75 6520 3d20          value = 
-0001d190: 7661 6c75 652e 6173 7479 7065 2873 656c  value.astype(sel
-0001d1a0: 662e 6474 7970 652c 2063 6173 7469 6e67  f.dtype, casting
-0001d1b0: 3d27 7361 6665 272c 2063 6f70 793d 4661  ='safe', copy=Fa
-0001d1c0: 6c73 6529 0a20 2020 2020 2020 2020 2020  lse).           
-0001d1d0: 2072 6574 7572 6e20 7661 6c75 650a 0a20   return value.. 
-0001d1e0: 2020 2064 6566 205f 6465 7269 7661 7469     def _derivati
-0001d1f0: 7665 2873 656c 662c 2076 6172 2c20 7365  ve(self, var, se
-0001d200: 656e 293a 0a20 2020 2020 2020 2069 6620  en):.        if 
-0001d210: 6973 696e 7374 616e 6365 2876 6172 2c20  isinstance(var, 
-0001d220: 4172 6775 6d65 6e74 2920 616e 6420 7661  Argument) and va
-0001d230: 722e 5f6e 616d 6520 3d3d 2073 656c 662e  r._name == self.
-0001d240: 5f6e 616d 6520 616e 6420 7365 6c66 2e64  _name and self.d
-0001d250: 7479 7065 2069 6e20 2866 6c6f 6174 2c20  type in (float, 
-0001d260: 636f 6d70 6c65 7829 3a0a 2020 2020 2020  complex):.      
-0001d270: 2020 2020 2020 7265 7375 6c74 203d 206f        result = o
-0001d280: 6e65 7328 7365 6c66 2e73 6861 7065 2c20  nes(self.shape, 
-0001d290: 7365 6c66 2e64 7479 7065 290a 2020 2020  self.dtype).    
-0001d2a0: 2020 2020 2020 2020 666f 7220 692c 2073          for i, s
-0001d2b0: 6820 696e 2065 6e75 6d65 7261 7465 2873  h in enumerate(s
-0001d2c0: 656c 662e 7368 6170 6529 3a0a 2020 2020  elf.shape):.    
-0001d2d0: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-0001d2e0: 6c74 203d 2064 6961 676f 6e61 6c69 7a65  lt = diagonalize
-0001d2f0: 2872 6573 756c 742c 2069 2c20 692b 7365  (result, i, i+se
-0001d300: 6c66 2e6e 6469 6d29 0a20 2020 2020 2020  lf.ndim).       
-0001d310: 2020 2020 2072 6574 7572 6e20 7265 7375       return resu
-0001d320: 6c74 0a20 2020 2020 2020 2065 6c73 653a  lt.        else:
-0001d330: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0001d340: 7572 6e20 7a65 726f 7328 7365 6c66 2e73  urn zeros(self.s
-0001d350: 6861 7065 2b76 6172 2e73 6861 7065 290a  hape+var.shape).
-0001d360: 0a20 2020 2064 6566 205f 5f73 7472 5f5f  .    def __str__
-0001d370: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0001d380: 7265 7475 726e 2027 7b7d 207b 2172 7d20  return '{} {!r} 
-0001d390: 3c7b 7d3e 272e 666f 726d 6174 2873 656c  <{}>'.format(sel
-0001d3a0: 662e 5f5f 636c 6173 735f 5f2e 5f5f 6e61  f.__class__.__na
-0001d3b0: 6d65 5f5f 2c20 7365 6c66 2e5f 6e61 6d65  me__, self._name
-0001d3c0: 2c20 7365 6c66 2e5f 7368 6170 655f 7374  , self._shape_st
-0001d3d0: 7228 666f 726d 3d73 7472 2929 0a0a 2020  r(form=str))..  
-0001d3e0: 2020 6465 6620 5f6e 6f64 6528 7365 6c66    def _node(self
-0001d3f0: 2c20 6361 6368 652c 2073 7562 6772 6170  , cache, subgrap
-0001d400: 682c 2074 696d 6573 293a 0a20 2020 2020  h, times):.     
-0001d410: 2020 2069 6620 7365 6c66 2069 6e20 6361     if self in ca
-0001d420: 6368 653a 0a20 2020 2020 2020 2020 2020  che:.           
-0001d430: 2072 6574 7572 6e20 6361 6368 655b 7365   return cache[se
-0001d440: 6c66 5d0a 2020 2020 2020 2020 656c 7365  lf].        else
-0001d450: 3a0a 2020 2020 2020 2020 2020 2020 6c61  :.            la
-0001d460: 6265 6c20 3d20 275c 6e27 2e6a 6f69 6e28  bel = '\n'.join(
-0001d470: 6669 6c74 6572 284e 6f6e 652c 2028 7479  filter(None, (ty
-0001d480: 7065 2873 656c 6629 2e5f 5f6e 616d 655f  pe(self).__name_
-0001d490: 5f2c 2073 656c 662e 5f6e 616d 652c 2073  _, self._name, s
-0001d4a0: 656c 662e 5f73 6861 7065 5f73 7472 2866  elf._shape_str(f
-0001d4b0: 6f72 6d3d 7265 7072 2929 2929 0a20 2020  orm=repr)))).   
-0001d4c0: 2020 2020 2020 2020 2063 6163 6865 5b73           cache[s
-0001d4d0: 656c 665d 203d 206e 6f64 6520 3d20 4475  elf] = node = Du
-0001d4e0: 706c 6963 6174 6564 4c65 6166 4e6f 6465  plicatedLeafNode
-0001d4f0: 286c 6162 656c 2c20 2874 7970 6528 7365  (label, (type(se
-0001d500: 6c66 292e 5f5f 6e61 6d65 5f5f 2c20 7469  lf).__name__, ti
-0001d510: 6d65 735b 7365 6c66 5d29 290a 2020 2020  mes[self])).    
-0001d520: 2020 2020 2020 2020 7265 7475 726e 206e          return n
-0001d530: 6f64 650a 0a20 2020 2040 7072 6f70 6572  ode..    @proper
-0001d540: 7479 0a20 2020 2064 6566 2061 7267 756d  ty.    def argum
-0001d550: 656e 7473 2873 656c 6629 3a0a 2020 2020  ents(self):.    
-0001d560: 2020 2020 7265 7475 726e 2066 726f 7a65      return froze
-0001d570: 6e73 6574 287b 7365 6c66 7d29 0a0a 0a63  nset({self})...c
-0001d580: 6c61 7373 2049 6465 6e74 6966 6965 7244  lass IdentifierD
-0001d590: 6572 6976 6174 6976 6554 6172 6765 7428  erivativeTarget(
-0001d5a0: 4465 7269 7661 7469 7665 5461 7267 6574  DerivativeTarget
-0001d5b0: 4261 7365 293a 0a20 2020 2027 2727 5669  Base):.    '''Vi
-0001d5c0: 7274 7561 6c20 6465 7269 7661 7469 7665  rtual derivative
-0001d5d0: 2074 6172 6765 7420 6469 7374 696e 6775   target distingu
-0001d5e0: 6973 6865 6420 6279 2061 6e20 6964 656e  ished by an iden
-0001d5f0: 7469 6669 6572 2e0a 0a20 2020 2050 6172  tifier...    Par
-0001d600: 616d 6574 6572 730a 2020 2020 2d2d 2d2d  ameters.    ----
-0001d610: 2d2d 2d2d 2d2d 0a20 2020 2069 6465 6e74  ------.    ident
-0001d620: 6966 6965 7220 3a20 6861 7368 6162 6c65  ifier : hashable
-0001d630: 203a 636c 6173 733a 606f 626a 6563 7460   :class:`object`
-0001d640: 0a20 2020 2020 2020 2054 6865 2069 6465  .        The ide
-0001d650: 6e74 6966 6965 7220 666f 7220 7468 6973  ntifier for this
-0001d660: 2064 6572 6976 6174 6976 6520 7461 7267   derivative targ
-0001d670: 6574 2e0a 2020 2020 7368 6170 6520 3a20  et..    shape : 
-0001d680: 3a63 6c61 7373 3a60 7475 706c 6560 206f  :class:`tuple` o
-0001d690: 6620 3a63 6c61 7373 3a60 4172 7261 7960  f :class:`Array`
-0001d6a0: 206f 7220 3a63 6c61 7373 3a60 696e 7460   or :class:`int`
-0001d6b0: 0a20 2020 2020 2020 2054 6865 2073 6861  .        The sha
-0001d6c0: 7065 206f 6620 7468 6973 2064 6572 6976  pe of this deriv
-0001d6d0: 6174 6976 6520 7461 7267 6574 2e0a 0a20  ative target... 
-0001d6e0: 2020 2053 6565 2041 6c73 6f0a 2020 2020     See Also.    
-0001d6f0: 2d2d 2d2d 2d2d 2d2d 0a20 2020 203a 636c  --------.    :cl
-0001d700: 6173 733a 6057 6974 6844 6572 6976 6174  ass:`WithDerivat
-0001d710: 6976 6560 203a 203a 636c 6173 733a 6041  ive` : :class:`A
-0001d720: 7272 6179 6020 7772 6170 7065 7220 7769  rray` wrapper wi
-0001d730: 7468 2061 6464 6974 696f 6e61 6c20 6465  th additional de
-0001d740: 7269 7661 7469 7665 0a20 2020 2027 2727  rivative.    '''
-0001d750: 0a0a 2020 2020 5f5f 736c 6f74 735f 5f20  ..    __slots__ 
-0001d760: 3d20 2769 6465 6e74 6966 6965 7227 0a0a  = 'identifier'..
-0001d770: 2020 2020 4074 7970 6573 2e61 7070 6c79      @types.apply
-0001d780: 5f61 6e6e 6f74 6174 696f 6e73 0a20 2020  _annotations.   
-0001d790: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
-0001d7a0: 6c66 2c20 6964 656e 7469 6669 6572 2c20  lf, identifier, 
-0001d7b0: 7368 6170 653a 2061 7373 6861 7065 293a  shape: asshape):
-0001d7c0: 0a20 2020 2020 2020 2073 656c 662e 6964  .        self.id
-0001d7d0: 656e 7469 6669 6572 203d 2069 6465 6e74  entifier = ident
-0001d7e0: 6966 6965 720a 2020 2020 2020 2020 7375  ifier.        su
-0001d7f0: 7065 7228 292e 5f5f 696e 6974 5f5f 2861  per().__init__(a
-0001d800: 7267 733d 5b5d 2c20 7368 6170 653d 7368  rgs=[], shape=sh
-0001d810: 6170 652c 2064 7479 7065 3d66 6c6f 6174  ape, dtype=float
-0001d820: 290a 0a20 2020 2064 6566 2065 7661 6c66  )..    def evalf
-0001d830: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0001d840: 7261 6973 6520 4578 6365 7074 696f 6e28  raise Exception(
-0001d850: 277b 7d20 6361 6e6e 6f74 2062 6520 6576  '{} cannot be ev
-0001d860: 616c 7561 626c 6564 272e 666f 726d 6174  aluabled'.format
-0001d870: 2874 7970 6528 7365 6c66 292e 5f5f 6e61  (type(self).__na
-0001d880: 6d65 5f5f 2929 0a0a 0a63 6c61 7373 2052  me__))...class R
-0001d890: 6176 656c 2841 7272 6179 293a 0a0a 2020  avel(Array):..  
-0001d8a0: 2020 5f5f 736c 6f74 735f 5f20 3d20 2766    __slots__ = 'f
-0001d8b0: 756e 6327 0a20 2020 205f 5f63 6163 6865  unc'.    __cache
-0001d8c0: 5f5f 203d 2027 5f69 6e66 6c61 7469 6f6e  __ = '_inflation
-0001d8d0: 7327 0a0a 2020 2020 4074 7970 6573 2e61  s'..    @types.a
-0001d8e0: 7070 6c79 5f61 6e6e 6f74 6174 696f 6e73  pply_annotations
-0001d8f0: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-0001d900: 5f28 7365 6c66 2c20 6675 6e63 3a20 6173  _(self, func: as
-0001d910: 6172 7261 7929 3a0a 2020 2020 2020 2020  array):.        
-0001d920: 6966 2066 756e 632e 6e64 696d 203c 2032  if func.ndim < 2
-0001d930: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-0001d940: 6973 6520 4578 6365 7074 696f 6e28 2763  ise Exception('c
-0001d950: 616e 6e6f 7420 7261 7665 6c20 6675 6e63  annot ravel func
-0001d960: 7469 6f6e 206f 6620 6469 6d65 6e73 696f  tion of dimensio
-0001d970: 6e20 3c20 3227 290a 2020 2020 2020 2020  n < 2').        
-0001d980: 7365 6c66 2e66 756e 6320 3d20 6675 6e63  self.func = func
-0001d990: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
-0001d9a0: 2e5f 5f69 6e69 745f 5f28 6172 6773 3d5b  .__init__(args=[
-0001d9b0: 6675 6e63 5d2c 2073 6861 7065 3d28 2a66  func], shape=(*f
-0001d9c0: 756e 632e 7368 6170 655b 3a2d 325d 2c20  unc.shape[:-2], 
-0001d9d0: 6675 6e63 2e73 6861 7065 5b2d 325d 202a  func.shape[-2] *
-0001d9e0: 2066 756e 632e 7368 6170 655b 2d31 5d29   func.shape[-1])
-0001d9f0: 2c20 6474 7970 653d 6675 6e63 2e64 7479  , dtype=func.dty
-0001da00: 7065 290a 0a20 2020 2040 7072 6f70 6572  pe)..    @proper
-0001da10: 7479 0a20 2020 2064 6566 205f 696e 666c  ty.    def _infl
-0001da20: 6174 696f 6e73 2873 656c 6629 3a0a 2020  ations(self):.  
-0001da30: 2020 2020 2020 696e 666c 6174 696f 6e73        inflations
-0001da40: 203d 205b 5d0a 2020 2020 2020 2020 7374   = [].        st
-0001da50: 7269 6465 203d 2073 656c 662e 6675 6e63  ride = self.func
-0001da60: 2e73 6861 7065 5b2d 315d 0a20 2020 2020  .shape[-1].     
-0001da70: 2020 206e 203d 204e 6f6e 650a 2020 2020     n = None.    
-0001da80: 2020 2020 666f 7220 6178 6973 2c20 6f6c      for axis, ol
-0001da90: 645f 7061 7274 7320 696e 2073 656c 662e  d_parts in self.
-0001daa0: 6675 6e63 2e5f 696e 666c 6174 696f 6e73  func._inflations
-0001dab0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-0001dac0: 2061 7869 7320 3d3d 2073 656c 662e 6e64   axis == self.nd
-0001dad0: 696d 202d 2031 2061 6e64 206e 2069 7320  im - 1 and n is 
-0001dae0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0001daf0: 2020 2020 2020 6e20 3d20 7365 6c66 2e66        n = self.f
-0001db00: 756e 632e 7368 6170 655b 2d31 5d0a 2020  unc.shape[-1].  
-0001db10: 2020 2020 2020 2020 2020 2020 2020 696e                in
-0001db20: 666c 6174 696f 6e73 2e61 7070 656e 6428  flations.append(
-0001db30: 2873 656c 662e 6e64 696d 202d 2031 2c20  (self.ndim - 1, 
-0001db40: 7479 7065 732e 6672 6f7a 656e 6469 6374  types.frozendict
-0001db50: 2828 5261 7665 6c49 6e64 6578 2864 6f66  ((RavelIndex(dof
-0001db60: 6d61 702c 2052 616e 6765 286e 292c 202a  map, Range(n), *
-0001db70: 7365 6c66 2e66 756e 632e 7368 6170 655b  self.func.shape[
-0001db80: 2d32 3a5d 292c 2066 756e 6329 2066 6f72  -2:]), func) for
-0001db90: 2064 6f66 6d61 702c 2066 756e 6320 696e   dofmap, func in
-0001dba0: 206f 6c64 5f70 6172 7473 2e69 7465 6d73   old_parts.items
-0001dbb0: 2829 2929 290a 2020 2020 2020 2020 2020  ()))).          
-0001dbc0: 2020 656c 6966 2061 7869 7320 3d3d 2073    elif axis == s
-0001dbd0: 656c 662e 6e64 696d 2061 6e64 206e 2069  elf.ndim and n i
-0001dbe0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-0001dbf0: 2020 2020 2020 2020 6e20 3d20 7365 6c66          n = self
-0001dc00: 2e66 756e 632e 7368 6170 655b 2d32 5d0a  .func.shape[-2].
-0001dc10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001dc20: 696e 666c 6174 696f 6e73 2e61 7070 656e  inflations.appen
-0001dc30: 6428 2873 656c 662e 6e64 696d 202d 2031  d((self.ndim - 1
-0001dc40: 2c20 7479 7065 732e 6672 6f7a 656e 6469  , types.frozendi
-0001dc50: 6374 2828 5261 7665 6c49 6e64 6578 2852  ct((RavelIndex(R
-0001dc60: 616e 6765 286e 292c 2064 6f66 6d61 702c  ange(n), dofmap,
-0001dc70: 202a 7365 6c66 2e66 756e 632e 7368 6170   *self.func.shap
-0001dc80: 655b 2d32 3a5d 292c 2066 756e 6329 2066  e[-2:]), func) f
-0001dc90: 6f72 2064 6f66 6d61 702c 2066 756e 6320  or dofmap, func 
-0001dca0: 696e 206f 6c64 5f70 6172 7473 2e69 7465  in old_parts.ite
-0001dcb0: 6d73 2829 2929 290a 2020 2020 2020 2020  ms()))).        
-0001dcc0: 2020 2020 656c 6966 2061 7869 7320 3c20      elif axis < 
-0001dcd0: 7365 6c66 2e6e 6469 6d20 2d20 313a 0a20  self.ndim - 1:. 
-0001dce0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0001dcf0: 6e66 6c61 7469 6f6e 732e 6170 7065 6e64  nflations.append
-0001dd00: 2828 6178 6973 2c20 7479 7065 732e 6672  ((axis, types.fr
-0001dd10: 6f7a 656e 6469 6374 2828 646f 666d 6170  ozendict((dofmap
-0001dd20: 2c20 5261 7665 6c28 6675 6e63 2929 2066  , Ravel(func)) f
-0001dd30: 6f72 2064 6f66 6d61 702c 2066 756e 6320  or dofmap, func 
-0001dd40: 696e 206f 6c64 5f70 6172 7473 2e69 7465  in old_parts.ite
-0001dd50: 6d73 2829 2929 290a 2020 2020 2020 2020  ms()))).        
-0001dd60: 7265 7475 726e 2074 7570 6c65 2869 6e66  return tuple(inf
-0001dd70: 6c61 7469 6f6e 7329 0a0a 2020 2020 6465  lations)..    de
-0001dd80: 6620 5f73 696d 706c 6966 6965 6428 7365  f _simplified(se
-0001dd90: 6c66 293a 0a20 2020 2020 2020 2069 6620  lf):.        if 
-0001dda0: 6571 7561 6c69 6e64 6578 2873 656c 662e  equalindex(self.
-0001ddb0: 6675 6e63 2e73 6861 7065 5b2d 325d 2c20  func.shape[-2], 
-0001ddc0: 3129 3a0a 2020 2020 2020 2020 2020 2020  1):.            
-0001ddd0: 7265 7475 726e 2067 6574 2873 656c 662e  return get(self.
-0001dde0: 6675 6e63 2c20 2d32 2c20 3029 0a20 2020  func, -2, 0).   
-0001ddf0: 2020 2020 2069 6620 6571 7561 6c69 6e64       if equalind
-0001de00: 6578 2873 656c 662e 6675 6e63 2e73 6861  ex(self.func.sha
-0001de10: 7065 5b2d 315d 2c20 3129 3a0a 2020 2020  pe[-1], 1):.    
-0001de20: 2020 2020 2020 2020 7265 7475 726e 2067          return g
-0001de30: 6574 2873 656c 662e 6675 6e63 2c20 2d31  et(self.func, -1
-0001de40: 2c20 3029 0a20 2020 2020 2020 2072 6574  , 0).        ret
-0001de50: 7572 6e20 7365 6c66 2e66 756e 632e 5f72  urn self.func._r
-0001de60: 6176 656c 2873 656c 662e 6e64 696d 2d31  avel(self.ndim-1
-0001de70: 290a 0a20 2020 2064 6566 2065 7661 6c66  )..    def evalf
-0001de80: 2873 656c 662c 2066 293a 0a20 2020 2020  (self, f):.     
-0001de90: 2020 2072 6574 7572 6e20 662e 7265 7368     return f.resh
-0001dea0: 6170 6528 662e 7368 6170 655b 3a2d 325d  ape(f.shape[:-2]
-0001deb0: 202b 2028 662e 7368 6170 655b 2d32 5d2a   + (f.shape[-2]*
-0001dec0: 662e 7368 6170 655b 2d31 5d2c 2929 0a0a  f.shape[-1],))..
-0001ded0: 2020 2020 6465 6620 5f6d 756c 7469 706c      def _multipl
-0001dee0: 7928 7365 6c66 2c20 6f74 6865 7229 3a0a  y(self, other):.
-0001def0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
-0001df00: 7461 6e63 6528 6f74 6865 722c 2052 6176  tance(other, Rav
-0001df10: 656c 2920 616e 6420 6571 7561 6c73 6861  el) and equalsha
-0001df20: 7065 286f 7468 6572 2e66 756e 632e 7368  pe(other.func.sh
-0001df30: 6170 655b 2d32 3a5d 2c20 7365 6c66 2e66  ape[-2:], self.f
-0001df40: 756e 632e 7368 6170 655b 2d32 3a5d 293a  unc.shape[-2:]):
-0001df50: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0001df60: 7572 6e20 5261 7665 6c28 4d75 6c74 6970  urn Ravel(Multip
-0001df70: 6c79 285b 7365 6c66 2e66 756e 632c 206f  ly([self.func, o
-0001df80: 7468 6572 2e66 756e 635d 2929 0a20 2020  ther.func])).   
-0001df90: 2020 2020 2072 6574 7572 6e20 5261 7665       return Rave
-0001dfa0: 6c28 4d75 6c74 6970 6c79 285b 7365 6c66  l(Multiply([self
-0001dfb0: 2e66 756e 632c 2055 6e72 6176 656c 286f  .func, Unravel(o
-0001dfc0: 7468 6572 2c20 2a73 656c 662e 6675 6e63  ther, *self.func
-0001dfd0: 2e73 6861 7065 5b2d 323a 5d29 5d29 290a  .shape[-2:])])).
-0001dfe0: 0a20 2020 2064 6566 205f 6164 6428 7365  .    def _add(se
-0001dff0: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-0001e000: 2020 2020 7265 7475 726e 2052 6176 656c      return Ravel
-0001e010: 2873 656c 662e 6675 6e63 202b 2055 6e72  (self.func + Unr
-0001e020: 6176 656c 286f 7468 6572 2c20 2a73 656c  avel(other, *sel
-0001e030: 662e 6675 6e63 2e73 6861 7065 5b2d 323a  f.func.shape[-2:
-0001e040: 5d29 290a 0a20 2020 2064 6566 205f 7375  ]))..    def _su
-0001e050: 6d28 7365 6c66 2c20 6178 6973 293a 0a20  m(self, axis):. 
-0001e060: 2020 2020 2020 2069 6620 6178 6973 203d         if axis =
-0001e070: 3d20 7365 6c66 2e6e 6469 6d2d 313a 0a20  = self.ndim-1:. 
-0001e080: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0001e090: 6e20 5375 6d28 5375 6d28 7365 6c66 2e66  n Sum(Sum(self.f
-0001e0a0: 756e 6329 290a 2020 2020 2020 2020 7265  unc)).        re
-0001e0b0: 7475 726e 2052 6176 656c 2873 756d 2873  turn Ravel(sum(s
-0001e0c0: 656c 662e 6675 6e63 2c20 6178 6973 2929  elf.func, axis))
-0001e0d0: 0a0a 2020 2020 6465 6620 5f64 6572 6976  ..    def _deriv
-0001e0e0: 6174 6976 6528 7365 6c66 2c20 7661 722c  ative(self, var,
-0001e0f0: 2073 6565 6e29 3a0a 2020 2020 2020 2020   seen):.        
-0001e100: 7265 7475 726e 2072 6176 656c 2864 6572  return ravel(der
-0001e110: 6976 6174 6976 6528 7365 6c66 2e66 756e  ivative(self.fun
-0001e120: 632c 2076 6172 2c20 7365 656e 292c 2061  c, var, seen), a
-0001e130: 7869 733d 7365 6c66 2e6e 6469 6d2d 3129  xis=self.ndim-1)
-0001e140: 0a0a 2020 2020 6465 6620 5f74 616b 6564  ..    def _taked
-0001e150: 6961 6728 7365 6c66 2c20 6178 6973 312c  iag(self, axis1,
-0001e160: 2061 7869 7332 293a 0a20 2020 2020 2020   axis2):.       
-0001e170: 2061 7373 6572 7420 6178 6973 3120 3c20   assert axis1 < 
-0001e180: 6178 6973 320a 2020 2020 2020 2020 6966  axis2.        if
-0001e190: 2061 7869 7332 203c 3d20 7365 6c66 2e6e   axis2 <= self.n
-0001e1a0: 6469 6d2d 323a 0a20 2020 2020 2020 2020  dim-2:.         
-0001e1b0: 2020 2072 6574 7572 6e20 7261 7665 6c28     return ravel(
-0001e1c0: 5f74 616b 6564 6961 6728 7365 6c66 2e66  _takediag(self.f
-0001e1d0: 756e 632c 2061 7869 7331 2c20 6178 6973  unc, axis1, axis
-0001e1e0: 3229 2c20 7365 6c66 2e6e 6469 6d2d 3329  2), self.ndim-3)
-0001e1f0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-0001e200: 2020 2020 2020 2020 2020 2075 6e72 6176             unrav
-0001e210: 656c 6564 203d 2075 6e72 6176 656c 2873  eled = unravel(s
-0001e220: 656c 662e 6675 6e63 2c20 6178 6973 312c  elf.func, axis1,
-0001e230: 2073 656c 662e 6675 6e63 2e73 6861 7065   self.func.shape
-0001e240: 5b2d 323a 5d29 0a20 2020 2020 2020 2020  [-2:]).         
-0001e250: 2020 2072 6574 7572 6e20 5261 7665 6c28     return Ravel(
-0001e260: 5f74 616b 6564 6961 6728 5f74 616b 6564  _takediag(_taked
-0001e270: 6961 6728 756e 7261 7665 6c65 642c 2061  iag(unraveled, a
-0001e280: 7869 7331 2c20 2d32 292c 2061 7869 7331  xis1, -2), axis1
-0001e290: 2c20 2d32 2929 0a0a 2020 2020 6465 6620  , -2))..    def 
-0001e2a0: 5f74 616b 6528 7365 6c66 2c20 696e 6465  _take(self, inde
-0001e2b0: 782c 2061 7869 7329 3a0a 2020 2020 2020  x, axis):.      
-0001e2c0: 2020 6966 2061 7869 7320 213d 2073 656c    if axis != sel
-0001e2d0: 662e 6e64 696d 2d31 3a0a 2020 2020 2020  f.ndim-1:.      
-0001e2e0: 2020 2020 2020 7265 7475 726e 2052 6176        return Rav
-0001e2f0: 656c 285f 7461 6b65 2873 656c 662e 6675  el(_take(self.fu
-0001e300: 6e63 2c20 696e 6465 782c 2061 7869 7329  nc, index, axis)
-0001e310: 290a 0a20 2020 2064 6566 205f 7274 616b  )..    def _rtak
-0001e320: 6528 7365 6c66 2c20 6675 6e63 2c20 6178  e(self, func, ax
-0001e330: 6973 293a 0a20 2020 2020 2020 2069 6620  is):.        if 
-0001e340: 7365 6c66 2e6e 6469 6d20 3d3d 2031 3a0a  self.ndim == 1:.
-0001e350: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0001e360: 726e 2052 6176 656c 2854 616b 6528 6675  rn Ravel(Take(fu
-0001e370: 6e63 2c20 7365 6c66 2e66 756e 6329 290a  nc, self.func)).
-0001e380: 0a20 2020 2064 6566 205f 756e 7261 7665  .    def _unrave
-0001e390: 6c28 7365 6c66 2c20 6178 6973 2c20 7368  l(self, axis, sh
-0001e3a0: 6170 6529 3a0a 2020 2020 2020 2020 6966  ape):.        if
-0001e3b0: 2061 7869 7320 213d 2073 656c 662e 6e64   axis != self.nd
-0001e3c0: 696d 2d31 3a0a 2020 2020 2020 2020 2020  im-1:.          
-0001e3d0: 2020 7265 7475 726e 2052 6176 656c 2875    return Ravel(u
-0001e3e0: 6e72 6176 656c 2873 656c 662e 6675 6e63  nravel(self.func
-0001e3f0: 2c20 6178 6973 2c20 7368 6170 6529 290a  , axis, shape)).
-0001e400: 2020 2020 2020 2020 656c 6966 2065 7175          elif equ
-0001e410: 616c 7368 6170 6528 7368 6170 652c 2073  alshape(shape, s
-0001e420: 656c 662e 6675 6e63 2e73 6861 7065 5b2d  elf.func.shape[-
-0001e430: 323a 5d29 3a0a 2020 2020 2020 2020 2020  2:]):.          
-0001e440: 2020 7265 7475 726e 2073 656c 662e 6675    return self.fu
-0001e450: 6e63 0a0a 2020 2020 6465 6620 5f69 6e66  nc..    def _inf
-0001e460: 6c61 7465 2873 656c 662c 2064 6f66 6d61  late(self, dofma
-0001e470: 702c 206c 656e 6774 682c 2061 7869 7329  p, length, axis)
-0001e480: 3a0a 2020 2020 2020 2020 6966 2061 7869  :.        if axi
-0001e490: 7320 3c20 7365 6c66 2e6e 6469 6d2d 646f  s < self.ndim-do
-0001e4a0: 666d 6170 2e6e 6469 6d3a 0a20 2020 2020  fmap.ndim:.     
-0001e4b0: 2020 2020 2020 2072 6574 7572 6e20 5261         return Ra
-0001e4c0: 7665 6c28 5f69 6e66 6c61 7465 2873 656c  vel(_inflate(sel
-0001e4d0: 662e 6675 6e63 2c20 646f 666d 6170 2c20  f.func, dofmap, 
-0001e4e0: 6c65 6e67 7468 2c20 6178 6973 2929 0a20  length, axis)). 
-0001e4f0: 2020 2020 2020 2065 6c69 6620 646f 666d         elif dofm
-0001e500: 6170 2e6e 6469 6d20 3d3d 2030 3a0a 2020  ap.ndim == 0:.  
-0001e510: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001e520: 2072 6176 656c 2849 6e66 6c61 7465 2873   ravel(Inflate(s
-0001e530: 656c 662e 6675 6e63 2c20 646f 666d 6170  elf.func, dofmap
-0001e540: 2c20 6c65 6e67 7468 292c 2073 656c 662e  , length), self.
-0001e550: 6e64 696d 2d31 290a 2020 2020 2020 2020  ndim-1).        
-0001e560: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0001e570: 2020 7265 7475 726e 205f 696e 666c 6174    return _inflat
-0001e580: 6528 7365 6c66 2e66 756e 632c 2055 6e72  e(self.func, Unr
-0001e590: 6176 656c 2864 6f66 6d61 702c 202a 7365  avel(dofmap, *se
-0001e5a0: 6c66 2e66 756e 632e 7368 6170 655b 2d32  lf.func.shape[-2
-0001e5b0: 3a5d 292c 206c 656e 6774 682c 2061 7869  :]), length, axi
-0001e5c0: 7329 0a0a 2020 2020 6465 6620 5f64 6961  s)..    def _dia
-0001e5d0: 676f 6e61 6c69 7a65 2873 656c 662c 2061  gonalize(self, a
-0001e5e0: 7869 7329 3a0a 2020 2020 2020 2020 6966  xis):.        if
-0001e5f0: 2061 7869 7320 213d 2073 656c 662e 6e64   axis != self.nd
-0001e600: 696d 2d31 3a0a 2020 2020 2020 2020 2020  im-1:.          
-0001e610: 2020 7265 7475 726e 2072 6176 656c 2864    return ravel(d
-0001e620: 6961 676f 6e61 6c69 7a65 2873 656c 662e  iagonalize(self.
-0001e630: 6675 6e63 2c20 6178 6973 292c 2073 656c  func, axis), sel
-0001e640: 662e 6e64 696d 2d31 290a 0a20 2020 2064  f.ndim-1)..    d
-0001e650: 6566 205f 696e 7365 7274 6178 6973 2873  ef _insertaxis(s
-0001e660: 656c 662c 2061 7869 732c 206c 656e 6774  elf, axis, lengt
-0001e670: 6829 3a0a 2020 2020 2020 2020 7265 7475  h):.        retu
-0001e680: 726e 2072 6176 656c 2869 6e73 6572 7461  rn ravel(inserta
-0001e690: 7869 7328 7365 6c66 2e66 756e 632c 2061  xis(self.func, a
-0001e6a0: 7869 732b 2861 7869 7320 3d3d 2073 656c  xis+(axis == sel
-0001e6b0: 662e 6e64 696d 292c 206c 656e 6774 6829  f.ndim), length)
-0001e6c0: 2c20 7365 6c66 2e6e 6469 6d2d 2861 7869  , self.ndim-(axi
-0001e6d0: 7320 3d3d 2073 656c 662e 6e64 696d 2929  s == self.ndim))
-0001e6e0: 0a0a 2020 2020 6465 6620 5f70 6f77 6572  ..    def _power
-0001e6f0: 2873 656c 662c 206e 293a 0a20 2020 2020  (self, n):.     
-0001e700: 2020 2072 6574 7572 6e20 5261 7665 6c28     return Ravel(
-0001e710: 506f 7765 7228 7365 6c66 2e66 756e 632c  Power(self.func,
-0001e720: 2055 6e72 6176 656c 286e 2c20 2a73 656c   Unravel(n, *sel
-0001e730: 662e 6675 6e63 2e73 6861 7065 5b2d 323a  f.func.shape[-2:
-0001e740: 5d29 2929 0a0a 2020 2020 6465 6620 5f73  ])))..    def _s
-0001e750: 6967 6e28 7365 6c66 293a 0a20 2020 2020  ign(self):.     
-0001e760: 2020 2072 6574 7572 6e20 5261 7665 6c28     return Ravel(
-0001e770: 5369 676e 2873 656c 662e 6675 6e63 2929  Sign(self.func))
-0001e780: 0a0a 2020 2020 6465 6620 5f70 726f 6475  ..    def _produ
-0001e790: 6374 2873 656c 6629 3a0a 2020 2020 2020  ct(self):.      
-0001e7a0: 2020 7265 7475 726e 2050 726f 6475 6374    return Product
-0001e7b0: 2850 726f 6475 6374 2873 656c 662e 6675  (Product(self.fu
-0001e7c0: 6e63 2929 0a0a 2020 2020 6465 6620 5f6c  nc))..    def _l
-0001e7d0: 6f6f 7073 756d 2873 656c 662c 2069 6e64  oopsum(self, ind
-0001e7e0: 6578 293a 0a20 2020 2020 2020 2072 6574  ex):.        ret
-0001e7f0: 7572 6e20 5261 7665 6c28 6c6f 6f70 5f73  urn Ravel(loop_s
-0001e800: 756d 2873 656c 662e 6675 6e63 2c20 696e  um(self.func, in
-0001e810: 6465 7829 290a 0a20 2020 2040 7072 6f70  dex))..    @prop
-0001e820: 6572 7479 0a20 2020 2064 6566 205f 756e  erty.    def _un
-0001e830: 616c 6967 6e65 6428 7365 6c66 293a 0a20  aligned(self):. 
-0001e840: 2020 2020 2020 2075 6e61 6c69 676e 6564         unaligned
-0001e850: 2c20 7768 6572 6520 3d20 756e 616c 6967  , where = unalig
-0001e860: 6e28 7365 6c66 2e66 756e 6329 0a20 2020  n(self.func).   
-0001e870: 2020 2020 2066 6f72 2069 2069 6e20 7365       for i in se
-0001e880: 6c66 2e6e 6469 6d20 2d20 312c 2073 656c  lf.ndim - 1, sel
-0001e890: 662e 6e64 696d 3a0a 2020 2020 2020 2020  f.ndim:.        
-0001e8a0: 2020 2020 6966 2069 206e 6f74 2069 6e20      if i not in 
-0001e8b0: 7768 6572 653a 0a20 2020 2020 2020 2020  where:.         
-0001e8c0: 2020 2020 2020 2075 6e61 6c69 676e 6564         unaligned
-0001e8d0: 203d 2049 6e73 6572 7441 7869 7328 756e   = InsertAxis(un
-0001e8e0: 616c 6967 6e65 642c 2073 656c 662e 6675  aligned, self.fu
-0001e8f0: 6e63 2e73 6861 7065 5b69 5d29 0a20 2020  nc.shape[i]).   
-0001e900: 2020 2020 2020 2020 2020 2020 2077 6865               whe
-0001e910: 7265 202b 3d20 692c 0a20 2020 2020 2020  re += i,.       
-0001e920: 2069 6620 7768 6572 655b 2d32 3a5d 2021   if where[-2:] !
-0001e930: 3d20 2873 656c 662e 6e64 696d 202d 2031  = (self.ndim - 1
-0001e940: 2c20 7365 6c66 2e6e 6469 6d29 3a0a 2020  , self.ndim):.  
-0001e950: 2020 2020 2020 2020 2020 756e 616c 6967            unalig
-0001e960: 6e65 6420 3d20 5472 616e 7370 6f73 6528  ned = Transpose(
-0001e970: 756e 616c 6967 6e65 642c 206e 756d 7079  unaligned, numpy
-0001e980: 2e61 7267 736f 7274 2877 6865 7265 2929  .argsort(where))
-0001e990: 0a20 2020 2020 2020 2020 2020 2077 6865  .            whe
-0001e9a0: 7265 203d 2074 7570 6c65 2873 6f72 7465  re = tuple(sorte
-0001e9b0: 6428 7768 6572 6529 290a 2020 2020 2020  d(where)).      
-0001e9c0: 2020 7265 7475 726e 2052 6176 656c 2875    return Ravel(u
-0001e9d0: 6e61 6c69 676e 6564 292c 2077 6865 7265  naligned), where
-0001e9e0: 5b3a 2d31 5d0a 0a20 2020 2040 7072 6f70  [:-1]..    @prop
-0001e9f0: 6572 7479 0a20 2020 2064 6566 205f 6173  erty.    def _as
-0001ea00: 7370 6172 7365 2873 656c 6629 3a0a 2020  sparse(self):.  
-0001ea10: 2020 2020 2020 7265 7475 726e 2074 7570        return tup
-0001ea20: 6c65 2828 2a69 6e64 6963 6573 5b3a 2d32  le((*indices[:-2
-0001ea30: 5d2c 2069 6e64 6963 6573 5b2d 325d 2a73  ], indices[-2]*s
-0001ea40: 656c 662e 6675 6e63 2e73 6861 7065 5b2d  elf.func.shape[-
-0001ea50: 315d 2b69 6e64 6963 6573 5b2d 315d 2c20  1]+indices[-1], 
-0001ea60: 7661 6c75 6573 2920 666f 7220 2a69 6e64  values) for *ind
-0001ea70: 6963 6573 2c20 7661 6c75 6573 2069 6e20  ices, values in 
-0001ea80: 7365 6c66 2e66 756e 632e 5f61 7373 7061  self.func._asspa
-0001ea90: 7273 6529 0a0a 2020 2020 6465 6620 5f69  rse)..    def _i
-0001eaa0: 6e74 626f 756e 6473 5f69 6d70 6c28 7365  ntbounds_impl(se
-0001eab0: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-0001eac0: 7572 6e20 7365 6c66 2e66 756e 632e 5f69  urn self.func._i
-0001ead0: 6e74 626f 756e 6473 5f69 6d70 6c28 290a  ntbounds_impl().
-0001eae0: 0a0a 636c 6173 7320 556e 7261 7665 6c28  ..class Unravel(
-0001eaf0: 4172 7261 7929 3a0a 0a20 2020 205f 5f73  Array):..    __s
-0001eb00: 6c6f 7473 5f5f 203d 2027 6675 6e63 270a  lots__ = 'func'.
-0001eb10: 0a20 2020 2040 7479 7065 732e 6170 706c  .    @types.appl
-0001eb20: 795f 616e 6e6f 7461 7469 6f6e 730a 2020  y_annotations.  
-0001eb30: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
-0001eb40: 656c 662c 2066 756e 633a 2061 7361 7272  elf, func: asarr
-0001eb50: 6179 2c20 7368 313a 2061 7369 6e64 6578  ay, sh1: asindex
-0001eb60: 2c20 7368 323a 2061 7369 6e64 6578 293a  , sh2: asindex):
-0001eb70: 0a20 2020 2020 2020 2069 6620 6675 6e63  .        if func
-0001eb80: 2e6e 6469 6d20 3d3d 2030 3a0a 2020 2020  .ndim == 0:.    
-0001eb90: 2020 2020 2020 2020 7261 6973 6520 4578          raise Ex
-0001eba0: 6365 7074 696f 6e28 2763 616e 6e6f 7420  ception('cannot 
-0001ebb0: 756e 7261 7665 6c20 7363 616c 6172 2066  unravel scalar f
-0001ebc0: 756e 6374 696f 6e27 290a 2020 2020 2020  unction').      
-0001ebd0: 2020 6966 206e 6f74 2065 7175 616c 696e    if not equalin
-0001ebe0: 6465 7828 6675 6e63 2e73 6861 7065 5b2d  dex(func.shape[-
-0001ebf0: 315d 2c20 7368 3120 2a20 7368 3229 3a0a  1], sh1 * sh2):.
-0001ec00: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-0001ec10: 6520 4578 6365 7074 696f 6e28 276e 6577  e Exception('new
-0001ec20: 2073 6861 7065 2064 6f65 7320 6e6f 7420   shape does not 
-0001ec30: 6d61 7463 6820 6178 6973 206c 656e 6774  match axis lengt
-0001ec40: 6827 290a 2020 2020 2020 2020 7365 6c66  h').        self
-0001ec50: 2e66 756e 6320 3d20 6675 6e63 0a20 2020  .func = func.   
-0001ec60: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
-0001ec70: 6e69 745f 5f28 6172 6773 3d5b 6675 6e63  nit__(args=[func
-0001ec80: 2c20 7368 312c 2073 6832 5d2c 2073 6861  , sh1, sh2], sha
-0001ec90: 7065 3d28 2a66 756e 632e 7368 6170 655b  pe=(*func.shape[
-0001eca0: 3a2d 315d 2c20 7368 312c 2073 6832 292c  :-1], sh1, sh2),
-0001ecb0: 2064 7479 7065 3d66 756e 632e 6474 7970   dtype=func.dtyp
-0001ecc0: 6529 0a0a 2020 2020 6465 6620 5f73 696d  e)..    def _sim
-0001ecd0: 706c 6966 6965 6428 7365 6c66 293a 0a20  plified(self):. 
-0001ece0: 2020 2020 2020 2069 6620 6571 7561 6c69         if equali
-0001ecf0: 6e64 6578 2873 656c 662e 7368 6170 655b  ndex(self.shape[
-0001ed00: 2d32 5d2c 2031 293a 0a20 2020 2020 2020  -2], 1):.       
-0001ed10: 2020 2020 2072 6574 7572 6e20 696e 7365       return inse
-0001ed20: 7274 6178 6973 2873 656c 662e 6675 6e63  rtaxis(self.func
-0001ed30: 2c20 7365 6c66 2e6e 6469 6d2d 322c 2031  , self.ndim-2, 1
-0001ed40: 290a 2020 2020 2020 2020 6966 2065 7175  ).        if equ
-0001ed50: 616c 696e 6465 7828 7365 6c66 2e73 6861  alindex(self.sha
-0001ed60: 7065 5b2d 315d 2c20 3129 3a0a 2020 2020  pe[-1], 1):.    
-0001ed70: 2020 2020 2020 2020 7265 7475 726e 2069          return i
-0001ed80: 6e73 6572 7461 7869 7328 7365 6c66 2e66  nsertaxis(self.f
-0001ed90: 756e 632c 2073 656c 662e 6e64 696d 2d31  unc, self.ndim-1
-0001eda0: 2c20 3129 0a20 2020 2020 2020 2072 6574  , 1).        ret
-0001edb0: 7572 6e20 7365 6c66 2e66 756e 632e 5f75  urn self.func._u
-0001edc0: 6e72 6176 656c 2873 656c 662e 6e64 696d  nravel(self.ndim
-0001edd0: 2d32 2c20 7365 6c66 2e73 6861 7065 5b2d  -2, self.shape[-
-0001ede0: 323a 5d29 0a0a 2020 2020 6465 6620 5f64  2:])..    def _d
-0001edf0: 6572 6976 6174 6976 6528 7365 6c66 2c20  erivative(self, 
-0001ee00: 7661 722c 2073 6565 6e29 3a0a 2020 2020  var, seen):.    
-0001ee10: 2020 2020 7265 7475 726e 2075 6e72 6176      return unrav
-0001ee20: 656c 2864 6572 6976 6174 6976 6528 7365  el(derivative(se
-0001ee30: 6c66 2e66 756e 632c 2076 6172 2c20 7365  lf.func, var, se
-0001ee40: 656e 292c 2061 7869 733d 7365 6c66 2e6e  en), axis=self.n
-0001ee50: 6469 6d2d 322c 2073 6861 7065 3d73 656c  dim-2, shape=sel
-0001ee60: 662e 7368 6170 655b 2d32 3a5d 290a 0a20  f.shape[-2:]).. 
-0001ee70: 2020 2064 6566 2065 7661 6c66 2873 656c     def evalf(sel
-0001ee80: 662c 2066 2c20 7368 312c 2073 6832 293a  f, f, sh1, sh2):
-0001ee90: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001eea0: 662e 7265 7368 6170 6528 662e 7368 6170  f.reshape(f.shap
-0001eeb0: 655b 3a2d 315d 202b 2028 7368 312c 2073  e[:-1] + (sh1, s
-0001eec0: 6832 2929 0a0a 2020 2020 6465 6620 5f74  h2))..    def _t
-0001eed0: 616b 6564 6961 6728 7365 6c66 2c20 6178  akediag(self, ax
-0001eee0: 6973 312c 2061 7869 7332 293a 0a20 2020  is1, axis2):.   
-0001eef0: 2020 2020 2069 6620 6178 6973 3220 3c20       if axis2 < 
-0001ef00: 7365 6c66 2e6e 6469 6d2d 323a 0a20 2020  self.ndim-2:.   
-0001ef10: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001ef20: 756e 7261 7665 6c28 5f74 616b 6564 6961  unravel(_takedia
-0001ef30: 6728 7365 6c66 2e66 756e 632c 2061 7869  g(self.func, axi
-0001ef40: 7331 2c20 6178 6973 3229 2c20 7365 6c66  s1, axis2), self
-0001ef50: 2e6e 6469 6d2d 342c 2073 656c 662e 7368  .ndim-4, self.sh
-0001ef60: 6170 655b 2d32 3a5d 290a 0a20 2020 2064  ape[-2:])..    d
-0001ef70: 6566 205f 7461 6b65 2873 656c 662c 2069  ef _take(self, i
-0001ef80: 6e64 6578 2c20 6178 6973 293a 0a20 2020  ndex, axis):.   
-0001ef90: 2020 2020 2069 6620 6178 6973 203c 2073       if axis < s
-0001efa0: 656c 662e 6e64 696d 202d 2032 3a0a 2020  elf.ndim - 2:.  
-0001efb0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001efc0: 2055 6e72 6176 656c 285f 7461 6b65 2873   Unravel(_take(s
-0001efd0: 656c 662e 6675 6e63 2c20 696e 6465 782c  elf.func, index,
-0001efe0: 2061 7869 7329 2c20 2a73 656c 662e 7368   axis), *self.sh
-0001eff0: 6170 655b 2d32 3a5d 290a 0a20 2020 2064  ape[-2:])..    d
-0001f000: 6566 205f 7375 6d28 7365 6c66 2c20 6178  ef _sum(self, ax
-0001f010: 6973 293a 0a20 2020 2020 2020 2069 6620  is):.        if 
-0001f020: 6178 6973 203c 2073 656c 662e 6e64 696d  axis < self.ndim
-0001f030: 202d 2032 3a0a 2020 2020 2020 2020 2020   - 2:.          
-0001f040: 2020 7265 7475 726e 2055 6e72 6176 656c    return Unravel
-0001f050: 2873 756d 2873 656c 662e 6675 6e63 2c20  (sum(self.func, 
-0001f060: 6178 6973 292c 202a 7365 6c66 2e73 6861  axis), *self.sha
-0001f070: 7065 5b2d 323a 5d29 0a0a 2020 2020 4070  pe[-2:])..    @p
-0001f080: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-0001f090: 5f61 7373 7061 7273 6528 7365 6c66 293a  _assparse(self):
-0001f0a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001f0b0: 7475 706c 6528 282a 696e 6469 6365 735b  tuple((*indices[
-0001f0c0: 3a2d 315d 2c20 2a64 6976 6d6f 6428 696e  :-1], *divmod(in
-0001f0d0: 6469 6365 735b 2d31 5d2c 2061 7070 656e  dices[-1], appen
-0001f0e0: 6461 7865 7328 7365 6c66 2e73 6861 7065  daxes(self.shape
-0001f0f0: 5b2d 315d 2c20 7661 6c75 6573 2e73 6861  [-1], values.sha
-0001f100: 7065 2929 2c20 7661 6c75 6573 2920 666f  pe)), values) fo
-0001f110: 7220 2a69 6e64 6963 6573 2c20 7661 6c75  r *indices, valu
-0001f120: 6573 2069 6e20 7365 6c66 2e66 756e 632e  es in self.func.
-0001f130: 5f61 7373 7061 7273 6529 0a0a 0a63 6c61  _assparse)...cla
-0001f140: 7373 2052 6176 656c 496e 6465 7828 4172  ss RavelIndex(Ar
-0001f150: 7261 7929 3a0a 0a20 2020 2040 7479 7065  ray):..    @type
-0001f160: 732e 6170 706c 795f 616e 6e6f 7461 7469  s.apply_annotati
-0001f170: 6f6e 730a 2020 2020 6465 6620 5f5f 696e  ons.    def __in
-0001f180: 6974 5f5f 2873 656c 662c 2069 613a 2061  it__(self, ia: a
-0001f190: 7361 7272 6179 2c20 6962 3a20 6173 6172  sarray, ib: asar
-0001f1a0: 7261 792c 206e 613a 2061 7369 6e64 6578  ray, na: asindex
-0001f1b0: 2c20 6e62 3a20 6173 696e 6465 7829 3a0a  , nb: asindex):.
-0001f1c0: 2020 2020 2020 2020 7365 6c66 2e5f 6961          self._ia
-0001f1d0: 203d 2069 610a 2020 2020 2020 2020 7365   = ia.        se
-0001f1e0: 6c66 2e5f 6962 203d 2069 620a 2020 2020  lf._ib = ib.    
-0001f1f0: 2020 2020 7365 6c66 2e5f 6e61 203d 206e      self._na = n
-0001f200: 610a 2020 2020 2020 2020 7365 6c66 2e5f  a.        self._
-0001f210: 6e62 203d 206e 620a 2020 2020 2020 2020  nb = nb.        
-0001f220: 7365 6c66 2e5f 6c65 6e67 7468 203d 206e  self._length = n
-0001f230: 6120 2a20 6e62 0a20 2020 2020 2020 2073  a * nb.        s
-0001f240: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
-0001f250: 6172 6773 3d5b 6961 2c20 6962 2c20 6e62  args=[ia, ib, nb
-0001f260: 5d2c 2073 6861 7065 3d69 612e 7368 6170  ], shape=ia.shap
-0001f270: 6520 2b20 6962 2e73 6861 7065 2c20 6474  e + ib.shape, dt
-0001f280: 7970 653d 696e 7429 0a0a 2020 2020 6465  ype=int)..    de
-0001f290: 6620 6576 616c 6628 7365 6c66 2c20 6961  f evalf(self, ia
-0001f2a0: 2c20 6962 2c20 6e62 293a 0a20 2020 2020  , ib, nb):.     
-0001f2b0: 2020 2072 6574 7572 6e20 6961 5b28 2e2e     return ia[(..
-0001f2c0: 2e2c 292b 286e 756d 7079 2e6e 6577 6178  .,)+(numpy.newax
-0001f2d0: 6973 2c29 2a69 622e 6e64 696d 5d20 2a20  is,)*ib.ndim] * 
-0001f2e0: 6e62 202b 2069 620a 0a20 2020 2064 6566  nb + ib..    def
-0001f2f0: 205f 7461 6b65 2873 656c 662c 2069 6e64   _take(self, ind
-0001f300: 6578 2c20 6178 6973 293a 0a20 2020 2020  ex, axis):.     
-0001f310: 2020 2069 6620 6178 6973 203c 2073 656c     if axis < sel
-0001f320: 662e 5f69 612e 6e64 696d 3a0a 2020 2020  f._ia.ndim:.    
-0001f330: 2020 2020 2020 2020 7265 7475 726e 2052          return R
-0001f340: 6176 656c 496e 6465 7828 5f74 616b 6528  avelIndex(_take(
-0001f350: 7365 6c66 2e5f 6961 2c20 696e 6465 782c  self._ia, index,
-0001f360: 2061 7869 7329 2c20 7365 6c66 2e5f 6962   axis), self._ib
-0001f370: 2c20 7365 6c66 2e5f 6e61 2c20 7365 6c66  , self._na, self
-0001f380: 2e5f 6e62 290a 2020 2020 2020 2020 656c  ._nb).        el
-0001f390: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0001f3a0: 7265 7475 726e 2052 6176 656c 496e 6465  return RavelInde
-0001f3b0: 7828 7365 6c66 2e5f 6961 2c20 5f74 616b  x(self._ia, _tak
-0001f3c0: 6528 7365 6c66 2e5f 6962 2c20 696e 6465  e(self._ib, inde
-0001f3d0: 782c 2061 7869 7320 2d20 7365 6c66 2e5f  x, axis - self._
-0001f3e0: 6961 2e6e 6469 6d29 2c20 7365 6c66 2e5f  ia.ndim), self._
-0001f3f0: 6e61 2c20 7365 6c66 2e5f 6e62 290a 0a20  na, self._nb).. 
-0001f400: 2020 2064 6566 205f 7274 616b 6528 7365     def _rtake(se
-0001f410: 6c66 2c20 6675 6e63 2c20 6178 6973 293a  lf, func, axis):
-0001f420: 0a20 2020 2020 2020 2069 6620 6571 7561  .        if equa
-0001f430: 6c69 6e64 6578 2866 756e 632e 7368 6170  lindex(func.shap
-0001f440: 655b 6178 6973 5d2c 2073 656c 662e 5f6c  e[axis], self._l
-0001f450: 656e 6774 6829 3a0a 2020 2020 2020 2020  ength):.        
-0001f460: 2020 2020 7265 7475 726e 205f 7461 6b65      return _take
-0001f470: 285f 7461 6b65 2875 6e72 6176 656c 2866  (_take(unravel(f
-0001f480: 756e 632c 2061 7869 732c 2028 7365 6c66  unc, axis, (self
-0001f490: 2e5f 6e61 2c20 7365 6c66 2e5f 6e62 2929  ._na, self._nb))
-0001f4a0: 2c20 7365 6c66 2e5f 6962 2c20 6178 6973  , self._ib, axis
-0001f4b0: 2b31 292c 2073 656c 662e 5f69 612c 2061  +1), self._ia, a
-0001f4c0: 7869 7329 0a0a 2020 2020 6465 6620 5f72  xis)..    def _r
-0001f4d0: 696e 666c 6174 6528 7365 6c66 2c20 6675  inflate(self, fu
-0001f4e0: 6e63 2c20 6c65 6e67 7468 2c20 6178 6973  nc, length, axis
-0001f4f0: 293a 0a20 2020 2020 2020 2069 6620 6571  ):.        if eq
-0001f500: 7561 6c69 6e64 6578 286c 656e 6774 682c  ualindex(length,
-0001f510: 2073 656c 662e 5f6c 656e 6774 6829 3a0a   self._length):.
-0001f520: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0001f530: 726e 2052 6176 656c 2849 6e66 6c61 7465  rn Ravel(Inflate
-0001f540: 285f 696e 666c 6174 6528 6675 6e63 2c20  (_inflate(func, 
-0001f550: 7365 6c66 2e5f 6961 2c20 7365 6c66 2e5f  self._ia, self._
-0001f560: 6e61 2c20 6675 6e63 2e6e 6469 6d20 2d20  na, func.ndim - 
-0001f570: 7365 6c66 2e6e 6469 6d29 2c20 7365 6c66  self.ndim), self
-0001f580: 2e5f 6962 2c20 7365 6c66 2e5f 6e62 2929  ._ib, self._nb))
-0001f590: 0a0a 2020 2020 6465 6620 5f75 6e72 6176  ..    def _unrav
-0001f5a0: 656c 2873 656c 662c 2061 7869 732c 2073  el(self, axis, s
-0001f5b0: 6861 7065 293a 0a20 2020 2020 2020 2069  hape):.        i
-0001f5c0: 6620 6178 6973 203c 2073 656c 662e 5f69  f axis < self._i
-0001f5d0: 612e 6e64 696d 3a0a 2020 2020 2020 2020  a.ndim:.        
-0001f5e0: 2020 2020 7265 7475 726e 2052 6176 656c      return Ravel
-0001f5f0: 496e 6465 7828 756e 7261 7665 6c28 7365  Index(unravel(se
-0001f600: 6c66 2e5f 6961 2c20 6178 6973 2c20 7368  lf._ia, axis, sh
-0001f610: 6170 6529 2c20 7365 6c66 2e5f 6962 2c20  ape), self._ib, 
-0001f620: 7365 6c66 2e5f 6e61 2c20 7365 6c66 2e5f  self._na, self._
-0001f630: 6e62 290a 2020 2020 2020 2020 656c 7365  nb).        else
-0001f640: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0001f650: 7475 726e 2052 6176 656c 496e 6465 7828  turn RavelIndex(
-0001f660: 7365 6c66 2e5f 6961 2c20 756e 7261 7665  self._ia, unrave
-0001f670: 6c28 7365 6c66 2e5f 6962 2c20 6178 6973  l(self._ib, axis
-0001f680: 2d73 656c 662e 5f69 612e 6e64 696d 2c20  -self._ia.ndim, 
-0001f690: 7368 6170 6529 2c20 7365 6c66 2e5f 6e61  shape), self._na
-0001f6a0: 2c20 7365 6c66 2e5f 6e62 290a 0a20 2020  , self._nb)..   
-0001f6b0: 2064 6566 205f 696e 7462 6f75 6e64 735f   def _intbounds_
-0001f6c0: 696d 706c 2873 656c 6629 3a0a 2020 2020  impl(self):.    
-0001f6d0: 2020 2020 6e62 6d69 6e2c 206e 626d 6178      nbmin, nbmax
-0001f6e0: 203d 2073 656c 662e 5f6e 622e 5f69 6e74   = self._nb._int
-0001f6f0: 626f 756e 6473 0a20 2020 2020 2020 2069  bounds.        i
-0001f700: 616d 696e 2c20 6961 6d61 7820 3d20 7365  amin, iamax = se
-0001f710: 6c66 2e5f 6961 2e5f 696e 7462 6f75 6e64  lf._ia._intbound
-0001f720: 730a 2020 2020 2020 2020 6962 6d69 6e2c  s.        ibmin,
-0001f730: 2069 626d 6178 203d 2073 656c 662e 5f69   ibmax = self._i
-0001f740: 622e 5f69 6e74 626f 756e 6473 0a20 2020  b._intbounds.   
-0001f750: 2020 2020 2072 6574 7572 6e20 6961 6d69       return iami
-0001f760: 6e20 2a20 6e62 6d69 6e20 2b20 6962 6d69  n * nbmin + ibmi
-0001f770: 6e2c 2028 6961 6d61 7820 616e 6420 6e62  n, (iamax and nb
-0001f780: 6d61 7820 616e 6420 6961 6d61 7820 2a20  max and iamax * 
-0001f790: 6e62 6d61 7829 202b 2069 626d 6178 0a0a  nbmax) + ibmax..
-0001f7a0: 0a63 6c61 7373 2052 616e 6765 2841 7272  .class Range(Arr
-0001f7b0: 6179 293a 0a0a 2020 2020 5f5f 736c 6f74  ay):..    __slot
-0001f7c0: 735f 5f20 3d20 276c 656e 6774 6827 0a0a  s__ = 'length'..
-0001f7d0: 2020 2020 4074 7970 6573 2e61 7070 6c79      @types.apply
-0001f7e0: 5f61 6e6e 6f74 6174 696f 6e73 0a20 2020  _annotations.   
-0001f7f0: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
-0001f800: 6c66 2c20 6c65 6e67 7468 3a20 6173 696e  lf, length: asin
-0001f810: 6465 7829 3a0a 2020 2020 2020 2020 7365  dex):.        se
-0001f820: 6c66 2e6c 656e 6774 6820 3d20 6c65 6e67  lf.length = leng
-0001f830: 7468 0a20 2020 2020 2020 2073 7570 6572  th.        super
-0001f840: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
-0001f850: 3d5b 6c65 6e67 7468 5d2c 2073 6861 7065  =[length], shape
-0001f860: 3d5b 6c65 6e67 7468 5d2c 2064 7479 7065  =[length], dtype
-0001f870: 3d69 6e74 290a 0a20 2020 2064 6566 205f  =int)..    def _
-0001f880: 7461 6b65 2873 656c 662c 2069 6e64 6578  take(self, index
-0001f890: 2c20 6178 6973 293a 0a20 2020 2020 2020  , axis):.       
-0001f8a0: 2072 6574 7572 6e20 496e 5261 6e67 6528   return InRange(
-0001f8b0: 696e 6465 782c 2073 656c 662e 6c65 6e67  index, self.leng
-0001f8c0: 7468 290a 0a20 2020 2064 6566 205f 7274  th)..    def _rt
-0001f8d0: 616b 6528 7365 6c66 2c20 6675 6e63 2c20  ake(self, func, 
-0001f8e0: 6178 6973 293a 0a20 2020 2020 2020 2069  axis):.        i
-0001f8f0: 6620 6571 7561 6c69 6e64 6578 2873 656c  f equalindex(sel
-0001f900: 662e 6c65 6e67 7468 2c20 6675 6e63 2e73  f.length, func.s
-0001f910: 6861 7065 5b61 7869 735d 293a 0a20 2020  hape[axis]):.   
-0001f920: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001f930: 6675 6e63 0a0a 2020 2020 6465 6620 5f72  func..    def _r
-0001f940: 696e 666c 6174 6528 7365 6c66 2c20 6675  inflate(self, fu
-0001f950: 6e63 2c20 6c65 6e67 7468 2c20 6178 6973  nc, length, axis
-0001f960: 293a 0a20 2020 2020 2020 2069 6620 6c65  ):.        if le
-0001f970: 6e67 7468 203d 3d20 7365 6c66 2e6c 656e  ngth == self.len
-0001f980: 6774 683a 0a20 2020 2020 2020 2020 2020  gth:.           
-0001f990: 2072 6574 7572 6e20 6675 6e63 0a0a 2020   return func..  
-0001f9a0: 2020 6465 6620 6576 616c 6628 7365 6c66    def evalf(self
-0001f9b0: 2c20 6c65 6e67 7468 293a 0a20 2020 2020  , length):.     
-0001f9c0: 2020 2072 6574 7572 6e20 6e75 6d70 792e     return numpy.
-0001f9d0: 6172 616e 6765 286c 656e 6774 6829 0a0a  arange(length)..
-0001f9e0: 2020 2020 6465 6620 5f69 6e74 626f 756e      def _intboun
-0001f9f0: 6473 5f69 6d70 6c28 7365 6c66 293a 0a20  ds_impl(self):. 
-0001fa00: 2020 2020 2020 206c 6f77 6572 2c20 7570         lower, up
-0001fa10: 7065 7220 3d20 7365 6c66 2e6c 656e 6774  per = self.lengt
-0001fa20: 682e 5f69 6e74 626f 756e 6473 0a20 2020  h._intbounds.   
-0001fa30: 2020 2020 2061 7373 6572 7420 6c6f 7765       assert lowe
-0001fa40: 7220 3e3d 2030 0a20 2020 2020 2020 2072  r >= 0.        r
-0001fa50: 6574 7572 6e20 302c 206d 6178 2830 2c20  eturn 0, max(0, 
-0001fa60: 7570 7065 7220 2d20 3129 0a0a 0a63 6c61  upper - 1)...cla
-0001fa70: 7373 2049 6e52 616e 6765 2841 7272 6179  ss InRange(Array
-0001fa80: 293a 0a0a 2020 2020 5f5f 736c 6f74 735f  ):..    __slots_
-0001fa90: 5f20 3d20 2769 6e64 6578 272c 2027 6c65  _ = 'index', 'le
-0001faa0: 6e67 7468 270a 0a20 2020 2040 7479 7065  ngth'..    @type
-0001fab0: 732e 6170 706c 795f 616e 6e6f 7461 7469  s.apply_annotati
-0001fac0: 6f6e 730a 2020 2020 6465 6620 5f5f 696e  ons.    def __in
-0001fad0: 6974 5f5f 2873 656c 662c 2069 6e64 6578  it__(self, index
-0001fae0: 3a20 6173 6172 7261 792c 206c 656e 6774  : asarray, lengt
-0001faf0: 683a 2061 7361 7272 6179 293a 0a20 2020  h: asarray):.   
-0001fb00: 2020 2020 2073 656c 662e 696e 6465 7820       self.index 
-0001fb10: 3d20 696e 6465 780a 2020 2020 2020 2020  = index.        
-0001fb20: 7365 6c66 2e6c 656e 6774 6820 3d20 6c65  self.length = le
-0001fb30: 6e67 7468 0a20 2020 2020 2020 2073 7570  ngth.        sup
-0001fb40: 6572 2829 2e5f 5f69 6e69 745f 5f28 6172  er().__init__(ar
-0001fb50: 6773 3d5b 696e 6465 782c 206c 656e 6774  gs=[index, lengt
-0001fb60: 685d 2c20 7368 6170 653d 696e 6465 782e  h], shape=index.
-0001fb70: 7368 6170 652c 2064 7479 7065 3d69 6e74  shape, dtype=int
-0001fb80: 290a 0a20 2020 2064 6566 2065 7661 6c66  )..    def evalf
-0001fb90: 2873 656c 662c 2069 6e64 6578 2c20 6c65  (self, index, le
-0001fba0: 6e67 7468 293a 0a20 2020 2020 2020 2061  ngth):.        a
-0001fbb0: 7373 6572 7420 696e 6465 782e 7369 7a65  ssert index.size
-0001fbc0: 203d 3d20 3020 6f72 2030 203c 3d20 696e   == 0 or 0 <= in
-0001fbd0: 6465 782e 6d69 6e28 2920 616e 6420 696e  dex.min() and in
-0001fbe0: 6465 782e 6d61 7828 2920 3c20 6c65 6e67  dex.max() < leng
-0001fbf0: 7468 0a20 2020 2020 2020 2072 6574 7572  th.        retur
-0001fc00: 6e20 696e 6465 780a 0a20 2020 2064 6566  n index..    def
-0001fc10: 205f 7369 6d70 6c69 6669 6564 2873 656c   _simplified(sel
-0001fc20: 6629 3a0a 2020 2020 2020 2020 6c6f 7765  f):.        lowe
-0001fc30: 725f 6c65 6e67 7468 2c20 7570 7065 725f  r_length, upper_
-0001fc40: 6c65 6e67 7468 203d 2073 656c 662e 6c65  length = self.le
-0001fc50: 6e67 7468 2e5f 696e 7462 6f75 6e64 730a  ngth._intbounds.
-0001fc60: 2020 2020 2020 2020 6c6f 7765 725f 696e          lower_in
-0001fc70: 6465 782c 2075 7070 6572 5f69 6e64 6578  dex, upper_index
-0001fc80: 203d 2073 656c 662e 696e 6465 782e 5f69   = self.index._i
-0001fc90: 6e74 626f 756e 6473 0a20 2020 2020 2020  ntbounds.       
-0001fca0: 2069 6620 3020 3c3d 206c 6f77 6572 5f69   if 0 <= lower_i
-0001fcb0: 6e64 6578 203c 3d20 7570 7065 725f 696e  ndex <= upper_in
-0001fcc0: 6465 7820 3c20 6c6f 7765 725f 6c65 6e67  dex < lower_leng
-0001fcd0: 7468 3a0a 2020 2020 2020 2020 2020 2020  th:.            
-0001fce0: 7265 7475 726e 2073 656c 662e 696e 6465  return self.inde
-0001fcf0: 780a 0a20 2020 2064 6566 205f 696e 7462  x..    def _intb
-0001fd00: 6f75 6e64 735f 696d 706c 2873 656c 6629  ounds_impl(self)
-0001fd10: 3a0a 2020 2020 2020 2020 6c6f 7765 725f  :.        lower_
-0001fd20: 696e 6465 782c 2075 7070 6572 5f69 6e64  index, upper_ind
-0001fd30: 6578 203d 2073 656c 662e 696e 6465 782e  ex = self.index.
-0001fd40: 5f69 6e74 626f 756e 6473 0a20 2020 2020  _intbounds.     
-0001fd50: 2020 206c 6f77 6572 5f6c 656e 6774 682c     lower_length,
-0001fd60: 2075 7070 6572 5f6c 656e 6774 6820 3d20   upper_length = 
-0001fd70: 7365 6c66 2e6c 656e 6774 682e 5f69 6e74  self.length._int
-0001fd80: 626f 756e 6473 0a20 2020 2020 2020 2075  bounds.        u
-0001fd90: 7070 6572 203d 206d 696e 2875 7070 6572  pper = min(upper
-0001fda0: 5f69 6e64 6578 2c20 6d61 7828 302c 2075  _index, max(0, u
-0001fdb0: 7070 6572 5f6c 656e 6774 6820 2d20 3129  pper_length - 1)
-0001fdc0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-0001fdd0: 206d 6178 2830 2c20 6d69 6e28 6c6f 7765   max(0, min(lowe
-0001fde0: 725f 696e 6465 782c 2075 7070 6572 2929  r_index, upper))
-0001fdf0: 2c20 7570 7065 720a 0a0a 636c 6173 7320  , upper...class 
-0001fe00: 506f 6c79 7661 6c28 4172 7261 7929 3a0a  Polyval(Array):.
-0001fe10: 2020 2020 2727 270a 2020 2020 436f 6d70      '''.    Comp
-0001fe20: 7574 6573 2074 6865 203a 6d61 7468 3a60  utes the :math:`
-0001fe30: 6b60 2d64 696d 656e 7369 6f6e 616c 2061  k`-dimensional a
-0001fe40: 7272 6179 0a0a 2020 2020 2e2e 206d 6174  rray..    .. mat
-0001fe50: 683a 3a20 6a5f 302c 5c5c 646f 7473 2c6a  h:: j_0,\\dots,j
-0001fe60: 5f7b 6b2d 317d 205c 5c6d 6170 7374 6f20  _{k-1} \\mapsto 
-0001fe70: 5c5c 7375 6d5f 7b5c 5c73 7562 7374 6163  \\sum_{\\substac
-0001fe80: 6b7b 695f 302c 5c5c 646f 7473 2c69 5f7b  k{i_0,\\dots,i_{
-0001fe90: 6e2d 317d 5c5c 696e 5c5c 6d61 7468 6262  n-1}\\in\\mathbb
-0001fea0: 7b4e 7d5c 5c5c 5c69 5f30 2b5c 5c63 646f  {N}\\\\i_0+\\cdo
-0001feb0: 7473 2b69 5f7b 6e2d 317d 5c5c 6c65 2064  ts+i_{n-1}\\le d
-0001fec0: 7d7d 2070 5f30 5e7b 695f 307d 205c 5c63  }} p_0^{i_0} \\c
-0001fed0: 646f 7473 2070 5f7b 6e2d 317d 5e7b 695f  dots p_{n-1}^{i_
-0001fee0: 7b6e 2d31 7d7d 2063 5f7b 6a5f 302c 5c5c  {n-1}} c_{j_0,\\
-0001fef0: 646f 7473 2c6a 5f7b 6b2d 317d 2c69 5f30  dots,j_{k-1},i_0
-0001ff00: 2c5c 5c64 6f74 732c 695f 7b6e 2d31 7d7d  ,\\dots,i_{n-1}}
-0001ff10: 2c0a 0a20 2020 2077 6865 7265 203a 6d61  ,..    where :ma
-0001ff20: 7468 3a60 7060 2061 7265 2074 6865 203a  th:`p` are the :
-0001ff30: 6d61 7468 3a60 6e60 2d64 696d 656e 7369  math:`n`-dimensi
-0001ff40: 6f6e 616c 206c 6f63 616c 2063 6f6f 7264  onal local coord
-0001ff50: 696e 6174 6573 2061 6e64 203a 6d61 7468  inates and :math
-0001ff60: 3a60 6360 0a20 2020 2069 7320 7468 6520  :`c`.    is the 
-0001ff70: 6172 6775 6d65 6e74 2060 6063 6f65 6666  argument ``coeff
-0001ff80: 7360 6020 616e 6420 3a6d 6174 683a 6064  s`` and :math:`d
-0001ff90: 6020 6973 2074 6865 2064 6567 7265 6520  ` is the degree 
-0001ffa0: 6f66 2074 6865 2070 6f6c 796e 6f6d 6961  of the polynomia
-0001ffb0: 6c2c 0a20 2020 2077 6865 7265 203a 6d61  l,.    where :ma
-0001ffc0: 7468 3a60 6460 2069 7320 7468 6520 6c65  th:`d` is the le
-0001ffd0: 6e67 7468 206f 6620 7468 6520 6c61 7374  ngth of the last
-0001ffe0: 203a 6d61 7468 3a60 6e60 2061 7865 7320   :math:`n` axes 
-0001fff0: 6f66 2060 6063 6f65 6666 7360 602e 0a0a  of ``coeffs``...
-00020000: 2020 2020 2e2e 2077 6172 6e69 6e67 3a3a      .. warning::
-00020010: 0a0a 2020 2020 2020 2041 6c6c 2063 6f65  ..       All coe
-00020020: 6666 6963 6965 6e74 7320 7769 7468 2061  fficients with a
-00020030: 2028 636f 6d62 696e 6564 2920 6465 6772   (combined) degr
-00020040: 6565 206c 6172 6765 7220 7468 616e 203a  ee larger than :
-00020050: 6d61 7468 3a60 6460 2073 686f 756c 6420  math:`d` should 
-00020060: 6265 0a20 2020 2020 2020 7a65 726f 2e20  be.       zero. 
-00020070: 2046 6169 6c69 6e67 2074 6f20 646f 2073   Failing to do s
-00020080: 6f20 776f 6e27 7420 7261 6973 6520 616e  o won't raise an
-00020090: 203a 636c 6173 733a 6045 7863 6570 7469   :class:`Excepti
-000200a0: 6f6e 602c 2062 7574 206d 6967 6874 2067  on`, but might g
-000200b0: 6976 650a 2020 2020 2020 2069 6e63 6f72  ive.       incor
-000200c0: 7265 6374 2072 6573 756c 7473 2e0a 2020  rect results..  
-000200d0: 2020 2727 270a 0a20 2020 205f 5f73 6c6f    '''..    __slo
-000200e0: 7473 5f5f 203d 2027 706f 696e 7473 5f6e  ts__ = 'points_n
-000200f0: 6469 6d27 2c20 2763 6f65 6666 7327 2c20  dim', 'coeffs', 
-00020100: 2770 6f69 6e74 7327 2c20 276e 6772 6164  'points', 'ngrad
-00020110: 270a 0a20 2020 2040 7479 7065 732e 6170  '..    @types.ap
-00020120: 706c 795f 616e 6e6f 7461 7469 6f6e 730a  ply_annotations.
-00020130: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
-00020140: 2873 656c 662c 2063 6f65 6666 733a 2061  (self, coeffs: a
-00020150: 7361 7272 6179 2c20 706f 696e 7473 3a20  sarray, points: 
-00020160: 6173 6172 7261 792c 206e 6772 6164 3a20  asarray, ngrad: 
-00020170: 7479 7065 732e 7374 7269 6374 696e 7420  types.strictint 
-00020180: 3d20 3029 3a0a 2020 2020 2020 2020 6173  = 0):.        as
-00020190: 7365 7274 2063 6f65 6666 732e 6474 7970  sert coeffs.dtyp
-000201a0: 6520 213d 2063 6f6d 706c 6578 2061 6e64  e != complex and
-000201b0: 2070 6f69 6e74 732e 6474 7970 6520 213d   points.dtype !=
-000201c0: 2063 6f6d 706c 6578 0a20 2020 2020 2020   complex.       
-000201d0: 2069 6620 706f 696e 7473 2e6e 6469 6d20   if points.ndim 
-000201e0: 3c20 313a 0a20 2020 2020 2020 2020 2020  < 1:.           
-000201f0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00020200: 7228 2761 7267 756d 656e 7420 6070 6f69  r('argument `poi
-00020210: 6e74 7360 2073 686f 756c 6420 6861 7665  nts` should have
-00020220: 2061 7420 6c65 6173 7420 6f6e 6520 6178   at least one ax
-00020230: 6973 2729 0a20 2020 2020 2020 2069 6620  is').        if 
-00020240: 6e6f 7420 706f 696e 7473 2e73 6861 7065  not points.shape
-00020250: 5b2d 315d 2e69 7363 6f6e 7374 616e 743a  [-1].isconstant:
-00020260: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-00020270: 7365 2056 616c 7565 4572 726f 7228 2774  se ValueError('t
-00020280: 6865 206c 6173 7420 6178 6973 206f 6620  he last axis of 
-00020290: 6172 6775 6d65 6e74 2060 706f 696e 7473  argument `points
-000202a0: 6020 7368 6f75 6c64 2062 6520 6120 636f  ` should be a co
-000202b0: 6e73 7461 6e74 2069 6e74 6567 6572 2729  nstant integer')
-000202c0: 0a20 2020 2020 2020 2073 656c 662e 706f  .        self.po
-000202d0: 696e 7473 5f6e 6469 6d20 3d20 696e 7428  ints_ndim = int(
-000202e0: 706f 696e 7473 2e73 6861 7065 5b2d 315d  points.shape[-1]
-000202f0: 290a 2020 2020 2020 2020 6e64 696d 203d  ).        ndim =
-00020300: 2063 6f65 6666 732e 6e64 696d 202d 2073   coeffs.ndim - s
-00020310: 656c 662e 706f 696e 7473 5f6e 6469 6d0a  elf.points_ndim.
-00020320: 2020 2020 2020 2020 6966 206e 6469 6d20          if ndim 
-00020330: 3c20 303a 0a20 2020 2020 2020 2020 2020  < 0:.           
-00020340: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00020350: 7228 2761 7267 756d 656e 7420 6063 6f65  r('argument `coe
-00020360: 6666 7360 2073 686f 756c 6420 6861 7665  ffs` should have
-00020370: 2061 7420 6c65 6173 7420 6f6e 6520 6178   at least one ax
-00020380: 6973 2070 6572 2073 7061 7469 616c 2064  is per spatial d
-00020390: 696d 656e 7369 6f6e 2729 0a20 2020 2020  imension').     
-000203a0: 2020 2073 656c 662e 636f 6566 6673 203d     self.coeffs =
-000203b0: 2063 6f65 6666 730a 2020 2020 2020 2020   coeffs.        
-000203c0: 7365 6c66 2e70 6f69 6e74 7320 3d20 706f  self.points = po
-000203d0: 696e 7473 0a20 2020 2020 2020 2073 656c  ints.        sel
-000203e0: 662e 6e67 7261 6420 3d20 6e67 7261 640a  f.ngrad = ngrad.
-000203f0: 2020 2020 2020 2020 7375 7065 7228 292e          super().
-00020400: 5f5f 696e 6974 5f5f 2861 7267 733d 5b70  __init__(args=[p
-00020410: 6f69 6e74 732c 2063 6f65 6666 735d 2c20  oints, coeffs], 
-00020420: 7368 6170 653d 706f 696e 7473 2e73 6861  shape=points.sha
-00020430: 7065 5b3a 2d31 5d2b 636f 6566 6673 2e73  pe[:-1]+coeffs.s
-00020440: 6861 7065 5b3a 6e64 696d 5d2b 2873 656c  hape[:ndim]+(sel
-00020450: 662e 706f 696e 7473 5f6e 6469 6d2c 292a  f.points_ndim,)*
-00020460: 6e67 7261 642c 2064 7479 7065 3d66 6c6f  ngrad, dtype=flo
-00020470: 6174 290a 0a20 2020 2064 6566 2065 7661  at)..    def eva
-00020480: 6c66 2873 656c 662c 2070 6f69 6e74 732c  lf(self, points,
-00020490: 2063 6f65 6666 7329 3a0a 2020 2020 2020   coeffs):.      
-000204a0: 2020 666f 7220 6967 7261 6420 696e 2072    for igrad in r
-000204b0: 616e 6765 2873 656c 662e 6e67 7261 6429  ange(self.ngrad)
-000204c0: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
-000204d0: 6566 6673 203d 206e 756d 6572 6963 2e70  effs = numeric.p
-000204e0: 6f6c 795f 6772 6164 2863 6f65 6666 732c  oly_grad(coeffs,
-000204f0: 2073 656c 662e 706f 696e 7473 5f6e 6469   self.points_ndi
-00020500: 6d29 0a20 2020 2020 2020 2072 6574 7572  m).        retur
-00020510: 6e20 6e75 6d65 7269 632e 706f 6c79 5f65  n numeric.poly_e
-00020520: 7661 6c28 636f 6566 6673 2c20 706f 696e  val(coeffs, poin
-00020530: 7473 290a 0a20 2020 2064 6566 205f 6465  ts)..    def _de
-00020540: 7269 7661 7469 7665 2873 656c 662c 2076  rivative(self, v
-00020550: 6172 2c20 7365 656e 293a 0a20 2020 2020  ar, seen):.     
-00020560: 2020 2069 6620 7365 6c66 2e64 7479 7065     if self.dtype
-00020570: 203d 3d20 636f 6d70 6c65 783a 0a20 2020   == complex:.   
-00020580: 2020 2020 2020 2020 2072 6169 7365 204e           raise N
-00020590: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
-000205a0: 6f72 2827 5468 6520 636f 6d70 6c65 7820  or('The complex 
-000205b0: 6465 7269 7661 7469 7665 2069 7320 6e6f  derivative is no
-000205c0: 7420 696d 706c 656d 656e 7465 642e 2729  t implemented.')
-000205d0: 0a20 2020 2020 2020 2064 706f 696e 7473  .        dpoints
-000205e0: 203d 2065 696e 7375 6d28 2741 4269 2c41   = einsum('ABi,A
-000205f0: 6944 2d3e 4142 4427 2c20 506f 6c79 7661  iD->ABD', Polyva
-00020600: 6c28 7365 6c66 2e63 6f65 6666 732c 2073  l(self.coeffs, s
-00020610: 656c 662e 706f 696e 7473 2c20 7365 6c66  elf.points, self
-00020620: 2e6e 6772 6164 2b31 292c 2064 6572 6976  .ngrad+1), deriv
-00020630: 6174 6976 6528 7365 6c66 2e70 6f69 6e74  ative(self.point
-00020640: 732c 2076 6172 2c20 7365 656e 292c 2041  s, var, seen), A
-00020650: 3d73 656c 662e 706f 696e 7473 2e6e 6469  =self.points.ndi
-00020660: 6d2d 3129 0a20 2020 2020 2020 2064 636f  m-1).        dco
-00020670: 6566 6673 203d 2054 7261 6e73 706f 7365  effs = Transpose
-00020680: 2e66 726f 6d5f 656e 6428 506f 6c79 7661  .from_end(Polyva
-00020690: 6c28 5472 616e 7370 6f73 652e 746f 5f65  l(Transpose.to_e
-000206a0: 6e64 2864 6572 6976 6174 6976 6528 7365  nd(derivative(se
-000206b0: 6c66 2e63 6f65 6666 732c 2076 6172 2c20  lf.coeffs, var, 
-000206c0: 7365 656e 292c 202a 7261 6e67 6528 7365  seen), *range(se
-000206d0: 6c66 2e63 6f65 6666 732e 6e64 696d 2929  lf.coeffs.ndim))
-000206e0: 2c20 7365 6c66 2e70 6f69 6e74 732c 2073  , self.points, s
-000206f0: 656c 662e 6e67 7261 6429 2c20 2a72 616e  elf.ngrad), *ran
-00020700: 6765 2873 656c 662e 706f 696e 7473 2e6e  ge(self.points.n
-00020710: 6469 6d2d 312c 2073 656c 662e 6e64 696d  dim-1, self.ndim
-00020720: 2929 0a20 2020 2020 2020 2072 6574 7572  )).        retur
-00020730: 6e20 6470 6f69 6e74 7320 2b20 6463 6f65  n dpoints + dcoe
-00020740: 6666 730a 0a20 2020 2064 6566 205f 7461  ffs..    def _ta
-00020750: 6b65 2873 656c 662c 2069 6e64 6578 2c20  ke(self, index, 
-00020760: 6178 6973 293a 0a20 2020 2020 2020 2069  axis):.        i
-00020770: 6620 6178 6973 203c 2073 656c 662e 706f  f axis < self.po
-00020780: 696e 7473 2e6e 6469 6d20 2d20 313a 0a20  ints.ndim - 1:. 
-00020790: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000207a0: 6e20 506f 6c79 7661 6c28 7365 6c66 2e63  n Polyval(self.c
-000207b0: 6f65 6666 732c 205f 7461 6b65 2873 656c  oeffs, _take(sel
-000207c0: 662e 706f 696e 7473 2c20 696e 6465 782c  f.points, index,
-000207d0: 2061 7869 7329 2c20 7365 6c66 2e6e 6772   axis), self.ngr
-000207e0: 6164 290a 2020 2020 2020 2020 656c 6966  ad).        elif
-000207f0: 2061 7869 7320 3c20 7365 6c66 2e70 6f69   axis < self.poi
-00020800: 6e74 732e 6e64 696d 202d 2031 202b 2073  nts.ndim - 1 + s
-00020810: 656c 662e 636f 6566 6673 2e6e 6469 6d20  elf.coeffs.ndim 
-00020820: 2d20 7365 6c66 2e70 6f69 6e74 735f 6e64  - self.points_nd
-00020830: 696d 3a0a 2020 2020 2020 2020 2020 2020  im:.            
-00020840: 7265 7475 726e 2050 6f6c 7976 616c 285f  return Polyval(_
-00020850: 7461 6b65 2873 656c 662e 636f 6566 6673  take(self.coeffs
-00020860: 2c20 696e 6465 782c 2061 7869 7320 2d20  , index, axis - 
-00020870: 7365 6c66 2e70 6f69 6e74 732e 6e64 696d  self.points.ndim
-00020880: 202b 2031 292c 2073 656c 662e 706f 696e   + 1), self.poin
-00020890: 7473 2c20 7365 6c66 2e6e 6772 6164 290a  ts, self.ngrad).
-000208a0: 0a20 2020 2064 6566 205f 636f 6e73 745f  .    def _const_
-000208b0: 6865 6c70 6572 2873 656c 662c 202a 6a29  helper(self, *j)
-000208c0: 3a0a 2020 2020 2020 2020 6966 206c 656e  :.        if len
-000208d0: 286a 2920 3d3d 2073 656c 662e 6e67 7261  (j) == self.ngra
-000208e0: 643a 0a20 2020 2020 2020 2020 2020 2063  d:.            c
-000208f0: 6f65 6666 7320 3d20 7365 6c66 2e63 6f65  oeffs = self.coe
-00020900: 6666 730a 2020 2020 2020 2020 2020 2020  ffs.            
-00020910: 666f 7220 6920 696e 2072 6576 6572 7365  for i in reverse
-00020920: 6428 7261 6e67 6528 7365 6c66 2e70 6f69  d(range(self.poi
-00020930: 6e74 735f 6e64 696d 2929 3a0a 2020 2020  nts_ndim)):.    
-00020940: 2020 2020 2020 2020 2020 2020 7020 3d20              p = 
-00020950: 6275 696c 7469 6e73 2e73 756d 286b 203d  builtins.sum(k =
-00020960: 3d20 6920 666f 7220 6b20 696e 206a 290a  = i for k in j).
-00020970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020980: 636f 6566 6673 203d 206d 6174 682e 6661  coeffs = math.fa
-00020990: 6374 6f72 6961 6c28 7029 2a67 6574 2863  ctorial(p)*get(c
-000209a0: 6f65 6666 732c 2069 2b73 656c 662e 636f  oeffs, i+self.co
-000209b0: 6566 6673 2e6e 6469 6d2d 7365 6c66 2e70  effs.ndim-self.p
-000209c0: 6f69 6e74 735f 6e64 696d 2c20 7029 0a20  oints_ndim, p). 
-000209d0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000209e0: 6e20 636f 6566 6673 0a20 2020 2020 2020  n coeffs.       
-000209f0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00020a00: 2020 2072 6574 7572 6e20 7374 6163 6b28     return stack(
-00020a10: 5b73 656c 662e 5f63 6f6e 7374 5f68 656c  [self._const_hel
-00020a20: 7065 7228 2a6a 2c20 6b29 2066 6f72 206b  per(*j, k) for k
-00020a30: 2069 6e20 7261 6e67 6528 7365 6c66 2e70   in range(self.p
-00020a40: 6f69 6e74 735f 6e64 696d 295d 2c20 6178  oints_ndim)], ax
-00020a50: 6973 3d73 656c 662e 636f 6566 6673 2e6e  is=self.coeffs.n
-00020a60: 6469 6d2d 7365 6c66 2e70 6f69 6e74 735f  dim-self.points_
-00020a70: 6e64 696d 2b73 656c 662e 6e67 7261 642d  ndim+self.ngrad-
-00020a80: 6c65 6e28 6a29 2d31 290a 0a20 2020 2064  len(j)-1)..    d
-00020a90: 6566 205f 7369 6d70 6c69 6669 6564 2873  ef _simplified(s
-00020aa0: 656c 6629 3a0a 2020 2020 2020 2020 6465  elf):.        de
-00020ab0: 6772 6565 203d 2030 2069 6620 7365 6c66  gree = 0 if self
-00020ac0: 2e70 6f69 6e74 735f 6e64 696d 203d 3d20  .points_ndim == 
-00020ad0: 3020 656c 7365 2073 656c 662e 636f 6566  0 else self.coef
-00020ae0: 6673 2e73 6861 7065 5b2d 315d 2d31 2069  fs.shape[-1]-1 i
-00020af0: 6620 6973 696e 7374 616e 6365 2873 656c  f isinstance(sel
-00020b00: 662e 636f 6566 6673 2e73 6861 7065 5b2d  f.coeffs.shape[-
-00020b10: 315d 2c20 696e 7429 2065 6c73 6520 666c  1], int) else fl
-00020b20: 6f61 7428 2769 6e66 2729 0a20 2020 2020  oat('inf').     
-00020b30: 2020 2069 6620 6973 7a65 726f 2873 656c     if iszero(sel
-00020b40: 662e 636f 6566 6673 2920 6f72 2073 656c  f.coeffs) or sel
-00020b50: 662e 6e67 7261 6420 3e20 6465 6772 6565  f.ngrad > degree
-00020b60: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00020b70: 7475 726e 207a 6572 6f73 5f6c 696b 6528  turn zeros_like(
-00020b80: 7365 6c66 290a 2020 2020 2020 2020 656c  self).        el
-00020b90: 6966 2073 656c 662e 6e67 7261 6420 3d3d  if self.ngrad ==
-00020ba0: 2064 6567 7265 653a 0a20 2020 2020 2020   degree:.       
-00020bb0: 2020 2020 2072 6574 7572 6e20 7072 6570       return prep
-00020bc0: 656e 6461 7865 7328 7365 6c66 2e5f 636f  endaxes(self._co
-00020bd0: 6e73 745f 6865 6c70 6572 2829 2c20 7365  nst_helper(), se
-00020be0: 6c66 2e70 6f69 6e74 732e 7368 6170 655b  lf.points.shape[
-00020bf0: 3a2d 315d 290a 2020 2020 2020 2020 706f  :-1]).        po
-00020c00: 696e 7473 2c20 7768 6572 6520 3d20 756e  ints, where = un
-00020c10: 616c 6967 6e28 7365 6c66 2e70 6f69 6e74  align(self.point
-00020c20: 7329 0a20 2020 2020 2020 2069 6620 706f  s).        if po
-00020c30: 696e 7473 2e6e 6469 6d20 3c20 7365 6c66  ints.ndim < self
-00020c40: 2e70 6f69 6e74 732e 6e64 696d 2061 6e64  .points.ndim and
-00020c50: 2073 6574 2877 6865 7265 2920 213d 2073   set(where) != s
-00020c60: 6574 2872 616e 6765 2873 656c 662e 706f  et(range(self.po
-00020c70: 696e 7473 2e6e 6469 6d2d 3129 293a 0a20  ints.ndim-1)):. 
-00020c80: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-00020c90: 6c66 2e70 6f69 6e74 732e 6e64 696d 202d  lf.points.ndim -
-00020ca0: 2031 206e 6f74 2069 6e20 7768 6572 653a   1 not in where:
-00020cb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00020cc0: 2070 6f69 6e74 7320 3d20 496e 7365 7274   points = Insert
-00020cd0: 4178 6973 2870 6f69 6e74 732c 2073 656c  Axis(points, sel
-00020ce0: 662e 706f 696e 7473 2e73 6861 7065 5b2d  f.points.shape[-
-00020cf0: 315d 290a 2020 2020 2020 2020 2020 2020  1]).            
-00020d00: 2020 2020 7768 6572 6520 2b3d 2073 656c      where += sel
-00020d10: 662e 706f 696e 7473 2e6e 6469 6d20 2d20  f.points.ndim - 
-00020d20: 312c 0a20 2020 2020 2020 2020 2020 2065  1,.            e
-00020d30: 6c69 6620 7768 6572 655b 2d31 5d20 213d  lif where[-1] !=
-00020d40: 2073 656c 662e 706f 696e 7473 2e6e 6469   self.points.ndi
-00020d50: 6d20 2d20 313a 0a20 2020 2020 2020 2020  m - 1:.         
-00020d60: 2020 2020 2020 2070 6f69 6e74 7320 3d20         points = 
-00020d70: 5472 616e 7370 6f73 6528 706f 696e 7473  Transpose(points
-00020d80: 2c20 6e75 6d70 792e 6172 6773 6f72 7428  , numpy.argsort(
-00020d90: 7768 6572 6529 290a 2020 2020 2020 2020  where)).        
-00020da0: 2020 2020 2020 2020 7768 6572 6520 3d20          where = 
-00020db0: 7475 706c 6528 736f 7274 6564 2877 6865  tuple(sorted(whe
-00020dc0: 7265 2929 0a20 2020 2020 2020 2020 2020  re)).           
-00020dd0: 2077 6865 7265 203d 2077 6865 7265 5b3a   where = where[:
-00020de0: 2d31 5d20 2b20 7475 706c 6528 7261 6e67  -1] + tuple(rang
-00020df0: 6528 7365 6c66 2e70 6f69 6e74 732e 6e64  e(self.points.nd
-00020e00: 696d 202d 2031 2c20 7365 6c66 2e6e 6469  im - 1, self.ndi
-00020e10: 6d29 290a 2020 2020 2020 2020 2020 2020  m)).            
-00020e20: 7265 7475 726e 2061 6c69 676e 2850 6f6c  return align(Pol
-00020e30: 7976 616c 2873 656c 662e 636f 6566 6673  yval(self.coeffs
-00020e40: 2c20 706f 696e 7473 2c20 7365 6c66 2e6e  , points, self.n
-00020e50: 6772 6164 292c 2077 6865 7265 2c20 7365  grad), where, se
-00020e60: 6c66 2e73 6861 7065 290a 0a0a 636c 6173  lf.shape)...clas
-00020e70: 7320 506f 6c79 4f75 7465 7250 726f 6475  s PolyOuterProdu
-00020e80: 6374 2841 7272 6179 293a 0a0a 2020 2020  ct(Array):..    
-00020e90: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00020ea0: 662c 206c 6566 742c 2072 6967 6874 293a  f, left, right):
-00020eb0: 0a20 2020 2020 2020 206e 6c65 6674 203d  .        nleft =
-00020ec0: 206c 6566 742e 7368 6170 655b 315d 0a20   left.shape[1]. 
-00020ed0: 2020 2020 2020 2061 7373 6572 7420 616c         assert al
-00020ee0: 6c28 6e20 3d3d 206e 6c65 6674 2066 6f72  l(n == nleft for
-00020ef0: 206e 2069 6e20 6c65 6674 2e73 6861 7065   n in left.shape
-00020f00: 5b32 3a5d 290a 2020 2020 2020 2020 6e72  [2:]).        nr
-00020f10: 6967 6874 203d 2072 6967 6874 2e73 6861  ight = right.sha
-00020f20: 7065 5b31 5d0a 2020 2020 2020 2020 6173  pe[1].        as
-00020f30: 7365 7274 2061 6c6c 286e 203d 3d20 6e72  sert all(n == nr
-00020f40: 6967 6874 2066 6f72 206e 2069 6e20 7269  ight for n in ri
-00020f50: 6768 742e 7368 6170 655b 323a 5d29 0a20  ght.shape[2:]). 
-00020f60: 2020 2020 2020 2073 6861 7065 203d 2028         shape = (
-00020f70: 6c65 6674 2e73 6861 7065 5b30 5d20 2a20  left.shape[0] * 
-00020f80: 7269 6768 742e 7368 6170 655b 305d 2c29  right.shape[0],)
-00020f90: 202b 2028 6e6c 6566 7420 2b20 6e72 6967   + (nleft + nrig
-00020fa0: 6874 202d 2031 2c29 202a 2028 6c65 6674  ht - 1,) * (left
-00020fb0: 2e6e 6469 6d20 2b20 7269 6768 742e 6e64  .ndim + right.nd
-00020fc0: 696d 202d 2032 290a 2020 2020 2020 2020  im - 2).        
-00020fd0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-00020fe0: 2861 7267 733d 5b6c 6566 742c 2072 6967  (args=[left, rig
-00020ff0: 6874 5d2c 2073 6861 7065 3d73 6861 7065  ht], shape=shape
-00021000: 2c20 6474 7970 653d 666c 6f61 7429 0a0a  , dtype=float)..
-00021010: 2020 2020 6465 6620 6576 616c 6628 7365      def evalf(se
-00021020: 6c66 2c20 6c65 6674 2c20 7269 6768 7429  lf, left, right)
-00021030: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00021040: 206e 756d 6572 6963 2e70 6f6c 795f 6f75   numeric.poly_ou
-00021050: 7465 725f 7072 6f64 7563 7428 6c65 6674  ter_product(left
-00021060: 2c20 7269 6768 7429 0a0a 0a63 6c61 7373  , right)...class
-00021070: 204c 6567 656e 6472 6528 4172 7261 7929   Legendre(Array)
-00021080: 3a0a 2020 2020 2727 2753 6572 6965 7320  :.    '''Series 
-00021090: 6f66 204c 6567 656e 6472 6520 706f 6c79  of Legendre poly
-000210a0: 6e6f 6d69 616c 2075 7020 746f 2061 6e64  nomial up to and
-000210b0: 2069 6e63 6c75 6469 6e67 2074 6865 2067   including the g
-000210c0: 6976 656e 2064 6567 7265 652e 0a0a 2020  iven degree...  
-000210d0: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
-000210e0: 202d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2078   ---------.    x
-000210f0: 203a 203a 636c 6173 733a 6041 7272 6179   : :class:`Array
-00021100: 600a 2020 2020 2020 2020 5468 6520 636f  `.        The co
-00021110: 6f72 6469 6e61 7465 7320 746f 2065 7661  ordinates to eva
-00021120: 6c75 6174 6520 7468 6520 7365 7269 6573  luate the series
-00021130: 2061 742e 0a20 2020 2064 6567 7265 6520   at..    degree 
-00021140: 3a20 3a63 6c61 7373 3a60 696e 7460 0a20  : :class:`int`. 
-00021150: 2020 2020 2020 2054 6865 2064 6567 7265         The degre
-00021160: 6520 6f66 2074 6865 206c 6173 7420 706f  e of the last po
-00021170: 6c79 6e6f 6d69 616c 206f 6620 7468 6520  lynomial of the 
-00021180: 7365 7269 6573 2e0a 2020 2020 2727 270a  series..    '''.
-00021190: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-000211a0: 5f28 7365 6c66 2c20 783a 2041 7272 6179  _(self, x: Array
-000211b0: 2c20 6465 6772 6565 3a20 696e 7429 202d  , degree: int) -
-000211c0: 3e20 4e6f 6e65 3a0a 2020 2020 2020 2020  > None:.        
-000211d0: 6173 7365 7274 2078 2e64 7479 7065 203d  assert x.dtype =
-000211e0: 3d20 666c 6f61 740a 2020 2020 2020 2020  = float.        
-000211f0: 7365 6c66 2e5f 7820 3d20 780a 2020 2020  self._x = x.    
-00021200: 2020 2020 7365 6c66 2e5f 6465 6772 6565      self._degree
-00021210: 203d 2064 6567 7265 650a 2020 2020 2020   = degree.      
-00021220: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-00021230: 5f5f 2861 7267 733d 2878 2c29 2c20 7368  __(args=(x,), sh
-00021240: 6170 653d 282a 782e 7368 6170 652c 2064  ape=(*x.shape, d
-00021250: 6567 7265 652b 3129 2c20 6474 7970 653d  egree+1), dtype=
-00021260: 666c 6f61 7429 0a0a 2020 2020 6465 6620  float)..    def 
-00021270: 6576 616c 6628 7365 6c66 2c20 783a 206e  evalf(self, x: n
-00021280: 756d 7079 2e6e 6461 7272 6179 2920 2d3e  umpy.ndarray) ->
-00021290: 206e 756d 7079 2e6e 6461 7272 6179 3a0a   numpy.ndarray:.
-000212a0: 2020 2020 2020 2020 5020 3d20 6e75 6d70          P = nump
-000212b0: 792e 656d 7074 7928 282a 782e 7368 6170  y.empty((*x.shap
-000212c0: 652c 2073 656c 662e 5f64 6567 7265 652b  e, self._degree+
-000212d0: 3129 2c20 6474 7970 653d 666c 6f61 7429  1), dtype=float)
-000212e0: 0a20 2020 2020 2020 2050 5b2e 2e2e 2c20  .        P[..., 
-000212f0: 305d 203d 2031 0a20 2020 2020 2020 2069  0] = 1.        i
-00021300: 6620 7365 6c66 2e5f 6465 6772 6565 3a0a  f self._degree:.
-00021310: 2020 2020 2020 2020 2020 2020 505b 2e2e              P[..
-00021320: 2e2c 2031 5d20 3d20 780a 2020 2020 2020  ., 1] = x.      
-00021330: 2020 666f 7220 6920 696e 2072 616e 6765    for i in range
-00021340: 2832 2c20 7365 6c66 2e5f 6465 6772 6565  (2, self._degree
-00021350: 2b31 293a 0a20 2020 2020 2020 2020 2020  +1):.           
-00021360: 2050 5b2e 2e2e 2c20 695d 203d 2028 322d   P[..., i] = (2-
-00021370: 312f 6929 2a50 5b2e 2e2e 2c20 315d 2a50  1/i)*P[..., 1]*P
-00021380: 5b2e 2e2e 2c20 692d 315d 202d 2028 312d  [..., i-1] - (1-
-00021390: 312f 6929 2a50 5b2e 2e2e 2c20 692d 325d  1/i)*P[..., i-2]
-000213a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000213b0: 500a 0a20 2020 2064 6566 205f 6465 7269  P..    def _deri
-000213c0: 7661 7469 7665 2873 656c 662c 2076 6172  vative(self, var
-000213d0: 2c20 7365 656e 293a 0a20 2020 2020 2020  , seen):.       
-000213e0: 2069 6620 7365 6c66 2e64 7479 7065 203d   if self.dtype =
-000213f0: 3d20 636f 6d70 6c65 783a 0a20 2020 2020  = complex:.     
-00021400: 2020 2020 2020 2072 6169 7365 204e 6f74         raise Not
-00021410: 496d 706c 656d 656e 7465 6445 7272 6f72  ImplementedError
-00021420: 2827 5468 6520 636f 6d70 6c65 7820 6465  ('The complex de
-00021430: 7269 7661 7469 7665 2069 7320 6e6f 7420  rivative is not 
-00021440: 696d 706c 656d 656e 7465 642e 2729 0a20  implemented.'). 
-00021450: 2020 2020 2020 2064 203d 206e 756d 7079         d = numpy
-00021460: 2e7a 6572 6f73 2828 7365 6c66 2e5f 6465  .zeros((self._de
-00021470: 6772 6565 2b31 2c29 2a32 2c20 6474 7970  gree+1,)*2, dtyp
-00021480: 653d 696e 7429 0a20 2020 2020 2020 2066  e=int).        f
-00021490: 6f72 2069 2069 6e20 7261 6e67 6528 7365  or i in range(se
-000214a0: 6c66 2e5f 6465 6772 6565 2b31 293a 0a20  lf._degree+1):. 
-000214b0: 2020 2020 2020 2020 2020 2064 5b69 2c20             d[i, 
-000214c0: 692b 313a 3a32 5d20 3d20 322a 692b 310a  i+1::2] = 2*i+1.
-000214d0: 2020 2020 2020 2020 6473 656c 6620 3d20          dself = 
-000214e0: 6569 6e73 756d 2827 4169 2c69 6a2d 3e41  einsum('Ai,ij->A
-000214f0: 6a27 2c20 7365 6c66 2c20 6429 0a20 2020  j', self, d).   
-00021500: 2020 2020 2072 6574 7572 6e20 6569 6e73       return eins
-00021510: 756d 2827 4169 2c41 422d 3e41 6942 272c  um('Ai,AB->AiB',
-00021520: 2064 7365 6c66 2c20 6465 7269 7661 7469   dself, derivati
-00021530: 7665 2873 656c 662e 5f78 2c20 7661 722c  ve(self._x, var,
-00021540: 2073 6565 6e29 290a 0a20 2020 2064 6566   seen))..    def
-00021550: 205f 7369 6d70 6c69 6669 6564 2873 656c   _simplified(sel
-00021560: 6629 3a0a 2020 2020 2020 2020 756e 616c  f):.        unal
-00021570: 6967 6e65 642c 2077 6865 7265 203d 2075  igned, where = u
-00021580: 6e61 6c69 676e 2873 656c 662e 5f78 290a  nalign(self._x).
-00021590: 2020 2020 2020 2020 6966 2077 6865 7265          if where
-000215a0: 2021 3d20 7475 706c 6528 7261 6e67 6528   != tuple(range(
-000215b0: 7365 6c66 2e5f 782e 6e64 696d 2929 3a0a  self._x.ndim)):.
-000215c0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000215d0: 726e 2061 6c69 676e 284c 6567 656e 6472  rn align(Legendr
-000215e0: 6528 756e 616c 6967 6e65 642c 2073 656c  e(unaligned, sel
-000215f0: 662e 5f64 6567 7265 6529 2c20 282a 7768  f._degree), (*wh
-00021600: 6572 652c 2073 656c 662e 6e64 696d 2d31  ere, self.ndim-1
-00021610: 292c 2073 656c 662e 7368 6170 6529 0a0a  ), self.shape)..
-00021620: 2020 2020 6465 6620 5f74 616b 6564 6961      def _takedia
-00021630: 6728 7365 6c66 2c20 6178 6973 312c 2061  g(self, axis1, a
-00021640: 7869 7332 293a 0a20 2020 2020 2020 2069  xis2):.        i
-00021650: 6620 6178 6973 3120 3c20 7365 6c66 2e6e  f axis1 < self.n
-00021660: 6469 6d20 2d20 3120 616e 6420 6178 6973  dim - 1 and axis
-00021670: 3220 3c20 7365 6c66 2e6e 6469 6d20 2d20  2 < self.ndim - 
-00021680: 313a 0a20 2020 2020 2020 2020 2020 2072  1:.            r
-00021690: 6574 7572 6e20 5472 616e 7370 6f73 652e  eturn Transpose.
-000216a0: 746f 5f65 6e64 284c 6567 656e 6472 6528  to_end(Legendre(
-000216b0: 5f74 616b 6564 6961 6728 7365 6c66 2e5f  _takediag(self._
-000216c0: 782c 2061 7869 7331 2c20 6178 6973 3229  x, axis1, axis2)
-000216d0: 2c20 7365 6c66 2e5f 6465 6772 6565 292c  , self._degree),
-000216e0: 202d 3229 0a0a 2020 2020 6465 6620 5f74   -2)..    def _t
-000216f0: 616b 6528 7365 6c66 2c20 696e 6465 782c  ake(self, index,
-00021700: 2061 7869 7329 3a0a 2020 2020 2020 2020   axis):.        
-00021710: 6966 2061 7869 7320 3c20 7365 6c66 2e6e  if axis < self.n
-00021720: 6469 6d20 2d20 313a 0a20 2020 2020 2020  dim - 1:.       
-00021730: 2020 2020 2072 6574 7572 6e20 4c65 6765       return Lege
-00021740: 6e64 7265 285f 7461 6b65 2873 656c 662e  ndre(_take(self.
-00021750: 5f78 2c20 696e 6465 782c 2061 7869 7329  _x, index, axis)
-00021760: 2c20 7365 6c66 2e5f 6465 6772 6565 290a  , self._degree).
-00021770: 0a20 2020 2064 6566 205f 756e 7261 7665  .    def _unrave
-00021780: 6c28 7365 6c66 2c20 6178 6973 2c20 7368  l(self, axis, sh
-00021790: 6170 6529 3a0a 2020 2020 2020 2020 6966  ape):.        if
-000217a0: 2061 7869 7320 3c20 7365 6c66 2e6e 6469   axis < self.ndi
-000217b0: 6d20 2d20 313a 0a20 2020 2020 2020 2020  m - 1:.         
-000217c0: 2020 2072 6574 7572 6e20 4c65 6765 6e64     return Legend
-000217d0: 7265 2875 6e72 6176 656c 2873 656c 662e  re(unravel(self.
-000217e0: 5f78 2c20 6178 6973 2c20 7368 6170 6529  _x, axis, shape)
-000217f0: 2c20 7365 6c66 2e5f 6465 6772 6565 290a  , self._degree).
-00021800: 0a0a 636c 6173 7320 4368 6f6f 7365 2841  ..class Choose(A
-00021810: 7272 6179 293a 0a20 2020 2027 2727 4675  rray):.    '''Fu
-00021820: 6e63 7469 6f6e 2065 7175 6976 616c 656e  nction equivalen
-00021830: 7420 6f66 203a 6675 6e63 3a60 6e75 6d70  t of :func:`nump
-00021840: 792e 6368 6f6f 7365 602e 2727 270a 0a20  y.choose`.'''.. 
-00021850: 2020 2040 7479 7065 732e 6170 706c 795f     @types.apply_
-00021860: 616e 6e6f 7461 7469 6f6e 730a 2020 2020  annotations.    
-00021870: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00021880: 662c 2069 6e64 6578 3a20 6173 6172 7261  f, index: asarra
-00021890: 792c 2063 686f 6963 6573 3a20 6173 6172  y, choices: asar
-000218a0: 7261 7973 293a 0a20 2020 2020 2020 2069  rays):.        i
-000218b0: 6620 696e 6465 782e 6474 7970 6520 213d  f index.dtype !=
-000218c0: 2069 6e74 3a0a 2020 2020 2020 2020 2020   int:.          
-000218d0: 2020 7261 6973 6520 4578 6365 7074 696f    raise Exceptio
-000218e0: 6e28 2769 6e64 6578 206d 7573 7420 6265  n('index must be
-000218f0: 2069 6e74 6567 6572 2076 616c 7565 6427   integer valued'
-00021900: 290a 2020 2020 2020 2020 6474 7970 6520  ).        dtype 
-00021910: 3d20 6368 6f69 6365 735b 305d 2e64 7479  = choices[0].dty
-00021920: 7065 0a20 2020 2020 2020 2069 6620 616e  pe.        if an
-00021930: 7928 6368 6f69 6365 2e64 7479 7065 2021  y(choice.dtype !
-00021940: 3d20 6474 7970 6520 666f 7220 6368 6f69  = dtype for choi
-00021950: 6365 2069 6e20 6368 6f69 6365 735b 313a  ce in choices[1:
-00021960: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
-00021970: 7261 6973 6520 4578 6365 7074 696f 6e28  raise Exception(
-00021980: 2764 7479 7065 7320 7661 7279 2729 0a20  'dtypes vary'). 
-00021990: 2020 2020 2020 2073 6861 7065 203d 2069         shape = i
-000219a0: 6e64 6578 2e73 6861 7065 0a20 2020 2020  ndex.shape.     
-000219b0: 2020 2069 6620 6e6f 7420 616c 6c28 6571     if not all(eq
-000219c0: 7561 6c73 6861 7065 2863 686f 6963 652e  ualshape(choice.
-000219d0: 7368 6170 652c 2073 6861 7065 2920 666f  shape, shape) fo
-000219e0: 7220 6368 6f69 6365 2069 6e20 6368 6f69  r choice in choi
-000219f0: 6365 7329 3a0a 2020 2020 2020 2020 2020  ces):.          
-00021a00: 2020 7261 6973 6520 4578 6365 7074 696f    raise Exceptio
-00021a10: 6e28 2773 6861 7065 7320 7661 7279 2729  n('shapes vary')
-00021a20: 0a20 2020 2020 2020 2073 656c 662e 696e  .        self.in
-00021a30: 6465 7820 3d20 696e 6465 780a 2020 2020  dex = index.    
-00021a40: 2020 2020 7365 6c66 2e63 686f 6963 6573      self.choices
-00021a50: 203d 2063 686f 6963 6573 0a20 2020 2020   = choices.     
-00021a60: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
-00021a70: 745f 5f28 6172 6773 3d28 696e 6465 782c  t__(args=(index,
-00021a80: 292b 6368 6f69 6365 732c 2073 6861 7065  )+choices, shape
-00021a90: 3d73 6861 7065 2c20 6474 7970 653d 6474  =shape, dtype=dt
-00021aa0: 7970 6529 0a0a 2020 2020 6465 6620 6576  ype)..    def ev
-00021ab0: 616c 6628 7365 6c66 2c20 696e 6465 782c  alf(self, index,
-00021ac0: 202a 6368 6f69 6365 7329 3a0a 2020 2020   *choices):.    
-00021ad0: 2020 2020 7265 7475 726e 206e 756d 7079      return numpy
-00021ae0: 2e63 686f 6f73 6528 696e 6465 782c 2063  .choose(index, c
-00021af0: 686f 6963 6573 290a 0a20 2020 2064 6566  hoices)..    def
-00021b00: 205f 6465 7269 7661 7469 7665 2873 656c   _derivative(sel
-00021b10: 662c 2076 6172 2c20 7365 656e 293a 0a20  f, var, seen):. 
-00021b20: 2020 2020 2020 2072 6574 7572 6e20 4368         return Ch
-00021b30: 6f6f 7365 2861 7070 656e 6461 7865 7328  oose(appendaxes(
-00021b40: 7365 6c66 2e69 6e64 6578 2c20 7661 722e  self.index, var.
-00021b50: 7368 6170 6529 2c20 5b64 6572 6976 6174  shape), [derivat
-00021b60: 6976 6528 6368 6f69 6365 2c20 7661 722c  ive(choice, var,
-00021b70: 2073 6565 6e29 2066 6f72 2063 686f 6963   seen) for choic
-00021b80: 6520 696e 2073 656c 662e 6368 6f69 6365  e in self.choice
-00021b90: 735d 290a 0a20 2020 2064 6566 205f 7369  s])..    def _si
-00021ba0: 6d70 6c69 6669 6564 2873 656c 6629 3a0a  mplified(self):.
-00021bb0: 2020 2020 2020 2020 6966 2061 6c6c 2863          if all(c
-00021bc0: 686f 6963 6520 3d3d 2073 656c 662e 6368  hoice == self.ch
-00021bd0: 6f69 6365 735b 305d 2066 6f72 2063 686f  oices[0] for cho
-00021be0: 6963 6520 696e 2073 656c 662e 6368 6f69  ice in self.choi
-00021bf0: 6365 735b 313a 5d29 3a0a 2020 2020 2020  ces[1:]):.      
-00021c00: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00021c10: 662e 6368 6f69 6365 735b 305d 0a20 2020  f.choices[0].   
-00021c20: 2020 2020 2069 6e64 6578 2c20 2a63 686f       index, *cho
-00021c30: 6963 6573 2c20 7768 6572 6520 3d20 756e  ices, where = un
-00021c40: 616c 6967 6e28 7365 6c66 2e69 6e64 6578  align(self.index
-00021c50: 2c20 2a73 656c 662e 6368 6f69 6365 7329  , *self.choices)
-00021c60: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
-00021c70: 7768 6572 6529 203c 2073 656c 662e 6e64  where) < self.nd
-00021c80: 696d 3a0a 2020 2020 2020 2020 2020 2020  im:.            
-00021c90: 7265 7475 726e 2061 6c69 676e 2843 686f  return align(Cho
-00021ca0: 6f73 6528 696e 6465 782c 2063 686f 6963  ose(index, choic
-00021cb0: 6573 292c 2077 6865 7265 2c20 7365 6c66  es), where, self
-00021cc0: 2e73 6861 7065 290a 0a20 2020 2064 6566  .shape)..    def
-00021cd0: 205f 6d75 6c74 6970 6c79 2873 656c 662c   _multiply(self,
-00021ce0: 206f 7468 6572 293a 0a20 2020 2020 2020   other):.       
-00021cf0: 2069 6620 6973 696e 7374 616e 6365 286f   if isinstance(o
-00021d00: 7468 6572 2c20 4368 6f6f 7365 2920 616e  ther, Choose) an
-00021d10: 6420 7365 6c66 2e69 6e64 6578 203d 3d20  d self.index == 
-00021d20: 6f74 6865 722e 696e 6465 783a 0a20 2020  other.index:.   
-00021d30: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00021d40: 4368 6f6f 7365 2873 656c 662e 696e 6465  Choose(self.inde
-00021d50: 782c 206d 6170 286d 756c 7469 706c 792c  x, map(multiply,
-00021d60: 2073 656c 662e 6368 6f69 6365 732c 206f   self.choices, o
-00021d70: 7468 6572 2e63 686f 6963 6573 2929 0a0a  ther.choices))..
-00021d80: 2020 2020 6465 6620 5f67 6574 2873 656c      def _get(sel
-00021d90: 662c 2069 2c20 6974 656d 293a 0a20 2020  f, i, item):.   
-00021da0: 2020 2020 2072 6574 7572 6e20 4368 6f6f       return Choo
-00021db0: 7365 2867 6574 2873 656c 662e 696e 6465  se(get(self.inde
-00021dc0: 782c 2069 2c20 6974 656d 292c 205b 6765  x, i, item), [ge
-00021dd0: 7428 6368 6f69 6365 2c20 692c 2069 7465  t(choice, i, ite
-00021de0: 6d29 2066 6f72 2063 686f 6963 6520 696e  m) for choice in
-00021df0: 2073 656c 662e 6368 6f69 6365 735d 290a   self.choices]).
-00021e00: 0a20 2020 2064 6566 205f 7375 6d28 7365  .    def _sum(se
-00021e10: 6c66 2c20 6178 6973 293a 0a20 2020 2020  lf, axis):.     
-00021e20: 2020 2075 6e61 6c69 676e 6564 2c20 7768     unaligned, wh
-00021e30: 6572 6520 3d20 756e 616c 6967 6e28 7365  ere = unalign(se
-00021e40: 6c66 2e69 6e64 6578 290a 2020 2020 2020  lf.index).      
-00021e50: 2020 6966 2061 7869 7320 6e6f 7420 696e    if axis not in
-00021e60: 2077 6865 7265 3a0a 2020 2020 2020 2020   where:.        
-00021e70: 2020 2020 696e 6465 7820 3d20 616c 6967      index = alig
-00021e80: 6e28 756e 616c 6967 6e65 642c 205b 692d  n(unaligned, [i-
-00021e90: 2869 203e 2061 7869 7329 2066 6f72 2069  (i > axis) for i
-00021ea0: 2069 6e20 7768 6572 655d 2c20 7365 6c66   in where], self
-00021eb0: 2e73 6861 7065 5b3a 6178 6973 5d2b 7365  .shape[:axis]+se
-00021ec0: 6c66 2e73 6861 7065 5b61 7869 732b 313a  lf.shape[axis+1:
-00021ed0: 5d29 0a20 2020 2020 2020 2020 2020 2072  ]).            r
-00021ee0: 6574 7572 6e20 4368 6f6f 7365 2869 6e64  eturn Choose(ind
-00021ef0: 6578 2c20 5b73 756d 2863 686f 6963 652c  ex, [sum(choice,
-00021f00: 2061 7869 7329 2066 6f72 2063 686f 6963   axis) for choic
-00021f10: 6520 696e 2073 656c 662e 6368 6f69 6365  e in self.choice
-00021f20: 735d 290a 0a20 2020 2064 6566 205f 7461  s])..    def _ta
-00021f30: 6b65 2873 656c 662c 2069 6e64 6578 2c20  ke(self, index, 
-00021f40: 6178 6973 293a 0a20 2020 2020 2020 2072  axis):.        r
-00021f50: 6574 7572 6e20 4368 6f6f 7365 285f 7461  eturn Choose(_ta
-00021f60: 6b65 2873 656c 662e 696e 6465 782c 2069  ke(self.index, i
-00021f70: 6e64 6578 2c20 6178 6973 292c 205b 5f74  ndex, axis), [_t
-00021f80: 616b 6528 6368 6f69 6365 2c20 696e 6465  ake(choice, inde
-00021f90: 782c 2061 7869 7329 2066 6f72 2063 686f  x, axis) for cho
-00021fa0: 6963 6520 696e 2073 656c 662e 6368 6f69  ice in self.choi
-00021fb0: 6365 735d 290a 0a20 2020 2064 6566 205f  ces])..    def _
-00021fc0: 7461 6b65 6469 6167 2873 656c 662c 2061  takediag(self, a
-00021fd0: 7869 732c 2072 6d61 7869 7329 3a0a 2020  xis, rmaxis):.  
-00021fe0: 2020 2020 2020 7265 7475 726e 2043 686f        return Cho
-00021ff0: 6f73 6528 7461 6b65 6469 6167 2873 656c  ose(takediag(sel
-00022000: 662e 696e 6465 782c 2061 7869 732c 2072  f.index, axis, r
-00022010: 6d61 7869 7329 2c20 5b74 616b 6564 6961  maxis), [takedia
-00022020: 6728 6368 6f69 6365 2c20 6178 6973 2c20  g(choice, axis, 
-00022030: 726d 6178 6973 2920 666f 7220 6368 6f69  rmaxis) for choi
-00022040: 6365 2069 6e20 7365 6c66 2e63 686f 6963  ce in self.choic
-00022050: 6573 5d29 0a0a 2020 2020 6465 6620 5f70  es])..    def _p
-00022060: 726f 6475 6374 2873 656c 6629 3a0a 2020  roduct(self):.  
-00022070: 2020 2020 2020 756e 616c 6967 6e65 642c        unaligned,
-00022080: 2077 6865 7265 203d 2075 6e61 6c69 676e   where = unalign
-00022090: 2873 656c 662e 696e 6465 7829 0a20 2020  (self.index).   
-000220a0: 2020 2020 2069 6620 7365 6c66 2e6e 6469       if self.ndi
-000220b0: 6d2d 3120 6e6f 7420 696e 2077 6865 7265  m-1 not in where
-000220c0: 3a0a 2020 2020 2020 2020 2020 2020 696e  :.            in
-000220d0: 6465 7820 3d20 616c 6967 6e28 756e 616c  dex = align(unal
-000220e0: 6967 6e65 642c 2077 6865 7265 2c20 7365  igned, where, se
-000220f0: 6c66 2e73 6861 7065 5b3a 2d31 5d29 0a20  lf.shape[:-1]). 
-00022100: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00022110: 6e20 4368 6f6f 7365 2869 6e64 6578 2c20  n Choose(index, 
-00022120: 5b50 726f 6475 6374 2863 686f 6963 6529  [Product(choice)
-00022130: 2066 6f72 2063 686f 6963 6520 696e 2073   for choice in s
-00022140: 656c 662e 6368 6f69 6365 735d 290a 0a0a  elf.choices])...
-00022150: 636c 6173 7320 4e6f 726d 4469 6d28 4172  class NormDim(Ar
-00022160: 7261 7929 3a0a 0a20 2020 2040 7479 7065  ray):..    @type
-00022170: 732e 6170 706c 795f 616e 6e6f 7461 7469  s.apply_annotati
-00022180: 6f6e 730a 2020 2020 6465 6620 5f5f 696e  ons.    def __in
-00022190: 6974 5f5f 2873 656c 662c 206c 656e 6774  it__(self, lengt
-000221a0: 683a 2061 7361 7272 6179 2c20 696e 6465  h: asarray, inde
-000221b0: 783a 2061 7361 7272 6179 293a 0a20 2020  x: asarray):.   
-000221c0: 2020 2020 2061 7373 6572 7420 6c65 6e67       assert leng
-000221d0: 7468 2e64 7479 7065 203d 3d20 696e 740a  th.dtype == int.
-000221e0: 2020 2020 2020 2020 6173 7365 7274 2069          assert i
-000221f0: 6e64 6578 2e64 7479 7065 203d 3d20 696e  ndex.dtype == in
-00022200: 740a 2020 2020 2020 2020 6173 7365 7274  t.        assert
-00022210: 2065 7175 616c 7368 6170 6528 6c65 6e67   equalshape(leng
-00022220: 7468 2e73 6861 7065 2c20 696e 6465 782e  th.shape, index.
-00022230: 7368 6170 6529 0a20 2020 2020 2020 2023  shape).        #
-00022240: 2054 6865 2066 6f6c 6c6f 7769 6e67 2063   The following c
-00022250: 6f72 6e65 7220 6361 7365 7320 6d61 6b65  orner cases make
-00022260: 7320 7468 6520 6173 7365 7274 696f 6e20  s the assertion 
-00022270: 6661 696c 2c20 6865 6e63 6520 7765 2063  fail, hence we c
-00022280: 616e 206f 6e6c 790a 2020 2020 2020 2020  an only.        
-00022290: 2320 6173 7365 7274 2074 6865 2062 6f75  # assert the bou
-000222a0: 6e64 7320 6966 2074 6865 2061 7272 6179  nds if the array
-000222b0: 7320 6172 6520 6775 6172 616e 7465 6564  s are guaranteed
-000222c0: 2074 6f20 6265 2075 6e65 6d70 7479 3a0a   to be unempty:.
-000222d0: 2020 2020 2020 2020 230a 2020 2020 2020          #.      
-000222e0: 2020 2320 2020 2020 5461 6b65 2866 756e    #     Take(fun
-000222f0: 632c 204e 6f72 6d44 696d 2866 756e 632e  c, NormDim(func.
-00022300: 7368 6170 655b 2d31 5d2c 2052 616e 6765  shape[-1], Range
-00022310: 2830 2920 2b20 6675 6e63 2e73 6861 7065  (0) + func.shape
-00022320: 5b2d 315d 2929 0a20 2020 2020 2020 2069  [-1])).        i
-00022330: 6620 616c 6c28 6e2e 5f69 6e74 626f 756e  f all(n._intboun
-00022340: 6473 5b30 5d20 3e20 3020 666f 7220 6e20  ds[0] > 0 for n 
-00022350: 696e 2069 6e64 6578 2e73 6861 7065 293a  in index.shape):
-00022360: 0a20 2020 2020 2020 2020 2020 2061 7373  .            ass
-00022370: 6572 7420 2d6c 656e 6774 682e 5f69 6e74  ert -length._int
-00022380: 626f 756e 6473 5b31 5d20 3c3d 2069 6e64  bounds[1] <= ind
-00022390: 6578 2e5f 696e 7462 6f75 6e64 735b 305d  ex._intbounds[0]
-000223a0: 2061 6e64 2069 6e64 6578 2e5f 696e 7462   and index._intb
-000223b0: 6f75 6e64 735b 315d 203c 3d20 6c65 6e67  ounds[1] <= leng
-000223c0: 7468 2e5f 696e 7462 6f75 6e64 735b 315d  th._intbounds[1]
-000223d0: 202d 2031 0a20 2020 2020 2020 2073 656c   - 1.        sel
-000223e0: 662e 6c65 6e67 7468 203d 206c 656e 6774  f.length = lengt
-000223f0: 680a 2020 2020 2020 2020 7365 6c66 2e69  h.        self.i
-00022400: 6e64 6578 203d 2069 6e64 6578 0a20 2020  ndex = index.   
-00022410: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
-00022420: 6e69 745f 5f28 6172 6773 3d5b 6c65 6e67  nit__(args=[leng
-00022430: 7468 2c20 696e 6465 785d 2c20 7368 6170  th, index], shap
-00022440: 653d 696e 6465 782e 7368 6170 652c 2064  e=index.shape, d
-00022450: 7479 7065 3d69 6e64 6578 2e64 7479 7065  type=index.dtype
-00022460: 290a 0a20 2020 2064 6566 2065 7661 6c66  )..    def evalf
-00022470: 2873 656c 662c 206c 656e 6774 682c 2069  (self, length, i
-00022480: 6e64 6578 293a 0a20 2020 2020 2020 2061  ndex):.        a
-00022490: 7373 6572 7420 6c65 6e67 7468 2e73 6861  ssert length.sha
-000224a0: 7065 203d 3d20 696e 6465 782e 7368 6170  pe == index.shap
-000224b0: 650a 2020 2020 2020 2020 6173 7365 7274  e.        assert
-000224c0: 206c 656e 6774 682e 6474 7970 652e 6b69   length.dtype.ki
-000224d0: 6e64 203d 3d20 2769 270a 2020 2020 2020  nd == 'i'.      
-000224e0: 2020 6173 7365 7274 2069 6e64 6578 2e64    assert index.d
-000224f0: 7479 7065 2e6b 696e 6420 3d3d 2027 6927  type.kind == 'i'
-00022500: 0a20 2020 2020 2020 2072 6573 756c 7420  .        result 
-00022510: 3d20 6e75 6d70 792e 656d 7074 7928 696e  = numpy.empty(in
-00022520: 6465 782e 7368 6170 652c 2064 7479 7065  dex.shape, dtype
-00022530: 3d69 6e74 290a 2020 2020 2020 2020 666f  =int).        fo
-00022540: 7220 6920 696e 206e 756d 7079 2e6e 6469  r i in numpy.ndi
-00022550: 6e64 6578 2869 6e64 6578 2e73 6861 7065  ndex(index.shape
-00022560: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-00022570: 6573 756c 745b 695d 203d 206e 756d 6572  esult[i] = numer
-00022580: 6963 2e6e 6f72 6d64 696d 286c 656e 6774  ic.normdim(lengt
-00022590: 685b 695d 2c20 696e 6465 785b 695d 290a  h[i], index[i]).
-000225a0: 2020 2020 2020 2020 7265 7475 726e 2072          return r
-000225b0: 6573 756c 740a 0a20 2020 2064 6566 205f  esult..    def _
-000225c0: 7369 6d70 6c69 6669 6564 2873 656c 6629  simplified(self)
-000225d0: 3a0a 2020 2020 2020 2020 6c6f 7765 725f  :.        lower_
-000225e0: 6c65 6e67 7468 2c20 7570 7065 725f 6c65  length, upper_le
-000225f0: 6e67 7468 203d 2073 656c 662e 6c65 6e67  ngth = self.leng
-00022600: 7468 2e5f 696e 7462 6f75 6e64 730a 2020  th._intbounds.  
-00022610: 2020 2020 2020 6c6f 7765 725f 696e 6465        lower_inde
-00022620: 782c 2075 7070 6572 5f69 6e64 6578 203d  x, upper_index =
-00022630: 2073 656c 662e 696e 6465 782e 5f69 6e74   self.index._int
-00022640: 626f 756e 6473 0a20 2020 2020 2020 2069  bounds.        i
-00022650: 6620 3020 3c3d 206c 6f77 6572 5f69 6e64  f 0 <= lower_ind
-00022660: 6578 2061 6e64 2075 7070 6572 5f69 6e64  ex and upper_ind
-00022670: 6578 203c 206c 6f77 6572 5f6c 656e 6774  ex < lower_lengt
-00022680: 683a 0a20 2020 2020 2020 2020 2020 2072  h:.            r
-00022690: 6574 7572 6e20 7365 6c66 2e69 6e64 6578  eturn self.index
-000226a0: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
-000226b0: 7374 616e 6365 286c 6f77 6572 5f6c 656e  stance(lower_len
-000226c0: 6774 682c 2069 6e74 2920 616e 6420 6c6f  gth, int) and lo
-000226d0: 7765 725f 6c65 6e67 7468 203d 3d20 7570  wer_length == up
-000226e0: 7065 725f 6c65 6e67 7468 2061 6e64 202d  per_length and -
-000226f0: 6c6f 7765 725f 6c65 6e67 7468 203c 3d20  lower_length <= 
-00022700: 6c6f 7765 725f 696e 6465 7820 616e 6420  lower_index and 
-00022710: 7570 7065 725f 696e 6465 7820 3c20 303a  upper_index < 0:
-00022720: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00022730: 7572 6e20 7365 6c66 2e69 6e64 6578 202b  urn self.index +
-00022740: 206c 6f77 6572 5f6c 656e 6774 680a 2020   lower_length.  
-00022750: 2020 2020 2020 6966 2073 656c 662e 6c65        if self.le
-00022760: 6e67 7468 2e69 7363 6f6e 7374 616e 7420  ngth.isconstant 
-00022770: 616e 6420 7365 6c66 2e69 6e64 6578 2e69  and self.index.i
-00022780: 7363 6f6e 7374 616e 743a 0a20 2020 2020  sconstant:.     
-00022790: 2020 2020 2020 2072 6574 7572 6e20 436f         return Co
-000227a0: 6e73 7461 6e74 2873 656c 662e 6576 616c  nstant(self.eval
-000227b0: 2829 290a 0a20 2020 2064 6566 205f 696e  ())..    def _in
-000227c0: 7462 6f75 6e64 735f 696d 706c 2873 656c  tbounds_impl(sel
-000227d0: 6629 3a0a 2020 2020 2020 2020 6c6f 7765  f):.        lowe
-000227e0: 725f 6c65 6e67 7468 2c20 7570 7065 725f  r_length, upper_
-000227f0: 6c65 6e67 7468 203d 2073 656c 662e 6c65  length = self.le
-00022800: 6e67 7468 2e5f 696e 7462 6f75 6e64 730a  ngth._intbounds.
-00022810: 2020 2020 2020 2020 6c6f 7765 725f 696e          lower_in
-00022820: 6465 782c 2075 7070 6572 5f69 6e64 6578  dex, upper_index
-00022830: 203d 2073 656c 662e 696e 6465 782e 5f69   = self.index._i
-00022840: 6e74 626f 756e 6473 0a20 2020 2020 2020  ntbounds.       
-00022850: 2069 6620 6c6f 7765 725f 696e 6465 7820   if lower_index 
-00022860: 3e3d 2030 3a0a 2020 2020 2020 2020 2020  >= 0:.          
-00022870: 2020 7265 7475 726e 206d 696e 286c 6f77    return min(low
-00022880: 6572 5f69 6e64 6578 2c20 7570 7065 725f  er_index, upper_
-00022890: 6c65 6e67 7468 202d 2031 292c 206d 696e  length - 1), min
-000228a0: 2875 7070 6572 5f69 6e64 6578 2c20 7570  (upper_index, up
-000228b0: 7065 725f 6c65 6e67 7468 202d 2031 290a  per_length - 1).
-000228c0: 2020 2020 2020 2020 656c 6966 2075 7070          elif upp
-000228d0: 6572 5f69 6e64 6578 203c 2030 2061 6e64  er_index < 0 and
-000228e0: 2069 7369 6e73 7461 6e63 6528 6c6f 7765   isinstance(lowe
-000228f0: 725f 6c65 6e67 7468 2c20 696e 7429 2061  r_length, int) a
-00022900: 6e64 206c 6f77 6572 5f6c 656e 6774 6820  nd lower_length 
-00022910: 3d3d 2075 7070 6572 5f6c 656e 6774 683a  == upper_length:
-00022920: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00022930: 7572 6e20 6d61 7828 6c6f 7765 725f 696e  urn max(lower_in
-00022940: 6465 7820 2b20 6c6f 7765 725f 6c65 6e67  dex + lower_leng
-00022950: 7468 2c20 3029 2c20 6d61 7828 7570 7065  th, 0), max(uppe
-00022960: 725f 696e 6465 7820 2b20 6c6f 7765 725f  r_index + lower_
-00022970: 6c65 6e67 7468 2c20 3029 0a20 2020 2020  length, 0).     
-00022980: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00022990: 2020 2020 2072 6574 7572 6e20 302c 2075       return 0, u
-000229a0: 7070 6572 5f6c 656e 6774 6820 2d20 310a  pper_length - 1.
-000229b0: 0a0a 636c 6173 7320 5f4c 6f6f 7049 6e64  ..class _LoopInd
-000229c0: 6578 2841 7267 756d 656e 7429 3a0a 0a20  ex(Argument):.. 
-000229d0: 2020 205f 5f73 6c6f 7473 5f5f 203d 2027     __slots__ = '
-000229e0: 6c65 6e67 7468 270a 0a20 2020 2040 7479  length'..    @ty
-000229f0: 7065 732e 6170 706c 795f 616e 6e6f 7461  pes.apply_annota
-00022a00: 7469 6f6e 730a 2020 2020 6465 6620 5f5f  tions.    def __
-00022a10: 696e 6974 5f5f 2873 656c 662c 206e 616d  init__(self, nam
-00022a20: 653a 2074 7970 6573 2e73 7472 6963 7473  e: types.stricts
-00022a30: 7472 2c20 6c65 6e67 7468 3a20 6173 696e  tr, length: asin
-00022a40: 6465 7829 3a0a 2020 2020 2020 2020 7365  dex):.        se
-00022a50: 6c66 2e6c 656e 6774 6820 3d20 6c65 6e67  lf.length = leng
-00022a60: 7468 0a20 2020 2020 2020 2073 7570 6572  th.        super
-00022a70: 2829 2e5f 5f69 6e69 745f 5f28 6e61 6d65  ().__init__(name
-00022a80: 2c20 2829 2c20 696e 7429 0a0a 2020 2020  , (), int)..    
-00022a90: 6465 6620 5f5f 7374 725f 5f28 7365 6c66  def __str__(self
-00022aa0: 293a 0a20 2020 2020 2020 2074 7279 3a0a  ):.        try:.
-00022ab0: 2020 2020 2020 2020 2020 2020 6c65 6e67              leng
-00022ac0: 7468 203d 2073 656c 662e 6c65 6e67 7468  th = self.length
-00022ad0: 2e5f 5f69 6e64 6578 5f5f 2829 0a20 2020  .__index__().   
-00022ae0: 2020 2020 2065 7863 6570 7420 4576 616c       except Eval
-00022af0: 7561 7469 6f6e 4572 726f 723a 0a20 2020  uationError:.   
-00022b00: 2020 2020 2020 2020 206c 656e 6774 6820           length 
-00022b10: 3d20 273f 270a 2020 2020 2020 2020 7265  = '?'.        re
-00022b20: 7475 726e 2027 4c6f 6f70 496e 6465 7828  turn 'LoopIndex(
-00022b30: 7b7d 2c20 6c65 6e67 7468 3d7b 7d29 272e  {}, length={})'.
-00022b40: 666f 726d 6174 2873 656c 662e 5f6e 616d  format(self._nam
-00022b50: 652c 206c 656e 6774 6829 0a0a 2020 2020  e, length)..    
-00022b60: 6465 6620 5f6e 6f64 6528 7365 6c66 2c20  def _node(self, 
-00022b70: 6361 6368 652c 2073 7562 6772 6170 682c  cache, subgraph,
-00022b80: 2074 696d 6573 293a 0a20 2020 2020 2020   times):.       
-00022b90: 2069 6620 7365 6c66 2069 6e20 6361 6368   if self in cach
-00022ba0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-00022bb0: 6574 7572 6e20 6361 6368 655b 7365 6c66  eturn cache[self
-00022bc0: 5d0a 2020 2020 2020 2020 6361 6368 655b  ].        cache[
-00022bd0: 7365 6c66 5d20 3d20 6e6f 6465 203d 2052  self] = node = R
-00022be0: 6567 756c 6172 4e6f 6465 2827 4c6f 6f70  egularNode('Loop
-00022bf0: 496e 6465 7827 2c20 2829 2c20 6469 6374  Index', (), dict
-00022c00: 286c 656e 6774 683d 7365 6c66 2e6c 656e  (length=self.len
-00022c10: 6774 682e 5f6e 6f64 6528 6361 6368 652c  gth._node(cache,
-00022c20: 2073 7562 6772 6170 682c 2074 696d 6573   subgraph, times
-00022c30: 2929 2c20 2874 7970 6528 7365 6c66 292e  )), (type(self).
-00022c40: 5f5f 6e61 6d65 5f5f 2c20 5f53 7461 7473  __name__, _Stats
-00022c50: 2829 292c 2073 7562 6772 6170 6829 0a20  ()), subgraph). 
-00022c60: 2020 2020 2020 2072 6574 7572 6e20 6e6f         return no
-00022c70: 6465 0a0a 2020 2020 6465 6620 5f69 6e74  de..    def _int
-00022c80: 626f 756e 6473 5f69 6d70 6c28 7365 6c66  bounds_impl(self
-00022c90: 293a 0a20 2020 2020 2020 206c 6f77 6572  ):.        lower
-00022ca0: 5f6c 656e 6774 682c 2075 7070 6572 5f6c  _length, upper_l
-00022cb0: 656e 6774 6820 3d20 7365 6c66 2e6c 656e  ength = self.len
-00022cc0: 6774 682e 5f69 6e74 626f 756e 6473 0a20  gth._intbounds. 
-00022cd0: 2020 2020 2020 2072 6574 7572 6e20 302c         return 0,
-00022ce0: 206d 6178 2830 2c20 7570 7065 725f 6c65   max(0, upper_le
-00022cf0: 6e67 7468 202d 2031 290a 0a20 2020 2064  ngth - 1)..    d
-00022d00: 6566 205f 7369 6d70 6c69 6669 6564 2873  ef _simplified(s
-00022d10: 656c 6629 3a0a 2020 2020 2020 2020 6966  elf):.        if
-00022d20: 2065 7175 616c 696e 6465 7828 7365 6c66   equalindex(self
-00022d30: 2e6c 656e 6774 682c 2031 293a 0a20 2020  .length, 1):.   
-00022d40: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00022d50: 5a65 726f 7328 2829 2c20 696e 7429 0a0a  Zeros((), int)..
-00022d60: 0a63 6c61 7373 204c 6f6f 7053 756d 2841  .class LoopSum(A
-00022d70: 7272 6179 293a 0a0a 2020 2020 5f5f 6361  rray):..    __ca
-00022d80: 6368 655f 5f20 3d20 275f 7365 7269 616c  che__ = '_serial
-00022d90: 697a 6564 270a 0a20 2020 2064 6566 2070  ized'..    def p
-00022da0: 7265 7061 7265 5f66 756e 6364 6174 6128  repare_funcdata(
-00022db0: 6172 6729 3a0a 2020 2020 2020 2020 2320  arg):.        # 
-00022dc0: 7365 7061 7261 7465 2073 6861 7065 2066  separate shape f
-00022dd0: 726f 6d20 6172 7261 7920 746f 206d 616b  rom array to mak
-00022de0: 6520 6974 2073 696d 706c 6966 6961 626c  e it simplifiabl
-00022df0: 6520 2861 6e6e 6f74 6174 696f 6e73 2061  e (annotations a
-00022e00: 7265 0a20 2020 2020 2020 2023 2074 7265  re.        # tre
-00022e10: 6174 6564 2061 7320 7072 6570 726f 6365  ated as preproce
-00022e20: 7373 6f72 2c20 7768 6963 6820 6d65 616e  ssor, which mean
-00022e30: 7320 7468 6520 7072 6f63 6573 7365 6420  s the processed 
-00022e40: 7661 6c75 6520 6973 2072 6574 7572 6e65  value is returne
-00022e50: 6420 6279 0a20 2020 2020 2020 2023 2073  d by.        # s
-00022e60: 656c 662e 5f5f 7265 6475 6365 5f5f 290a  elf.__reduce__).
-00022e70: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
-00022e80: 7461 6e63 6528 6172 672c 2074 7570 6c65  tance(arg, tuple
-00022e90: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-00022ea0: 6574 7572 6e20 6172 670a 2020 2020 2020  eturn arg.      
-00022eb0: 2020 6172 6720 3d20 6173 6172 7261 7928    arg = asarray(
-00022ec0: 6172 6729 0a20 2020 2020 2020 2072 6574  arg).        ret
-00022ed0: 7572 6e20 2861 7267 2c20 2a61 7267 2e73  urn (arg, *arg.s
-00022ee0: 6861 7065 290a 0a20 2020 2040 7479 7065  hape)..    @type
-00022ef0: 732e 6170 706c 795f 616e 6e6f 7461 7469  s.apply_annotati
-00022f00: 6f6e 730a 2020 2020 6465 6620 5f5f 696e  ons.    def __in
-00022f10: 6974 5f5f 2873 656c 662c 2066 756e 6364  it__(self, funcd
-00022f20: 6174 613a 2070 7265 7061 7265 5f66 756e  ata: prepare_fun
-00022f30: 6364 6174 612c 2069 6e64 6578 5f6e 616d  cdata, index_nam
-00022f40: 653a 2074 7970 6573 2e73 7472 6963 7473  e: types.stricts
-00022f50: 7472 2c20 6c65 6e67 7468 3a20 6173 696e  tr, length: asin
-00022f60: 6465 7829 3a0a 2020 2020 2020 2020 7368  dex):.        sh
-00022f70: 6170 6520 3d20 5475 706c 6528 6675 6e63  ape = Tuple(func
-00022f80: 6461 7461 5b31 3a5d 290a 2020 2020 2020  data[1:]).      
-00022f90: 2020 7365 6c66 2e69 6e64 6578 203d 206c    self.index = l
-00022fa0: 6f6f 705f 696e 6465 7828 696e 6465 785f  oop_index(index_
-00022fb0: 6e61 6d65 2c20 6c65 6e67 7468 290a 2020  name, length).  
-00022fc0: 2020 2020 2020 6966 2073 656c 662e 696e        if self.in
-00022fd0: 6465 7820 696e 2073 6861 7065 2e61 7267  dex in shape.arg
-00022fe0: 756d 656e 7473 3a0a 2020 2020 2020 2020  uments:.        
-00022ff0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-00023000: 7272 6f72 2827 7468 6520 7368 6170 6520  rror('the shape 
-00023010: 6f66 2074 6865 2066 756e 6374 696f 6e20  of the function 
-00023020: 6d75 7374 206e 6f74 2064 6570 656e 6420  must not depend 
-00023030: 6f6e 2074 6865 2069 6e64 6578 2729 0a20  on the index'). 
-00023040: 2020 2020 2020 2073 656c 662e 6675 6e63         self.func
-00023050: 203d 2066 756e 6364 6174 615b 305d 0a20   = funcdata[0]. 
-00023060: 2020 2020 2020 2061 7373 6572 7420 7365         assert se
-00023070: 6c66 2e66 756e 632e 6474 7970 6520 213d  lf.func.dtype !=
-00023080: 2062 6f6f 6c0a 2020 2020 2020 2020 7365   bool.        se
-00023090: 6c66 2e5f 696e 7661 7269 616e 7473 2c20  lf._invariants, 
-000230a0: 7365 6c66 2e5f 6465 7065 6e64 656e 6369  self._dependenci
-000230b0: 6573 203d 205f 6465 7065 6e64 656e 6369  es = _dependenci
-000230c0: 6573 5f73 616e 735f 696e 7661 7269 616e  es_sans_invarian
-000230d0: 7473 2873 656c 662e 6675 6e63 2c20 7365  ts(self.func, se
-000230e0: 6c66 2e69 6e64 6578 290a 2020 2020 2020  lf.index).      
-000230f0: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
-00023100: 5f5f 2861 7267 733d 2873 6861 7065 2c20  __(args=(shape, 
-00023110: 6c65 6e67 7468 2c20 2a73 656c 662e 5f69  length, *self._i
-00023120: 6e76 6172 6961 6e74 7329 2c20 7368 6170  nvariants), shap
-00023130: 653d 7365 6c66 2e66 756e 632e 7368 6170  e=self.func.shap
-00023140: 652c 2064 7479 7065 3d73 656c 662e 6675  e, dtype=self.fu
-00023150: 6e63 2e64 7479 7065 290a 0a20 2020 2040  nc.dtype)..    @
-00023160: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-00023170: 205f 7365 7269 616c 697a 6564 2873 656c   _serialized(sel
-00023180: 6629 3a0a 2020 2020 2020 2020 696e 6469  f):.        indi
-00023190: 6365 7320 3d20 7b64 3a20 6920 666f 7220  ces = {d: i for 
-000231a0: 692c 2064 2069 6e20 656e 756d 6572 6174  i, d in enumerat
-000231b0: 6528 6974 6572 746f 6f6c 732e 6368 6169  e(itertools.chai
-000231c0: 6e28 5b73 656c 662e 696e 6465 785d 2c20  n([self.index], 
-000231d0: 7365 6c66 2e5f 696e 7661 7269 616e 7473  self._invariants
-000231e0: 2c20 7365 6c66 2e5f 6465 7065 6e64 656e  , self._dependen
-000231f0: 6369 6573 2929 7d0a 2020 2020 2020 2020  cies))}.        
-00023200: 7265 7475 726e 2074 7570 6c65 2828 6465  return tuple((de
-00023210: 702c 2074 7570 6c65 286d 6170 2869 6e64  p, tuple(map(ind
-00023220: 6963 6573 2e5f 5f67 6574 6974 656d 5f5f  ices.__getitem__
-00023230: 2c20 6465 702e 5f45 7661 6c75 6162 6c65  , dep._Evaluable
-00023240: 5f5f 6172 6773 2929 2920 666f 7220 6465  __args))) for de
-00023250: 7020 696e 2073 656c 662e 5f64 6570 656e  p in self._depen
-00023260: 6465 6e63 6965 7329 0a0a 2020 2020 6465  dencies)..    de
-00023270: 6620 6576 616c 6628 7365 6c66 2c20 7368  f evalf(self, sh
-00023280: 6170 652c 206c 656e 6774 682c 202a 6172  ape, length, *ar
-00023290: 6773 293a 0a20 2020 2020 2020 2073 6572  gs):.        ser
-000232a0: 6961 6c69 7a65 6420 3d20 7365 6c66 2e5f  ialized = self._
-000232b0: 7365 7269 616c 697a 6564 0a20 2020 2020  serialized.     
-000232c0: 2020 2072 6573 756c 7420 3d20 6e75 6d70     result = nump
-000232d0: 792e 7a65 726f 7328 7368 6170 652c 2073  y.zeros(shape, s
-000232e0: 656c 662e 6474 7970 6529 0a20 2020 2020  elf.dtype).     
-000232f0: 2020 2066 6f72 2069 6e64 6578 2069 6e20     for index in 
-00023300: 7261 6e67 6528 6c65 6e67 7468 293a 0a20  range(length):. 
-00023310: 2020 2020 2020 2020 2020 2076 616c 7565             value
-00023320: 7320 3d20 5b6e 756d 7079 2e61 7272 6179  s = [numpy.array
-00023330: 2869 6e64 6578 295d 0a20 2020 2020 2020  (index)].       
-00023340: 2020 2020 2076 616c 7565 732e 6578 7465       values.exte
-00023350: 6e64 2861 7267 7329 0a20 2020 2020 2020  nd(args).       
-00023360: 2020 2020 2076 616c 7565 732e 6578 7465       values.exte
-00023370: 6e64 286f 702e 6576 616c 6628 2a5b 7661  nd(op.evalf(*[va
-00023380: 6c75 6573 5b69 5d20 666f 7220 6920 696e  lues[i] for i in
-00023390: 2069 6e64 6963 6573 5d29 2066 6f72 206f   indices]) for o
-000233a0: 702c 2069 6e64 6963 6573 2069 6e20 7365  p, indices in se
-000233b0: 7269 616c 697a 6564 290a 2020 2020 2020  rialized).      
-000233c0: 2020 2020 2020 7265 7375 6c74 202b 3d20        result += 
-000233d0: 7661 6c75 6573 5b2d 315d 0a20 2020 2020  values[-1].     
-000233e0: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
-000233f0: 0a0a 2020 2020 6465 6620 6576 616c 665f  ..    def evalf_
-00023400: 7769 7468 7469 6d65 7328 7365 6c66 2c20  withtimes(self, 
-00023410: 7469 6d65 732c 2073 6861 7065 2c20 6c65  times, shape, le
-00023420: 6e67 7468 2c20 2a61 7267 7329 3a0a 2020  ngth, *args):.  
-00023430: 2020 2020 2020 7365 7269 616c 697a 6564        serialized
-00023440: 203d 2073 656c 662e 5f73 6572 6961 6c69   = self._seriali
-00023450: 7a65 640a 2020 2020 2020 2020 7375 6274  zed.        subt
-00023460: 696d 6573 203d 2074 696d 6573 2e73 6574  imes = times.set
-00023470: 6465 6661 756c 7428 7365 6c66 2c20 636f  default(self, co
-00023480: 6c6c 6563 7469 6f6e 732e 6465 6661 756c  llections.defaul
-00023490: 7464 6963 7428 5f53 7461 7473 2929 0a20  tdict(_Stats)). 
-000234a0: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
-000234b0: 6e75 6d70 792e 7a65 726f 7328 7368 6170  numpy.zeros(shap
-000234c0: 652c 2073 656c 662e 6474 7970 6529 0a20  e, self.dtype). 
-000234d0: 2020 2020 2020 2066 6f72 2069 6e64 6578         for index
-000234e0: 2069 6e20 7261 6e67 6528 6c65 6e67 7468   in range(length
-000234f0: 293a 0a20 2020 2020 2020 2020 2020 2076  ):.            v
-00023500: 616c 7565 7320 3d20 5b6e 756d 7079 2e61  alues = [numpy.a
-00023510: 7272 6179 2869 6e64 6578 295d 0a20 2020  rray(index)].   
-00023520: 2020 2020 2020 2020 2076 616c 7565 732e           values.
-00023530: 6578 7465 6e64 2861 7267 7329 0a20 2020  extend(args).   
-00023540: 2020 2020 2020 2020 2076 616c 7565 732e           values.
-00023550: 6578 7465 6e64 286f 702e 6576 616c 665f  extend(op.evalf_
-00023560: 7769 7468 7469 6d65 7328 7375 6274 696d  withtimes(subtim
-00023570: 6573 2c20 2a5b 7661 6c75 6573 5b69 5d20  es, *[values[i] 
-00023580: 666f 7220 6920 696e 2069 6e64 6963 6573  for i in indices
-00023590: 5d29 2066 6f72 206f 702c 2069 6e64 6963  ]) for op, indic
-000235a0: 6573 2069 6e20 7365 7269 616c 697a 6564  es in serialized
-000235b0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
-000235c0: 7375 6c74 202b 3d20 7661 6c75 6573 5b2d  sult += values[-
-000235d0: 315d 0a20 2020 2020 2020 2072 6574 7572  1].        retur
-000235e0: 6e20 7265 7375 6c74 0a0a 2020 2020 6465  n result..    de
-000235f0: 6620 5f64 6572 6976 6174 6976 6528 7365  f _derivative(se
-00023600: 6c66 2c20 7661 722c 2073 6565 6e29 3a0a  lf, var, seen):.
-00023610: 2020 2020 2020 2020 7265 7475 726e 206c          return l
-00023620: 6f6f 705f 7375 6d28 6465 7269 7661 7469  oop_sum(derivati
-00023630: 7665 2873 656c 662e 6675 6e63 2c20 7661  ve(self.func, va
-00023640: 722c 2073 6565 6e29 2c20 7365 6c66 2e69  r, seen), self.i
-00023650: 6e64 6578 290a 0a20 2020 2064 6566 205f  ndex)..    def _
-00023660: 6e6f 6465 2873 656c 662c 2063 6163 6865  node(self, cache
-00023670: 2c20 7375 6267 7261 7068 2c20 7469 6d65  , subgraph, time
-00023680: 7329 3a0a 2020 2020 2020 2020 6966 2073  s):.        if s
-00023690: 656c 6620 696e 2063 6163 6865 3a0a 2020  elf in cache:.  
-000236a0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-000236b0: 2063 6163 6865 5b73 656c 665d 0a20 2020   cache[self].   
-000236c0: 2020 2020 2073 7562 6361 6368 6520 3d20       subcache = 
-000236d0: 7b7d 0a20 2020 2020 2020 2066 6f72 2061  {}.        for a
-000236e0: 7267 2069 6e20 7365 6c66 2e5f 4576 616c  rg in self._Eval
-000236f0: 7561 626c 655f 5f61 7267 733a 0a20 2020  uable__args:.   
-00023700: 2020 2020 2020 2020 2073 7562 6361 6368           subcach
-00023710: 655b 6172 675d 203d 2061 7267 2e5f 6e6f  e[arg] = arg._no
-00023720: 6465 2863 6163 6865 2c20 7375 6267 7261  de(cache, subgra
-00023730: 7068 2c20 7469 6d65 7329 0a20 2020 2020  ph, times).     
-00023740: 2020 206c 6f6f 7067 7261 7068 203d 2053     loopgraph = S
-00023750: 7562 6772 6170 6828 274c 6f6f 7027 2c20  ubgraph('Loop', 
-00023760: 7375 6267 7261 7068 290a 2020 2020 2020  subgraph).      
-00023770: 2020 7375 6274 696d 6573 203d 2074 696d    subtimes = tim
-00023780: 6573 2e67 6574 2873 656c 662c 2063 6f6c  es.get(self, col
-00023790: 6c65 6374 696f 6e73 2e64 6566 6175 6c74  lections.default
-000237a0: 6469 6374 285f 5374 6174 7329 290a 2020  dict(_Stats)).  
-000237b0: 2020 2020 2020 7375 6d5f 6b77 6172 6773        sum_kwargs
-000237c0: 203d 207b 2773 6861 7065 5b7b 7d5d 272e   = {'shape[{}]'.
-000237d0: 666f 726d 6174 2869 293a 206e 2e5f 6e6f  format(i): n._no
-000237e0: 6465 2863 6163 6865 2c20 7375 6267 7261  de(cache, subgra
-000237f0: 7068 2c20 7469 6d65 7329 2066 6f72 2069  ph, times) for i
-00023800: 2c20 6e20 696e 2065 6e75 6d65 7261 7465  , n in enumerate
-00023810: 2873 656c 662e 7368 6170 6529 7d0a 2020  (self.shape)}.  
-00023820: 2020 2020 2020 7375 6d5f 6b77 6172 6773        sum_kwargs
-00023830: 5b27 6675 6e63 275d 203d 2073 656c 662e  ['func'] = self.
-00023840: 6675 6e63 2e5f 6e6f 6465 2873 7562 6361  func._node(subca
-00023850: 6368 652c 206c 6f6f 7067 7261 7068 2c20  che, loopgraph, 
-00023860: 7375 6274 696d 6573 290a 2020 2020 2020  subtimes).      
-00023870: 2020 6361 6368 655b 7365 6c66 5d20 3d20    cache[self] = 
-00023880: 6e6f 6465 203d 2052 6567 756c 6172 4e6f  node = RegularNo
-00023890: 6465 2827 4c6f 6f70 5375 6d27 2c20 2829  de('LoopSum', ()
-000238a0: 2c20 7375 6d5f 6b77 6172 6773 2c20 2874  , sum_kwargs, (t
-000238b0: 7970 6528 7365 6c66 292e 5f5f 6e61 6d65  ype(self).__name
-000238c0: 5f5f 2c20 7375 6274 696d 6573 5b27 7375  __, subtimes['su
-000238d0: 6d27 5d29 2c20 6c6f 6f70 6772 6170 6829  m']), loopgraph)
-000238e0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000238f0: 6e6f 6465 0a0a 2020 2020 6465 6620 5f73  node..    def _s
-00023900: 696d 706c 6966 6965 6428 7365 6c66 293a  implified(self):
-00023910: 0a20 2020 2020 2020 2069 6620 6973 7a65  .        if isze
-00023920: 726f 2873 656c 662e 6675 6e63 293a 0a20  ro(self.func):. 
-00023930: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00023940: 6e20 7a65 726f 735f 6c69 6b65 2873 656c  n zeros_like(sel
-00023950: 6629 0a20 2020 2020 2020 2065 6c69 6620  f).        elif 
-00023960: 7365 6c66 2e69 6e64 6578 206e 6f74 2069  self.index not i
-00023970: 6e20 7365 6c66 2e66 756e 632e 6172 6775  n self.func.argu
-00023980: 6d65 6e74 733a 0a20 2020 2020 2020 2020  ments:.         
-00023990: 2020 2072 6574 7572 6e20 7365 6c66 2e66     return self.f
-000239a0: 756e 6320 2a20 7365 6c66 2e69 6e64 6578  unc * self.index
-000239b0: 2e6c 656e 6774 680a 2020 2020 2020 2020  .length.        
-000239c0: 7265 7475 726e 2073 656c 662e 6675 6e63  return self.func
-000239d0: 2e5f 6c6f 6f70 7375 6d28 7365 6c66 2e69  ._loopsum(self.i
-000239e0: 6e64 6578 290a 0a20 2020 2064 6566 205f  ndex)..    def _
-000239f0: 7461 6b65 6469 6167 2873 656c 662c 2061  takediag(self, a
-00023a00: 7869 7331 2c20 6178 6973 3229 3a0a 2020  xis1, axis2):.  
-00023a10: 2020 2020 2020 7265 7475 726e 206c 6f6f        return loo
-00023a20: 705f 7375 6d28 5f74 616b 6564 6961 6728  p_sum(_takediag(
-00023a30: 7365 6c66 2e66 756e 632c 2061 7869 7331  self.func, axis1
-00023a40: 2c20 6178 6973 3229 2c20 7365 6c66 2e69  , axis2), self.i
-00023a50: 6e64 6578 290a 0a20 2020 2064 6566 205f  ndex)..    def _
-00023a60: 7461 6b65 2873 656c 662c 2069 6e64 6578  take(self, index
-00023a70: 2c20 6178 6973 293a 0a20 2020 2020 2020  , axis):.       
-00023a80: 2072 6574 7572 6e20 6c6f 6f70 5f73 756d   return loop_sum
-00023a90: 285f 7461 6b65 2873 656c 662e 6675 6e63  (_take(self.func
-00023aa0: 2c20 696e 6465 782c 2061 7869 7329 2c20  , index, axis), 
-00023ab0: 7365 6c66 2e69 6e64 6578 290a 0a20 2020  self.index)..   
-00023ac0: 2064 6566 205f 756e 7261 7665 6c28 7365   def _unravel(se
-00023ad0: 6c66 2c20 6178 6973 2c20 7368 6170 6529  lf, axis, shape)
-00023ae0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00023af0: 206c 6f6f 705f 7375 6d28 756e 7261 7665   loop_sum(unrave
-00023b00: 6c28 7365 6c66 2e66 756e 632c 2061 7869  l(self.func, axi
-00023b10: 732c 2073 6861 7065 292c 2073 656c 662e  s, shape), self.
-00023b20: 696e 6465 7829 0a0a 2020 2020 6465 6620  index)..    def 
-00023b30: 5f73 756d 2873 656c 662c 2061 7869 7329  _sum(self, axis)
-00023b40: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00023b50: 206c 6f6f 705f 7375 6d28 7375 6d28 7365   loop_sum(sum(se
-00023b60: 6c66 2e66 756e 632c 2061 7869 7329 2c20  lf.func, axis), 
-00023b70: 7365 6c66 2e69 6e64 6578 290a 0a20 2020  self.index)..   
-00023b80: 2064 6566 205f 6164 6428 7365 6c66 2c20   def _add(self, 
-00023b90: 6f74 6865 7229 3a0a 2020 2020 2020 2020  other):.        
-00023ba0: 6966 2069 7369 6e73 7461 6e63 6528 6f74  if isinstance(ot
-00023bb0: 6865 722c 204c 6f6f 7053 756d 2920 616e  her, LoopSum) an
-00023bc0: 6420 6f74 6865 722e 696e 6465 7820 3d3d  d other.index ==
-00023bd0: 2073 656c 662e 696e 6465 783a 0a20 2020   self.index:.   
-00023be0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00023bf0: 6c6f 6f70 5f73 756d 2873 656c 662e 6675  loop_sum(self.fu
-00023c00: 6e63 202b 206f 7468 6572 2e66 756e 632c  nc + other.func,
-00023c10: 2073 656c 662e 696e 6465 7829 0a0a 2020   self.index)..  
-00023c20: 2020 6465 6620 5f6d 756c 7469 706c 7928    def _multiply(
-00023c30: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-00023c40: 2020 2020 2020 7265 7475 726e 206c 6f6f        return loo
-00023c50: 705f 7375 6d28 7365 6c66 2e66 756e 6320  p_sum(self.func 
-00023c60: 2a20 6f74 6865 722c 2073 656c 662e 696e  * other, self.in
-00023c70: 6465 7829 0a0a 2020 2020 4070 726f 7065  dex)..    @prope
-00023c80: 7274 790a 2020 2020 6465 6620 5f61 7373  rty.    def _ass
-00023c90: 7061 7273 6528 7365 6c66 293a 0a20 2020  parse(self):.   
-00023ca0: 2020 2020 2063 6875 6e6b 7320 3d20 5b5d       chunks = []
-00023cb0: 0a20 2020 2020 2020 2066 6f72 202a 656c  .        for *el
-00023cc0: 656d 5f69 6e64 6963 6573 2c20 656c 656d  em_indices, elem
-00023cd0: 5f76 616c 7565 7320 696e 2073 656c 662e  _values in self.
-00023ce0: 6675 6e63 2e5f 6173 7370 6172 7365 3a0a  func._assparse:.
-00023cf0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-00023d00: 656c 662e 6e64 696d 203d 3d20 303a 0a20  elf.ndim == 0:. 
-00023d10: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-00023d20: 616c 7565 7320 3d20 6c6f 6f70 5f63 6f6e  alues = loop_con
-00023d30: 6361 7465 6e61 7465 2849 6e73 6572 7441  catenate(InsertA
-00023d40: 7869 7328 656c 656d 5f76 616c 7565 732c  xis(elem_values,
-00023d50: 2031 292c 2073 656c 662e 696e 6465 7829   1), self.index)
-00023d60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00023d70: 2077 6869 6c65 2076 616c 7565 732e 6e64   while values.nd
-00023d80: 696d 3a0a 2020 2020 2020 2020 2020 2020  im:.            
-00023d90: 2020 2020 2020 2020 7661 6c75 6573 203d          values =
-00023da0: 2053 756d 2876 616c 7565 7329 0a20 2020   Sum(values).   
-00023db0: 2020 2020 2020 2020 2020 2020 2063 6875               chu
-00023dc0: 6e6b 732e 6170 7065 6e64 2828 7661 6c75  nks.append((valu
-00023dd0: 6573 2c29 290a 2020 2020 2020 2020 2020  es,)).          
-00023de0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00023df0: 2020 2020 2020 2020 6966 2065 6c65 6d5f          if elem_
-00023e00: 7661 6c75 6573 2e6e 6469 6d20 3d3d 2030  values.ndim == 0
-00023e10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00023e20: 2020 2020 2020 2a65 6c65 6d5f 696e 6469        *elem_indi
-00023e30: 6365 732c 2065 6c65 6d5f 7661 6c75 6573  ces, elem_values
-00023e40: 203d 2028 496e 7365 7274 4178 6973 2861   = (InsertAxis(a
-00023e50: 7272 2c20 3129 2066 6f72 2061 7272 2069  rr, 1) for arr i
-00023e60: 6e20 282a 656c 656d 5f69 6e64 6963 6573  n (*elem_indices
-00023e70: 2c20 656c 656d 5f76 616c 7565 7329 290a  , elem_values)).
-00023e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023e90: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00023ea0: 2020 2020 2020 2020 2020 2320 6d69 6e69            # mini
-00023eb0: 6d69 7a65 2072 6176 656c 7320 6279 2074  mize ravels by t
-00023ec0: 7261 6e73 706f 7369 6e67 2061 6c6c 2076  ransposing all v
-00023ed0: 6172 6961 626c 6520 6c65 6e67 7468 2061  ariable length a
-00023ee0: 7865 7320 746f 2074 6865 2065 6e64 0a20  xes to the end. 
-00023ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023f00: 2020 2076 6172 6961 626c 6520 3d20 7475     variable = tu
-00023f10: 706c 6528 6920 666f 7220 692c 206e 2069  ple(i for i, n i
-00023f20: 6e20 656e 756d 6572 6174 6528 656c 656d  n enumerate(elem
-00023f30: 5f76 616c 7565 732e 7368 6170 6529 2069  _values.shape) i
-00023f40: 6620 7365 6c66 2e69 6e64 6578 2069 6e20  f self.index in 
-00023f50: 6e2e 6172 6775 6d65 6e74 7329 0a20 2020  n.arguments).   
-00023f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023f70: 202a 656c 656d 5f69 6e64 6963 6573 2c20   *elem_indices, 
-00023f80: 656c 656d 5f76 616c 7565 7320 3d20 2854  elem_values = (T
-00023f90: 7261 6e73 706f 7365 2e74 6f5f 656e 6428  ranspose.to_end(
-00023fa0: 6172 722c 202a 7661 7269 6162 6c65 2920  arr, *variable) 
-00023fb0: 666f 7220 6172 7220 696e 2028 2a65 6c65  for arr in (*ele
-00023fc0: 6d5f 696e 6469 6365 732c 2065 6c65 6d5f  m_indices, elem_
-00023fd0: 7661 6c75 6573 2929 0a20 2020 2020 2020  values)).       
-00023fe0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00023ff0: 2069 2069 6e20 7661 7269 6162 6c65 5b3a   i in variable[:
-00024000: 2d31 5d3a 0a20 2020 2020 2020 2020 2020  -1]:.           
-00024010: 2020 2020 2020 2020 2020 2020 202a 656c               *el
-00024020: 656d 5f69 6e64 6963 6573 2c20 656c 656d  em_indices, elem
-00024030: 5f76 616c 7565 7320 3d20 6d61 7028 5261  _values = map(Ra
-00024040: 7665 6c2c 2028 2a65 6c65 6d5f 696e 6469  vel, (*elem_indi
-00024050: 6365 732c 2065 6c65 6d5f 7661 6c75 6573  ces, elem_values
-00024060: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
-00024070: 2020 2020 2020 2061 7373 6572 7420 616c         assert al
-00024080: 6c28 7365 6c66 2e69 6e64 6578 206e 6f74  l(self.index not
-00024090: 2069 6e20 6e2e 6172 6775 6d65 6e74 7320   in n.arguments 
-000240a0: 666f 7220 6e20 696e 2065 6c65 6d5f 7661  for n in elem_va
-000240b0: 6c75 6573 2e73 6861 7065 5b3a 2d31 5d29  lues.shape[:-1])
-000240c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000240d0: 2063 6875 6e6b 732e 6170 7065 6e64 2874   chunks.append(t
-000240e0: 7570 6c65 286c 6f6f 705f 636f 6e63 6174  uple(loop_concat
-000240f0: 656e 6174 6528 6172 722c 2073 656c 662e  enate(arr, self.
-00024100: 696e 6465 7829 2066 6f72 2061 7272 2069  index) for arr i
-00024110: 6e20 282a 656c 656d 5f69 6e64 6963 6573  n (*elem_indices
-00024120: 2c20 656c 656d 5f76 616c 7565 7329 2929  , elem_values)))
-00024130: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00024140: 7475 706c 6528 6368 756e 6b73 290a 0a0a  tuple(chunks)...
-00024150: 636c 6173 7320 5f53 697a 6573 546f 4f66  class _SizesToOf
-00024160: 6673 6574 7328 4172 7261 7929 3a0a 0a20  fsets(Array):.. 
-00024170: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
-00024180: 7365 6c66 2c20 7369 7a65 7329 3a0a 2020  self, sizes):.  
-00024190: 2020 2020 2020 6173 7365 7274 2073 697a        assert siz
-000241a0: 6573 2e6e 6469 6d20 3d3d 2031 0a20 2020  es.ndim == 1.   
-000241b0: 2020 2020 2061 7373 6572 7420 7369 7a65       assert size
-000241c0: 732e 6474 7970 6520 3d3d 2069 6e74 0a20  s.dtype == int. 
-000241d0: 2020 2020 2020 2061 7373 6572 7420 7369         assert si
-000241e0: 7a65 732e 5f69 6e74 626f 756e 6473 5b30  zes._intbounds[0
-000241f0: 5d20 3e3d 2030 0a20 2020 2020 2020 2073  ] >= 0.        s
-00024200: 656c 662e 5f73 697a 6573 203d 2073 697a  elf._sizes = siz
-00024210: 6573 0a20 2020 2020 2020 2073 7570 6572  es.        super
-00024220: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
-00024230: 3d5b 7369 7a65 735d 2c20 7368 6170 653d  =[sizes], shape=
-00024240: 2873 697a 6573 2e73 6861 7065 5b30 5d2b  (sizes.shape[0]+
-00024250: 312c 292c 2064 7479 7065 3d69 6e74 290a  1,), dtype=int).
-00024260: 0a20 2020 2064 6566 2065 7661 6c66 2873  .    def evalf(s
-00024270: 656c 662c 2073 697a 6573 293a 0a20 2020  elf, sizes):.   
-00024280: 2020 2020 2072 6574 7572 6e20 6e75 6d70       return nump
-00024290: 792e 6375 6d73 756d 285b 302c 202a 7369  y.cumsum([0, *si
-000242a0: 7a65 735d 290a 0a20 2020 2064 6566 205f  zes])..    def _
-000242b0: 7369 6d70 6c69 6669 6564 2873 656c 6629  simplified(self)
-000242c0: 3a0a 2020 2020 2020 2020 756e 616c 6967  :.        unalig
-000242d0: 6e65 642c 2077 6865 7265 203d 2075 6e61  ned, where = una
-000242e0: 6c69 676e 2873 656c 662e 5f73 697a 6573  lign(self._sizes
-000242f0: 290a 2020 2020 2020 2020 6966 206e 6f74  ).        if not
-00024300: 2077 6865 7265 3a0a 2020 2020 2020 2020   where:.        
-00024310: 2020 2020 7265 7475 726e 2052 616e 6765      return Range
-00024320: 2873 656c 662e 7368 6170 655b 305d 2920  (self.shape[0]) 
-00024330: 2a20 6170 7065 6e64 6178 6573 2875 6e61  * appendaxes(una
-00024340: 6c69 676e 6564 2c20 7365 6c66 2e73 6861  ligned, self.sha
-00024350: 7065 5b3a 315d 290a 0a20 2020 2064 6566  pe[:1])..    def
-00024360: 205f 696e 7462 6f75 6e64 735f 696d 706c   _intbounds_impl
-00024370: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00024380: 6e20 3d20 7365 6c66 2e5f 7369 7a65 732e  n = self._sizes.
-00024390: 7369 7a65 2e5f 696e 7462 6f75 6e64 735b  size._intbounds[
-000243a0: 315d 0a20 2020 2020 2020 206d 203d 2073  1].        m = s
-000243b0: 656c 662e 5f73 697a 6573 2e5f 696e 7462  elf._sizes._intb
-000243c0: 6f75 6e64 735b 315d 0a20 2020 2020 2020  ounds[1].       
-000243d0: 2072 6574 7572 6e20 302c 2028 3020 6966   return 0, (0 if
-000243e0: 206e 203d 3d20 3020 6f72 206d 203d 3d20   n == 0 or m == 
-000243f0: 3020 656c 7365 206e 202a 206d 290a 0a0a  0 else n * m)...
-00024400: 636c 6173 7320 4c6f 6f70 436f 6e63 6174  class LoopConcat
-00024410: 656e 6174 6528 4172 7261 7929 3a0a 0a20  enate(Array):.. 
-00024420: 2020 2040 7479 7065 732e 6170 706c 795f     @types.apply_
-00024430: 616e 6e6f 7461 7469 6f6e 730a 2020 2020  annotations.    
-00024440: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00024450: 662c 2066 756e 6364 6174 613a 2061 7361  f, funcdata: asa
-00024460: 7272 6179 732c 2069 6e64 6578 5f6e 616d  rrays, index_nam
-00024470: 653a 2074 7970 6573 2e73 7472 6963 7473  e: types.stricts
-00024480: 7472 2c20 6c65 6e67 7468 3a20 6173 696e  tr, length: asin
-00024490: 6465 7829 3a0a 2020 2020 2020 2020 7365  dex):.        se
-000244a0: 6c66 2e66 756e 6364 6174 6120 3d20 6675  lf.funcdata = fu
-000244b0: 6e63 6461 7461 0a20 2020 2020 2020 2073  ncdata.        s
-000244c0: 656c 662e 6675 6e63 2c20 7365 6c66 2e73  elf.func, self.s
-000244d0: 7461 7274 2c20 7374 6f70 2c20 2a73 6861  tart, stop, *sha
-000244e0: 7065 203d 2066 756e 6364 6174 610a 2020  pe = funcdata.  
-000244f0: 2020 2020 2020 7365 6c66 2e69 6e64 6578        self.index
-00024500: 203d 206c 6f6f 705f 696e 6465 7828 696e   = loop_index(in
-00024510: 6465 785f 6e61 6d65 2c20 6c65 6e67 7468  dex_name, length
-00024520: 290a 2020 2020 2020 2020 6966 206e 6f74  ).        if not
-00024530: 2073 656c 662e 6675 6e63 2e6e 6469 6d3a   self.func.ndim:
-00024540: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-00024550: 7365 2056 616c 7565 4572 726f 7228 2765  se ValueError('e
-00024560: 7870 6563 7465 6420 616e 2061 7272 6179  xpected an array
-00024570: 2077 6974 6820 6174 206c 6561 7374 206f   with at least o
-00024580: 6e65 2061 7869 7327 290a 2020 2020 2020  ne axis').      
-00024590: 2020 6966 2061 6e79 2873 656c 662e 696e    if any(self.in
-000245a0: 6465 7820 696e 206e 2e61 7267 756d 656e  dex in n.argumen
-000245b0: 7473 2066 6f72 206e 2069 6e20 7368 6170  ts for n in shap
-000245c0: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
-000245d0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-000245e0: 2827 7468 6520 7368 6170 6520 6f66 2074  ('the shape of t
-000245f0: 6865 2066 756e 6374 696f 6e20 6d75 7374  he function must
-00024600: 206e 6f74 2064 6570 656e 6420 6f6e 2074   not depend on t
-00024610: 6865 2069 6e64 6578 2729 0a20 2020 2020  he index').     
-00024620: 2020 2073 656c 662e 5f6c 6363 203d 204c     self._lcc = L
-00024630: 6f6f 7043 6f6e 6361 7465 6e61 7465 436f  oopConcatenateCo
-00024640: 6d62 696e 6564 2828 7365 6c66 2e66 756e  mbined((self.fun
-00024650: 6364 6174 612c 292c 2069 6e64 6578 5f6e  cdata,), index_n
-00024660: 616d 652c 206c 656e 6774 6829 0a20 2020  ame, length).   
-00024670: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
-00024680: 6e69 745f 5f28 6172 6773 3d5b 7365 6c66  nit__(args=[self
-00024690: 2e5f 6c63 635d 2c20 7368 6170 653d 7368  ._lcc], shape=sh
-000246a0: 6170 652c 2064 7479 7065 3d73 656c 662e  ape, dtype=self.
-000246b0: 6675 6e63 2e64 7479 7065 290a 0a20 2020  func.dtype)..   
-000246c0: 2064 6566 2065 7661 6c66 2873 656c 662c   def evalf(self,
-000246d0: 2061 7267 293a 0a20 2020 2020 2020 2072   arg):.        r
-000246e0: 6574 7572 6e20 6172 675b 305d 0a0a 2020  eturn arg[0]..  
-000246f0: 2020 6465 6620 6576 616c 665f 7769 7468    def evalf_with
-00024700: 7469 6d65 7328 7365 6c66 2c20 7469 6d65  times(self, time
-00024710: 732c 2061 7267 293a 0a20 2020 2020 2020  s, arg):.       
-00024720: 2077 6974 6820 7469 6d65 735b 7365 6c66   with times[self
-00024730: 5d3a 0a20 2020 2020 2020 2020 2020 2072  ]:.            r
-00024740: 6574 7572 6e20 6172 675b 305d 0a0a 2020  eturn arg[0]..  
-00024750: 2020 6465 6620 5f64 6572 6976 6174 6976    def _derivativ
-00024760: 6528 7365 6c66 2c20 7661 722c 2073 6565  e(self, var, see
-00024770: 6e29 3a0a 2020 2020 2020 2020 7265 7475  n):.        retu
-00024780: 726e 2054 7261 6e73 706f 7365 2e66 726f  rn Transpose.fro
-00024790: 6d5f 656e 6428 6c6f 6f70 5f63 6f6e 6361  m_end(loop_conca
-000247a0: 7465 6e61 7465 2854 7261 6e73 706f 7365  tenate(Transpose
-000247b0: 2e74 6f5f 656e 6428 6465 7269 7661 7469  .to_end(derivati
-000247c0: 7665 2873 656c 662e 6675 6e63 2c20 7661  ve(self.func, va
-000247d0: 722c 2073 6565 6e29 2c20 7365 6c66 2e6e  r, seen), self.n
-000247e0: 6469 6d2d 3129 2c20 7365 6c66 2e69 6e64  dim-1), self.ind
-000247f0: 6578 292c 2073 656c 662e 6e64 696d 2d31  ex), self.ndim-1
-00024800: 290a 0a20 2020 2064 6566 205f 6e6f 6465  )..    def _node
-00024810: 2873 656c 662c 2063 6163 6865 2c20 7375  (self, cache, su
-00024820: 6267 7261 7068 2c20 7469 6d65 7329 3a0a  bgraph, times):.
-00024830: 2020 2020 2020 2020 6966 2073 656c 6620          if self 
-00024840: 696e 2063 6163 6865 3a0a 2020 2020 2020  in cache:.      
-00024850: 2020 2020 2020 7265 7475 726e 2063 6163        return cac
-00024860: 6865 5b73 656c 665d 0a20 2020 2020 2020  he[self].       
-00024870: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00024880: 2020 2063 6163 6865 5b73 656c 665d 203d     cache[self] =
-00024890: 206e 6f64 6520 3d20 7365 6c66 2e5f 6c63   node = self._lc
-000248a0: 632e 5f6e 6f64 655f 7475 706c 6528 6361  c._node_tuple(ca
-000248b0: 6368 652c 2073 7562 6772 6170 682c 2074  che, subgraph, t
-000248c0: 696d 6573 295b 305d 0a20 2020 2020 2020  imes)[0].       
-000248d0: 2020 2020 2072 6574 7572 6e20 6e6f 6465       return node
-000248e0: 0a0a 2020 2020 6465 6620 5f73 696d 706c  ..    def _simpl
-000248f0: 6966 6965 6428 7365 6c66 293a 0a20 2020  ified(self):.   
-00024900: 2020 2020 2069 6620 6973 7a65 726f 2873       if iszero(s
-00024910: 656c 662e 6675 6e63 293a 0a20 2020 2020  elf.func):.     
-00024920: 2020 2020 2020 2072 6574 7572 6e20 7a65         return ze
-00024930: 726f 735f 6c69 6b65 2873 656c 6629 0a20  ros_like(self). 
-00024940: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-00024950: 2e69 6e64 6578 206e 6f74 2069 6e20 7365  .index not in se
-00024960: 6c66 2e66 756e 632e 6172 6775 6d65 6e74  lf.func.argument
-00024970: 733a 0a20 2020 2020 2020 2020 2020 2072  s:.            r
-00024980: 6574 7572 6e20 5261 7665 6c28 5472 616e  eturn Ravel(Tran
-00024990: 7370 6f73 652e 6672 6f6d 5f65 6e64 2849  spose.from_end(I
-000249a0: 6e73 6572 7441 7869 7328 7365 6c66 2e66  nsertAxis(self.f
-000249b0: 756e 632c 2073 656c 662e 696e 6465 782e  unc, self.index.
-000249c0: 6c65 6e67 7468 292c 202d 3229 290a 2020  length), -2)).  
-000249d0: 2020 2020 2020 756e 616c 6967 6e65 642c        unaligned,
-000249e0: 2077 6865 7265 203d 2075 6e61 6c69 676e   where = unalign
-000249f0: 2873 656c 662e 6675 6e63 290a 2020 2020  (self.func).    
-00024a00: 2020 2020 6966 2073 656c 662e 6e64 696d      if self.ndim
-00024a10: 2d31 206e 6f74 2069 6e20 7768 6572 653a  -1 not in where:
-00024a20: 0a20 2020 2020 2020 2020 2020 2023 2072  .            # r
-00024a30: 6569 6e73 6572 7420 636f 6e63 6174 656e  einsert concaten
-00024a40: 6174 696f 6e20 6178 6973 2c20 6174 2075  ation axis, at u
-00024a50: 6e69 7420 6c65 6e67 7468 2069 6620 706f  nit length if po
-00024a60: 7373 6962 6c65 2073 6f20 7765 2063 616e  ssible so we can
-00024a70: 0a20 2020 2020 2020 2020 2020 2023 2069  .            # i
-00024a80: 6e73 6572 7420 7468 6520 7265 6d61 696e  nsert the remain
-00024a90: 6465 7220 6f75 7473 6964 6520 6f66 2074  der outside of t
-00024aa0: 6865 206c 6f6f 700a 2020 2020 2020 2020  he loop.        
-00024ab0: 2020 2020 756e 616c 6967 6e65 6420 3d20      unaligned = 
-00024ac0: 496e 7365 7274 4178 6973 2875 6e61 6c69  InsertAxis(unali
-00024ad0: 676e 6564 2c20 7365 6c66 2e66 756e 632e  gned, self.func.
-00024ae0: 7368 6170 655b 2d31 5d20 6966 2073 656c  shape[-1] if sel
-00024af0: 662e 696e 6465 7820 696e 2073 656c 662e  f.index in self.
-00024b00: 6675 6e63 2e73 6861 7065 5b2d 315d 2e61  func.shape[-1].a
-00024b10: 7267 756d 656e 7473 2065 6c73 6520 3129  rguments else 1)
-00024b20: 0a20 2020 2020 2020 2020 2020 2077 6865  .            whe
-00024b30: 7265 202b 3d20 7365 6c66 2e6e 6469 6d2d  re += self.ndim-
-00024b40: 312c 0a20 2020 2020 2020 2065 6c69 6620  1,.        elif 
-00024b50: 7768 6572 655b 2d31 5d20 213d 2073 656c  where[-1] != sel
-00024b60: 662e 6e64 696d 2d31 3a0a 2020 2020 2020  f.ndim-1:.      
-00024b70: 2020 2020 2020 2320 6272 696e 6720 636f        # bring co
-00024b80: 6e63 6174 656e 6174 696f 6e20 6178 6973  ncatenation axis
-00024b90: 2074 6f20 7468 6520 656e 640a 2020 2020   to the end.    
-00024ba0: 2020 2020 2020 2020 756e 616c 6967 6e65          unaligne
-00024bb0: 6420 3d20 5472 616e 7370 6f73 6528 756e  d = Transpose(un
-00024bc0: 616c 6967 6e65 642c 206e 756d 7079 2e61  aligned, numpy.a
-00024bd0: 7267 736f 7274 2877 6865 7265 2929 0a20  rgsort(where)). 
-00024be0: 2020 2020 2020 2020 2020 2077 6865 7265             where
-00024bf0: 203d 2074 7570 6c65 2873 6f72 7465 6428   = tuple(sorted(
-00024c00: 7768 6572 6529 290a 2020 2020 2020 2020  where)).        
-00024c10: 6620 3d20 6c6f 6f70 5f63 6f6e 6361 7465  f = loop_concate
-00024c20: 6e61 7465 2875 6e61 6c69 676e 6564 2c20  nate(unaligned, 
-00024c30: 7365 6c66 2e69 6e64 6578 290a 2020 2020  self.index).    
-00024c40: 2020 2020 6966 206e 6f74 2065 7175 616c      if not equal
-00024c50: 696e 6465 7828 7365 6c66 2e73 6861 7065  index(self.shape
-00024c60: 5b2d 315d 2c20 662e 7368 6170 655b 2d31  [-1], f.shape[-1
-00024c70: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
-00024c80: 2320 6c61 7374 2061 7869 7320 7761 7320  # last axis was 
-00024c90: 7265 696e 7365 7274 6564 2061 7420 756e  reinserted at un
-00024ca0: 6974 206c 656e 6774 6820 414e 4420 6974  it length AND it
-00024cb0: 2077 6173 206e 6f74 2075 6e69 7420 6c65   was not unit le
-00024cc0: 6e67 7468 0a20 2020 2020 2020 2020 2020  ngth.           
-00024cd0: 2023 206f 7269 6769 6e61 6c6c 7920 2d20   # originally - 
-00024ce0: 6966 2069 7420 7761 7320 756e 6974 206c  if it was unit l
-00024cf0: 656e 6774 6820 6f72 6967 696e 616c 6c79  ength originally
-00024d00: 2074 6865 6e20 7765 2070 726f 6365 6564   then we proceed
-00024d10: 206f 6e6c 7920 6966 0a20 2020 2020 2020   only if.       
-00024d20: 2020 2020 2023 2074 6865 7265 2061 7265       # there are
-00024d30: 206f 7468 6572 2069 6e73 6572 7469 6f6e   other insertion
-00024d40: 7320 746f 2070 726f 6d6f 7465 2c20 6f74  s to promote, ot
-00024d50: 6865 7277 6973 6520 7765 2764 2067 6574  herwise we'd get
-00024d60: 2061 2072 6563 7572 7369 6f6e 2e0a 2020   a recursion..  
-00024d70: 2020 2020 2020 2020 2020 6620 3d20 5261            f = Ra
-00024d80: 7665 6c28 496e 7365 7274 4178 6973 2866  vel(InsertAxis(f
-00024d90: 2c20 7365 6c66 2e66 756e 632e 7368 6170  , self.func.shap
-00024da0: 655b 2d31 5d29 290a 2020 2020 2020 2020  e[-1])).        
-00024db0: 656c 6966 206c 656e 2877 6865 7265 2920  elif len(where) 
-00024dc0: 3d3d 2073 656c 662e 6e64 696d 3a0a 2020  == self.ndim:.  
-00024dd0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00024de0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00024df0: 616c 6967 6e28 662c 2077 6865 7265 2c20  align(f, where, 
-00024e00: 7365 6c66 2e73 6861 7065 290a 0a20 2020  self.shape)..   
-00024e10: 2064 6566 205f 7461 6b65 6469 6167 2873   def _takediag(s
-00024e20: 656c 662c 2061 7869 7331 2c20 6178 6973  elf, axis1, axis
-00024e30: 3229 3a0a 2020 2020 2020 2020 6966 2061  2):.        if a
-00024e40: 7869 7331 203c 2073 656c 662e 6e64 696d  xis1 < self.ndim
-00024e50: 2d31 2061 6e64 2061 7869 7332 203c 2073  -1 and axis2 < s
-00024e60: 656c 662e 6e64 696d 2d31 3a0a 2020 2020  elf.ndim-1:.    
-00024e70: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-00024e80: 7261 6e73 706f 7365 2e66 726f 6d5f 656e  ranspose.from_en
-00024e90: 6428 6c6f 6f70 5f63 6f6e 6361 7465 6e61  d(loop_concatena
-00024ea0: 7465 2854 7261 6e73 706f 7365 2e74 6f5f  te(Transpose.to_
-00024eb0: 656e 6428 5f74 616b 6564 6961 6728 7365  end(_takediag(se
-00024ec0: 6c66 2e66 756e 632c 2061 7869 7331 2c20  lf.func, axis1, 
-00024ed0: 6178 6973 3229 2c20 2d32 292c 2073 656c  axis2), -2), sel
-00024ee0: 662e 696e 6465 7829 2c20 2d32 290a 0a20  f.index), -2).. 
-00024ef0: 2020 2064 6566 205f 7461 6b65 2873 656c     def _take(sel
-00024f00: 662c 2069 6e64 6578 2c20 6178 6973 293a  f, index, axis):
-00024f10: 0a20 2020 2020 2020 2069 6620 6178 6973  .        if axis
-00024f20: 203c 2073 656c 662e 6e64 696d 2d31 3a0a   < self.ndim-1:.
-00024f30: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00024f40: 726e 206c 6f6f 705f 636f 6e63 6174 656e  rn loop_concaten
-00024f50: 6174 6528 5f74 616b 6528 7365 6c66 2e66  ate(_take(self.f
-00024f60: 756e 632c 2069 6e64 6578 2c20 6178 6973  unc, index, axis
-00024f70: 292c 2073 656c 662e 696e 6465 7829 0a0a  ), self.index)..
-00024f80: 2020 2020 6465 6620 5f75 6e72 6176 656c      def _unravel
-00024f90: 2873 656c 662c 2061 7869 732c 2073 6861  (self, axis, sha
-00024fa0: 7065 293a 0a20 2020 2020 2020 2069 6620  pe):.        if 
-00024fb0: 6178 6973 203c 2073 656c 662e 6e64 696d  axis < self.ndim
-00024fc0: 2d31 3a0a 2020 2020 2020 2020 2020 2020  -1:.            
-00024fd0: 7265 7475 726e 206c 6f6f 705f 636f 6e63  return loop_conc
-00024fe0: 6174 656e 6174 6528 756e 7261 7665 6c28  atenate(unravel(
-00024ff0: 7365 6c66 2e66 756e 632c 2061 7869 732c  self.func, axis,
-00025000: 2073 6861 7065 292c 2073 656c 662e 696e   shape), self.in
-00025010: 6465 7829 0a0a 2020 2020 4070 726f 7065  dex)..    @prope
-00025020: 7274 790a 2020 2020 6465 6620 5f61 7373  rty.    def _ass
-00025030: 7061 7273 6528 7365 6c66 293a 0a20 2020  parse(self):.   
-00025040: 2020 2020 2063 6875 6e6b 7320 3d20 5b5d       chunks = []
-00025050: 0a20 2020 2020 2020 2066 6f72 202a 696e  .        for *in
-00025060: 6469 6365 732c 206c 6173 745f 696e 6465  dices, last_inde
-00025070: 782c 2076 616c 7565 7320 696e 2073 656c  x, values in sel
-00025080: 662e 6675 6e63 2e5f 6173 7370 6172 7365  f.func._assparse
-00025090: 3a0a 2020 2020 2020 2020 2020 2020 6c61  :.            la
-000250a0: 7374 5f69 6e64 6578 203d 206c 6173 745f  st_index = last_
-000250b0: 696e 6465 7820 2b20 7072 6570 656e 6461  index + prependa
-000250c0: 7865 7328 7365 6c66 2e73 7461 7274 2c20  xes(self.start, 
-000250d0: 6c61 7374 5f69 6e64 6578 2e73 6861 7065  last_index.shape
-000250e0: 290a 2020 2020 2020 2020 2020 2020 6368  ).            ch
-000250f0: 756e 6b73 2e61 7070 656e 6428 7475 706c  unks.append(tupl
-00025100: 6528 6c6f 6f70 5f63 6f6e 6361 7465 6e61  e(loop_concatena
-00025110: 7465 285f 666c 6174 2861 7272 292c 2073  te(_flat(arr), s
-00025120: 656c 662e 696e 6465 7829 2066 6f72 2061  elf.index) for a
-00025130: 7272 2069 6e20 282a 696e 6469 6365 732c  rr in (*indices,
-00025140: 206c 6173 745f 696e 6465 782c 2076 616c   last_index, val
-00025150: 7565 7329 2929 0a20 2020 2020 2020 2072  ues))).        r
-00025160: 6574 7572 6e20 7475 706c 6528 6368 756e  eturn tuple(chun
-00025170: 6b73 290a 0a20 2020 2040 7072 6f70 6572  ks)..    @proper
-00025180: 7479 0a20 2020 2064 6566 205f 6c6f 6f70  ty.    def _loop
-00025190: 5f63 6f6e 6361 7465 6e61 7465 5f64 6570  _concatenate_dep
-000251a0: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
-000251b0: 2072 6574 7572 6e20 2873 656c 662c 2920   return (self,) 
-000251c0: 2b20 7375 7065 7228 292e 5f6c 6f6f 705f  + super()._loop_
-000251d0: 636f 6e63 6174 656e 6174 655f 6465 7073  concatenate_deps
-000251e0: 0a0a 2020 2020 6465 6620 5f69 6e74 626f  ..    def _intbo
-000251f0: 756e 6473 5f69 6d70 6c28 7365 6c66 293a  unds_impl(self):
-00025200: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00025210: 7365 6c66 2e66 756e 632e 5f69 6e74 626f  self.func._intbo
-00025220: 756e 6473 0a0a 0a63 6c61 7373 204c 6f6f  unds...class Loo
-00025230: 7043 6f6e 6361 7465 6e61 7465 436f 6d62  pConcatenateComb
-00025240: 696e 6564 2845 7661 6c75 6162 6c65 293a  ined(Evaluable):
-00025250: 0a0a 2020 2020 5f5f 6361 6368 655f 5f20  ..    __cache__ 
-00025260: 3d20 275f 7365 7269 616c 697a 6564 270a  = '_serialized'.
-00025270: 0a20 2020 2040 7479 7065 732e 6170 706c  .    @types.appl
-00025280: 795f 616e 6e6f 7461 7469 6f6e 730a 2020  y_annotations.  
-00025290: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
-000252a0: 656c 662c 2066 756e 6364 6174 6173 3a20  elf, funcdatas: 
-000252b0: 7479 7065 732e 7475 706c 655b 6173 6172  types.tuple[asar
-000252c0: 7261 7973 5d2c 2069 6e64 6578 5f6e 616d  rays], index_nam
-000252d0: 653a 2074 7970 6573 2e73 7472 6963 7473  e: types.stricts
-000252e0: 7472 2c20 6c65 6e67 7468 3a20 6173 696e  tr, length: asin
-000252f0: 6465 7829 3a0a 2020 2020 2020 2020 7365  dex):.        se
-00025300: 6c66 2e5f 6675 6e63 6461 7461 7320 3d20  lf._funcdatas = 
-00025310: 6675 6e63 6461 7461 730a 2020 2020 2020  funcdatas.      
-00025320: 2020 7365 6c66 2e5f 6675 6e63 7320 3d20    self._funcs = 
-00025330: 7475 706c 6528 6675 6e63 2066 6f72 2066  tuple(func for f
-00025340: 756e 632c 2073 7461 7274 2c20 7374 6f70  unc, start, stop
-00025350: 2c20 2a73 6861 7065 2069 6e20 6675 6e63  , *shape in func
-00025360: 6461 7461 7329 0a20 2020 2020 2020 2073  datas).        s
-00025370: 656c 662e 5f69 6e64 6578 5f6e 616d 6520  elf._index_name 
-00025380: 3d20 696e 6465 785f 6e61 6d65 0a20 2020  = index_name.   
-00025390: 2020 2020 2073 656c 662e 5f69 6e64 6578       self._index
-000253a0: 203d 206c 6f6f 705f 696e 6465 7828 696e   = loop_index(in
-000253b0: 6465 785f 6e61 6d65 2c20 6c65 6e67 7468  dex_name, length
-000253c0: 290a 2020 2020 2020 2020 6966 2061 6e79  ).        if any
-000253d0: 286e 6f74 2066 756e 632e 6e64 696d 2066  (not func.ndim f
-000253e0: 6f72 2066 756e 6320 696e 2073 656c 662e  or func in self.
-000253f0: 5f66 756e 6373 293a 0a20 2020 2020 2020  _funcs):.       
-00025400: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-00025410: 4572 726f 7228 2765 7870 6563 7465 6420  Error('expected 
-00025420: 616e 2061 7272 6179 2077 6974 6820 6174  an array with at
-00025430: 206c 6561 7374 206f 6e65 2061 7869 7327   least one axis'
-00025440: 290a 2020 2020 2020 2020 7368 6170 6573  ).        shapes
-00025450: 203d 205b 5475 706c 6528 7368 6170 6529   = [Tuple(shape)
-00025460: 2066 6f72 2066 756e 632c 2073 7461 7274   for func, start
-00025470: 2c20 7374 6f70 2c20 2a73 6861 7065 2069  , stop, *shape i
-00025480: 6e20 6675 6e63 6461 7461 735d 0a20 2020  n funcdatas].   
-00025490: 2020 2020 2069 6620 616e 7928 7365 6c66       if any(self
-000254a0: 2e5f 696e 6465 7820 696e 2073 6861 7065  ._index in shape
-000254b0: 2e61 7267 756d 656e 7473 2066 6f72 2073  .arguments for s
-000254c0: 6861 7065 2069 6e20 7368 6170 6573 293a  hape in shapes):
-000254d0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-000254e0: 7365 2056 616c 7565 4572 726f 7228 2774  se ValueError('t
-000254f0: 6865 2073 6861 7065 206f 6620 7468 6520  he shape of the 
-00025500: 6675 6e63 7469 6f6e 206d 7573 7420 6e6f  function must no
-00025510: 7420 6465 7065 6e64 206f 6e20 7468 6520  t depend on the 
-00025520: 696e 6465 7827 290a 2020 2020 2020 2020  index').        
-00025530: 7365 6c66 2e5f 696e 7661 7269 616e 7473  self._invariants
-00025540: 2c20 7365 6c66 2e5f 6465 7065 6e64 656e  , self._dependen
-00025550: 6369 6573 203d 205f 6465 7065 6e64 656e  cies = _dependen
-00025560: 6369 6573 5f73 616e 735f 696e 7661 7269  cies_sans_invari
-00025570: 616e 7473 280a 2020 2020 2020 2020 2020  ants(.          
-00025580: 2020 5475 706c 6528 5b54 7570 6c65 285b    Tuple([Tuple([
-00025590: 7374 6172 742c 2073 746f 702c 2066 756e  start, stop, fun
-000255a0: 635d 2920 666f 7220 6675 6e63 2c20 7374  c]) for func, st
-000255b0: 6172 742c 2073 746f 702c 202a 7368 6170  art, stop, *shap
-000255c0: 6520 696e 2066 756e 6364 6174 6173 5d29  e in funcdatas])
-000255d0: 2c20 7365 6c66 2e5f 696e 6465 7829 0a20  , self._index). 
-000255e0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
-000255f0: 5f69 6e69 745f 5f28 6172 6773 3d28 5475  _init__(args=(Tu
-00025600: 706c 6528 7368 6170 6573 292c 206c 656e  ple(shapes), len
-00025610: 6774 682c 202a 7365 6c66 2e5f 696e 7661  gth, *self._inva
-00025620: 7269 616e 7473 2929 0a0a 2020 2020 4070  riants))..    @p
-00025630: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00025640: 5f73 6572 6961 6c69 7a65 6428 7365 6c66  _serialized(self
-00025650: 293a 0a20 2020 2020 2020 2069 6e64 6963  ):.        indic
-00025660: 6573 203d 207b 643a 2069 2066 6f72 2069  es = {d: i for i
-00025670: 2c20 6420 696e 2065 6e75 6d65 7261 7465  , d in enumerate
-00025680: 2869 7465 7274 6f6f 6c73 2e63 6861 696e  (itertools.chain
-00025690: 285b 7365 6c66 2e5f 696e 6465 785d 2c20  ([self._index], 
-000256a0: 7365 6c66 2e5f 696e 7661 7269 616e 7473  self._invariants
-000256b0: 2c20 7365 6c66 2e5f 6465 7065 6e64 656e  , self._dependen
-000256c0: 6369 6573 2929 7d0a 2020 2020 2020 2020  cies))}.        
-000256d0: 7265 7475 726e 2074 7570 6c65 2828 6465  return tuple((de
-000256e0: 702c 2074 7570 6c65 286d 6170 2869 6e64  p, tuple(map(ind
-000256f0: 6963 6573 2e5f 5f67 6574 6974 656d 5f5f  ices.__getitem__
-00025700: 2c20 6465 702e 5f45 7661 6c75 6162 6c65  , dep._Evaluable
-00025710: 5f5f 6172 6773 2929 2920 666f 7220 6465  __args))) for de
-00025720: 7020 696e 2073 656c 662e 5f64 6570 656e  p in self._depen
-00025730: 6465 6e63 6965 7329 0a0a 2020 2020 6465  dencies)..    de
-00025740: 6620 6576 616c 6628 7365 6c66 2c20 7368  f evalf(self, sh
-00025750: 6170 6573 2c20 6c65 6e67 7468 2c20 2a61  apes, length, *a
-00025760: 7267 7329 3a0a 2020 2020 2020 2020 7365  rgs):.        se
-00025770: 7269 616c 697a 6564 203d 2073 656c 662e  rialized = self.
-00025780: 5f73 6572 6961 6c69 7a65 640a 2020 2020  _serialized.    
-00025790: 2020 2020 7265 7375 6c74 7320 3d20 5b70      results = [p
-000257a0: 6172 616c 6c65 6c2e 7368 656d 7074 7928  arallel.shempty(
-000257b0: 7475 706c 6528 6d61 7028 696e 742c 2073  tuple(map(int, s
-000257c0: 6861 7065 2929 2c20 6474 7970 653d 6675  hape)), dtype=fu
-000257d0: 6e63 2e64 7479 7065 2920 666f 7220 6675  nc.dtype) for fu
-000257e0: 6e63 2c20 7368 6170 6520 696e 207a 6970  nc, shape in zip
-000257f0: 2873 656c 662e 5f66 756e 6373 2c20 7368  (self._funcs, sh
-00025800: 6170 6573 295d 0a20 2020 2020 2020 2077  apes)].        w
-00025810: 6974 6820 7061 7261 6c6c 656c 2e63 7478  ith parallel.ctx
-00025820: 7261 6e67 6528 276c 6f6f 7020 7b7d 272e  range('loop {}'.
-00025830: 666f 726d 6174 2873 656c 662e 5f69 6e64  format(self._ind
-00025840: 6578 5f6e 616d 6529 2c20 696e 7428 6c65  ex_name), int(le
-00025850: 6e67 7468 2929 2061 7320 696e 6469 6365  ngth)) as indice
-00025860: 733a 0a20 2020 2020 2020 2020 2020 2066  s:.            f
-00025870: 6f72 2069 6e64 6578 2069 6e20 696e 6469  or index in indi
-00025880: 6365 733a 0a20 2020 2020 2020 2020 2020  ces:.           
-00025890: 2020 2020 2076 616c 7565 7320 3d20 5b6e       values = [n
-000258a0: 756d 7079 2e61 7272 6179 2869 6e64 6578  umpy.array(index
-000258b0: 295d 0a20 2020 2020 2020 2020 2020 2020  )].             
-000258c0: 2020 2076 616c 7565 732e 6578 7465 6e64     values.extend
-000258d0: 2861 7267 7329 0a20 2020 2020 2020 2020  (args).         
-000258e0: 2020 2020 2020 2076 616c 7565 732e 6578         values.ex
-000258f0: 7465 6e64 286f 702e 6576 616c 6628 2a5b  tend(op.evalf(*[
-00025900: 7661 6c75 6573 5b69 5d20 666f 7220 6920  values[i] for i 
-00025910: 696e 2069 6e64 6963 6573 5d29 2066 6f72  in indices]) for
-00025920: 206f 702c 2069 6e64 6963 6573 2069 6e20   op, indices in 
-00025930: 7365 7269 616c 697a 6564 290a 2020 2020  serialized).    
-00025940: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00025950: 7265 7375 6c74 2c20 2873 7461 7274 2c20  result, (start, 
-00025960: 7374 6f70 2c20 626c 6f63 6b29 2069 6e20  stop, block) in 
-00025970: 7a69 7028 7265 7375 6c74 732c 2076 616c  zip(results, val
-00025980: 7565 735b 2d31 5d29 3a0a 2020 2020 2020  ues[-1]):.      
-00025990: 2020 2020 2020 2020 2020 2020 2020 7265                re
-000259a0: 7375 6c74 5b2e 2e2e 2c20 7374 6172 743a  sult[..., start:
-000259b0: 7374 6f70 5d20 3d20 626c 6f63 6b0a 2020  stop] = block.  
-000259c0: 2020 2020 2020 7265 7475 726e 2074 7570        return tup
-000259d0: 6c65 2872 6573 756c 7473 290a 0a20 2020  le(results)..   
-000259e0: 2064 6566 2065 7661 6c66 5f77 6974 6874   def evalf_witht
-000259f0: 696d 6573 2873 656c 662c 2074 696d 6573  imes(self, times
-00025a00: 2c20 7368 6170 6573 2c20 6c65 6e67 7468  , shapes, length
-00025a10: 2c20 2a61 7267 7329 3a0a 2020 2020 2020  , *args):.      
-00025a20: 2020 7365 7269 616c 697a 6564 203d 2073    serialized = s
-00025a30: 656c 662e 5f73 6572 6961 6c69 7a65 640a  elf._serialized.
-00025a40: 2020 2020 2020 2020 7375 6274 696d 6573          subtimes
-00025a50: 203d 2074 696d 6573 2e73 6574 6465 6661   = times.setdefa
-00025a60: 756c 7428 7365 6c66 2c20 636f 6c6c 6563  ult(self, collec
-00025a70: 7469 6f6e 732e 6465 6661 756c 7464 6963  tions.defaultdic
-00025a80: 7428 5f53 7461 7473 2929 0a20 2020 2020  t(_Stats)).     
-00025a90: 2020 2072 6573 756c 7473 203d 205b 7061     results = [pa
-00025aa0: 7261 6c6c 656c 2e73 6865 6d70 7479 2874  rallel.shempty(t
-00025ab0: 7570 6c65 286d 6170 2869 6e74 2c20 7368  uple(map(int, sh
-00025ac0: 6170 6529 292c 2064 7479 7065 3d66 756e  ape)), dtype=fun
-00025ad0: 632e 6474 7970 6529 2066 6f72 2066 756e  c.dtype) for fun
-00025ae0: 632c 2073 6861 7065 2069 6e20 7a69 7028  c, shape in zip(
-00025af0: 7365 6c66 2e5f 6675 6e63 732c 2073 6861  self._funcs, sha
-00025b00: 7065 7329 5d0a 2020 2020 2020 2020 666f  pes)].        fo
-00025b10: 7220 696e 6465 7820 696e 2072 616e 6765  r index in range
-00025b20: 286c 656e 6774 6829 3a0a 2020 2020 2020  (length):.      
-00025b30: 2020 2020 2020 7661 6c75 6573 203d 205b        values = [
-00025b40: 6e75 6d70 792e 6172 7261 7928 696e 6465  numpy.array(inde
-00025b50: 7829 5d0a 2020 2020 2020 2020 2020 2020  x)].            
-00025b60: 7661 6c75 6573 2e65 7874 656e 6428 6172  values.extend(ar
-00025b70: 6773 290a 2020 2020 2020 2020 2020 2020  gs).            
-00025b80: 7661 6c75 6573 2e65 7874 656e 6428 6f70  values.extend(op
-00025b90: 2e65 7661 6c66 5f77 6974 6874 696d 6573  .evalf_withtimes
-00025ba0: 2873 7562 7469 6d65 732c 202a 5b76 616c  (subtimes, *[val
-00025bb0: 7565 735b 695d 2066 6f72 2069 2069 6e20  ues[i] for i in 
-00025bc0: 696e 6469 6365 735d 2920 666f 7220 6f70  indices]) for op
-00025bd0: 2c20 696e 6469 6365 7320 696e 2073 6572  , indices in ser
-00025be0: 6961 6c69 7a65 6429 0a20 2020 2020 2020  ialized).       
-00025bf0: 2020 2020 2066 6f72 2066 756e 632c 2072       for func, r
-00025c00: 6573 756c 742c 2028 7374 6172 742c 2073  esult, (start, s
-00025c10: 746f 702c 2062 6c6f 636b 2920 696e 207a  top, block) in z
-00025c20: 6970 2873 656c 662e 5f66 756e 6373 2c20  ip(self._funcs, 
-00025c30: 7265 7375 6c74 732c 2076 616c 7565 735b  results, values[
-00025c40: 2d31 5d29 3a0a 2020 2020 2020 2020 2020  -1]):.          
-00025c50: 2020 2020 2020 7769 7468 2073 7562 7469        with subti
-00025c60: 6d65 735b 2763 6f6e 6361 7427 2c20 6675  mes['concat', fu
-00025c70: 6e63 5d3a 0a20 2020 2020 2020 2020 2020  nc]:.           
-00025c80: 2020 2020 2020 2020 2072 6573 756c 745b           result[
-00025c90: 2e2e 2e2c 2073 7461 7274 3a73 746f 705d  ..., start:stop]
-00025ca0: 203d 2062 6c6f 636b 0a20 2020 2020 2020   = block.       
-00025cb0: 2072 6574 7572 6e20 7475 706c 6528 7265   return tuple(re
-00025cc0: 7375 6c74 7329 0a0a 2020 2020 6465 6620  sults)..    def 
-00025cd0: 5f6e 6f64 655f 7475 706c 6528 7365 6c66  _node_tuple(self
-00025ce0: 2c20 6361 6368 652c 2073 7562 6772 6170  , cache, subgrap
-00025cf0: 682c 2074 696d 6573 293a 0a20 2020 2020  h, times):.     
-00025d00: 2020 2069 6620 2873 656c 662c 2027 7475     if (self, 'tu
-00025d10: 706c 6527 2920 696e 2063 6163 6865 3a0a  ple') in cache:.
-00025d20: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00025d30: 726e 2063 6163 6865 5b73 656c 662c 2027  rn cache[self, '
-00025d40: 7475 706c 6527 5d0a 2020 2020 2020 2020  tuple'].        
-00025d50: 7375 6263 6163 6865 203d 207b 7d0a 2020  subcache = {}.  
-00025d60: 2020 2020 2020 666f 7220 6172 6720 696e        for arg in
-00025d70: 2073 656c 662e 5f69 6e76 6172 6961 6e74   self._invariant
-00025d80: 733a 0a20 2020 2020 2020 2020 2020 2073  s:.            s
-00025d90: 7562 6361 6368 655b 6172 675d 203d 2061  ubcache[arg] = a
-00025da0: 7267 2e5f 6e6f 6465 2863 6163 6865 2c20  rg._node(cache, 
-00025db0: 7375 6267 7261 7068 2c20 7469 6d65 7329  subgraph, times)
-00025dc0: 0a20 2020 2020 2020 206c 6f6f 7067 7261  .        loopgra
-00025dd0: 7068 203d 2053 7562 6772 6170 6828 274c  ph = Subgraph('L
-00025de0: 6f6f 7027 2c20 7375 6267 7261 7068 290a  oop', subgraph).
-00025df0: 2020 2020 2020 2020 7375 6274 696d 6573          subtimes
-00025e00: 203d 2074 696d 6573 2e67 6574 2873 656c   = times.get(sel
-00025e10: 662c 2063 6f6c 6c65 6374 696f 6e73 2e64  f, collections.d
-00025e20: 6566 6175 6c74 6469 6374 285f 5374 6174  efaultdict(_Stat
-00025e30: 7329 290a 2020 2020 2020 2020 636f 6e63  s)).        conc
-00025e40: 6174 7320 3d20 5b5d 0a20 2020 2020 2020  ats = [].       
-00025e50: 2066 6f72 2066 756e 632c 2073 7461 7274   for func, start
-00025e60: 2c20 7374 6f70 2c20 2a73 6861 7065 2069  , stop, *shape i
-00025e70: 6e20 7365 6c66 2e5f 6675 6e63 6461 7461  n self._funcdata
-00025e80: 733a 0a20 2020 2020 2020 2020 2020 2063  s:.            c
-00025e90: 6f6e 6361 745f 6b77 6172 6773 203d 207b  oncat_kwargs = {
-00025ea0: 2773 6861 7065 5b7b 7d5d 272e 666f 726d  'shape[{}]'.form
-00025eb0: 6174 2869 293a 206e 2e5f 6e6f 6465 2863  at(i): n._node(c
-00025ec0: 6163 6865 2c20 7375 6267 7261 7068 2c20  ache, subgraph, 
-00025ed0: 7469 6d65 7329 2066 6f72 2069 2c20 6e20  times) for i, n 
-00025ee0: 696e 2065 6e75 6d65 7261 7465 2873 6861  in enumerate(sha
-00025ef0: 7065 297d 0a20 2020 2020 2020 2020 2020  pe)}.           
-00025f00: 2063 6f6e 6361 745f 6b77 6172 6773 5b27   concat_kwargs['
-00025f10: 7374 6172 7427 5d20 3d20 7374 6172 742e  start'] = start.
-00025f20: 5f6e 6f64 6528 7375 6263 6163 6865 2c20  _node(subcache, 
-00025f30: 6c6f 6f70 6772 6170 682c 2073 7562 7469  loopgraph, subti
-00025f40: 6d65 7329 0a20 2020 2020 2020 2020 2020  mes).           
-00025f50: 2063 6f6e 6361 745f 6b77 6172 6773 5b27   concat_kwargs['
-00025f60: 7374 6f70 275d 203d 2073 746f 702e 5f6e  stop'] = stop._n
-00025f70: 6f64 6528 7375 6263 6163 6865 2c20 6c6f  ode(subcache, lo
-00025f80: 6f70 6772 6170 682c 2073 7562 7469 6d65  opgraph, subtime
-00025f90: 7329 0a20 2020 2020 2020 2020 2020 2063  s).            c
-00025fa0: 6f6e 6361 745f 6b77 6172 6773 5b27 6675  oncat_kwargs['fu
-00025fb0: 6e63 275d 203d 2066 756e 632e 5f6e 6f64  nc'] = func._nod
-00025fc0: 6528 7375 6263 6163 6865 2c20 6c6f 6f70  e(subcache, loop
-00025fd0: 6772 6170 682c 2073 7562 7469 6d65 7329  graph, subtimes)
-00025fe0: 0a20 2020 2020 2020 2020 2020 2063 6f6e  .            con
-00025ff0: 6361 7473 2e61 7070 656e 6428 5265 6775  cats.append(Regu
-00026000: 6c61 724e 6f64 6528 274c 6f6f 7043 6f6e  larNode('LoopCon
-00026010: 6361 7465 6e61 7465 272c 2028 292c 2063  catenate', (), c
-00026020: 6f6e 6361 745f 6b77 6172 6773 2c20 2874  oncat_kwargs, (t
-00026030: 7970 6528 7365 6c66 292e 5f5f 6e61 6d65  ype(self).__name
-00026040: 5f5f 2c20 7375 6274 696d 6573 5b27 636f  __, subtimes['co
-00026050: 6e63 6174 272c 2066 756e 635d 292c 206c  ncat', func]), l
-00026060: 6f6f 7067 7261 7068 2929 0a20 2020 2020  oopgraph)).     
-00026070: 2020 2063 6163 6865 5b73 656c 662c 2027     cache[self, '
-00026080: 7475 706c 6527 5d20 3d20 636f 6e63 6174  tuple'] = concat
-00026090: 7320 3d20 7475 706c 6528 636f 6e63 6174  s = tuple(concat
-000260a0: 7329 0a20 2020 2020 2020 2072 6574 7572  s).        retur
-000260b0: 6e20 636f 6e63 6174 730a 0a23 2041 5558  n concats..# AUX
-000260c0: 494c 4941 5259 2046 554e 4354 494f 4e53  ILIARY FUNCTIONS
-000260d0: 2028 464f 5220 494e 5445 524e 414c 2055   (FOR INTERNAL U
-000260e0: 5345 290a 0a0a 5f61 7363 656e 6469 6e67  SE)..._ascending
-000260f0: 203d 206c 616d 6264 6120 6172 673a 206e   = lambda arg: n
-00026100: 756d 7079 2e67 7265 6174 6572 286e 756d  umpy.greater(num
-00026110: 7079 2e64 6966 6628 6172 6729 2c20 3029  py.diff(arg), 0)
-00026120: 2e61 6c6c 2829 0a5f 6e6f 726d 6469 6d73  .all()._normdims
-00026130: 203d 206c 616d 6264 6120 6e64 696d 2c20   = lambda ndim, 
-00026140: 7368 6170 6573 3a20 7475 706c 6528 6e75  shapes: tuple(nu
-00026150: 6d65 7269 632e 6e6f 726d 6469 6d28 6e64  meric.normdim(nd
-00026160: 696d 2c20 7368 2920 666f 7220 7368 2069  im, sh) for sh i
-00026170: 6e20 7368 6170 6573 290a 0a0a 6465 6620  n shapes)...def 
-00026180: 5f67 6174 6865 7262 6c6f 636b 7328 626c  _gatherblocks(bl
-00026190: 6f63 6b73 293a 0a20 2020 2072 6574 7572  ocks):.    retur
-000261a0: 6e20 7475 706c 6528 2869 6e64 2c20 7574  n tuple((ind, ut
-000261b0: 696c 2e73 756d 2866 756e 6373 2929 2066  il.sum(funcs)) f
-000261c0: 6f72 2069 6e64 2c20 6675 6e63 7320 696e  or ind, funcs in
-000261d0: 2075 7469 6c2e 6761 7468 6572 2862 6c6f   util.gather(blo
-000261e0: 636b 7329 290a 0a0a 6465 6620 5f67 6174  cks))...def _gat
-000261f0: 6865 7273 7061 7273 6563 6875 6e6b 7328  hersparsechunks(
-00026200: 6368 756e 6b73 293a 0a20 2020 2072 6574  chunks):.    ret
-00026210: 7572 6e20 7475 706c 6528 282a 696e 642c  urn tuple((*ind,
-00026220: 2075 7469 6c2e 7375 6d28 6675 6e63 7329   util.sum(funcs)
-00026230: 2920 666f 7220 696e 642c 2066 756e 6373  ) for ind, funcs
-00026240: 2069 6e20 7574 696c 2e67 6174 6865 7228   in util.gather(
-00026250: 2874 7570 6c65 2869 6e64 292c 2066 756e  (tuple(ind), fun
-00026260: 6329 2066 6f72 202a 696e 642c 2066 756e  c) for *ind, fun
-00026270: 6320 696e 2063 6875 6e6b 7329 290a 0a0a  c in chunks))...
-00026280: 6465 6620 5f6e 756d 7079 5f61 6c69 676e  def _numpy_align
-00026290: 2861 2c20 6229 3a0a 2020 2020 2727 2763  (a, b):.    '''c
-000262a0: 6865 636b 2073 6861 7065 2063 6f6e 7369  heck shape consi
-000262b0: 7374 656e 6379 2061 6e64 2069 6e66 6c61  stency and infla
-000262c0: 7465 2073 6361 6c61 7273 2727 270a 0a20  te scalars'''.. 
-000262d0: 2020 2061 203d 2061 7361 7272 6179 2861     a = asarray(a
-000262e0: 290a 2020 2020 6220 3d20 6173 6172 7261  ).    b = asarra
-000262f0: 7928 6229 0a20 2020 2069 6620 612e 6474  y(b).    if a.dt
-00026300: 7970 6520 213d 2062 2e64 7479 7065 3a0a  ype != b.dtype:.
-00026310: 2020 2020 2020 2020 6966 205f 7479 7065          if _type
-00026320: 5f6f 7264 6572 2e69 6e64 6578 2861 2e64  _order.index(a.d
-00026330: 7479 7065 2920 3c20 5f74 7970 655f 6f72  type) < _type_or
-00026340: 6465 722e 696e 6465 7828 622e 6474 7970  der.index(b.dtyp
-00026350: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
-00026360: 6120 3d20 6173 7479 7065 2861 2c20 622e  a = astype(a, b.
-00026370: 6474 7970 6529 0a20 2020 2020 2020 2065  dtype).        e
-00026380: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00026390: 2062 203d 2061 7374 7970 6528 622c 2061   b = astype(b, a
-000263a0: 2e64 7479 7065 290a 2020 2020 6966 206e  .dtype).    if n
-000263b0: 6f74 2061 2e6e 6469 6d3a 0a20 2020 2020  ot a.ndim:.     
-000263c0: 2020 2072 6574 7572 6e20 5f69 6e66 6c61     return _infla
-000263d0: 7465 5f73 6361 6c61 7228 612c 2062 2e73  te_scalar(a, b.s
-000263e0: 6861 7065 292c 2062 0a20 2020 2069 6620  hape), b.    if 
-000263f0: 6e6f 7420 622e 6e64 696d 3a0a 2020 2020  not b.ndim:.    
-00026400: 2020 2020 7265 7475 726e 2061 2c20 5f69      return a, _i
-00026410: 6e66 6c61 7465 5f73 6361 6c61 7228 622c  nflate_scalar(b,
-00026420: 2061 2e73 6861 7065 290a 2020 2020 6966   a.shape).    if
-00026430: 2065 7175 616c 7368 6170 6528 612e 7368   equalshape(a.sh
-00026440: 6170 652c 2062 2e73 6861 7065 293a 0a20  ape, b.shape):. 
-00026450: 2020 2020 2020 2072 6574 7572 6e20 612c         return a,
-00026460: 2062 0a20 2020 2072 6169 7365 2056 616c   b.    raise Val
-00026470: 7565 4572 726f 7228 2769 6e63 6f6d 7061  ueError('incompa
-00026480: 7469 626c 6520 7368 6170 6573 3a20 7b7d  tible shapes: {}
-00026490: 2021 3d20 7b7d 272e 666f 726d 6174 282a   != {}'.format(*
-000264a0: 5b74 7570 6c65 2869 6e74 286e 2920 6966  [tuple(int(n) if
-000264b0: 206e 2e69 7363 6f6e 7374 616e 7420 656c   n.isconstant el
-000264c0: 7365 206e 2066 6f72 206e 2069 6e20 6172  se n for n in ar
-000264d0: 672e 7368 6170 6529 2066 6f72 2061 7267  g.shape) for arg
-000264e0: 2069 6e20 2861 2c20 6229 5d29 290a 0a0a   in (a, b)]))...
-000264f0: 6465 6620 5f69 6e66 6c61 7465 5f73 6361  def _inflate_sca
-00026500: 6c61 7228 6172 672c 2073 6861 7065 293a  lar(arg, shape):
-00026510: 0a20 2020 2061 7267 203d 2061 7361 7272  .    arg = asarr
-00026520: 6179 2861 7267 290a 2020 2020 6173 7365  ay(arg).    asse
-00026530: 7274 2061 7267 2e6e 6469 6d20 3d3d 2030  rt arg.ndim == 0
-00026540: 0a20 2020 2066 6f72 2069 6469 6d2c 206c  .    for idim, l
-00026550: 656e 6774 6820 696e 2065 6e75 6d65 7261  ength in enumera
-00026560: 7465 2873 6861 7065 293a 0a20 2020 2020  te(shape):.     
-00026570: 2020 2061 7267 203d 2069 6e73 6572 7461     arg = inserta
-00026580: 7869 7328 6172 672c 2069 6469 6d2c 206c  xis(arg, idim, l
-00026590: 656e 6774 6829 0a20 2020 2072 6574 7572  ength).    retur
-000265a0: 6e20 6172 670a 0a0a 6465 6620 5f69 7375  n arg...def _isu
-000265b0: 6e69 7175 6528 6172 7261 7929 3a0a 2020  nique(array):.  
-000265c0: 2020 7265 7475 726e 206e 756d 7079 2e75    return numpy.u
-000265d0: 6e69 7175 6528 6172 7261 7929 2e73 697a  nique(array).siz
-000265e0: 6520 3d3d 2061 7272 6179 2e73 697a 650a  e == array.size.
-000265f0: 0a0a 6465 6620 5f64 6570 656e 6465 6e63  ..def _dependenc
-00026600: 6965 735f 7361 6e73 5f69 6e76 6172 6961  ies_sans_invaria
-00026610: 6e74 7328 6675 6e63 2c20 6172 6729 3a0a  nts(func, arg):.
-00026620: 2020 2020 696e 7661 7269 616e 7473 203d      invariants =
-00026630: 205b 5d0a 2020 2020 6465 7065 6e64 656e   [].    dependen
-00026640: 6369 6573 203d 205b 5d0a 2020 2020 5f70  cies = [].    _p
-00026650: 6f70 756c 6174 655f 6465 7065 6e64 656e  opulate_dependen
-00026660: 6369 6573 5f73 616e 735f 696e 7661 7269  cies_sans_invari
-00026670: 616e 7473 2866 756e 632c 2061 7267 2c20  ants(func, arg, 
-00026680: 696e 7661 7269 616e 7473 2c20 6465 7065  invariants, depe
-00026690: 6e64 656e 6369 6573 2c20 7b61 7267 7d29  ndencies, {arg})
-000266a0: 0a20 2020 2061 7373 6572 7420 2864 6570  .    assert (dep
-000266b0: 656e 6465 6e63 6965 7320 6f72 2069 6e76  endencies or inv
-000266c0: 6172 6961 6e74 7320 6f72 205b 6172 675d  ariants or [arg]
-000266d0: 295b 2d31 5d20 3d3d 2066 756e 630a 2020  )[-1] == func.  
-000266e0: 2020 7265 7475 726e 2074 7570 6c65 2869    return tuple(i
-000266f0: 6e76 6172 6961 6e74 7329 2c20 7475 706c  nvariants), tupl
-00026700: 6528 6465 7065 6e64 656e 6369 6573 290a  e(dependencies).
-00026710: 0a0a 6465 6620 5f70 6f70 756c 6174 655f  ..def _populate_
-00026720: 6465 7065 6e64 656e 6369 6573 5f73 616e  dependencies_san
-00026730: 735f 696e 7661 7269 616e 7473 2866 756e  s_invariants(fun
-00026740: 632c 2061 7267 2c20 696e 7661 7269 616e  c, arg, invarian
-00026750: 7473 2c20 6465 7065 6e64 656e 6369 6573  ts, dependencies
-00026760: 2c20 6361 6368 6529 3a0a 2020 2020 6966  , cache):.    if
-00026770: 2066 756e 6320 696e 2063 6163 6865 3a0a   func in cache:.
-00026780: 2020 2020 2020 2020 7265 7475 726e 0a20          return. 
-00026790: 2020 2063 6163 6865 2e61 6464 2866 756e     cache.add(fun
-000267a0: 6329 0a20 2020 2069 6620 6172 6720 696e  c).    if arg in
-000267b0: 2066 756e 632e 6172 6775 6d65 6e74 733a   func.arguments:
-000267c0: 0a20 2020 2020 2020 2066 6f72 2063 6869  .        for chi
-000267d0: 6c64 2069 6e20 6675 6e63 2e5f 4576 616c  ld in func._Eval
-000267e0: 7561 626c 655f 5f61 7267 733a 0a20 2020  uable__args:.   
-000267f0: 2020 2020 2020 2020 205f 706f 7075 6c61           _popula
-00026800: 7465 5f64 6570 656e 6465 6e63 6965 735f  te_dependencies_
-00026810: 7361 6e73 5f69 6e76 6172 6961 6e74 7328  sans_invariants(
-00026820: 6368 696c 642c 2061 7267 2c20 696e 7661  child, arg, inva
-00026830: 7269 616e 7473 2c20 6465 7065 6e64 656e  riants, dependen
-00026840: 6369 6573 2c20 6361 6368 6529 0a20 2020  cies, cache).   
-00026850: 2020 2020 2064 6570 656e 6465 6e63 6965       dependencie
-00026860: 732e 6170 7065 6e64 2866 756e 6329 0a20  s.append(func). 
-00026870: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00026880: 2069 6e76 6172 6961 6e74 732e 6170 7065   invariants.appe
-00026890: 6e64 2866 756e 6329 0a0a 0a63 6c61 7373  nd(func)...class
-000268a0: 205f 5374 6174 733a 0a0a 2020 2020 5f5f   _Stats:..    __
-000268b0: 736c 6f74 735f 5f20 3d20 276e 6361 6c6c  slots__ = 'ncall
-000268c0: 7327 2c20 2774 696d 6527 2c20 275f 7374  s', 'time', '_st
-000268d0: 6172 7427 0a0a 2020 2020 6465 6620 5f5f  art'..    def __
-000268e0: 696e 6974 5f5f 2873 656c 662c 206e 6361  init__(self, nca
-000268f0: 6c6c 733a 2069 6e74 203d 2030 2c20 7469  lls: int = 0, ti
-00026900: 6d65 3a20 696e 7420 3d20 3029 202d 3e20  me: int = 0) -> 
-00026910: 4e6f 6e65 3a0a 2020 2020 2020 2020 7365  None:.        se
-00026920: 6c66 2e6e 6361 6c6c 7320 3d20 6e63 616c  lf.ncalls = ncal
-00026930: 6c73 0a20 2020 2020 2020 2073 656c 662e  ls.        self.
-00026940: 7469 6d65 203d 2074 696d 650a 2020 2020  time = time.    
-00026950: 2020 2020 7365 6c66 2e5f 7374 6172 7420      self._start 
-00026960: 3d20 4e6f 6e65 0a0a 2020 2020 6465 6620  = None..    def 
-00026970: 5f5f 7265 7072 5f5f 2873 656c 6629 3a0a  __repr__(self):.
-00026980: 2020 2020 2020 2020 7265 7475 726e 2027          return '
-00026990: 5f53 7461 7473 286e 6361 6c6c 733d 7b7d  _Stats(ncalls={}
-000269a0: 2c20 7469 6d65 3d7b 7d29 272e 666f 726d  , time={})'.form
-000269b0: 6174 2873 656c 662e 6e63 616c 6c73 2c20  at(self.ncalls, 
-000269c0: 7365 6c66 2e74 696d 6529 0a0a 2020 2020  self.time)..    
-000269d0: 6465 6620 5f5f 6164 645f 5f28 7365 6c66  def __add__(self
-000269e0: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
-000269f0: 2020 6966 206e 6f74 2069 7369 6e73 7461    if not isinsta
-00026a00: 6e63 6528 6f74 6865 722c 205f 5374 6174  nce(other, _Stat
-00026a10: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-00026a20: 7265 7475 726e 204e 6f74 496d 706c 656d  return NotImplem
-00026a30: 656e 7465 640a 2020 2020 2020 2020 7265  ented.        re
-00026a40: 7475 726e 205f 5374 6174 7328 7365 6c66  turn _Stats(self
-00026a50: 2e6e 6361 6c6c 732b 6f74 6865 722e 6e63  .ncalls+other.nc
-00026a60: 616c 6c73 2c20 7365 6c66 2e74 696d 652b  alls, self.time+
-00026a70: 6f74 6865 722e 7469 6d65 290a 0a20 2020  other.time)..   
-00026a80: 2064 6566 205f 5f65 6e74 6572 5f5f 2873   def __enter__(s
-00026a90: 656c 6629 202d 3e20 4e6f 6e65 3a0a 2020  elf) -> None:.  
-00026aa0: 2020 2020 2020 7365 6c66 2e5f 7374 6172        self._star
-00026ab0: 7420 3d20 7469 6d65 2e70 6572 665f 636f  t = time.perf_co
-00026ac0: 756e 7465 725f 6e73 2829 0a0a 2020 2020  unter_ns()..    
-00026ad0: 6465 6620 5f5f 6578 6974 5f5f 2873 656c  def __exit__(sel
-00026ae0: 662c 202a 6578 635f 696e 666f 2920 2d3e  f, *exc_info) ->
-00026af0: 204e 6f6e 653a 0a20 2020 2020 2020 2073   None:.        s
-00026b00: 656c 662e 7469 6d65 202b 3d20 7469 6d65  elf.time += time
-00026b10: 2e70 6572 665f 636f 756e 7465 725f 6e73  .perf_counter_ns
-00026b20: 2829 202d 2073 656c 662e 5f73 7461 7274  () - self._start
-00026b30: 0a20 2020 2020 2020 2073 656c 662e 6e63  .        self.nc
-00026b40: 616c 6c73 202b 3d20 310a 0a23 2046 554e  alls += 1..# FUN
-00026b50: 4354 494f 4e53 0a0a 0a64 6566 2069 7361  CTIONS...def isa
-00026b60: 7272 6179 2861 7267 293a 0a20 2020 2072  rray(arg):.    r
-00026b70: 6574 7572 6e20 6973 696e 7374 616e 6365  eturn isinstance
-00026b80: 2861 7267 2c20 4172 7261 7929 0a0a 0a64  (arg, Array)...d
-00026b90: 6566 205f 636f 6e74 6169 6e73 6172 7261  ef _containsarra
-00026ba0: 7928 6172 6729 3a0a 2020 2020 7265 7475  y(arg):.    retu
-00026bb0: 726e 2061 6e79 286d 6170 285f 636f 6e74  rn any(map(_cont
-00026bc0: 6169 6e73 6172 7261 792c 2061 7267 2929  ainsarray, arg))
-00026bd0: 2069 6620 6973 696e 7374 616e 6365 2861   if isinstance(a
-00026be0: 7267 2c20 286c 6973 742c 2074 7570 6c65  rg, (list, tuple
-00026bf0: 2929 2065 6c73 6520 6973 6172 7261 7928  )) else isarray(
-00026c00: 6172 6729 0a0a 0a64 6566 2069 737a 6572  arg)...def iszer
-00026c10: 6f28 6172 6729 3a0a 2020 2020 7265 7475  o(arg):.    retu
-00026c20: 726e 2069 7369 6e73 7461 6e63 6528 6172  rn isinstance(ar
-00026c30: 672e 7369 6d70 6c69 6669 6564 2c20 5a65  g.simplified, Ze
-00026c40: 726f 7329 0a0a 0a64 6566 207a 6572 6f73  ros)...def zeros
-00026c50: 2873 6861 7065 2c20 6474 7970 653d 666c  (shape, dtype=fl
-00026c60: 6f61 7429 3a0a 2020 2020 7265 7475 726e  oat):.    return
-00026c70: 205a 6572 6f73 2873 6861 7065 2c20 6474   Zeros(shape, dt
-00026c80: 7970 6529 0a0a 0a64 6566 207a 6572 6f73  ype)...def zeros
-00026c90: 5f6c 696b 6528 6172 7229 3a0a 2020 2020  _like(arr):.    
-00026ca0: 7265 7475 726e 207a 6572 6f73 2861 7272  return zeros(arr
-00026cb0: 2e73 6861 7065 2c20 6172 722e 6474 7970  .shape, arr.dtyp
-00026cc0: 6529 0a0a 0a64 6566 206f 6e65 7328 7368  e)...def ones(sh
-00026cd0: 6170 652c 2064 7479 7065 3d66 6c6f 6174  ape, dtype=float
-00026ce0: 293a 0a20 2020 2072 6574 7572 6e20 5f69  ):.    return _i
-00026cf0: 6e66 6c61 7465 5f73 6361 6c61 7228 6173  nflate_scalar(as
-00026d00: 7479 7065 286e 756d 7079 2e6f 6e65 7328  type(numpy.ones(
-00026d10: 2829 2c20 6474 7970 653d 696e 7429 2c20  (), dtype=int), 
-00026d20: 6474 7970 6529 2c20 7368 6170 6529 0a0a  dtype), shape)..
-00026d30: 0a64 6566 206f 6e65 735f 6c69 6b65 2861  .def ones_like(a
-00026d40: 7272 293a 0a20 2020 2072 6574 7572 6e20  rr):.    return 
-00026d50: 6f6e 6573 2861 7272 2e73 6861 7065 2c20  ones(arr.shape, 
-00026d60: 6172 722e 6474 7970 6529 0a0a 0a64 6566  arr.dtype)...def
-00026d70: 2072 6563 6970 726f 6361 6c28 6172 6729   reciprocal(arg)
-00026d80: 3a0a 2020 2020 7265 7475 726e 2070 6f77  :.    return pow
-00026d90: 6572 2861 7267 2c20 6173 7479 7065 282d  er(arg, astype(-
-00026da0: 312c 2066 6c6f 6174 2929 0a0a 0a64 6566  1, float))...def
-00026db0: 206e 6567 6174 6976 6528 6172 6729 3a0a   negative(arg):.
-00026dc0: 2020 2020 7265 7475 726e 206d 756c 7469      return multi
-00026dd0: 706c 7928 6172 672c 202d 3129 0a0a 0a64  ply(arg, -1)...d
-00026de0: 6566 2073 696e 2878 293a 0a20 2020 2072  ef sin(x):.    r
-00026df0: 6574 7572 6e20 5369 6e28 7829 0a0a 0a64  eturn Sin(x)...d
-00026e00: 6566 2063 6f73 2878 293a 0a20 2020 2072  ef cos(x):.    r
-00026e10: 6574 7572 6e20 436f 7328 7829 0a0a 0a64  eturn Cos(x)...d
-00026e20: 6566 2074 616e 2878 293a 0a20 2020 2072  ef tan(x):.    r
-00026e30: 6574 7572 6e20 5461 6e28 7829 0a0a 0a64  eturn Tan(x)...d
-00026e40: 6566 2061 7263 7369 6e28 7829 3a0a 2020  ef arcsin(x):.  
-00026e50: 2020 7265 7475 726e 2041 7263 5369 6e28    return ArcSin(
-00026e60: 7829 0a0a 0a64 6566 2061 7263 636f 7328  x)...def arccos(
-00026e70: 7829 3a0a 2020 2020 7265 7475 726e 2041  x):.    return A
-00026e80: 7263 436f 7328 7829 0a0a 0a64 6566 2061  rcCos(x)...def a
-00026e90: 7263 7461 6e28 7829 3a0a 2020 2020 7265  rctan(x):.    re
-00026ea0: 7475 726e 2041 7263 5461 6e28 7829 0a0a  turn ArcTan(x)..
-00026eb0: 0a64 6566 2065 7870 2878 293a 0a20 2020  .def exp(x):.   
-00026ec0: 2072 6574 7572 6e20 4578 7028 7829 0a0a   return Exp(x)..
-00026ed0: 0a64 6566 206c 6e28 7829 3a0a 2020 2020  .def ln(x):.    
-00026ee0: 7265 7475 726e 204c 6f67 2878 290a 0a0a  return Log(x)...
-00026ef0: 6465 6620 6469 766d 6f64 2878 2c20 7929  def divmod(x, y)
-00026f00: 3a0a 2020 2020 6469 7620 3d20 466c 6f6f  :.    div = Floo
-00026f10: 7244 6976 6964 6528 2a5f 6e75 6d70 795f  rDivide(*_numpy_
-00026f20: 616c 6967 6e28 782c 2079 2929 0a20 2020  align(x, y)).   
-00026f30: 206d 6f64 203d 2078 202d 2064 6976 202a   mod = x - div *
-00026f40: 2079 0a20 2020 2072 6574 7572 6e20 6469   y.    return di
-00026f50: 762c 206d 6f64 0a0a 0a64 6566 206d 6f64  v, mod...def mod
-00026f60: 2861 7267 312c 2061 7267 3229 3a0a 2020  (arg1, arg2):.  
-00026f70: 2020 7265 7475 726e 204d 6f64 282a 5f6e    return Mod(*_n
-00026f80: 756d 7079 5f61 6c69 676e 2861 7267 312c  umpy_align(arg1,
-00026f90: 2061 7267 3229 290a 0a0a 6465 6620 6c6f   arg2))...def lo
-00026fa0: 6732 2861 7267 293a 0a20 2020 2072 6574  g2(arg):.    ret
-00026fb0: 7572 6e20 6c6e 2861 7267 2920 2f20 6c6e  urn ln(arg) / ln
-00026fc0: 2832 290a 0a0a 6465 6620 6c6f 6731 3028  (2)...def log10(
-00026fd0: 6172 6729 3a0a 2020 2020 7265 7475 726e  arg):.    return
-00026fe0: 206c 6e28 6172 6729 202f 206c 6e28 3130   ln(arg) / ln(10
-00026ff0: 290a 0a0a 6465 6620 7371 7274 2861 7267  )...def sqrt(arg
-00027000: 293a 0a20 2020 2072 6574 7572 6e20 706f  ):.    return po
-00027010: 7765 7228 6172 672c 202e 3529 0a0a 0a64  wer(arg, .5)...d
-00027020: 6566 2061 7263 7461 6e32 2861 7267 312c  ef arctan2(arg1,
-00027030: 2061 7267 3229 3a0a 2020 2020 7265 7475   arg2):.    retu
-00027040: 726e 2041 7263 5461 6e32 282a 5f6e 756d  rn ArcTan2(*_num
-00027050: 7079 5f61 6c69 676e 2861 7267 312c 2061  py_align(arg1, a
-00027060: 7267 3229 290a 0a0a 6465 6620 6162 7328  rg2))...def abs(
-00027070: 6172 6729 3a0a 2020 2020 6966 2061 7267  arg):.    if arg
-00027080: 2e64 7479 7065 203d 3d20 636f 6d70 6c65  .dtype == comple
-00027090: 783a 0a20 2020 2020 2020 2072 6574 7572  x:.        retur
-000270a0: 6e20 7371 7274 2861 7267 2e72 6561 6c2a  n sqrt(arg.real*
-000270b0: 2a32 202b 2061 7267 2e69 6d61 672a 2a32  *2 + arg.imag**2
-000270c0: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
-000270d0: 2020 2020 7265 7475 726e 2061 7267 202a      return arg *
-000270e0: 2073 6967 6e28 6172 6729 0a0a 0a64 6566   sign(arg)...def
-000270f0: 2073 696e 6828 6172 6729 3a0a 2020 2020   sinh(arg):.    
-00027100: 7265 7475 726e 2053 696e 4828 6172 6729  return SinH(arg)
-00027110: 0a0a 0a64 6566 2063 6f73 6828 6172 6729  ...def cosh(arg)
-00027120: 3a0a 2020 2020 7265 7475 726e 2043 6f73  :.    return Cos
-00027130: 4828 6172 6729 0a0a 0a64 6566 2074 616e  H(arg)...def tan
-00027140: 6828 6172 6729 3a0a 2020 2020 7265 7475  h(arg):.    retu
-00027150: 726e 2054 616e 4828 6172 6729 0a0a 0a64  rn TanH(arg)...d
-00027160: 6566 2061 7263 7461 6e68 2861 7267 293a  ef arctanh(arg):
-00027170: 0a20 2020 2072 6574 7572 6e20 4172 6354  .    return ArcT
-00027180: 616e 4828 6172 6729 0a0a 0a64 6566 2064  anH(arg)...def d
-00027190: 6976 6964 6528 6172 6731 2c20 6172 6732  ivide(arg1, arg2
-000271a0: 293a 0a20 2020 2072 6574 7572 6e20 6d75  ):.    return mu
-000271b0: 6c74 6970 6c79 2861 7267 312c 2072 6563  ltiply(arg1, rec
-000271c0: 6970 726f 6361 6c28 6172 6732 2929 0a0a  iprocal(arg2))..
-000271d0: 0a64 6566 2073 7562 7472 6163 7428 6172  .def subtract(ar
-000271e0: 6731 2c20 6172 6732 293a 0a20 2020 2072  g1, arg2):.    r
-000271f0: 6574 7572 6e20 6164 6428 6172 6731 2c20  eturn add(arg1, 
-00027200: 6e65 6761 7469 7665 2861 7267 3229 290a  negative(arg2)).
-00027210: 0a0a 6465 6620 696e 7365 7274 6178 6973  ..def insertaxis
-00027220: 2861 7267 2c20 6e2c 206c 656e 6774 6829  (arg, n, length)
-00027230: 3a0a 2020 2020 7265 7475 726e 2054 7261  :.    return Tra
-00027240: 6e73 706f 7365 2e66 726f 6d5f 656e 6428  nspose.from_end(
-00027250: 496e 7365 7274 4178 6973 2861 7267 2c20  InsertAxis(arg, 
-00027260: 6c65 6e67 7468 292c 206e 290a 0a0a 6465  length), n)...de
-00027270: 6620 636f 6e63 6174 656e 6174 6528 6172  f concatenate(ar
-00027280: 6773 2c20 6178 6973 3d30 293a 0a20 2020  gs, axis=0):.   
-00027290: 206c 656e 6774 6873 203d 205b 6172 672e   lengths = [arg.
-000272a0: 7368 6170 655b 6178 6973 5d20 666f 7220  shape[axis] for 
-000272b0: 6172 6720 696e 2061 7267 735d 0a20 2020  arg in args].   
-000272c0: 202a 6f66 6673 6574 732c 2074 6f74 6c65   *offsets, totle
-000272d0: 6e67 7468 203d 2075 7469 6c2e 6375 6d73  ngth = util.cums
-000272e0: 756d 286c 656e 6774 6873 202b 205b 305d  um(lengths + [0]
-000272f0: 290a 2020 2020 7265 7475 726e 2054 7261  ).    return Tra
-00027300: 6e73 706f 7365 2e66 726f 6d5f 656e 6428  nspose.from_end(
-00027310: 7574 696c 2e73 756d 2849 6e66 6c61 7465  util.sum(Inflate
-00027320: 2854 7261 6e73 706f 7365 2e74 6f5f 656e  (Transpose.to_en
-00027330: 6428 6172 672c 2061 7869 7329 2c20 5261  d(arg, axis), Ra
-00027340: 6e67 6528 6c65 6e67 7468 2920 2b20 6f66  nge(length) + of
-00027350: 6673 6574 2c20 746f 746c 656e 6774 6829  fset, totlength)
-00027360: 2066 6f72 2061 7267 2c20 6c65 6e67 7468   for arg, length
-00027370: 2c20 6f66 6673 6574 2069 6e20 7a69 7028  , offset in zip(
-00027380: 6172 6773 2c20 6c65 6e67 7468 732c 206f  args, lengths, o
-00027390: 6666 7365 7473 2929 2c20 6178 6973 290a  ffsets)), axis).
-000273a0: 0a0a 6465 6620 7374 6163 6b28 6172 6773  ..def stack(args
-000273b0: 2c20 6178 6973 3d30 293a 0a20 2020 2072  , axis=0):.    r
-000273c0: 6574 7572 6e20 5472 616e 7370 6f73 652e  eturn Transpose.
-000273d0: 6672 6f6d 5f65 6e64 2875 7469 6c2e 7375  from_end(util.su
-000273e0: 6d28 496e 666c 6174 6528 6172 672c 2069  m(Inflate(arg, i
-000273f0: 2c20 6c65 6e28 6172 6773 2929 2066 6f72  , len(args)) for
-00027400: 2069 2c20 6172 6720 696e 2065 6e75 6d65   i, arg in enume
-00027410: 7261 7465 2861 7267 7329 292c 2061 7869  rate(args)), axi
-00027420: 7329 0a0a 0a64 6566 2072 6570 6561 7428  s)...def repeat(
-00027430: 6172 672c 206c 656e 6774 682c 2061 7869  arg, length, axi
-00027440: 7329 3a0a 2020 2020 6172 6720 3d20 6173  s):.    arg = as
-00027450: 6172 7261 7928 6172 6729 0a20 2020 2061  array(arg).    a
-00027460: 7373 6572 7420 6571 7561 6c69 6e64 6578  ssert equalindex
-00027470: 2861 7267 2e73 6861 7065 5b61 7869 735d  (arg.shape[axis]
-00027480: 2c20 3129 0a20 2020 2072 6574 7572 6e20  , 1).    return 
-00027490: 696e 7365 7274 6178 6973 2867 6574 2861  insertaxis(get(a
-000274a0: 7267 2c20 6178 6973 2c20 3029 2c20 6178  rg, axis, 0), ax
-000274b0: 6973 2c20 6c65 6e67 7468 290a 0a0a 6465  is, length)...de
-000274c0: 6620 6765 7428 6172 672c 2069 6178 2c20  f get(arg, iax, 
-000274d0: 6974 656d 293a 0a20 2020 2069 6620 6e75  item):.    if nu
-000274e0: 6d65 7269 632e 6973 696e 7428 6974 656d  meric.isint(item
-000274f0: 293a 0a20 2020 2020 2020 2069 6620 6e75  ):.        if nu
-00027500: 6d65 7269 632e 6973 696e 7428 6172 672e  meric.isint(arg.
-00027510: 7368 6170 655b 6961 785d 293a 0a20 2020  shape[iax]):.   
-00027520: 2020 2020 2020 2020 2069 7465 6d20 3d20           item = 
-00027530: 6e75 6d65 7269 632e 6e6f 726d 6469 6d28  numeric.normdim(
-00027540: 6172 672e 7368 6170 655b 6961 785d 2c20  arg.shape[iax], 
-00027550: 6974 656d 290a 2020 2020 2020 2020 656c  item).        el
-00027560: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00027570: 6173 7365 7274 2069 7465 6d20 3e3d 2030  assert item >= 0
-00027580: 0a20 2020 2072 6574 7572 6e20 5461 6b65  .    return Take
-00027590: 2854 7261 6e73 706f 7365 2e74 6f5f 656e  (Transpose.to_en
-000275a0: 6428 6172 672c 2069 6178 292c 2069 7465  d(arg, iax), ite
-000275b0: 6d29 0a0a 0a64 6566 2064 6574 6572 6d69  m)...def determi
-000275c0: 6e61 6e74 2861 7267 2c20 6178 6573 3d28  nant(arg, axes=(
-000275d0: 2d32 2c20 2d31 2929 3a0a 2020 2020 7265  -2, -1)):.    re
-000275e0: 7475 726e 2044 6574 6572 6d69 6e61 6e74  turn Determinant
-000275f0: 2854 7261 6e73 706f 7365 2e74 6f5f 656e  (Transpose.to_en
-00027600: 6428 6172 672c 202a 6178 6573 2929 0a0a  d(arg, *axes))..
-00027610: 0a64 6566 2067 7261 6d6d 6975 6d28 6172  .def grammium(ar
-00027620: 672c 2061 7865 733d 282d 322c 202d 3129  g, axes=(-2, -1)
-00027630: 293a 0a20 2020 2061 7267 203d 2054 7261  ):.    arg = Tra
-00027640: 6e73 706f 7365 2e74 6f5f 656e 6428 6172  nspose.to_end(ar
-00027650: 672c 202a 6178 6573 290a 2020 2020 6772  g, *axes).    gr
-00027660: 616d 6d69 756d 203d 2065 696e 7375 6d28  ammium = einsum(
-00027670: 2741 6b69 2c41 6b6a 2d3e 4169 6a27 2c20  'Aki,Akj->Aij', 
-00027680: 6172 672c 2061 7267 290a 2020 2020 7265  arg, arg).    re
-00027690: 7475 726e 2054 7261 6e73 706f 7365 2e66  turn Transpose.f
-000276a0: 726f 6d5f 656e 6428 6772 616d 6d69 756d  rom_end(grammium
-000276b0: 2c20 2a61 7865 7329 0a0a 0a64 6566 2073  , *axes)...def s
-000276c0: 7172 745f 6162 735f 6465 745f 6772 616d  qrt_abs_det_gram
-000276d0: 2861 7267 2c20 6178 6573 3d28 2d32 2c20  (arg, axes=(-2, 
-000276e0: 2d31 2929 3a0a 2020 2020 6172 6720 3d20  -1)):.    arg = 
-000276f0: 5472 616e 7370 6f73 652e 746f 5f65 6e64  Transpose.to_end
-00027700: 2861 7267 2c20 2a61 7865 7329 0a20 2020  (arg, *axes).   
-00027710: 2069 6620 6571 7561 6c69 6e64 6578 2861   if equalindex(a
-00027720: 7267 2e73 6861 7065 5b2d 315d 2c20 6172  rg.shape[-1], ar
-00027730: 672e 7368 6170 655b 2d32 5d29 3a0a 2020  g.shape[-2]):.  
-00027740: 2020 2020 2020 7265 7475 726e 2061 6273        return abs
-00027750: 2844 6574 6572 6d69 6e61 6e74 2861 7267  (Determinant(arg
-00027760: 2929 0a20 2020 2065 6c73 653a 0a20 2020  )).    else:.   
-00027770: 2020 2020 2072 6574 7572 6e20 7371 7274       return sqrt
-00027780: 2861 6273 2844 6574 6572 6d69 6e61 6e74  (abs(Determinant
-00027790: 2867 7261 6d6d 6975 6d28 6172 6729 2929  (grammium(arg)))
-000277a0: 290a 0a0a 6465 6620 696e 7665 7273 6528  )...def inverse(
-000277b0: 6172 672c 2061 7865 733d 282d 322c 202d  arg, axes=(-2, -
-000277c0: 3129 293a 0a20 2020 2072 6574 7572 6e20  1)):.    return 
-000277d0: 5472 616e 7370 6f73 652e 6672 6f6d 5f65  Transpose.from_e
-000277e0: 6e64 2849 6e76 6572 7365 2854 7261 6e73  nd(Inverse(Trans
-000277f0: 706f 7365 2e74 6f5f 656e 6428 6172 672c  pose.to_end(arg,
-00027800: 202a 6178 6573 2929 2c20 2a61 7865 7329   *axes)), *axes)
-00027810: 0a0a 0a64 6566 2074 616b 6564 6961 6728  ...def takediag(
-00027820: 6172 672c 2061 7869 733d 2d32 2c20 726d  arg, axis=-2, rm
-00027830: 6178 6973 3d2d 3129 3a0a 2020 2020 6172  axis=-1):.    ar
-00027840: 6720 3d20 6173 6172 7261 7928 6172 6729  g = asarray(arg)
-00027850: 0a20 2020 2061 7869 7320 3d20 6e75 6d65  .    axis = nume
-00027860: 7269 632e 6e6f 726d 6469 6d28 6172 672e  ric.normdim(arg.
-00027870: 6e64 696d 2c20 6178 6973 290a 2020 2020  ndim, axis).    
-00027880: 726d 6178 6973 203d 206e 756d 6572 6963  rmaxis = numeric
-00027890: 2e6e 6f72 6d64 696d 2861 7267 2e6e 6469  .normdim(arg.ndi
-000278a0: 6d2c 2072 6d61 7869 7329 0a20 2020 2061  m, rmaxis).    a
-000278b0: 7373 6572 7420 6178 6973 203c 2072 6d61  ssert axis < rma
-000278c0: 7869 730a 2020 2020 7265 7475 726e 2054  xis.    return T
-000278d0: 7261 6e73 706f 7365 2e66 726f 6d5f 656e  ranspose.from_en
-000278e0: 6428 5f74 616b 6564 6961 6728 6172 672c  d(_takediag(arg,
-000278f0: 2061 7869 732c 2072 6d61 7869 7329 2c20   axis, rmaxis), 
-00027900: 6178 6973 290a 0a0a 6465 6620 5f74 616b  axis)...def _tak
-00027910: 6564 6961 6728 6172 672c 2061 7869 7331  ediag(arg, axis1
-00027920: 3d2d 322c 2061 7869 7332 3d2d 3129 3a0a  =-2, axis2=-1):.
-00027930: 2020 2020 7265 7475 726e 2054 616b 6544      return TakeD
-00027940: 6961 6728 5472 616e 7370 6f73 652e 746f  iag(Transpose.to
-00027950: 5f65 6e64 2861 7267 2c20 6178 6973 312c  _end(arg, axis1,
-00027960: 2061 7869 7332 2929 0a0a 0a64 6566 2064   axis2))...def d
-00027970: 6572 6976 6174 6976 6528 6675 6e63 2c20  erivative(func, 
-00027980: 7661 722c 2073 6565 6e3d 4e6f 6e65 293a  var, seen=None):
-00027990: 0a20 2020 2027 6465 7269 7661 7469 7665  .    'derivative
-000279a0: 270a 0a20 2020 2061 7373 6572 7420 6973  '..    assert is
-000279b0: 696e 7374 616e 6365 2876 6172 2c20 4465  instance(var, De
-000279c0: 7269 7661 7469 7665 5461 7267 6574 4261  rivativeTargetBa
-000279d0: 7365 292c 2027 696e 7661 6c69 6420 6465  se), 'invalid de
-000279e0: 7269 7661 7469 7665 2074 6172 6765 7420  rivative target 
-000279f0: 7b21 727d 272e 666f 726d 6174 2876 6172  {!r}'.format(var
-00027a00: 290a 2020 2020 6966 2076 6172 2e64 7479  ).    if var.dty
-00027a10: 7065 2069 6e20 2862 6f6f 6c2c 2069 6e74  pe in (bool, int
-00027a20: 2920 6f72 2076 6172 206e 6f74 2069 6e20  ) or var not in 
-00027a30: 6675 6e63 2e61 7267 756d 656e 7473 3a0a  func.arguments:.
-00027a40: 2020 2020 2020 2020 7265 7475 726e 205a          return Z
-00027a50: 6572 6f73 2866 756e 632e 7368 6170 6520  eros(func.shape 
-00027a60: 2b20 7661 722e 7368 6170 652c 2064 7479  + var.shape, dty
-00027a70: 7065 3d66 756e 632e 6474 7970 6529 0a20  pe=func.dtype). 
-00027a80: 2020 2069 6620 7365 656e 2069 7320 4e6f     if seen is No
-00027a90: 6e65 3a0a 2020 2020 2020 2020 7365 656e  ne:.        seen
-00027aa0: 203d 207b 7d0a 2020 2020 6966 2066 756e   = {}.    if fun
-00027ab0: 6320 696e 2073 6565 6e3a 0a20 2020 2020  c in seen:.     
-00027ac0: 2020 2072 6573 756c 7420 3d20 7365 656e     result = seen
-00027ad0: 5b66 756e 635d 0a20 2020 2065 6c73 653a  [func].    else:
-00027ae0: 0a20 2020 2020 2020 2072 6573 756c 7420  .        result 
-00027af0: 3d20 6675 6e63 2e5f 6465 7269 7661 7469  = func._derivati
-00027b00: 7665 2876 6172 2c20 7365 656e 290a 2020  ve(var, seen).  
-00027b10: 2020 2020 2020 7365 656e 5b66 756e 635d        seen[func]
-00027b20: 203d 2072 6573 756c 740a 2020 2020 6173   = result.    as
-00027b30: 7365 7274 2065 7175 616c 7368 6170 6528  sert equalshape(
-00027b40: 7265 7375 6c74 2e73 6861 7065 2c20 6675  result.shape, fu
-00027b50: 6e63 2e73 6861 7065 2b76 6172 2e73 6861  nc.shape+var.sha
-00027b60: 7065 2920 616e 6420 7265 7375 6c74 2e64  pe) and result.d
-00027b70: 7479 7065 203d 3d20 6675 6e63 2e64 7479  type == func.dty
-00027b80: 7065 2c20 2762 7567 2069 6e20 7b7d 2e5f  pe, 'bug in {}._
-00027b90: 6465 7269 7661 7469 7665 272e 666f 726d  derivative'.form
-00027ba0: 6174 2874 7970 6528 6675 6e63 292e 5f5f  at(type(func).__
-00027bb0: 6e61 6d65 5f5f 290a 2020 2020 7265 7475  name__).    retu
-00027bc0: 726e 2072 6573 756c 740a 0a0a 6465 6620  rn result...def 
-00027bd0: 6469 6167 6f6e 616c 697a 6528 6172 672c  diagonalize(arg,
-00027be0: 2061 7869 733d 2d31 2c20 6e65 7761 7869   axis=-1, newaxi
-00027bf0: 733d 2d31 293a 0a20 2020 2061 7267 203d  s=-1):.    arg =
-00027c00: 2061 7361 7272 6179 2861 7267 290a 2020   asarray(arg).  
-00027c10: 2020 6178 6973 203d 206e 756d 6572 6963    axis = numeric
-00027c20: 2e6e 6f72 6d64 696d 2861 7267 2e6e 6469  .normdim(arg.ndi
-00027c30: 6d2c 2061 7869 7329 0a20 2020 206e 6577  m, axis).    new
-00027c40: 6178 6973 203d 206e 756d 6572 6963 2e6e  axis = numeric.n
-00027c50: 6f72 6d64 696d 2861 7267 2e6e 6469 6d2b  ormdim(arg.ndim+
-00027c60: 312c 206e 6577 6178 6973 290a 2020 2020  1, newaxis).    
-00027c70: 6173 7365 7274 2061 7869 7320 3c20 6e65  assert axis < ne
-00027c80: 7761 7869 730a 2020 2020 7265 7475 726e  waxis.    return
-00027c90: 2054 7261 6e73 706f 7365 2e66 726f 6d5f   Transpose.from_
-00027ca0: 656e 6428 4469 6167 6f6e 616c 697a 6528  end(Diagonalize(
-00027cb0: 5472 616e 7370 6f73 652e 746f 5f65 6e64  Transpose.to_end
-00027cc0: 2861 7267 2c20 6178 6973 2929 2c20 6178  (arg, axis)), ax
-00027cd0: 6973 2c20 6e65 7761 7869 7329 0a0a 0a64  is, newaxis)...d
-00027ce0: 6566 2073 6967 6e28 6172 6729 3a0a 2020  ef sign(arg):.  
-00027cf0: 2020 6172 6720 3d20 6173 6172 7261 7928    arg = asarray(
-00027d00: 6172 6729 0a20 2020 2069 6620 6172 672e  arg).    if arg.
-00027d10: 6474 7970 6520 3d3d 2063 6f6d 706c 6578  dtype == complex
-00027d20: 3a0a 2020 2020 2020 2020 7261 6973 6520  :.        raise 
-00027d30: 5661 6c75 6545 7272 6f72 2827 7369 676e  ValueError('sign
-00027d40: 2069 7320 6e6f 7420 6465 6669 6e65 6420   is not defined 
-00027d50: 666f 7220 636f 6d70 6c65 7820 6e75 6d62  for complex numb
-00027d60: 6572 7327 290a 2020 2020 7265 7475 726e  ers').    return
-00027d70: 2053 6967 6e28 6172 6729 0a0a 0a64 6566   Sign(arg)...def
-00027d80: 2065 6967 2861 7267 2c20 6178 6573 3d28   eig(arg, axes=(
-00027d90: 2d32 2c20 2d31 292c 2073 796d 6d65 7472  -2, -1), symmetr
-00027da0: 6963 3d46 616c 7365 293a 0a20 2020 2065  ic=False):.    e
-00027db0: 6967 7661 6c2c 2065 6967 7665 6320 3d20  igval, eigvec = 
-00027dc0: 4569 6728 5472 616e 7370 6f73 652e 746f  Eig(Transpose.to
-00027dd0: 5f65 6e64 2861 7267 2c20 2a61 7865 7329  _end(arg, *axes)
-00027de0: 2c20 7379 6d6d 6574 7269 6329 0a20 2020  , symmetric).   
-00027df0: 2072 6574 7572 6e20 5475 706c 6528 5472   return Tuple(Tr
-00027e00: 616e 7370 6f73 652e 6672 6f6d 5f65 6e64  anspose.from_end
-00027e10: 2876 2c20 2a61 7865 7329 2066 6f72 2076  (v, *axes) for v
-00027e20: 2069 6e20 5b64 6961 676f 6e61 6c69 7a65   in [diagonalize
-00027e30: 2865 6967 7661 6c29 2c20 6569 6776 6563  (eigval), eigvec
-00027e40: 5d29 0a0a 0a40 7479 7065 732e 6170 706c  ])...@types.appl
-00027e50: 795f 616e 6e6f 7461 7469 6f6e 730a 6465  y_annotations.de
-00027e60: 6620 5f74 616b 6573 6c69 6365 2861 7267  f _takeslice(arg
-00027e70: 3a20 6173 6172 7261 792c 2073 3a20 7479  : asarray, s: ty
-00027e80: 7065 732e 7374 7269 6374 5b73 6c69 6365  pes.strict[slice
-00027e90: 5d2c 2061 7869 733a 2074 7970 6573 2e73  ], axis: types.s
-00027ea0: 7472 6963 7469 6e74 293a 0a20 2020 206e  trictint):.    n
-00027eb0: 203d 2061 7267 2e73 6861 7065 5b61 7869   = arg.shape[axi
-00027ec0: 735d 0a20 2020 2069 6620 732e 7374 6570  s].    if s.step
-00027ed0: 203d 3d20 4e6f 6e65 206f 7220 732e 7374   == None or s.st
-00027ee0: 6570 203d 3d20 313a 0a20 2020 2020 2020  ep == 1:.       
-00027ef0: 2073 7461 7274 203d 2030 2069 6620 732e   start = 0 if s.
-00027f00: 7374 6172 7420 6973 204e 6f6e 6520 656c  start is None el
-00027f10: 7365 2073 2e73 7461 7274 2069 6620 732e  se s.start if s.
-00027f20: 7374 6172 7420 3e3d 2030 2065 6c73 6520  start >= 0 else 
-00027f30: 732e 7374 6172 7420 2b20 6e0a 2020 2020  s.start + n.    
-00027f40: 2020 2020 7374 6f70 203d 206e 2069 6620      stop = n if 
-00027f50: 732e 7374 6f70 2069 7320 4e6f 6e65 2065  s.stop is None e
-00027f60: 6c73 6520 732e 7374 6f70 2069 6620 732e  lse s.stop if s.
-00027f70: 7374 6f70 203e 3d20 3020 656c 7365 2073  stop >= 0 else s
-00027f80: 2e73 746f 7020 2b20 6e0a 2020 2020 2020  .stop + n.      
-00027f90: 2020 6966 2073 7461 7274 203d 3d20 3020    if start == 0 
-00027fa0: 616e 6420 7374 6f70 203d 3d20 6e3a 0a20  and stop == n:. 
-00027fb0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00027fc0: 6e20 6172 670a 2020 2020 2020 2020 696e  n arg.        in
-00027fd0: 6465 7820 3d20 5261 6e67 6528 7374 6f70  dex = Range(stop
-00027fe0: 2d73 7461 7274 2920 2b20 7374 6172 740a  -start) + start.
-00027ff0: 2020 2020 656c 6966 206e 2e69 7363 6f6e      elif n.iscon
-00028000: 7374 616e 743a 0a20 2020 2020 2020 2069  stant:.        i
-00028010: 6e64 6578 203d 2043 6f6e 7374 616e 7428  ndex = Constant(
-00028020: 6e75 6d70 792e 6172 616e 6765 282a 732e  numpy.arange(*s.
-00028030: 696e 6469 6365 7328 6172 672e 7368 6170  indices(arg.shap
-00028040: 655b 6178 6973 5d29 2929 0a20 2020 2065  e[axis]))).    e
-00028050: 6c73 653a 0a20 2020 2020 2020 2072 6169  lse:.        rai
-00028060: 7365 2045 7863 6570 7469 6f6e 2827 6120  se Exception('a 
-00028070: 6e6f 6e2d 756e 6974 2073 6c69 6365 2072  non-unit slice r
-00028080: 6571 7569 7265 7320 6120 636f 6e73 7461  equires a consta
-00028090: 6e74 2d6c 656e 6774 6820 6178 6973 2729  nt-length axis')
-000280a0: 0a20 2020 2072 6574 7572 6e20 7461 6b65  .    return take
-000280b0: 2861 7267 2c20 696e 6465 782c 2061 7869  (arg, index, axi
-000280c0: 7329 0a0a 0a40 7479 7065 732e 6170 706c  s)...@types.appl
-000280d0: 795f 616e 6e6f 7461 7469 6f6e 730a 6465  y_annotations.de
-000280e0: 6620 7461 6b65 2861 7267 3a20 6173 6172  f take(arg: asar
-000280f0: 7261 792c 2069 6e64 6578 3a20 6173 6172  ray, index: asar
-00028100: 7261 792c 2061 7869 733a 2074 7970 6573  ray, axis: types
-00028110: 2e73 7472 6963 7469 6e74 293a 0a20 2020  .strictint):.   
-00028120: 2061 7373 6572 7420 696e 6465 782e 6e64   assert index.nd
-00028130: 696d 203d 3d20 310a 2020 2020 6c65 6e67  im == 1.    leng
-00028140: 7468 203d 2061 7267 2e73 6861 7065 5b61  th = arg.shape[a
-00028150: 7869 735d 0a20 2020 2069 6620 696e 6465  xis].    if inde
-00028160: 782e 6474 7970 6520 3d3d 2062 6f6f 6c3a  x.dtype == bool:
-00028170: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
-00028180: 6571 7561 6c69 6e64 6578 2869 6e64 6578  equalindex(index
-00028190: 2e73 6861 7065 5b30 5d2c 206c 656e 6774  .shape[0], lengt
-000281a0: 6829 0a20 2020 2020 2020 2069 6e64 6578  h).        index
-000281b0: 203d 2046 696e 6428 696e 6465 7829 0a20   = Find(index). 
-000281c0: 2020 2065 6c69 6620 696e 6465 782e 6973     elif index.is
-000281d0: 636f 6e73 7461 6e74 3a0a 2020 2020 2020  constant:.      
-000281e0: 2020 696e 6465 785f 203d 2069 6e64 6578    index_ = index
-000281f0: 2e65 7661 6c28 290a 2020 2020 2020 2020  .eval().        
-00028200: 696e 6567 203d 206e 756d 7079 2e6c 6573  ineg = numpy.les
-00028210: 7328 696e 6465 785f 2c20 3029 0a20 2020  s(index_, 0).   
-00028220: 2020 2020 2069 6620 6e6f 7420 6c65 6e67       if not leng
-00028230: 7468 2e69 7363 6f6e 7374 616e 743a 0a20  th.isconstant:. 
-00028240: 2020 2020 2020 2020 2020 2069 6620 696e             if in
-00028250: 6567 2e61 6e79 2829 3a0a 2020 2020 2020  eg.any():.      
-00028260: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00028270: 496e 6465 7845 7272 6f72 2827 6e65 6761  IndexError('nega
-00028280: 7469 7665 2069 6e64 6963 6573 206f 6e6c  tive indices onl
-00028290: 7920 616c 6c6f 7765 6420 666f 7220 636f  y allowed for co
-000282a0: 6e73 7461 6e74 2d6c 656e 6774 6820 6178  nstant-length ax
-000282b0: 6573 2729 0a20 2020 2020 2020 2065 6c69  es').        eli
-000282c0: 6620 696e 6567 2e61 6e79 2829 3a0a 2020  f ineg.any():.  
-000282d0: 2020 2020 2020 2020 2020 6966 206e 756d            if num
-000282e0: 7079 2e6c 6573 7328 696e 6465 785f 2c20  py.less(index_, 
-000282f0: 2d69 6e74 286c 656e 6774 6829 292e 616e  -int(length)).an
-00028300: 7928 293a 0a20 2020 2020 2020 2020 2020  y():.           
-00028310: 2020 2020 2072 6169 7365 2049 6e64 6578       raise Index
-00028320: 4572 726f 7228 2769 6e64 6963 6573 206f  Error('indices o
-00028330: 7574 206f 6620 626f 756e 6473 3a20 7b7d  ut of bounds: {}
-00028340: 203c 207b 7d27 2e66 6f72 6d61 7428 696e   < {}'.format(in
-00028350: 6465 785f 2c20 2d69 6e74 286c 656e 6774  dex_, -int(lengt
-00028360: 6829 2929 0a20 2020 2020 2020 2020 2020  h))).           
-00028370: 2072 6574 7572 6e20 5f74 616b 6528 6172   return _take(ar
-00028380: 672c 2043 6f6e 7374 616e 7428 696e 6465  g, Constant(inde
-00028390: 785f 202b 2069 6e65 6720 2a20 696e 7428  x_ + ineg * int(
-000283a0: 6c65 6e67 7468 2929 2c20 6178 6973 290a  length)), axis).
-000283b0: 2020 2020 2020 2020 656c 6966 206e 756d          elif num
-000283c0: 7079 2e67 7265 6174 6572 5f65 7175 616c  py.greater_equal
-000283d0: 2869 6e64 6578 5f2c 2069 6e74 286c 656e  (index_, int(len
-000283e0: 6774 6829 292e 616e 7928 293a 0a20 2020  gth)).any():.   
-000283f0: 2020 2020 2020 2020 2072 6169 7365 2049           raise I
-00028400: 6e64 6578 4572 726f 7228 2769 6e64 6963  ndexError('indic
-00028410: 6573 206f 7574 206f 6620 626f 756e 6473  es out of bounds
-00028420: 3a20 7b7d 203e 3d20 7b7d 272e 666f 726d  : {} >= {}'.form
-00028430: 6174 2869 6e64 6578 5f2c 2069 6e74 286c  at(index_, int(l
-00028440: 656e 6774 6829 2929 0a20 2020 2020 2020  ength))).       
-00028450: 2065 6c69 6620 6e75 6d70 792e 6772 6561   elif numpy.grea
-00028460: 7465 7228 6e75 6d70 792e 6469 6666 2869  ter(numpy.diff(i
-00028470: 6e64 6578 5f29 2c20 3029 2e61 6c6c 2829  ndex_), 0).all()
-00028480: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00028490: 7475 726e 206d 6173 6b28 6172 672c 206e  turn mask(arg, n
-000284a0: 756d 6572 6963 2e61 7362 6f6f 6c65 616e  umeric.asboolean
-000284b0: 2869 6e64 6578 5f2c 2069 6e74 286c 656e  (index_, int(len
-000284c0: 6774 6829 292c 2061 7869 7329 0a20 2020  gth)), axis).   
-000284d0: 2072 6574 7572 6e20 5f74 616b 6528 6172   return _take(ar
-000284e0: 672c 2069 6e64 6578 2c20 6178 6973 290a  g, index, axis).
-000284f0: 0a0a 4074 7970 6573 2e61 7070 6c79 5f61  ..@types.apply_a
-00028500: 6e6e 6f74 6174 696f 6e73 0a64 6566 205f  nnotations.def _
-00028510: 7461 6b65 2861 7267 3a20 6173 6172 7261  take(arg: asarra
-00028520: 792c 2069 6e64 6578 3a20 6173 6172 7261  y, index: asarra
-00028530: 792c 2061 7869 733a 2074 7970 6573 2e73  y, axis: types.s
-00028540: 7472 6963 7469 6e74 293a 0a20 2020 2061  trictint):.    a
-00028550: 7869 7320 3d20 6e75 6d65 7269 632e 6e6f  xis = numeric.no
-00028560: 726d 6469 6d28 6172 672e 6e64 696d 2c20  rmdim(arg.ndim, 
-00028570: 6178 6973 290a 2020 2020 7265 7475 726e  axis).    return
-00028580: 2054 7261 6e73 706f 7365 2e66 726f 6d5f   Transpose.from_
-00028590: 656e 6428 5461 6b65 2854 7261 6e73 706f  end(Take(Transpo
-000285a0: 7365 2e74 6f5f 656e 6428 6172 672c 2061  se.to_end(arg, a
-000285b0: 7869 7329 2c20 696e 6465 7829 2c20 2a72  xis), index), *r
-000285c0: 616e 6765 2861 7869 732c 2061 7869 732b  ange(axis, axis+
-000285d0: 696e 6465 782e 6e64 696d 2929 0a0a 0a40  index.ndim))...@
-000285e0: 7479 7065 732e 6170 706c 795f 616e 6e6f  types.apply_anno
-000285f0: 7461 7469 6f6e 730a 6465 6620 5f69 6e66  tations.def _inf
-00028600: 6c61 7465 2861 7267 3a20 6173 6172 7261  late(arg: asarra
-00028610: 792c 2064 6f66 6d61 703a 2061 7361 7272  y, dofmap: asarr
-00028620: 6179 2c20 6c65 6e67 7468 3a20 6173 696e  ay, length: asin
-00028630: 6465 782c 2061 7869 733a 2074 7970 6573  dex, axis: types
-00028640: 2e73 7472 6963 7469 6e74 293a 0a20 2020  .strictint):.   
-00028650: 2061 7869 7320 3d20 6e75 6d65 7269 632e   axis = numeric.
-00028660: 6e6f 726d 6469 6d28 6172 672e 6e64 696d  normdim(arg.ndim
-00028670: 2b31 2d64 6f66 6d61 702e 6e64 696d 2c20  +1-dofmap.ndim, 
-00028680: 6178 6973 290a 2020 2020 6173 7365 7274  axis).    assert
-00028690: 2065 7175 616c 7368 6170 6528 646f 666d   equalshape(dofm
-000286a0: 6170 2e73 6861 7065 2c20 6172 672e 7368  ap.shape, arg.sh
-000286b0: 6170 655b 6178 6973 3a61 7869 732b 646f  ape[axis:axis+do
-000286c0: 666d 6170 2e6e 6469 6d5d 290a 2020 2020  fmap.ndim]).    
-000286d0: 7265 7475 726e 2054 7261 6e73 706f 7365  return Transpose
-000286e0: 2e66 726f 6d5f 656e 6428 496e 666c 6174  .from_end(Inflat
-000286f0: 6528 5472 616e 7370 6f73 652e 746f 5f65  e(Transpose.to_e
-00028700: 6e64 2861 7267 2c20 2a72 616e 6765 2861  nd(arg, *range(a
-00028710: 7869 732c 2061 7869 732b 646f 666d 6170  xis, axis+dofmap
-00028720: 2e6e 6469 6d29 292c 2064 6f66 6d61 702c  .ndim)), dofmap,
-00028730: 206c 656e 6774 6829 2c20 6178 6973 290a   length), axis).
-00028740: 0a0a 6465 6620 6d61 736b 2861 7267 2c20  ..def mask(arg, 
-00028750: 6d61 736b 2c20 6178 6973 3d30 293a 0a20  mask, axis=0):. 
-00028760: 2020 2072 6574 7572 6e20 7461 6b65 2861     return take(a
-00028770: 7267 2c20 6d61 736b 2c20 6178 6973 290a  rg, mask, axis).
-00028780: 0a0a 6465 6620 756e 7261 7665 6c28 6675  ..def unravel(fu
-00028790: 6e63 2c20 6178 6973 2c20 7368 6170 6529  nc, axis, shape)
-000287a0: 3a0a 2020 2020 6675 6e63 203d 2061 7361  :.    func = asa
-000287b0: 7272 6179 2866 756e 6329 0a20 2020 2061  rray(func).    a
-000287c0: 7869 7320 3d20 6e75 6d65 7269 632e 6e6f  xis = numeric.no
-000287d0: 726d 6469 6d28 6675 6e63 2e6e 6469 6d2c  rmdim(func.ndim,
-000287e0: 2061 7869 7329 0a20 2020 2061 7373 6572   axis).    asser
-000287f0: 7420 6c65 6e28 7368 6170 6529 203d 3d20  t len(shape) == 
-00028800: 320a 2020 2020 7265 7475 726e 2054 7261  2.    return Tra
-00028810: 6e73 706f 7365 2e66 726f 6d5f 656e 6428  nspose.from_end(
-00028820: 556e 7261 7665 6c28 5472 616e 7370 6f73  Unravel(Transpos
-00028830: 652e 746f 5f65 6e64 2866 756e 632c 2061  e.to_end(func, a
-00028840: 7869 7329 2c20 2a73 6861 7065 292c 2061  xis), *shape), a
-00028850: 7869 732c 2061 7869 732b 3129 0a0a 0a64  xis, axis+1)...d
-00028860: 6566 2072 6176 656c 2866 756e 632c 2061  ef ravel(func, a
-00028870: 7869 7329 3a0a 2020 2020 6675 6e63 203d  xis):.    func =
-00028880: 2061 7361 7272 6179 2866 756e 6329 0a20   asarray(func). 
-00028890: 2020 2061 7869 7320 3d20 6e75 6d65 7269     axis = numeri
-000288a0: 632e 6e6f 726d 6469 6d28 6675 6e63 2e6e  c.normdim(func.n
-000288b0: 6469 6d2d 312c 2061 7869 7329 0a20 2020  dim-1, axis).   
-000288c0: 2072 6574 7572 6e20 5472 616e 7370 6f73   return Transpos
-000288d0: 652e 6672 6f6d 5f65 6e64 2852 6176 656c  e.from_end(Ravel
-000288e0: 2854 7261 6e73 706f 7365 2e74 6f5f 656e  (Transpose.to_en
-000288f0: 6428 6675 6e63 2c20 6178 6973 2c20 6178  d(func, axis, ax
-00028900: 6973 2b31 2929 2c20 6178 6973 290a 0a0a  is+1)), axis)...
-00028910: 6465 6620 5f66 6c61 7428 6675 6e63 293a  def _flat(func):
-00028920: 0a20 2020 2066 756e 6320 3d20 6173 6172  .    func = asar
-00028930: 7261 7928 6675 6e63 290a 2020 2020 6966  ray(func).    if
-00028940: 2066 756e 632e 6e64 696d 203d 3d20 303a   func.ndim == 0:
-00028950: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00028960: 496e 7365 7274 4178 6973 2866 756e 632c  InsertAxis(func,
-00028970: 2031 290a 2020 2020 7768 696c 6520 6675   1).    while fu
-00028980: 6e63 2e6e 6469 6d20 3e20 313a 0a20 2020  nc.ndim > 1:.   
-00028990: 2020 2020 2066 756e 6320 3d20 5261 7665       func = Rave
-000289a0: 6c28 6675 6e63 290a 2020 2020 7265 7475  l(func).    retu
-000289b0: 726e 2066 756e 630a 0a0a 6465 6620 7072  rn func...def pr
-000289c0: 6570 656e 6461 7865 7328 6675 6e63 2c20  ependaxes(func, 
-000289d0: 7368 6170 6529 3a0a 2020 2020 2750 7265  shape):.    'Pre
-000289e0: 7065 6e64 2061 7865 7320 7769 7468 2073  pend axes with s
-000289f0: 7065 6369 6669 6564 2060 7368 6170 6560  pecified `shape`
-00028a00: 2074 6f20 6066 756e 6360 2e27 0a0a 2020   to `func`.'..  
-00028a10: 2020 6675 6e63 203d 2061 7361 7272 6179    func = asarray
-00028a20: 2866 756e 6329 0a20 2020 2066 6f72 2069  (func).    for i
-00028a30: 2c20 6e20 696e 2065 6e75 6d65 7261 7465  , n in enumerate
-00028a40: 2873 6861 7065 293a 0a20 2020 2020 2020  (shape):.       
-00028a50: 2066 756e 6320 3d20 696e 7365 7274 6178   func = insertax
-00028a60: 6973 2866 756e 632c 2069 2c20 6e29 0a20  is(func, i, n). 
-00028a70: 2020 2072 6574 7572 6e20 6675 6e63 0a0a     return func..
-00028a80: 0a64 6566 2061 7070 656e 6461 7865 7328  .def appendaxes(
-00028a90: 6675 6e63 2c20 7368 6170 6529 3a0a 2020  func, shape):.  
-00028aa0: 2020 2741 7070 656e 6420 6178 6573 2077    'Append axes w
-00028ab0: 6974 6820 7370 6563 6966 6965 6420 6073  ith specified `s
-00028ac0: 6861 7065 6020 746f 2060 6675 6e63 602e  hape` to `func`.
-00028ad0: 270a 0a20 2020 2066 756e 6320 3d20 6173  '..    func = as
-00028ae0: 6172 7261 7928 6675 6e63 290a 2020 2020  array(func).    
-00028af0: 666f 7220 6e20 696e 2073 6861 7065 3a0a  for n in shape:.
-00028b00: 2020 2020 2020 2020 6675 6e63 203d 2049          func = I
-00028b10: 6e73 6572 7441 7869 7328 6675 6e63 2c20  nsertAxis(func, 
-00028b20: 6e29 0a20 2020 2072 6574 7572 6e20 6675  n).    return fu
-00028b30: 6e63 0a0a 0a64 6566 206c 6f6f 705f 696e  nc...def loop_in
-00028b40: 6465 7828 6e61 6d65 2c20 6c65 6e67 7468  dex(name, length
-00028b50: 293a 0a20 2020 2072 6574 7572 6e20 5f4c  ):.    return _L
-00028b60: 6f6f 7049 6e64 6578 286e 616d 652c 206c  oopIndex(name, l
-00028b70: 656e 6774 6829 0a0a 0a64 6566 206c 6f6f  ength)...def loo
-00028b80: 705f 7375 6d28 6675 6e63 2c20 696e 6465  p_sum(func, inde
-00028b90: 7829 3a0a 2020 2020 6675 6e63 203d 2061  x):.    func = a
-00028ba0: 7361 7272 6179 2866 756e 6329 0a20 2020  sarray(func).   
-00028bb0: 2069 6e64 6578 203d 2074 7970 6573 2e73   index = types.s
-00028bc0: 7472 6963 745b 5f4c 6f6f 7049 6e64 6578  trict[_LoopIndex
-00028bd0: 5d28 696e 6465 7829 0a20 2020 2072 6574  ](index).    ret
-00028be0: 7572 6e20 4c6f 6f70 5375 6d28 6675 6e63  urn LoopSum(func
-00028bf0: 2c20 696e 6465 782e 5f6e 616d 652c 2069  , index._name, i
-00028c00: 6e64 6578 2e6c 656e 6774 6829 0a0a 0a64  ndex.length)...d
-00028c10: 6566 205f 6c6f 6f70 5f63 6f6e 6361 7465  ef _loop_concate
-00028c20: 6e61 7465 5f64 6174 6128 6675 6e63 2c20  nate_data(func, 
-00028c30: 696e 6465 7829 3a0a 2020 2020 6675 6e63  index):.    func
-00028c40: 203d 2061 7361 7272 6179 2866 756e 6329   = asarray(func)
-00028c50: 0a20 2020 2069 6e64 6578 203d 2074 7970  .    index = typ
-00028c60: 6573 2e73 7472 6963 745b 5f4c 6f6f 7049  es.strict[_LoopI
-00028c70: 6e64 6578 5d28 696e 6465 7829 0a20 2020  ndex](index).   
-00028c80: 2063 6875 6e6b 5f73 697a 6520 3d20 6675   chunk_size = fu
-00028c90: 6e63 2e73 6861 7065 5b2d 315d 0a20 2020  nc.shape[-1].   
-00028ca0: 2069 6620 6368 756e 6b5f 7369 7a65 2e69   if chunk_size.i
-00028cb0: 7363 6f6e 7374 616e 743a 0a20 2020 2020  sconstant:.     
-00028cc0: 2020 2063 6875 6e6b 5f73 697a 6573 203d     chunk_sizes =
-00028cd0: 2049 6e73 6572 7441 7869 7328 6368 756e   InsertAxis(chun
-00028ce0: 6b5f 7369 7a65 2c20 696e 6465 782e 6c65  k_size, index.le
-00028cf0: 6e67 7468 290a 2020 2020 656c 7365 3a0a  ngth).    else:.
-00028d00: 2020 2020 2020 2020 6368 756e 6b5f 7369          chunk_si
-00028d10: 7a65 7320 3d20 6c6f 6f70 5f63 6f6e 6361  zes = loop_conca
-00028d20: 7465 6e61 7465 2849 6e73 6572 7441 7869  tenate(InsertAxi
-00028d30: 7328 6675 6e63 2e73 6861 7065 5b2d 315d  s(func.shape[-1]
-00028d40: 2c20 3129 2c20 696e 6465 7829 0a20 2020  , 1), index).   
-00028d50: 206f 6666 7365 7473 203d 205f 5369 7a65   offsets = _Size
-00028d60: 7354 6f4f 6666 7365 7473 2863 6875 6e6b  sToOffsets(chunk
-00028d70: 5f73 697a 6573 290a 2020 2020 7374 6172  _sizes).    star
-00028d80: 7420 3d20 5461 6b65 286f 6666 7365 7473  t = Take(offsets
-00028d90: 2c20 696e 6465 7829 0a20 2020 2073 746f  , index).    sto
-00028da0: 7020 3d20 5461 6b65 286f 6666 7365 7473  p = Take(offsets
-00028db0: 2c20 696e 6465 782b 3129 0a20 2020 2072  , index+1).    r
-00028dc0: 6574 7572 6e20 2866 756e 632c 2073 7461  eturn (func, sta
-00028dd0: 7274 2c20 7374 6f70 2c20 2a66 756e 632e  rt, stop, *func.
-00028de0: 7368 6170 655b 3a2d 315d 2c20 5461 6b65  shape[:-1], Take
-00028df0: 286f 6666 7365 7473 2c20 696e 6465 782e  (offsets, index.
-00028e00: 6c65 6e67 7468 2929 0a0a 0a64 6566 206c  length))...def l
-00028e10: 6f6f 705f 636f 6e63 6174 656e 6174 6528  oop_concatenate(
-00028e20: 6675 6e63 2c20 696e 6465 7829 3a0a 2020  func, index):.  
-00028e30: 2020 6675 6e63 6461 7461 203d 205f 6c6f    funcdata = _lo
-00028e40: 6f70 5f63 6f6e 6361 7465 6e61 7465 5f64  op_concatenate_d
-00028e50: 6174 6128 6675 6e63 2c20 696e 6465 7829  ata(func, index)
-00028e60: 0a20 2020 2072 6574 7572 6e20 4c6f 6f70  .    return Loop
-00028e70: 436f 6e63 6174 656e 6174 6528 6675 6e63  Concatenate(func
-00028e80: 6461 7461 2c20 696e 6465 782e 5f6e 616d  data, index._nam
-00028e90: 652c 2069 6e64 6578 2e6c 656e 6774 6829  e, index.length)
-00028ea0: 0a0a 0a64 6566 206c 6f6f 705f 636f 6e63  ...def loop_conc
-00028eb0: 6174 656e 6174 655f 636f 6d62 696e 6564  atenate_combined
-00028ec0: 2866 756e 6373 2c20 696e 6465 7829 3a0a  (funcs, index):.
-00028ed0: 2020 2020 756e 6971 7565 5f66 756e 6373      unique_funcs
-00028ee0: 203d 205b 5d0a 2020 2020 756e 6971 7565   = [].    unique
-00028ef0: 5f66 756e 6373 2e65 7874 656e 6428 6675  _funcs.extend(fu
-00028f00: 6e63 2066 6f72 2066 756e 6320 696e 2066  nc for func in f
-00028f10: 756e 6373 2069 6620 6675 6e63 206e 6f74  uncs if func not
-00028f20: 2069 6e20 756e 6971 7565 5f66 756e 6373   in unique_funcs
-00028f30: 290a 2020 2020 756e 6971 7565 5f66 756e  ).    unique_fun
-00028f40: 635f 6461 7461 203d 2074 7570 6c65 285f  c_data = tuple(_
-00028f50: 6c6f 6f70 5f63 6f6e 6361 7465 6e61 7465  loop_concatenate
-00028f60: 5f64 6174 6128 6675 6e63 2c20 696e 6465  _data(func, inde
-00028f70: 7829 2066 6f72 2066 756e 6320 696e 2075  x) for func in u
-00028f80: 6e69 7175 655f 6675 6e63 7329 0a20 2020  nique_funcs).   
-00028f90: 206c 6f6f 7020 3d20 4c6f 6f70 436f 6e63   loop = LoopConc
-00028fa0: 6174 656e 6174 6543 6f6d 6269 6e65 6428  atenateCombined(
-00028fb0: 756e 6971 7565 5f66 756e 635f 6461 7461  unique_func_data
-00028fc0: 2c20 696e 6465 782e 5f6e 616d 652c 2069  , index._name, i
-00028fd0: 6e64 6578 2e6c 656e 6774 6829 0a20 2020  ndex.length).   
-00028fe0: 2072 6574 7572 6e20 7475 706c 6528 4172   return tuple(Ar
-00028ff0: 7261 7946 726f 6d54 7570 6c65 286c 6f6f  rayFromTuple(loo
-00029000: 702c 2075 6e69 7175 655f 6675 6e63 732e  p, unique_funcs.
-00029010: 696e 6465 7828 6675 6e63 292c 2073 6861  index(func), sha
-00029020: 7065 2c20 6675 6e63 2e64 7479 7065 2920  pe, func.dtype) 
-00029030: 666f 7220 6675 6e63 2c20 7374 6172 742c  for func, start,
-00029040: 2073 746f 702c 202a 7368 6170 6520 696e   stop, *shape in
-00029050: 2075 6e69 7175 655f 6675 6e63 5f64 6174   unique_func_dat
-00029060: 6129 0a0a 0a40 7265 706c 6163 650a 6465  a)...@replace.de
-00029070: 6620 7265 706c 6163 655f 6172 6775 6d65  f replace_argume
-00029080: 6e74 7328 7661 6c75 652c 2061 7267 756d  nts(value, argum
-00029090: 656e 7473 293a 0a20 2020 2027 2727 5265  ents):.    '''Re
-000290a0: 706c 6163 6520 3a63 6c61 7373 3a60 4172  place :class:`Ar
-000290b0: 6775 6d65 6e74 6020 6f62 6a65 6374 7320  gument` objects 
-000290c0: 696e 2060 6076 616c 7565 6060 2e0a 0a20  in ``value``... 
-000290d0: 2020 2052 6570 6c61 6365 203a 636c 6173     Replace :clas
-000290e0: 733a 6041 7267 756d 656e 7460 206f 626a  s:`Argument` obj
-000290f0: 6563 7473 2069 6e20 6060 7661 6c75 6560  ects in ``value`
-00029100: 6020 6163 636f 7264 696e 6720 746f 2074  ` according to t
-00029110: 6865 2060 6061 7267 756d 656e 7473 6060  he ``arguments``
-00029120: 0a20 2020 206d 6170 2c20 7461 6b69 6e67  .    map, taking
-00029130: 2069 6e74 6f20 6163 636f 756e 7420 6465   into account de
-00029140: 7269 7661 7469 7665 7320 746f 2074 6865  rivatives to the
-00029150: 206c 6f63 616c 2063 6f6f 7264 696e 6174   local coordinat
-00029160: 6573 2e0a 0a20 2020 2041 7267 730a 2020  es...    Args.  
-00029170: 2020 2d2d 2d2d 0a20 2020 2076 616c 7565    ----.    value
-00029180: 203a 203a 636c 6173 733a 6041 7272 6179   : :class:`Array
-00029190: 600a 2020 2020 2020 2020 4172 7261 7920  `.        Array 
-000291a0: 746f 2062 6520 6564 6974 6564 2e0a 2020  to be edited..  
-000291b0: 2020 6172 6775 6d65 6e74 7320 3a20 3a63    arguments : :c
-000291c0: 6c61 7373 3a60 636f 6c6c 6563 7469 6f6e  lass:`collection
-000291d0: 732e 6162 632e 4d61 7070 696e 6760 2077  s.abc.Mapping` w
-000291e0: 6974 6820 3a63 6c61 7373 3a60 4172 7261  ith :class:`Arra
-000291f0: 7960 5c5c 7320 6173 2076 616c 7565 730a  y`\\s as values.
-00029200: 2020 2020 2020 2020 3a63 6c61 7373 3a60          :class:`
-00029210: 4172 6775 6d65 6e74 605c 5c73 2072 6570  Argument`\\s rep
-00029220: 6c61 6365 6d65 6e74 732e 2020 5468 6520  lacements.  The 
-00029230: 6b65 7920 636f 7272 6573 706f 6e64 2074  key correspond t
-00029240: 6f20 7468 6520 6060 6e61 6d65 6060 0a20  o the ``name``. 
-00029250: 2020 2020 2020 2070 6173 7365 6420 746f         passed to
-00029260: 2061 6e20 3a63 6c61 7373 3a60 4172 6775   an :class:`Argu
-00029270: 6d65 6e74 6020 616e 6420 7468 6520 7661  ment` and the va
-00029280: 6c75 6520 6973 2074 6865 2072 6570 6c61  lue is the repla
-00029290: 6365 6d65 6e74 2e0a 0a20 2020 2052 6574  cement...    Ret
-000292a0: 7572 6e73 0a20 2020 202d 2d2d 2d2d 2d2d  urns.    -------
-000292b0: 0a20 2020 203a 636c 6173 733a 6041 7272  .    :class:`Arr
-000292c0: 6179 600a 2020 2020 2020 2020 5468 6520  ay`.        The 
-000292d0: 6564 6974 6564 2060 6076 616c 7565 6060  edited ``value``
-000292e0: 2e0a 2020 2020 2727 270a 2020 2020 6966  ..    '''.    if
-000292f0: 2069 7369 6e73 7461 6e63 6528 7661 6c75   isinstance(valu
-00029300: 652c 2041 7267 756d 656e 7429 2061 6e64  e, Argument) and
-00029310: 2076 616c 7565 2e5f 6e61 6d65 2069 6e20   value._name in 
-00029320: 6172 6775 6d65 6e74 733a 0a20 2020 2020  arguments:.     
-00029330: 2020 2076 203d 2061 7361 7272 6179 2861     v = asarray(a
-00029340: 7267 756d 656e 7473 5b76 616c 7565 2e5f  rguments[value._
-00029350: 6e61 6d65 5d29 0a20 2020 2020 2020 2061  name]).        a
-00029360: 7373 6572 7420 6571 7561 6c73 6861 7065  ssert equalshape
-00029370: 2876 616c 7565 2e73 6861 7065 2c20 762e  (value.shape, v.
-00029380: 7368 6170 6529 2c20 2876 616c 7565 2e73  shape), (value.s
-00029390: 6861 7065 2c20 762e 7368 6170 6529 0a20  hape, v.shape). 
-000293a0: 2020 2020 2020 2061 7373 6572 7420 7661         assert va
-000293b0: 6c75 652e 6474 7970 6520 3d3d 2076 2e64  lue.dtype == v.d
-000293c0: 7479 7065 2c20 2876 616c 7565 2e64 7479  type, (value.dty
-000293d0: 7065 2c20 762e 6474 7970 6529 0a20 2020  pe, v.dtype).   
-000293e0: 2020 2020 2072 6574 7572 6e20 760a 0a0a       return v...
-000293f0: 6465 6620 6569 6e73 756d 2866 6d74 2c20  def einsum(fmt, 
-00029400: 2a61 7267 732c 202a 2a64 696d 7329 3a0a  *args, **dims):.
-00029410: 2020 2020 2727 274d 756c 7469 706c 7920      '''Multiply 
-00029420: 616e 642f 6f72 2063 6f6e 7472 6163 7420  and/or contract 
-00029430: 6172 7261 7973 2076 6961 2066 6f72 6d61  arrays via forma
-00029440: 7420 7374 7269 6e67 2e0a 0a20 2020 2054  t string...    T
-00029450: 6865 2066 6f72 6d61 7420 7374 7269 6e67  he format string
-00029460: 2063 6f6e 7369 7374 7320 6f66 2061 2063   consists of a c
-00029470: 6f6d 6d61 2073 6570 6172 6174 6564 206c  omma separated l
-00029480: 6973 7420 6f66 2061 7869 7320 6c61 6265  ist of axis labe
-00029490: 6c73 2c20 666f 6c6c 6f77 6564 0a20 2020  ls, followed.   
-000294a0: 2062 7920 6060 2d3e 6060 2061 6e64 2074   by ``->`` and t
-000294b0: 6865 2061 7869 7320 6c61 6265 6c73 206f  he axis labels o
-000294c0: 6620 7468 6520 7265 7475 726e 2076 616c  f the return val
-000294d0: 7565 2e20 466f 7220 6578 616d 706c 652c  ue. For example,
-000294e0: 2074 6865 2066 6f6c 6c6f 7769 6e67 0a20   the following. 
-000294f0: 2020 2073 7761 7073 2074 6865 2061 7865     swaps the axe
-00029500: 7320 6f66 2061 206d 6174 7269 783a 0a0a  s of a matrix:..
-00029510: 2020 2020 3e3e 3e20 6569 6e73 756d 2827      >>> einsum('
-00029520: 696a 2d3e 6a69 272c 206f 6e65 7328 5b32  ij->ji', ones([2
-00029530: 2c33 5d29 290a 2020 2020 6e75 7469 6c73  ,3])).    nutils
-00029540: 2e65 7661 6c75 6162 6c65 2e54 7261 6e73  .evaluable.Trans
-00029550: 706f 7365 3c66 3a33 2c32 3e0a 0a20 2020  pose<f:3,2>..   
-00029560: 2041 7869 7320 6c61 6265 6c73 2074 6861   Axis labels tha
-00029570: 7420 646f 206e 6f74 206f 6363 7572 2069  t do not occur i
-00029580: 6e20 7468 6520 7265 7475 726e 2076 616c  n the return val
-00029590: 7565 2061 7265 2073 756d 6d65 642e 2046  ue are summed. F
-000295a0: 6f72 2065 7861 6d70 6c65 2c0a 2020 2020  or example,.    
-000295b0: 7468 6520 666f 6c6c 6f77 696e 6720 7065  the following pe
-000295c0: 7266 6f72 6d73 2061 2064 6f74 2070 726f  rforms a dot pro
-000295d0: 6475 6374 206f 6620 7468 7265 6520 6d61  duct of three ma
-000295e0: 7472 6963 6573 3a0a 0a20 2020 203e 3e3e  trices:..    >>>
-000295f0: 2065 696e 7375 6d28 2769 6a2c 6a6b 2c6b   einsum('ij,jk,k
-00029600: 6c2d 3e69 6c27 2c20 6f6e 6573 285b 322c  l->il', ones([2,
-00029610: 335d 292c 206f 6e65 7328 5b33 2c34 5d29  3]), ones([3,4])
-00029620: 2c20 6f6e 6573 285b 342c 355d 2929 0a20  , ones([4,5])). 
-00029630: 2020 206e 7574 696c 732e 6576 616c 7561     nutils.evalua
-00029640: 626c 652e 5375 6d3c 663a 322c 353e 0a0a  ble.Sum<f:2,5>..
-00029650: 2020 2020 496e 2063 6173 6520 7468 6520      In case the 
-00029660: 6469 6d65 6e73 696f 6e20 6f66 2074 6865  dimension of the
-00029670: 2069 6e70 7574 2061 6e64 206f 7574 7075   input and outpu
-00029680: 7420 6172 7261 7973 206d 6179 2076 6172  t arrays may var
-00029690: 792c 2061 2076 6172 6961 626c 650a 2020  y, a variable.  
-000296a0: 2020 6c65 6e67 7468 2061 7865 7320 6772    length axes gr
-000296b0: 6f75 7020 6361 6e20 6265 2064 656e 6f74  oup can be denot
-000296c0: 6564 2062 7920 6120 6361 7069 7461 6c2e  ed by a capital.
-000296d0: 2049 7473 206c 656e 6774 6820 6973 2061   Its length is a
-000296e0: 7574 6f6d 6174 6963 616c 6c79 0a20 2020  utomatically.   
-000296f0: 2065 7374 6162 6c69 7368 6564 2062 6173   established bas
-00029700: 6564 206f 6e20 7468 6520 6469 6d65 6e73  ed on the dimens
-00029710: 696f 6e20 6f66 2074 6865 2069 6e70 7574  ion of the input
-00029720: 2061 7272 6179 732e 2054 6865 2066 6f6c   arrays. The fol
-00029730: 6c6f 7769 6e67 2065 7861 6d70 6c65 0a20  lowing example. 
-00029740: 2020 2070 6572 666f 726d 7320 6120 7465     performs a te
-00029750: 6e73 6f72 2070 726f 6475 6374 206f 6620  nsor product of 
-00029760: 616e 2061 7272 6179 2061 6e64 2061 2076  an array and a v
-00029770: 6563 746f 723a 0a0a 2020 2020 3e3e 3e20  ector:..    >>> 
-00029780: 6569 6e73 756d 2827 412c 692d 3e41 6927  einsum('A,i->Ai'
-00029790: 2c20 6f6e 6573 285b 322c 332c 345d 292c  , ones([2,3,4]),
-000297a0: 206f 6e65 7328 5b35 5d29 290a 2020 2020   ones([5])).    
-000297b0: 6e75 7469 6c73 2e65 7661 6c75 6162 6c65  nutils.evaluable
-000297c0: 2e4d 756c 7469 706c 793c 663a 322c 332c  .Multiply<f:2,3,
-000297d0: 342c 353e 0a0a 2020 2020 5468 6520 666f  4,5>..    The fo
-000297e0: 726d 6174 2073 7472 696e 6720 6d61 7920  rmat string may 
-000297f0: 636f 6e74 6169 6e20 6d75 6c74 6970 6c65  contain multiple
-00029800: 2076 6172 6961 626c 6520 6c65 6e67 7468   variable length
-00029810: 2061 7865 7320 6772 6f75 7073 2c20 6275   axes groups, bu
-00029820: 7420 7468 6569 720a 2020 2020 6c65 6e67  t their.    leng
-00029830: 7468 7320 6d75 7374 2062 6520 7265 736f  ths must be reso
-00029840: 6c76 6162 6c65 2066 726f 6d20 6c65 6674  lvable from left
-00029850: 2074 6f20 7269 6768 742e 2049 6e20 6361   to right. In ca
-00029860: 7365 2074 6869 7320 6973 206e 6f74 2070  se this is not p
-00029870: 6f73 7369 626c 652c 0a20 2020 206c 656e  ossible,.    len
-00029880: 6774 6873 206d 6179 2062 6520 7370 6563  gths may be spec
-00029890: 6966 6965 6420 6173 206b 6579 776f 7264  ified as keyword
-000298a0: 2061 7267 756d 656e 7473 2e0a 0a20 2020   arguments...   
-000298b0: 203e 3e3e 2065 696e 7375 6d28 2741 6a42   >>> einsum('AjB
-000298c0: 2c69 2d3e 4169 6a42 272c 206f 6e65 7328  ,i->AijB', ones(
-000298d0: 5b32 2c33 2c34 5d29 2c20 6f6e 6573 285b  [2,3,4]), ones([
-000298e0: 355d 292c 2042 3d31 290a 2020 2020 6e75  5]), B=1).    nu
-000298f0: 7469 6c73 2e65 7661 6c75 6162 6c65 2e4d  tils.evaluable.M
-00029900: 756c 7469 706c 793c 663a 322c 352c 332c  ultiply<f:2,5,3,
-00029910: 343e 0a20 2020 2027 2727 0a0a 2020 2020  4>.    '''..    
-00029920: 7369 6e2c 2073 6f75 7420 3d20 666d 742e  sin, sout = fmt.
-00029930: 7370 6c69 7428 272d 3e27 290a 2020 2020  split('->').    
-00029940: 7369 6e20 3d20 7369 6e2e 7370 6c69 7428  sin = sin.split(
-00029950: 272c 2729 0a0a 2020 2020 6966 206c 656e  ',')..    if len
-00029960: 2873 696e 2920 213d 206c 656e 2861 7267  (sin) != len(arg
-00029970: 7329 3a0a 2020 2020 2020 2020 7261 6973  s):.        rais
-00029980: 6520 5661 6c75 6545 7272 6f72 2827 6e75  e ValueError('nu
-00029990: 6d62 6572 206f 6620 6172 6775 6d65 6e74  mber of argument
-000299a0: 7320 646f 6573 206e 6f74 206d 6174 6368  s does not match
-000299b0: 2066 6f72 6d61 7420 7374 7269 6e67 2729   format string')
-000299c0: 0a0a 2020 2020 6966 2061 6e79 286c 656e  ..    if any(len
-000299d0: 2873 2920 213d 206c 656e 2873 6574 2873  (s) != len(set(s
-000299e0: 2929 2066 6f72 2073 2069 6e20 282a 7369  )) for s in (*si
-000299f0: 6e2c 2073 6f75 7429 293a 0a20 2020 2020  n, sout)):.     
-00029a00: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00029a10: 726f 7228 2769 6e74 6572 6e61 6c20 7265  ror('internal re
-00029a20: 7065 7469 7469 6f6e 7320 6172 6520 6e6f  petitions are no
-00029a30: 7420 7375 7070 6f72 7465 6427 290a 0a20  t supported').. 
-00029a40: 2020 2069 6620 616e 7928 6e20 3c20 3020     if any(n < 0 
-00029a50: 666f 7220 6e20 696e 2064 696d 732e 7661  for n in dims.va
-00029a60: 6c75 6573 2829 293a 0a20 2020 2020 2020  lues()):.       
-00029a70: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00029a80: 7228 2761 7869 7320 6772 6f75 7020 6469  r('axis group di
-00029a90: 6d65 6e73 696f 6e73 2063 616e 6e6f 7420  mensions cannot 
-00029aa0: 6265 206e 6567 6174 6976 6527 290a 0a20  be negative').. 
-00029ab0: 2020 2066 6f72 2063 2069 6e20 2761 6263     for c in 'abc
-00029ac0: 6465 6667 6869 6a6b 6c6d 6e6f 7071 7273  defghijklmnopqrs
-00029ad0: 7475 7677 7879 7a27 3a0a 2020 2020 2020  tuvwxyz':.      
-00029ae0: 2020 6469 6d73 2e73 6574 6465 6661 756c    dims.setdefaul
-00029af0: 7428 632c 2031 2920 2023 206c 6f77 6572  t(c, 1)  # lower
-00029b00: 6361 7365 2063 6861 7261 6374 6572 7320  case characters 
-00029b10: 6465 6661 756c 7420 746f 2073 696e 676c  default to singl
-00029b20: 6520 6469 6d65 6e73 696f 6e0a 0a20 2020  e dimension..   
-00029b30: 2066 6f72 2073 2c20 6172 6720 696e 207a   for s, arg in z
-00029b40: 6970 2873 696e 2c20 6172 6773 293a 0a20  ip(sin, args):. 
-00029b50: 2020 2020 2020 206d 6973 7369 6e67 5f64         missing_d
-00029b60: 696d 7320 3d20 6172 672e 6e64 696d 202d  ims = arg.ndim -
-00029b70: 2062 7569 6c74 696e 732e 7375 6d28 6469   builtins.sum(di
-00029b80: 6d73 2e67 6574 2863 2c20 3029 2066 6f72  ms.get(c, 0) for
-00029b90: 2063 2069 6e20 7329 0a20 2020 2020 2020   c in s).       
-00029ba0: 2075 6e6b 6e6f 776e 5f61 7865 7320 3d20   unknown_axes = 
-00029bb0: 5b63 2066 6f72 2063 2069 6e20 7320 6966  [c for c in s if
-00029bc0: 2063 206e 6f74 2069 6e20 6469 6d73 5d0a   c not in dims].
-00029bd0: 2020 2020 2020 2020 6966 206c 656e 2875          if len(u
-00029be0: 6e6b 6e6f 776e 5f61 7865 7329 203d 3d20  nknown_axes) == 
-00029bf0: 3120 616e 6420 6d69 7373 696e 675f 6469  1 and missing_di
-00029c00: 6d73 203e 3d20 303a 0a20 2020 2020 2020  ms >= 0:.       
-00029c10: 2020 2020 2064 696d 735b 756e 6b6e 6f77       dims[unknow
-00029c20: 6e5f 6178 6573 5b30 5d5d 203d 206d 6973  n_axes[0]] = mis
-00029c30: 7369 6e67 5f64 696d 730a 2020 2020 2020  sing_dims.      
-00029c40: 2020 656c 6966 206c 656e 2875 6e6b 6e6f    elif len(unkno
-00029c50: 776e 5f61 7865 7329 203e 2031 3a0a 2020  wn_axes) > 1:.  
-00029c60: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00029c70: 5661 6c75 6545 7272 6f72 2827 6361 6e6e  ValueError('cann
-00029c80: 6f74 2065 7374 6162 6c69 7368 206c 656e  ot establish len
-00029c90: 6774 6820 6f66 2076 6172 6961 626c 6520  gth of variable 
-00029ca0: 6772 6f75 7073 207b 7d27 2e66 6f72 6d61  groups {}'.forma
-00029cb0: 7428 272c 2027 2e6a 6f69 6e28 756e 6b6e  t(', '.join(unkn
-00029cc0: 6f77 6e5f 6178 6573 2929 290a 2020 2020  own_axes))).    
-00029cd0: 2020 2020 656c 6966 206d 6973 7369 6e67      elif missing
-00029ce0: 5f64 696d 733a 0a20 2020 2020 2020 2020  _dims:.         
-00029cf0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00029d00: 726f 7228 2761 7267 756d 656e 7420 6469  ror('argument di
-00029d10: 6d65 6e73 696f 6e73 2061 7265 2069 6e63  mensions are inc
-00029d20: 6f6e 7369 7374 656e 7420 7769 7468 2066  onsistent with f
-00029d30: 6f72 6d61 7420 7374 7269 6e67 2729 0a0a  ormat string')..
-00029d40: 2020 2020 2320 6578 7061 6e64 2063 6861      # expand cha
-00029d50: 7261 6374 6572 7320 746f 206d 6174 6368  racters to match
-00029d60: 2061 7267 756d 656e 7420 6469 6d65 6e73   argument dimens
-00029d70: 696f 6e0a 2020 2020 2a73 696e 2c20 736f  ion.    *sin, so
-00029d80: 7574 203d 205b 5b28 632c 2064 2920 666f  ut = [[(c, d) fo
-00029d90: 7220 6320 696e 2073 2066 6f72 2064 2069  r c in s for d i
-00029da0: 6e20 7261 6e67 6528 6469 6d73 5b63 5d29  n range(dims[c])
-00029db0: 5d20 666f 7220 7320 696e 2028 2a73 696e  ] for s in (*sin
-00029dc0: 2c20 736f 7574 295d 0a20 2020 2073 616c  , sout)].    sal
-00029dd0: 6c20 3d20 736f 7574 202b 2073 6f72 7465  l = sout + sorte
-00029de0: 6428 7b63 2066 6f72 2073 2069 6e20 7369  d({c for s in si
-00029df0: 6e20 666f 7220 6320 696e 2073 2069 6620  n for c in s if 
-00029e00: 6320 6e6f 7420 696e 2073 6f75 747d 290a  c not in sout}).
-00029e10: 0a20 2020 2073 6861 7065 7320 3d20 7b7d  .    shapes = {}
-00029e20: 0a20 2020 2066 6f72 2073 2c20 6172 6720  .    for s, arg 
-00029e30: 696e 207a 6970 2873 696e 2c20 6172 6773  in zip(sin, args
-00029e40: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
-00029e50: 7420 6c65 6e28 7329 203d 3d20 6172 672e  t len(s) == arg.
-00029e60: 6e64 696d 0a20 2020 2020 2020 2066 6f72  ndim.        for
-00029e70: 2063 2c20 7368 2069 6e20 7a69 7028 732c   c, sh in zip(s,
-00029e80: 2061 7267 2e73 6861 7065 293a 0a20 2020   arg.shape):.   
-00029e90: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-00029ea0: 6571 7561 6c69 6e64 6578 2873 6861 7065  equalindex(shape
-00029eb0: 732e 7365 7464 6566 6175 6c74 2863 2c20  s.setdefault(c, 
-00029ec0: 7368 292c 2073 6829 3a0a 2020 2020 2020  sh), sh):.      
-00029ed0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00029ee0: 5661 6c75 6545 7272 6f72 2827 7368 6170  ValueError('shap
-00029ef0: 6573 2064 6f20 6e6f 7420 6d61 7463 6820  es do not match 
-00029f00: 666f 7220 6178 6973 207b 305b 305d 7d7b  for axis {0[0]}{
-00029f10: 305b 315d 7d27 2e66 6f72 6d61 7428 6329  0[1]}'.format(c)
-00029f20: 290a 0a20 2020 2072 6574 203d 204e 6f6e  )..    ret = Non
-00029f30: 650a 2020 2020 666f 7220 732c 2061 7267  e.    for s, arg
-00029f40: 2069 6e20 7a69 7028 7369 6e2c 2061 7267   in zip(sin, arg
-00029f50: 7329 3a0a 2020 2020 2020 2020 696e 6465  s):.        inde
-00029f60: 7820 3d20 7b63 3a20 6920 666f 7220 692c  x = {c: i for i,
-00029f70: 2063 2069 6e20 656e 756d 6572 6174 6528   c in enumerate(
-00029f80: 7329 7d0a 2020 2020 2020 2020 666f 7220  s)}.        for 
-00029f90: 6320 696e 2073 616c 6c3a 0a20 2020 2020  c in sall:.     
-00029fa0: 2020 2020 2020 2069 6620 6320 6e6f 7420         if c not 
-00029fb0: 696e 2069 6e64 6578 3a0a 2020 2020 2020  in index:.      
-00029fc0: 2020 2020 2020 2020 2020 696e 6465 785b            index[
-00029fd0: 635d 203d 2061 7267 2e6e 6469 6d0a 2020  c] = arg.ndim.  
-00029fe0: 2020 2020 2020 2020 2020 2020 2020 6172                ar
-00029ff0: 6720 3d20 496e 7365 7274 4178 6973 2861  g = InsertAxis(a
-0002a000: 7267 2c20 7368 6170 6573 5b63 5d29 0a20  rg, shapes[c]). 
-0002a010: 2020 2020 2020 2076 203d 2054 7261 6e73         v = Trans
-0002a020: 706f 7365 2861 7267 2c20 5b69 6e64 6578  pose(arg, [index
-0002a030: 5b63 5d20 666f 7220 6320 696e 2073 616c  [c] for c in sal
-0002a040: 6c5d 290a 2020 2020 2020 2020 7265 7420  l]).        ret 
-0002a050: 3d20 7620 6966 2072 6574 2069 7320 4e6f  = v if ret is No
-0002a060: 6e65 2065 6c73 6520 7265 7420 2a20 760a  ne else ret * v.
-0002a070: 2020 2020 666f 7220 6920 696e 2072 616e      for i in ran
-0002a080: 6765 286c 656e 2873 6f75 7429 2c20 6c65  ge(len(sout), le
-0002a090: 6e28 7361 6c6c 2929 3a0a 2020 2020 2020  n(sall)):.      
-0002a0a0: 2020 7265 7420 3d20 5375 6d28 7265 7429    ret = Sum(ret)
-0002a0b0: 0a20 2020 2072 6574 7572 6e20 7265 740a  .    return ret.
-0002a0c0: 0a0a 4075 7469 6c2e 7369 6e67 6c65 5f6f  ..@util.single_o
-0002a0d0: 725f 6d75 6c74 6970 6c65 0a64 6566 2065  r_multiple.def e
-0002a0e0: 7661 6c5f 7370 6172 7365 2866 756e 6373  val_sparse(funcs
-0002a0f0: 3a20 4173 4576 616c 7561 626c 6541 7272  : AsEvaluableArr
-0002a100: 6179 2c20 2a2a 6172 6775 6d65 6e74 733a  ay, **arguments:
-0002a110: 2074 7970 696e 672e 4d61 7070 696e 675b   typing.Mapping[
-0002a120: 7374 722c 206e 756d 7079 2e6e 6461 7272  str, numpy.ndarr
-0002a130: 6179 5d29 202d 3e20 7479 7069 6e67 2e54  ay]) -> typing.T
-0002a140: 7570 6c65 5b6e 756d 7079 2e6e 6461 7272  uple[numpy.ndarr
-0002a150: 6179 2c20 2e2e 2e5d 3a0a 2020 2020 2727  ay, ...]:.    ''
-0002a160: 2745 7661 6c75 6174 6520 6f6e 6520 6f72  'Evaluate one or
-0002a170: 2073 6576 6572 616c 2041 7272 6179 206f   several Array o
-0002a180: 626a 6563 7473 2061 7320 7370 6172 7365  bjects as sparse
-0002a190: 2064 6174 612e 0a0a 2020 2020 4172 6773   data...    Args
-0002a1a0: 0a20 2020 202d 2d2d 2d0a 2020 2020 6675  .    ----.    fu
-0002a1b0: 6e63 7320 3a20 3a63 6c61 7373 3a60 7475  ncs : :class:`tu
-0002a1c0: 706c 6560 206f 6620 4172 7261 7920 6f62  ple` of Array ob
-0002a1d0: 6a65 6374 730a 2020 2020 2020 2020 4172  jects.        Ar
-0002a1e0: 7261 7973 2074 6f20 6265 2065 7661 6c75  rays to be evalu
-0002a1f0: 6174 6564 2e0a 2020 2020 6172 6775 6d65  ated..    argume
-0002a200: 6e74 7320 3a20 3a63 6c61 7373 3a60 6469  nts : :class:`di
-0002a210: 6374 6020 2864 6566 6175 6c74 3a20 4e6f  ct` (default: No
-0002a220: 6e65 290a 2020 2020 2020 2020 4f70 7469  ne).        Opti
-0002a230: 6f6e 616c 2061 7267 756d 656e 7473 2066  onal arguments f
-0002a240: 6f72 2066 756e 6374 696f 6e20 6576 616c  or function eval
-0002a250: 7561 7469 6f6e 2e0a 0a20 2020 2052 6574  uation...    Ret
-0002a260: 7572 6e73 0a20 2020 202d 2d2d 2d2d 2d2d  urns.    -------
-0002a270: 0a20 2020 2072 6573 756c 7473 203a 203a  .    results : :
-0002a280: 636c 6173 733a 6074 7570 6c65 6020 6f66  class:`tuple` of
-0002a290: 2073 7061 7273 6520 6461 7461 2061 7272   sparse data arr
-0002a2a0: 6179 730a 2020 2020 2727 270a 0a20 2020  ays.    '''..   
-0002a2b0: 2066 756e 6373 203d 2074 7570 6c65 2866   funcs = tuple(f
-0002a2c0: 756e 632e 6173 5f65 7661 6c75 6162 6c65  unc.as_evaluable
-0002a2d0: 5f61 7272 6179 2e61 7373 7061 7273 6520  _array.assparse 
-0002a2e0: 666f 7220 6675 6e63 2069 6e20 6675 6e63  for func in func
-0002a2f0: 7329 0a20 2020 2077 6974 6820 5475 706c  s).    with Tupl
-0002a300: 6528 6675 6e63 7329 2e6f 7074 696d 697a  e(funcs).optimiz
-0002a310: 6564 5f66 6f72 5f6e 756d 7079 2e73 6573  ed_for_numpy.ses
-0002a320: 7369 6f6e 2867 7261 7068 7669 7a3d 6772  sion(graphviz=gr
-0002a330: 6170 6876 697a 2920 6173 2065 7661 6c3a  aphviz) as eval:
-0002a340: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0002a350: 6576 616c 282a 2a61 7267 756d 656e 7473  eval(**arguments
-0002a360: 290a 0a0a 6966 205f 5f6e 616d 655f 5f20  )...if __name__ 
-0002a370: 3d3d 2027 5f5f 6d61 696e 5f5f 273a 0a20  == '__main__':. 
-0002a380: 2020 2023 2044 6961 676e 6f73 7469 6373     # Diagnostics
-0002a390: 2066 6f72 2074 6865 2064 6576 656c 6f70   for the develop
-0002a3a0: 6d65 6e74 2066 6f72 2073 696d 706c 6966  ment for simplif
-0002a3b0: 7920 6f70 6572 6174 696f 6e73 2e0a 2020  y operations..  
-0002a3c0: 2020 7369 6d70 6c69 6679 5f70 7269 6f72    simplify_prior
-0002a3d0: 6974 7920 3d20 280a 2020 2020 2020 2020  ity = (.        
-0002a3e0: 5472 616e 7370 6f73 652c 2052 6176 656c  Transpose, Ravel
-0002a3f0: 2c20 2023 2072 6569 6e74 6572 7072 6574  ,  # reinterpret
-0002a400: 6174 696f 6e0a 2020 2020 2020 2020 496e  ation.        In
-0002a410: 7365 7274 4178 6973 2c20 496e 666c 6174  sertAxis, Inflat
-0002a420: 652c 2044 6961 676f 6e61 6c69 7a65 2c20  e, Diagonalize, 
-0002a430: 2023 2073 697a 6520 696e 6372 6561 7369   # size increasi
-0002a440: 6e67 0a20 2020 2020 2020 204d 756c 7469  ng.        Multi
-0002a450: 706c 792c 2041 6464 2c20 4c6f 6f70 5375  ply, Add, LoopSu
-0002a460: 6d2c 2053 6967 6e2c 2050 6f77 6572 2c20  m, Sign, Power, 
-0002a470: 496e 7665 7273 652c 2055 6e72 6176 656c  Inverse, Unravel
-0002a480: 2c20 2023 2073 697a 6520 7072 6573 6572  ,  # size preser
-0002a490: 7669 6e67 0a20 2020 2020 2020 2050 726f  ving.        Pro
-0002a4a0: 6475 6374 2c20 4465 7465 726d 696e 616e  duct, Determinan
-0002a4b0: 742c 2054 616b 6544 6961 672c 2054 616b  t, TakeDiag, Tak
-0002a4c0: 652c 2053 756d 2920 2023 2073 697a 6520  e, Sum)  # size 
-0002a4d0: 6465 6372 6561 7369 6e67 0a20 2020 2023  decreasing.    #
-0002a4e0: 2054 6865 2073 696d 706c 6966 7920 7072   The simplify pr
-0002a4f0: 696f 7269 7479 2064 6566 696e 6573 2074  iority defines t
-0002a500: 6865 2070 7265 6665 7272 6564 206f 7264  he preferred ord
-0002a510: 6572 2069 6e20 7768 6963 6820 6f70 6572  er in which oper
-0002a520: 6174 696f 6e73 2061 7265 0a20 2020 2023  ations are.    #
-0002a530: 2070 6572 666f 726d 6564 3a20 7368 6170   performed: shap
-0002a540: 6520 6465 6372 6561 7369 6e67 206f 7065  e decreasing ope
-0002a550: 7261 7469 6f6e 7320 7375 6368 2061 7320  rations such as 
-0002a560: 5375 6d20 616e 6420 5461 6b65 2073 686f  Sum and Take sho
-0002a570: 756c 6420 6265 2064 6f6e 650a 2020 2020  uld be done.    
-0002a580: 2320 6173 2073 6f6f 6e20 6173 2070 6f73  # as soon as pos
-0002a590: 7369 626c 652c 2061 6e64 2073 6861 7065  sible, and shape
-0002a5a0: 2069 6e63 7265 6173 696e 6720 6f70 6572   increasing oper
-0002a5b0: 6174 696f 6e73 2073 7563 6820 6173 2049  ations such as I
-0002a5c0: 6e66 6c61 7465 2061 6e64 0a20 2020 2023  nflate and.    #
-0002a5d0: 2044 6961 676f 6e61 6c69 7a65 2061 7320   Diagonalize as 
-0002a5e0: 6c61 7465 2061 7320 706f 7373 6962 6c65  late as possible
-0002a5f0: 2e20 496e 2073 6875 6666 6c69 6e67 2074  . In shuffling t
-0002a600: 6865 206f 7264 6572 206f 6620 6f70 6572  he order of oper
-0002a610: 6174 696f 6e73 2074 6865 0a20 2020 2023  ations the.    #
-0002a620: 2074 776f 2063 6c61 7373 6573 206d 6967   two classes mig
-0002a630: 6874 2061 6e6e 6968 696c 6174 6520 6561  ht annihilate ea
-0002a640: 6368 206f 7468 6572 2c20 666f 7220 6578  ch other, for ex
-0002a650: 616d 706c 6520 7768 656e 2061 2053 756d  ample when a Sum
-0002a660: 2070 6173 7365 730a 2020 2020 2320 7468   passes.    # th
-0002a670: 726f 7567 6820 6120 4469 6167 6f6e 616c  rough a Diagonal
-0002a680: 697a 652e 2041 6e79 2073 6861 7065 2069  ize. Any shape i
-0002a690: 6e63 7265 6173 696e 6720 6f70 6572 6174  ncreasing operat
-0002a6a0: 696f 6e73 2074 6861 7420 7265 6d61 696e  ions that remain
-0002a6b0: 2073 686f 756c 640a 2020 2020 2320 656e   should.    # en
-0002a6c0: 6420 7570 2061 7420 7468 6520 7375 7266  d up at the surf
-0002a6d0: 6163 652c 2065 7870 6f73 696e 6720 7370  ace, exposing sp
-0002a6e0: 6172 7369 7479 2062 7920 6d65 616e 7320  arsity by means 
-0002a6f0: 6f66 2074 6865 2061 7373 7061 7273 6520  of the assparse 
-0002a700: 6d65 7468 6f64 2e0a 2020 2020 6174 7472  method..    attr
-0002a710: 7320 3d20 5b27 5f27 2b63 6c73 2e5f 5f6e  s = ['_'+cls.__n
-0002a720: 616d 655f 5f2e 6c6f 7765 7228 2920 666f  ame__.lower() fo
-0002a730: 7220 636c 7320 696e 2073 696d 706c 6966  r cls in simplif
-0002a740: 795f 7072 696f 7269 7479 5d0a 2020 2020  y_priority].    
-0002a750: 2320 5468 6520 7369 6d70 6c69 6679 206f  # The simplify o
-0002a760: 7065 7261 7469 6f6e 7320 7265 7370 6f6e  perations respon
-0002a770: 7369 626c 6520 666f 7220 7377 6170 7069  sible for swappi
-0002a780: 6e67 2028 612e 6f2e 2920 6172 6520 6d65  ng (a.o.) are me
-0002a790: 7468 6f64 7320 6e61 6d65 640a 2020 2020  thods named.    
-0002a7a0: 2320 275f 6164 6427 2c20 275f 6d75 6c74  # '_add', '_mult
-0002a7b0: 6970 6c79 272c 2065 7463 2e20 496e 206f  iply', etc. In o
-0002a7c0: 7264 6572 2074 6f20 6176 6f69 6420 7265  rder to avoid re
-0002a7d0: 6375 7273 696f 6e73 2074 6865 206f 7065  cursions the ope
-0002a7e0: 7261 7469 6f6e 730a 2020 2020 2320 7368  rations.    # sh
-0002a7f0: 6f75 6c64 206f 6e6c 7920 6265 2064 6566  ould only be def
-0002a800: 696e 6564 2069 6e20 7468 6520 6469 7265  ined in the dire
-0002a810: 6374 696f 6e20 6465 6669 6e65 6420 6279  ction defined by
-0002a820: 206f 7065 7261 746f 7220 7072 696f 7269   operator priori
-0002a830: 7479 2e20 5468 650a 2020 2020 2320 666f  ty. The.    # fo
-0002a840: 6c6c 6f77 696e 6720 636f 6465 2077 6172  llowing code war
-0002a850: 6e73 2067 6169 6e73 7420 7669 6f6c 6174  ns gainst violat
-0002a860: 696f 6e73 206f 6620 7468 6973 2072 756c  ions of this rul
-0002a870: 6520 616e 6420 6c69 7374 7320 7065 726d  e and lists perm
-0002a880: 6973 7369 626c 650a 2020 2020 2320 7369  issible.    # si
-0002a890: 6d70 6c69 6669 6361 7469 6f6e 7320 7468  mplifications th
-0002a8a0: 6174 2068 6176 6520 6e6f 7420 7965 7420  at have not yet 
-0002a8b0: 6265 656e 2069 6d70 6c65 6d65 6e74 6564  been implemented
-0002a8c0: 2e0a 2020 2020 666f 7220 692c 2063 6c73  ..    for i, cls
-0002a8d0: 2069 6e20 656e 756d 6572 6174 6528 7369   in enumerate(si
-0002a8e0: 6d70 6c69 6679 5f70 7269 6f72 6974 7929  mplify_priority)
-0002a8f0: 3a0a 2020 2020 2020 2020 7761 726e 203d  :.        warn =
-0002a900: 205b 6174 7472 2066 6f72 2061 7474 7220   [attr for attr 
-0002a910: 696e 2061 7474 7273 5b3a 695d 2069 6620  in attrs[:i] if 
-0002a920: 6765 7461 7474 7228 636c 732c 2061 7474  getattr(cls, att
-0002a930: 7229 2069 7320 6e6f 7420 6765 7461 7474  r) is not getatt
-0002a940: 7228 4172 7261 792c 2061 7474 7229 5d0a  r(Array, attr)].
-0002a950: 2020 2020 2020 2020 6966 2077 6172 6e3a          if warn:
-0002a960: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
-0002a970: 6e74 2827 5b21 5d20 7b7d 2073 686f 756c  nt('[!] {} shoul
-0002a980: 6420 6e6f 7420 6465 6669 6e65 207b 7d27  d not define {}'
-0002a990: 2e66 6f72 6d61 7428 636c 732e 5f5f 6e61  .format(cls.__na
-0002a9a0: 6d65 5f5f 2c20 272c 2027 2e6a 6f69 6e28  me__, ', '.join(
-0002a9b0: 7761 726e 2929 290a 2020 2020 2020 2020  warn))).        
-0002a9c0: 6d69 7373 696e 6720 3d20 5b61 7474 7220  missing = [attr 
-0002a9d0: 666f 7220 6174 7472 2069 6e20 6174 7472  for attr in attr
-0002a9e0: 735b 692b 313a 5d20 6966 206e 6f74 2067  s[i+1:] if not g
-0002a9f0: 6574 6174 7472 2863 6c73 2c20 6174 7472  etattr(cls, attr
-0002aa00: 2920 6973 206e 6f74 2067 6574 6174 7472  ) is not getattr
-0002aa10: 2841 7272 6179 2c20 6174 7472 295d 0a20  (Array, attr)]. 
-0002aa20: 2020 2020 2020 2069 6620 6d69 7373 696e         if missin
-0002aa30: 673a 0a20 2020 2020 2020 2020 2020 2070  g:.            p
-0002aa40: 7269 6e74 2827 5b20 5d20 7b7d 2063 6f75  rint('[ ] {} cou
-0002aa50: 6c64 2064 6566 696e 6520 7b7d 272e 666f  ld define {}'.fo
-0002aa60: 726d 6174 2863 6c73 2e5f 5f6e 616d 655f  rmat(cls.__name_
-0002aa70: 5f2c 2027 2c20 272e 6a6f 696e 286d 6973  _, ', '.join(mis
-0002aa80: 7369 6e67 2929 290a 0a23 2076 696d 3a73  sing)))..# vim:s
-0002aa90: 773d 323a 7374 733d 323a 6574 0a         w=2:sts=2:et.
+00013b60: 7572 6e20 616c 6967 6e28 5461 6b65 2873  urn align(Take(s
+00013b70: 656c 662e 6675 6e63 2c20 756e 616c 6967  elf.func, unalig
+00013b80: 6e65 6429 2c20 282a 7261 6e67 6528 6e29  ned), (*range(n)
+00013b90: 2c20 2a28 6e2b 6920 666f 7220 6920 696e  , *(n+i for i in
+00013ba0: 2077 6865 7265 2929 2c20 7365 6c66 2e73   where)), self.s
+00013bb0: 6861 7065 290a 2020 2020 2020 2020 7472  hape).        tr
+00013bc0: 7974 616b 6520 3d20 7365 6c66 2e66 756e  ytake = self.fun
+00013bd0: 632e 5f74 616b 6528 7365 6c66 2e69 6e64  c._take(self.ind
+00013be0: 6963 6573 2c20 7365 6c66 2e66 756e 632e  ices, self.func.
+00013bf0: 6e64 696d 2d31 2920 6f72 205c 0a20 2020  ndim-1) or \.   
+00013c00: 2020 2020 2020 2020 2073 656c 662e 696e           self.in
+00013c10: 6469 6365 732e 5f72 7461 6b65 2873 656c  dices._rtake(sel
+00013c20: 662e 6675 6e63 2c20 7365 6c66 2e66 756e  f.func, self.fun
+00013c30: 632e 6e64 696d 2d31 290a 2020 2020 2020  c.ndim-1).      
+00013c40: 2020 6966 2074 7279 7461 6b65 3a0a 2020    if trytake:.  
+00013c50: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00013c60: 2074 7279 7461 6b65 0a20 2020 2020 2020   trytake.       
+00013c70: 2066 6f72 2061 7869 732c 2070 6172 7473   for axis, parts
+00013c80: 2069 6e20 7365 6c66 2e66 756e 632e 5f69   in self.func._i
+00013c90: 6e66 6c61 7469 6f6e 733a 0a20 2020 2020  nflations:.     
+00013ca0: 2020 2020 2020 2069 6620 6178 6973 203d         if axis =
+00013cb0: 3d20 7365 6c66 2e66 756e 632e 6e64 696d  = self.func.ndim
+00013cc0: 202d 2031 3a0a 2020 2020 2020 2020 2020   - 1:.          
+00013cd0: 2020 2020 2020 7265 7475 726e 2075 7469        return uti
+00013ce0: 6c2e 7375 6d28 496e 666c 6174 6528 6675  l.sum(Inflate(fu
+00013cf0: 6e63 2c20 646f 666d 6170 2c20 7365 6c66  nc, dofmap, self
+00013d00: 2e66 756e 632e 7368 6170 655b 2d31 5d29  .func.shape[-1])
+00013d10: 2e5f 7461 6b65 2873 656c 662e 696e 6469  ._take(self.indi
+00013d20: 6365 732c 2073 656c 662e 6675 6e63 2e6e  ces, self.func.n
+00013d30: 6469 6d20 2d20 3129 2066 6f72 2064 6f66  dim - 1) for dof
+00013d40: 6d61 702c 2066 756e 6320 696e 2070 6172  map, func in par
+00013d50: 7473 2e69 7465 6d73 2829 290a 0a20 2020  ts.items())..   
+00013d60: 2040 7374 6174 6963 6d65 7468 6f64 0a20   @staticmethod. 
+00013d70: 2020 2064 6566 2065 7661 6c66 2861 7272     def evalf(arr
+00013d80: 2c20 696e 6469 6365 7329 3a0a 2020 2020  , indices):.    
+00013d90: 2020 2020 7265 7475 726e 2061 7272 5b2e      return arr[.
+00013da0: 2e2e 2c20 696e 6469 6365 735d 0a0a 2020  .., indices]..  
+00013db0: 2020 6465 6620 5f64 6572 6976 6174 6976    def _derivativ
+00013dc0: 6528 7365 6c66 2c20 7661 722c 2073 6565  e(self, var, see
+00013dd0: 6e29 3a0a 2020 2020 2020 2020 7265 7475  n):.        retu
+00013de0: 726e 205f 7461 6b65 2864 6572 6976 6174  rn _take(derivat
+00013df0: 6976 6528 7365 6c66 2e66 756e 632c 2076  ive(self.func, v
+00013e00: 6172 2c20 7365 656e 292c 2073 656c 662e  ar, seen), self.
+00013e10: 696e 6469 6365 732c 2073 656c 662e 6675  indices, self.fu
+00013e20: 6e63 2e6e 6469 6d2d 3129 0a0a 2020 2020  nc.ndim-1)..    
+00013e30: 6465 6620 5f74 616b 6528 7365 6c66 2c20  def _take(self, 
+00013e40: 696e 6465 782c 2061 7869 7329 3a0a 2020  index, axis):.  
+00013e50: 2020 2020 2020 6966 2061 7869 7320 3e3d        if axis >=
+00013e60: 2073 656c 662e 6675 6e63 2e6e 6469 6d2d   self.func.ndim-
+00013e70: 313a 0a20 2020 2020 2020 2020 2020 2072  1:.            r
+00013e80: 6574 7572 6e20 5461 6b65 2873 656c 662e  eturn Take(self.
+00013e90: 6675 6e63 2c20 5f74 616b 6528 7365 6c66  func, _take(self
+00013ea0: 2e69 6e64 6963 6573 2c20 696e 6465 782c  .indices, index,
+00013eb0: 2061 7869 732d 7365 6c66 2e66 756e 632e   axis-self.func.
+00013ec0: 6e64 696d 2b31 2929 0a20 2020 2020 2020  ndim+1)).       
+00013ed0: 2074 7279 7461 6b65 203d 2073 656c 662e   trytake = self.
+00013ee0: 6675 6e63 2e5f 7461 6b65 2869 6e64 6578  func._take(index
+00013ef0: 2c20 6178 6973 290a 2020 2020 2020 2020  , axis).        
+00013f00: 6966 2074 7279 7461 6b65 2069 7320 6e6f  if trytake is no
+00013f10: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+00013f20: 2020 2020 7265 7475 726e 2054 616b 6528      return Take(
+00013f30: 7472 7974 616b 652c 2073 656c 662e 696e  trytake, self.in
+00013f40: 6469 6365 7329 0a0a 2020 2020 6465 6620  dices)..    def 
+00013f50: 5f73 756d 2873 656c 662c 2061 7869 7329  _sum(self, axis)
+00013f60: 3a0a 2020 2020 2020 2020 6966 2061 7869  :.        if axi
+00013f70: 7320 3c20 7365 6c66 2e66 756e 632e 6e64  s < self.func.nd
+00013f80: 696d 202d 2031 3a0a 2020 2020 2020 2020  im - 1:.        
+00013f90: 2020 2020 7265 7475 726e 2054 616b 6528      return Take(
+00013fa0: 7375 6d28 7365 6c66 2e66 756e 632c 2061  sum(self.func, a
+00013fb0: 7869 7329 2c20 7365 6c66 2e69 6e64 6963  xis), self.indic
+00013fc0: 6573 290a 0a20 2020 2064 6566 205f 696e  es)..    def _in
+00013fd0: 7462 6f75 6e64 735f 696d 706c 2873 656c  tbounds_impl(sel
+00013fe0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+00013ff0: 726e 2073 656c 662e 6675 6e63 2e5f 696e  rn self.func._in
+00014000: 7462 6f75 6e64 730a 0a0a 636c 6173 7320  tbounds...class 
+00014010: 506f 7765 7228 4172 7261 7929 3a0a 0a20  Power(Array):.. 
+00014020: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
+00014030: 7365 6c66 2c20 6675 6e63 3a20 4172 7261  self, func: Arra
+00014040: 792c 2070 6f77 6572 3a20 4172 7261 7929  y, power: Array)
+00014050: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
+00014060: 2069 7369 6e73 7461 6e63 6528 6675 6e63   isinstance(func
+00014070: 2c20 4172 7261 7929 2c20 6627 6675 6e63  , Array), f'func
+00014080: 3d7b 6675 6e63 2172 7d27 0a20 2020 2020  ={func!r}'.     
+00014090: 2020 2061 7373 6572 7420 6973 696e 7374     assert isinst
+000140a0: 616e 6365 2870 6f77 6572 2c20 4172 7261  ance(power, Arra
+000140b0: 7929 2061 6e64 2028 706f 7765 722e 6474  y) and (power.dt
+000140c0: 7970 6520 696e 2028 666c 6f61 742c 2063  ype in (float, c
+000140d0: 6f6d 706c 6578 2920 6f72 2070 6f77 6572  omplex) or power
+000140e0: 2e64 7479 7065 203d 3d20 696e 7420 616e  .dtype == int an
+000140f0: 6420 706f 7765 722e 5f69 6e74 626f 756e  d power._intboun
+00014100: 6473 5b30 5d20 3e3d 2030 292c 2066 2770  ds[0] >= 0), f'p
+00014110: 6f77 6572 3d7b 706f 7765 7221 727d 270a  ower={power!r}'.
+00014120: 2020 2020 2020 2020 6173 7365 7274 2065          assert e
+00014130: 7175 616c 7368 6170 6528 6675 6e63 2e73  qualshape(func.s
+00014140: 6861 7065 2c20 706f 7765 722e 7368 6170  hape, power.shap
+00014150: 6529 2061 6e64 2066 756e 632e 6474 7970  e) and func.dtyp
+00014160: 6520 3d3d 2070 6f77 6572 2e64 7479 7065  e == power.dtype
+00014170: 2c20 2750 6f77 6572 287b 7d2c 207b 7d29  , 'Power({}, {})
+00014180: 272e 666f 726d 6174 2866 756e 632c 2070  '.format(func, p
+00014190: 6f77 6572 290a 2020 2020 2020 2020 7365  ower).        se
+000141a0: 6c66 2e66 756e 6320 3d20 6675 6e63 0a20  lf.func = func. 
+000141b0: 2020 2020 2020 2073 656c 662e 706f 7765         self.powe
+000141c0: 7220 3d20 706f 7765 720a 2020 2020 2020  r = power.      
+000141d0: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
+000141e0: 5f5f 2861 7267 733d 2866 756e 632c 2070  __(args=(func, p
+000141f0: 6f77 6572 292c 2073 6861 7065 3d66 756e  ower), shape=fun
+00014200: 632e 7368 6170 652c 2064 7479 7065 3d66  c.shape, dtype=f
+00014210: 756e 632e 6474 7970 6529 0a0a 2020 2020  unc.dtype)..    
+00014220: 6465 6620 5f73 696d 706c 6966 6965 6428  def _simplified(
+00014230: 7365 6c66 293a 0a20 2020 2020 2020 2069  self):.        i
+00014240: 6620 6973 7a65 726f 2873 656c 662e 706f  f iszero(self.po
+00014250: 7765 7229 3a0a 2020 2020 2020 2020 2020  wer):.          
+00014260: 2020 7265 7475 726e 206f 6e65 735f 6c69    return ones_li
+00014270: 6b65 2873 656c 6629 0a20 2020 2020 2020  ke(self).       
+00014280: 2070 203d 2073 656c 662e 706f 7765 722e   p = self.power.
+00014290: 5f63 6f6e 7374 5f75 6e69 666f 726d 0a20  _const_uniform. 
+000142a0: 2020 2020 2020 2069 6620 7020 3d3d 2031         if p == 1
+000142b0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+000142c0: 7475 726e 2073 656c 662e 6675 6e63 0a20  turn self.func. 
+000142d0: 2020 2020 2020 2065 6c69 6620 7020 3d3d         elif p ==
+000142e0: 2032 3a0a 2020 2020 2020 2020 2020 2020   2:.            
+000142f0: 7265 7475 726e 2073 656c 662e 6675 6e63  return self.func
+00014300: 202a 2073 656c 662e 6675 6e63 0a20 2020   * self.func.   
+00014310: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00014320: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00014330: 6c66 2e66 756e 632e 5f70 6f77 6572 2873  lf.func._power(s
+00014340: 656c 662e 706f 7765 7229 0a0a 2020 2020  elf.power)..    
+00014350: 6465 6620 5f6f 7074 696d 697a 6564 5f66  def _optimized_f
+00014360: 6f72 5f6e 756d 7079 2873 656c 6629 3a0a  or_numpy(self):.
+00014370: 2020 2020 2020 2020 7020 3d20 7365 6c66          p = self
+00014380: 2e70 6f77 6572 2e5f 636f 6e73 745f 756e  .power._const_un
+00014390: 6966 6f72 6d0a 2020 2020 2020 2020 6966  iform.        if
+000143a0: 2070 203d 3d20 2d31 3a0a 2020 2020 2020   p == -1:.      
+000143b0: 2020 2020 2020 7265 7475 726e 2052 6563        return Rec
+000143c0: 6970 726f 6361 6c28 7365 6c66 2e66 756e  iprocal(self.fun
+000143d0: 6329 0a20 2020 2020 2020 2065 6c69 6620  c).        elif 
+000143e0: 7020 3d3d 202d 323a 0a20 2020 2020 2020  p == -2:.       
+000143f0: 2020 2020 2072 6574 7572 6e20 5265 6369       return Reci
+00014400: 7072 6f63 616c 2873 656c 662e 6675 6e63  procal(self.func
+00014410: 202a 2073 656c 662e 6675 6e63 290a 2020   * self.func).  
+00014420: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00014430: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00014440: 656c 662e 5f73 696d 706c 6966 6965 6428  elf._simplified(
+00014450: 290a 0a20 2020 2065 7661 6c66 203d 2073  )..    evalf = s
+00014460: 7461 7469 636d 6574 686f 6428 6e75 6d70  taticmethod(nump
+00014470: 792e 706f 7765 7229 0a0a 2020 2020 6465  y.power)..    de
+00014480: 6620 5f64 6572 6976 6174 6976 6528 7365  f _derivative(se
+00014490: 6c66 2c20 7661 722c 2073 6565 6e29 3a0a  lf, var, seen):.
+000144a0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+000144b0: 706f 7765 722e 6973 636f 6e73 7461 6e74  power.isconstant
+000144c0: 3a0a 2020 2020 2020 2020 2020 2020 7020  :.            p 
+000144d0: 3d20 7365 6c66 2e70 6f77 6572 2e65 7661  = self.power.eva
+000144e0: 6c28 290a 2020 2020 2020 2020 2020 2020  l().            
+000144f0: 7265 7475 726e 2065 696e 7375 6d28 2741  return einsum('A
+00014500: 2c41 2c41 422d 3e41 4227 2c20 636f 6e73  ,A,AB->AB', cons
+00014510: 7461 6e74 2870 292c 2070 6f77 6572 2873  tant(p), power(s
+00014520: 656c 662e 6675 6e63 2c20 7020 2d20 2870  elf.func, p - (p
+00014530: 2021 3d20 3029 292c 2064 6572 6976 6174   != 0)), derivat
+00014540: 6976 6528 7365 6c66 2e66 756e 632c 2076  ive(self.func, v
+00014550: 6172 2c20 7365 656e 2929 0a20 2020 2020  ar, seen)).     
+00014560: 2020 2069 6620 7365 6c66 2e64 7479 7065     if self.dtype
+00014570: 203d 3d20 636f 6d70 6c65 783a 0a20 2020   == complex:.   
+00014580: 2020 2020 2020 2020 2072 6169 7365 204e           raise N
+00014590: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
+000145a0: 6f72 2827 5468 6520 636f 6d70 6c65 7820  or('The complex 
+000145b0: 6465 7269 7661 7469 7665 2069 7320 6e6f  derivative is no
+000145c0: 7420 696d 706c 656d 656e 7465 642e 2729  t implemented.')
+000145d0: 0a20 2020 2020 2020 2023 2073 656c 6620  .        # self 
+000145e0: 3d20 6675 6e63 2a2a 706f 7765 720a 2020  = func**power.  
+000145f0: 2020 2020 2020 2320 6c6e 2073 656c 6620        # ln self 
+00014600: 3d20 706f 7765 7220 2a20 6c6e 2066 756e  = power * ln fun
+00014610: 630a 2020 2020 2020 2020 2320 7365 6c66  c.        # self
+00014620: 6020 2f20 7365 6c66 203d 2070 6f77 6572  ` / self = power
+00014630: 6020 2a20 6c6e 2066 756e 6320 2b20 706f  ` * ln func + po
+00014640: 7765 7220 2a20 6675 6e63 6020 2f20 6675  wer * func` / fu
+00014650: 6e63 0a20 2020 2020 2020 2023 2073 656c  nc.        # sel
+00014660: 6660 203d 2070 6f77 6572 6020 2a20 6c6e  f` = power` * ln
+00014670: 2066 756e 6320 2a20 7365 6c66 202b 2070   func * self + p
+00014680: 6f77 6572 202a 2066 756e 6360 202a 2066  ower * func` * f
+00014690: 756e 632a 2a28 706f 7765 722d 3129 0a20  unc**(power-1). 
+000146a0: 2020 2020 2020 2072 6574 7572 6e20 6569         return ei
+000146b0: 6e73 756d 2827 412c 412c 4142 2d3e 4142  nsum('A,A,AB->AB
+000146c0: 272c 2073 656c 662e 706f 7765 722c 2070  ', self.power, p
+000146d0: 6f77 6572 2873 656c 662e 6675 6e63 2c20  ower(self.func, 
+000146e0: 7365 6c66 2e70 6f77 6572 202d 2031 292c  self.power - 1),
+000146f0: 2064 6572 6976 6174 6976 6528 7365 6c66   derivative(self
+00014700: 2e66 756e 632c 2076 6172 2c20 7365 656e  .func, var, seen
+00014710: 2929 205c 0a20 2020 2020 2020 2020 2020  )) \.           
+00014720: 202b 2065 696e 7375 6d28 2741 2c41 2c41   + einsum('A,A,A
+00014730: 422d 3e41 4227 2c20 6c6e 2873 656c 662e  B->AB', ln(self.
+00014740: 6675 6e63 292c 2073 656c 662c 2064 6572  func), self, der
+00014750: 6976 6174 6976 6528 7365 6c66 2e70 6f77  ivative(self.pow
+00014760: 6572 2c20 7661 722c 2073 6565 6e29 290a  er, var, seen)).
+00014770: 0a20 2020 2064 6566 205f 706f 7765 7228  .    def _power(
+00014780: 7365 6c66 2c20 6e29 3a0a 2020 2020 2020  self, n):.      
+00014790: 2020 6966 2073 656c 662e 6474 7970 6520    if self.dtype 
+000147a0: 3d3d 2063 6f6d 706c 6578 206f 7220 6e2e  == complex or n.
+000147b0: 6474 7970 6520 3d3d 2063 6f6d 706c 6578  dtype == complex
+000147c0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+000147d0: 7475 726e 0a20 2020 2020 2020 2066 756e  turn.        fun
+000147e0: 6320 3d20 7365 6c66 2e66 756e 630a 2020  c = self.func.  
+000147f0: 2020 2020 2020 6e65 7770 6f77 6572 203d        newpower =
+00014800: 206d 756c 7469 706c 7928 7365 6c66 2e70   multiply(self.p
+00014810: 6f77 6572 2c20 6e29 0a20 2020 2020 2020  ower, n).       
+00014820: 2069 6620 6973 7a65 726f 2873 656c 662e   if iszero(self.
+00014830: 706f 7765 7220 2520 3229 2061 6e64 206e  power % 2) and n
+00014840: 6f74 2069 737a 6572 6f28 6e65 7770 6f77  ot iszero(newpow
+00014850: 6572 2025 2032 293a 0a20 2020 2020 2020  er % 2):.       
+00014860: 2020 2020 2066 756e 6320 3d20 6162 7328       func = abs(
+00014870: 6675 6e63 290a 2020 2020 2020 2020 7265  func).        re
+00014880: 7475 726e 2050 6f77 6572 2866 756e 632c  turn Power(func,
+00014890: 206e 6577 706f 7765 7229 0a0a 2020 2020   newpower)..    
+000148a0: 6465 6620 5f74 616b 6564 6961 6728 7365  def _takediag(se
+000148b0: 6c66 2c20 6178 6973 312c 2061 7869 7332  lf, axis1, axis2
+000148c0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+000148d0: 6e20 506f 7765 7228 5f74 616b 6564 6961  n Power(_takedia
+000148e0: 6728 7365 6c66 2e66 756e 632c 2061 7869  g(self.func, axi
+000148f0: 7331 2c20 6178 6973 3229 2c20 5f74 616b  s1, axis2), _tak
+00014900: 6564 6961 6728 7365 6c66 2e70 6f77 6572  ediag(self.power
+00014910: 2c20 6178 6973 312c 2061 7869 7332 2929  , axis1, axis2))
+00014920: 0a0a 2020 2020 6465 6620 5f74 616b 6528  ..    def _take(
+00014930: 7365 6c66 2c20 696e 6465 782c 2061 7869  self, index, axi
+00014940: 7329 3a0a 2020 2020 2020 2020 7265 7475  s):.        retu
+00014950: 726e 2050 6f77 6572 285f 7461 6b65 2873  rn Power(_take(s
+00014960: 656c 662e 6675 6e63 2c20 696e 6465 782c  elf.func, index,
+00014970: 2061 7869 7329 2c20 5f74 616b 6528 7365   axis), _take(se
+00014980: 6c66 2e70 6f77 6572 2c20 696e 6465 782c  lf.power, index,
+00014990: 2061 7869 7329 290a 0a20 2020 2064 6566   axis))..    def
+000149a0: 205f 756e 7261 7665 6c28 7365 6c66 2c20   _unravel(self, 
+000149b0: 6178 6973 2c20 7368 6170 6529 3a0a 2020  axis, shape):.  
+000149c0: 2020 2020 2020 7265 7475 726e 2050 6f77        return Pow
+000149d0: 6572 2875 6e72 6176 656c 2873 656c 662e  er(unravel(self.
+000149e0: 6675 6e63 2c20 6178 6973 2c20 7368 6170  func, axis, shap
+000149f0: 6529 2c20 756e 7261 7665 6c28 7365 6c66  e), unravel(self
+00014a00: 2e70 6f77 6572 2c20 6178 6973 2c20 7368  .power, axis, sh
+00014a10: 6170 6529 290a 0a0a 636c 6173 7320 506f  ape))...class Po
+00014a20: 696e 7477 6973 6528 4172 7261 7929 3a0a  intwise(Array):.
+00014a30: 2020 2020 2727 270a 2020 2020 4162 7374      '''.    Abst
+00014a40: 7261 6374 2062 6173 6520 636c 6173 7320  ract base class 
+00014a50: 666f 7220 706f 696e 7477 6973 6520 6172  for pointwise ar
+00014a60: 7261 7920 6675 6e63 7469 6f6e 732e 0a20  ray functions.. 
+00014a70: 2020 2027 2727 0a0a 2020 2020 6465 7269     '''..    deri
+00014a80: 7620 3d20 4e6f 6e65 0a20 2020 2063 6f6d  v = None.    com
+00014a90: 706c 6578 5f64 6572 6976 203d 204e 6f6e  plex_deriv = Non
+00014aa0: 650a 2020 2020 7265 7475 726e 5f74 7970  e.    return_typ
+00014ab0: 6520 3d20 4e6f 6e65 0a0a 2020 2020 6465  e = None..    de
+00014ac0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
+00014ad0: 202a 6172 6773 3a20 4172 7261 792c 202a   *args: Array, *
+00014ae0: 2a70 6172 616d 7329 3a0a 2020 2020 2020  *params):.      
+00014af0: 2020 6173 7365 7274 2061 6c6c 2869 7369    assert all(isi
+00014b00: 6e73 7461 6e63 6528 6172 672c 2041 7272  nstance(arg, Arr
+00014b10: 6179 2920 666f 7220 6172 6720 696e 2061  ay) for arg in a
+00014b20: 7267 7329 2c20 6627 6172 6773 3d7b 6172  rgs), f'args={ar
+00014b30: 6773 2172 7d27 0a20 2020 2020 2020 2064  gs!r}'.        d
+00014b40: 7479 7065 203d 2073 656c 662e 5f5f 636c  type = self.__cl
+00014b50: 6173 735f 5f2e 7265 7475 726e 5f74 7970  ass__.return_typ
+00014b60: 6528 2a5b 6172 672e 6474 7970 6520 666f  e(*[arg.dtype fo
+00014b70: 7220 6172 6720 696e 2061 7267 735d 2c20  r arg in args], 
+00014b80: 2a2a 7061 7261 6d73 290a 2020 2020 2020  **params).      
+00014b90: 2020 7368 6170 6530 203d 2061 7267 735b    shape0 = args[
+00014ba0: 305d 2e73 6861 7065 0a20 2020 2020 2020  0].shape.       
+00014bb0: 2061 7373 6572 7420 616c 6c28 6571 7561   assert all(equa
+00014bc0: 6c73 6861 7065 2861 7267 2e73 6861 7065  lshape(arg.shape
+00014bd0: 2c20 7368 6170 6530 2920 666f 7220 6172  , shape0) for ar
+00014be0: 6720 696e 2061 7267 735b 313a 5d29 2c20  g in args[1:]), 
+00014bf0: 2770 6f69 6e74 7769 7365 2061 7267 756d  'pointwise argum
+00014c00: 656e 7473 2068 6176 6520 696e 636f 6e73  ents have incons
+00014c10: 6973 7465 6e74 2073 6861 7065 7327 0a20  istent shapes'. 
+00014c20: 2020 2020 2020 2073 656c 662e 6172 6773         self.args
+00014c30: 203d 2061 7267 730a 2020 2020 2020 2020   = args.        
+00014c40: 7365 6c66 2e70 6172 616d 7320 3d20 7061  self.params = pa
+00014c50: 7261 6d73 0a20 2020 2020 2020 2069 6620  rams.        if 
+00014c60: 7061 7261 6d73 3a0a 2020 2020 2020 2020  params:.        
+00014c70: 2020 2020 7365 6c66 2e65 7661 6c66 203d      self.evalf =
+00014c80: 2066 756e 6374 6f6f 6c73 2e70 6172 7469   functools.parti
+00014c90: 616c 2873 656c 662e 6576 616c 662c 202a  al(self.evalf, *
+00014ca0: 2a70 6172 616d 7329 0a20 2020 2020 2020  *params).       
+00014cb0: 2073 7570 6572 2829 2e5f 5f69 6e69 745f   super().__init_
+00014cc0: 5f28 6172 6773 3d61 7267 732c 2073 6861  _(args=args, sha
+00014cd0: 7065 3d73 6861 7065 302c 2064 7479 7065  pe=shape0, dtype
+00014ce0: 3d64 7479 7065 290a 0a20 2020 2064 6566  =dtype)..    def
+00014cf0: 205f 6e65 7761 7267 7328 7365 6c66 2c20   _newargs(self, 
+00014d00: 2a61 7267 7329 3a0a 2020 2020 2020 2020  *args):.        
+00014d10: 2727 270a 2020 2020 2020 2020 5265 696e  '''.        Rein
+00014d20: 7374 616e 7469 6174 6520 7365 6c66 2077  stantiate self w
+00014d30: 6974 6820 6469 6666 6572 656e 7420 6172  ith different ar
+00014d40: 6775 6d65 6e74 732e 2050 6172 616d 6574  guments. Paramet
+00014d50: 6572 7320 6172 6520 7072 6573 6572 7665  ers are preserve
+00014d60: 642c 0a20 2020 2020 2020 2061 7320 7468  d,.        as th
+00014d70: 6573 6520 6172 6520 636f 6e73 6964 6572  ese are consider
+00014d80: 6564 2070 6172 7420 6f66 2074 6865 2074  ed part of the t
+00014d90: 7970 652e 0a20 2020 2020 2020 2027 2727  ype..        '''
+00014da0: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+00014db0: 2073 656c 662e 5f5f 636c 6173 735f 5f28   self.__class__(
+00014dc0: 2a61 7267 732c 202a 2a73 656c 662e 7061  *args, **self.pa
+00014dd0: 7261 6d73 290a 0a20 2020 2040 636c 6173  rams)..    @clas
+00014de0: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
+00014df0: 6f75 7465 7228 636c 732c 202a 6172 6773  outer(cls, *args
+00014e00: 293a 0a20 2020 2020 2020 2027 2727 416c  ):.        '''Al
+00014e10: 7465 726e 6174 6976 6520 636f 6e73 7472  ternative constr
+00014e20: 7563 746f 7220 7468 6174 206f 7574 6572  uctor that outer
+00014e30: 2d61 6c69 676e 7320 7468 6520 6172 6775  -aligns the argu
+00014e40: 6d65 6e74 732e 0a0a 2020 2020 2020 2020  ments...        
+00014e50: 5468 6520 6f75 7470 7574 2073 6861 7065  The output shape
+00014e60: 206f 6620 7468 6973 2070 6f69 6e74 7769   of this pointwi
+00014e70: 7365 2066 756e 6374 696f 6e20 6973 2074  se function is t
+00014e80: 6865 2073 756d 206f 6620 616c 6c20 7368  he sum of all sh
+00014e90: 6170 6573 206f 6620 6974 730a 2020 2020  apes of its.    
+00014ea0: 2020 2020 6172 6775 6d65 6e74 732e 2057      arguments. W
+00014eb0: 6865 6e20 6361 6c6c 6564 2077 6974 6820  hen called with 
+00014ec0: 6d75 6c74 6970 6c65 2061 7267 756d 656e  multiple argumen
+00014ed0: 7473 2c20 7468 6520 6669 7273 7420 6172  ts, the first ar
+00014ee0: 6775 6d65 6e74 2077 696c 6c20 6265 0a20  gument will be. 
+00014ef0: 2020 2020 2020 2061 7070 656e 6465 6420         appended 
+00014f00: 7769 7468 2073 696e 676c 6574 6f6e 2061  with singleton a
+00014f10: 7865 7320 746f 206d 6174 6368 2074 6865  xes to match the
+00014f20: 206f 7574 7075 7420 7368 6170 652c 2074   output shape, t
+00014f30: 6865 2073 6563 6f6e 6420 6172 6775 6d65  he second argume
+00014f40: 6e74 0a20 2020 2020 2020 2077 696c 6c20  nt.        will 
+00014f50: 6265 2070 7265 7065 6e64 6564 2077 6974  be prepended wit
+00014f60: 6820 6173 206d 616e 7920 7369 6e67 6c65  h as many single
+00014f70: 746f 6e20 6178 6573 2061 7320 7468 6520  ton axes as the 
+00014f80: 6469 6d65 6e73 696f 6e20 6f66 2074 6865  dimension of the
+00014f90: 0a20 2020 2020 2020 206f 7269 6769 6e61  .        origina
+00014fa0: 6c20 6669 7273 7420 6172 6775 6d65 6e74  l first argument
+00014fb0: 2061 6e64 2061 7070 656e 6465 6420 746f   and appended to
+00014fc0: 206d 6174 6368 2074 6865 206f 7574 7075   match the outpu
+00014fd0: 7420 7368 6170 652c 2061 6e64 2073 6f0a  t shape, and so.
+00014fe0: 2020 2020 2020 2020 666f 7274 6820 616e          forth an
+00014ff0: 6420 736f 206f 6e2e 0a20 2020 2020 2020  d so on..       
+00015000: 2027 2727 0a0a 2020 2020 2020 2020 6172   '''..        ar
+00015010: 6773 203d 2074 7570 6c65 286d 6170 2861  gs = tuple(map(a
+00015020: 7361 7272 6179 2c20 6172 6773 2929 0a20  sarray, args)). 
+00015030: 2020 2020 2020 2073 6861 7065 203d 2062         shape = b
+00015040: 7569 6c74 696e 732e 7375 6d28 2861 7267  uiltins.sum((arg
+00015050: 2e73 6861 7065 2066 6f72 2061 7267 2069  .shape for arg i
+00015060: 6e20 6172 6773 292c 2028 2929 0a20 2020  n args), ()).   
+00015070: 2020 2020 206f 6666 7365 7473 203d 206e       offsets = n
+00015080: 756d 7079 2e63 756d 7375 6d28 5b30 5d2b  umpy.cumsum([0]+
+00015090: 5b61 7267 2e6e 6469 6d20 666f 7220 6172  [arg.ndim for ar
+000150a0: 6720 696e 2061 7267 735d 290a 2020 2020  g in args]).    
+000150b0: 2020 2020 7265 7475 726e 2063 6c73 282a      return cls(*
+000150c0: 2870 7265 7065 6e64 6178 6573 2861 7070  (prependaxes(app
+000150d0: 656e 6461 7865 7328 6172 672c 2073 6861  endaxes(arg, sha
+000150e0: 7065 5b72 3a5d 292c 2073 6861 7065 5b3a  pe[r:]), shape[:
+000150f0: 6c5d 2920 666f 7220 6172 672c 206c 2c20  l]) for arg, l, 
+00015100: 7220 696e 207a 6970 2861 7267 732c 206f  r in zip(args, o
+00015110: 6666 7365 7473 5b3a 2d31 5d2c 206f 6666  ffsets[:-1], off
+00015120: 7365 7473 5b31 3a5d 2929 290a 0a20 2020  sets[1:])))..   
+00015130: 2064 6566 205f 7369 6d70 6c69 6669 6564   def _simplified
+00015140: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00015150: 6966 206c 656e 2873 656c 662e 6172 6773  if len(self.args
+00015160: 2920 3d3d 2031 2061 6e64 2069 7369 6e73  ) == 1 and isins
+00015170: 7461 6e63 6528 7365 6c66 2e61 7267 735b  tance(self.args[
+00015180: 305d 2c20 5472 616e 7370 6f73 6529 3a0a  0], Transpose):.
+00015190: 2020 2020 2020 2020 2020 2020 6172 672c              arg,
+000151a0: 203d 2073 656c 662e 6172 6773 0a20 2020   = self.args.   
+000151b0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000151c0: 5472 616e 7370 6f73 6528 7365 6c66 2e5f  Transpose(self._
+000151d0: 6e65 7761 7267 7328 6172 672e 6675 6e63  newargs(arg.func
+000151e0: 292c 2061 7267 2e61 7865 7329 0a20 2020  ), arg.axes).   
+000151f0: 2020 2020 202a 756e 696e 7365 7274 6564       *uninserted
+00015200: 2c20 7768 6572 6520 3d20 756e 616c 6967  , where = unalig
+00015210: 6e28 2a73 656c 662e 6172 6773 290a 2020  n(*self.args).  
+00015220: 2020 2020 2020 6966 206c 656e 2877 6865        if len(whe
+00015230: 7265 2920 213d 2073 656c 662e 6e64 696d  re) != self.ndim
+00015240: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00015250: 7475 726e 2061 6c69 676e 2873 656c 662e  turn align(self.
+00015260: 5f6e 6577 6172 6773 282a 756e 696e 7365  _newargs(*uninse
+00015270: 7274 6564 292c 2077 6865 7265 2c20 7365  rted), where, se
+00015280: 6c66 2e73 6861 7065 290a 0a20 2020 2064  lf.shape)..    d
+00015290: 6566 205f 6f70 7469 6d69 7a65 645f 666f  ef _optimized_fo
+000152a0: 725f 6e75 6d70 7928 7365 6c66 293a 0a20  r_numpy(self):. 
+000152b0: 2020 2020 2020 2069 6620 7365 6c66 2e69         if self.i
+000152c0: 7363 6f6e 7374 616e 743a 0a20 2020 2020  sconstant:.     
+000152d0: 2020 2020 2020 2072 6574 7661 6c20 3d20         retval = 
+000152e0: 7365 6c66 2e65 7661 6c28 290a 2020 2020  self.eval().    
+000152f0: 2020 2020 2020 2020 7265 7475 726e 2063          return c
+00015300: 6f6e 7374 616e 7428 7265 7476 616c 290a  onstant(retval).
+00015310: 0a20 2020 2064 6566 205f 6465 7269 7661  .    def _deriva
+00015320: 7469 7665 2873 656c 662c 2076 6172 2c20  tive(self, var, 
+00015330: 7365 656e 293a 0a20 2020 2020 2020 2069  seen):.        i
+00015340: 6620 7365 6c66 2e63 6f6d 706c 6578 5f64  f self.complex_d
+00015350: 6572 6976 2069 7320 6e6f 7420 4e6f 6e65  eriv is not None
+00015360: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00015370: 7475 726e 2075 7469 6c2e 7375 6d28 6569  turn util.sum(ei
+00015380: 6e73 756d 2827 412c 4142 2d3e 4142 272c  nsum('A,AB->AB',
+00015390: 2064 6572 6976 282a 7365 6c66 2e61 7267   deriv(*self.arg
+000153a0: 732c 202a 2a73 656c 662e 7061 7261 6d73  s, **self.params
+000153b0: 292c 2064 6572 6976 6174 6976 6528 6172  ), derivative(ar
+000153c0: 672c 2076 6172 2c20 7365 656e 2929 2066  g, var, seen)) f
+000153d0: 6f72 2061 7267 2c20 6465 7269 7620 696e  or arg, deriv in
+000153e0: 207a 6970 2873 656c 662e 6172 6773 2c20   zip(self.args, 
+000153f0: 7365 6c66 2e63 6f6d 706c 6578 5f64 6572  self.complex_der
+00015400: 6976 2929 0a20 2020 2020 2020 2065 6c69  iv)).        eli
+00015410: 6620 7365 6c66 2e64 7479 7065 203d 3d20  f self.dtype == 
+00015420: 636f 6d70 6c65 7820 6f72 2076 6172 2e64  complex or var.d
+00015430: 7479 7065 203d 3d20 636f 6d70 6c65 783a  type == complex:
+00015440: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00015450: 7365 204e 6f74 496d 706c 656d 656e 7465  se NotImplemente
+00015460: 6445 7272 6f72 2827 5468 6520 636f 6d70  dError('The comp
+00015470: 6c65 7820 6465 7269 7661 7469 7665 2069  lex derivative i
+00015480: 7320 6e6f 7420 696d 706c 656d 656e 7465  s not implemente
+00015490: 642e 2729 0a20 2020 2020 2020 2065 6c69  d.').        eli
+000154a0: 6620 7365 6c66 2e64 6572 6976 2069 7320  f self.deriv is 
+000154b0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+000154c0: 2020 2020 2020 7265 7475 726e 2075 7469        return uti
+000154d0: 6c2e 7375 6d28 6569 6e73 756d 2827 412c  l.sum(einsum('A,
+000154e0: 4142 2d3e 4142 272c 2064 6572 6976 282a  AB->AB', deriv(*
+000154f0: 7365 6c66 2e61 7267 732c 202a 2a73 656c  self.args, **sel
+00015500: 662e 7061 7261 6d73 292c 2064 6572 6976  f.params), deriv
+00015510: 6174 6976 6528 6172 672c 2076 6172 2c20  ative(arg, var, 
+00015520: 7365 656e 2929 2066 6f72 2061 7267 2c20  seen)) for arg, 
+00015530: 6465 7269 7620 696e 207a 6970 2873 656c  deriv in zip(sel
+00015540: 662e 6172 6773 2c20 7365 6c66 2e64 6572  f.args, self.der
+00015550: 6976 2929 0a20 2020 2020 2020 2065 6c73  iv)).        els
+00015560: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+00015570: 6574 7572 6e20 7375 7065 7228 292e 5f64  eturn super()._d
+00015580: 6572 6976 6174 6976 6528 7661 722c 2073  erivative(var, s
+00015590: 6565 6e29 0a0a 2020 2020 6465 6620 5f74  een)..    def _t
+000155a0: 616b 6564 6961 6728 7365 6c66 2c20 6178  akediag(self, ax
+000155b0: 6973 312c 2061 7869 7332 293a 0a20 2020  is1, axis2):.   
+000155c0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+000155d0: 2e5f 6e65 7761 7267 7328 2a5b 5f74 616b  ._newargs(*[_tak
+000155e0: 6564 6961 6728 6172 672c 2061 7869 7331  ediag(arg, axis1
+000155f0: 2c20 6178 6973 3229 2066 6f72 2061 7267  , axis2) for arg
+00015600: 2069 6e20 7365 6c66 2e61 7267 735d 290a   in self.args]).
+00015610: 0a20 2020 2064 6566 205f 7461 6b65 2873  .    def _take(s
+00015620: 656c 662c 2069 6e64 6578 2c20 6178 6973  elf, index, axis
+00015630: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00015640: 6e20 7365 6c66 2e5f 6e65 7761 7267 7328  n self._newargs(
+00015650: 2a5b 5f74 616b 6528 6172 672c 2069 6e64  *[_take(arg, ind
+00015660: 6578 2c20 6178 6973 2920 666f 7220 6172  ex, axis) for ar
+00015670: 6720 696e 2073 656c 662e 6172 6773 5d29  g in self.args])
+00015680: 0a0a 2020 2020 6465 6620 5f75 6e72 6176  ..    def _unrav
+00015690: 656c 2873 656c 662c 2061 7869 732c 2073  el(self, axis, s
+000156a0: 6861 7065 293a 0a20 2020 2020 2020 2072  hape):.        r
+000156b0: 6574 7572 6e20 7365 6c66 2e5f 6e65 7761  eturn self._newa
+000156c0: 7267 7328 2a5b 756e 7261 7665 6c28 6172  rgs(*[unravel(ar
+000156d0: 672c 2061 7869 732c 2073 6861 7065 2920  g, axis, shape) 
+000156e0: 666f 7220 6172 6720 696e 2073 656c 662e  for arg in self.
+000156f0: 6172 6773 5d29 0a0a 0a63 6c61 7373 2052  args])...class R
+00015700: 6563 6970 726f 6361 6c28 506f 696e 7477  eciprocal(Pointw
+00015710: 6973 6529 3a0a 2020 2020 6576 616c 6620  ise):.    evalf 
+00015720: 3d20 7374 6174 6963 6d65 7468 6f64 286e  = staticmethod(n
+00015730: 756d 7079 2e72 6563 6970 726f 6361 6c29  umpy.reciprocal)
+00015740: 0a20 2020 2072 6574 7572 6e5f 7479 7065  .    return_type
+00015750: 203d 206c 616d 6264 6120 543a 2063 6f6d   = lambda T: com
+00015760: 706c 6578 2069 6620 5420 3d3d 2063 6f6d  plex if T == com
+00015770: 706c 6578 2065 6c73 6520 666c 6f61 740a  plex else float.
+00015780: 0a0a 636c 6173 7320 4e65 6761 7469 7665  ..class Negative
+00015790: 2850 6f69 6e74 7769 7365 293a 0a20 2020  (Pointwise):.   
+000157a0: 2065 7661 6c66 203d 2073 7461 7469 636d   evalf = staticm
+000157b0: 6574 686f 6428 6e75 6d70 792e 6e65 6761  ethod(numpy.nega
+000157c0: 7469 7665 290a 2020 2020 6465 6620 7265  tive).    def re
+000157d0: 7475 726e 5f74 7970 6528 5429 3a0a 2020  turn_type(T):.  
+000157e0: 2020 2020 2020 6966 2054 203d 3d20 626f        if T == bo
+000157f0: 6f6c 3a0a 2020 2020 2020 2020 2020 2020  ol:.            
+00015800: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+00015810: 2827 626f 6f6c 6561 6e20 7661 6c75 6573  ('boolean values
+00015820: 2063 616e 6e6f 7420 6265 206e 6567 6174   cannot be negat
+00015830: 6564 2729 0a20 2020 2020 2020 2072 6574  ed').        ret
+00015840: 7572 6e20 540a 0a20 2020 2064 6566 205f  urn T..    def _
+00015850: 696e 7462 6f75 6e64 735f 696d 706c 2873  intbounds_impl(s
+00015860: 656c 6629 3a0a 2020 2020 2020 2020 6c6f  elf):.        lo
+00015870: 7765 722c 2075 7070 6572 203d 2073 656c  wer, upper = sel
+00015880: 662e 6172 6773 5b30 5d2e 5f69 6e74 626f  f.args[0]._intbo
+00015890: 756e 6473 0a20 2020 2020 2020 2072 6574  unds.        ret
+000158a0: 7572 6e20 2d75 7070 6572 2c20 2d6c 6f77  urn -upper, -low
+000158b0: 6572 0a0a 0a63 6c61 7373 2046 6c6f 6f72  er...class Floor
+000158c0: 4469 7669 6465 2850 6f69 6e74 7769 7365  Divide(Pointwise
+000158d0: 293a 0a20 2020 2065 7661 6c66 203d 2073  ):.    evalf = s
+000158e0: 7461 7469 636d 6574 686f 6428 6e75 6d70  taticmethod(nump
+000158f0: 792e 666c 6f6f 725f 6469 7669 6465 290a  y.floor_divide).
+00015900: 2020 2020 7265 7475 726e 5f74 7970 6520      return_type 
+00015910: 3d20 6c61 6d62 6461 2054 312c 2054 323a  = lambda T1, T2:
+00015920: 2063 6f6d 706c 6578 2069 6620 636f 6d70   complex if comp
+00015930: 6c65 7820 696e 2028 5431 2c20 5432 2920  lex in (T1, T2) 
+00015940: 656c 7365 2066 6c6f 6174 2069 6620 666c  else float if fl
+00015950: 6f61 7420 696e 2028 5431 2c20 5432 2920  oat in (T1, T2) 
+00015960: 656c 7365 2069 6e74 0a0a 0a63 6c61 7373  else int...class
+00015970: 2041 6273 6f6c 7574 6528 506f 696e 7477   Absolute(Pointw
+00015980: 6973 6529 3a0a 2020 2020 6576 616c 6620  ise):.    evalf 
+00015990: 3d20 7374 6174 6963 6d65 7468 6f64 286e  = staticmethod(n
+000159a0: 756d 7079 2e61 6273 6f6c 7574 6529 0a20  umpy.absolute). 
+000159b0: 2020 2072 6574 7572 6e5f 7479 7065 203d     return_type =
+000159c0: 206c 616d 6264 6120 543a 2066 6c6f 6174   lambda T: float
+000159d0: 2069 6620 5420 696e 2028 666c 6f61 742c   if T in (float,
+000159e0: 2063 6f6d 706c 6578 2920 656c 7365 2069   complex) else i
+000159f0: 6e74 0a0a 2020 2020 6465 6620 5f69 6e74  nt..    def _int
+00015a00: 626f 756e 6473 5f69 6d70 6c28 7365 6c66  bounds_impl(self
+00015a10: 293a 0a20 2020 2020 2020 206c 6f77 6572  ):.        lower
+00015a20: 2c20 7570 7065 7220 3d20 7365 6c66 2e61  , upper = self.a
+00015a30: 7267 735b 305d 2e5f 696e 7462 6f75 6e64  rgs[0]._intbound
+00015a40: 730a 2020 2020 2020 2020 6578 7472 656d  s.        extrem
+00015a50: 6120 3d20 6275 696c 7469 6e73 2e61 6273  a = builtins.abs
+00015a60: 286c 6f77 6572 292c 2062 7569 6c74 696e  (lower), builtin
+00015a70: 732e 6162 7328 7570 7065 7229 0a20 2020  s.abs(upper).   
+00015a80: 2020 2020 2069 6620 6c6f 7765 7220 3c3d       if lower <=
+00015a90: 2030 2061 6e64 2075 7070 6572 203e 3d20   0 and upper >= 
+00015aa0: 303a 0a20 2020 2020 2020 2020 2020 2072  0:.            r
+00015ab0: 6574 7572 6e20 302c 206d 6178 2865 7874  eturn 0, max(ext
+00015ac0: 7265 6d61 290a 2020 2020 2020 2020 656c  rema).        el
+00015ad0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00015ae0: 7265 7475 726e 206d 696e 2865 7874 7265  return min(extre
+00015af0: 6d61 292c 206d 6178 2865 7874 7265 6d61  ma), max(extrema
+00015b00: 290a 0a0a 636c 6173 7320 436f 7328 506f  )...class Cos(Po
+00015b10: 696e 7477 6973 6529 3a0a 2020 2020 2743  intwise):.    'C
+00015b20: 6f73 696e 652c 2065 6c65 6d65 6e74 2d77  osine, element-w
+00015b30: 6973 652e 270a 2020 2020 6576 616c 6620  ise.'.    evalf 
+00015b40: 3d20 7374 6174 6963 6d65 7468 6f64 286e  = staticmethod(n
+00015b50: 756d 7079 2e63 6f73 290a 2020 2020 636f  umpy.cos).    co
+00015b60: 6d70 6c65 785f 6465 7269 7620 3d20 6c61  mplex_deriv = la
+00015b70: 6d62 6461 2078 3a20 2d53 696e 2878 292c  mbda x: -Sin(x),
+00015b80: 0a20 2020 2072 6574 7572 6e5f 7479 7065  .    return_type
+00015b90: 203d 206c 616d 6264 6120 543a 2063 6f6d   = lambda T: com
+00015ba0: 706c 6578 2069 6620 5420 3d3d 2063 6f6d  plex if T == com
+00015bb0: 706c 6578 2065 6c73 6520 666c 6f61 740a  plex else float.
+00015bc0: 0a20 2020 2064 6566 205f 7369 6d70 6c69  .    def _simpli
+00015bd0: 6669 6564 2873 656c 6629 3a0a 2020 2020  fied(self):.    
+00015be0: 2020 2020 6172 672c 203d 2073 656c 662e      arg, = self.
+00015bf0: 6172 6773 0a20 2020 2020 2020 2069 6620  args.        if 
+00015c00: 6973 7a65 726f 2861 7267 293a 0a20 2020  iszero(arg):.   
+00015c10: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00015c20: 6f6e 6573 2873 656c 662e 7368 6170 652c  ones(self.shape,
+00015c30: 2064 7479 7065 3d73 656c 662e 6474 7970   dtype=self.dtyp
+00015c40: 6529 0a20 2020 2020 2020 2072 6574 7572  e).        retur
+00015c50: 6e20 7375 7065 7228 292e 5f73 696d 706c  n super()._simpl
+00015c60: 6966 6965 6428 290a 0a0a 636c 6173 7320  ified()...class 
+00015c70: 5369 6e28 506f 696e 7477 6973 6529 3a0a  Sin(Pointwise):.
+00015c80: 2020 2020 2753 696e 652c 2065 6c65 6d65      'Sine, eleme
+00015c90: 6e74 2d77 6973 652e 270a 2020 2020 6576  nt-wise.'.    ev
+00015ca0: 616c 6620 3d20 7374 6174 6963 6d65 7468  alf = staticmeth
+00015cb0: 6f64 286e 756d 7079 2e73 696e 290a 2020  od(numpy.sin).  
+00015cc0: 2020 636f 6d70 6c65 785f 6465 7269 7620    complex_deriv 
+00015cd0: 3d20 436f 732c 0a20 2020 2072 6574 7572  = Cos,.    retur
+00015ce0: 6e5f 7479 7065 203d 206c 616d 6264 6120  n_type = lambda 
+00015cf0: 543a 2063 6f6d 706c 6578 2069 6620 5420  T: complex if T 
+00015d00: 3d3d 2063 6f6d 706c 6578 2065 6c73 6520  == complex else 
+00015d10: 666c 6f61 740a 0a20 2020 2064 6566 205f  float..    def _
+00015d20: 7369 6d70 6c69 6669 6564 2873 656c 6629  simplified(self)
+00015d30: 3a0a 2020 2020 2020 2020 6172 672c 203d  :.        arg, =
+00015d40: 2073 656c 662e 6172 6773 0a20 2020 2020   self.args.     
+00015d50: 2020 2069 6620 6973 7a65 726f 2861 7267     if iszero(arg
+00015d60: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+00015d70: 6574 7572 6e20 7a65 726f 7328 7365 6c66  eturn zeros(self
+00015d80: 2e73 6861 7065 2c20 6474 7970 653d 7365  .shape, dtype=se
+00015d90: 6c66 2e64 7479 7065 290a 2020 2020 2020  lf.dtype).      
+00015da0: 2020 7265 7475 726e 2073 7570 6572 2829    return super()
+00015db0: 2e5f 7369 6d70 6c69 6669 6564 2829 0a0a  ._simplified()..
+00015dc0: 0a63 6c61 7373 2054 616e 2850 6f69 6e74  .class Tan(Point
+00015dd0: 7769 7365 293a 0a20 2020 2027 5461 6e67  wise):.    'Tang
+00015de0: 656e 742c 2065 6c65 6d65 6e74 2d77 6973  ent, element-wis
+00015df0: 652e 270a 2020 2020 6576 616c 6620 3d20  e.'.    evalf = 
+00015e00: 7374 6174 6963 6d65 7468 6f64 286e 756d  staticmethod(num
+00015e10: 7079 2e74 616e 290a 2020 2020 636f 6d70  py.tan).    comp
+00015e20: 6c65 785f 6465 7269 7620 3d20 6c61 6d62  lex_deriv = lamb
+00015e30: 6461 2078 3a20 436f 7328 7829 2a2a 2d32  da x: Cos(x)**-2
+00015e40: 2c0a 2020 2020 7265 7475 726e 5f74 7970  ,.    return_typ
+00015e50: 6520 3d20 6c61 6d62 6461 2054 3a20 636f  e = lambda T: co
+00015e60: 6d70 6c65 7820 6966 2054 203d 3d20 636f  mplex if T == co
+00015e70: 6d70 6c65 7820 656c 7365 2066 6c6f 6174  mplex else float
+00015e80: 0a0a 0a63 6c61 7373 2041 7263 5369 6e28  ...class ArcSin(
+00015e90: 506f 696e 7477 6973 6529 3a0a 2020 2020  Pointwise):.    
+00015ea0: 2749 6e76 6572 7365 2073 696e 652c 2065  'Inverse sine, e
+00015eb0: 6c65 6d65 6e74 2d77 6973 652e 270a 2020  lement-wise.'.  
+00015ec0: 2020 6576 616c 6620 3d20 7374 6174 6963    evalf = static
+00015ed0: 6d65 7468 6f64 286e 756d 7079 2e61 7263  method(numpy.arc
+00015ee0: 7369 6e29 0a20 2020 2063 6f6d 706c 6578  sin).    complex
+00015ef0: 5f64 6572 6976 203d 206c 616d 6264 6120  _deriv = lambda 
+00015f00: 783a 2072 6563 6970 726f 6361 6c28 7371  x: reciprocal(sq
+00015f10: 7274 2831 2d78 2a2a 3229 292c 0a20 2020  rt(1-x**2)),.   
+00015f20: 2072 6574 7572 6e5f 7479 7065 203d 206c   return_type = l
+00015f30: 616d 6264 6120 543a 2063 6f6d 706c 6578  ambda T: complex
+00015f40: 2069 6620 5420 3d3d 2063 6f6d 706c 6578   if T == complex
+00015f50: 2065 6c73 6520 666c 6f61 740a 0a0a 636c   else float...cl
+00015f60: 6173 7320 4172 6343 6f73 2850 6f69 6e74  ass ArcCos(Point
+00015f70: 7769 7365 293a 0a20 2020 2027 496e 7665  wise):.    'Inve
+00015f80: 7273 6520 636f 7369 6e65 2c20 656c 656d  rse cosine, elem
+00015f90: 656e 742d 7769 7365 2e27 0a20 2020 2065  ent-wise.'.    e
+00015fa0: 7661 6c66 203d 2073 7461 7469 636d 6574  valf = staticmet
+00015fb0: 686f 6428 6e75 6d70 792e 6172 6363 6f73  hod(numpy.arccos
+00015fc0: 290a 2020 2020 636f 6d70 6c65 785f 6465  ).    complex_de
+00015fd0: 7269 7620 3d20 6c61 6d62 6461 2078 3a20  riv = lambda x: 
+00015fe0: 2d72 6563 6970 726f 6361 6c28 7371 7274  -reciprocal(sqrt
+00015ff0: 2831 2d78 2a2a 3229 292c 0a20 2020 2072  (1-x**2)),.    r
+00016000: 6574 7572 6e5f 7479 7065 203d 206c 616d  eturn_type = lam
+00016010: 6264 6120 543a 2063 6f6d 706c 6578 2069  bda T: complex i
+00016020: 6620 5420 3d3d 2063 6f6d 706c 6578 2065  f T == complex e
+00016030: 6c73 6520 666c 6f61 740a 0a0a 636c 6173  lse float...clas
+00016040: 7320 4172 6354 616e 2850 6f69 6e74 7769  s ArcTan(Pointwi
+00016050: 7365 293a 0a20 2020 2027 496e 7665 7273  se):.    'Invers
+00016060: 6520 7461 6e67 656e 742c 2065 6c65 6d65  e tangent, eleme
+00016070: 6e74 2d77 6973 652e 270a 2020 2020 6576  nt-wise.'.    ev
+00016080: 616c 6620 3d20 7374 6174 6963 6d65 7468  alf = staticmeth
+00016090: 6f64 286e 756d 7079 2e61 7263 7461 6e29  od(numpy.arctan)
+000160a0: 0a20 2020 2063 6f6d 706c 6578 5f64 6572  .    complex_der
+000160b0: 6976 203d 206c 616d 6264 6120 783a 2072  iv = lambda x: r
+000160c0: 6563 6970 726f 6361 6c28 312b 782a 2a32  eciprocal(1+x**2
+000160d0: 292c 0a20 2020 2072 6574 7572 6e5f 7479  ),.    return_ty
+000160e0: 7065 203d 206c 616d 6264 6120 543a 2063  pe = lambda T: c
+000160f0: 6f6d 706c 6578 2069 6620 5420 3d3d 2063  omplex if T == c
+00016100: 6f6d 706c 6578 2065 6c73 6520 666c 6f61  omplex else floa
+00016110: 740a 0a0a 636c 6173 7320 5369 6e63 2850  t...class Sinc(P
+00016120: 6f69 6e74 7769 7365 293a 0a20 2020 2065  ointwise):.    e
+00016130: 7661 6c66 203d 2073 7461 7469 636d 6574  valf = staticmet
+00016140: 686f 6428 6e75 6d65 7269 632e 7369 6e63  hod(numeric.sinc
+00016150: 290a 2020 2020 636f 6d70 6c65 785f 6465  ).    complex_de
+00016160: 7269 7620 3d20 6c61 6d62 6461 2078 2c20  riv = lambda x, 
+00016170: 6e3a 2053 696e 6328 782c 206e 3d6e 2b31  n: Sinc(x, n=n+1
+00016180: 292c 0a20 2020 2072 6574 7572 6e5f 7479  ),.    return_ty
+00016190: 7065 203d 206c 616d 6264 6120 542c 206e  pe = lambda T, n
+000161a0: 3a20 636f 6d70 6c65 7820 6966 2054 203d  : complex if T =
+000161b0: 3d20 636f 6d70 6c65 7820 656c 7365 2066  = complex else f
+000161c0: 6c6f 6174 0a0a 0a63 6c61 7373 2043 6f73  loat...class Cos
+000161d0: 4828 506f 696e 7477 6973 6529 3a0a 2020  H(Pointwise):.  
+000161e0: 2020 2748 7970 6572 626f 6c69 6320 636f    'Hyperbolic co
+000161f0: 7369 6e65 2c20 656c 656d 656e 742d 7769  sine, element-wi
+00016200: 7365 2e27 0a20 2020 2065 7661 6c66 203d  se.'.    evalf =
+00016210: 2073 7461 7469 636d 6574 686f 6428 6e75   staticmethod(nu
+00016220: 6d70 792e 636f 7368 290a 2020 2020 636f  mpy.cosh).    co
+00016230: 6d70 6c65 785f 6465 7269 7620 3d20 6c61  mplex_deriv = la
+00016240: 6d62 6461 2078 3a20 5369 6e48 2878 292c  mbda x: SinH(x),
+00016250: 0a20 2020 2072 6574 7572 6e5f 7479 7065  .    return_type
+00016260: 203d 206c 616d 6264 6120 543a 2063 6f6d   = lambda T: com
+00016270: 706c 6578 2069 6620 5420 3d3d 2063 6f6d  plex if T == com
+00016280: 706c 6578 2065 6c73 6520 666c 6f61 740a  plex else float.
+00016290: 0a0a 636c 6173 7320 5369 6e48 2850 6f69  ..class SinH(Poi
+000162a0: 6e74 7769 7365 293a 0a20 2020 2027 4879  ntwise):.    'Hy
+000162b0: 7065 7262 6f6c 6963 2073 696e 652c 2065  perbolic sine, e
+000162c0: 6c65 6d65 6e74 2d77 6973 652e 270a 2020  lement-wise.'.  
+000162d0: 2020 6576 616c 6620 3d20 7374 6174 6963    evalf = static
+000162e0: 6d65 7468 6f64 286e 756d 7079 2e73 696e  method(numpy.sin
+000162f0: 6829 0a20 2020 2063 6f6d 706c 6578 5f64  h).    complex_d
+00016300: 6572 6976 203d 2043 6f73 482c 0a20 2020  eriv = CosH,.   
+00016310: 2072 6574 7572 6e5f 7479 7065 203d 206c   return_type = l
+00016320: 616d 6264 6120 543a 2063 6f6d 706c 6578  ambda T: complex
+00016330: 2069 6620 5420 3d3d 2063 6f6d 706c 6578   if T == complex
+00016340: 2065 6c73 6520 666c 6f61 740a 0a0a 636c   else float...cl
+00016350: 6173 7320 5461 6e48 2850 6f69 6e74 7769  ass TanH(Pointwi
+00016360: 7365 293a 0a20 2020 2027 4879 7065 7262  se):.    'Hyperb
+00016370: 6f6c 6963 2074 616e 6765 6e74 2c20 656c  olic tangent, el
+00016380: 656d 656e 742d 7769 7365 2e27 0a20 2020  ement-wise.'.   
+00016390: 2065 7661 6c66 203d 2073 7461 7469 636d   evalf = staticm
+000163a0: 6574 686f 6428 6e75 6d70 792e 7461 6e68  ethod(numpy.tanh
+000163b0: 290a 2020 2020 636f 6d70 6c65 785f 6465  ).    complex_de
+000163c0: 7269 7620 3d20 6c61 6d62 6461 2078 3a20  riv = lambda x: 
+000163d0: 3120 2d20 5461 6e48 2878 292a 2a32 2c0a  1 - TanH(x)**2,.
+000163e0: 2020 2020 7265 7475 726e 5f74 7970 6520      return_type 
+000163f0: 3d20 6c61 6d62 6461 2054 3a20 636f 6d70  = lambda T: comp
+00016400: 6c65 7820 6966 2054 203d 3d20 636f 6d70  lex if T == comp
+00016410: 6c65 7820 656c 7365 2066 6c6f 6174 0a0a  lex else float..
+00016420: 0a63 6c61 7373 2041 7263 5461 6e48 2850  .class ArcTanH(P
+00016430: 6f69 6e74 7769 7365 293a 0a20 2020 2027  ointwise):.    '
+00016440: 496e 7665 7273 6520 6879 7065 7262 6f6c  Inverse hyperbol
+00016450: 6963 2074 616e 6765 6e74 2c20 656c 656d  ic tangent, elem
+00016460: 656e 742d 7769 7365 2e27 0a20 2020 2065  ent-wise.'.    e
+00016470: 7661 6c66 203d 2073 7461 7469 636d 6574  valf = staticmet
+00016480: 686f 6428 6e75 6d70 792e 6172 6374 616e  hod(numpy.arctan
+00016490: 6829 0a20 2020 2063 6f6d 706c 6578 5f64  h).    complex_d
+000164a0: 6572 6976 203d 206c 616d 6264 6120 783a  eriv = lambda x:
+000164b0: 2072 6563 6970 726f 6361 6c28 312d 782a   reciprocal(1-x*
+000164c0: 2a32 292c 0a20 2020 2072 6574 7572 6e5f  *2),.    return_
+000164d0: 7479 7065 203d 206c 616d 6264 6120 543a  type = lambda T:
+000164e0: 2063 6f6d 706c 6578 2069 6620 5420 3d3d   complex if T ==
+000164f0: 2063 6f6d 706c 6578 2065 6c73 6520 666c   complex else fl
+00016500: 6f61 740a 0a0a 636c 6173 7320 4578 7028  oat...class Exp(
+00016510: 506f 696e 7477 6973 6529 3a0a 2020 2020  Pointwise):.    
+00016520: 6576 616c 6620 3d20 7374 6174 6963 6d65  evalf = staticme
+00016530: 7468 6f64 286e 756d 7079 2e65 7870 290a  thod(numpy.exp).
+00016540: 2020 2020 636f 6d70 6c65 785f 6465 7269      complex_deri
+00016550: 7620 3d20 6c61 6d62 6461 2078 3a20 4578  v = lambda x: Ex
+00016560: 7028 7829 2c0a 2020 2020 7265 7475 726e  p(x),.    return
+00016570: 5f74 7970 6520 3d20 6c61 6d62 6461 2054  _type = lambda T
+00016580: 3a20 636f 6d70 6c65 7820 6966 2054 203d  : complex if T =
+00016590: 3d20 636f 6d70 6c65 7820 656c 7365 2066  = complex else f
+000165a0: 6c6f 6174 0a0a 0a63 6c61 7373 204c 6f67  loat...class Log
+000165b0: 2850 6f69 6e74 7769 7365 293a 0a20 2020  (Pointwise):.   
+000165c0: 2065 7661 6c66 203d 2073 7461 7469 636d   evalf = staticm
+000165d0: 6574 686f 6428 6e75 6d70 792e 6c6f 6729  ethod(numpy.log)
+000165e0: 0a20 2020 2063 6f6d 706c 6578 5f64 6572  .    complex_der
+000165f0: 6976 203d 206c 616d 6264 6120 783a 2072  iv = lambda x: r
+00016600: 6563 6970 726f 6361 6c28 7829 2c0a 2020  eciprocal(x),.  
+00016610: 2020 7265 7475 726e 5f74 7970 6520 3d20    return_type = 
+00016620: 6c61 6d62 6461 2054 3a20 636f 6d70 6c65  lambda T: comple
+00016630: 7820 6966 2054 203d 3d20 636f 6d70 6c65  x if T == comple
+00016640: 7820 656c 7365 2066 6c6f 6174 0a0a 0a63  x else float...c
+00016650: 6c61 7373 204d 6f64 2850 6f69 6e74 7769  lass Mod(Pointwi
+00016660: 7365 293a 0a20 2020 2065 7661 6c66 203d  se):.    evalf =
+00016670: 2073 7461 7469 636d 6574 686f 6428 6e75   staticmethod(nu
+00016680: 6d70 792e 6d6f 6429 0a20 2020 2064 6566  mpy.mod).    def
+00016690: 2072 6574 7572 6e5f 7479 7065 2854 312c   return_type(T1,
+000166a0: 2054 3229 3a0a 2020 2020 2020 2020 6966   T2):.        if
+000166b0: 2054 3120 3d3d 2063 6f6d 706c 6578 206f   T1 == complex o
+000166c0: 7220 5432 203d 3d20 636f 6d70 6c65 783a  r T2 == complex:
+000166d0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+000166e0: 7365 2056 616c 7565 4572 726f 7228 276d  se ValueError('m
+000166f0: 6f64 2069 7320 6e6f 7420 6465 6669 6e65  od is not define
+00016700: 6420 666f 7220 636f 6d70 6c65 7820 6e75  d for complex nu
+00016710: 6d62 6572 7327 290a 2020 2020 2020 2020  mbers').        
+00016720: 7265 7475 726e 2066 6c6f 6174 2069 6620  return float if 
+00016730: 666c 6f61 7420 696e 2028 5431 2c20 5432  float in (T1, T2
+00016740: 2920 656c 7365 2069 6e74 0a0a 2020 2020  ) else int..    
+00016750: 6465 6620 5f69 6e74 626f 756e 6473 5f69  def _intbounds_i
+00016760: 6d70 6c28 7365 6c66 293a 0a20 2020 2020  mpl(self):.     
+00016770: 2020 2064 6976 6964 656e 642c 2064 6976     dividend, div
+00016780: 6973 6f72 203d 2073 656c 662e 6172 6773  isor = self.args
+00016790: 0a20 2020 2020 2020 206c 6f77 6572 5f64  .        lower_d
+000167a0: 6976 6973 6f72 2c20 7570 7065 725f 6469  ivisor, upper_di
+000167b0: 7669 736f 7220 3d20 6469 7669 736f 722e  visor = divisor.
+000167c0: 5f69 6e74 626f 756e 6473 0a20 2020 2020  _intbounds.     
+000167d0: 2020 2069 6620 6c6f 7765 725f 6469 7669     if lower_divi
+000167e0: 736f 7220 3e20 303a 0a20 2020 2020 2020  sor > 0:.       
+000167f0: 2020 2020 206c 6f77 6572 5f64 6976 6964       lower_divid
+00016800: 656e 642c 2075 7070 6572 5f64 6976 6964  end, upper_divid
+00016810: 656e 6420 3d20 6469 7669 6465 6e64 2e5f  end = dividend._
+00016820: 696e 7462 6f75 6e64 730a 2020 2020 2020  intbounds.      
+00016830: 2020 2020 2020 6966 2030 203c 3d20 6c6f        if 0 <= lo
+00016840: 7765 725f 6469 7669 6465 6e64 2061 6e64  wer_dividend and
+00016850: 2075 7070 6572 5f64 6976 6964 656e 6420   upper_dividend 
+00016860: 3c20 6c6f 7765 725f 6469 7669 736f 723a  < lower_divisor:
+00016870: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016880: 2072 6574 7572 6e20 6c6f 7765 725f 6469   return lower_di
+00016890: 7669 6465 6e64 2c20 7570 7065 725f 6469  vidend, upper_di
+000168a0: 7669 6465 6e64 0a20 2020 2020 2020 2020  vidend.         
+000168b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000168c0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000168d0: 302c 2075 7070 6572 5f64 6976 6973 6f72  0, upper_divisor
+000168e0: 202d 2031 0a20 2020 2020 2020 2065 6c73   - 1.        els
+000168f0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+00016900: 6574 7572 6e20 7375 7065 7228 292e 5f69  eturn super()._i
+00016910: 6e74 626f 756e 6473 5f69 6d70 6c28 290a  ntbounds_impl().
+00016920: 0a20 2020 2064 6566 205f 7369 6d70 6c69  .    def _simpli
+00016930: 6669 6564 2873 656c 6629 3a0a 2020 2020  fied(self):.    
+00016940: 2020 2020 6469 7669 6465 6e64 2c20 6469      dividend, di
+00016950: 7669 736f 7220 3d20 7365 6c66 2e61 7267  visor = self.arg
+00016960: 730a 2020 2020 2020 2020 6c6f 7765 725f  s.        lower_
+00016970: 6469 7669 736f 722c 2075 7070 6572 5f64  divisor, upper_d
+00016980: 6976 6973 6f72 203d 2064 6976 6973 6f72  ivisor = divisor
+00016990: 2e5f 696e 7462 6f75 6e64 730a 2020 2020  ._intbounds.    
+000169a0: 2020 2020 6966 206c 6f77 6572 5f64 6976      if lower_div
+000169b0: 6973 6f72 203e 2030 3a0a 2020 2020 2020  isor > 0:.      
+000169c0: 2020 2020 2020 6c6f 7765 725f 6469 7669        lower_divi
+000169d0: 6465 6e64 2c20 7570 7065 725f 6469 7669  dend, upper_divi
+000169e0: 6465 6e64 203d 2064 6976 6964 656e 642e  dend = dividend.
+000169f0: 5f69 6e74 626f 756e 6473 0a20 2020 2020  _intbounds.     
+00016a00: 2020 2020 2020 2069 6620 3020 3c3d 206c         if 0 <= l
+00016a10: 6f77 6572 5f64 6976 6964 656e 6420 616e  ower_dividend an
+00016a20: 6420 7570 7065 725f 6469 7669 6465 6e64  d upper_dividend
+00016a30: 203c 206c 6f77 6572 5f64 6976 6973 6f72   < lower_divisor
+00016a40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00016a50: 2020 7265 7475 726e 2064 6976 6964 656e    return dividen
+00016a60: 640a 0a0a 636c 6173 7320 4172 6354 616e  d...class ArcTan
+00016a70: 3228 506f 696e 7477 6973 6529 3a0a 2020  2(Pointwise):.  
+00016a80: 2020 6576 616c 6620 3d20 7374 6174 6963    evalf = static
+00016a90: 6d65 7468 6f64 286e 756d 7079 2e61 7263  method(numpy.arc
+00016aa0: 7461 6e32 290a 2020 2020 6465 7269 7620  tan2).    deriv 
+00016ab0: 3d20 6c61 6d62 6461 2078 2c20 793a 2079  = lambda x, y: y
+00016ac0: 202f 2028 782a 2a32 202b 2079 2a2a 3229   / (x**2 + y**2)
+00016ad0: 2c20 6c61 6d62 6461 2078 2c20 793a 202d  , lambda x, y: -
+00016ae0: 7820 2f20 2878 2a2a 3220 2b20 792a 2a32  x / (x**2 + y**2
+00016af0: 290a 2020 2020 6465 6620 7265 7475 726e  ).    def return
+00016b00: 5f74 7970 6528 5431 2c20 5432 293a 0a20  _type(T1, T2):. 
+00016b10: 2020 2020 2020 2069 6620 5431 203d 3d20         if T1 == 
+00016b20: 636f 6d70 6c65 7820 6f72 2054 3220 3d3d  complex or T2 ==
+00016b30: 2063 6f6d 706c 6578 3a0a 2020 2020 2020   complex:.      
+00016b40: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00016b50: 6545 7272 6f72 2827 6172 6374 616e 3220  eError('arctan2 
+00016b60: 6973 206e 6f74 2064 6566 696e 6564 2066  is not defined f
+00016b70: 6f72 2063 6f6d 706c 6578 206e 756d 6265  or complex numbe
+00016b80: 7273 2729 0a20 2020 2020 2020 2072 6574  rs').        ret
+00016b90: 7572 6e20 666c 6f61 740a 0a0a 636c 6173  urn float...clas
+00016ba0: 7320 4772 6561 7465 7228 506f 696e 7477  s Greater(Pointw
+00016bb0: 6973 6529 3a0a 2020 2020 6576 616c 6620  ise):.    evalf 
+00016bc0: 3d20 7374 6174 6963 6d65 7468 6f64 286e  = staticmethod(n
+00016bd0: 756d 7079 2e67 7265 6174 6572 290a 2020  umpy.greater).  
+00016be0: 2020 6465 6620 7265 7475 726e 5f74 7970    def return_typ
+00016bf0: 6528 5431 2c20 5432 293a 0a20 2020 2020  e(T1, T2):.     
+00016c00: 2020 2069 6620 5431 203d 3d20 636f 6d70     if T1 == comp
+00016c10: 6c65 7820 6f72 2054 3220 3d3d 2063 6f6d  lex or T2 == com
+00016c20: 706c 6578 3a0a 2020 2020 2020 2020 2020  plex:.          
+00016c30: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+00016c40: 6f72 2827 436f 6d70 6c65 7820 6e75 6d62  or('Complex numb
+00016c50: 6572 7320 6861 7665 206e 6f20 746f 7461  ers have no tota
+00016c60: 6c20 6f72 6465 722e 2729 0a20 2020 2020  l order.').     
+00016c70: 2020 2072 6574 7572 6e20 626f 6f6c 0a0a     return bool..
+00016c80: 0a63 6c61 7373 2045 7175 616c 2850 6f69  .class Equal(Poi
+00016c90: 6e74 7769 7365 293a 0a20 2020 2065 7661  ntwise):.    eva
+00016ca0: 6c66 203d 2073 7461 7469 636d 6574 686f  lf = staticmetho
+00016cb0: 6428 6e75 6d70 792e 6571 7561 6c29 0a20  d(numpy.equal). 
+00016cc0: 2020 2072 6574 7572 6e5f 7479 7065 203d     return_type =
+00016cd0: 206c 616d 6264 6120 5431 2c20 5432 3a20   lambda T1, T2: 
+00016ce0: 626f 6f6c 0a0a 2020 2020 6465 6620 5f73  bool..    def _s
+00016cf0: 696d 706c 6966 6965 6428 7365 6c66 293a  implified(self):
+00016d00: 0a20 2020 2020 2020 2061 312c 2061 3220  .        a1, a2 
+00016d10: 3d20 7365 6c66 2e61 7267 730a 2020 2020  = self.args.    
+00016d20: 2020 2020 6966 2061 3120 3d3d 2061 323a      if a1 == a2:
+00016d30: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00016d40: 7572 6e20 6f6e 6573 2873 656c 662e 7368  urn ones(self.sh
+00016d50: 6170 652c 2062 6f6f 6c29 0a20 2020 2020  ape, bool).     
+00016d60: 2020 2069 6620 7365 6c66 2e6e 6469 6d20     if self.ndim 
+00016d70: 3d3d 2032 3a0a 2020 2020 2020 2020 2020  == 2:.          
+00016d80: 2020 7531 2c20 7731 203d 2075 6e61 6c69    u1, w1 = unali
+00016d90: 676e 2861 3129 0a20 2020 2020 2020 2020  gn(a1).         
+00016da0: 2020 2075 322c 2077 3220 3d20 756e 616c     u2, w2 = unal
+00016db0: 6967 6e28 6132 290a 2020 2020 2020 2020  ign(a2).        
+00016dc0: 2020 2020 6966 2075 3120 3d3d 2075 3220      if u1 == u2 
+00016dd0: 616e 6420 6973 696e 7374 616e 6365 2875  and isinstance(u
+00016de0: 312c 2052 616e 6765 293a 0a20 2020 2020  1, Range):.     
+00016df0: 2020 2020 2020 2020 2020 2023 204e 4f54             # NOT
+00016e00: 453a 204f 6e63 6520 7765 2069 6e74 726f  E: Once we intro
+00016e10: 6475 6365 2069 7375 6e69 7175 6520 7765  duce isunique we
+00016e20: 2063 616e 2072 656c 6178 2074 6865 2052   can relax the R
+00016e30: 616e 6765 2062 6f75 6e64 0a20 2020 2020  ange bound.     
+00016e40: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00016e50: 6e20 4469 6167 6f6e 616c 697a 6528 6f6e  n Diagonalize(on
+00016e60: 6573 2875 312e 7368 6170 652c 2062 6f6f  es(u1.shape, boo
+00016e70: 6c29 290a 2020 2020 2020 2020 7265 7475  l)).        retu
+00016e80: 726e 2073 7570 6572 2829 2e5f 7369 6d70  rn super()._simp
+00016e90: 6c69 6669 6564 2829 0a0a 0a63 6c61 7373  lified()...class
+00016ea0: 204c 6573 7328 506f 696e 7477 6973 6529   Less(Pointwise)
+00016eb0: 3a0a 2020 2020 6576 616c 6620 3d20 7374  :.    evalf = st
+00016ec0: 6174 6963 6d65 7468 6f64 286e 756d 7079  aticmethod(numpy
+00016ed0: 2e6c 6573 7329 0a20 2020 2064 6566 2072  .less).    def r
+00016ee0: 6574 7572 6e5f 7479 7065 2854 312c 2054  eturn_type(T1, T
+00016ef0: 3229 3a0a 2020 2020 2020 2020 6966 2054  2):.        if T
+00016f00: 3120 3d3d 2063 6f6d 706c 6578 206f 7220  1 == complex or 
+00016f10: 5432 203d 3d20 636f 6d70 6c65 783a 0a20  T2 == complex:. 
+00016f20: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00016f30: 2056 616c 7565 4572 726f 7228 2743 6f6d   ValueError('Com
+00016f40: 706c 6578 206e 756d 6265 7273 2068 6176  plex numbers hav
+00016f50: 6520 6e6f 2074 6f74 616c 206f 7264 6572  e no total order
+00016f60: 2e27 290a 2020 2020 2020 2020 7265 7475  .').        retu
+00016f70: 726e 2062 6f6f 6c0a 0a0a 636c 6173 7320  rn bool...class 
+00016f80: 4d69 6e69 6d75 6d28 506f 696e 7477 6973  Minimum(Pointwis
+00016f90: 6529 3a0a 2020 2020 6576 616c 6620 3d20  e):.    evalf = 
+00016fa0: 7374 6174 6963 6d65 7468 6f64 286e 756d  staticmethod(num
+00016fb0: 7079 2e6d 696e 696d 756d 290a 2020 2020  py.minimum).    
+00016fc0: 6465 7269 7620 3d20 6c61 6d62 6461 2078  deriv = lambda x
+00016fd0: 2c20 793a 202e 3520 2d20 2e35 202a 2053  , y: .5 - .5 * S
+00016fe0: 6967 6e28 7820 2d20 7929 2c20 6c61 6d62  ign(x - y), lamb
+00016ff0: 6461 2078 2c20 793a 202e 3520 2b20 2e35  da x, y: .5 + .5
+00017000: 202a 2053 6967 6e28 7820 2d20 7929 0a20   * Sign(x - y). 
+00017010: 2020 2064 6566 2072 6574 7572 6e5f 7479     def return_ty
+00017020: 7065 2854 312c 2054 3229 3a0a 2020 2020  pe(T1, T2):.    
+00017030: 2020 2020 6966 2054 3120 3d3d 2063 6f6d      if T1 == com
+00017040: 706c 6578 206f 7220 5432 203d 3d20 636f  plex or T2 == co
+00017050: 6d70 6c65 783a 0a20 2020 2020 2020 2020  mplex:.         
+00017060: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00017070: 726f 7228 2743 6f6d 706c 6578 206e 756d  ror('Complex num
+00017080: 6265 7273 2068 6176 6520 6e6f 2074 6f74  bers have no tot
+00017090: 616c 206f 7264 6572 2e27 290a 2020 2020  al order.').    
+000170a0: 2020 2020 7265 7475 726e 2066 6c6f 6174      return float
+000170b0: 2069 6620 666c 6f61 7420 696e 2028 5431   if float in (T1
+000170c0: 2c20 5432 2920 656c 7365 2069 6e74 2069  , T2) else int i
+000170d0: 6620 696e 7420 696e 2028 5431 2c20 5432  f int in (T1, T2
+000170e0: 2920 656c 7365 2062 6f6f 6c0a 0a20 2020  ) else bool..   
+000170f0: 2064 6566 205f 7369 6d70 6c69 6669 6564   def _simplified
+00017100: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00017110: 6966 2073 656c 662e 6474 7970 6520 3d3d  if self.dtype ==
+00017120: 2069 6e74 3a0a 2020 2020 2020 2020 2020   int:.          
+00017130: 2020 6c6f 7765 7231 2c20 7570 7065 7231    lower1, upper1
+00017140: 203d 2073 656c 662e 6172 6773 5b30 5d2e   = self.args[0].
+00017150: 5f69 6e74 626f 756e 6473 0a20 2020 2020  _intbounds.     
+00017160: 2020 2020 2020 206c 6f77 6572 322c 2075         lower2, u
+00017170: 7070 6572 3220 3d20 7365 6c66 2e61 7267  pper2 = self.arg
+00017180: 735b 315d 2e5f 696e 7462 6f75 6e64 730a  s[1]._intbounds.
+00017190: 2020 2020 2020 2020 2020 2020 6966 2075              if u
+000171a0: 7070 6572 3120 3c3d 206c 6f77 6572 323a  pper1 <= lower2:
+000171b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000171c0: 2072 6574 7572 6e20 7365 6c66 2e61 7267   return self.arg
+000171d0: 735b 305d 0a20 2020 2020 2020 2020 2020  s[0].           
+000171e0: 2065 6c69 6620 7570 7065 7232 203c 3d20   elif upper2 <= 
+000171f0: 6c6f 7765 7231 3a0a 2020 2020 2020 2020  lower1:.        
+00017200: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00017210: 656c 662e 6172 6773 5b31 5d0a 2020 2020  elf.args[1].    
+00017220: 2020 2020 7265 7475 726e 2073 7570 6572      return super
+00017230: 2829 2e5f 7369 6d70 6c69 6669 6564 2829  ()._simplified()
+00017240: 0a0a 2020 2020 6465 6620 5f69 6e74 626f  ..    def _intbo
+00017250: 756e 6473 5f69 6d70 6c28 7365 6c66 293a  unds_impl(self):
+00017260: 0a20 2020 2020 2020 206c 6f77 6572 312c  .        lower1,
+00017270: 2075 7070 6572 3120 3d20 7365 6c66 2e61   upper1 = self.a
+00017280: 7267 735b 305d 2e5f 696e 7462 6f75 6e64  rgs[0]._intbound
+00017290: 730a 2020 2020 2020 2020 6c6f 7765 7232  s.        lower2
+000172a0: 2c20 7570 7065 7232 203d 2073 656c 662e  , upper2 = self.
+000172b0: 6172 6773 5b31 5d2e 5f69 6e74 626f 756e  args[1]._intboun
+000172c0: 6473 0a20 2020 2020 2020 2072 6574 7572  ds.        retur
+000172d0: 6e20 6d69 6e28 6c6f 7765 7231 2c20 6c6f  n min(lower1, lo
+000172e0: 7765 7232 292c 206d 696e 2875 7070 6572  wer2), min(upper
+000172f0: 312c 2075 7070 6572 3229 0a0a 0a63 6c61  1, upper2)...cla
+00017300: 7373 204d 6178 696d 756d 2850 6f69 6e74  ss Maximum(Point
+00017310: 7769 7365 293a 0a20 2020 2065 7661 6c66  wise):.    evalf
+00017320: 203d 2073 7461 7469 636d 6574 686f 6428   = staticmethod(
+00017330: 6e75 6d70 792e 6d61 7869 6d75 6d29 0a20  numpy.maximum). 
+00017340: 2020 2064 6572 6976 203d 206c 616d 6264     deriv = lambd
+00017350: 6120 782c 2079 3a20 2e35 202b 202e 3520  a x, y: .5 + .5 
+00017360: 2a20 5369 676e 2878 202d 2079 292c 206c  * Sign(x - y), l
+00017370: 616d 6264 6120 782c 2079 3a20 2e35 202d  ambda x, y: .5 -
+00017380: 202e 3520 2a20 5369 676e 2878 202d 2079   .5 * Sign(x - y
+00017390: 290a 2020 2020 6465 6620 7265 7475 726e  ).    def return
+000173a0: 5f74 7970 6528 5431 2c20 5432 293a 0a20  _type(T1, T2):. 
+000173b0: 2020 2020 2020 2069 6620 5431 203d 3d20         if T1 == 
+000173c0: 636f 6d70 6c65 7820 6f72 2054 3220 3d3d  complex or T2 ==
+000173d0: 2063 6f6d 706c 6578 3a0a 2020 2020 2020   complex:.      
+000173e0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+000173f0: 6545 7272 6f72 2827 436f 6d70 6c65 7820  eError('Complex 
+00017400: 6e75 6d62 6572 7320 6861 7665 206e 6f20  numbers have no 
+00017410: 746f 7461 6c20 6f72 6465 722e 2729 0a20  total order.'). 
+00017420: 2020 2020 2020 2072 6574 7572 6e20 666c         return fl
+00017430: 6f61 7420 6966 2066 6c6f 6174 2069 6e20  oat if float in 
+00017440: 2854 312c 2054 3229 2065 6c73 6520 696e  (T1, T2) else in
+00017450: 7420 6966 2069 6e74 2069 6e20 2854 312c  t if int in (T1,
+00017460: 2054 3229 2065 6c73 6520 626f 6f6c 0a0a   T2) else bool..
+00017470: 2020 2020 6465 6620 5f73 696d 706c 6966      def _simplif
+00017480: 6965 6428 7365 6c66 293a 0a20 2020 2020  ied(self):.     
+00017490: 2020 2069 6620 7365 6c66 2e64 7479 7065     if self.dtype
+000174a0: 203d 3d20 696e 743a 0a20 2020 2020 2020   == int:.       
+000174b0: 2020 2020 206c 6f77 6572 312c 2075 7070       lower1, upp
+000174c0: 6572 3120 3d20 7365 6c66 2e61 7267 735b  er1 = self.args[
+000174d0: 305d 2e5f 696e 7462 6f75 6e64 730a 2020  0]._intbounds.  
+000174e0: 2020 2020 2020 2020 2020 6c6f 7765 7232            lower2
+000174f0: 2c20 7570 7065 7232 203d 2073 656c 662e  , upper2 = self.
+00017500: 6172 6773 5b31 5d2e 5f69 6e74 626f 756e  args[1]._intboun
+00017510: 6473 0a20 2020 2020 2020 2020 2020 2069  ds.            i
+00017520: 6620 7570 7065 7232 203c 3d20 6c6f 7765  f upper2 <= lowe
+00017530: 7231 3a0a 2020 2020 2020 2020 2020 2020  r1:.            
+00017540: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00017550: 6172 6773 5b30 5d0a 2020 2020 2020 2020  args[0].        
+00017560: 2020 2020 656c 6966 2075 7070 6572 3120      elif upper1 
+00017570: 3c3d 206c 6f77 6572 323a 0a20 2020 2020  <= lower2:.     
+00017580: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00017590: 6e20 7365 6c66 2e61 7267 735b 315d 0a20  n self.args[1]. 
+000175a0: 2020 2020 2020 2072 6574 7572 6e20 7375         return su
+000175b0: 7065 7228 292e 5f73 696d 706c 6966 6965  per()._simplifie
+000175c0: 6428 290a 0a20 2020 2064 6566 205f 696e  d()..    def _in
+000175d0: 7462 6f75 6e64 735f 696d 706c 2873 656c  tbounds_impl(sel
+000175e0: 6629 3a0a 2020 2020 2020 2020 6c6f 7765  f):.        lowe
+000175f0: 7231 2c20 7570 7065 7231 203d 2073 656c  r1, upper1 = sel
+00017600: 662e 6172 6773 5b30 5d2e 5f69 6e74 626f  f.args[0]._intbo
+00017610: 756e 6473 0a20 2020 2020 2020 206c 6f77  unds.        low
+00017620: 6572 322c 2075 7070 6572 3220 3d20 7365  er2, upper2 = se
+00017630: 6c66 2e61 7267 735b 315d 2e5f 696e 7462  lf.args[1]._intb
+00017640: 6f75 6e64 730a 2020 2020 2020 2020 7265  ounds.        re
+00017650: 7475 726e 206d 6178 286c 6f77 6572 312c  turn max(lower1,
+00017660: 206c 6f77 6572 3229 2c20 6d61 7828 7570   lower2), max(up
+00017670: 7065 7231 2c20 7570 7065 7232 290a 0a0a  per1, upper2)...
+00017680: 636c 6173 7320 436f 6e6a 7567 6174 6528  class Conjugate(
+00017690: 506f 696e 7477 6973 6529 3a0a 2020 2020  Pointwise):.    
+000176a0: 6576 616c 6620 3d20 7374 6174 6963 6d65  evalf = staticme
+000176b0: 7468 6f64 286e 756d 7079 2e63 6f6e 6a75  thod(numpy.conju
+000176c0: 6761 7465 290a 2020 2020 7265 7475 726e  gate).    return
+000176d0: 5f74 7970 6520 3d20 6c61 6d62 6461 2054  _type = lambda T
+000176e0: 3a20 696e 7420 6966 2054 203d 3d20 626f  : int if T == bo
+000176f0: 6f6c 2065 6c73 6520 540a 0a20 2020 2064  ol else T..    d
+00017700: 6566 205f 7369 6d70 6c69 6669 6564 2873  ef _simplified(s
+00017710: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00017720: 7476 616c 203d 2073 656c 662e 6172 6773  tval = self.args
+00017730: 5b30 5d2e 5f63 6f6e 6a75 6761 7465 2829  [0]._conjugate()
+00017740: 0a20 2020 2020 2020 2069 6620 7265 7476  .        if retv
+00017750: 616c 2069 7320 6e6f 7420 4e6f 6e65 3a0a  al is not None:.
+00017760: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00017770: 726e 2072 6574 7661 6c0a 2020 2020 2020  rn retval.      
+00017780: 2020 7265 7475 726e 2073 7570 6572 2829    return super()
+00017790: 2e5f 7369 6d70 6c69 6669 6564 2829 0a0a  ._simplified()..
+000177a0: 0a63 6c61 7373 2052 6561 6c28 506f 696e  .class Real(Poin
+000177b0: 7477 6973 6529 3a0a 2020 2020 6576 616c  twise):.    eval
+000177c0: 6620 3d20 7374 6174 6963 6d65 7468 6f64  f = staticmethod
+000177d0: 286e 756d 7079 2e72 6561 6c29 0a20 2020  (numpy.real).   
+000177e0: 2072 6574 7572 6e5f 7479 7065 203d 206c   return_type = l
+000177f0: 616d 6264 6120 543a 2066 6c6f 6174 2069  ambda T: float i
+00017800: 6620 5420 3d3d 2063 6f6d 706c 6578 2065  f T == complex e
+00017810: 6c73 6520 540a 0a20 2020 2064 6566 205f  lse T..    def _
+00017820: 7369 6d70 6c69 6669 6564 2873 656c 6629  simplified(self)
+00017830: 3a0a 2020 2020 2020 2020 7265 7476 616c  :.        retval
+00017840: 203d 2073 656c 662e 6172 6773 5b30 5d2e   = self.args[0].
+00017850: 5f72 6561 6c28 290a 2020 2020 2020 2020  _real().        
+00017860: 6966 2072 6574 7661 6c20 6973 206e 6f74  if retval is not
+00017870: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00017880: 2020 2072 6574 7572 6e20 7265 7476 616c     return retval
+00017890: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000178a0: 7375 7065 7228 292e 5f73 696d 706c 6966  super()._simplif
+000178b0: 6965 6428 290a 0a0a 636c 6173 7320 496d  ied()...class Im
+000178c0: 6167 2850 6f69 6e74 7769 7365 293a 0a20  ag(Pointwise):. 
+000178d0: 2020 2065 7661 6c66 203d 2073 7461 7469     evalf = stati
+000178e0: 636d 6574 686f 6428 6e75 6d70 792e 696d  cmethod(numpy.im
+000178f0: 6167 290a 2020 2020 7265 7475 726e 5f74  ag).    return_t
+00017900: 7970 6520 3d20 6c61 6d62 6461 2054 3a20  ype = lambda T: 
+00017910: 666c 6f61 7420 6966 2054 203d 3d20 636f  float if T == co
+00017920: 6d70 6c65 7820 656c 7365 2054 0a0a 2020  mplex else T..  
+00017930: 2020 6465 6620 5f73 696d 706c 6966 6965    def _simplifie
+00017940: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
+00017950: 2072 6574 7661 6c20 3d20 7365 6c66 2e61   retval = self.a
+00017960: 7267 735b 305d 2e5f 696d 6167 2829 0a20  rgs[0]._imag(). 
+00017970: 2020 2020 2020 2069 6620 7265 7476 616c         if retval
+00017980: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+00017990: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000179a0: 2072 6574 7661 6c0a 2020 2020 2020 2020   retval.        
+000179b0: 7265 7475 726e 2073 7570 6572 2829 2e5f  return super()._
+000179c0: 7369 6d70 6c69 6669 6564 2829 0a0a 0a63  simplified()...c
+000179d0: 6c61 7373 2043 6173 7428 506f 696e 7477  lass Cast(Pointw
+000179e0: 6973 6529 3a0a 0a20 2020 2064 6566 2065  ise):..    def e
+000179f0: 7661 6c66 2873 656c 662c 2061 7267 293a  valf(self, arg):
+00017a00: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00017a10: 6e75 6d70 792e 6172 7261 7928 6172 672c  numpy.array(arg,
+00017a20: 2064 7479 7065 3d73 656c 662e 6474 7970   dtype=self.dtyp
+00017a30: 6529 0a0a 2020 2020 6465 6620 5f73 696d  e)..    def _sim
+00017a40: 706c 6966 6965 6428 7365 6c66 293a 0a20  plified(self):. 
+00017a50: 2020 2020 2020 2061 7267 2c20 3d20 7365         arg, = se
+00017a60: 6c66 2e61 7267 730a 2020 2020 2020 2020  lf.args.        
+00017a70: 6966 2069 737a 6572 6f28 6172 6729 3a0a  if iszero(arg):.
+00017a80: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00017a90: 726e 207a 6572 6f73 5f6c 696b 6528 7365  rn zeros_like(se
+00017aa0: 6c66 290a 2020 2020 2020 2020 666f 7220  lf).        for 
+00017ab0: 6178 6973 2c20 7061 7274 7320 696e 2061  axis, parts in a
+00017ac0: 7267 2e5f 696e 666c 6174 696f 6e73 3a0a  rg._inflations:.
+00017ad0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00017ae0: 726e 2075 7469 6c2e 7375 6d28 5f69 6e66  rn util.sum(_inf
+00017af0: 6c61 7465 2873 656c 662e 5f6e 6577 6172  late(self._newar
+00017b00: 6773 2866 756e 6329 2c20 646f 666d 6170  gs(func), dofmap
+00017b10: 2c20 7365 6c66 2e73 6861 7065 5b61 7869  , self.shape[axi
+00017b20: 735d 2c20 6178 6973 2920 666f 7220 646f  s], axis) for do
+00017b30: 666d 6170 2c20 6675 6e63 2069 6e20 7061  fmap, func in pa
+00017b40: 7274 732e 6974 656d 7328 2929 0a20 2020  rts.items()).   
+00017b50: 2020 2020 2072 6574 7572 6e20 7375 7065       return supe
+00017b60: 7228 292e 5f73 696d 706c 6966 6965 6428  r()._simplified(
+00017b70: 290a 0a20 2020 2064 6566 205f 696e 7462  )..    def _intb
+00017b80: 6f75 6e64 735f 696d 706c 2873 656c 6629  ounds_impl(self)
+00017b90: 3a0a 2020 2020 2020 2020 6966 2073 656c  :.        if sel
+00017ba0: 662e 6172 6773 5b30 5d2e 6474 7970 6520  f.args[0].dtype 
+00017bb0: 3d3d 2062 6f6f 6c3a 0a20 2020 2020 2020  == bool:.       
+00017bc0: 2020 2020 2072 6574 7572 6e20 302c 2031       return 0, 1
+00017bd0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00017be0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00017bf0: 6e20 7365 6c66 2e61 7267 735b 305d 2e5f  n self.args[0]._
+00017c00: 696e 7462 6f75 6e64 730a 0a20 2020 2040  intbounds..    @
+00017c10: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00017c20: 205f 636f 6e73 745f 756e 6966 6f72 6d28   _const_uniform(
+00017c30: 7365 6c66 293a 0a20 2020 2020 2020 2076  self):.        v
+00017c40: 616c 7565 203d 2073 656c 662e 6172 6773  alue = self.args
+00017c50: 5b30 5d2e 5f63 6f6e 7374 5f75 6e69 666f  [0]._const_unifo
+00017c60: 726d 0a20 2020 2020 2020 2069 6620 7661  rm.        if va
+00017c70: 6c75 6520 6973 206e 6f74 204e 6f6e 653a  lue is not None:
+00017c80: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00017c90: 7572 6e20 7365 6c66 2e64 7479 7065 2876  urn self.dtype(v
+00017ca0: 616c 7565 290a 0a0a 636c 6173 7320 426f  alue)...class Bo
+00017cb0: 6f6c 546f 496e 7428 4361 7374 293a 0a20  olToInt(Cast):. 
+00017cc0: 2020 2064 6566 2072 6574 7572 6e5f 7479     def return_ty
+00017cd0: 7065 2854 293a 0a20 2020 2020 2020 2069  pe(T):.        i
+00017ce0: 6620 5420 213d 2062 6f6f 6c3a 0a20 2020  f T != bool:.   
+00017cf0: 2020 2020 2020 2020 2072 6169 7365 2054           raise T
+00017d00: 7970 6545 7272 6f72 2866 2745 7870 6563  ypeError(f'Expec
+00017d10: 7465 6420 616e 2061 7272 6179 2077 6974  ted an array wit
+00017d20: 6820 6474 7970 6520 626f 6f6c 2062 7574  h dtype bool but
+00017d30: 2067 6f74 207b 542e 5f5f 6e61 6d65 5f5f   got {T.__name__
+00017d40: 7d2e 2729 0a20 2020 2020 2020 2072 6574  }.').        ret
+00017d50: 7572 6e20 696e 740a 0a0a 636c 6173 7320  urn int...class 
+00017d60: 496e 7454 6f46 6c6f 6174 2843 6173 7429  IntToFloat(Cast)
+00017d70: 3a0a 2020 2020 6465 6620 7265 7475 726e  :.    def return
+00017d80: 5f74 7970 6528 5429 3a0a 2020 2020 2020  _type(T):.      
+00017d90: 2020 6966 2054 2021 3d20 696e 743a 0a20    if T != int:. 
+00017da0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00017db0: 2054 7970 6545 7272 6f72 2866 2745 7870   TypeError(f'Exp
+00017dc0: 6563 7465 6420 616e 2061 7272 6179 2077  ected an array w
+00017dd0: 6974 6820 6474 7970 6520 696e 7420 6275  ith dtype int bu
+00017de0: 7420 676f 7420 7b54 2e5f 5f6e 616d 655f  t got {T.__name_
+00017df0: 5f7d 2e27 290a 2020 2020 2020 2020 7265  _}.').        re
+00017e00: 7475 726e 2066 6c6f 6174 0a0a 2020 2020  turn float..    
+00017e10: 6465 6620 5f61 6464 2873 656c 662c 206f  def _add(self, o
+00017e20: 7468 6572 293a 0a20 2020 2020 2020 2069  ther):.        i
+00017e30: 6620 6973 696e 7374 616e 6365 286f 7468  f isinstance(oth
+00017e40: 6572 2c20 5f5f 636c 6173 735f 5f29 3a0a  er, __class__):.
+00017e50: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00017e60: 726e 2073 656c 662e 5f6e 6577 6172 6773  rn self._newargs
+00017e70: 2873 656c 662e 6172 6773 5b30 5d20 2b20  (self.args[0] + 
+00017e80: 6f74 6865 722e 6172 6773 5b30 5d29 0a0a  other.args[0])..
+00017e90: 2020 2020 6465 6620 5f6d 756c 7469 706c      def _multipl
+00017ea0: 7928 7365 6c66 2c20 6f74 6865 7229 3a0a  y(self, other):.
+00017eb0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+00017ec0: 7461 6e63 6528 6f74 6865 722c 205f 5f63  tance(other, __c
+00017ed0: 6c61 7373 5f5f 293a 0a20 2020 2020 2020  lass__):.       
+00017ee0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00017ef0: 2e5f 6e65 7761 7267 7328 7365 6c66 2e61  ._newargs(self.a
+00017f00: 7267 735b 305d 202a 206f 7468 6572 2e61  rgs[0] * other.a
+00017f10: 7267 735b 305d 290a 0a20 2020 2064 6566  rgs[0])..    def
+00017f20: 205f 7375 6d28 7365 6c66 2c20 6178 6973   _sum(self, axis
+00017f30: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00017f40: 6e20 7365 6c66 2e5f 6e65 7761 7267 7328  n self._newargs(
+00017f50: 7375 6d28 7365 6c66 2e61 7267 735b 305d  sum(self.args[0]
+00017f60: 2c20 6178 6973 2929 0a0a 2020 2020 6465  , axis))..    de
+00017f70: 6620 5f70 726f 6475 6374 2873 656c 6629  f _product(self)
+00017f80: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00017f90: 2073 656c 662e 5f6e 6577 6172 6773 2870   self._newargs(p
+00017fa0: 726f 6475 6374 2873 656c 662e 6172 6773  roduct(self.args
+00017fb0: 5b30 5d2c 202d 3129 290a 0a20 2020 2064  [0], -1))..    d
+00017fc0: 6566 205f 7369 676e 2873 656c 6629 3a0a  ef _sign(self):.
+00017fd0: 2020 2020 2020 2020 6173 7365 7274 2073          assert s
+00017fe0: 656c 662e 6474 7970 6520 213d 2063 6f6d  elf.dtype != com
+00017ff0: 706c 6578 0a20 2020 2020 2020 2072 6574  plex.        ret
+00018000: 7572 6e20 7365 6c66 2e5f 6e65 7761 7267  urn self._newarg
+00018010: 7328 7369 676e 2873 656c 662e 6172 6773  s(sign(self.args
+00018020: 5b30 5d29 290a 0a20 2020 2064 6566 205f  [0]))..    def _
+00018030: 6465 7269 7661 7469 7665 2873 656c 662c  derivative(self,
+00018040: 2076 6172 2c20 7365 656e 293a 0a20 2020   var, seen):.   
+00018050: 2020 2020 2072 6574 7572 6e20 5a65 726f       return Zero
+00018060: 7328 7365 6c66 2e73 6861 7065 202b 2076  s(self.shape + v
+00018070: 6172 2e73 6861 7065 2c20 6474 7970 653d  ar.shape, dtype=
+00018080: 7365 6c66 2e64 7479 7065 290a 0a0a 636c  self.dtype)...cl
+00018090: 6173 7320 466c 6f61 7454 6f43 6f6d 706c  ass FloatToCompl
+000180a0: 6578 2843 6173 7429 3a0a 2020 2020 6465  ex(Cast):.    de
+000180b0: 6620 7265 7475 726e 5f74 7970 6528 5429  f return_type(T)
+000180c0: 3a0a 2020 2020 2020 2020 6966 2054 2021  :.        if T !
+000180d0: 3d20 666c 6f61 743a 0a20 2020 2020 2020  = float:.       
+000180e0: 2020 2020 2072 6169 7365 2054 7970 6545       raise TypeE
+000180f0: 7272 6f72 2866 2745 7870 6563 7465 6420  rror(f'Expected 
+00018100: 616e 2061 7272 6179 2077 6974 6820 6474  an array with dt
+00018110: 7970 6520 666c 6f61 7420 6275 7420 676f  ype float but go
+00018120: 7420 7b54 2e5f 5f6e 616d 655f 5f7d 2e27  t {T.__name__}.'
+00018130: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00018140: 2063 6f6d 706c 6578 0a0a 2020 2020 6465   complex..    de
+00018150: 6620 5f61 6464 2873 656c 662c 206f 7468  f _add(self, oth
+00018160: 6572 293a 0a20 2020 2020 2020 2069 6620  er):.        if 
+00018170: 6973 696e 7374 616e 6365 286f 7468 6572  isinstance(other
+00018180: 2c20 5f5f 636c 6173 735f 5f29 3a0a 2020  , __class__):.  
+00018190: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000181a0: 2073 656c 662e 5f6e 6577 6172 6773 2873   self._newargs(s
+000181b0: 656c 662e 6172 6773 5b30 5d20 2b20 6f74  elf.args[0] + ot
+000181c0: 6865 722e 6172 6773 5b30 5d29 0a0a 2020  her.args[0])..  
+000181d0: 2020 6465 6620 5f6d 756c 7469 706c 7928    def _multiply(
+000181e0: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
+000181f0: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00018200: 6e63 6528 6f74 6865 722c 205f 5f63 6c61  nce(other, __cla
+00018210: 7373 5f5f 293a 0a20 2020 2020 2020 2020  ss__):.         
+00018220: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+00018230: 6e65 7761 7267 7328 7365 6c66 2e61 7267  newargs(self.arg
+00018240: 735b 305d 202a 206f 7468 6572 2e61 7267  s[0] * other.arg
+00018250: 735b 305d 290a 0a20 2020 2064 6566 205f  s[0])..    def _
+00018260: 7375 6d28 7365 6c66 2c20 6178 6973 293a  sum(self, axis):
+00018270: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00018280: 7365 6c66 2e5f 6e65 7761 7267 7328 7375  self._newargs(su
+00018290: 6d28 7365 6c66 2e61 7267 735b 305d 2c20  m(self.args[0], 
+000182a0: 6178 6973 2929 0a0a 2020 2020 6465 6620  axis))..    def 
+000182b0: 5f70 726f 6475 6374 2873 656c 6629 3a0a  _product(self):.
+000182c0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+000182d0: 656c 662e 5f6e 6577 6172 6773 2870 726f  elf._newargs(pro
+000182e0: 6475 6374 2873 656c 662e 6172 6773 5b30  duct(self.args[0
+000182f0: 5d2c 202d 3129 290a 0a20 2020 2064 6566  ], -1))..    def
+00018300: 205f 7265 616c 2873 656c 6629 3a0a 2020   _real(self):.  
+00018310: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00018320: 662e 6172 6773 5b30 5d0a 0a20 2020 2064  f.args[0]..    d
+00018330: 6566 205f 696d 6167 2873 656c 6629 3a0a  ef _imag(self):.
+00018340: 2020 2020 2020 2020 7265 7475 726e 207a          return z
+00018350: 6572 6f73 5f6c 696b 6528 7365 6c66 2e61  eros_like(self.a
+00018360: 7267 735b 305d 290a 0a20 2020 2064 6566  rgs[0])..    def
+00018370: 205f 636f 6e6a 7567 6174 6528 7365 6c66   _conjugate(self
+00018380: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00018390: 6e20 7365 6c66 0a0a 2020 2020 6465 6620  n self..    def 
+000183a0: 5f64 6572 6976 6174 6976 6528 7365 6c66  _derivative(self
+000183b0: 2c20 7661 722c 2073 6565 6e29 3a0a 2020  , var, seen):.  
+000183c0: 2020 2020 2020 6966 2076 6172 2e64 7479        if var.dty
+000183d0: 7065 203d 3d20 636f 6d70 6c65 783a 0a20  pe == complex:. 
+000183e0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+000183f0: 2056 616c 7565 4572 726f 7228 2754 6865   ValueError('The
+00018400: 2063 6f6d 706c 6578 2064 6572 6976 6174   complex derivat
+00018410: 6976 6520 646f 6573 206e 6f74 2065 7869  ive does not exi
+00018420: 7374 2e27 290a 2020 2020 2020 2020 6172  st.').        ar
+00018430: 672c 203d 2073 656c 662e 6172 6773 0a20  g, = self.args. 
+00018440: 2020 2020 2020 2072 6574 7572 6e20 466c         return Fl
+00018450: 6f61 7454 6f43 6f6d 706c 6578 2864 6572  oatToComplex(der
+00018460: 6976 6174 6976 6528 6172 672c 2076 6172  ivative(arg, var
+00018470: 2c20 7365 656e 2929 0a0a 0a64 6566 2061  , seen))...def a
+00018480: 7374 7970 6528 6172 672c 2064 7479 7065  stype(arg, dtype
+00018490: 293a 0a20 2020 2061 7267 203d 2061 7361  ):.    arg = asa
+000184a0: 7272 6179 2861 7267 290a 2020 2020 6920  rray(arg).    i 
+000184b0: 3d20 5f74 7970 655f 6f72 6465 722e 696e  = _type_order.in
+000184c0: 6465 7828 6172 672e 6474 7970 6529 0a20  dex(arg.dtype). 
+000184d0: 2020 206a 203d 205f 7479 7065 5f6f 7264     j = _type_ord
+000184e0: 6572 2e69 6e64 6578 2864 7479 7065 290a  er.index(dtype).
+000184f0: 2020 2020 6966 2069 203e 206a 3a0a 2020      if i > j:.  
+00018500: 2020 2020 2020 7261 6973 6520 5479 7065        raise Type
+00018510: 4572 726f 7228 2744 6f77 6e63 6173 7469  Error('Downcasti
+00018520: 6e67 2069 7320 666f 7262 6964 6465 6e2e  ng is forbidden.
+00018530: 2729 0a20 2020 2066 6f72 2063 6173 7420  ').    for cast 
+00018540: 696e 2028 426f 6f6c 546f 496e 742c 2049  in (BoolToInt, I
+00018550: 6e74 546f 466c 6f61 742c 2046 6c6f 6174  ntToFloat, Float
+00018560: 546f 436f 6d70 6c65 7829 5b69 3a6a 5d3a  ToComplex)[i:j]:
+00018570: 0a20 2020 2020 2020 2061 7267 203d 2063  .        arg = c
+00018580: 6173 7428 6172 6729 0a20 2020 2072 6574  ast(arg).    ret
+00018590: 7572 6e20 6172 670a 0a0a 636c 6173 7320  urn arg...class 
+000185a0: 5369 676e 2841 7272 6179 293a 0a0a 2020  Sign(Array):..  
+000185b0: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+000185c0: 656c 662c 2066 756e 633a 2041 7272 6179  elf, func: Array
+000185d0: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+000185e0: 7420 6973 696e 7374 616e 6365 2866 756e  t isinstance(fun
+000185f0: 632c 2041 7272 6179 2920 616e 6420 6675  c, Array) and fu
+00018600: 6e63 2e64 7479 7065 2021 3d20 636f 6d70  nc.dtype != comp
+00018610: 6c65 782c 2066 2766 756e 633d 7b66 756e  lex, f'func={fun
+00018620: 6321 727d 270a 2020 2020 2020 2020 7365  c!r}'.        se
+00018630: 6c66 2e66 756e 6320 3d20 6675 6e63 0a20  lf.func = func. 
+00018640: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+00018650: 5f69 6e69 745f 5f28 6172 6773 3d28 6675  _init__(args=(fu
+00018660: 6e63 2c29 2c20 7368 6170 653d 6675 6e63  nc,), shape=func
+00018670: 2e73 6861 7065 2c20 6474 7970 653d 6675  .shape, dtype=fu
+00018680: 6e63 2e64 7479 7065 290a 0a20 2020 2064  nc.dtype)..    d
+00018690: 6566 205f 7369 6d70 6c69 6669 6564 2873  ef _simplified(s
+000186a0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+000186b0: 7475 726e 2073 656c 662e 6675 6e63 2e5f  turn self.func._
+000186c0: 7369 676e 2829 0a0a 2020 2020 6576 616c  sign()..    eval
+000186d0: 6620 3d20 7374 6174 6963 6d65 7468 6f64  f = staticmethod
+000186e0: 286e 756d 7079 2e73 6967 6e29 0a0a 2020  (numpy.sign)..  
+000186f0: 2020 6465 6620 5f74 616b 6564 6961 6728    def _takediag(
+00018700: 7365 6c66 2c20 6178 6973 312c 2061 7869  self, axis1, axi
+00018710: 7332 293a 0a20 2020 2020 2020 2072 6574  s2):.        ret
+00018720: 7572 6e20 5369 676e 285f 7461 6b65 6469  urn Sign(_takedi
+00018730: 6167 2873 656c 662e 6675 6e63 2c20 6178  ag(self.func, ax
+00018740: 6973 312c 2061 7869 7332 2929 0a0a 2020  is1, axis2))..  
+00018750: 2020 6465 6620 5f74 616b 6528 7365 6c66    def _take(self
+00018760: 2c20 696e 6465 782c 2061 7869 7329 3a0a  , index, axis):.
+00018770: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+00018780: 6967 6e28 5f74 616b 6528 7365 6c66 2e66  ign(_take(self.f
+00018790: 756e 632c 2069 6e64 6578 2c20 6178 6973  unc, index, axis
+000187a0: 2929 0a0a 2020 2020 6465 6620 5f73 6967  ))..    def _sig
+000187b0: 6e28 7365 6c66 293a 0a20 2020 2020 2020  n(self):.       
+000187c0: 2072 6574 7572 6e20 7365 6c66 0a0a 2020   return self..  
+000187d0: 2020 6465 6620 5f75 6e72 6176 656c 2873    def _unravel(s
+000187e0: 656c 662c 2061 7869 732c 2073 6861 7065  elf, axis, shape
+000187f0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00018800: 6e20 5369 676e 2875 6e72 6176 656c 2873  n Sign(unravel(s
+00018810: 656c 662e 6675 6e63 2c20 6178 6973 2c20  elf.func, axis, 
+00018820: 7368 6170 6529 290a 0a20 2020 2064 6566  shape))..    def
+00018830: 205f 6465 7269 7661 7469 7665 2873 656c   _derivative(sel
+00018840: 662c 2076 6172 2c20 7365 656e 293a 0a20  f, var, seen):. 
+00018850: 2020 2020 2020 2072 6574 7572 6e20 5a65         return Ze
+00018860: 726f 7328 7365 6c66 2e73 6861 7065 202b  ros(self.shape +
+00018870: 2076 6172 2e73 6861 7065 2c20 6474 7970   var.shape, dtyp
+00018880: 653d 7365 6c66 2e64 7479 7065 290a 0a20  e=self.dtype).. 
+00018890: 2020 2064 6566 205f 696e 7462 6f75 6e64     def _intbound
+000188a0: 735f 696d 706c 2873 656c 6629 3a0a 2020  s_impl(self):.  
+000188b0: 2020 2020 2020 6c6f 7765 722c 2075 7070        lower, upp
+000188c0: 6572 203d 2073 656c 662e 6675 6e63 2e5f  er = self.func._
+000188d0: 696e 7462 6f75 6e64 730a 2020 2020 2020  intbounds.      
+000188e0: 2020 7265 7475 726e 2069 6e74 286e 756d    return int(num
+000188f0: 7079 2e73 6967 6e28 6c6f 7765 7229 292c  py.sign(lower)),
+00018900: 2069 6e74 286e 756d 7079 2e73 6967 6e28   int(numpy.sign(
+00018910: 7570 7065 7229 290a 0a0a 636c 6173 7320  upper))...class 
+00018920: 5361 6d70 6c65 6428 4172 7261 7929 3a0a  Sampled(Array):.
+00018930: 2020 2020 2727 2742 6173 6973 2d6c 696b      '''Basis-lik
+00018940: 6520 6964 656e 7469 7479 206f 7065 7261  e identity opera
+00018950: 746f 722e 0a0a 2020 2020 4261 7369 732d  tor...    Basis-
+00018960: 6c69 6b65 2066 756e 6374 696f 6e20 7468  like function th
+00018970: 6174 2066 6f72 2065 7665 7279 2070 6f69  at for every poi
+00018980: 6e74 2065 7661 6c75 6174 6573 2074 6f20  nt evaluates to 
+00018990: 6120 7061 7274 6974 696f 6e20 6f66 2075  a partition of u
+000189a0: 6e69 7479 0a20 2020 206f 6620 6120 7072  nity.    of a pr
+000189b0: 6564 6566 696e 6564 2073 6574 2062 6173  edefined set bas
+000189c0: 6564 206f 6e20 7468 6520 7365 6c65 6374  ed on the select
+000189d0: 6564 2069 6e74 6572 706f 6c61 7469 6f6e  ed interpolation
+000189e0: 2073 6368 656d 652e 0a0a 2020 2020 4172   scheme...    Ar
+000189f0: 6773 0a20 2020 202d 2d2d 2d0a 2020 2020  gs.    ----.    
+00018a00: 706f 696e 7473 203a 2032 6420 3a63 6c61  points : 2d :cla
+00018a10: 7373 3a60 4172 7261 7960 0a20 2020 2020  ss:`Array`.     
+00018a20: 2020 2050 7265 7365 6e74 2070 6f69 6e74     Present point
+00018a30: 2063 6f6f 7264 696e 6174 6573 2e0a 2020   coordinates..  
+00018a40: 2020 7461 7267 6574 203a 2032 6420 3a63    target : 2d :c
+00018a50: 6c61 7373 3a60 4172 7261 7960 0a20 2020  lass:`Array`.   
+00018a60: 2020 2020 2045 6c65 6d65 6e74 7769 7365       Elementwise
+00018a70: 2063 6f6e 7374 616e 7420 7468 6174 2065   constant that e
+00018a80: 7661 6c75 6174 6573 2074 6f20 7468 6520  valuates to the 
+00018a90: 7461 7267 6574 2070 6f69 6e74 2063 6f6f  target point coo
+00018aa0: 7264 696e 6174 6573 2e0a 2020 2020 696e  rdinates..    in
+00018ab0: 7465 7270 6f6c 6174 696f 6e20 3a20 3a63  terpolation : :c
+00018ac0: 6c61 7373 3a60 7374 7260 0a20 2020 2020  lass:`str`.     
+00018ad0: 2020 2049 6e74 6572 706f 6c61 7469 6f6e     Interpolation
+00018ae0: 2073 6368 656d 6520 746f 206d 6170 2070   scheme to map p
+00018af0: 6f69 6e74 7320 746f 2074 6172 6765 743a  oints to target:
+00018b00: 2022 6e6f 6e65 2220 6f72 2022 6e65 6172   "none" or "near
+00018b10: 6573 7422 2e0a 2020 2020 2727 270a 0a20  est"..    '''.. 
+00018b20: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
+00018b30: 7365 6c66 2c20 706f 696e 7473 3a20 4172  self, points: Ar
+00018b40: 7261 792c 2074 6172 6765 743a 2041 7272  ray, target: Arr
+00018b50: 6179 2c20 696e 7465 7270 6f6c 6174 696f  ay, interpolatio
+00018b60: 6e3a 2073 7472 293a 0a20 2020 2020 2020  n: str):.       
+00018b70: 2061 7373 6572 7420 6973 696e 7374 616e   assert isinstan
+00018b80: 6365 2870 6f69 6e74 732c 2041 7272 6179  ce(points, Array
+00018b90: 2920 616e 6420 706f 696e 7473 2e6e 6469  ) and points.ndi
+00018ba0: 6d20 3d3d 2032 2c20 6627 706f 696e 7473  m == 2, f'points
+00018bb0: 3d7b 706f 696e 7473 2172 7d27 0a20 2020  ={points!r}'.   
+00018bc0: 2020 2020 2061 7373 6572 7420 6973 696e       assert isin
+00018bd0: 7374 616e 6365 2874 6172 6765 742c 2041  stance(target, A
+00018be0: 7272 6179 2920 616e 6420 7461 7267 6574  rray) and target
+00018bf0: 2e6e 6469 6d20 3d3d 2032 2c20 6627 7461  .ndim == 2, f'ta
+00018c00: 7267 6574 3d7b 7461 7267 6574 2172 7d27  rget={target!r}'
+00018c10: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+00018c20: 706f 696e 7473 2e73 6861 7065 5b31 5d20  points.shape[1] 
+00018c30: 3d3d 2074 6172 6765 742e 7368 6170 655b  == target.shape[
+00018c40: 315d 0a20 2020 2020 2020 2069 6620 696e  1].        if in
+00018c50: 7465 7270 6f6c 6174 696f 6e20 3d3d 2027  terpolation == '
+00018c60: 6e6f 6e65 273a 0a20 2020 2020 2020 2020  none':.         
+00018c70: 2020 2073 656c 662e 6576 616c 6620 3d20     self.evalf = 
+00018c80: 7365 6c66 2e65 7661 6c66 5f6e 6f6e 650a  self.evalf_none.
+00018c90: 2020 2020 2020 2020 656c 6966 2069 6e74          elif int
+00018ca0: 6572 706f 6c61 7469 6f6e 203d 3d20 276e  erpolation == 'n
+00018cb0: 6561 7265 7374 273a 0a20 2020 2020 2020  earest':.       
+00018cc0: 2020 2020 2073 656c 662e 6576 616c 6620       self.evalf 
+00018cd0: 3d20 7365 6c66 2e65 7661 6c66 5f6e 6561  = self.evalf_nea
+00018ce0: 7265 7374 0a20 2020 2020 2020 2065 6c73  rest.        els
+00018cf0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+00018d00: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+00018d10: 6627 696e 7661 6c69 6420 696e 7465 7270  f'invalid interp
+00018d20: 6f6c 6174 696f 6e20 7b69 6e74 6572 706f  olation {interpo
+00018d30: 6c61 7469 6f6e 2172 7d3b 2076 616c 6964  lation!r}; valid
+00018d40: 2076 616c 7565 7320 6172 6520 226e 6f6e   values are "non
+00018d50: 6522 2061 6e64 2022 6e65 6172 6573 7422  e" and "nearest"
+00018d60: 2729 0a20 2020 2020 2020 2073 7570 6572  ').        super
+00018d70: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
+00018d80: 3d28 706f 696e 7473 2c20 7461 7267 6574  =(points, target
+00018d90: 292c 2073 6861 7065 3d28 706f 696e 7473  ), shape=(points
+00018da0: 2e73 6861 7065 5b30 5d2c 2074 6172 6765  .shape[0], targe
+00018db0: 742e 7368 6170 655b 305d 292c 2064 7479  t.shape[0]), dty
+00018dc0: 7065 3d66 6c6f 6174 290a 0a20 2020 2040  pe=float)..    @
+00018dd0: 7374 6174 6963 6d65 7468 6f64 0a20 2020  staticmethod.   
+00018de0: 2064 6566 2065 7661 6c66 5f6e 6f6e 6528   def evalf_none(
+00018df0: 706f 696e 7473 2c20 7461 7267 6574 293a  points, target):
+00018e00: 0a20 2020 2020 2020 2069 6620 706f 696e  .        if poin
+00018e10: 7473 2e73 6861 7065 2021 3d20 7461 7267  ts.shape != targ
+00018e20: 6574 2e73 6861 7065 206f 7220 6e6f 7420  et.shape or not 
+00018e30: 6e75 6d70 792e 6571 7561 6c28 706f 696e  numpy.equal(poin
+00018e40: 7473 2c20 7461 7267 6574 292e 616c 6c28  ts, target).all(
+00018e50: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+00018e60: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+00018e70: 2770 6f69 6e74 7320 646f 206e 6f74 2063  'points do not c
+00018e80: 6f72 7265 7370 6f6e 6420 746f 2074 6865  orrespond to the
+00018e90: 2074 6172 6765 7420 7361 6d70 6c65 3b20   target sample; 
+00018ea0: 636f 6e73 6964 6572 2075 7369 6e67 2022  consider using "
+00018eb0: 6e65 6172 6573 7422 2069 6e74 6572 706f  nearest" interpo
+00018ec0: 6c61 7469 6f6e 2069 6620 7468 6973 2069  lation if this i
+00018ed0: 7320 6465 7369 7265 6427 290a 2020 2020  s desired').    
+00018ee0: 2020 2020 7265 7475 726e 206e 756d 7079      return numpy
+00018ef0: 2e65 7965 286c 656e 2870 6f69 6e74 7329  .eye(len(points)
+00018f00: 290a 0a20 2020 2040 7374 6174 6963 6d65  )..    @staticme
+00018f10: 7468 6f64 0a20 2020 2064 6566 2065 7661  thod.    def eva
+00018f20: 6c66 5f6e 6561 7265 7374 2870 6f69 6e74  lf_nearest(point
+00018f30: 732c 2074 6172 6765 7429 3a0a 2020 2020  s, target):.    
+00018f40: 2020 2020 6e65 6172 6573 7420 3d20 6e75      nearest = nu
+00018f50: 6d70 792e 6c69 6e61 6c67 2e6e 6f72 6d28  mpy.linalg.norm(
+00018f60: 706f 696e 7473 5b3a 2c6e 756d 7079 2e6e  points[:,numpy.n
+00018f70: 6577 6178 6973 2c3a 5d20 2d20 7461 7267  ewaxis,:] - targ
+00018f80: 6574 5b6e 756d 7079 2e6e 6577 6178 6973  et[numpy.newaxis
+00018f90: 2c3a 2c3a 5d2c 2061 7869 733d 3229 2e61  ,:,:], axis=2).a
+00018fa0: 7267 6d69 6e28 6178 6973 3d31 290a 2020  rgmin(axis=1).  
+00018fb0: 2020 2020 2020 7265 7475 726e 206e 756d        return num
+00018fc0: 7079 2e65 7965 286c 656e 2874 6172 6765  py.eye(len(targe
+00018fd0: 7429 295b 6e65 6172 6573 745d 0a0a 0a64  t))[nearest]...d
+00018fe0: 6566 2045 6c65 6d77 6973 6528 6461 7461  ef Elemwise(data
+00018ff0: 3a20 7479 7069 6e67 2e54 7570 6c65 5b74  : typing.Tuple[t
+00019000: 7970 6573 2e61 7272 6179 6461 7461 2c20  ypes.arraydata, 
+00019010: 2e2e 2e5d 2c20 696e 6465 783a 2041 7272  ...], index: Arr
+00019020: 6179 2c20 6474 7970 653a 2044 7479 7065  ay, dtype: Dtype
+00019030: 293a 0a20 2020 2061 7373 6572 7420 6973  ):.    assert is
+00019040: 696e 7374 616e 6365 2864 6174 612c 2074  instance(data, t
+00019050: 7570 6c65 2920 616e 6420 616c 6c28 6973  uple) and all(is
+00019060: 696e 7374 616e 6365 2864 2c20 7479 7065  instance(d, type
+00019070: 732e 6172 7261 7964 6174 6129 2061 6e64  s.arraydata) and
+00019080: 2064 2e64 7479 7065 203d 3d20 6474 7970   d.dtype == dtyp
+00019090: 6520 666f 7220 6420 696e 2064 6174 6129  e for d in data)
+000190a0: 2c20 6627 6461 7461 3d7b 6461 7461 2172  , f'data={data!r
+000190b0: 7d27 0a20 2020 2061 7373 6572 7420 6973  }'.    assert is
+000190c0: 696e 7374 616e 6365 2869 6e64 6578 2c20  instance(index, 
+000190d0: 4172 7261 7929 2061 6e64 2069 6e64 6578  Array) and index
+000190e0: 2e6e 6469 6d20 3d3d 2030 2061 6e64 2069  .ndim == 0 and i
+000190f0: 6e64 6578 2e64 7479 7065 203d 3d20 696e  ndex.dtype == in
+00019100: 742c 2066 2769 6e64 6578 3d7b 696e 6465  t, f'index={inde
+00019110: 7821 727d 270a 2020 2020 756e 6971 7565  x!r}'.    unique
+00019120: 2c20 696e 6469 6365 7320 3d20 7574 696c  , indices = util
+00019130: 2e75 6e69 7175 6528 6461 7461 290a 2020  .unique(data).  
+00019140: 2020 6966 206c 656e 2875 6e69 7175 6529    if len(unique)
+00019150: 203d 3d20 313a 0a20 2020 2020 2020 2072   == 1:.        r
+00019160: 6574 7572 6e20 436f 6e73 7461 6e74 2875  eturn Constant(u
+00019170: 6e69 7175 655b 305d 290a 2020 2020 2320  nique[0]).    # 
+00019180: 4372 6561 7465 2073 6861 7065 2066 726f  Create shape fro
+00019190: 6d20 6461 7461 2061 6e64 2069 6e64 6578  m data and index
+000191a0: 2c20 7261 7468 6572 2074 6861 6e20 756e  , rather than un
+000191b0: 6971 7565 2061 6e64 2074 6865 206d 6f64  ique and the mod
+000191c0: 6966 6965 640a 2020 2020 2320 696e 6465  ified.    # inde
+000191d0: 782c 2069 6e20 6f72 6465 7220 746f 2061  x, in order to a
+000191e0: 766f 6964 2070 6f74 656e 7469 616c 2073  void potential s
+000191f0: 6861 7065 2069 6e63 6f6e 7369 7374 656e  hape inconsisten
+00019200: 6369 6573 206c 6174 6572 206f 6e2e 0a20  cies later on.. 
+00019210: 2020 2073 6861 7065 7320 3d20 6e75 6d70     shapes = nump
+00019220: 792e 6172 7261 7928 5b64 2e73 6861 7065  y.array([d.shape
+00019230: 2066 6f72 2064 2069 6e20 6461 7461 5d29   for d in data])
+00019240: 0a20 2020 2073 6861 7065 203d 205b 5461  .    shape = [Ta
+00019250: 6b65 2863 6f6e 7374 616e 7428 7329 2c20  ke(constant(s), 
+00019260: 696e 6465 7829 2066 6f72 2073 2069 6e20  index) for s in 
+00019270: 7368 6170 6573 2e54 5d0a 2020 2020 6966  shapes.T].    if
+00019280: 206c 656e 2875 6e69 7175 6529 203c 206c   len(unique) < l
+00019290: 656e 2864 6174 6129 3a0a 2020 2020 2020  en(data):.      
+000192a0: 2020 696e 6465 7820 3d20 5461 6b65 2863    index = Take(c
+000192b0: 6f6e 7374 616e 7428 696e 6469 6365 7329  onstant(indices)
+000192c0: 2c20 696e 6465 7829 0a20 2020 2023 204d  , index).    # M
+000192d0: 6f76 6520 616c 6c20 6178 6573 2077 6974  ove all axes wit
+000192e0: 6820 636f 6e73 7461 6e74 2073 6861 7065  h constant shape
+000192f0: 2074 6f20 7468 6520 6c65 6674 2061 6e64   to the left and
+00019300: 2072 6176 656c 2074 6865 2072 656d 6169   ravel the remai
+00019310: 6e64 6572 2e0a 2020 2020 6973 5f63 6f6e  nder..    is_con
+00019320: 7374 616e 7420 3d20 6e75 6d70 792e 616c  stant = numpy.al
+00019330: 6c28 7368 6170 6573 5b31 3a5d 203d 3d20  l(shapes[1:] == 
+00019340: 7368 6170 6573 5b30 5d2c 2061 7869 733d  shapes[0], axis=
+00019350: 3029 0a20 2020 206e 636f 6e73 7461 6e74  0).    nconstant
+00019360: 203d 2069 735f 636f 6e73 7461 6e74 2e73   = is_constant.s
+00019370: 756d 2829 0a20 2020 2072 656f 7264 6572  um().    reorder
+00019380: 203d 206e 756d 7079 2e61 7267 736f 7274   = numpy.argsort
+00019390: 287e 6973 5f63 6f6e 7374 616e 7429 0a20  (~is_constant). 
+000193a0: 2020 2072 6176 656c 6564 203d 205b 6e75     raveled = [nu
+000193b0: 6d70 792e 7472 616e 7370 6f73 6528 642c  mpy.transpose(d,
+000193c0: 2072 656f 7264 6572 292e 7265 7368 6170   reorder).reshap
+000193d0: 6528 2a73 6861 7065 735b 302c 2072 656f  e(*shapes[0, reo
+000193e0: 7264 6572 5b3a 6e63 6f6e 7374 616e 745d  rder[:nconstant]
+000193f0: 5d2c 202d 3129 2066 6f72 2064 2069 6e20  ], -1) for d in 
+00019400: 756e 6971 7565 5d0a 2020 2020 2320 436f  unique].    # Co
+00019410: 6e63 6174 656e 6174 6520 7468 6520 7261  ncatenate the ra
+00019420: 7665 6c65 6420 6178 6973 2c20 7461 6b65  veled axis, take
+00019430: 2073 6c69 6365 732c 2075 6e72 6176 656c   slices, unravel
+00019440: 2061 6e64 2072 656f 7264 6572 2074 6865   and reorder the
+00019450: 2061 7865 7320 746f 0a20 2020 2023 2074   axes to.    # t
+00019460: 6865 206f 7269 6769 6e61 6c20 706f 7369  he original posi
+00019470: 7469 6f6e 2e0a 2020 2020 636f 6e63 6174  tion..    concat
+00019480: 203d 2063 6f6e 7374 616e 7428 6e75 6d70   = constant(nump
+00019490: 792e 636f 6e63 6174 656e 6174 6528 7261  y.concatenate(ra
+000194a0: 7665 6c65 642c 2061 7869 733d 2d31 2929  veled, axis=-1))
+000194b0: 0a20 2020 2069 6620 6973 5f63 6f6e 7374  .    if is_const
+000194c0: 616e 742e 616c 6c28 293a 0a20 2020 2020  ant.all():.     
+000194d0: 2020 2072 6574 7572 6e20 5461 6b65 2863     return Take(c
+000194e0: 6f6e 6361 742c 2069 6e64 6578 290a 2020  oncat, index).  
+000194f0: 2020 7661 725f 7368 6170 6520 3d20 7475    var_shape = tu
+00019500: 706c 6528 7368 6170 655b 695d 2066 6f72  ple(shape[i] for
+00019510: 2069 2069 6e20 7265 6f72 6465 725b 6e63   i in reorder[nc
+00019520: 6f6e 7374 616e 743a 5d29 0a20 2020 2063  onstant:]).    c
+00019530: 756d 7072 6f64 203d 206c 6973 7428 7661  umprod = list(va
+00019540: 725f 7368 6170 6529 0a20 2020 2066 6f72  r_shape).    for
+00019550: 2069 2069 6e20 7265 7665 7273 6564 2872   i in reversed(r
+00019560: 616e 6765 286c 656e 2876 6172 5f73 6861  ange(len(var_sha
+00019570: 7065 292d 3129 293a 0a20 2020 2020 2020  pe)-1)):.       
+00019580: 2063 756d 7072 6f64 5b69 5d20 2a3d 2063   cumprod[i] *= c
+00019590: 756d 7072 6f64 5b69 2b31 5d20 2023 2077  umprod[i+1]  # w
+000195a0: 6f72 6b20 6261 636b 7761 7264 7320 736f  ork backwards so
+000195b0: 2074 6861 7420 7468 6520 7368 6170 6520   that the shape 
+000195c0: 6368 6563 6b20 6d61 7463 6865 7320 696e  check matches in
+000195d0: 2055 6e72 6176 656c 0a20 2020 206f 6666   Unravel.    off
+000195e0: 7365 7473 203d 205f 5369 7a65 7354 6f4f  sets = _SizesToO
+000195f0: 6666 7365 7473 2861 7361 7272 6179 285b  ffsets(asarray([
+00019600: 642e 7368 6170 655b 2d31 5d20 666f 7220  d.shape[-1] for 
+00019610: 6420 696e 2072 6176 656c 6564 5d29 290a  d in raveled])).
+00019620: 2020 2020 656c 656d 7769 7365 203d 2054      elemwise = T
+00019630: 616b 6528 636f 6e63 6174 2c20 5261 6e67  ake(concat, Rang
+00019640: 6528 6375 6d70 726f 645b 305d 2920 2b20  e(cumprod[0]) + 
+00019650: 5461 6b65 286f 6666 7365 7473 2c20 696e  Take(offsets, in
+00019660: 6465 7829 290a 2020 2020 666f 7220 6920  dex)).    for i 
+00019670: 696e 2072 616e 6765 286c 656e 2876 6172  in range(len(var
+00019680: 5f73 6861 7065 292d 3129 3a0a 2020 2020  _shape)-1):.    
+00019690: 2020 2020 656c 656d 7769 7365 203d 2055      elemwise = U
+000196a0: 6e72 6176 656c 2865 6c65 6d77 6973 652c  nravel(elemwise,
+000196b0: 2076 6172 5f73 6861 7065 5b69 5d2c 2063   var_shape[i], c
+000196c0: 756d 7072 6f64 5b69 2b31 5d29 0a20 2020  umprod[i+1]).   
+000196d0: 2072 6574 7572 6e20 5472 616e 7370 6f73   return Transpos
+000196e0: 652e 696e 7628 656c 656d 7769 7365 2c20  e.inv(elemwise, 
+000196f0: 7265 6f72 6465 7229 0a0a 0a63 6c61 7373  reorder)...class
+00019700: 2045 6967 2845 7661 6c75 6162 6c65 293a   Eig(Evaluable):
+00019710: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
+00019720: 5f5f 2873 656c 662c 2066 756e 633a 2041  __(self, func: A
+00019730: 7272 6179 2c20 7379 6d6d 6574 7269 633a  rray, symmetric:
+00019740: 2062 6f6f 6c20 3d20 4661 6c73 6529 3a0a   bool = False):.
+00019750: 2020 2020 2020 2020 6173 7365 7274 2069          assert i
+00019760: 7369 6e73 7461 6e63 6528 6675 6e63 2c20  sinstance(func, 
+00019770: 4172 7261 7929 2061 6e64 2066 756e 632e  Array) and func.
+00019780: 6e64 696d 203e 3d20 3220 616e 6420 5f65  ndim >= 2 and _e
+00019790: 7175 616c 735f 7369 6d70 6c69 6669 6564  quals_simplified
+000197a0: 2866 756e 632e 7368 6170 655b 2d31 5d2c  (func.shape[-1],
+000197b0: 2066 756e 632e 7368 6170 655b 2d32 5d29   func.shape[-2])
+000197c0: 2c20 6627 6675 6e63 3d7b 6675 6e63 2172  , f'func={func!r
+000197d0: 7d27 0a20 2020 2020 2020 2061 7373 6572  }'.        asser
+000197e0: 7420 6973 696e 7374 616e 6365 2873 796d  t isinstance(sym
+000197f0: 6d65 7472 6963 2c20 626f 6f6c 292c 2066  metric, bool), f
+00019800: 2773 796d 6d65 7472 6963 3d7b 7379 6d6d  'symmetric={symm
+00019810: 6574 7269 6321 727d 270a 2020 2020 2020  etric!r}'.      
+00019820: 2020 7365 6c66 2e73 796d 6d65 7472 6963    self.symmetric
+00019830: 203d 2073 796d 6d65 7472 6963 0a20 2020   = symmetric.   
+00019840: 2020 2020 2073 656c 662e 6675 6e63 203d       self.func =
+00019850: 2066 756e 630a 2020 2020 2020 2020 7365   func.        se
+00019860: 6c66 2e5f 775f 6474 7970 6520 3d20 666c  lf._w_dtype = fl
+00019870: 6f61 7420 6966 2073 796d 6d65 7472 6963  oat if symmetric
+00019880: 2065 6c73 6520 636f 6d70 6c65 780a 2020   else complex.  
+00019890: 2020 2020 2020 7365 6c66 2e5f 7674 5f64        self._vt_d
+000198a0: 7479 7065 203d 2066 6c6f 6174 2069 6620  type = float if 
+000198b0: 7379 6d6d 6574 7269 6320 616e 6420 6675  symmetric and fu
+000198c0: 6e63 2e64 7479 7065 2021 3d20 636f 6d70  nc.dtype != comp
+000198d0: 6c65 7820 656c 7365 2063 6f6d 706c 6578  lex else complex
+000198e0: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
+000198f0: 2e5f 5f69 6e69 745f 5f28 6172 6773 3d28  .__init__(args=(
+00019900: 6675 6e63 2c29 290a 0a20 2020 2064 6566  func,))..    def
+00019910: 205f 5f6c 656e 5f5f 2873 656c 6629 3a0a   __len__(self):.
+00019920: 2020 2020 2020 2020 7265 7475 726e 2032          return 2
+00019930: 0a0a 2020 2020 6465 6620 5f5f 6765 7469  ..    def __geti
+00019940: 7465 6d5f 5f28 7365 6c66 2c20 696e 6465  tem__(self, inde
+00019950: 7829 3a0a 2020 2020 2020 2020 6966 2069  x):.        if i
+00019960: 6e64 6578 203d 3d20 303a 0a20 2020 2020  ndex == 0:.     
+00019970: 2020 2020 2020 2073 6861 7065 203d 2073         shape = s
+00019980: 656c 662e 6675 6e63 2e73 6861 7065 5b3a  elf.func.shape[:
+00019990: 2d31 5d0a 2020 2020 2020 2020 2020 2020  -1].            
+000199a0: 6474 7970 6520 3d20 7365 6c66 2e5f 775f  dtype = self._w_
+000199b0: 6474 7970 650a 2020 2020 2020 2020 656c  dtype.        el
+000199c0: 6966 2069 6e64 6578 203d 3d20 313a 0a20  if index == 1:. 
+000199d0: 2020 2020 2020 2020 2020 2073 6861 7065             shape
+000199e0: 3d73 656c 662e 6675 6e63 2e73 6861 7065  =self.func.shape
+000199f0: 0a20 2020 2020 2020 2020 2020 2064 7479  .            dty
+00019a00: 7065 3d73 656c 662e 5f76 745f 6474 7970  pe=self._vt_dtyp
+00019a10: 650a 2020 2020 2020 2020 656c 7365 3a0a  e.        else:.
+00019a20: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00019a30: 6520 496e 6465 7845 7272 6f72 0a20 2020  e IndexError.   
+00019a40: 2020 2020 2072 6574 7572 6e20 4172 7261       return Arra
+00019a50: 7946 726f 6d54 7570 6c65 2873 656c 662c  yFromTuple(self,
+00019a60: 2069 6e64 6578 3d69 6e64 6578 2c20 7368   index=index, sh
+00019a70: 6170 653d 7368 6170 652c 2064 7479 7065  ape=shape, dtype
+00019a80: 3d64 7479 7065 290a 0a20 2020 2064 6566  =dtype)..    def
+00019a90: 205f 7369 6d70 6c69 6669 6564 2873 656c   _simplified(sel
+00019aa0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+00019ab0: 726e 2073 656c 662e 6675 6e63 2e5f 6569  rn self.func._ei
+00019ac0: 6728 7365 6c66 2e73 796d 6d65 7472 6963  g(self.symmetric
+00019ad0: 290a 0a20 2020 2064 6566 2065 7661 6c66  )..    def evalf
+00019ae0: 2873 656c 662c 2061 7272 293a 0a20 2020  (self, arr):.   
+00019af0: 2020 2020 2077 2c20 7674 203d 2028 6e75       w, vt = (nu
+00019b00: 6d70 792e 6c69 6e61 6c67 2e65 6967 6820  mpy.linalg.eigh 
+00019b10: 6966 2073 656c 662e 7379 6d6d 6574 7269  if self.symmetri
+00019b20: 6320 656c 7365 206e 756d 7079 2e6c 696e  c else numpy.lin
+00019b30: 616c 672e 6569 6729 2861 7272 290a 2020  alg.eig)(arr).  
+00019b40: 2020 2020 2020 7720 3d20 772e 6173 7479        w = w.asty
+00019b50: 7065 2873 656c 662e 5f77 5f64 7479 7065  pe(self._w_dtype
+00019b60: 2c20 636f 7079 3d46 616c 7365 290a 2020  , copy=False).  
+00019b70: 2020 2020 2020 7674 203d 2076 742e 6173        vt = vt.as
+00019b80: 7479 7065 2873 656c 662e 5f76 745f 6474  type(self._vt_dt
+00019b90: 7970 652c 2063 6f70 793d 4661 6c73 6529  ype, copy=False)
+00019ba0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00019bb0: 2877 2c20 7674 290a 0a0a 636c 6173 7320  (w, vt)...class 
+00019bc0: 4172 7261 7946 726f 6d54 7570 6c65 2841  ArrayFromTuple(A
+00019bd0: 7272 6179 293a 0a0a 2020 2020 6465 6620  rray):..    def 
+00019be0: 5f5f 696e 6974 5f5f 2873 656c 662c 2061  __init__(self, a
+00019bf0: 7272 6179 733a 2045 7661 6c75 6162 6c65  rrays: Evaluable
+00019c00: 2c20 696e 6465 783a 2069 6e74 2c20 7368  , index: int, sh
+00019c10: 6170 653a 2074 7970 696e 672e 5475 706c  ape: typing.Tupl
+00019c20: 655b 4172 7261 792c 202e 2e2e 5d2c 2064  e[Array, ...], d
+00019c30: 7479 7065 3a20 4474 7970 652c 202a 2c20  type: Dtype, *, 
+00019c40: 5f6c 6f77 6572 3d66 6c6f 6174 2827 2d69  _lower=float('-i
+00019c50: 6e66 2729 2c20 5f75 7070 6572 3d66 6c6f  nf'), _upper=flo
+00019c60: 6174 2827 696e 6627 2929 3a0a 2020 2020  at('inf')):.    
+00019c70: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
+00019c80: 7461 6e63 6528 6172 7261 7973 2c20 4576  tance(arrays, Ev
+00019c90: 616c 7561 626c 6529 2c20 6627 6172 7261  aluable), f'arra
+00019ca0: 7973 3d7b 6172 7261 7973 2172 7d27 0a20  ys={arrays!r}'. 
+00019cb0: 2020 2020 2020 2061 7373 6572 7420 6973         assert is
+00019cc0: 696e 7374 616e 6365 2869 6e64 6578 2c20  instance(index, 
+00019cd0: 696e 7429 2c20 6627 696e 6465 783d 667b  int), f'index=f{
+00019ce0: 696e 6465 787d 270a 2020 2020 2020 2020  index}'.        
+00019cf0: 7365 6c66 2e61 7272 6179 7320 3d20 6172  self.arrays = ar
+00019d00: 7261 7973 0a20 2020 2020 2020 2073 656c  rays.        sel
+00019d10: 662e 696e 6465 7820 3d20 696e 6465 780a  f.index = index.
+00019d20: 2020 2020 2020 2020 7365 6c66 2e5f 6c6f          self._lo
+00019d30: 7765 7220 3d20 5f6c 6f77 6572 0a20 2020  wer = _lower.   
+00019d40: 2020 2020 2073 656c 662e 5f75 7070 6572       self._upper
+00019d50: 203d 205f 7570 7065 720a 2020 2020 2020   = _upper.      
+00019d60: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
+00019d70: 5f5f 2861 7267 733d 2861 7272 6179 732c  __(args=(arrays,
+00019d80: 292c 2073 6861 7065 3d73 6861 7065 2c20  ), shape=shape, 
+00019d90: 6474 7970 653d 6474 7970 6529 0a0a 2020  dtype=dtype)..  
+00019da0: 2020 6465 6620 5f73 696d 706c 6966 6965    def _simplifie
+00019db0: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
+00019dc0: 2069 6620 6973 696e 7374 616e 6365 2873   if isinstance(s
+00019dd0: 656c 662e 6172 7261 7973 2c20 5475 706c  elf.arrays, Tupl
+00019de0: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
+00019df0: 2320 5468 6973 2061 6c6c 6f77 7320 7468  # This allows th
+00019e00: 6520 7365 6c66 2e61 7272 6179 7320 6576  e self.arrays ev
+00019e10: 616c 7561 626c 6520 746f 2073 696d 706c  aluable to simpl
+00019e20: 6966 7920 6974 7365 6c66 2069 6e74 6f20  ify itself into 
+00019e30: 610a 2020 2020 2020 2020 2020 2020 2320  a.            # 
+00019e40: 5475 706c 6520 616e 6420 6974 7320 636f  Tuple and its co
+00019e50: 6d70 6f6e 656e 7473 2062 6520 6578 706f  mponents be expo
+00019e60: 7365 6420 746f 2074 6865 2066 756e 6374  sed to the funct
+00019e70: 696f 6e20 7472 6565 2e0a 2020 2020 2020  ion tree..      
+00019e80: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00019e90: 662e 6172 7261 7973 5b73 656c 662e 696e  f.arrays[self.in
+00019ea0: 6465 785d 0a0a 2020 2020 6465 6620 6576  dex]..    def ev
+00019eb0: 616c 6628 7365 6c66 2c20 6172 7261 7973  alf(self, arrays
+00019ec0: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+00019ed0: 7420 6973 696e 7374 616e 6365 2861 7272  t isinstance(arr
+00019ee0: 6179 732c 2074 7570 6c65 290a 2020 2020  ays, tuple).    
+00019ef0: 2020 2020 7265 7475 726e 2061 7272 6179      return array
+00019f00: 735b 7365 6c66 2e69 6e64 6578 5d0a 0a20  s[self.index].. 
+00019f10: 2020 2064 6566 205f 6e6f 6465 2873 656c     def _node(sel
+00019f20: 662c 2063 6163 6865 2c20 7375 6267 7261  f, cache, subgra
+00019f30: 7068 2c20 7469 6d65 7329 3a0a 2020 2020  ph, times):.    
+00019f40: 2020 2020 6966 2073 656c 6620 696e 2063      if self in c
+00019f50: 6163 6865 3a0a 2020 2020 2020 2020 2020  ache:.          
+00019f60: 2020 7265 7475 726e 2063 6163 6865 5b73    return cache[s
+00019f70: 656c 665d 0a20 2020 2020 2020 2065 6c69  elf].        eli
+00019f80: 6620 6861 7361 7474 7228 7365 6c66 2e61  f hasattr(self.a
+00019f90: 7272 6179 732c 2027 5f6e 6f64 655f 7475  rrays, '_node_tu
+00019fa0: 706c 6527 293a 0a20 2020 2020 2020 2020  ple'):.         
+00019fb0: 2020 2063 6163 6865 5b73 656c 665d 203d     cache[self] =
+00019fc0: 206e 6f64 6520 3d20 7365 6c66 2e61 7272   node = self.arr
+00019fd0: 6179 732e 5f6e 6f64 655f 7475 706c 6528  ays._node_tuple(
+00019fe0: 6361 6368 652c 2073 7562 6772 6170 682c  cache, subgraph,
+00019ff0: 2074 696d 6573 295b 7365 6c66 2e69 6e64   times)[self.ind
+0001a000: 6578 5d0a 2020 2020 2020 2020 2020 2020  ex].            
+0001a010: 7265 7475 726e 206e 6f64 650a 2020 2020  return node.    
+0001a020: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0001a030: 2020 2020 2020 7265 7475 726e 2073 7570        return sup
+0001a040: 6572 2829 2e5f 6e6f 6465 2863 6163 6865  er()._node(cache
+0001a050: 2c20 7375 6267 7261 7068 2c20 7469 6d65  , subgraph, time
+0001a060: 7329 0a0a 2020 2020 6465 6620 5f69 6e74  s)..    def _int
+0001a070: 626f 756e 6473 5f69 6d70 6c28 7365 6c66  bounds_impl(self
+0001a080: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0001a090: 6e20 7365 6c66 2e5f 6c6f 7765 722c 2073  n self._lower, s
+0001a0a0: 656c 662e 5f75 7070 6572 0a0a 0a63 6c61  elf._upper...cla
+0001a0b0: 7373 205a 6572 6f73 2841 7272 6179 293a  ss Zeros(Array):
+0001a0c0: 0a20 2020 2027 7a65 726f 270a 0a20 2020  .    'zero'..   
+0001a0d0: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
+0001a0e0: 6c66 2c20 7368 6170 652c 2064 7479 7065  lf, shape, dtype
+0001a0f0: 293a 0a20 2020 2020 2020 2073 7570 6572  ):.        super
+0001a100: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
+0001a110: 3d73 6861 7065 2c20 7368 6170 653d 7368  =shape, shape=sh
+0001a120: 6170 652c 2064 7479 7065 3d64 7479 7065  ape, dtype=dtype
+0001a130: 290a 0a20 2020 2040 6361 6368 6564 5f70  )..    @cached_p
+0001a140: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+0001a150: 5f75 6e61 6c69 676e 6564 2873 656c 6629  _unaligned(self)
+0001a160: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+0001a170: 205a 6572 6f73 2828 292c 2073 656c 662e   Zeros((), self.
+0001a180: 6474 7970 6529 2c20 2829 0a0a 2020 2020  dtype), ()..    
+0001a190: 6465 6620 6576 616c 6628 7365 6c66 2c20  def evalf(self, 
+0001a1a0: 2a73 6861 7065 293a 0a20 2020 2020 2020  *shape):.       
+0001a1b0: 2072 6574 7572 6e20 6e75 6d70 792e 7a65   return numpy.ze
+0001a1c0: 726f 7328 7368 6170 652c 2064 7479 7065  ros(shape, dtype
+0001a1d0: 3d73 656c 662e 6474 7970 6529 0a0a 2020  =self.dtype)..  
+0001a1e0: 2020 6465 6620 5f6e 6f64 6528 7365 6c66    def _node(self
+0001a1f0: 2c20 6361 6368 652c 2073 7562 6772 6170  , cache, subgrap
+0001a200: 682c 2074 696d 6573 293a 0a20 2020 2020  h, times):.     
+0001a210: 2020 2069 6620 7365 6c66 2e6e 6469 6d3a     if self.ndim:
+0001a220: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0001a230: 7572 6e20 7375 7065 7228 292e 5f6e 6f64  urn super()._nod
+0001a240: 6528 6361 6368 652c 2073 7562 6772 6170  e(cache, subgrap
+0001a250: 682c 2074 696d 6573 290a 2020 2020 2020  h, times).      
+0001a260: 2020 656c 6966 2073 656c 6620 696e 2063    elif self in c
+0001a270: 6163 6865 3a0a 2020 2020 2020 2020 2020  ache:.          
+0001a280: 2020 7265 7475 726e 2063 6163 6865 5b73    return cache[s
+0001a290: 656c 665d 0a20 2020 2020 2020 2065 6c73  elf].        els
+0001a2a0: 653a 0a20 2020 2020 2020 2020 2020 2063  e:.            c
+0001a2b0: 6163 6865 5b73 656c 665d 203d 206e 6f64  ache[self] = nod
+0001a2c0: 6520 3d20 4475 706c 6963 6174 6564 4c65  e = DuplicatedLe
+0001a2d0: 6166 4e6f 6465 2827 3027 2c20 2874 7970  afNode('0', (typ
+0001a2e0: 6528 7365 6c66 292e 5f5f 6e61 6d65 5f5f  e(self).__name__
+0001a2f0: 2c20 7469 6d65 735b 7365 6c66 5d29 290a  , times[self])).
+0001a300: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0001a310: 726e 206e 6f64 650a 0a20 2020 2064 6566  rn node..    def
+0001a320: 205f 6164 6428 7365 6c66 2c20 6f74 6865   _add(self, othe
+0001a330: 7229 3a0a 2020 2020 2020 2020 7265 7475  r):.        retu
+0001a340: 726e 206f 7468 6572 0a0a 2020 2020 6465  rn other..    de
+0001a350: 6620 5f6d 756c 7469 706c 7928 7365 6c66  f _multiply(self
+0001a360: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+0001a370: 2020 7265 7475 726e 2073 656c 660a 0a20    return self.. 
+0001a380: 2020 2064 6566 205f 6469 6167 6f6e 616c     def _diagonal
+0001a390: 697a 6528 7365 6c66 2c20 6178 6973 293a  ize(self, axis):
+0001a3a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001a3b0: 5a65 726f 7328 7365 6c66 2e73 6861 7065  Zeros(self.shape
+0001a3c0: 2b28 7365 6c66 2e73 6861 7065 5b61 7869  +(self.shape[axi
+0001a3d0: 735d 2c29 2c20 6474 7970 653d 7365 6c66  s],), dtype=self
+0001a3e0: 2e64 7479 7065 290a 0a20 2020 2064 6566  .dtype)..    def
+0001a3f0: 205f 7375 6d28 7365 6c66 2c20 6178 6973   _sum(self, axis
+0001a400: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0001a410: 6e20 5a65 726f 7328 7365 6c66 2e73 6861  n Zeros(self.sha
+0001a420: 7065 5b3a 6178 6973 5d20 2b20 7365 6c66  pe[:axis] + self
+0001a430: 2e73 6861 7065 5b61 7869 732b 313a 5d2c  .shape[axis+1:],
+0001a440: 2064 7479 7065 3d69 6e74 2069 6620 7365   dtype=int if se
+0001a450: 6c66 2e64 7479 7065 203d 3d20 626f 6f6c  lf.dtype == bool
+0001a460: 2065 6c73 6520 7365 6c66 2e64 7479 7065   else self.dtype
+0001a470: 290a 0a20 2020 2064 6566 205f 7472 616e  )..    def _tran
+0001a480: 7370 6f73 6528 7365 6c66 2c20 6178 6573  spose(self, axes
+0001a490: 293a 0a20 2020 2020 2020 2073 6861 7065  ):.        shape
+0001a4a0: 203d 2074 7570 6c65 2873 656c 662e 7368   = tuple(self.sh
+0001a4b0: 6170 655b 6e5d 2066 6f72 206e 2069 6e20  ape[n] for n in 
+0001a4c0: 6178 6573 290a 2020 2020 2020 2020 7265  axes).        re
+0001a4d0: 7475 726e 205a 6572 6f73 2873 6861 7065  turn Zeros(shape
+0001a4e0: 2c20 6474 7970 653d 7365 6c66 2e64 7479  , dtype=self.dty
+0001a4f0: 7065 290a 0a20 2020 2064 6566 205f 696e  pe)..    def _in
+0001a500: 7365 7274 6178 6973 2873 656c 662c 2061  sertaxis(self, a
+0001a510: 7869 732c 206c 656e 6774 6829 3a0a 2020  xis, length):.  
+0001a520: 2020 2020 2020 7265 7475 726e 205a 6572        return Zer
+0001a530: 6f73 2873 656c 662e 7368 6170 655b 3a61  os(self.shape[:a
+0001a540: 7869 735d 2b28 6c65 6e67 7468 2c29 2b73  xis]+(length,)+s
+0001a550: 656c 662e 7368 6170 655b 6178 6973 3a5d  elf.shape[axis:]
+0001a560: 2c20 7365 6c66 2e64 7479 7065 290a 0a20  , self.dtype).. 
+0001a570: 2020 2064 6566 205f 7461 6b65 6469 6167     def _takediag
+0001a580: 2873 656c 662c 2061 7869 7331 2c20 6178  (self, axis1, ax
+0001a590: 6973 3229 3a0a 2020 2020 2020 2020 7265  is2):.        re
+0001a5a0: 7475 726e 205a 6572 6f73 2873 656c 662e  turn Zeros(self.
+0001a5b0: 7368 6170 655b 3a61 7869 7331 5d2b 7365  shape[:axis1]+se
+0001a5c0: 6c66 2e73 6861 7065 5b61 7869 7331 2b31  lf.shape[axis1+1
+0001a5d0: 3a61 7869 7332 5d2b 7365 6c66 2e73 6861  :axis2]+self.sha
+0001a5e0: 7065 5b61 7869 7332 2b31 3a73 656c 662e  pe[axis2+1:self.
+0001a5f0: 6e64 696d 5d2b 2873 656c 662e 7368 6170  ndim]+(self.shap
+0001a600: 655b 6178 6973 315d 2c29 2c20 6474 7970  e[axis1],), dtyp
+0001a610: 653d 7365 6c66 2e64 7479 7065 290a 0a20  e=self.dtype).. 
+0001a620: 2020 2064 6566 205f 7461 6b65 2873 656c     def _take(sel
+0001a630: 662c 2069 6e64 6578 2c20 6178 6973 293a  f, index, axis):
+0001a640: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001a650: 5a65 726f 7328 7365 6c66 2e73 6861 7065  Zeros(self.shape
+0001a660: 5b3a 6178 6973 5d20 2b20 696e 6465 782e  [:axis] + index.
+0001a670: 7368 6170 6520 2b20 7365 6c66 2e73 6861  shape + self.sha
+0001a680: 7065 5b61 7869 732b 313a 5d2c 2064 7479  pe[axis+1:], dty
+0001a690: 7065 3d73 656c 662e 6474 7970 6529 0a0a  pe=self.dtype)..
+0001a6a0: 2020 2020 6465 6620 5f69 6e66 6c61 7465      def _inflate
+0001a6b0: 2873 656c 662c 2064 6f66 6d61 702c 206c  (self, dofmap, l
+0001a6c0: 656e 6774 682c 2061 7869 7329 3a0a 2020  ength, axis):.  
+0001a6d0: 2020 2020 2020 7265 7475 726e 205a 6572        return Zer
+0001a6e0: 6f73 2873 656c 662e 7368 6170 655b 3a61  os(self.shape[:a
+0001a6f0: 7869 735d 202b 2028 6c65 6e67 7468 2c29  xis] + (length,)
+0001a700: 202b 2073 656c 662e 7368 6170 655b 6178   + self.shape[ax
+0001a710: 6973 2b64 6f66 6d61 702e 6e64 696d 3a5d  is+dofmap.ndim:]
+0001a720: 2c20 6474 7970 653d 7365 6c66 2e64 7479  , dtype=self.dty
+0001a730: 7065 290a 0a20 2020 2064 6566 205f 756e  pe)..    def _un
+0001a740: 7261 7665 6c28 7365 6c66 2c20 6178 6973  ravel(self, axis
+0001a750: 2c20 7368 6170 6529 3a0a 2020 2020 2020  , shape):.      
+0001a760: 2020 7368 6170 6520 3d20 7365 6c66 2e73    shape = self.s
+0001a770: 6861 7065 5b3a 6178 6973 5d20 2b20 7368  hape[:axis] + sh
+0001a780: 6170 6520 2b20 7365 6c66 2e73 6861 7065  ape + self.shape
+0001a790: 5b61 7869 732b 313a 5d0a 2020 2020 2020  [axis+1:].      
+0001a7a0: 2020 7265 7475 726e 205a 6572 6f73 2873    return Zeros(s
+0001a7b0: 6861 7065 2c20 6474 7970 653d 7365 6c66  hape, dtype=self
+0001a7c0: 2e64 7479 7065 290a 0a20 2020 2064 6566  .dtype)..    def
+0001a7d0: 205f 7261 7665 6c28 7365 6c66 2c20 6178   _ravel(self, ax
+0001a7e0: 6973 293a 0a20 2020 2020 2020 2072 6574  is):.        ret
+0001a7f0: 7572 6e20 5a65 726f 7328 7365 6c66 2e73  urn Zeros(self.s
+0001a800: 6861 7065 5b3a 6178 6973 5d20 2b20 2873  hape[:axis] + (s
+0001a810: 656c 662e 7368 6170 655b 6178 6973 5d2a  elf.shape[axis]*
+0001a820: 7365 6c66 2e73 6861 7065 5b61 7869 732b  self.shape[axis+
+0001a830: 315d 2c29 202b 2073 656c 662e 7368 6170  1],) + self.shap
+0001a840: 655b 6178 6973 2b32 3a5d 2c20 7365 6c66  e[axis+2:], self
+0001a850: 2e64 7479 7065 290a 0a20 2020 2064 6566  .dtype)..    def
+0001a860: 205f 6465 7465 726d 696e 616e 7428 7365   _determinant(se
+0001a870: 6c66 2c20 6178 6973 312c 2061 7869 7332  lf, axis1, axis2
+0001a880: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+0001a890: 7420 6178 6973 3120 213d 2061 7869 7332  t axis1 != axis2
+0001a8a0: 0a20 2020 2020 2020 206c 656e 6774 6820  .        length 
+0001a8b0: 3d20 7365 6c66 2e73 6861 7065 5b61 7869  = self.shape[axi
+0001a8c0: 7331 5d0a 2020 2020 2020 2020 6173 7365  s1].        asse
+0001a8d0: 7274 206c 656e 6774 6820 3d3d 2073 656c  rt length == sel
+0001a8e0: 662e 7368 6170 655b 6178 6973 325d 0a20  f.shape[axis2]. 
+0001a8f0: 2020 2020 2020 2069 2c20 6a20 3d20 736f         i, j = so
+0001a900: 7274 6564 285b 6178 6973 312c 2061 7869  rted([axis1, axi
+0001a910: 7332 5d29 0a20 2020 2020 2020 2073 6861  s2]).        sha
+0001a920: 7065 203d 2028 2a73 656c 662e 7368 6170  pe = (*self.shap
+0001a930: 655b 3a69 5d2c 202a 7365 6c66 2e73 6861  e[:i], *self.sha
+0001a940: 7065 5b69 2b31 3a6a 5d2c 202a 7365 6c66  pe[i+1:j], *self
+0001a950: 2e73 6861 7065 5b6a 2b31 3a5d 290a 2020  .shape[j+1:]).  
+0001a960: 2020 2020 2020 6474 7970 6520 3d20 636f        dtype = co
+0001a970: 6d70 6c65 7820 6966 2073 656c 662e 6474  mplex if self.dt
+0001a980: 7970 6520 3d3d 2063 6f6d 706c 6578 2065  ype == complex e
+0001a990: 6c73 6520 666c 6f61 740a 2020 2020 2020  lse float.      
+0001a9a0: 2020 6966 2069 737a 6572 6f28 6c65 6e67    if iszero(leng
+0001a9b0: 7468 293a 0a20 2020 2020 2020 2020 2020  th):.           
+0001a9c0: 2072 6574 7572 6e20 6f6e 6573 2873 6861   return ones(sha
+0001a9d0: 7065 2c20 6474 7970 6529 0a20 2020 2020  pe, dtype).     
+0001a9e0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001a9f0: 2020 2020 2072 6574 7572 6e20 5a65 726f       return Zero
+0001aa00: 7328 7368 6170 652c 2064 7479 7065 290a  s(shape, dtype).
+0001aa10: 0a20 2020 2040 6361 6368 6564 5f70 726f  .    @cached_pro
+0001aa20: 7065 7274 790a 2020 2020 6465 6620 5f61  perty.    def _a
+0001aa30: 7373 7061 7273 6528 7365 6c66 293a 0a20  ssparse(self):. 
+0001aa40: 2020 2020 2020 2072 6574 7572 6e20 2829         return ()
+0001aa50: 0a0a 2020 2020 6465 6620 5f69 6e74 626f  ..    def _intbo
+0001aa60: 756e 6473 5f69 6d70 6c28 7365 6c66 293a  unds_impl(self):
+0001aa70: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001aa80: 302c 2030 0a0a 0a63 6c61 7373 2049 6e66  0, 0...class Inf
+0001aa90: 6c61 7465 2841 7272 6179 293a 0a0a 2020  late(Array):..  
+0001aaa0: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+0001aab0: 656c 662c 2066 756e 633a 2041 7272 6179  elf, func: Array
+0001aac0: 2c20 646f 666d 6170 3a20 4172 7261 792c  , dofmap: Array,
+0001aad0: 206c 656e 6774 683a 2041 7272 6179 293a   length: Array):
+0001aae0: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+0001aaf0: 6973 696e 7374 616e 6365 2866 756e 632c  isinstance(func,
+0001ab00: 2041 7272 6179 292c 2066 2766 756e 633d   Array), f'func=
+0001ab10: 7b66 756e 6321 727d 270a 2020 2020 2020  {func!r}'.      
+0001ab20: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+0001ab30: 6e63 6528 646f 666d 6170 2c20 4172 7261  nce(dofmap, Arra
+0001ab40: 7929 2c20 6627 646f 666d 6170 3d7b 646f  y), f'dofmap={do
+0001ab50: 666d 6170 2172 7d27 0a20 2020 2020 2020  fmap!r}'.       
+0001ab60: 2061 7373 6572 7420 5f69 7369 6e64 6578   assert _isindex
+0001ab70: 286c 656e 6774 6829 2c20 6627 6c65 6e67  (length), f'leng
+0001ab80: 7468 3d7b 6c65 6e67 7468 2172 7d27 0a20  th={length!r}'. 
+0001ab90: 2020 2020 2020 2061 7373 6572 7420 6571         assert eq
+0001aba0: 7561 6c73 6861 7065 2866 756e 632e 7368  ualshape(func.sh
+0001abb0: 6170 655b 6675 6e63 2e6e 6469 6d2d 646f  ape[func.ndim-do
+0001abc0: 666d 6170 2e6e 6469 6d3a 5d2c 2064 6f66  fmap.ndim:], dof
+0001abd0: 6d61 702e 7368 6170 6529 2c20 6627 6675  map.shape), f'fu
+0001abe0: 6e63 2e73 6861 7065 3d7b 6675 6e63 2e73  nc.shape={func.s
+0001abf0: 6861 7065 2172 7d2c 2064 6f66 6d61 702e  hape!r}, dofmap.
+0001ac00: 7368 6170 653d 7b64 6f66 6d61 702e 7368  shape={dofmap.sh
+0001ac10: 6170 6521 727d 270a 2020 2020 2020 2020  ape!r}'.        
+0001ac20: 7365 6c66 2e66 756e 6320 3d20 6675 6e63  self.func = func
+0001ac30: 0a20 2020 2020 2020 2073 656c 662e 646f  .        self.do
+0001ac40: 666d 6170 203d 2064 6f66 6d61 700a 2020  fmap = dofmap.  
+0001ac50: 2020 2020 2020 7365 6c66 2e6c 656e 6774        self.lengt
+0001ac60: 6820 3d20 6c65 6e67 7468 0a20 2020 2020  h = length.     
+0001ac70: 2020 2073 656c 662e 7761 726e 203d 206e     self.warn = n
+0001ac80: 6f74 2064 6f66 6d61 702e 6973 636f 6e73  ot dofmap.iscons
+0001ac90: 7461 6e74 0a20 2020 2020 2020 2073 7570  tant.        sup
+0001aca0: 6572 2829 2e5f 5f69 6e69 745f 5f28 6172  er().__init__(ar
+0001acb0: 6773 3d28 6675 6e63 2c20 646f 666d 6170  gs=(func, dofmap
+0001acc0: 2c20 6c65 6e67 7468 292c 2073 6861 7065  , length), shape
+0001acd0: 3d28 2a66 756e 632e 7368 6170 655b 3a66  =(*func.shape[:f
+0001ace0: 756e 632e 6e64 696d 2d64 6f66 6d61 702e  unc.ndim-dofmap.
+0001acf0: 6e64 696d 5d2c 206c 656e 6774 6829 2c20  ndim], length), 
+0001ad00: 6474 7970 653d 6675 6e63 2e64 7479 7065  dtype=func.dtype
+0001ad10: 290a 0a20 2020 2040 6361 6368 6564 5f70  )..    @cached_p
+0001ad20: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+0001ad30: 5f64 6961 676f 6e61 6c73 2873 656c 6629  _diagonals(self)
+0001ad40: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+0001ad50: 2074 7570 6c65 2861 7865 7320 666f 7220   tuple(axes for 
+0001ad60: 6178 6573 2069 6e20 7365 6c66 2e66 756e  axes in self.fun
+0001ad70: 632e 5f64 6961 676f 6e61 6c73 2069 6620  c._diagonals if 
+0001ad80: 616c 6c28 6178 6973 203c 2073 656c 662e  all(axis < self.
+0001ad90: 6e64 696d 2d31 2066 6f72 2061 7869 7320  ndim-1 for axis 
+0001ada0: 696e 2061 7865 7329 290a 0a20 2020 2040  in axes))..    @
+0001adb0: 6361 6368 6564 5f70 726f 7065 7274 790a  cached_property.
+0001adc0: 2020 2020 6465 6620 5f69 6e66 6c61 7469      def _inflati
+0001add0: 6f6e 7328 7365 6c66 293a 0a20 2020 2020  ons(self):.     
+0001ade0: 2020 2069 6e66 6c61 7469 6f6e 7320 3d20     inflations = 
+0001adf0: 5b28 7365 6c66 2e6e 6469 6d2d 312c 2074  [(self.ndim-1, t
+0001ae00: 7970 6573 2e66 726f 7a65 6e64 6963 7428  ypes.frozendict(
+0001ae10: 7b73 656c 662e 646f 666d 6170 3a20 7365  {self.dofmap: se
+0001ae20: 6c66 2e66 756e 637d 2929 5d0a 2020 2020  lf.func}))].    
+0001ae30: 2020 2020 666f 7220 6178 6973 2c20 7061      for axis, pa
+0001ae40: 7274 7320 696e 2073 656c 662e 6675 6e63  rts in self.func
+0001ae50: 2e5f 696e 666c 6174 696f 6e73 3a0a 2020  ._inflations:.  
+0001ae60: 2020 2020 2020 2020 2020 696e 666c 6174            inflat
+0001ae70: 696f 6e73 2e61 7070 656e 6428 2861 7869  ions.append((axi
+0001ae80: 732c 2074 7970 6573 2e66 726f 7a65 6e64  s, types.frozend
+0001ae90: 6963 7428 2864 6f66 6d61 702c 2049 6e66  ict((dofmap, Inf
+0001aea0: 6c61 7465 2866 756e 632c 2073 656c 662e  late(func, self.
+0001aeb0: 646f 666d 6170 2c20 7365 6c66 2e6c 656e  dofmap, self.len
+0001aec0: 6774 6829 2920 666f 7220 646f 666d 6170  gth)) for dofmap
+0001aed0: 2c20 6675 6e63 2069 6e20 7061 7274 732e  , func in parts.
+0001aee0: 6974 656d 7328 2929 2929 0a20 2020 2020  items()))).     
+0001aef0: 2020 2072 6574 7572 6e20 7475 706c 6528     return tuple(
+0001af00: 696e 666c 6174 696f 6e73 290a 0a20 2020  inflations)..   
+0001af10: 2064 6566 205f 7369 6d70 6c69 6669 6564   def _simplified
+0001af20: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0001af30: 666f 7220 6178 6973 2069 6e20 7261 6e67  for axis in rang
+0001af40: 6528 7365 6c66 2e64 6f66 6d61 702e 6e64  e(self.dofmap.nd
+0001af50: 696d 293a 0a20 2020 2020 2020 2020 2020  im):.           
+0001af60: 2069 6620 5f65 7175 616c 735f 7363 616c   if _equals_scal
+0001af70: 6172 5f63 6f6e 7374 616e 7428 7365 6c66  ar_constant(self
+0001af80: 2e64 6f66 6d61 702e 7368 6170 655b 6178  .dofmap.shape[ax
+0001af90: 6973 5d2c 2031 293a 0a20 2020 2020 2020  is], 1):.       
+0001afa0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001afb0: 496e 666c 6174 6528 5f74 616b 6528 7365  Inflate(_take(se
+0001afc0: 6c66 2e66 756e 632c 2063 6f6e 7374 616e  lf.func, constan
+0001afd0: 7428 3029 2c20 7365 6c66 2e66 756e 632e  t(0), self.func.
+0001afe0: 6e64 696d 2d73 656c 662e 646f 666d 6170  ndim-self.dofmap
+0001aff0: 2e6e 6469 6d2b 6178 6973 292c 205f 7461  .ndim+axis), _ta
+0001b000: 6b65 2873 656c 662e 646f 666d 6170 2c20  ke(self.dofmap, 
+0001b010: 636f 6e73 7461 6e74 2830 292c 2061 7869  constant(0), axi
+0001b020: 7329 2c20 7365 6c66 2e6c 656e 6774 6829  s), self.length)
+0001b030: 0a20 2020 2020 2020 2066 6f72 2061 7869  .        for axi
+0001b040: 732c 2070 6172 7473 2069 6e20 7365 6c66  s, parts in self
+0001b050: 2e66 756e 632e 5f69 6e66 6c61 7469 6f6e  .func._inflation
+0001b060: 733a 0a20 2020 2020 2020 2020 2020 2069  s:.            i
+0001b070: 203d 2061 7869 7320 2d20 2873 656c 662e   = axis - (self.
+0001b080: 6e64 696d 2d31 290a 2020 2020 2020 2020  ndim-1).        
+0001b090: 2020 2020 6966 2069 203e 3d20 303a 0a20      if i >= 0:. 
+0001b0a0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0001b0b0: 6574 7572 6e20 7574 696c 2e73 756d 2849  eturn util.sum(I
+0001b0c0: 6e66 6c61 7465 2866 2c20 5f74 616b 6528  nflate(f, _take(
+0001b0d0: 7365 6c66 2e64 6f66 6d61 702c 2069 6e64  self.dofmap, ind
+0001b0e0: 2c20 6929 2c20 7365 6c66 2e6c 656e 6774  , i), self.lengt
+0001b0f0: 6829 2066 6f72 2069 6e64 2c20 6620 696e  h) for ind, f in
+0001b100: 2070 6172 7473 2e69 7465 6d73 2829 290a   parts.items()).
+0001b110: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0001b120: 646f 666d 6170 2e6e 6469 6d20 3d3d 2030  dofmap.ndim == 0
+0001b130: 2061 6e64 205f 6571 7561 6c73 5f73 6361   and _equals_sca
+0001b140: 6c61 725f 636f 6e73 7461 6e74 2873 656c  lar_constant(sel
+0001b150: 662e 646f 666d 6170 2c20 3029 2061 6e64  f.dofmap, 0) and
+0001b160: 205f 6571 7561 6c73 5f73 6361 6c61 725f   _equals_scalar_
+0001b170: 636f 6e73 7461 6e74 2873 656c 662e 6c65  constant(self.le
+0001b180: 6e67 7468 2c20 3129 3a0a 2020 2020 2020  ngth, 1):.      
+0001b190: 2020 2020 2020 7265 7475 726e 2049 6e73        return Ins
+0001b1a0: 6572 7441 7869 7328 7365 6c66 2e66 756e  ertAxis(self.fun
+0001b1b0: 632c 2063 6f6e 7374 616e 7428 3129 290a  c, constant(1)).
+0001b1c0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0001b1d0: 656c 662e 6675 6e63 2e5f 696e 666c 6174  elf.func._inflat
+0001b1e0: 6528 7365 6c66 2e64 6f66 6d61 702c 2073  e(self.dofmap, s
+0001b1f0: 656c 662e 6c65 6e67 7468 2c20 7365 6c66  elf.length, self
+0001b200: 2e6e 6469 6d2d 3129 205c 0a20 2020 2020  .ndim-1) \.     
+0001b210: 2020 2020 2020 206f 7220 7365 6c66 2e64         or self.d
+0001b220: 6f66 6d61 702e 5f72 696e 666c 6174 6528  ofmap._rinflate(
+0001b230: 7365 6c66 2e66 756e 632c 2073 656c 662e  self.func, self.
+0001b240: 6c65 6e67 7468 2c20 7365 6c66 2e6e 6469  length, self.ndi
+0001b250: 6d2d 3129 0a0a 2020 2020 6465 6620 6576  m-1)..    def ev
+0001b260: 616c 6628 7365 6c66 2c20 6172 7261 792c  alf(self, array,
+0001b270: 2069 6e64 6963 6573 2c20 6c65 6e67 7468   indices, length
+0001b280: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+0001b290: 7420 696e 6469 6365 732e 6e64 696d 203d  t indices.ndim =
+0001b2a0: 3d20 7365 6c66 2e64 6f66 6d61 702e 6e64  = self.dofmap.nd
+0001b2b0: 696d 0a20 2020 2020 2020 2061 7373 6572  im.        asser
+0001b2c0: 7420 6c65 6e67 7468 2e6e 6469 6d20 3d3d  t length.ndim ==
+0001b2d0: 2030 0a20 2020 2020 2020 2069 6620 7365   0.        if se
+0001b2e0: 6c66 2e77 6172 6e20 616e 6420 696e 7428  lf.warn and int(
+0001b2f0: 6c65 6e67 7468 2920 3e20 696e 6469 6365  length) > indice
+0001b300: 732e 7369 7a65 3a0a 2020 2020 2020 2020  s.size:.        
+0001b310: 2020 2020 7761 726e 696e 6773 2e77 6172      warnings.war
+0001b320: 6e28 2775 7369 6e67 2065 7870 6c69 6369  n('using explici
+0001b330: 7420 696e 666c 6174 696f 6e3b 2074 6869  t inflation; thi
+0001b340: 7320 6973 2075 7375 616c 6c79 2061 2062  s is usually a b
+0001b350: 7567 2e27 2c20 4578 7065 6e73 6976 6545  ug.', ExpensiveE
+0001b360: 7661 6c75 6174 696f 6e57 6172 6e69 6e67  valuationWarning
+0001b370: 290a 2020 2020 2020 2020 696e 666c 6174  ).        inflat
+0001b380: 6564 203d 206e 756d 7079 2e7a 6572 6f73  ed = numpy.zeros
+0001b390: 2861 7272 6179 2e73 6861 7065 5b3a 6172  (array.shape[:ar
+0001b3a0: 7261 792e 6e64 696d 2d69 6e64 6963 6573  ray.ndim-indices
+0001b3b0: 2e6e 6469 6d5d 202b 2028 6c65 6e67 7468  .ndim] + (length
+0001b3c0: 2c29 2c20 6474 7970 653d 7365 6c66 2e64  ,), dtype=self.d
+0001b3d0: 7479 7065 290a 2020 2020 2020 2020 6e75  type).        nu
+0001b3e0: 6d70 792e 6164 642e 6174 2869 6e66 6c61  mpy.add.at(infla
+0001b3f0: 7465 642c 2028 736c 6963 6528 4e6f 6e65  ted, (slice(None
+0001b400: 292c 292a 2873 656c 662e 6e64 696d 2d31  ),)*(self.ndim-1
+0001b410: 292b 2869 6e64 6963 6573 2c29 2c20 6172  )+(indices,), ar
+0001b420: 7261 7929 0a20 2020 2020 2020 2072 6574  ray).        ret
+0001b430: 7572 6e20 696e 666c 6174 6564 0a0a 2020  urn inflated..  
+0001b440: 2020 6465 6620 5f69 6e66 6c61 7465 2873    def _inflate(s
+0001b450: 656c 662c 2064 6f66 6d61 702c 206c 656e  elf, dofmap, len
+0001b460: 6774 682c 2061 7869 7329 3a0a 2020 2020  gth, axis):.    
+0001b470: 2020 2020 6966 2064 6f66 6d61 702e 6e64      if dofmap.nd
+0001b480: 696d 203d 3d20 3020 616e 6420 646f 666d  im == 0 and dofm
+0001b490: 6170 203d 3d20 7365 6c66 2e64 6f66 6d61  ap == self.dofma
+0001b4a0: 7020 616e 6420 6c65 6e67 7468 203d 3d20  p and length == 
+0001b4b0: 7365 6c66 2e6c 656e 6774 683a 0a20 2020  self.length:.   
+0001b4c0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001b4d0: 6469 6167 6f6e 616c 697a 6528 7365 6c66  diagonalize(self
+0001b4e0: 2c20 2d31 2c20 6178 6973 290a 0a20 2020  , -1, axis)..   
+0001b4f0: 2064 6566 205f 6465 7269 7661 7469 7665   def _derivative
+0001b500: 2873 656c 662c 2076 6172 2c20 7365 656e  (self, var, seen
+0001b510: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0001b520: 6e20 5f69 6e66 6c61 7465 2864 6572 6976  n _inflate(deriv
+0001b530: 6174 6976 6528 7365 6c66 2e66 756e 632c  ative(self.func,
+0001b540: 2076 6172 2c20 7365 656e 292c 2073 656c   var, seen), sel
+0001b550: 662e 646f 666d 6170 2c20 7365 6c66 2e6c  f.dofmap, self.l
+0001b560: 656e 6774 682c 2073 656c 662e 6e64 696d  ength, self.ndim
+0001b570: 2d31 290a 0a20 2020 2064 6566 205f 6d75  -1)..    def _mu
+0001b580: 6c74 6970 6c79 2873 656c 662c 206f 7468  ltiply(self, oth
+0001b590: 6572 293a 0a20 2020 2020 2020 2072 6574  er):.        ret
+0001b5a0: 7572 6e20 496e 666c 6174 6528 6d75 6c74  urn Inflate(mult
+0001b5b0: 6970 6c79 2873 656c 662e 6675 6e63 2c20  iply(self.func, 
+0001b5c0: 5461 6b65 286f 7468 6572 2c20 7365 6c66  Take(other, self
+0001b5d0: 2e64 6f66 6d61 7029 292c 2073 656c 662e  .dofmap)), self.
+0001b5e0: 646f 666d 6170 2c20 7365 6c66 2e6c 656e  dofmap, self.len
+0001b5f0: 6774 6829 0a0a 2020 2020 6465 6620 5f61  gth)..    def _a
+0001b600: 6464 2873 656c 662c 206f 7468 6572 293a  dd(self, other):
+0001b610: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
+0001b620: 7374 616e 6365 286f 7468 6572 2c20 496e  stance(other, In
+0001b630: 666c 6174 6529 2061 6e64 2073 656c 662e  flate) and self.
+0001b640: 646f 666d 6170 203d 3d20 6f74 6865 722e  dofmap == other.
+0001b650: 646f 666d 6170 3a0a 2020 2020 2020 2020  dofmap:.        
+0001b660: 2020 2020 7265 7475 726e 2049 6e66 6c61      return Infla
+0001b670: 7465 2861 6464 2873 656c 662e 6675 6e63  te(add(self.func
+0001b680: 2c20 6f74 6865 722e 6675 6e63 292c 2073  , other.func), s
+0001b690: 656c 662e 646f 666d 6170 2c20 7365 6c66  elf.dofmap, self
+0001b6a0: 2e6c 656e 6774 6829 0a0a 2020 2020 6465  .length)..    de
+0001b6b0: 6620 5f74 616b 6564 6961 6728 7365 6c66  f _takediag(self
+0001b6c0: 2c20 6178 6973 312c 2061 7869 7332 293a  , axis1, axis2):
+0001b6d0: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+0001b6e0: 6178 6973 3120 3c20 6178 6973 320a 2020  axis1 < axis2.  
+0001b6f0: 2020 2020 2020 6966 2061 7869 7332 203d        if axis2 =
+0001b700: 3d20 7365 6c66 2e6e 6469 6d2d 313a 0a20  = self.ndim-1:. 
+0001b710: 2020 2020 2020 2020 2020 2066 756e 6320             func 
+0001b720: 3d20 5f74 616b 6528 7365 6c66 2e66 756e  = _take(self.fun
+0001b730: 632c 2073 656c 662e 646f 666d 6170 2c20  c, self.dofmap, 
+0001b740: 6178 6973 3129 0a20 2020 2020 2020 2020  axis1).         
+0001b750: 2020 2066 6f72 2069 2069 6e20 7261 6e67     for i in rang
+0001b760: 6528 7365 6c66 2e64 6f66 6d61 702e 6e64  e(self.dofmap.nd
+0001b770: 696d 293a 0a20 2020 2020 2020 2020 2020  im):.           
+0001b780: 2020 2020 2066 756e 6320 3d20 5f74 616b       func = _tak
+0001b790: 6564 6961 6728 6675 6e63 2c20 6178 6973  ediag(func, axis
+0001b7a0: 312c 2061 7869 7332 2b73 656c 662e 646f  1, axis2+self.do
+0001b7b0: 666d 6170 2e6e 6469 6d2d 312d 6929 0a20  fmap.ndim-1-i). 
+0001b7c0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001b7d0: 6e20 496e 666c 6174 6528 6675 6e63 2c20  n Inflate(func, 
+0001b7e0: 7365 6c66 2e64 6f66 6d61 702c 2073 656c  self.dofmap, sel
+0001b7f0: 662e 6c65 6e67 7468 290a 2020 2020 2020  f.length).      
+0001b800: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0001b810: 2020 2020 7265 7475 726e 205f 696e 666c      return _infl
+0001b820: 6174 6528 5f74 616b 6564 6961 6728 7365  ate(_takediag(se
+0001b830: 6c66 2e66 756e 632c 2061 7869 7331 2c20  lf.func, axis1, 
+0001b840: 6178 6973 3229 2c20 7365 6c66 2e64 6f66  axis2), self.dof
+0001b850: 6d61 702c 2073 656c 662e 6c65 6e67 7468  map, self.length
+0001b860: 2c20 7365 6c66 2e6e 6469 6d2d 3329 0a0a  , self.ndim-3)..
+0001b870: 2020 2020 6465 6620 5f74 616b 6528 7365      def _take(se
+0001b880: 6c66 2c20 696e 6465 782c 2061 7869 7329  lf, index, axis)
+0001b890: 3a0a 2020 2020 2020 2020 6966 2061 7869  :.        if axi
+0001b8a0: 7320 213d 2073 656c 662e 6e64 696d 2d31  s != self.ndim-1
+0001b8b0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0001b8c0: 7475 726e 2049 6e66 6c61 7465 285f 7461  turn Inflate(_ta
+0001b8d0: 6b65 2873 656c 662e 6675 6e63 2c20 696e  ke(self.func, in
+0001b8e0: 6465 782c 2061 7869 7329 2c20 7365 6c66  dex, axis), self
+0001b8f0: 2e64 6f66 6d61 702c 2073 656c 662e 6c65  .dofmap, self.le
+0001b900: 6e67 7468 290a 2020 2020 2020 2020 6e65  ngth).        ne
+0001b910: 7769 6e64 6578 2c20 6e65 7764 6f66 6d61  windex, newdofma
+0001b920: 7020 3d20 5377 6170 496e 666c 6174 6554  p = SwapInflateT
+0001b930: 616b 6528 7365 6c66 2e64 6f66 6d61 702c  ake(self.dofmap,
+0001b940: 2069 6e64 6578 290a 2020 2020 2020 2020   index).        
+0001b950: 6966 2073 656c 662e 646f 666d 6170 2e6e  if self.dofmap.n
+0001b960: 6469 6d3a 0a20 2020 2020 2020 2020 2020  dim:.           
+0001b970: 2066 756e 6320 3d20 7365 6c66 2e66 756e   func = self.fun
+0001b980: 630a 2020 2020 2020 2020 2020 2020 666f  c.            fo
+0001b990: 7220 6920 696e 2072 616e 6765 2873 656c  r i in range(sel
+0001b9a0: 662e 646f 666d 6170 2e6e 6469 6d2d 3129  f.dofmap.ndim-1)
+0001b9b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001b9c0: 2020 6675 6e63 203d 2052 6176 656c 2866    func = Ravel(f
+0001b9d0: 756e 6329 0a20 2020 2020 2020 2020 2020  unc).           
+0001b9e0: 2069 6e74 6572 7365 6374 696f 6e20 3d20   intersection = 
+0001b9f0: 5461 6b65 2866 756e 632c 206e 6577 696e  Take(func, newin
+0001ba00: 6465 7829 0a20 2020 2020 2020 2065 6c73  dex).        els
+0001ba10: 653a 2020 2320 6b72 6f6e 6563 6b65 723b  e:  # kronecker;
+0001ba20: 206e 6577 696e 6465 7820 6973 2061 6c6c   newindex is all
+0001ba30: 207a 6572 6f73 2028 6275 7420 6f66 2076   zeros (but of v
+0001ba40: 6172 7969 6e67 206c 656e 6774 6829 0a20  arying length). 
+0001ba50: 2020 2020 2020 2020 2020 2069 6e74 6572             inter
+0001ba60: 7365 6374 696f 6e20 3d20 496e 7365 7274  section = Insert
+0001ba70: 4178 6973 2873 656c 662e 6675 6e63 2c20  Axis(self.func, 
+0001ba80: 6e65 7769 6e64 6578 2e73 6861 7065 5b30  newindex.shape[0
+0001ba90: 5d29 0a20 2020 2020 2020 2069 6620 696e  ]).        if in
+0001baa0: 6465 782e 6e64 696d 3a0a 2020 2020 2020  dex.ndim:.      
+0001bab0: 2020 2020 2020 7377 6170 7065 6420 3d20        swapped = 
+0001bac0: 496e 666c 6174 6528 696e 7465 7273 6563  Inflate(intersec
+0001bad0: 7469 6f6e 2c20 6e65 7764 6f66 6d61 702c  tion, newdofmap,
+0001bae0: 2075 7469 6c2e 7072 6f64 7563 7428 696e   util.product(in
+0001baf0: 6465 782e 7368 6170 6529 290a 2020 2020  dex.shape)).    
+0001bb00: 2020 2020 2020 2020 666f 7220 6920 696e          for i in
+0001bb10: 2072 616e 6765 2869 6e64 6578 2e6e 6469   range(index.ndi
+0001bb20: 6d2d 3129 3a0a 2020 2020 2020 2020 2020  m-1):.          
+0001bb30: 2020 2020 2020 7377 6170 7065 6420 3d20        swapped = 
+0001bb40: 556e 7261 7665 6c28 7377 6170 7065 642c  Unravel(swapped,
+0001bb50: 2069 6e64 6578 2e73 6861 7065 5b69 5d2c   index.shape[i],
+0001bb60: 2075 7469 6c2e 7072 6f64 7563 7428 696e   util.product(in
+0001bb70: 6465 782e 7368 6170 655b 692b 313a 5d29  dex.shape[i+1:])
+0001bb80: 290a 2020 2020 2020 2020 656c 7365 3a20  ).        else: 
+0001bb90: 2023 2067 6574 3b20 6e65 7764 6f66 6d61   # get; newdofma
+0001bba0: 7020 6973 2061 6c6c 207a 6572 6f73 2028  p is all zeros (
+0001bbb0: 6275 7420 6f66 2076 6172 7969 6e67 206c  but of varying l
+0001bbc0: 656e 6774 6829 0a20 2020 2020 2020 2020  ength).         
+0001bbd0: 2020 2073 7761 7070 6564 203d 2053 756d     swapped = Sum
+0001bbe0: 2869 6e74 6572 7365 6374 696f 6e29 0a20  (intersection). 
+0001bbf0: 2020 2020 2020 2072 6574 7572 6e20 7377         return sw
+0001bc00: 6170 7065 640a 0a20 2020 2064 6566 205f  apped..    def _
+0001bc10: 6469 6167 6f6e 616c 697a 6528 7365 6c66  diagonalize(self
+0001bc20: 2c20 6178 6973 293a 0a20 2020 2020 2020  , axis):.       
+0001bc30: 2069 6620 6178 6973 2021 3d20 7365 6c66   if axis != self
+0001bc40: 2e6e 6469 6d2d 313a 0a20 2020 2020 2020  .ndim-1:.       
+0001bc50: 2020 2020 2072 6574 7572 6e20 5f69 6e66       return _inf
+0001bc60: 6c61 7465 2864 6961 676f 6e61 6c69 7a65  late(diagonalize
+0001bc70: 2873 656c 662e 6675 6e63 2c20 6178 6973  (self.func, axis
+0001bc80: 292c 2073 656c 662e 646f 666d 6170 2c20  ), self.dofmap, 
+0001bc90: 7365 6c66 2e6c 656e 6774 682c 2073 656c  self.length, sel
+0001bca0: 662e 6e64 696d 2d31 290a 0a20 2020 2064  f.ndim-1)..    d
+0001bcb0: 6566 205f 7375 6d28 7365 6c66 2c20 6178  ef _sum(self, ax
+0001bcc0: 6973 293a 0a20 2020 2020 2020 2069 6620  is):.        if 
+0001bcd0: 6178 6973 203d 3d20 7365 6c66 2e6e 6469  axis == self.ndi
+0001bce0: 6d2d 313a 0a20 2020 2020 2020 2020 2020  m-1:.           
+0001bcf0: 2066 756e 6320 3d20 7365 6c66 2e66 756e   func = self.fun
+0001bd00: 630a 2020 2020 2020 2020 2020 2020 666f  c.            fo
+0001bd10: 7220 6920 696e 2072 616e 6765 2873 656c  r i in range(sel
+0001bd20: 662e 646f 666d 6170 2e6e 6469 6d29 3a0a  f.dofmap.ndim):.
+0001bd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bd40: 6675 6e63 203d 2053 756d 2866 756e 6329  func = Sum(func)
+0001bd50: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0001bd60: 7572 6e20 6675 6e63 0a20 2020 2020 2020  urn func.       
+0001bd70: 2072 6574 7572 6e20 496e 666c 6174 6528   return Inflate(
+0001bd80: 7375 6d28 7365 6c66 2e66 756e 632c 2061  sum(self.func, a
+0001bd90: 7869 7329 2c20 7365 6c66 2e64 6f66 6d61  xis), self.dofma
+0001bda0: 702c 2073 656c 662e 6c65 6e67 7468 290a  p, self.length).
+0001bdb0: 0a20 2020 2064 6566 205f 756e 7261 7665  .    def _unrave
+0001bdc0: 6c28 7365 6c66 2c20 6178 6973 2c20 7368  l(self, axis, sh
+0001bdd0: 6170 6529 3a0a 2020 2020 2020 2020 6966  ape):.        if
+0001bde0: 2061 7869 7320 213d 2073 656c 662e 6e64   axis != self.nd
+0001bdf0: 696d 2d31 3a0a 2020 2020 2020 2020 2020  im-1:.          
+0001be00: 2020 7265 7475 726e 2049 6e66 6c61 7465    return Inflate
+0001be10: 2875 6e72 6176 656c 2873 656c 662e 6675  (unravel(self.fu
+0001be20: 6e63 2c20 6178 6973 2c20 7368 6170 6529  nc, axis, shape)
+0001be30: 2c20 7365 6c66 2e64 6f66 6d61 702c 2073  , self.dofmap, s
+0001be40: 656c 662e 6c65 6e67 7468 290a 0a20 2020  elf.length)..   
+0001be50: 2064 6566 205f 7369 676e 2873 656c 6629   def _sign(self)
+0001be60: 3a0a 2020 2020 2020 2020 6966 2073 656c  :.        if sel
+0001be70: 662e 646f 666d 6170 2e69 7363 6f6e 7374  f.dofmap.isconst
+0001be80: 616e 7420 616e 6420 5f69 7375 6e69 7175  ant and _isuniqu
+0001be90: 6528 7365 6c66 2e64 6f66 6d61 702e 6576  e(self.dofmap.ev
+0001bea0: 616c 2829 293a 0a20 2020 2020 2020 2020  al()):.         
+0001beb0: 2020 2072 6574 7572 6e20 496e 666c 6174     return Inflat
+0001bec0: 6528 5369 676e 2873 656c 662e 6675 6e63  e(Sign(self.func
+0001bed0: 292c 2073 656c 662e 646f 666d 6170 2c20  ), self.dofmap, 
+0001bee0: 7365 6c66 2e6c 656e 6774 6829 0a0a 2020  self.length)..  
+0001bef0: 2020 4063 6163 6865 645f 7072 6f70 6572    @cached_proper
+0001bf00: 7479 0a20 2020 2064 6566 205f 6173 7370  ty.    def _assp
+0001bf10: 6172 7365 2873 656c 6629 3a0a 2020 2020  arse(self):.    
+0001bf20: 2020 2020 6368 756e 6b73 203d 205b 5d0a      chunks = [].
+0001bf30: 2020 2020 2020 2020 666c 6174 5f64 6f66          flat_dof
+0001bf40: 6d61 7020 3d20 5f66 6c61 7428 7365 6c66  map = _flat(self
+0001bf50: 2e64 6f66 6d61 7029 0a20 2020 2020 2020  .dofmap).       
+0001bf60: 206b 6565 705f 6469 6d20 3d20 7365 6c66   keep_dim = self
+0001bf70: 2e66 756e 632e 6e64 696d 202d 2073 656c  .func.ndim - sel
+0001bf80: 662e 646f 666d 6170 2e6e 6469 6d0a 2020  f.dofmap.ndim.  
+0001bf90: 2020 2020 2020 7374 7269 6465 7320 3d20        strides = 
+0001bfa0: 2831 2c20 2a69 7465 7274 6f6f 6c73 2e61  (1, *itertools.a
+0001bfb0: 6363 756d 756c 6174 6528 7365 6c66 2e64  ccumulate(self.d
+0001bfc0: 6f66 6d61 702e 7368 6170 655b 3a30 3a2d  ofmap.shape[:0:-
+0001bfd0: 315d 2c20 6f70 6572 6174 6f72 2e6d 756c  1], operator.mul
+0001bfe0: 2929 5b3a 3a2d 315d 0a20 2020 2020 2020  ))[::-1].       
+0001bff0: 2066 6f72 202a 696e 6469 6365 732c 2076   for *indices, v
+0001c000: 616c 7565 7320 696e 2073 656c 662e 6675  alues in self.fu
+0001c010: 6e63 2e5f 6173 7370 6172 7365 3a0a 2020  nc._assparse:.  
+0001c020: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+0001c030: 662e 646f 666d 6170 2e6e 6469 6d3a 0a20  f.dofmap.ndim:. 
+0001c040: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0001c050: 6e66 6c61 7465 5f69 6e64 6963 6573 203d  nflate_indices =
+0001c060: 2054 616b 6528 666c 6174 5f64 6f66 6d61   Take(flat_dofma
+0001c070: 702c 2066 756e 6374 6f6f 6c73 2e72 6564  p, functools.red
+0001c080: 7563 6528 6f70 6572 6174 6f72 2e61 6464  uce(operator.add
+0001c090: 2c20 6d61 7028 6f70 6572 6174 6f72 2e6d  , map(operator.m
+0001c0a0: 756c 2c20 696e 6469 6365 735b 6b65 6570  ul, indices[keep
+0001c0b0: 5f64 696d 3a5d 2c20 7374 7269 6465 7329  _dim:], strides)
+0001c0c0: 2929 0a20 2020 2020 2020 2020 2020 2065  )).            e
+0001c0d0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0001c0e0: 2020 2020 2069 6e66 6c61 7465 5f69 6e64       inflate_ind
+0001c0f0: 6963 6573 203d 2061 7070 656e 6461 7865  ices = appendaxe
+0001c100: 7328 7365 6c66 2e64 6f66 6d61 702c 2076  s(self.dofmap, v
+0001c110: 616c 7565 732e 7368 6170 6529 0a20 2020  alues.shape).   
+0001c120: 2020 2020 2020 2020 2063 6875 6e6b 732e           chunks.
+0001c130: 6170 7065 6e64 2828 2a69 6e64 6963 6573  append((*indices
+0001c140: 5b3a 6b65 6570 5f64 696d 5d2c 2069 6e66  [:keep_dim], inf
+0001c150: 6c61 7465 5f69 6e64 6963 6573 2c20 7661  late_indices, va
+0001c160: 6c75 6573 2929 0a20 2020 2020 2020 2072  lues)).        r
+0001c170: 6574 7572 6e20 7475 706c 6528 6368 756e  eturn tuple(chun
+0001c180: 6b73 290a 0a20 2020 2064 6566 205f 696e  ks)..    def _in
+0001c190: 7462 6f75 6e64 735f 696d 706c 2873 656c  tbounds_impl(sel
+0001c1a0: 6629 3a0a 2020 2020 2020 2020 6c6f 7765  f):.        lowe
+0001c1b0: 722c 2075 7070 6572 203d 2073 656c 662e  r, upper = self.
+0001c1c0: 6675 6e63 2e5f 696e 7462 6f75 6e64 730a  func._intbounds.
+0001c1d0: 2020 2020 2020 2020 7265 7475 726e 206d          return m
+0001c1e0: 696e 286c 6f77 6572 2c20 3029 2c20 6d61  in(lower, 0), ma
+0001c1f0: 7828 7570 7065 722c 2030 290a 0a0a 636c  x(upper, 0)...cl
+0001c200: 6173 7320 5377 6170 496e 666c 6174 6554  ass SwapInflateT
+0001c210: 616b 6528 4576 616c 7561 626c 6529 3a0a  ake(Evaluable):.
+0001c220: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+0001c230: 5f28 7365 6c66 2c20 696e 666c 6174 6569  _(self, inflatei
+0001c240: 6478 2c20 7461 6b65 6964 7829 3a0a 2020  dx, takeidx):.  
+0001c250: 2020 2020 2020 7365 6c66 2e69 6e66 6c61        self.infla
+0001c260: 7465 6964 7820 3d20 696e 666c 6174 6569  teidx = inflatei
+0001c270: 6478 0a20 2020 2020 2020 2073 656c 662e  dx.        self.
+0001c280: 7461 6b65 6964 7820 3d20 7461 6b65 6964  takeidx = takeid
+0001c290: 780a 2020 2020 2020 2020 7375 7065 7228  x.        super(
+0001c2a0: 292e 5f5f 696e 6974 5f5f 2861 7267 733d  ).__init__(args=
+0001c2b0: 2869 6e66 6c61 7465 6964 782c 2074 616b  (inflateidx, tak
+0001c2c0: 6569 6478 2929 0a0a 2020 2020 6465 6620  eidx))..    def 
+0001c2d0: 5f73 696d 706c 6966 6965 6428 7365 6c66  _simplified(self
+0001c2e0: 293a 0a20 2020 2020 2020 2069 6620 7365  ):.        if se
+0001c2f0: 6c66 2e69 7363 6f6e 7374 616e 743a 0a20  lf.isconstant:. 
+0001c300: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001c310: 6e20 5475 706c 6528 7475 706c 6528 6d61  n Tuple(tuple(ma
+0001c320: 7028 636f 6e73 7461 6e74 2c20 7365 6c66  p(constant, self
+0001c330: 2e65 7661 6c28 2929 2929 0a0a 2020 2020  .eval())))..    
+0001c340: 6465 6620 5f5f 6974 6572 5f5f 2873 656c  def __iter__(sel
+0001c350: 6629 3a0a 2020 2020 2020 2020 7368 6170  f):.        shap
+0001c360: 6520 3d20 4172 7261 7946 726f 6d54 7570  e = ArrayFromTup
+0001c370: 6c65 2873 656c 662c 2069 6e64 6578 3d32  le(self, index=2
+0001c380: 2c20 7368 6170 653d 2829 2c20 6474 7970  , shape=(), dtyp
+0001c390: 653d 696e 742c 205f 6c6f 7765 723d 3029  e=int, _lower=0)
+0001c3a0: 2c0a 2020 2020 2020 2020 7265 7475 726e  ,.        return
+0001c3b0: 2028 4172 7261 7946 726f 6d54 7570 6c65   (ArrayFromTuple
+0001c3c0: 2873 656c 662c 2069 6e64 6578 3d69 6e64  (self, index=ind
+0001c3d0: 6578 2c20 7368 6170 653d 7368 6170 652c  ex, shape=shape,
+0001c3e0: 2064 7479 7065 3d69 6e74 2c20 5f6c 6f77   dtype=int, _low
+0001c3f0: 6572 3d30 2920 666f 7220 696e 6465 7820  er=0) for index 
+0001c400: 696e 2072 616e 6765 2832 2929 0a0a 2020  in range(2))..  
+0001c410: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
+0001c420: 2020 2020 6465 6620 6576 616c 6628 696e      def evalf(in
+0001c430: 666c 6174 6569 6478 2c20 7461 6b65 6964  flateidx, takeid
+0001c440: 7829 3a0a 2020 2020 2020 2020 756e 6971  x):.        uniq
+0001c450: 7565 696e 666c 6174 6520 3d20 5f69 7375  ueinflate = _isu
+0001c460: 6e69 7175 6528 696e 666c 6174 6569 6478  nique(inflateidx
+0001c470: 290a 2020 2020 2020 2020 756e 6971 7565  ).        unique
+0001c480: 7461 6b65 203d 205f 6973 756e 6971 7565  take = _isunique
+0001c490: 2874 616b 6569 6478 290a 2020 2020 2020  (takeidx).      
+0001c4a0: 2020 756e 6971 7565 203d 2075 6e69 7175    unique = uniqu
+0001c4b0: 6569 6e66 6c61 7465 2061 6e64 2075 6e69  einflate and uni
+0001c4c0: 7175 6574 616b 650a 2020 2020 2020 2020  quetake.        
+0001c4d0: 2320 4966 2062 6f74 6820 696e 6469 6365  # If both indice
+0001c4e0: 7320 6172 6520 756e 6971 7565 2028 692e  s are unique (i.
+0001c4f0: 652e 2074 6865 7920 646f 206e 6f74 2063  e. they do not c
+0001c500: 6f6e 7461 696e 2064 7570 6c69 6361 7465  ontain duplicate
+0001c510: 7329 2074 6865 6e20 7468 650a 2020 2020  s) then the.    
+0001c520: 2020 2020 2320 7461 6b65 2061 6e64 2069      # take and i
+0001c530: 6e66 6c61 7465 206f 7065 7261 7469 6f6e  nflate operation
+0001c540: 7320 6361 6e20 7369 6d70 6c79 2062 6520  s can simply be 
+0001c550: 7265 7374 7269 6374 6564 2074 6f20 7468  restricted to th
+0001c560: 6520 696e 7465 7273 6563 7469 6f6e 2c0a  e intersection,.
+0001c570: 2020 2020 2020 2020 2320 7769 7468 2074          # with t
+0001c580: 6865 2074 6865 206c 6f63 6174 696f 6e20  he the location 
+0001c590: 6f66 2074 6865 2069 6e74 6572 7365 6374  of the intersect
+0001c5a0: 696f 6e20 696e 2074 6865 206f 7269 6769  ion in the origi
+0001c5b0: 6e61 6c20 696e 6465 7820 7665 6374 6f72  nal index vector
+0001c5c0: 730a 2020 2020 2020 2020 2320 6265 696e  s.        # bein
+0001c5d0: 6720 7468 6520 6e65 7720 696e 6469 6365  g the new indice
+0001c5e0: 7320 666f 7220 7468 6520 7377 6170 7065  s for the swappe
+0001c5f0: 6420 6f70 6572 6174 696f 6e73 2e0a 2020  d operations..  
+0001c600: 2020 2020 2020 696e 7465 7273 6563 7469        intersecti
+0001c610: 6f6e 2c20 7375 6269 6e66 6c61 7465 2c20  on, subinflate, 
+0001c620: 7375 6274 616b 6520 3d20 6e75 6d70 792e  subtake = numpy.
+0001c630: 696e 7465 7273 6563 7431 6428 696e 666c  intersect1d(infl
+0001c640: 6174 6569 6478 2c20 7461 6b65 6964 782c  ateidx, takeidx,
+0001c650: 2072 6574 7572 6e5f 696e 6469 6365 733d   return_indices=
+0001c660: 5472 7565 2c20 6173 7375 6d65 5f75 6e69  True, assume_uni
+0001c670: 7175 653d 756e 6971 7565 290a 2020 2020  que=unique).    
+0001c680: 2020 2020 6966 2075 6e69 7175 653a 0a20      if unique:. 
+0001c690: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001c6a0: 6e20 7375 6269 6e66 6c61 7465 2c20 7375  n subinflate, su
+0001c6b0: 6274 616b 652c 206e 756d 7079 2e61 7272  btake, numpy.arr
+0001c6c0: 6179 286c 656e 2869 6e74 6572 7365 6374  ay(len(intersect
+0001c6d0: 696f 6e29 290a 2020 2020 2020 2020 2320  ion)).        # 
+0001c6e0: 4f74 6865 7277 6973 652c 2077 6869 6c65  Otherwise, while
+0001c6f0: 2073 7469 6c6c 206c 696d 6974 696e 6720   still limiting 
+0001c700: 7468 6520 6f70 6572 6174 696f 6e73 2074  the operations t
+0001c710: 6f20 7468 6520 696e 7465 7273 6563 7469  o the intersecti
+0001c720: 6f6e 2c20 7765 0a20 2020 2020 2020 2023  on, we.        #
+0001c730: 206e 6565 6420 746f 2061 6464 2074 6865   need to add the
+0001c740: 2061 7070 726f 7072 6961 7465 2064 7570   appropriate dup
+0001c750: 6c69 6361 7469 6f6e 7320 6f6e 2065 6974  lications on eit
+0001c760: 6865 7220 7369 6465 2e20 5468 6520 6561  her side. The ea
+0001c770: 7369 6573 7420 7761 790a 2020 2020 2020  siest way.      
+0001c780: 2020 2320 746f 2064 6f20 7468 6973 2069    # to do this i
+0001c790: 7320 746f 2066 6f72 6d20 7468 6520 7065  s to form the pe
+0001c7a0: 726d 7574 6174 696f 6e20 6d61 7472 6978  rmutation matrix
+0001c7b0: 2041 2066 6f72 2074 616b 6520 286d 6179   A for take (may
+0001c7c0: 2063 6f6e 7461 696e 0a20 2020 2020 2020   contain.       
+0001c7d0: 2023 206d 756c 7469 706c 6520 6974 656d   # multiple item
+0001c7e0: 7320 7065 7220 636f 6c75 6d6e 2920 616e  s per column) an
+0001c7f0: 6420 4220 666f 7220 696e 666c 6174 6520  d B for inflate 
+0001c800: 286d 6179 2063 6f6e 7461 696e 2073 6576  (may contain sev
+0001c810: 6572 616c 2069 7465 6d73 0a20 2020 2020  eral items.     
+0001c820: 2020 2023 2070 6572 2072 6f77 2920 616e     # per row) an
+0001c830: 6420 7461 6b65 2074 6865 2070 726f 6475  d take the produ
+0001c840: 6374 2041 4220 666f 7220 7468 6520 636f  ct AB for the co
+0001c850: 6d62 696e 6564 206f 7065 7261 7469 6f6e  mbined operation
+0001c860: 2e20 546f 2074 6865 6e0a 2020 2020 2020  . To then.      
+0001c870: 2020 2320 6465 636f 6d70 6f73 6520 4142    # decompose AB
+0001c880: 2069 6e74 6f20 7468 6520 6571 7569 7661   into the equiva
+0001c890: 6c65 6e74 2074 616b 6520 666f 6c6c 6f77  lent take follow
+0001c8a0: 6564 2062 7920 696e 666c 6174 6520 7765  ed by inflate we
+0001c8b0: 2063 616e 2073 696d 706c 790a 2020 2020   can simply.    
+0001c8c0: 2020 2020 2320 7461 6b65 2074 6865 2074      # take the t
+0001c8d0: 776f 2069 6e64 6578 2076 6563 746f 7273  wo index vectors
+0001c8e0: 2066 726f 6d20 4142 2e6e 6f6e 7a65 726f   from AB.nonzero
+0001c8f0: 2829 2061 6e64 2066 6f72 6d20 4344 203d  () and form CD =
+0001c900: 2041 422e 2054 6865 0a20 2020 2020 2020   AB. The.       
+0001c910: 2023 2061 6c67 6f72 6974 686d 2062 656c   # algorithm bel
+0001c920: 6f77 2064 6f65 7320 7072 6563 6973 656c  ow does precisel
+0001c930: 7920 7468 6973 2077 6974 686f 7574 2066  y this without f
+0001c940: 6f72 6d69 6e67 2041 4220 6578 706c 6963  orming AB explic
+0001c950: 6974 6c79 2e0a 2020 2020 2020 2020 6e65  itly..        ne
+0001c960: 7769 6e66 6c61 7465 203d 205b 5d0a 2020  winflate = [].  
+0001c970: 2020 2020 2020 6e65 7774 616b 6520 3d20        newtake = 
+0001c980: 5b5d 0a20 2020 2020 2020 2066 6f72 206b  [].        for k
+0001c990: 2c20 6e20 696e 2065 6e75 6d65 7261 7465  , n in enumerate
+0001c9a0: 2869 6e74 6572 7365 6374 696f 6e29 3a0a  (intersection):.
+0001c9b0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+0001c9c0: 6920 696e 205b 7375 6274 616b 655b 6b5d  i in [subtake[k]
+0001c9d0: 5d20 6966 2075 6e69 7175 6574 616b 6520  ] if uniquetake 
+0001c9e0: 656c 7365 206e 756d 7079 2e65 7175 616c  else numpy.equal
+0001c9f0: 2874 616b 6569 6478 2e72 6176 656c 2829  (takeidx.ravel()
+0001ca00: 2c20 6e29 2e6e 6f6e 7a65 726f 2829 5b30  , n).nonzero()[0
+0001ca10: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
+0001ca20: 2020 2066 6f72 206a 2069 6e20 5b73 7562     for j in [sub
+0001ca30: 696e 666c 6174 655b 6b5d 5d20 6966 2075  inflate[k]] if u
+0001ca40: 6e69 7175 6569 6e66 6c61 7465 2065 6c73  niqueinflate els
+0001ca50: 6520 6e75 6d70 792e 6571 7561 6c28 696e  e numpy.equal(in
+0001ca60: 666c 6174 6569 6478 2e72 6176 656c 2829  flateidx.ravel()
+0001ca70: 2c20 6e29 2e6e 6f6e 7a65 726f 2829 5b30  , n).nonzero()[0
+0001ca80: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
+0001ca90: 2020 2020 2020 206e 6577 696e 666c 6174         newinflat
+0001caa0: 652e 6170 7065 6e64 2869 290a 2020 2020  e.append(i).    
+0001cab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cac0: 6e65 7774 616b 652e 6170 7065 6e64 286a  newtake.append(j
+0001cad0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0001cae0: 206e 756d 7079 2e61 7272 6179 286e 6577   numpy.array(new
+0001caf0: 7461 6b65 2c20 6474 7970 653d 696e 7429  take, dtype=int)
+0001cb00: 2c20 6e75 6d70 792e 6172 7261 7928 6e65  , numpy.array(ne
+0001cb10: 7769 6e66 6c61 7465 2c20 6474 7970 653d  winflate, dtype=
+0001cb20: 696e 7429 2c20 6e75 6d70 792e 6172 7261  int), numpy.arra
+0001cb30: 7928 6c65 6e28 6e65 7774 616b 6529 2c20  y(len(newtake), 
+0001cb40: 6474 7970 653d 696e 7429 0a0a 0a63 6c61  dtype=int)...cla
+0001cb50: 7373 2044 6961 676f 6e61 6c69 7a65 2841  ss Diagonalize(A
+0001cb60: 7272 6179 293a 0a0a 2020 2020 6465 6620  rray):..    def 
+0001cb70: 5f5f 696e 6974 5f5f 2873 656c 662c 2066  __init__(self, f
+0001cb80: 756e 633a 2041 7272 6179 293a 0a20 2020  unc: Array):.   
+0001cb90: 2020 2020 2061 7373 6572 7420 6973 696e       assert isin
+0001cba0: 7374 616e 6365 2866 756e 632c 2041 7272  stance(func, Arr
+0001cbb0: 6179 2920 616e 6420 6675 6e63 2e6e 6469  ay) and func.ndi
+0001cbc0: 6d20 3e20 302c 2066 2766 756e 633d 7b66  m > 0, f'func={f
+0001cbd0: 756e 6321 727d 270a 2020 2020 2020 2020  unc!r}'.        
+0001cbe0: 7365 6c66 2e66 756e 6320 3d20 6675 6e63  self.func = func
+0001cbf0: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
+0001cc00: 2e5f 5f69 6e69 745f 5f28 6172 6773 3d28  .__init__(args=(
+0001cc10: 6675 6e63 2c29 2c20 7368 6170 653d 282a  func,), shape=(*
+0001cc20: 6675 6e63 2e73 6861 7065 2c20 6675 6e63  func.shape, func
+0001cc30: 2e73 6861 7065 5b2d 315d 292c 2064 7479  .shape[-1]), dty
+0001cc40: 7065 3d66 756e 632e 6474 7970 6529 0a0a  pe=func.dtype)..
+0001cc50: 2020 2020 4063 6163 6865 645f 7072 6f70      @cached_prop
+0001cc60: 6572 7479 0a20 2020 2064 6566 205f 6469  erty.    def _di
+0001cc70: 6167 6f6e 616c 7328 7365 6c66 293a 0a20  agonals(self):. 
+0001cc80: 2020 2020 2020 2064 6961 676f 6e61 6c73         diagonals
+0001cc90: 203d 205b 6672 6f7a 656e 7365 7428 5b73   = [frozenset([s
+0001cca0: 656c 662e 6e64 696d 2d32 2c20 7365 6c66  elf.ndim-2, self
+0001ccb0: 2e6e 6469 6d2d 315d 295d 0a20 2020 2020  .ndim-1])].     
+0001ccc0: 2020 2066 6f72 2061 7865 7320 696e 2073     for axes in s
+0001ccd0: 656c 662e 6675 6e63 2e5f 6469 6167 6f6e  elf.func._diagon
+0001cce0: 616c 733a 0a20 2020 2020 2020 2020 2020  als:.           
+0001ccf0: 2069 6620 6178 6573 2026 2064 6961 676f   if axes & diago
+0001cd00: 6e61 6c73 5b30 5d3a 0a20 2020 2020 2020  nals[0]:.       
+0001cd10: 2020 2020 2020 2020 2064 6961 676f 6e61           diagona
+0001cd20: 6c73 5b30 5d20 7c3d 2061 7865 730a 2020  ls[0] |= axes.  
+0001cd30: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0001cd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cd50: 6469 6167 6f6e 616c 732e 6170 7065 6e64  diagonals.append
+0001cd60: 2861 7865 7329 0a20 2020 2020 2020 2072  (axes).        r
+0001cd70: 6574 7572 6e20 7475 706c 6528 6469 6167  eturn tuple(diag
+0001cd80: 6f6e 616c 7329 0a0a 2020 2020 4070 726f  onals)..    @pro
+0001cd90: 7065 7274 790a 2020 2020 6465 6620 5f69  perty.    def _i
+0001cda0: 6e66 6c61 7469 6f6e 7328 7365 6c66 293a  nflations(self):
+0001cdb0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001cdc0: 7475 706c 6528 2861 7869 732c 2074 7970  tuple((axis, typ
+0001cdd0: 6573 2e66 726f 7a65 6e64 6963 7428 2864  es.frozendict((d
+0001cde0: 6f66 6d61 702c 2044 6961 676f 6e61 6c69  ofmap, Diagonali
+0001cdf0: 7a65 2866 756e 6329 2920 666f 7220 646f  ze(func)) for do
+0001ce00: 666d 6170 2c20 6675 6e63 2069 6e20 7061  fmap, func in pa
+0001ce10: 7274 732e 6974 656d 7328 2929 290a 2020  rts.items())).  
+0001ce20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ce30: 2020 2066 6f72 2061 7869 732c 2070 6172     for axis, par
+0001ce40: 7473 2069 6e20 7365 6c66 2e66 756e 632e  ts in self.func.
+0001ce50: 5f69 6e66 6c61 7469 6f6e 730a 2020 2020  _inflations.    
+0001ce60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ce70: 2069 6620 6178 6973 203c 2073 656c 662e   if axis < self.
+0001ce80: 6e64 696d 2d32 290a 0a20 2020 2064 6566  ndim-2)..    def
+0001ce90: 205f 7369 6d70 6c69 6669 6564 2873 656c   _simplified(sel
+0001cea0: 6629 3a0a 2020 2020 2020 2020 6966 2073  f):.        if s
+0001ceb0: 656c 662e 7368 6170 655b 2d31 5d20 3d3d  elf.shape[-1] ==
+0001cec0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+0001ced0: 7265 7475 726e 2049 6e73 6572 7441 7869  return InsertAxi
+0001cee0: 7328 7365 6c66 2e66 756e 632c 2031 290a  s(self.func, 1).
+0001cef0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0001cf00: 656c 662e 6675 6e63 2e5f 6469 6167 6f6e  elf.func._diagon
+0001cf10: 616c 697a 6528 7365 6c66 2e6e 6469 6d2d  alize(self.ndim-
+0001cf20: 3229 0a0a 2020 2020 4073 7461 7469 636d  2)..    @staticm
+0001cf30: 6574 686f 640a 2020 2020 6465 6620 6576  ethod.    def ev
+0001cf40: 616c 6628 6172 7229 3a0a 2020 2020 2020  alf(arr):.      
+0001cf50: 2020 7265 7375 6c74 203d 206e 756d 7079    result = numpy
+0001cf60: 2e7a 6572 6f73 2861 7272 2e73 6861 7065  .zeros(arr.shape
+0001cf70: 2b28 6172 722e 7368 6170 655b 2d31 5d2c  +(arr.shape[-1],
+0001cf80: 292c 2064 7479 7065 3d61 7272 2e64 7479  ), dtype=arr.dty
+0001cf90: 7065 2c20 6f72 6465 723d 2746 2729 0a20  pe, order='F'). 
+0001cfa0: 2020 2020 2020 2064 6961 6720 3d20 6e75         diag = nu
+0001cfb0: 6d70 792e 636f 7265 2e6d 756c 7469 6172  mpy.core.multiar
+0001cfc0: 7261 792e 635f 6569 6e73 756d 2827 2e2e  ray.c_einsum('..
+0001cfd0: 2e69 692d 3e2e 2e2e 6927 2c20 7265 7375  .ii->...i', resu
+0001cfe0: 6c74 290a 2020 2020 2020 2020 6469 6167  lt).        diag
+0001cff0: 5b3a 5d20 3d20 6172 720a 2020 2020 2020  [:] = arr.      
+0001d000: 2020 7265 7475 726e 2072 6573 756c 740a    return result.
+0001d010: 0a20 2020 2064 6566 205f 6465 7269 7661  .    def _deriva
+0001d020: 7469 7665 2873 656c 662c 2076 6172 2c20  tive(self, var, 
+0001d030: 7365 656e 293a 0a20 2020 2020 2020 2072  seen):.        r
+0001d040: 6574 7572 6e20 6469 6167 6f6e 616c 697a  eturn diagonaliz
+0001d050: 6528 6465 7269 7661 7469 7665 2873 656c  e(derivative(sel
+0001d060: 662e 6675 6e63 2c20 7661 722c 2073 6565  f.func, var, see
+0001d070: 6e29 2c20 7365 6c66 2e6e 6469 6d2d 322c  n), self.ndim-2,
+0001d080: 2073 656c 662e 6e64 696d 2d31 290a 0a20   self.ndim-1).. 
+0001d090: 2020 2064 6566 205f 696e 7665 7273 6528     def _inverse(
+0001d0a0: 7365 6c66 2c20 6178 6973 312c 2061 7869  self, axis1, axi
+0001d0b0: 7332 293a 0a20 2020 2020 2020 2069 6620  s2):.        if 
+0001d0c0: 736f 7274 6564 285b 6178 6973 312c 2061  sorted([axis1, a
+0001d0d0: 7869 7332 5d29 203d 3d20 5b73 656c 662e  xis2]) == [self.
+0001d0e0: 6e64 696d 2d32 2c20 7365 6c66 2e6e 6469  ndim-2, self.ndi
+0001d0f0: 6d2d 315d 3a0a 2020 2020 2020 2020 2020  m-1]:.          
+0001d100: 2020 7265 7475 726e 2044 6961 676f 6e61    return Diagona
+0001d110: 6c69 7a65 2872 6563 6970 726f 6361 6c28  lize(reciprocal(
+0001d120: 7365 6c66 2e66 756e 6329 290a 0a20 2020  self.func))..   
+0001d130: 2064 6566 205f 6465 7465 726d 696e 616e   def _determinan
+0001d140: 7428 7365 6c66 2c20 6178 6973 312c 2061  t(self, axis1, a
+0001d150: 7869 7332 293a 0a20 2020 2020 2020 2069  xis2):.        i
+0001d160: 6620 736f 7274 6564 285b 6178 6973 312c  f sorted([axis1,
+0001d170: 2061 7869 7332 5d29 203d 3d20 5b73 656c   axis2]) == [sel
+0001d180: 662e 6e64 696d 2d32 2c20 7365 6c66 2e6e  f.ndim-2, self.n
+0001d190: 6469 6d2d 315d 3a0a 2020 2020 2020 2020  dim-1]:.        
+0001d1a0: 2020 2020 7265 7475 726e 2050 726f 6475      return Produ
+0001d1b0: 6374 2873 656c 662e 6675 6e63 290a 2020  ct(self.func).  
+0001d1c0: 2020 2020 2020 656c 6966 2061 7869 7331        elif axis1
+0001d1d0: 203c 2073 656c 662e 6e64 696d 2d32 2061   < self.ndim-2 a
+0001d1e0: 6e64 2061 7869 7332 203c 2073 656c 662e  nd axis2 < self.
+0001d1f0: 6e64 696d 2d32 3a0a 2020 2020 2020 2020  ndim-2:.        
+0001d200: 2020 2020 7265 7475 726e 2044 6961 676f      return Diago
+0001d210: 6e61 6c69 7a65 2864 6574 6572 6d69 6e61  nalize(determina
+0001d220: 6e74 2873 656c 662e 6675 6e63 2c20 2861  nt(self.func, (a
+0001d230: 7869 7331 2c20 6178 6973 3229 2929 0a0a  xis1, axis2)))..
+0001d240: 2020 2020 6465 6620 5f73 756d 2873 656c      def _sum(sel
+0001d250: 662c 2061 7869 7329 3a0a 2020 2020 2020  f, axis):.      
+0001d260: 2020 6966 2061 7869 7320 3e3d 2073 656c    if axis >= sel
+0001d270: 662e 6e64 696d 202d 2032 3a0a 2020 2020  f.ndim - 2:.    
+0001d280: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0001d290: 656c 662e 6675 6e63 0a20 2020 2020 2020  elf.func.       
+0001d2a0: 2072 6574 7572 6e20 4469 6167 6f6e 616c   return Diagonal
+0001d2b0: 697a 6528 7375 6d28 7365 6c66 2e66 756e  ize(sum(self.fun
+0001d2c0: 632c 2061 7869 7329 290a 0a20 2020 2064  c, axis))..    d
+0001d2d0: 6566 205f 7461 6b65 6469 6167 2873 656c  ef _takediag(sel
+0001d2e0: 662c 2061 7869 7331 2c20 6178 6973 3229  f, axis1, axis2)
+0001d2f0: 3a0a 2020 2020 2020 2020 6966 2061 7869  :.        if axi
+0001d300: 7331 203d 3d20 7365 6c66 2e6e 6469 6d2d  s1 == self.ndim-
+0001d310: 323a 2020 2320 6178 6973 3220 3d3d 2073  2:  # axis2 == s
+0001d320: 656c 662e 6e64 696d 2d31 0a20 2020 2020  elf.ndim-1.     
+0001d330: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0001d340: 6c66 2e66 756e 630a 2020 2020 2020 2020  lf.func.        
+0001d350: 656c 6966 2061 7869 7332 203e 3d20 7365  elif axis2 >= se
+0001d360: 6c66 2e6e 6469 6d2d 323a 0a20 2020 2020  lf.ndim-2:.     
+0001d370: 2020 2020 2020 2072 6574 7572 6e20 6469         return di
+0001d380: 6167 6f6e 616c 697a 6528 5f74 616b 6564  agonalize(_taked
+0001d390: 6961 6728 7365 6c66 2e66 756e 632c 2061  iag(self.func, a
+0001d3a0: 7869 7331 2c20 7365 6c66 2e6e 6469 6d2d  xis1, self.ndim-
+0001d3b0: 3229 2c20 7365 6c66 2e6e 6469 6d2d 332c  2), self.ndim-3,
+0001d3c0: 2073 656c 662e 6e64 696d 2d32 290a 2020   self.ndim-2).  
+0001d3d0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0001d3e0: 2020 2020 2020 2020 7265 7475 726e 2064          return d
+0001d3f0: 6961 676f 6e61 6c69 7a65 285f 7461 6b65  iagonalize(_take
+0001d400: 6469 6167 2873 656c 662e 6675 6e63 2c20  diag(self.func, 
+0001d410: 6178 6973 312c 2061 7869 7332 292c 2073  axis1, axis2), s
+0001d420: 656c 662e 6e64 696d 2d34 2c20 7365 6c66  elf.ndim-4, self
+0001d430: 2e6e 6469 6d2d 3329 0a0a 2020 2020 6465  .ndim-3)..    de
+0001d440: 6620 5f74 616b 6528 7365 6c66 2c20 696e  f _take(self, in
+0001d450: 6465 782c 2061 7869 7329 3a0a 2020 2020  dex, axis):.    
+0001d460: 2020 2020 6966 2061 7869 7320 3c20 7365      if axis < se
+0001d470: 6c66 2e6e 6469 6d20 2d20 323a 0a20 2020  lf.ndim - 2:.   
+0001d480: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001d490: 4469 6167 6f6e 616c 697a 6528 5f74 616b  Diagonalize(_tak
+0001d4a0: 6528 7365 6c66 2e66 756e 632c 2069 6e64  e(self.func, ind
+0001d4b0: 6578 2c20 6178 6973 2929 0a20 2020 2020  ex, axis)).     
+0001d4c0: 2020 2066 756e 6320 3d20 5f74 616b 6528     func = _take(
+0001d4d0: 7365 6c66 2e66 756e 632c 2069 6e64 6578  self.func, index
+0001d4e0: 2c20 7365 6c66 2e6e 6469 6d2d 3229 0a20  , self.ndim-2). 
+0001d4f0: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+0001d500: 7261 6e67 6528 696e 6465 782e 6e64 696d  range(index.ndim
+0001d510: 293a 0a20 2020 2020 2020 2020 2020 2066  ):.            f
+0001d520: 756e 6320 3d20 6469 6167 6f6e 616c 697a  unc = diagonaliz
+0001d530: 6528 6675 6e63 2c20 7365 6c66 2e6e 6469  e(func, self.ndi
+0001d540: 6d2d 322b 6929 0a20 2020 2020 2020 2072  m-2+i).        r
+0001d550: 6574 7572 6e20 5f69 6e66 6c61 7465 2866  eturn _inflate(f
+0001d560: 756e 632c 2069 6e64 6578 2c20 7365 6c66  unc, index, self
+0001d570: 2e66 756e 632e 7368 6170 655b 2d31 5d2c  .func.shape[-1],
+0001d580: 2073 656c 662e 6e64 696d 2d32 2069 6620   self.ndim-2 if 
+0001d590: 6178 6973 203d 3d20 7365 6c66 2e6e 6469  axis == self.ndi
+0001d5a0: 6d2d 3120 656c 7365 2073 656c 662e 6e64  m-1 else self.nd
+0001d5b0: 696d 2d32 2b69 6e64 6578 2e6e 6469 6d29  im-2+index.ndim)
+0001d5c0: 0a0a 2020 2020 6465 6620 5f75 6e72 6176  ..    def _unrav
+0001d5d0: 656c 2873 656c 662c 2061 7869 732c 2073  el(self, axis, s
+0001d5e0: 6861 7065 293a 0a20 2020 2020 2020 2069  hape):.        i
+0001d5f0: 6620 6178 6973 203e 3d20 7365 6c66 2e6e  f axis >= self.n
+0001d600: 6469 6d20 2d20 323a 0a20 2020 2020 2020  dim - 2:.       
+0001d610: 2020 2020 2064 6961 6720 3d20 6469 6167       diag = diag
+0001d620: 6f6e 616c 697a 6528 6469 6167 6f6e 616c  onalize(diagonal
+0001d630: 697a 6528 556e 7261 7665 6c28 7365 6c66  ize(Unravel(self
+0001d640: 2e66 756e 632c 202a 7368 6170 6529 2c20  .func, *shape), 
+0001d650: 7365 6c66 2e6e 6469 6d2d 322c 2073 656c  self.ndim-2, sel
+0001d660: 662e 6e64 696d 292c 2073 656c 662e 6e64  f.ndim), self.nd
+0001d670: 696d 2d31 2c20 7365 6c66 2e6e 6469 6d2b  im-1, self.ndim+
+0001d680: 3129 0a20 2020 2020 2020 2020 2020 2072  1).            r
+0001d690: 6574 7572 6e20 7261 7665 6c28 6469 6167  eturn ravel(diag
+0001d6a0: 2c20 7365 6c66 2e6e 6469 6d20 6966 2061  , self.ndim if a
+0001d6b0: 7869 7320 3d3d 2073 656c 662e 6e64 696d  xis == self.ndim
+0001d6c0: 2d32 2065 6c73 6520 7365 6c66 2e6e 6469  -2 else self.ndi
+0001d6d0: 6d2d 3229 0a20 2020 2020 2020 2065 6c73  m-2).        els
+0001d6e0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+0001d6f0: 6574 7572 6e20 4469 6167 6f6e 616c 697a  eturn Diagonaliz
+0001d700: 6528 756e 7261 7665 6c28 7365 6c66 2e66  e(unravel(self.f
+0001d710: 756e 632c 2061 7869 732c 2073 6861 7065  unc, axis, shape
+0001d720: 2929 0a0a 2020 2020 6465 6620 5f73 6967  ))..    def _sig
+0001d730: 6e28 7365 6c66 293a 0a20 2020 2020 2020  n(self):.       
+0001d740: 2072 6574 7572 6e20 4469 6167 6f6e 616c   return Diagonal
+0001d750: 697a 6528 5369 676e 2873 656c 662e 6675  ize(Sign(self.fu
+0001d760: 6e63 2929 0a0a 2020 2020 6465 6620 5f70  nc))..    def _p
+0001d770: 726f 6475 6374 2873 656c 6629 3a0a 2020  roduct(self):.  
+0001d780: 2020 2020 2020 6966 206e 756d 6572 6963        if numeric
+0001d790: 2e69 7369 6e74 2873 656c 662e 7368 6170  .isint(self.shap
+0001d7a0: 655b 2d31 5d29 2061 6e64 2073 656c 662e  e[-1]) and self.
+0001d7b0: 7368 6170 655b 2d31 5d20 3e20 313a 0a20  shape[-1] > 1:. 
+0001d7c0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001d7d0: 6e20 5a65 726f 7328 7365 6c66 2e73 6861  n Zeros(self.sha
+0001d7e0: 7065 5b3a 2d31 5d2c 2064 7479 7065 3d73  pe[:-1], dtype=s
+0001d7f0: 656c 662e 6474 7970 6529 0a0a 2020 2020  elf.dtype)..    
+0001d800: 6465 6620 5f6c 6f6f 7073 756d 2873 656c  def _loopsum(sel
+0001d810: 662c 2069 6e64 6578 293a 0a20 2020 2020  f, index):.     
+0001d820: 2020 2072 6574 7572 6e20 4469 6167 6f6e     return Diagon
+0001d830: 616c 697a 6528 6c6f 6f70 5f73 756d 2873  alize(loop_sum(s
+0001d840: 656c 662e 6675 6e63 2c20 696e 6465 7829  elf.func, index)
+0001d850: 290a 0a20 2020 2040 6361 6368 6564 5f70  )..    @cached_p
+0001d860: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+0001d870: 5f61 7373 7061 7273 6528 7365 6c66 293a  _assparse(self):
+0001d880: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001d890: 7475 706c 6528 282a 696e 6469 6365 732c  tuple((*indices,
+0001d8a0: 2069 6e64 6963 6573 5b2d 315d 2c20 7661   indices[-1], va
+0001d8b0: 6c75 6573 2920 666f 7220 2a69 6e64 6963  lues) for *indic
+0001d8c0: 6573 2c20 7661 6c75 6573 2069 6e20 7365  es, values in se
+0001d8d0: 6c66 2e66 756e 632e 5f61 7373 7061 7273  lf.func._asspars
+0001d8e0: 6529 0a0a 0a63 6c61 7373 2047 7561 7264  e)...class Guard
+0001d8f0: 2841 7272 6179 293a 0a20 2020 2027 6261  (Array):.    'ba
+0001d900: 7220 616c 6c20 7369 6d70 6c69 6669 6361  r all simplifica
+0001d910: 7469 6f6e 7327 0a0a 2020 2020 6465 6620  tions'..    def 
+0001d920: 5f5f 696e 6974 5f5f 2873 656c 662c 2066  __init__(self, f
+0001d930: 756e 3a20 4172 7261 7929 3a0a 2020 2020  un: Array):.    
+0001d940: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
+0001d950: 7461 6e63 6528 6675 6e2c 2041 7272 6179  tance(fun, Array
+0001d960: 292c 2066 2766 756e 3d7b 6675 6e21 727d  ), f'fun={fun!r}
+0001d970: 270a 2020 2020 2020 2020 7365 6c66 2e66  '.        self.f
+0001d980: 756e 203d 2066 756e 0a20 2020 2020 2020  un = fun.       
+0001d990: 2073 7570 6572 2829 2e5f 5f69 6e69 745f   super().__init_
+0001d9a0: 5f28 6172 6773 3d28 6675 6e2c 292c 2073  _(args=(fun,), s
+0001d9b0: 6861 7065 3d66 756e 2e73 6861 7065 2c20  hape=fun.shape, 
+0001d9c0: 6474 7970 653d 6675 6e2e 6474 7970 6529  dtype=fun.dtype)
+0001d9d0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+0001d9e0: 2020 2020 6465 6620 6973 636f 6e73 7461      def isconsta
+0001d9f0: 6e74 2873 656c 6629 3a0a 2020 2020 2020  nt(self):.      
+0001da00: 2020 7265 7475 726e 2046 616c 7365 2020    return False  
+0001da10: 2320 6176 6f69 6420 7369 6d70 6c69 6669  # avoid simplifi
+0001da20: 6361 7469 6f6e 7320 6261 7365 6420 6f6e  cations based on
+0001da30: 2066 756e 2062 6569 6e67 2063 6f6e 7374   fun being const
+0001da40: 616e 740a 0a20 2020 2040 7374 6174 6963  ant..    @static
+0001da50: 6d65 7468 6f64 0a20 2020 2064 6566 2065  method.    def e
+0001da60: 7661 6c66 2864 6174 293a 0a20 2020 2020  valf(dat):.     
+0001da70: 2020 2072 6574 7572 6e20 6461 740a 0a20     return dat.. 
+0001da80: 2020 2064 6566 205f 6465 7269 7661 7469     def _derivati
+0001da90: 7665 2873 656c 662c 2076 6172 2c20 7365  ve(self, var, se
+0001daa0: 656e 293a 0a20 2020 2020 2020 2072 6574  en):.        ret
+0001dab0: 7572 6e20 4775 6172 6428 6465 7269 7661  urn Guard(deriva
+0001dac0: 7469 7665 2873 656c 662e 6675 6e2c 2076  tive(self.fun, v
+0001dad0: 6172 2c20 7365 656e 2929 0a0a 0a63 6c61  ar, seen))...cla
+0001dae0: 7373 2046 696e 6428 4172 7261 7929 3a0a  ss Find(Array):.
+0001daf0: 2020 2020 2769 6e64 6963 6573 206f 6620      'indices of 
+0001db00: 626f 6f6c 6561 6e20 696e 6465 7820 7665  boolean index ve
+0001db10: 6374 6f72 270a 0a20 2020 2064 6566 205f  ctor'..    def _
+0001db20: 5f69 6e69 745f 5f28 7365 6c66 2c20 7768  _init__(self, wh
+0001db30: 6572 653a 2041 7272 6179 293a 0a20 2020  ere: Array):.   
+0001db40: 2020 2020 2061 7373 6572 7420 6973 6172       assert isar
+0001db50: 7261 7928 7768 6572 6529 2061 6e64 2077  ray(where) and w
+0001db60: 6865 7265 2e6e 6469 6d20 3d3d 2031 2061  here.ndim == 1 a
+0001db70: 6e64 2077 6865 7265 2e64 7479 7065 203d  nd where.dtype =
+0001db80: 3d20 626f 6f6c 0a20 2020 2020 2020 2073  = bool.        s
+0001db90: 656c 662e 7768 6572 6520 3d20 7768 6572  elf.where = wher
+0001dba0: 650a 2020 2020 2020 2020 7375 7065 7228  e.        super(
+0001dbb0: 292e 5f5f 696e 6974 5f5f 2861 7267 733d  ).__init__(args=
+0001dbc0: 2877 6865 7265 2c29 2c20 7368 6170 653d  (where,), shape=
+0001dbd0: 2853 756d 2842 6f6f 6c54 6f49 6e74 2877  (Sum(BoolToInt(w
+0001dbe0: 6865 7265 2929 2c29 2c20 6474 7970 653d  here)),), dtype=
+0001dbf0: 696e 7429 0a0a 2020 2020 4073 7461 7469  int)..    @stati
+0001dc00: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
+0001dc10: 6576 616c 6628 7768 6572 6529 3a0a 2020  evalf(where):.  
+0001dc20: 2020 2020 2020 7265 7475 726e 2077 6865        return whe
+0001dc30: 7265 2e6e 6f6e 7a65 726f 2829 5b30 5d0a  re.nonzero()[0].
+0001dc40: 0a20 2020 2064 6566 205f 7369 6d70 6c69  .    def _simpli
+0001dc50: 6669 6564 2873 656c 6629 3a0a 2020 2020  fied(self):.    
+0001dc60: 2020 2020 6966 2073 656c 662e 6973 636f      if self.isco
+0001dc70: 6e73 7461 6e74 3a0a 2020 2020 2020 2020  nstant:.        
+0001dc80: 2020 2020 7265 7475 726e 2063 6f6e 7374      return const
+0001dc90: 616e 7428 7365 6c66 2e65 7661 6c28 2929  ant(self.eval())
+0001dca0: 0a0a 0a63 6c61 7373 2044 6572 6976 6174  ...class Derivat
+0001dcb0: 6976 6554 6172 6765 7442 6173 6528 4172  iveTargetBase(Ar
+0001dcc0: 7261 7929 3a0a 2020 2020 2762 6173 6520  ray):.    'base 
+0001dcd0: 636c 6173 7320 666f 7220 6465 7269 7661  class for deriva
+0001dce0: 7469 7665 2074 6172 6765 7473 270a 0a20  tive targets'.. 
+0001dcf0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+0001dd00: 2064 6566 2069 7363 6f6e 7374 616e 7428   def isconstant(
+0001dd10: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+0001dd20: 6574 7572 6e20 4661 6c73 650a 0a0a 636c  eturn False...cl
+0001dd30: 6173 7320 5769 7468 4465 7269 7661 7469  ass WithDerivati
+0001dd40: 7665 2841 7272 6179 293a 0a20 2020 2027  ve(Array):.    '
+0001dd50: 2727 5772 6170 2074 6865 2067 6976 656e  ''Wrap the given
+0001dd60: 2066 756e 6374 696f 6e20 616e 6420 6465   function and de
+0001dd70: 6669 6e65 2074 6865 2064 6572 6976 6174  fine the derivat
+0001dd80: 6976 6520 746f 2061 2074 6172 6765 742e  ive to a target.
+0001dd90: 0a0a 2020 2020 5468 6520 7772 6170 7065  ..    The wrappe
+0001dda0: 7220 6973 2074 7970 6963 616c 6c79 2075  r is typically u
+0001ddb0: 7365 6420 746f 6765 7468 6572 2077 6974  sed together wit
+0001ddc0: 6820 6120 7669 7274 7561 6c20 6465 7269  h a virtual deri
+0001ddd0: 7661 7469 7665 2074 6172 6765 7420 6c69  vative target li
+0001dde0: 6b65 0a20 2020 203a 636c 6173 733a 6049  ke.    :class:`I
+0001ddf0: 6465 6e74 6966 6965 7244 6572 6976 6174  dentifierDerivat
+0001de00: 6976 6554 6172 6765 7460 2e20 5468 6520  iveTarget`. The 
+0001de10: 7772 6170 7065 7220 6973 2072 656d 6f76  wrapper is remov
+0001de20: 6564 2069 6e20 7468 6520 7369 6d70 6c69  ed in the simpli
+0001de30: 6669 6564 0a20 2020 2066 6f72 6d2e 0a0a  fied.    form...
+0001de40: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
+0001de50: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
+0001de60: 2020 6675 6e63 203a 203a 636c 6173 733a    func : :class:
+0001de70: 6041 7272 6179 600a 2020 2020 2020 2020  `Array`.        
+0001de80: 5468 6520 6675 6e63 7469 6f6e 2074 6f20  The function to 
+0001de90: 7772 6170 2e0a 2020 2020 7661 7220 3a20  wrap..    var : 
+0001dea0: 3a63 6c61 7373 3a60 4465 7269 7661 7469  :class:`Derivati
+0001deb0: 7665 5461 7267 6574 4261 7365 600a 2020  veTargetBase`.  
+0001dec0: 2020 2020 2020 5468 6520 6465 7269 7661        The deriva
+0001ded0: 7469 7665 2074 6172 6765 742e 0a20 2020  tive target..   
+0001dee0: 2064 6572 6976 6174 6976 6520 3a20 3a63   derivative : :c
+0001def0: 6c61 7373 3a60 4172 7261 7960 0a20 2020  lass:`Array`.   
+0001df00: 2020 2020 2054 6865 2064 6572 6976 6174       The derivat
+0001df10: 6976 6520 7769 7468 2073 6861 7065 2060  ive with shape `
+0001df20: 6066 756e 632e 7368 6170 6520 2b20 7661  `func.shape + va
+0001df30: 722e 7368 6170 6560 602e 0a0a 2020 2020  r.shape``...    
+0001df40: 5365 6520 416c 736f 0a20 2020 202d 2d2d  See Also.    ---
+0001df50: 2d2d 2d2d 2d0a 2020 2020 3a63 6c61 7373  -----.    :class
+0001df60: 3a60 4964 656e 7469 6669 6572 4465 7269  :`IdentifierDeri
+0001df70: 7661 7469 7665 5461 7267 6574 6020 3a20  vativeTarget` : 
+0001df80: 6120 7669 7274 7561 6c20 6465 7269 7661  a virtual deriva
+0001df90: 7469 7665 2074 6172 6765 740a 2020 2020  tive target.    
+0001dfa0: 2727 270a 0a20 2020 2064 6566 205f 5f69  '''..    def __i
+0001dfb0: 6e69 745f 5f28 7365 6c66 2c20 6675 6e63  nit__(self, func
+0001dfc0: 3a20 4172 7261 792c 2076 6172 3a20 4465  : Array, var: De
+0001dfd0: 7269 7661 7469 7665 5461 7267 6574 4261  rivativeTargetBa
+0001dfe0: 7365 2c20 6465 7269 7661 7469 7665 3a20  se, derivative: 
+0001dff0: 4172 7261 7929 202d 3e20 4e6f 6e65 3a0a  Array) -> None:.
+0001e000: 2020 2020 2020 2020 7365 6c66 2e5f 6675          self._fu
+0001e010: 6e63 203d 2066 756e 630a 2020 2020 2020  nc = func.      
+0001e020: 2020 7365 6c66 2e5f 7661 7220 3d20 7661    self._var = va
+0001e030: 720a 2020 2020 2020 2020 7365 6c66 2e5f  r.        self._
+0001e040: 6465 7269 7620 3d20 6465 7269 7661 7469  deriv = derivati
+0001e050: 7665 0a20 2020 2020 2020 2073 7570 6572  ve.        super
+0001e060: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
+0001e070: 3d28 6675 6e63 2c29 2c20 7368 6170 653d  =(func,), shape=
+0001e080: 6675 6e63 2e73 6861 7065 2c20 6474 7970  func.shape, dtyp
+0001e090: 653d 6675 6e63 2e64 7479 7065 290a 0a20  e=func.dtype).. 
+0001e0a0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+0001e0b0: 2064 6566 2061 7267 756d 656e 7473 2873   def arguments(s
+0001e0c0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0001e0d0: 7475 726e 2073 656c 662e 5f66 756e 632e  turn self._func.
+0001e0e0: 6172 6775 6d65 6e74 7320 7c20 7b73 656c  arguments | {sel
+0001e0f0: 662e 5f76 6172 7d0a 0a20 2020 2040 7374  f._var}..    @st
+0001e100: 6174 6963 6d65 7468 6f64 0a20 2020 2064  aticmethod.    d
+0001e110: 6566 2065 7661 6c66 2866 756e 633a 206e  ef evalf(func: n
+0001e120: 756d 7079 2e6e 6461 7272 6179 2920 2d3e  umpy.ndarray) ->
+0001e130: 206e 756d 7079 2e6e 6461 7272 6179 3a0a   numpy.ndarray:.
+0001e140: 2020 2020 2020 2020 7265 7475 726e 2066          return f
+0001e150: 756e 630a 0a20 2020 2064 6566 205f 6465  unc..    def _de
+0001e160: 7269 7661 7469 7665 2873 656c 662c 2076  rivative(self, v
+0001e170: 6172 3a20 4465 7269 7661 7469 7665 5461  ar: DerivativeTa
+0001e180: 7267 6574 4261 7365 2c20 7365 656e 2920  rgetBase, seen) 
+0001e190: 2d3e 2041 7272 6179 3a0a 2020 2020 2020  -> Array:.      
+0001e1a0: 2020 6966 2076 6172 203d 3d20 7365 6c66    if var == self
+0001e1b0: 2e5f 7661 723a 0a20 2020 2020 2020 2020  ._var:.         
+0001e1c0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+0001e1d0: 6465 7269 760a 2020 2020 2020 2020 656c  deriv.        el
+0001e1e0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0001e1f0: 7265 7475 726e 2064 6572 6976 6174 6976  return derivativ
+0001e200: 6528 7365 6c66 2e5f 6675 6e63 2c20 7661  e(self._func, va
+0001e210: 722c 2073 6565 6e29 0a0a 2020 2020 6465  r, seen)..    de
+0001e220: 6620 5f73 696d 706c 6966 6965 6428 7365  f _simplified(se
+0001e230: 6c66 2920 2d3e 2041 7272 6179 3a0a 2020  lf) -> Array:.  
+0001e240: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0001e250: 662e 5f66 756e 630a 0a0a 636c 6173 7320  f._func...class 
+0001e260: 4172 6775 6d65 6e74 2844 6572 6976 6174  Argument(Derivat
+0001e270: 6976 6554 6172 6765 7442 6173 6529 3a0a  iveTargetBase):.
+0001e280: 2020 2020 2727 2741 7272 6179 2061 7267      '''Array arg
+0001e290: 756d 656e 742c 2074 6f20 6265 2073 7562  ument, to be sub
+0001e2a0: 7374 6974 7574 6564 2062 6566 6f72 6520  stituted before 
+0001e2b0: 6576 616c 7561 7469 6f6e 2e0a 0a20 2020  evaluation...   
+0001e2c0: 2054 6865 203a 636c 6173 733a 6041 7267   The :class:`Arg
+0001e2d0: 756d 656e 7460 2069 7320 616e 203a 636c  ument` is an :cl
+0001e2e0: 6173 733a 6041 7272 6179 6020 7769 7468  ass:`Array` with
+0001e2f0: 2061 206b 6e6f 776e 2073 6861 7065 2c20   a known shape, 
+0001e300: 6275 7420 7768 6f73 650a 2020 2020 7661  but whose.    va
+0001e310: 6c75 6573 2061 7265 2074 6f20 6265 2064  lues are to be d
+0001e320: 6566 696e 6564 206c 6174 6572 2c20 6265  efined later, be
+0001e330: 666f 7265 2065 7661 6c75 6174 696f 6e2c  fore evaluation,
+0001e340: 2065 2e67 2e20 7573 696e 670a 2020 2020   e.g. using.    
+0001e350: 3a66 756e 633a 6072 6570 6c61 6365 5f61  :func:`replace_a
+0001e360: 7267 756d 656e 7473 602e 0a0a 2020 2020  rguments`...    
+0001e370: 4974 2069 7320 706f 7373 6962 6c65 2074  It is possible t
+0001e380: 6f20 7461 6b65 2074 6865 2064 6572 6976  o take the deriv
+0001e390: 6174 6976 6520 6f66 2061 6e20 3a63 6c61  ative of an :cla
+0001e3a0: 7373 3a60 4172 7261 7960 2074 6f20 616e  ss:`Array` to an
+0001e3b0: 0a20 2020 203a 636c 6173 733a 6041 7267  .    :class:`Arg
+0001e3c0: 756d 656e 7460 3a0a 0a20 2020 203e 3e3e  ument`:..    >>>
+0001e3d0: 2066 726f 6d20 6e75 7469 6c73 2069 6d70   from nutils imp
+0001e3e0: 6f72 7420 6576 616c 7561 626c 650a 2020  ort evaluable.  
+0001e3f0: 2020 3e3e 3e20 6120 3d20 6576 616c 7561    >>> a = evalua
+0001e400: 626c 652e 4172 6775 6d65 6e74 2827 7827  ble.Argument('x'
+0001e410: 2c20 2829 290a 2020 2020 3e3e 3e20 6220  , ()).    >>> b 
+0001e420: 3d20 6576 616c 7561 626c 652e 4172 6775  = evaluable.Argu
+0001e430: 6d65 6e74 2827 7927 2c20 2829 290a 2020  ment('y', ()).  
+0001e440: 2020 3e3e 3e20 6620 3d20 612a 2a33 202b    >>> f = a**3 +
+0001e450: 2062 2a2a 320a 2020 2020 3e3e 3e20 6576   b**2.    >>> ev
+0001e460: 616c 7561 626c 652e 6465 7269 7661 7469  aluable.derivati
+0001e470: 7665 2866 2c20 6229 2e73 696d 706c 6966  ve(f, b).simplif
+0001e480: 6965 6420 3d3d 2032 2e2a 620a 2020 2020  ied == 2.*b.    
+0001e490: 5472 7565 0a0a 2020 2020 4172 6773 0a20  True..    Args. 
+0001e4a0: 2020 202d 2d2d 2d0a 2020 2020 6e61 6d65     ----.    name
+0001e4b0: 203a 203a 636c 6173 733a 6073 7472 600a   : :class:`str`.
+0001e4c0: 2020 2020 2020 2020 5468 6520 4964 656e          The Iden
+0001e4d0: 7469 6669 6572 206f 6620 7468 6973 2061  tifier of this a
+0001e4e0: 7267 756d 656e 742e 0a20 2020 2073 6861  rgument..    sha
+0001e4f0: 7065 203a 203a 636c 6173 733a 6074 7570  pe : :class:`tup
+0001e500: 6c65 6020 6f66 203a 636c 6173 733a 6069  le` of :class:`i
+0001e510: 6e74 605c 5c73 0a20 2020 2020 2020 2054  nt`\\s.        T
+0001e520: 6865 2073 6861 7065 206f 6620 7468 6973  he shape of this
+0001e530: 2061 7267 756d 656e 742e 0a20 2020 2027   argument..    '
+0001e540: 2727 0a0a 2020 2020 6465 6620 5f5f 696e  ''..    def __in
+0001e550: 6974 5f5f 2873 656c 662c 206e 616d 653a  it__(self, name:
+0001e560: 2073 7472 2c20 7368 6170 653a 2074 7970   str, shape: typ
+0001e570: 696e 672e 5475 706c 655b 4172 7261 792c  ing.Tuple[Array,
+0001e580: 202e 2e2e 5d2c 2064 7479 7065 3a20 4474   ...], dtype: Dt
+0001e590: 7970 6520 3d20 666c 6f61 7429 3a0a 2020  ype = float):.  
+0001e5a0: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+0001e5b0: 6e73 7461 6e63 6528 6e61 6d65 2c20 7374  nstance(name, st
+0001e5c0: 7229 2c20 6627 6e61 6d65 3d7b 6e61 6d65  r), f'name={name
+0001e5d0: 2172 7d27 0a20 2020 2020 2020 2061 7373  !r}'.        ass
+0001e5e0: 6572 7420 6973 696e 7374 616e 6365 2873  ert isinstance(s
+0001e5f0: 6861 7065 2c20 7475 706c 6529 2061 6e64  hape, tuple) and
+0001e600: 2061 6c6c 285f 6973 696e 6465 7828 6e29   all(_isindex(n)
+0001e610: 2066 6f72 206e 2069 6e20 7368 6170 6529   for n in shape)
+0001e620: 2c20 6627 7368 6170 653d 7b73 6861 7065  , f'shape={shape
+0001e630: 2172 7d27 0a20 2020 2020 2020 2073 656c  !r}'.        sel
+0001e640: 662e 5f6e 616d 6520 3d20 6e61 6d65 0a20  f._name = name. 
+0001e650: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+0001e660: 5f69 6e69 745f 5f28 6172 6773 3d28 4556  _init__(args=(EV
+0001e670: 414c 4152 4753 2c20 2a73 6861 7065 292c  ALARGS, *shape),
+0001e680: 2073 6861 7065 3d73 6861 7065 2c20 6474   shape=shape, dt
+0001e690: 7970 653d 6474 7970 6529 0a0a 2020 2020  ype=dtype)..    
+0001e6a0: 6465 6620 6576 616c 6628 7365 6c66 2c20  def evalf(self, 
+0001e6b0: 6576 616c 6172 6773 2c20 2a73 6861 7065  evalargs, *shape
+0001e6c0: 293a 0a20 2020 2020 2020 2074 7279 3a0a  ):.        try:.
+0001e6d0: 2020 2020 2020 2020 2020 2020 7661 6c75              valu
+0001e6e0: 6520 3d20 6576 616c 6172 6773 5b73 656c  e = evalargs[sel
+0001e6f0: 662e 5f6e 616d 655d 0a20 2020 2020 2020  f._name].       
+0001e700: 2065 7863 6570 7420 4b65 7945 7272 6f72   except KeyError
+0001e710: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+0001e720: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
+0001e730: 2761 7267 756d 656e 7420 7b73 656c 662e  'argument {self.
+0001e740: 5f6e 616d 6521 727d 206d 6973 7369 6e67  _name!r} missing
+0001e750: 2729 0a20 2020 2020 2020 2076 616c 7565  ').        value
+0001e760: 203d 206e 756d 7079 2e61 7361 7272 6179   = numpy.asarray
+0001e770: 2876 616c 7565 290a 2020 2020 2020 2020  (value).        
+0001e780: 6966 2076 616c 7565 2e73 6861 7065 2021  if value.shape !
+0001e790: 3d20 7368 6170 653a 0a20 2020 2020 2020  = shape:.       
+0001e7a0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+0001e7b0: 4572 726f 7228 6627 6172 6775 6d65 6e74  Error(f'argument
+0001e7c0: 207b 7365 6c66 2e5f 6e61 6d65 2172 7d20   {self._name!r} 
+0001e7d0: 6861 7320 7468 6520 7772 6f6e 6720 7368  has the wrong sh
+0001e7e0: 6170 653a 2065 7870 6563 7465 6420 7b73  ape: expected {s
+0001e7f0: 6861 7065 7d2c 2067 6f74 207b 7661 6c75  hape}, got {valu
+0001e800: 652e 7368 6170 657d 2729 0a20 2020 2020  e.shape}').     
+0001e810: 2020 2072 6574 7572 6e20 7661 6c75 652e     return value.
+0001e820: 6173 7479 7065 2873 656c 662e 6474 7970  astype(self.dtyp
+0001e830: 652c 2063 6173 7469 6e67 3d27 7361 6665  e, casting='safe
+0001e840: 272c 2063 6f70 793d 4661 6c73 6529 0a0a  ', copy=False)..
+0001e850: 2020 2020 6465 6620 5f64 6572 6976 6174      def _derivat
+0001e860: 6976 6528 7365 6c66 2c20 7661 722c 2073  ive(self, var, s
+0001e870: 6565 6e29 3a0a 2020 2020 2020 2020 6966  een):.        if
+0001e880: 2069 7369 6e73 7461 6e63 6528 7661 722c   isinstance(var,
+0001e890: 2041 7267 756d 656e 7429 2061 6e64 2076   Argument) and v
+0001e8a0: 6172 2e5f 6e61 6d65 203d 3d20 7365 6c66  ar._name == self
+0001e8b0: 2e5f 6e61 6d65 2061 6e64 2073 656c 662e  ._name and self.
+0001e8c0: 6474 7970 6520 696e 2028 666c 6f61 742c  dtype in (float,
+0001e8d0: 2063 6f6d 706c 6578 293a 0a20 2020 2020   complex):.     
+0001e8e0: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
+0001e8f0: 6f6e 6573 2873 656c 662e 7368 6170 652c  ones(self.shape,
+0001e900: 2073 656c 662e 6474 7970 6529 0a20 2020   self.dtype).   
+0001e910: 2020 2020 2020 2020 2066 6f72 2069 2c20           for i, 
+0001e920: 7368 2069 6e20 656e 756d 6572 6174 6528  sh in enumerate(
+0001e930: 7365 6c66 2e73 6861 7065 293a 0a20 2020  self.shape):.   
+0001e940: 2020 2020 2020 2020 2020 2020 2072 6573               res
+0001e950: 756c 7420 3d20 6469 6167 6f6e 616c 697a  ult = diagonaliz
+0001e960: 6528 7265 7375 6c74 2c20 692c 2069 2b73  e(result, i, i+s
+0001e970: 656c 662e 6e64 696d 290a 2020 2020 2020  elf.ndim).      
+0001e980: 2020 2020 2020 7265 7475 726e 2072 6573        return res
+0001e990: 756c 740a 2020 2020 2020 2020 656c 7365  ult.        else
+0001e9a0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0001e9b0: 7475 726e 207a 6572 6f73 2873 656c 662e  turn zeros(self.
+0001e9c0: 7368 6170 652b 7661 722e 7368 6170 6529  shape+var.shape)
+0001e9d0: 0a0a 2020 2020 6465 6620 5f5f 7374 725f  ..    def __str_
+0001e9e0: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
+0001e9f0: 2072 6574 7572 6e20 277b 7d20 7b21 727d   return '{} {!r}
+0001ea00: 203c 7b7d 3e27 2e66 6f72 6d61 7428 7365   <{}>'.format(se
+0001ea10: 6c66 2e5f 5f63 6c61 7373 5f5f 2e5f 5f6e  lf.__class__.__n
+0001ea20: 616d 655f 5f2c 2073 656c 662e 5f6e 616d  ame__, self._nam
+0001ea30: 652c 2073 656c 662e 5f73 6861 7065 5f73  e, self._shape_s
+0001ea40: 7472 2866 6f72 6d3d 7374 7229 290a 0a20  tr(form=str)).. 
+0001ea50: 2020 2064 6566 205f 6e6f 6465 2873 656c     def _node(sel
+0001ea60: 662c 2063 6163 6865 2c20 7375 6267 7261  f, cache, subgra
+0001ea70: 7068 2c20 7469 6d65 7329 3a0a 2020 2020  ph, times):.    
+0001ea80: 2020 2020 6966 2073 656c 6620 696e 2063      if self in c
+0001ea90: 6163 6865 3a0a 2020 2020 2020 2020 2020  ache:.          
+0001eaa0: 2020 7265 7475 726e 2063 6163 6865 5b73    return cache[s
+0001eab0: 656c 665d 0a20 2020 2020 2020 2065 6c73  elf].        els
+0001eac0: 653a 0a20 2020 2020 2020 2020 2020 206c  e:.            l
+0001ead0: 6162 656c 203d 2027 5c6e 272e 6a6f 696e  abel = '\n'.join
+0001eae0: 2866 696c 7465 7228 4e6f 6e65 2c20 2874  (filter(None, (t
+0001eaf0: 7970 6528 7365 6c66 292e 5f5f 6e61 6d65  ype(self).__name
+0001eb00: 5f5f 2c20 7365 6c66 2e5f 6e61 6d65 2c20  __, self._name, 
+0001eb10: 7365 6c66 2e5f 7368 6170 655f 7374 7228  self._shape_str(
+0001eb20: 666f 726d 3d72 6570 7229 2929 290a 2020  form=repr)))).  
+0001eb30: 2020 2020 2020 2020 2020 6361 6368 655b            cache[
+0001eb40: 7365 6c66 5d20 3d20 6e6f 6465 203d 2044  self] = node = D
+0001eb50: 7570 6c69 6361 7465 644c 6561 664e 6f64  uplicatedLeafNod
+0001eb60: 6528 6c61 6265 6c2c 2028 7479 7065 2873  e(label, (type(s
+0001eb70: 656c 6629 2e5f 5f6e 616d 655f 5f2c 2074  elf).__name__, t
+0001eb80: 696d 6573 5b73 656c 665d 2929 0a20 2020  imes[self])).   
+0001eb90: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001eba0: 6e6f 6465 0a0a 2020 2020 4070 726f 7065  node..    @prope
+0001ebb0: 7274 790a 2020 2020 6465 6620 6172 6775  rty.    def argu
+0001ebc0: 6d65 6e74 7328 7365 6c66 293a 0a20 2020  ments(self):.   
+0001ebd0: 2020 2020 2072 6574 7572 6e20 6672 6f7a       return froz
+0001ebe0: 656e 7365 7428 7b73 656c 667d 290a 0a0a  enset({self})...
+0001ebf0: 636c 6173 7320 4964 656e 7469 6669 6572  class Identifier
+0001ec00: 4465 7269 7661 7469 7665 5461 7267 6574  DerivativeTarget
+0001ec10: 2844 6572 6976 6174 6976 6554 6172 6765  (DerivativeTarge
+0001ec20: 7442 6173 6529 3a0a 2020 2020 2727 2756  tBase):.    '''V
+0001ec30: 6972 7475 616c 2064 6572 6976 6174 6976  irtual derivativ
+0001ec40: 6520 7461 7267 6574 2064 6973 7469 6e67  e target disting
+0001ec50: 7569 7368 6564 2062 7920 616e 2069 6465  uished by an ide
+0001ec60: 6e74 6966 6965 722e 0a0a 2020 2020 5061  ntifier...    Pa
+0001ec70: 7261 6d65 7465 7273 0a20 2020 202d 2d2d  rameters.    ---
+0001ec80: 2d2d 2d2d 2d2d 2d0a 2020 2020 6964 656e  -------.    iden
+0001ec90: 7469 6669 6572 203a 2068 6173 6861 626c  tifier : hashabl
+0001eca0: 6520 3a63 6c61 7373 3a60 6f62 6a65 6374  e :class:`object
+0001ecb0: 600a 2020 2020 2020 2020 5468 6520 6964  `.        The id
+0001ecc0: 656e 7469 6669 6572 2066 6f72 2074 6869  entifier for thi
+0001ecd0: 7320 6465 7269 7661 7469 7665 2074 6172  s derivative tar
+0001ece0: 6765 742e 0a20 2020 2073 6861 7065 203a  get..    shape :
+0001ecf0: 203a 636c 6173 733a 6074 7570 6c65 6020   :class:`tuple` 
+0001ed00: 6f66 203a 636c 6173 733a 6041 7272 6179  of :class:`Array
+0001ed10: 6020 6f72 203a 636c 6173 733a 6069 6e74  ` or :class:`int
+0001ed20: 600a 2020 2020 2020 2020 5468 6520 7368  `.        The sh
+0001ed30: 6170 6520 6f66 2074 6869 7320 6465 7269  ape of this deri
+0001ed40: 7661 7469 7665 2074 6172 6765 742e 0a0a  vative target...
+0001ed50: 2020 2020 5365 6520 416c 736f 0a20 2020      See Also.   
+0001ed60: 202d 2d2d 2d2d 2d2d 2d0a 2020 2020 3a63   --------.    :c
+0001ed70: 6c61 7373 3a60 5769 7468 4465 7269 7661  lass:`WithDeriva
+0001ed80: 7469 7665 6020 3a20 3a63 6c61 7373 3a60  tive` : :class:`
+0001ed90: 4172 7261 7960 2077 7261 7070 6572 2077  Array` wrapper w
+0001eda0: 6974 6820 6164 6469 7469 6f6e 616c 2064  ith additional d
+0001edb0: 6572 6976 6174 6976 650a 2020 2020 2727  erivative.    ''
+0001edc0: 270a 0a20 2020 2064 6566 205f 5f69 6e69  '..    def __ini
+0001edd0: 745f 5f28 7365 6c66 2c20 6964 656e 7469  t__(self, identi
+0001ede0: 6669 6572 2c20 7368 6170 6529 3a0a 2020  fier, shape):.  
+0001edf0: 2020 2020 2020 7365 6c66 2e69 6465 6e74        self.ident
+0001ee00: 6966 6965 7220 3d20 6964 656e 7469 6669  ifier = identifi
+0001ee10: 6572 0a20 2020 2020 2020 2073 7570 6572  er.        super
+0001ee20: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
+0001ee30: 3d28 292c 2073 6861 7065 3d73 6861 7065  =(), shape=shape
+0001ee40: 2c20 6474 7970 653d 666c 6f61 7429 0a0a  , dtype=float)..
+0001ee50: 2020 2020 6465 6620 6576 616c 6628 7365      def evalf(se
+0001ee60: 6c66 293a 0a20 2020 2020 2020 2072 6169  lf):.        rai
+0001ee70: 7365 2045 7863 6570 7469 6f6e 2827 7b7d  se Exception('{}
+0001ee80: 2063 616e 6e6f 7420 6265 2065 7661 6c75   cannot be evalu
+0001ee90: 6162 6c65 6427 2e66 6f72 6d61 7428 7479  abled'.format(ty
+0001eea0: 7065 2873 656c 6629 2e5f 5f6e 616d 655f  pe(self).__name_
+0001eeb0: 5f29 290a 0a0a 636c 6173 7320 5261 7665  _))...class Rave
+0001eec0: 6c28 4172 7261 7929 3a0a 0a20 2020 2064  l(Array):..    d
+0001eed0: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+0001eee0: 2c20 6675 6e63 3a20 4172 7261 7929 3a0a  , func: Array):.
+0001eef0: 2020 2020 2020 2020 6173 7365 7274 2069          assert i
+0001ef00: 7369 6e73 7461 6e63 6528 6675 6e63 2c20  sinstance(func, 
+0001ef10: 4172 7261 7929 2061 6e64 2066 756e 632e  Array) and func.
+0001ef20: 6e64 696d 203e 3d20 322c 2066 2766 756e  ndim >= 2, f'fun
+0001ef30: 633d 7b66 756e 6321 727d 270a 2020 2020  c={func!r}'.    
+0001ef40: 2020 2020 7365 6c66 2e66 756e 6320 3d20      self.func = 
+0001ef50: 6675 6e63 0a20 2020 2020 2020 2073 7570  func.        sup
+0001ef60: 6572 2829 2e5f 5f69 6e69 745f 5f28 6172  er().__init__(ar
+0001ef70: 6773 3d28 6675 6e63 2c29 2c20 7368 6170  gs=(func,), shap
+0001ef80: 653d 282a 6675 6e63 2e73 6861 7065 5b3a  e=(*func.shape[:
+0001ef90: 2d32 5d2c 2066 756e 632e 7368 6170 655b  -2], func.shape[
+0001efa0: 2d32 5d20 2a20 6675 6e63 2e73 6861 7065  -2] * func.shape
+0001efb0: 5b2d 315d 292c 2064 7479 7065 3d66 756e  [-1]), dtype=fun
+0001efc0: 632e 6474 7970 6529 0a0a 2020 2020 4063  c.dtype)..    @c
+0001efd0: 6163 6865 645f 7072 6f70 6572 7479 0a20  ached_property. 
+0001efe0: 2020 2064 6566 205f 696e 666c 6174 696f     def _inflatio
+0001eff0: 6e73 2873 656c 6629 3a0a 2020 2020 2020  ns(self):.      
+0001f000: 2020 696e 666c 6174 696f 6e73 203d 205b    inflations = [
+0001f010: 5d0a 2020 2020 2020 2020 7374 7269 6465  ].        stride
+0001f020: 203d 2073 656c 662e 6675 6e63 2e73 6861   = self.func.sha
+0001f030: 7065 5b2d 315d 0a20 2020 2020 2020 206e  pe[-1].        n
+0001f040: 203d 204e 6f6e 650a 2020 2020 2020 2020   = None.        
+0001f050: 666f 7220 6178 6973 2c20 6f6c 645f 7061  for axis, old_pa
+0001f060: 7274 7320 696e 2073 656c 662e 6675 6e63  rts in self.func
+0001f070: 2e5f 696e 666c 6174 696f 6e73 3a0a 2020  ._inflations:.  
+0001f080: 2020 2020 2020 2020 2020 6966 2061 7869            if axi
+0001f090: 7320 3d3d 2073 656c 662e 6e64 696d 202d  s == self.ndim -
+0001f0a0: 2031 2061 6e64 206e 2069 7320 4e6f 6e65   1 and n is None
+0001f0b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001f0c0: 2020 6e20 3d20 7365 6c66 2e66 756e 632e    n = self.func.
+0001f0d0: 7368 6170 655b 2d31 5d0a 2020 2020 2020  shape[-1].      
+0001f0e0: 2020 2020 2020 2020 2020 696e 666c 6174            inflat
+0001f0f0: 696f 6e73 2e61 7070 656e 6428 2873 656c  ions.append((sel
+0001f100: 662e 6e64 696d 202d 2031 2c20 7479 7065  f.ndim - 1, type
+0001f110: 732e 6672 6f7a 656e 6469 6374 2828 5261  s.frozendict((Ra
+0001f120: 7665 6c49 6e64 6578 2864 6f66 6d61 702c  velIndex(dofmap,
+0001f130: 2052 616e 6765 286e 292c 202a 7365 6c66   Range(n), *self
+0001f140: 2e66 756e 632e 7368 6170 655b 2d32 3a5d  .func.shape[-2:]
+0001f150: 292c 2066 756e 6329 2066 6f72 2064 6f66  ), func) for dof
+0001f160: 6d61 702c 2066 756e 6320 696e 206f 6c64  map, func in old
+0001f170: 5f70 6172 7473 2e69 7465 6d73 2829 2929  _parts.items()))
+0001f180: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
+0001f190: 6966 2061 7869 7320 3d3d 2073 656c 662e  if axis == self.
+0001f1a0: 6e64 696d 2061 6e64 206e 2069 7320 4e6f  ndim and n is No
+0001f1b0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+0001f1c0: 2020 2020 6e20 3d20 7365 6c66 2e66 756e      n = self.fun
+0001f1d0: 632e 7368 6170 655b 2d32 5d0a 2020 2020  c.shape[-2].    
+0001f1e0: 2020 2020 2020 2020 2020 2020 696e 666c              infl
+0001f1f0: 6174 696f 6e73 2e61 7070 656e 6428 2873  ations.append((s
+0001f200: 656c 662e 6e64 696d 202d 2031 2c20 7479  elf.ndim - 1, ty
+0001f210: 7065 732e 6672 6f7a 656e 6469 6374 2828  pes.frozendict((
+0001f220: 5261 7665 6c49 6e64 6578 2852 616e 6765  RavelIndex(Range
+0001f230: 286e 292c 2064 6f66 6d61 702c 202a 7365  (n), dofmap, *se
+0001f240: 6c66 2e66 756e 632e 7368 6170 655b 2d32  lf.func.shape[-2
+0001f250: 3a5d 292c 2066 756e 6329 2066 6f72 2064  :]), func) for d
+0001f260: 6f66 6d61 702c 2066 756e 6320 696e 206f  ofmap, func in o
+0001f270: 6c64 5f70 6172 7473 2e69 7465 6d73 2829  ld_parts.items()
+0001f280: 2929 290a 2020 2020 2020 2020 2020 2020  ))).            
+0001f290: 656c 6966 2061 7869 7320 3c20 7365 6c66  elif axis < self
+0001f2a0: 2e6e 6469 6d20 2d20 313a 0a20 2020 2020  .ndim - 1:.     
+0001f2b0: 2020 2020 2020 2020 2020 2069 6e66 6c61             infla
+0001f2c0: 7469 6f6e 732e 6170 7065 6e64 2828 6178  tions.append((ax
+0001f2d0: 6973 2c20 7479 7065 732e 6672 6f7a 656e  is, types.frozen
+0001f2e0: 6469 6374 2828 646f 666d 6170 2c20 5261  dict((dofmap, Ra
+0001f2f0: 7665 6c28 6675 6e63 2929 2066 6f72 2064  vel(func)) for d
+0001f300: 6f66 6d61 702c 2066 756e 6320 696e 206f  ofmap, func in o
+0001f310: 6c64 5f70 6172 7473 2e69 7465 6d73 2829  ld_parts.items()
+0001f320: 2929 290a 2020 2020 2020 2020 7265 7475  ))).        retu
+0001f330: 726e 2074 7570 6c65 2869 6e66 6c61 7469  rn tuple(inflati
+0001f340: 6f6e 7329 0a0a 2020 2020 6465 6620 5f73  ons)..    def _s
+0001f350: 696d 706c 6966 6965 6428 7365 6c66 293a  implified(self):
+0001f360: 0a20 2020 2020 2020 2069 6620 5f65 7175  .        if _equ
+0001f370: 616c 735f 7363 616c 6172 5f63 6f6e 7374  als_scalar_const
+0001f380: 616e 7428 7365 6c66 2e66 756e 632e 7368  ant(self.func.sh
+0001f390: 6170 655b 2d32 5d2c 2031 293a 0a20 2020  ape[-2], 1):.   
+0001f3a0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001f3b0: 6765 7428 7365 6c66 2e66 756e 632c 202d  get(self.func, -
+0001f3c0: 322c 2063 6f6e 7374 616e 7428 3029 290a  2, constant(0)).
+0001f3d0: 2020 2020 2020 2020 6966 205f 6571 7561          if _equa
+0001f3e0: 6c73 5f73 6361 6c61 725f 636f 6e73 7461  ls_scalar_consta
+0001f3f0: 6e74 2873 656c 662e 6675 6e63 2e73 6861  nt(self.func.sha
+0001f400: 7065 5b2d 315d 2c20 3129 3a0a 2020 2020  pe[-1], 1):.    
+0001f410: 2020 2020 2020 2020 7265 7475 726e 2067          return g
+0001f420: 6574 2873 656c 662e 6675 6e63 2c20 2d31  et(self.func, -1
+0001f430: 2c20 636f 6e73 7461 6e74 2830 2929 0a20  , constant(0)). 
+0001f440: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0001f450: 6c66 2e66 756e 632e 5f72 6176 656c 2873  lf.func._ravel(s
+0001f460: 656c 662e 6e64 696d 2d31 290a 0a20 2020  elf.ndim-1)..   
+0001f470: 2040 7374 6174 6963 6d65 7468 6f64 0a20   @staticmethod. 
+0001f480: 2020 2064 6566 2065 7661 6c66 2866 293a     def evalf(f):
+0001f490: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001f4a0: 662e 7265 7368 6170 6528 662e 7368 6170  f.reshape(f.shap
+0001f4b0: 655b 3a2d 325d 202b 2028 662e 7368 6170  e[:-2] + (f.shap
+0001f4c0: 655b 2d32 5d2a 662e 7368 6170 655b 2d31  e[-2]*f.shape[-1
+0001f4d0: 5d2c 2929 0a0a 2020 2020 6465 6620 5f6d  ],))..    def _m
+0001f4e0: 756c 7469 706c 7928 7365 6c66 2c20 6f74  ultiply(self, ot
+0001f4f0: 6865 7229 3a0a 2020 2020 2020 2020 6966  her):.        if
+0001f500: 2069 7369 6e73 7461 6e63 6528 6f74 6865   isinstance(othe
+0001f510: 722c 2052 6176 656c 2920 616e 6420 6571  r, Ravel) and eq
+0001f520: 7561 6c73 6861 7065 286f 7468 6572 2e66  ualshape(other.f
+0001f530: 756e 632e 7368 6170 655b 2d32 3a5d 2c20  unc.shape[-2:], 
+0001f540: 7365 6c66 2e66 756e 632e 7368 6170 655b  self.func.shape[
+0001f550: 2d32 3a5d 293a 0a20 2020 2020 2020 2020  -2:]):.         
+0001f560: 2020 2072 6574 7572 6e20 5261 7665 6c28     return Ravel(
+0001f570: 6d75 6c74 6970 6c79 2873 656c 662e 6675  multiply(self.fu
+0001f580: 6e63 2c20 6f74 6865 722e 6675 6e63 2929  nc, other.func))
+0001f590: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001f5a0: 5261 7665 6c28 6d75 6c74 6970 6c79 2873  Ravel(multiply(s
+0001f5b0: 656c 662e 6675 6e63 2c20 556e 7261 7665  elf.func, Unrave
+0001f5c0: 6c28 6f74 6865 722c 202a 7365 6c66 2e66  l(other, *self.f
+0001f5d0: 756e 632e 7368 6170 655b 2d32 3a5d 2929  unc.shape[-2:]))
+0001f5e0: 290a 0a20 2020 2064 6566 205f 6164 6428  )..    def _add(
+0001f5f0: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
+0001f600: 2020 2020 2020 7265 7475 726e 2052 6176        return Rav
+0001f610: 656c 2873 656c 662e 6675 6e63 202b 2055  el(self.func + U
+0001f620: 6e72 6176 656c 286f 7468 6572 2c20 2a73  nravel(other, *s
+0001f630: 656c 662e 6675 6e63 2e73 6861 7065 5b2d  elf.func.shape[-
+0001f640: 323a 5d29 290a 0a20 2020 2064 6566 205f  2:]))..    def _
+0001f650: 7375 6d28 7365 6c66 2c20 6178 6973 293a  sum(self, axis):
+0001f660: 0a20 2020 2020 2020 2069 6620 6178 6973  .        if axis
+0001f670: 203d 3d20 7365 6c66 2e6e 6469 6d2d 313a   == self.ndim-1:
+0001f680: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0001f690: 7572 6e20 5375 6d28 5375 6d28 7365 6c66  urn Sum(Sum(self
+0001f6a0: 2e66 756e 6329 290a 2020 2020 2020 2020  .func)).        
+0001f6b0: 7265 7475 726e 2052 6176 656c 2873 756d  return Ravel(sum
+0001f6c0: 2873 656c 662e 6675 6e63 2c20 6178 6973  (self.func, axis
+0001f6d0: 2929 0a0a 2020 2020 6465 6620 5f64 6572  ))..    def _der
+0001f6e0: 6976 6174 6976 6528 7365 6c66 2c20 7661  ivative(self, va
+0001f6f0: 722c 2073 6565 6e29 3a0a 2020 2020 2020  r, seen):.      
+0001f700: 2020 7265 7475 726e 2072 6176 656c 2864    return ravel(d
+0001f710: 6572 6976 6174 6976 6528 7365 6c66 2e66  erivative(self.f
+0001f720: 756e 632c 2076 6172 2c20 7365 656e 292c  unc, var, seen),
+0001f730: 2061 7869 733d 7365 6c66 2e6e 6469 6d2d   axis=self.ndim-
+0001f740: 3129 0a0a 2020 2020 6465 6620 5f74 616b  1)..    def _tak
+0001f750: 6564 6961 6728 7365 6c66 2c20 6178 6973  ediag(self, axis
+0001f760: 312c 2061 7869 7332 293a 0a20 2020 2020  1, axis2):.     
+0001f770: 2020 2061 7373 6572 7420 6178 6973 3120     assert axis1 
+0001f780: 3c20 6178 6973 320a 2020 2020 2020 2020  < axis2.        
+0001f790: 6966 2061 7869 7332 203c 3d20 7365 6c66  if axis2 <= self
+0001f7a0: 2e6e 6469 6d2d 323a 0a20 2020 2020 2020  .ndim-2:.       
+0001f7b0: 2020 2020 2072 6574 7572 6e20 7261 7665       return rave
+0001f7c0: 6c28 5f74 616b 6564 6961 6728 7365 6c66  l(_takediag(self
+0001f7d0: 2e66 756e 632c 2061 7869 7331 2c20 6178  .func, axis1, ax
+0001f7e0: 6973 3229 2c20 7365 6c66 2e6e 6469 6d2d  is2), self.ndim-
+0001f7f0: 3329 0a20 2020 2020 2020 2065 6c73 653a  3).        else:
+0001f800: 0a20 2020 2020 2020 2020 2020 2075 6e72  .            unr
+0001f810: 6176 656c 6564 203d 2075 6e72 6176 656c  aveled = unravel
+0001f820: 2873 656c 662e 6675 6e63 2c20 6178 6973  (self.func, axis
+0001f830: 312c 2073 656c 662e 6675 6e63 2e73 6861  1, self.func.sha
+0001f840: 7065 5b2d 323a 5d29 0a20 2020 2020 2020  pe[-2:]).       
+0001f850: 2020 2020 2072 6574 7572 6e20 5261 7665       return Rave
+0001f860: 6c28 5f74 616b 6564 6961 6728 5f74 616b  l(_takediag(_tak
+0001f870: 6564 6961 6728 756e 7261 7665 6c65 642c  ediag(unraveled,
+0001f880: 2061 7869 7331 2c20 2d32 292c 2061 7869   axis1, -2), axi
+0001f890: 7331 2c20 2d32 2929 0a0a 2020 2020 6465  s1, -2))..    de
+0001f8a0: 6620 5f74 616b 6528 7365 6c66 2c20 696e  f _take(self, in
+0001f8b0: 6465 782c 2061 7869 7329 3a0a 2020 2020  dex, axis):.    
+0001f8c0: 2020 2020 6966 2061 7869 7320 213d 2073      if axis != s
+0001f8d0: 656c 662e 6e64 696d 2d31 3a0a 2020 2020  elf.ndim-1:.    
+0001f8e0: 2020 2020 2020 2020 7265 7475 726e 2052          return R
+0001f8f0: 6176 656c 285f 7461 6b65 2873 656c 662e  avel(_take(self.
+0001f900: 6675 6e63 2c20 696e 6465 782c 2061 7869  func, index, axi
+0001f910: 7329 290a 0a20 2020 2064 6566 205f 7274  s))..    def _rt
+0001f920: 616b 6528 7365 6c66 2c20 6675 6e63 2c20  ake(self, func, 
+0001f930: 6178 6973 293a 0a20 2020 2020 2020 2069  axis):.        i
+0001f940: 6620 7365 6c66 2e6e 6469 6d20 3d3d 2031  f self.ndim == 1
+0001f950: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0001f960: 7475 726e 2052 6176 656c 2854 616b 6528  turn Ravel(Take(
+0001f970: 6675 6e63 2c20 7365 6c66 2e66 756e 6329  func, self.func)
+0001f980: 290a 0a20 2020 2064 6566 205f 756e 7261  )..    def _unra
+0001f990: 7665 6c28 7365 6c66 2c20 6178 6973 2c20  vel(self, axis, 
+0001f9a0: 7368 6170 6529 3a0a 2020 2020 2020 2020  shape):.        
+0001f9b0: 6966 2061 7869 7320 213d 2073 656c 662e  if axis != self.
+0001f9c0: 6e64 696d 2d31 3a0a 2020 2020 2020 2020  ndim-1:.        
+0001f9d0: 2020 2020 7265 7475 726e 2052 6176 656c      return Ravel
+0001f9e0: 2875 6e72 6176 656c 2873 656c 662e 6675  (unravel(self.fu
+0001f9f0: 6e63 2c20 6178 6973 2c20 7368 6170 6529  nc, axis, shape)
+0001fa00: 290a 2020 2020 2020 2020 656c 6966 2065  ).        elif e
+0001fa10: 7175 616c 7368 6170 6528 7368 6170 652c  qualshape(shape,
+0001fa20: 2073 656c 662e 6675 6e63 2e73 6861 7065   self.func.shape
+0001fa30: 5b2d 323a 5d29 3a0a 2020 2020 2020 2020  [-2:]):.        
+0001fa40: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0001fa50: 6675 6e63 0a0a 2020 2020 6465 6620 5f69  func..    def _i
+0001fa60: 6e66 6c61 7465 2873 656c 662c 2064 6f66  nflate(self, dof
+0001fa70: 6d61 702c 206c 656e 6774 682c 2061 7869  map, length, axi
+0001fa80: 7329 3a0a 2020 2020 2020 2020 6966 2061  s):.        if a
+0001fa90: 7869 7320 3c20 7365 6c66 2e6e 6469 6d2d  xis < self.ndim-
+0001faa0: 646f 666d 6170 2e6e 6469 6d3a 0a20 2020  dofmap.ndim:.   
+0001fab0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001fac0: 5261 7665 6c28 5f69 6e66 6c61 7465 2873  Ravel(_inflate(s
+0001fad0: 656c 662e 6675 6e63 2c20 646f 666d 6170  elf.func, dofmap
+0001fae0: 2c20 6c65 6e67 7468 2c20 6178 6973 2929  , length, axis))
+0001faf0: 0a20 2020 2020 2020 2065 6c69 6620 646f  .        elif do
+0001fb00: 666d 6170 2e6e 6469 6d20 3d3d 2030 3a0a  fmap.ndim == 0:.
+0001fb10: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0001fb20: 726e 2072 6176 656c 2849 6e66 6c61 7465  rn ravel(Inflate
+0001fb30: 2873 656c 662e 6675 6e63 2c20 646f 666d  (self.func, dofm
+0001fb40: 6170 2c20 6c65 6e67 7468 292c 2073 656c  ap, length), sel
+0001fb50: 662e 6e64 696d 2d31 290a 2020 2020 2020  f.ndim-1).      
+0001fb60: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0001fb70: 2020 2020 7265 7475 726e 205f 696e 666c      return _infl
+0001fb80: 6174 6528 7365 6c66 2e66 756e 632c 2055  ate(self.func, U
+0001fb90: 6e72 6176 656c 2864 6f66 6d61 702c 202a  nravel(dofmap, *
+0001fba0: 7365 6c66 2e66 756e 632e 7368 6170 655b  self.func.shape[
+0001fbb0: 2d32 3a5d 292c 206c 656e 6774 682c 2061  -2:]), length, a
+0001fbc0: 7869 7329 0a0a 2020 2020 6465 6620 5f64  xis)..    def _d
+0001fbd0: 6961 676f 6e61 6c69 7a65 2873 656c 662c  iagonalize(self,
+0001fbe0: 2061 7869 7329 3a0a 2020 2020 2020 2020   axis):.        
+0001fbf0: 6966 2061 7869 7320 213d 2073 656c 662e  if axis != self.
+0001fc00: 6e64 696d 2d31 3a0a 2020 2020 2020 2020  ndim-1:.        
+0001fc10: 2020 2020 7265 7475 726e 2072 6176 656c      return ravel
+0001fc20: 2864 6961 676f 6e61 6c69 7a65 2873 656c  (diagonalize(sel
+0001fc30: 662e 6675 6e63 2c20 6178 6973 292c 2073  f.func, axis), s
+0001fc40: 656c 662e 6e64 696d 2d31 290a 0a20 2020  elf.ndim-1)..   
+0001fc50: 2064 6566 205f 696e 7365 7274 6178 6973   def _insertaxis
+0001fc60: 2873 656c 662c 2061 7869 732c 206c 656e  (self, axis, len
+0001fc70: 6774 6829 3a0a 2020 2020 2020 2020 7265  gth):.        re
+0001fc80: 7475 726e 2072 6176 656c 2869 6e73 6572  turn ravel(inser
+0001fc90: 7461 7869 7328 7365 6c66 2e66 756e 632c  taxis(self.func,
+0001fca0: 2061 7869 732b 2861 7869 7320 3d3d 2073   axis+(axis == s
+0001fcb0: 656c 662e 6e64 696d 292c 206c 656e 6774  elf.ndim), lengt
+0001fcc0: 6829 2c20 7365 6c66 2e6e 6469 6d2d 2861  h), self.ndim-(a
+0001fcd0: 7869 7320 3d3d 2073 656c 662e 6e64 696d  xis == self.ndim
+0001fce0: 2929 0a0a 2020 2020 6465 6620 5f70 6f77  ))..    def _pow
+0001fcf0: 6572 2873 656c 662c 206e 293a 0a20 2020  er(self, n):.   
+0001fd00: 2020 2020 2072 6574 7572 6e20 5261 7665       return Rave
+0001fd10: 6c28 506f 7765 7228 7365 6c66 2e66 756e  l(Power(self.fun
+0001fd20: 632c 2055 6e72 6176 656c 286e 2c20 2a73  c, Unravel(n, *s
+0001fd30: 656c 662e 6675 6e63 2e73 6861 7065 5b2d  elf.func.shape[-
+0001fd40: 323a 5d29 2929 0a0a 2020 2020 6465 6620  2:])))..    def 
+0001fd50: 5f73 6967 6e28 7365 6c66 293a 0a20 2020  _sign(self):.   
+0001fd60: 2020 2020 2072 6574 7572 6e20 5261 7665       return Rave
+0001fd70: 6c28 5369 676e 2873 656c 662e 6675 6e63  l(Sign(self.func
+0001fd80: 2929 0a0a 2020 2020 6465 6620 5f70 726f  ))..    def _pro
+0001fd90: 6475 6374 2873 656c 6629 3a0a 2020 2020  duct(self):.    
+0001fda0: 2020 2020 7265 7475 726e 2050 726f 6475      return Produ
+0001fdb0: 6374 2850 726f 6475 6374 2873 656c 662e  ct(Product(self.
+0001fdc0: 6675 6e63 2929 0a0a 2020 2020 6465 6620  func))..    def 
+0001fdd0: 5f6c 6f6f 7073 756d 2873 656c 662c 2069  _loopsum(self, i
+0001fde0: 6e64 6578 293a 0a20 2020 2020 2020 2072  ndex):.        r
+0001fdf0: 6574 7572 6e20 5261 7665 6c28 6c6f 6f70  eturn Ravel(loop
+0001fe00: 5f73 756d 2873 656c 662e 6675 6e63 2c20  _sum(self.func, 
+0001fe10: 696e 6465 7829 290a 0a20 2020 2040 7072  index))..    @pr
+0001fe20: 6f70 6572 7479 0a20 2020 2064 6566 205f  operty.    def _
+0001fe30: 756e 616c 6967 6e65 6428 7365 6c66 293a  unaligned(self):
+0001fe40: 0a20 2020 2020 2020 2075 6e61 6c69 676e  .        unalign
+0001fe50: 6564 2c20 7768 6572 6520 3d20 756e 616c  ed, where = unal
+0001fe60: 6967 6e28 7365 6c66 2e66 756e 632c 206e  ign(self.func, n
+0001fe70: 6178 6573 3d73 656c 662e 6e64 696d 202d  axes=self.ndim -
+0001fe80: 2031 290a 2020 2020 2020 2020 7265 7475   1).        retu
+0001fe90: 726e 2052 6176 656c 2875 6e61 6c69 676e  rn Ravel(unalign
+0001fea0: 6564 292c 2028 2a77 6865 7265 2c20 7365  ed), (*where, se
+0001feb0: 6c66 2e6e 6469 6d20 2d20 3129 0a0a 2020  lf.ndim - 1)..  
+0001fec0: 2020 4063 6163 6865 645f 7072 6f70 6572    @cached_proper
+0001fed0: 7479 0a20 2020 2064 6566 205f 6173 7370  ty.    def _assp
+0001fee0: 6172 7365 2873 656c 6629 3a0a 2020 2020  arse(self):.    
+0001fef0: 2020 2020 7265 7475 726e 2074 7570 6c65      return tuple
+0001ff00: 2828 2a69 6e64 6963 6573 5b3a 2d32 5d2c  ((*indices[:-2],
+0001ff10: 2069 6e64 6963 6573 5b2d 325d 2a73 656c   indices[-2]*sel
+0001ff20: 662e 6675 6e63 2e73 6861 7065 5b2d 315d  f.func.shape[-1]
+0001ff30: 2b69 6e64 6963 6573 5b2d 315d 2c20 7661  +indices[-1], va
+0001ff40: 6c75 6573 2920 666f 7220 2a69 6e64 6963  lues) for *indic
+0001ff50: 6573 2c20 7661 6c75 6573 2069 6e20 7365  es, values in se
+0001ff60: 6c66 2e66 756e 632e 5f61 7373 7061 7273  lf.func._asspars
+0001ff70: 6529 0a0a 2020 2020 6465 6620 5f69 6e74  e)..    def _int
+0001ff80: 626f 756e 6473 5f69 6d70 6c28 7365 6c66  bounds_impl(self
+0001ff90: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0001ffa0: 6e20 7365 6c66 2e66 756e 632e 5f69 6e74  n self.func._int
+0001ffb0: 626f 756e 6473 5f69 6d70 6c28 290a 0a0a  bounds_impl()...
+0001ffc0: 636c 6173 7320 556e 7261 7665 6c28 4172  class Unravel(Ar
+0001ffd0: 7261 7929 3a0a 0a20 2020 2064 6566 205f  ray):..    def _
+0001ffe0: 5f69 6e69 745f 5f28 7365 6c66 2c20 6675  _init__(self, fu
+0001fff0: 6e63 3a20 4172 7261 792c 2073 6831 3a20  nc: Array, sh1: 
+00020000: 4172 7261 792c 2073 6832 3a20 4172 7261  Array, sh2: Arra
+00020010: 7929 3a0a 2020 2020 2020 2020 6173 7365  y):.        asse
+00020020: 7274 2069 7369 6e73 7461 6e63 6528 6675  rt isinstance(fu
+00020030: 6e63 2c20 4172 7261 7929 2061 6e64 2066  nc, Array) and f
+00020040: 756e 632e 6e64 696d 203e 2030 2c20 6627  unc.ndim > 0, f'
+00020050: 6675 6e63 3d7b 6675 6e63 2172 7d27 0a20  func={func!r}'. 
+00020060: 2020 2020 2020 2061 7373 6572 7420 5f69         assert _i
+00020070: 7369 6e64 6578 2873 6831 292c 2066 2773  sindex(sh1), f's
+00020080: 6831 3d7b 7368 3121 727d 270a 2020 2020  h1={sh1!r}'.    
+00020090: 2020 2020 6173 7365 7274 205f 6973 696e      assert _isin
+000200a0: 6465 7828 7368 3229 2c20 6627 7368 323d  dex(sh2), f'sh2=
+000200b0: 7b73 6832 2172 7d27 0a20 2020 2020 2020  {sh2!r}'.       
+000200c0: 2061 7373 6572 7420 5f65 7175 616c 735f   assert _equals_
+000200d0: 7369 6d70 6c69 6669 6564 2866 756e 632e  simplified(func.
+000200e0: 7368 6170 655b 2d31 5d2c 2073 6831 202a  shape[-1], sh1 *
+000200f0: 2073 6832 290a 2020 2020 2020 2020 7365   sh2).        se
+00020100: 6c66 2e66 756e 6320 3d20 6675 6e63 0a20  lf.func = func. 
+00020110: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+00020120: 5f69 6e69 745f 5f28 6172 6773 3d28 6675  _init__(args=(fu
+00020130: 6e63 2c20 7368 312c 2073 6832 292c 2073  nc, sh1, sh2), s
+00020140: 6861 7065 3d28 2a66 756e 632e 7368 6170  hape=(*func.shap
+00020150: 655b 3a2d 315d 2c20 7368 312c 2073 6832  e[:-1], sh1, sh2
+00020160: 292c 2064 7479 7065 3d66 756e 632e 6474  ), dtype=func.dt
+00020170: 7970 6529 0a0a 2020 2020 6465 6620 5f73  ype)..    def _s
+00020180: 696d 706c 6966 6965 6428 7365 6c66 293a  implified(self):
+00020190: 0a20 2020 2020 2020 2069 6620 5f65 7175  .        if _equ
+000201a0: 616c 735f 7363 616c 6172 5f63 6f6e 7374  als_scalar_const
+000201b0: 616e 7428 7365 6c66 2e73 6861 7065 5b2d  ant(self.shape[-
+000201c0: 325d 2c20 3129 3a0a 2020 2020 2020 2020  2], 1):.        
+000201d0: 2020 2020 7265 7475 726e 2069 6e73 6572      return inser
+000201e0: 7461 7869 7328 7365 6c66 2e66 756e 632c  taxis(self.func,
+000201f0: 2073 656c 662e 6e64 696d 2d32 2c20 636f   self.ndim-2, co
+00020200: 6e73 7461 6e74 2831 2929 0a20 2020 2020  nstant(1)).     
+00020210: 2020 2069 6620 5f65 7175 616c 735f 7363     if _equals_sc
+00020220: 616c 6172 5f63 6f6e 7374 616e 7428 7365  alar_constant(se
+00020230: 6c66 2e73 6861 7065 5b2d 315d 2c20 3129  lf.shape[-1], 1)
+00020240: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00020250: 7475 726e 2069 6e73 6572 7461 7869 7328  turn insertaxis(
+00020260: 7365 6c66 2e66 756e 632c 2073 656c 662e  self.func, self.
+00020270: 6e64 696d 2d31 2c20 636f 6e73 7461 6e74  ndim-1, constant
+00020280: 2831 2929 0a20 2020 2020 2020 2072 6574  (1)).        ret
+00020290: 7572 6e20 7365 6c66 2e66 756e 632e 5f75  urn self.func._u
+000202a0: 6e72 6176 656c 2873 656c 662e 6e64 696d  nravel(self.ndim
+000202b0: 2d32 2c20 7365 6c66 2e73 6861 7065 5b2d  -2, self.shape[-
+000202c0: 323a 5d29 0a0a 2020 2020 6465 6620 5f64  2:])..    def _d
+000202d0: 6572 6976 6174 6976 6528 7365 6c66 2c20  erivative(self, 
+000202e0: 7661 722c 2073 6565 6e29 3a0a 2020 2020  var, seen):.    
+000202f0: 2020 2020 7265 7475 726e 2075 6e72 6176      return unrav
+00020300: 656c 2864 6572 6976 6174 6976 6528 7365  el(derivative(se
+00020310: 6c66 2e66 756e 632c 2076 6172 2c20 7365  lf.func, var, se
+00020320: 656e 292c 2061 7869 733d 7365 6c66 2e6e  en), axis=self.n
+00020330: 6469 6d2d 322c 2073 6861 7065 3d73 656c  dim-2, shape=sel
+00020340: 662e 7368 6170 655b 2d32 3a5d 290a 0a20  f.shape[-2:]).. 
+00020350: 2020 2040 7374 6174 6963 6d65 7468 6f64     @staticmethod
+00020360: 0a20 2020 2064 6566 2065 7661 6c66 2866  .    def evalf(f
+00020370: 2c20 7368 312c 2073 6832 293a 0a20 2020  , sh1, sh2):.   
+00020380: 2020 2020 2072 6574 7572 6e20 662e 7265       return f.re
+00020390: 7368 6170 6528 662e 7368 6170 655b 3a2d  shape(f.shape[:-
+000203a0: 315d 202b 2028 7368 312c 2073 6832 2929  1] + (sh1, sh2))
+000203b0: 0a0a 2020 2020 6465 6620 5f74 616b 6564  ..    def _taked
+000203c0: 6961 6728 7365 6c66 2c20 6178 6973 312c  iag(self, axis1,
+000203d0: 2061 7869 7332 293a 0a20 2020 2020 2020   axis2):.       
+000203e0: 2069 6620 6178 6973 3220 3c20 7365 6c66   if axis2 < self
+000203f0: 2e6e 6469 6d2d 323a 0a20 2020 2020 2020  .ndim-2:.       
+00020400: 2020 2020 2072 6574 7572 6e20 756e 7261       return unra
+00020410: 7665 6c28 5f74 616b 6564 6961 6728 7365  vel(_takediag(se
+00020420: 6c66 2e66 756e 632c 2061 7869 7331 2c20  lf.func, axis1, 
+00020430: 6178 6973 3229 2c20 7365 6c66 2e6e 6469  axis2), self.ndi
+00020440: 6d2d 342c 2073 656c 662e 7368 6170 655b  m-4, self.shape[
+00020450: 2d32 3a5d 290a 0a20 2020 2064 6566 205f  -2:])..    def _
+00020460: 7461 6b65 2873 656c 662c 2069 6e64 6578  take(self, index
+00020470: 2c20 6178 6973 293a 0a20 2020 2020 2020  , axis):.       
+00020480: 2069 6620 6178 6973 203c 2073 656c 662e   if axis < self.
+00020490: 6e64 696d 202d 2032 3a0a 2020 2020 2020  ndim - 2:.      
+000204a0: 2020 2020 2020 7265 7475 726e 2055 6e72        return Unr
+000204b0: 6176 656c 285f 7461 6b65 2873 656c 662e  avel(_take(self.
+000204c0: 6675 6e63 2c20 696e 6465 782c 2061 7869  func, index, axi
+000204d0: 7329 2c20 2a73 656c 662e 7368 6170 655b  s), *self.shape[
+000204e0: 2d32 3a5d 290a 0a20 2020 2064 6566 205f  -2:])..    def _
+000204f0: 7375 6d28 7365 6c66 2c20 6178 6973 293a  sum(self, axis):
+00020500: 0a20 2020 2020 2020 2069 6620 6178 6973  .        if axis
+00020510: 203c 2073 656c 662e 6e64 696d 202d 2032   < self.ndim - 2
+00020520: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00020530: 7475 726e 2055 6e72 6176 656c 2873 756d  turn Unravel(sum
+00020540: 2873 656c 662e 6675 6e63 2c20 6178 6973  (self.func, axis
+00020550: 292c 202a 7365 6c66 2e73 6861 7065 5b2d  ), *self.shape[-
+00020560: 323a 5d29 0a0a 2020 2020 4063 6163 6865  2:])..    @cache
+00020570: 645f 7072 6f70 6572 7479 0a20 2020 2064  d_property.    d
+00020580: 6566 205f 6173 7370 6172 7365 2873 656c  ef _assparse(sel
+00020590: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+000205a0: 726e 2074 7570 6c65 2828 2a69 6e64 6963  rn tuple((*indic
+000205b0: 6573 5b3a 2d31 5d2c 202a 6469 766d 6f64  es[:-1], *divmod
+000205c0: 2869 6e64 6963 6573 5b2d 315d 2c20 6170  (indices[-1], ap
+000205d0: 7065 6e64 6178 6573 2873 656c 662e 7368  pendaxes(self.sh
+000205e0: 6170 655b 2d31 5d2c 2076 616c 7565 732e  ape[-1], values.
+000205f0: 7368 6170 6529 292c 2076 616c 7565 7329  shape)), values)
+00020600: 2066 6f72 202a 696e 6469 6365 732c 2076   for *indices, v
+00020610: 616c 7565 7320 696e 2073 656c 662e 6675  alues in self.fu
+00020620: 6e63 2e5f 6173 7370 6172 7365 290a 0a0a  nc._assparse)...
+00020630: 636c 6173 7320 5261 7665 6c49 6e64 6578  class RavelIndex
+00020640: 2841 7272 6179 293a 0a0a 2020 2020 6465  (Array):..    de
+00020650: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
+00020660: 2069 613a 2041 7272 6179 2c20 6962 3a20   ia: Array, ib: 
+00020670: 4172 7261 792c 206e 613a 2041 7272 6179  Array, na: Array
+00020680: 2c20 6e62 3a20 4172 7261 7929 3a0a 2020  , nb: Array):.  
+00020690: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+000206a0: 6e73 7461 6e63 6528 6961 2c20 4172 7261  nstance(ia, Arra
+000206b0: 7929 2c20 6627 6961 3d7b 6961 2172 7d27  y), f'ia={ia!r}'
+000206c0: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+000206d0: 6973 696e 7374 616e 6365 2869 622c 2041  isinstance(ib, A
+000206e0: 7272 6179 292c 2066 2769 623d 7b69 6221  rray), f'ib={ib!
+000206f0: 727d 270a 2020 2020 2020 2020 6173 7365  r}'.        asse
+00020700: 7274 205f 6973 696e 6465 7828 6e61 292c  rt _isindex(na),
+00020710: 2066 276e 613d 7b6e 6121 727d 270a 2020   f'na={na!r}'.  
+00020720: 2020 2020 2020 6173 7365 7274 205f 6973        assert _is
+00020730: 696e 6465 7828 6e62 292c 2066 276e 623d  index(nb), f'nb=
+00020740: 7b6e 6221 727d 270a 2020 2020 2020 2020  {nb!r}'.        
+00020750: 7365 6c66 2e5f 6961 203d 2069 610a 2020  self._ia = ia.  
+00020760: 2020 2020 2020 7365 6c66 2e5f 6962 203d        self._ib =
+00020770: 2069 620a 2020 2020 2020 2020 7365 6c66   ib.        self
+00020780: 2e5f 6e61 203d 206e 610a 2020 2020 2020  ._na = na.      
+00020790: 2020 7365 6c66 2e5f 6e62 203d 206e 620a    self._nb = nb.
+000207a0: 2020 2020 2020 2020 7365 6c66 2e5f 6c65          self._le
+000207b0: 6e67 7468 203d 206e 6120 2a20 6e62 0a20  ngth = na * nb. 
+000207c0: 2020 2020 2020 2073 7570 6572 2829 2e5f         super()._
+000207d0: 5f69 6e69 745f 5f28 6172 6773 3d28 6961  _init__(args=(ia
+000207e0: 2c20 6962 2c20 6e62 292c 2073 6861 7065  , ib, nb), shape
+000207f0: 3d69 612e 7368 6170 6520 2b20 6962 2e73  =ia.shape + ib.s
+00020800: 6861 7065 2c20 6474 7970 653d 696e 7429  hape, dtype=int)
+00020810: 0a0a 2020 2020 4073 7461 7469 636d 6574  ..    @staticmet
+00020820: 686f 640a 2020 2020 6465 6620 6576 616c  hod.    def eval
+00020830: 6628 6961 2c20 6962 2c20 6e62 293a 0a20  f(ia, ib, nb):. 
+00020840: 2020 2020 2020 2072 6574 7572 6e20 6961         return ia
+00020850: 5b28 2e2e 2e2c 292b 286e 756d 7079 2e6e  [(...,)+(numpy.n
+00020860: 6577 6178 6973 2c29 2a69 622e 6e64 696d  ewaxis,)*ib.ndim
+00020870: 5d20 2a20 6e62 202b 2069 620a 0a20 2020  ] * nb + ib..   
+00020880: 2064 6566 205f 7461 6b65 2873 656c 662c   def _take(self,
+00020890: 2069 6e64 6578 2c20 6178 6973 293a 0a20   index, axis):. 
+000208a0: 2020 2020 2020 2069 6620 6178 6973 203c         if axis <
+000208b0: 2073 656c 662e 5f69 612e 6e64 696d 3a0a   self._ia.ndim:.
+000208c0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000208d0: 726e 2052 6176 656c 496e 6465 7828 5f74  rn RavelIndex(_t
+000208e0: 616b 6528 7365 6c66 2e5f 6961 2c20 696e  ake(self._ia, in
+000208f0: 6465 782c 2061 7869 7329 2c20 7365 6c66  dex, axis), self
+00020900: 2e5f 6962 2c20 7365 6c66 2e5f 6e61 2c20  ._ib, self._na, 
+00020910: 7365 6c66 2e5f 6e62 290a 2020 2020 2020  self._nb).      
+00020920: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00020930: 2020 2020 7265 7475 726e 2052 6176 656c      return Ravel
+00020940: 496e 6465 7828 7365 6c66 2e5f 6961 2c20  Index(self._ia, 
+00020950: 5f74 616b 6528 7365 6c66 2e5f 6962 2c20  _take(self._ib, 
+00020960: 696e 6465 782c 2061 7869 7320 2d20 7365  index, axis - se
+00020970: 6c66 2e5f 6961 2e6e 6469 6d29 2c20 7365  lf._ia.ndim), se
+00020980: 6c66 2e5f 6e61 2c20 7365 6c66 2e5f 6e62  lf._na, self._nb
+00020990: 290a 0a20 2020 2064 6566 205f 7274 616b  )..    def _rtak
+000209a0: 6528 7365 6c66 2c20 6675 6e63 2c20 6178  e(self, func, ax
+000209b0: 6973 293a 0a20 2020 2020 2020 2069 6620  is):.        if 
+000209c0: 5f65 7175 616c 735f 7369 6d70 6c69 6669  _equals_simplifi
+000209d0: 6564 2866 756e 632e 7368 6170 655b 6178  ed(func.shape[ax
+000209e0: 6973 5d2c 2073 656c 662e 5f6c 656e 6774  is], self._lengt
+000209f0: 6829 3a0a 2020 2020 2020 2020 2020 2020  h):.            
+00020a00: 7265 7475 726e 205f 7461 6b65 285f 7461  return _take(_ta
+00020a10: 6b65 2875 6e72 6176 656c 2866 756e 632c  ke(unravel(func,
+00020a20: 2061 7869 732c 2028 7365 6c66 2e5f 6e61   axis, (self._na
+00020a30: 2c20 7365 6c66 2e5f 6e62 2929 2c20 7365  , self._nb)), se
+00020a40: 6c66 2e5f 6962 2c20 6178 6973 2b31 292c  lf._ib, axis+1),
+00020a50: 2073 656c 662e 5f69 612c 2061 7869 7329   self._ia, axis)
+00020a60: 0a0a 2020 2020 6465 6620 5f72 696e 666c  ..    def _rinfl
+00020a70: 6174 6528 7365 6c66 2c20 6675 6e63 2c20  ate(self, func, 
+00020a80: 6c65 6e67 7468 2c20 6178 6973 293a 0a20  length, axis):. 
+00020a90: 2020 2020 2020 2069 6620 5f65 7175 616c         if _equal
+00020aa0: 735f 7369 6d70 6c69 6669 6564 286c 656e  s_simplified(len
+00020ab0: 6774 682c 2073 656c 662e 5f6c 656e 6774  gth, self._lengt
+00020ac0: 6829 3a0a 2020 2020 2020 2020 2020 2020  h):.            
+00020ad0: 7265 7475 726e 2052 6176 656c 2849 6e66  return Ravel(Inf
+00020ae0: 6c61 7465 285f 696e 666c 6174 6528 6675  late(_inflate(fu
+00020af0: 6e63 2c20 7365 6c66 2e5f 6961 2c20 7365  nc, self._ia, se
+00020b00: 6c66 2e5f 6e61 2c20 6675 6e63 2e6e 6469  lf._na, func.ndi
+00020b10: 6d20 2d20 7365 6c66 2e6e 6469 6d29 2c20  m - self.ndim), 
+00020b20: 7365 6c66 2e5f 6962 2c20 7365 6c66 2e5f  self._ib, self._
+00020b30: 6e62 2929 0a0a 2020 2020 6465 6620 5f75  nb))..    def _u
+00020b40: 6e72 6176 656c 2873 656c 662c 2061 7869  nravel(self, axi
+00020b50: 732c 2073 6861 7065 293a 0a20 2020 2020  s, shape):.     
+00020b60: 2020 2069 6620 6178 6973 203c 2073 656c     if axis < sel
+00020b70: 662e 5f69 612e 6e64 696d 3a0a 2020 2020  f._ia.ndim:.    
+00020b80: 2020 2020 2020 2020 7265 7475 726e 2052          return R
+00020b90: 6176 656c 496e 6465 7828 756e 7261 7665  avelIndex(unrave
+00020ba0: 6c28 7365 6c66 2e5f 6961 2c20 6178 6973  l(self._ia, axis
+00020bb0: 2c20 7368 6170 6529 2c20 7365 6c66 2e5f  , shape), self._
+00020bc0: 6962 2c20 7365 6c66 2e5f 6e61 2c20 7365  ib, self._na, se
+00020bd0: 6c66 2e5f 6e62 290a 2020 2020 2020 2020  lf._nb).        
+00020be0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00020bf0: 2020 7265 7475 726e 2052 6176 656c 496e    return RavelIn
+00020c00: 6465 7828 7365 6c66 2e5f 6961 2c20 756e  dex(self._ia, un
+00020c10: 7261 7665 6c28 7365 6c66 2e5f 6962 2c20  ravel(self._ib, 
+00020c20: 6178 6973 2d73 656c 662e 5f69 612e 6e64  axis-self._ia.nd
+00020c30: 696d 2c20 7368 6170 6529 2c20 7365 6c66  im, shape), self
+00020c40: 2e5f 6e61 2c20 7365 6c66 2e5f 6e62 290a  ._na, self._nb).
+00020c50: 0a20 2020 2064 6566 205f 696e 7462 6f75  .    def _intbou
+00020c60: 6e64 735f 696d 706c 2873 656c 6629 3a0a  nds_impl(self):.
+00020c70: 2020 2020 2020 2020 6e62 6d69 6e2c 206e          nbmin, n
+00020c80: 626d 6178 203d 2073 656c 662e 5f6e 622e  bmax = self._nb.
+00020c90: 5f69 6e74 626f 756e 6473 0a20 2020 2020  _intbounds.     
+00020ca0: 2020 2069 616d 696e 2c20 6961 6d61 7820     iamin, iamax 
+00020cb0: 3d20 7365 6c66 2e5f 6961 2e5f 696e 7462  = self._ia._intb
+00020cc0: 6f75 6e64 730a 2020 2020 2020 2020 6962  ounds.        ib
+00020cd0: 6d69 6e2c 2069 626d 6178 203d 2073 656c  min, ibmax = sel
+00020ce0: 662e 5f69 622e 5f69 6e74 626f 756e 6473  f._ib._intbounds
+00020cf0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00020d00: 6961 6d69 6e20 2a20 6e62 6d69 6e20 2b20  iamin * nbmin + 
+00020d10: 6962 6d69 6e2c 2028 6961 6d61 7820 616e  ibmin, (iamax an
+00020d20: 6420 6e62 6d61 7820 616e 6420 6961 6d61  d nbmax and iama
+00020d30: 7820 2a20 6e62 6d61 7829 202b 2069 626d  x * nbmax) + ibm
+00020d40: 6178 0a0a 0a63 6c61 7373 2052 616e 6765  ax...class Range
+00020d50: 2841 7272 6179 293a 0a0a 2020 2020 6465  (Array):..    de
+00020d60: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
+00020d70: 206c 656e 6774 683a 2041 7272 6179 293a   length: Array):
+00020d80: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+00020d90: 5f69 7369 6e64 6578 286c 656e 6774 6829  _isindex(length)
+00020da0: 2c20 6627 6c65 6e67 7468 3d7b 6c65 6e67  , f'length={leng
+00020db0: 7468 2172 7d27 0a20 2020 2020 2020 2073  th!r}'.        s
+00020dc0: 656c 662e 6c65 6e67 7468 203d 206c 656e  elf.length = len
+00020dd0: 6774 680a 2020 2020 2020 2020 7375 7065  gth.        supe
+00020de0: 7228 292e 5f5f 696e 6974 5f5f 2861 7267  r().__init__(arg
+00020df0: 733d 286c 656e 6774 682c 292c 2073 6861  s=(length,), sha
+00020e00: 7065 3d28 6c65 6e67 7468 2c29 2c20 6474  pe=(length,), dt
+00020e10: 7970 653d 696e 7429 0a0a 2020 2020 6465  ype=int)..    de
+00020e20: 6620 5f74 616b 6528 7365 6c66 2c20 696e  f _take(self, in
+00020e30: 6465 782c 2061 7869 7329 3a0a 2020 2020  dex, axis):.    
+00020e40: 2020 2020 7265 7475 726e 2049 6e52 616e      return InRan
+00020e50: 6765 2869 6e64 6578 2c20 7365 6c66 2e6c  ge(index, self.l
+00020e60: 656e 6774 6829 0a0a 2020 2020 6465 6620  ength)..    def 
+00020e70: 5f75 6e72 6176 656c 2873 656c 662c 2061  _unravel(self, a
+00020e80: 7869 732c 2073 6861 7065 293a 0a20 2020  xis, shape):.   
+00020e90: 2020 2020 2069 6620 6c65 6e28 7368 6170       if len(shap
+00020ea0: 6529 203d 3d20 323a 0a20 2020 2020 2020  e) == 2:.       
+00020eb0: 2020 2020 2072 6574 7572 6e20 5261 7665       return Rave
+00020ec0: 6c49 6e64 6578 2852 616e 6765 2873 6861  lIndex(Range(sha
+00020ed0: 7065 5b30 5d29 2c20 5261 6e67 6528 7368  pe[0]), Range(sh
+00020ee0: 6170 655b 315d 292c 2073 6861 7065 5b30  ape[1]), shape[0
+00020ef0: 5d2c 2073 6861 7065 5b31 5d29 0a0a 2020  ], shape[1])..  
+00020f00: 2020 6465 6620 5f72 7461 6b65 2873 656c    def _rtake(sel
+00020f10: 662c 2066 756e 632c 2061 7869 7329 3a0a  f, func, axis):.
+00020f20: 2020 2020 2020 2020 6966 205f 6571 7561          if _equa
+00020f30: 6c73 5f73 696d 706c 6966 6965 6428 7365  ls_simplified(se
+00020f40: 6c66 2e6c 656e 6774 682c 2066 756e 632e  lf.length, func.
+00020f50: 7368 6170 655b 6178 6973 5d29 3a0a 2020  shape[axis]):.  
+00020f60: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00020f70: 2066 756e 630a 0a20 2020 2064 6566 205f   func..    def _
+00020f80: 7269 6e66 6c61 7465 2873 656c 662c 2066  rinflate(self, f
+00020f90: 756e 632c 206c 656e 6774 682c 2061 7869  unc, length, axi
+00020fa0: 7329 3a0a 2020 2020 2020 2020 6966 206c  s):.        if l
+00020fb0: 656e 6774 6820 3d3d 2073 656c 662e 6c65  ength == self.le
+00020fc0: 6e67 7468 3a0a 2020 2020 2020 2020 2020  ngth:.          
+00020fd0: 2020 7265 7475 726e 2066 756e 630a 0a20    return func.. 
+00020fe0: 2020 2065 7661 6c66 203d 2073 7461 7469     evalf = stati
+00020ff0: 636d 6574 686f 6428 6e75 6d70 792e 6172  cmethod(numpy.ar
+00021000: 616e 6765 290a 0a20 2020 2064 6566 205f  ange)..    def _
+00021010: 696e 7462 6f75 6e64 735f 696d 706c 2873  intbounds_impl(s
+00021020: 656c 6629 3a0a 2020 2020 2020 2020 6c6f  elf):.        lo
+00021030: 7765 722c 2075 7070 6572 203d 2073 656c  wer, upper = sel
+00021040: 662e 6c65 6e67 7468 2e5f 696e 7462 6f75  f.length._intbou
+00021050: 6e64 730a 2020 2020 2020 2020 6173 7365  nds.        asse
+00021060: 7274 206c 6f77 6572 203e 3d20 300a 2020  rt lower >= 0.  
+00021070: 2020 2020 2020 7265 7475 726e 2030 2c20        return 0, 
+00021080: 6d61 7828 302c 2075 7070 6572 202d 2031  max(0, upper - 1
+00021090: 290a 0a0a 636c 6173 7320 496e 5261 6e67  )...class InRang
+000210a0: 6528 4172 7261 7929 3a0a 0a20 2020 2064  e(Array):..    d
+000210b0: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+000210c0: 2c20 696e 6465 783a 2041 7272 6179 2c20  , index: Array, 
+000210d0: 6c65 6e67 7468 3a20 4172 7261 7929 3a0a  length: Array):.
+000210e0: 2020 2020 2020 2020 6173 7365 7274 2069          assert i
+000210f0: 7369 6e73 7461 6e63 6528 696e 6465 782c  sinstance(index,
+00021100: 2041 7272 6179 2920 616e 6420 696e 6465   Array) and inde
+00021110: 782e 6474 7970 6520 3d3d 2069 6e74 2c20  x.dtype == int, 
+00021120: 6627 696e 6465 783d 7b69 6e64 6578 2172  f'index={index!r
+00021130: 7d27 0a20 2020 2020 2020 2061 7373 6572  }'.        asser
+00021140: 7420 6973 696e 7374 616e 6365 286c 656e  t isinstance(len
+00021150: 6774 682c 2041 7272 6179 2920 616e 6420  gth, Array) and 
+00021160: 6c65 6e67 7468 2e64 7479 7065 203d 3d20  length.dtype == 
+00021170: 696e 7420 616e 6420 6c65 6e67 7468 2e6e  int and length.n
+00021180: 6469 6d20 3d3d 2030 2c20 6627 6c65 6e67  dim == 0, f'leng
+00021190: 7468 3d7b 6c65 6e67 7468 2172 7d27 0a20  th={length!r}'. 
+000211a0: 2020 2020 2020 2073 656c 662e 696e 6465         self.inde
+000211b0: 7820 3d20 696e 6465 780a 2020 2020 2020  x = index.      
+000211c0: 2020 7365 6c66 2e6c 656e 6774 6820 3d20    self.length = 
+000211d0: 6c65 6e67 7468 0a20 2020 2020 2020 2073  length.        s
+000211e0: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
+000211f0: 6172 6773 3d28 696e 6465 782c 206c 656e  args=(index, len
+00021200: 6774 6829 2c20 7368 6170 653d 696e 6465  gth), shape=inde
+00021210: 782e 7368 6170 652c 2064 7479 7065 3d69  x.shape, dtype=i
+00021220: 6e74 290a 0a20 2020 2040 7374 6174 6963  nt)..    @static
+00021230: 6d65 7468 6f64 0a20 2020 2064 6566 2065  method.    def e
+00021240: 7661 6c66 2869 6e64 6578 2c20 6c65 6e67  valf(index, leng
+00021250: 7468 293a 0a20 2020 2020 2020 2061 7373  th):.        ass
+00021260: 6572 7420 696e 6465 782e 7369 7a65 203d  ert index.size =
+00021270: 3d20 3020 6f72 2030 203c 3d20 696e 6465  = 0 or 0 <= inde
+00021280: 782e 6d69 6e28 2920 616e 6420 696e 6465  x.min() and inde
+00021290: 782e 6d61 7828 2920 3c20 6c65 6e67 7468  x.max() < length
+000212a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000212b0: 696e 6465 780a 0a20 2020 2064 6566 205f  index..    def _
+000212c0: 7369 6d70 6c69 6669 6564 2873 656c 6629  simplified(self)
+000212d0: 3a0a 2020 2020 2020 2020 6c6f 7765 725f  :.        lower_
+000212e0: 6c65 6e67 7468 2c20 7570 7065 725f 6c65  length, upper_le
+000212f0: 6e67 7468 203d 2073 656c 662e 6c65 6e67  ngth = self.leng
+00021300: 7468 2e5f 696e 7462 6f75 6e64 730a 2020  th._intbounds.  
+00021310: 2020 2020 2020 6c6f 7765 725f 696e 6465        lower_inde
+00021320: 782c 2075 7070 6572 5f69 6e64 6578 203d  x, upper_index =
+00021330: 2073 656c 662e 696e 6465 782e 5f69 6e74   self.index._int
+00021340: 626f 756e 6473 0a20 2020 2020 2020 2069  bounds.        i
+00021350: 6620 3020 3c3d 206c 6f77 6572 5f69 6e64  f 0 <= lower_ind
+00021360: 6578 203c 3d20 7570 7065 725f 696e 6465  ex <= upper_inde
+00021370: 7820 3c20 6c6f 7765 725f 6c65 6e67 7468  x < lower_length
+00021380: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00021390: 7475 726e 2073 656c 662e 696e 6465 780a  turn self.index.
+000213a0: 0a20 2020 2064 6566 205f 696e 7462 6f75  .    def _intbou
+000213b0: 6e64 735f 696d 706c 2873 656c 6629 3a0a  nds_impl(self):.
+000213c0: 2020 2020 2020 2020 6c6f 7765 725f 696e          lower_in
+000213d0: 6465 782c 2075 7070 6572 5f69 6e64 6578  dex, upper_index
+000213e0: 203d 2073 656c 662e 696e 6465 782e 5f69   = self.index._i
+000213f0: 6e74 626f 756e 6473 0a20 2020 2020 2020  ntbounds.       
+00021400: 206c 6f77 6572 5f6c 656e 6774 682c 2075   lower_length, u
+00021410: 7070 6572 5f6c 656e 6774 6820 3d20 7365  pper_length = se
+00021420: 6c66 2e6c 656e 6774 682e 5f69 6e74 626f  lf.length._intbo
+00021430: 756e 6473 0a20 2020 2020 2020 2075 7070  unds.        upp
+00021440: 6572 203d 206d 696e 2875 7070 6572 5f69  er = min(upper_i
+00021450: 6e64 6578 2c20 6d61 7828 302c 2075 7070  ndex, max(0, upp
+00021460: 6572 5f6c 656e 6774 6820 2d20 3129 290a  er_length - 1)).
+00021470: 2020 2020 2020 2020 7265 7475 726e 206d          return m
+00021480: 6178 2830 2c20 6d69 6e28 6c6f 7765 725f  ax(0, min(lower_
+00021490: 696e 6465 782c 2075 7070 6572 2929 2c20  index, upper)), 
+000214a0: 7570 7065 720a 0a0a 636c 6173 7320 506f  upper...class Po
+000214b0: 6c79 7661 6c28 4172 7261 7929 3a0a 2020  lyval(Array):.  
+000214c0: 2020 2727 2745 7661 6c75 6174 6520 6120    '''Evaluate a 
+000214d0: 706f 6c79 6e6f 6d69 616c 0a0a 2020 2020  polynomial..    
+000214e0: 5468 6520 706f 6c79 6e6f 6d69 616c 7320  The polynomials 
+000214f0: 6172 6520 6f66 2074 6865 2066 6f72 6d0a  are of the form.
+00021500: 0a20 2020 202e 2e20 6d61 7468 3a3a 20ce  .    .. math:: .
+00021510: a35f 7b6b 20e2 8888 20e2 84a4 5e6e 207c  ._{k ... ...^n |
+00021520: 20ce a35f 6920 6b5f 6920 e289 a420 707d   .._i k_i ... p}
+00021530: 2063 5f6b 20e2 888f 5f69 2078 5f69 5e28   c_k ..._i x_i^(
+00021540: 6b5f 6929 0a0a 2020 2020 7768 6572 6520  k_i)..    where 
+00021550: 3a6d 6174 683a 6063 6020 6973 2061 2076  :math:`c` is a v
+00021560: 6563 746f 7220 6f66 2063 6f65 6666 6963  ector of coeffic
+00021570: 6965 6e74 732c 203a 6d61 7468 3a60 7860  ients, :math:`x`
+00021580: 2061 2076 6563 746f 7220 6f66 0a20 2020   a vector of.   
+00021590: 203a 6d61 7468 3a60 6e60 2076 6172 6961   :math:`n` varia
+000215a0: 626c 6573 2061 6e64 203a 6d61 7468 3a60  bles and :math:`
+000215b0: 7060 2061 206e 6f6e 6e65 6761 7469 7665  p` a nonnegative
+000215c0: 2069 6e74 6567 6572 2064 6567 7265 652e   integer degree.
+000215d0: 2054 6865 0a20 2020 2063 6f65 6666 6963   The.    coeffic
+000215e0: 6965 6e74 7320 6172 6520 6173 7375 6d65  ients are assume
+000215f0: 6420 746f 2062 6520 696e 2072 6576 6572  d to be in rever
+00021600: 7365 205b 6c65 7869 636f 6772 6170 6869  se [lexicographi
+00021610: 6320 6f72 6465 725d 3a20 7468 650a 2020  c order]: the.  
+00021620: 2020 636f 6566 6669 6369 656e 7420 666f    coefficient fo
+00021630: 7220 706f 7765 7273 203a 6d61 7468 3a60  r powers :math:`
+00021640: 6a20 e288 8820 e284 a45e 6e60 2063 6f6d  j ... ...^n` com
+00021650: 6573 2062 6566 6f72 6520 7468 6520 636f  es before the co
+00021660: 6566 6669 6369 656e 7420 666f 720a 2020  efficient for.  
+00021670: 2020 706f 7765 7273 203a 6d61 7468 3a60    powers :math:`
+00021680: 6b20 e288 8820 e284 a45e 6e20 2f20 7b6a  k ... ...^n / {j
+00021690: 7d60 2069 6666 203a 6d61 7468 3a60 6a5f  }` iff :math:`j_
+000216a0: 6920 3e20 6b5f 6960 2c20 7768 6572 6520  i > k_i`, where 
+000216b0: 3a6d 6174 683a 6069 203d 0a20 2020 206d  :math:`i =.    m
+000216c0: 6178 5f6c 286a 5f6c 20e2 89a0 206b 5f6c  ax_l(j_l ... k_l
+000216d0: 2960 2c20 7468 6520 696e 6465 7820 6f66  )`, the index of
+000216e0: 2074 6865 202a 6c61 7374 2a20 6e6f 6e2d   the *last* non-
+000216f0: 6d61 7463 6869 6e67 2070 6f77 6572 2e0a  matching power..
+00021700: 0a20 2020 2041 7267 730a 2020 2020 2d2d  .    Args.    --
+00021710: 2d2d 0a20 2020 2063 6f65 6666 7320 3a20  --.    coeffs : 
+00021720: 3a63 6c61 7373 3a60 4172 7261 7960 0a20  :class:`Array`. 
+00021730: 2020 2020 2020 2041 7272 6179 206f 6620         Array of 
+00021740: 636f 6566 6669 6369 656e 7473 2077 6865  coefficients whe
+00021750: 7265 2074 6865 206c 6173 7420 6178 6973  re the last axis
+00021760: 2069 7320 7472 6561 7465 6420 6173 2074   is treated as t
+00021770: 6865 0a20 2020 2020 2020 2063 6f65 6666  he.        coeff
+00021780: 6963 6965 6e74 7320 6178 6573 2e20 416c  icients axes. Al
+00021790: 6c20 7265 6d61 696e 696e 6720 6178 6573  l remaining axes
+000217a0: 2061 7265 2074 7265 6174 6564 2070 6f69   are treated poi
+000217b0: 6e74 7769 7365 2e0a 2020 2020 706f 696e  ntwise..    poin
+000217c0: 7473 203a 203a 636c 6173 733a 6041 7272  ts : :class:`Arr
+000217d0: 6179 600a 2020 2020 2020 2020 4172 7261  ay`.        Arra
+000217e0: 7920 6f66 2076 616c 7565 7320 7768 6572  y of values wher
+000217f0: 6520 7468 6520 6c61 7374 2061 7869 7320  e the last axis 
+00021800: 6973 2074 7265 6174 6564 2061 7320 7468  is treated as th
+00021810: 6520 7661 7269 6162 6c65 7320 6178 6973  e variables axis
+00021820: 2e0a 2020 2020 2020 2020 416c 6c20 7265  ..        All re
+00021830: 6d61 696e 696e 6720 6178 6573 2061 7265  maining axes are
+00021840: 2074 7265 6174 6564 2070 6f69 6e74 7769   treated pointwi
+00021850: 7365 2e0a 2020 2020 2727 270a 0a20 2020  se..    '''..   
+00021860: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
+00021870: 6c66 2c20 636f 6566 6673 3a20 4172 7261  lf, coeffs: Arra
+00021880: 792c 2070 6f69 6e74 733a 2041 7272 6179  y, points: Array
+00021890: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+000218a0: 7420 6973 696e 7374 616e 6365 2863 6f65  t isinstance(coe
+000218b0: 6666 732c 2041 7272 6179 2920 616e 6420  ffs, Array) and 
+000218c0: 636f 6566 6673 2e64 7479 7065 203d 3d20  coeffs.dtype == 
+000218d0: 666c 6f61 7420 616e 6420 636f 6566 6673  float and coeffs
+000218e0: 2e6e 6469 6d20 3e3d 2031 2c20 6627 636f  .ndim >= 1, f'co
+000218f0: 6566 6673 3d7b 636f 6566 6673 2172 7d27  effs={coeffs!r}'
+00021900: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+00021910: 6973 696e 7374 616e 6365 2870 6f69 6e74  isinstance(point
+00021920: 732c 2041 7272 6179 2920 616e 6420 706f  s, Array) and po
+00021930: 696e 7473 2e64 7479 7065 203d 3d20 666c  ints.dtype == fl
+00021940: 6f61 7420 616e 6420 706f 696e 7473 2e6e  oat and points.n
+00021950: 6469 6d20 3e3d 2031 2061 6e64 2070 6f69  dim >= 1 and poi
+00021960: 6e74 732e 7368 6170 655b 2d31 5d2e 6973  nts.shape[-1].is
+00021970: 636f 6e73 7461 6e74 2c20 6627 706f 696e  constant, f'poin
+00021980: 7473 3d7b 706f 696e 7473 2172 7d27 0a20  ts={points!r}'. 
+00021990: 2020 2020 2020 2073 656c 662e 706f 696e         self.poin
+000219a0: 7473 5f6e 6469 6d20 3d20 696e 7428 706f  ts_ndim = int(po
+000219b0: 696e 7473 2e73 6861 7065 5b2d 315d 290a  ints.shape[-1]).
+000219c0: 2020 2020 2020 2020 7365 6c66 2e63 6f65          self.coe
+000219d0: 6666 7320 3d20 636f 6566 6673 0a20 2020  ffs = coeffs.   
+000219e0: 2020 2020 2073 656c 662e 706f 696e 7473       self.points
+000219f0: 203d 2070 6f69 6e74 730a 2020 2020 2020   = points.      
+00021a00: 2020 7375 7065 7228 292e 5f5f 696e 6974    super().__init
+00021a10: 5f5f 2861 7267 733d 2863 6f65 6666 732c  __(args=(coeffs,
+00021a20: 2070 6f69 6e74 7329 2c20 7368 6170 653d   points), shape=
+00021a30: 706f 696e 7473 2e73 6861 7065 5b3a 2d31  points.shape[:-1
+00021a40: 5d2b 636f 6566 6673 2e73 6861 7065 5b3a  ]+coeffs.shape[:
+00021a50: 2d31 5d2c 2064 7479 7065 3d66 6c6f 6174  -1], dtype=float
+00021a60: 290a 0a20 2020 2065 7661 6c66 203d 2073  )..    evalf = s
+00021a70: 7461 7469 636d 6574 686f 6428 706f 6c79  taticmethod(poly
+00021a80: 2e65 7661 6c5f 6f75 7465 7229 0a0a 2020  .eval_outer)..  
+00021a90: 2020 6465 6620 5f64 6572 6976 6174 6976    def _derivativ
+00021aa0: 6528 7365 6c66 2c20 7661 722c 2073 6565  e(self, var, see
+00021ab0: 6e29 3a0a 2020 2020 2020 2020 6966 2073  n):.        if s
+00021ac0: 656c 662e 6474 7970 6520 3d3d 2063 6f6d  elf.dtype == com
+00021ad0: 706c 6578 3a0a 2020 2020 2020 2020 2020  plex:.          
+00021ae0: 2020 7261 6973 6520 4e6f 7449 6d70 6c65    raise NotImple
+00021af0: 6d65 6e74 6564 4572 726f 7228 2754 6865  mentedError('The
+00021b00: 2063 6f6d 706c 6578 2064 6572 6976 6174   complex derivat
+00021b10: 6976 6520 6973 206e 6f74 2069 6d70 6c65  ive is not imple
+00021b20: 6d65 6e74 6564 2e27 290a 2020 2020 2020  mented.').      
+00021b30: 2020 6470 6f69 6e74 7320 3d20 6569 6e73    dpoints = eins
+00021b40: 756d 2827 4142 692c 4169 442d 3e41 4244  um('ABi,AiD->ABD
+00021b50: 272c 2050 6f6c 7976 616c 2850 6f6c 7947  ', Polyval(PolyG
+00021b60: 7261 6428 7365 6c66 2e63 6f65 6666 732c  rad(self.coeffs,
+00021b70: 2073 656c 662e 706f 696e 7473 5f6e 6469   self.points_ndi
+00021b80: 6d29 2c20 7365 6c66 2e70 6f69 6e74 7329  m), self.points)
+00021b90: 2c20 6465 7269 7661 7469 7665 2873 656c  , derivative(sel
+00021ba0: 662e 706f 696e 7473 2c20 7661 722c 2073  f.points, var, s
+00021bb0: 6565 6e29 2c20 413d 7365 6c66 2e70 6f69  een), A=self.poi
+00021bc0: 6e74 732e 6e64 696d 2d31 290a 2020 2020  nts.ndim-1).    
+00021bd0: 2020 2020 6463 6f65 6666 7320 3d20 5472      dcoeffs = Tr
+00021be0: 616e 7370 6f73 652e 6672 6f6d 5f65 6e64  anspose.from_end
+00021bf0: 2850 6f6c 7976 616c 2854 7261 6e73 706f  (Polyval(Transpo
+00021c00: 7365 2e74 6f5f 656e 6428 6465 7269 7661  se.to_end(deriva
+00021c10: 7469 7665 2873 656c 662e 636f 6566 6673  tive(self.coeffs
+00021c20: 2c20 7661 722c 2073 6565 6e29 2c20 2a72  , var, seen), *r
+00021c30: 616e 6765 2873 656c 662e 636f 6566 6673  ange(self.coeffs
+00021c40: 2e6e 6469 6d29 292c 2073 656c 662e 706f  .ndim)), self.po
+00021c50: 696e 7473 292c 202a 7261 6e67 6528 7365  ints), *range(se
+00021c60: 6c66 2e70 6f69 6e74 732e 6e64 696d 2d31  lf.points.ndim-1
+00021c70: 2c20 7365 6c66 2e6e 6469 6d29 290a 2020  , self.ndim)).  
+00021c80: 2020 2020 2020 7265 7475 726e 2064 706f        return dpo
+00021c90: 696e 7473 202b 2064 636f 6566 6673 0a0a  ints + dcoeffs..
+00021ca0: 2020 2020 6465 6620 5f74 616b 6528 7365      def _take(se
+00021cb0: 6c66 2c20 696e 6465 782c 2061 7869 7329  lf, index, axis)
+00021cc0: 3a0a 2020 2020 2020 2020 6966 2061 7869  :.        if axi
+00021cd0: 7320 3c20 7365 6c66 2e70 6f69 6e74 732e  s < self.points.
+00021ce0: 6e64 696d 202d 2031 3a0a 2020 2020 2020  ndim - 1:.      
+00021cf0: 2020 2020 2020 7265 7475 726e 2050 6f6c        return Pol
+00021d00: 7976 616c 2873 656c 662e 636f 6566 6673  yval(self.coeffs
+00021d10: 2c20 5f74 616b 6528 7365 6c66 2e70 6f69  , _take(self.poi
+00021d20: 6e74 732c 2069 6e64 6578 2c20 6178 6973  nts, index, axis
+00021d30: 2929 0a20 2020 2020 2020 2065 6c69 6620  )).        elif 
+00021d40: 6178 6973 203c 2073 656c 662e 6e64 696d  axis < self.ndim
+00021d50: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00021d60: 7475 726e 2050 6f6c 7976 616c 285f 7461  turn Polyval(_ta
+00021d70: 6b65 2873 656c 662e 636f 6566 6673 2c20  ke(self.coeffs, 
+00021d80: 696e 6465 782c 2061 7869 7320 2d20 7365  index, axis - se
+00021d90: 6c66 2e70 6f69 6e74 732e 6e64 696d 202b  lf.points.ndim +
+00021da0: 2031 292c 2073 656c 662e 706f 696e 7473   1), self.points
+00021db0: 290a 0a20 2020 2064 6566 205f 7369 6d70  )..    def _simp
+00021dc0: 6c69 6669 6564 2873 656c 6629 3a0a 2020  lified(self):.  
+00021dd0: 2020 2020 2020 6e63 6f65 6666 735f 6c6f        ncoeffs_lo
+00021de0: 7765 722c 206e 636f 6566 6673 5f75 7070  wer, ncoeffs_upp
+00021df0: 6572 203d 2073 656c 662e 636f 6566 6673  er = self.coeffs
+00021e00: 2e73 6861 7065 5b2d 315d 2e5f 696e 7462  .shape[-1]._intb
+00021e10: 6f75 6e64 730a 2020 2020 2020 2020 6966  ounds.        if
+00021e20: 2069 737a 6572 6f28 7365 6c66 2e63 6f65   iszero(self.coe
+00021e30: 6666 7329 3a0a 2020 2020 2020 2020 2020  ffs):.          
+00021e40: 2020 7265 7475 726e 207a 6572 6f73 5f6c    return zeros_l
+00021e50: 696b 6528 7365 6c66 290a 2020 2020 2020  ike(self).      
+00021e60: 2020 656c 6966 205f 6571 7561 6c73 5f73    elif _equals_s
+00021e70: 6361 6c61 725f 636f 6e73 7461 6e74 2873  calar_constant(s
+00021e80: 656c 662e 636f 6566 6673 2e73 6861 7065  elf.coeffs.shape
+00021e90: 5b2d 315d 2c20 3129 3a0a 2020 2020 2020  [-1], 1):.      
+00021ea0: 2020 2020 2020 7265 7475 726e 2070 7265        return pre
+00021eb0: 7065 6e64 6178 6573 2867 6574 2873 656c  pendaxes(get(sel
+00021ec0: 662e 636f 6566 6673 2c20 2d31 2c20 636f  f.coeffs, -1, co
+00021ed0: 6e73 7461 6e74 2830 2929 2c20 7365 6c66  nstant(0)), self
+00021ee0: 2e70 6f69 6e74 732e 7368 6170 655b 3a2d  .points.shape[:-
+00021ef0: 315d 290a 2020 2020 2020 2020 706f 696e  1]).        poin
+00021f00: 7473 2c20 7768 6572 655f 706f 696e 7473  ts, where_points
+00021f10: 203d 2075 6e61 6c69 676e 2873 656c 662e   = unalign(self.
+00021f20: 706f 696e 7473 2c20 6e61 7865 733d 7365  points, naxes=se
+00021f30: 6c66 2e70 6f69 6e74 732e 6e64 696d 202d  lf.points.ndim -
+00021f40: 2031 290a 2020 2020 2020 2020 636f 6566   1).        coef
+00021f50: 6673 2c20 7768 6572 655f 636f 6566 6673  fs, where_coeffs
+00021f60: 203d 2075 6e61 6c69 676e 2873 656c 662e   = unalign(self.
+00021f70: 636f 6566 6673 2c20 6e61 7865 733d 7365  coeffs, naxes=se
+00021f80: 6c66 2e63 6f65 6666 732e 6e64 696d 202d  lf.coeffs.ndim -
+00021f90: 2031 290a 2020 2020 2020 2020 6966 206c   1).        if l
+00021fa0: 656e 2877 6865 7265 5f70 6f69 6e74 7329  en(where_points)
+00021fb0: 202b 206c 656e 2877 6865 7265 5f63 6f65   + len(where_coe
+00021fc0: 6666 7329 203c 2073 656c 662e 6e64 696d  ffs) < self.ndim
+00021fd0: 3a0a 2020 2020 2020 2020 2020 2020 7768  :.            wh
+00021fe0: 6572 6520 3d20 2a77 6865 7265 5f70 6f69  ere = *where_poi
+00021ff0: 6e74 732c 202a 2861 7869 7320 2b20 7365  nts, *(axis + se
+00022000: 6c66 2e70 6f69 6e74 732e 6e64 696d 202d  lf.points.ndim -
+00022010: 2031 2066 6f72 2061 7869 7320 696e 2077   1 for axis in w
+00022020: 6865 7265 5f63 6f65 6666 7329 0a20 2020  here_coeffs).   
+00022030: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00022040: 616c 6967 6e28 506f 6c79 7661 6c28 636f  align(Polyval(co
+00022050: 6566 6673 2c20 706f 696e 7473 292c 2077  effs, points), w
+00022060: 6865 7265 2c20 7365 6c66 2e73 6861 7065  here, self.shape
+00022070: 290a 0a0a 636c 6173 7320 506f 6c79 4465  )...class PolyDe
+00022080: 6772 6565 2841 7272 6179 293a 0a20 2020  gree(Array):.   
+00022090: 2027 2727 5265 7475 726e 7320 7468 6520   '''Returns the 
+000220a0: 6465 6772 6565 206f 6620 6120 706f 6c79  degree of a poly
+000220b0: 6e6f 6d69 616c 2067 6976 656e 2074 6865  nomial given the
+000220c0: 206e 756d 6265 7220 6f66 2063 6f65 6666   number of coeff
+000220d0: 6963 6965 6e74 7320 616e 6420 6e75 6d62  icients and numb
+000220e0: 6572 206f 6620 7661 7269 6162 6c65 730a  er of variables.
+000220f0: 0a20 2020 2041 7267 730a 2020 2020 2d2d  .    Args.    --
+00022100: 2d2d 0a20 2020 206e 636f 6566 6673 203a  --.    ncoeffs :
+00022110: 203a 636c 6173 733a 6041 7272 6179 600a   :class:`Array`.
+00022120: 2020 2020 2020 2020 5468 6520 6e75 6d62          The numb
+00022130: 6572 206f 6620 636f 6566 6669 6369 656e  er of coefficien
+00022140: 7473 206f 6620 7468 6520 706f 6c79 6e6f  ts of the polyno
+00022150: 6d69 616c 2e0a 2020 2020 6e76 6172 7320  mial..    nvars 
+00022160: 3a20 3a63 6c61 7373 3a60 696e 7460 0a20  : :class:`int`. 
+00022170: 2020 2020 2020 2054 6865 206e 756d 6265         The numbe
+00022180: 7220 6f66 2076 6172 6961 626c 6573 206f  r of variables o
+00022190: 6620 7468 6520 706f 6c79 6e6f 6d69 616c  f the polynomial
+000221a0: 2e0a 0a20 2020 204e 6f74 6573 0a20 2020  ...    Notes.   
+000221b0: 202d 2d2d 2d2d 0a0a 2020 2020 5365 6520   -----..    See 
+000221c0: 3a63 6c61 7373 3a60 506f 6c79 7661 6c60  :class:`Polyval`
+000221d0: 2066 6f72 2061 2064 6566 696e 6974 696f   for a definitio
+000221e0: 6e20 6f66 2074 6865 2070 6f6c 796e 6f6d  n of the polynom
+000221f0: 6961 6c2e 0a20 2020 2027 2727 0a0a 2020  ial..    '''..  
+00022200: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+00022210: 656c 662c 206e 636f 6566 6673 3a20 4172  elf, ncoeffs: Ar
+00022220: 7261 792c 206e 7661 7273 3a20 696e 7429  ray, nvars: int)
+00022230: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
+00022240: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+00022250: 6e63 6528 6e63 6f65 6666 732c 2041 7272  nce(ncoeffs, Arr
+00022260: 6179 2920 616e 6420 6e63 6f65 6666 732e  ay) and ncoeffs.
+00022270: 6e64 696d 203d 3d20 3020 616e 6420 6e63  ndim == 0 and nc
+00022280: 6f65 6666 732e 6474 7970 6520 3d3d 2069  oeffs.dtype == i
+00022290: 6e74 2c20 276e 636f 6566 6673 3d7b 6e63  nt, 'ncoeffs={nc
+000222a0: 6f65 6666 7321 727d 270a 2020 2020 2020  oeffs!r}'.      
+000222b0: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+000222c0: 6e63 6528 6e76 6172 732c 2069 6e74 2920  nce(nvars, int) 
+000222d0: 616e 6420 6e76 6172 7320 3e3d 2030 2c20  and nvars >= 0, 
+000222e0: 276e 7661 7273 3d7b 6e76 6172 7321 727d  'nvars={nvars!r}
+000222f0: 270a 2020 2020 2020 2020 7365 6c66 2e6e  '.        self.n
+00022300: 636f 6566 6673 203d 206e 636f 6566 6673  coeffs = ncoeffs
+00022310: 0a20 2020 2020 2020 2073 656c 662e 6e76  .        self.nv
+00022320: 6172 7320 3d20 6e76 6172 730a 2020 2020  ars = nvars.    
+00022330: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
+00022340: 6974 5f5f 2861 7267 733d 286e 636f 6566  it__(args=(ncoef
+00022350: 6673 2c29 2c20 7368 6170 653d 2829 2c20  fs,), shape=(), 
+00022360: 6474 7970 653d 696e 7429 0a0a 2020 2020  dtype=int)..    
+00022370: 6465 6620 6576 616c 6628 7365 6c66 2c20  def evalf(self, 
+00022380: 6e63 6f65 6666 7329 3a0a 2020 2020 2020  ncoeffs):.      
+00022390: 2020 7265 7475 726e 206e 756d 7079 2e61    return numpy.a
+000223a0: 7272 6179 2870 6f6c 792e 6465 6772 6565  rray(poly.degree
+000223b0: 2873 656c 662e 6e76 6172 732c 206e 636f  (self.nvars, nco
+000223c0: 6566 6673 2e5f 5f69 6e64 6578 5f5f 2829  effs.__index__()
+000223d0: 2929 0a0a 2020 2020 6465 6620 5f69 6e74  ))..    def _int
+000223e0: 626f 756e 6473 5f69 6d70 6c28 7365 6c66  bounds_impl(self
+000223f0: 293a 0a20 2020 2020 2020 206c 6f77 6572  ):.        lower
+00022400: 2c20 7570 7065 7220 3d20 7365 6c66 2e6e  , upper = self.n
+00022410: 636f 6566 6673 2e5f 696e 7462 6f75 6e64  coeffs._intbound
+00022420: 730a 2020 2020 2020 2020 7472 793a 0a20  s.        try:. 
+00022430: 2020 2020 2020 2020 2020 206c 6f77 6572             lower
+00022440: 203d 2070 6f6c 792e 6465 6772 6565 2873   = poly.degree(s
+00022450: 656c 662e 6e76 6172 732c 206c 6f77 6572  elf.nvars, lower
+00022460: 290a 2020 2020 2020 2020 6578 6365 7074  ).        except
+00022470: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
+00022480: 7765 7220 3d20 300a 2020 2020 2020 2020  wer = 0.        
+00022490: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
+000224a0: 2075 7070 6572 203d 2070 6f6c 792e 6465   upper = poly.de
+000224b0: 6772 6565 2873 656c 662e 6e76 6172 732c  gree(self.nvars,
+000224c0: 2075 7070 6572 290a 2020 2020 2020 2020   upper).        
+000224d0: 6578 6365 7074 3a0a 2020 2020 2020 2020  except:.        
+000224e0: 2020 2020 7570 7065 7220 3d20 666c 6f61      upper = floa
+000224f0: 7428 2769 6e66 2729 0a20 2020 2020 2020  t('inf').       
+00022500: 2072 6574 7572 6e20 6c6f 7765 722c 2075   return lower, u
+00022510: 7070 6572 0a0a 0a63 6c61 7373 2050 6f6c  pper...class Pol
+00022520: 794e 436f 6566 6673 2841 7272 6179 293a  yNCoeffs(Array):
+00022530: 0a20 2020 2027 2727 5265 7475 726e 7320  .    '''Returns 
+00022540: 7468 6520 6e75 6d62 6572 206f 6620 636f  the number of co
+00022550: 6566 6669 6369 656e 7473 2066 6f72 2061  efficients for a
+00022560: 2070 6f6c 796e 6f6d 6961 6c20 6f66 2067   polynomial of g
+00022570: 6976 656e 2064 6567 7265 6520 616e 6420  iven degree and 
+00022580: 6e75 6d62 6572 206f 6620 7661 7269 6162  number of variab
+00022590: 6c65 730a 0a20 2020 2041 7267 730a 2020  les..    Args.  
+000225a0: 2020 2d2d 2d2d 0a20 2020 206e 7661 7273    ----.    nvars
+000225b0: 203a 203a 636c 6173 733a 6069 6e74 600a   : :class:`int`.
+000225c0: 2020 2020 2020 2020 5468 6520 6e75 6d62          The numb
+000225d0: 6572 206f 6620 7661 7269 6162 6c65 7320  er of variables 
+000225e0: 6f66 2074 6865 2070 6f6c 796e 6f6d 6961  of the polynomia
+000225f0: 6c2e 0a20 2020 2064 6567 7265 6520 3a20  l..    degree : 
+00022600: 3a63 6c61 7373 3a60 4172 7261 7960 0a20  :class:`Array`. 
+00022610: 2020 2020 2020 2054 6865 2064 6567 7265         The degre
+00022620: 6520 6f66 2074 6865 2070 6f6c 796e 6f6d  e of the polynom
+00022630: 6961 6c2e 0a0a 2020 2020 4e6f 7465 730a  ial...    Notes.
+00022640: 2020 2020 2d2d 2d2d 2d0a 0a20 2020 2053      -----..    S
+00022650: 6565 203a 636c 6173 733a 6050 6f6c 7976  ee :class:`Polyv
+00022660: 616c 6020 666f 7220 6120 6465 6669 6e69  al` for a defini
+00022670: 7469 6f6e 206f 6620 7468 6520 706f 6c79  tion of the poly
+00022680: 6e6f 6d69 616c 2e0a 2020 2020 2727 270a  nomial..    '''.
+00022690: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+000226a0: 5f28 7365 6c66 2c20 6e76 6172 733a 2069  _(self, nvars: i
+000226b0: 6e74 2c20 6465 6772 6565 3a20 4172 7261  nt, degree: Arra
+000226c0: 7929 202d 3e20 4e6f 6e65 3a0a 2020 2020  y) -> None:.    
+000226d0: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
+000226e0: 7461 6e63 6528 6465 6772 6565 2c20 4172  tance(degree, Ar
+000226f0: 7261 7929 2061 6e64 2064 6567 7265 652e  ray) and degree.
+00022700: 6e64 696d 203d 3d20 3020 616e 6420 6465  ndim == 0 and de
+00022710: 6772 6565 2e64 7479 7065 203d 3d20 696e  gree.dtype == in
+00022720: 742c 2066 2764 6567 7265 653d 7b64 6567  t, f'degree={deg
+00022730: 7265 6521 727d 270a 2020 2020 2020 2020  ree!r}'.        
+00022740: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+00022750: 6528 6e76 6172 732c 2069 6e74 2920 616e  e(nvars, int) an
+00022760: 6420 6e76 6172 7320 3e3d 2030 2c20 276e  d nvars >= 0, 'n
+00022770: 7661 7273 3d7b 6e76 6172 7321 727d 270a  vars={nvars!r}'.
+00022780: 2020 2020 2020 2020 7365 6c66 2e6e 7661          self.nva
+00022790: 7273 203d 206e 7661 7273 0a20 2020 2020  rs = nvars.     
+000227a0: 2020 2073 656c 662e 6465 6772 6565 203d     self.degree =
+000227b0: 2064 6567 7265 650a 2020 2020 2020 2020   degree.        
+000227c0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+000227d0: 2861 7267 733d 2864 6567 7265 652c 292c  (args=(degree,),
+000227e0: 2073 6861 7065 3d28 292c 2064 7479 7065   shape=(), dtype
+000227f0: 3d69 6e74 290a 0a20 2020 2064 6566 2065  =int)..    def e
+00022800: 7661 6c66 2873 656c 662c 2064 6567 7265  valf(self, degre
+00022810: 6529 3a0a 2020 2020 2020 2020 7265 7475  e):.        retu
+00022820: 726e 206e 756d 7079 2e61 7272 6179 2870  rn numpy.array(p
+00022830: 6f6c 792e 6e63 6f65 6666 7328 7365 6c66  oly.ncoeffs(self
+00022840: 2e6e 7661 7273 2c20 6465 6772 6565 2e5f  .nvars, degree._
+00022850: 5f69 6e64 6578 5f5f 2829 2929 0a0a 2020  _index__()))..  
+00022860: 2020 6465 6620 5f69 6e74 626f 756e 6473    def _intbounds
+00022870: 5f69 6d70 6c28 7365 6c66 293a 0a20 2020  _impl(self):.   
+00022880: 2020 2020 206c 6f77 6572 2c20 7570 7065       lower, uppe
+00022890: 7220 3d20 7365 6c66 2e64 6567 7265 652e  r = self.degree.
+000228a0: 5f69 6e74 626f 756e 6473 0a20 2020 2020  _intbounds.     
+000228b0: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+000228c0: 286c 6f77 6572 2c20 696e 7429 2061 6e64  (lower, int) and
+000228d0: 206c 6f77 6572 203e 3d20 303a 0a20 2020   lower >= 0:.   
+000228e0: 2020 2020 2020 2020 206c 6f77 6572 203d           lower =
+000228f0: 2070 6f6c 792e 6e63 6f65 6666 7328 7365   poly.ncoeffs(se
+00022900: 6c66 2e6e 7661 7273 2c20 6c6f 7765 7229  lf.nvars, lower)
+00022910: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00022920: 2020 2020 2020 2020 2020 206c 6f77 6572             lower
+00022930: 203d 2030 0a20 2020 2020 2020 2069 6620   = 0.        if 
+00022940: 6973 696e 7374 616e 6365 2875 7070 6572  isinstance(upper
+00022950: 2c20 696e 7429 2061 6e64 2075 7070 6572  , int) and upper
+00022960: 203e 3d20 303a 0a20 2020 2020 2020 2020   >= 0:.         
+00022970: 2020 2075 7070 6572 203d 2070 6f6c 792e     upper = poly.
+00022980: 6e63 6f65 6666 7328 7365 6c66 2e6e 7661  ncoeffs(self.nva
+00022990: 7273 2c20 7570 7065 7229 0a20 2020 2020  rs, upper).     
+000229a0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000229b0: 2020 2020 2075 7070 6572 203d 2066 6c6f       upper = flo
+000229c0: 6174 2827 696e 6627 290a 2020 2020 2020  at('inf').      
+000229d0: 2020 7265 7475 726e 206c 6f77 6572 2c20    return lower, 
+000229e0: 7570 7065 720a 0a0a 636c 6173 7320 506f  upper...class Po
+000229f0: 6c79 4d75 6c28 4172 7261 7929 3a0a 2020  lyMul(Array):.  
+00022a00: 2020 2727 2743 6f6d 7075 7465 2074 6865    '''Compute the
+00022a10: 2063 6f65 6666 6963 6965 6e74 7320 666f   coefficients fo
+00022a20: 7220 7468 6520 7072 6f64 7563 7420 6f66  r the product of
+00022a30: 2074 776f 2070 6f6c 796e 6f6d 6961 6c73   two polynomials
+00022a40: 0a0a 2020 2020 5265 7475 726e 2074 6865  ..    Return the
+00022a50: 2063 6f65 6666 6963 6965 6e74 7320 7375   coefficients su
+00022a60: 6368 2074 6861 7420 6361 6c6c 696e 6720  ch that calling 
+00022a70: 3a63 6c61 7373 3a60 506f 6c79 7661 6c60  :class:`Polyval`
+00022a80: 206f 6e20 7468 6973 2072 6573 756c 740a   on this result.
+00022a90: 2020 2020 6973 2065 7175 616c 2074 6f20      is equal to 
+00022aa0: 7468 6520 7072 6f64 7563 7420 6f66 203a  the product of :
+00022ab0: 636c 6173 733a 6050 6f6c 7976 616c 6020  class:`Polyval` 
+00022ac0: 6361 6c6c 6564 206f 6e20 7468 6520 696e  called on the in
+00022ad0: 6469 7669 6475 616c 2061 7272 6179 730a  dividual arrays.
+00022ae0: 2020 2020 6f66 2063 6f65 6666 6963 6965      of coefficie
+00022af0: 6e74 7320 2877 6974 6820 7468 6520 6170  nts (with the ap
+00022b00: 7072 6f70 7269 6174 6520 7365 6c65 6374  propriate select
+00022b10: 696f 6e20 6f66 2074 6865 2076 6172 6961  ion of the varia
+00022b20: 626c 6573 2061 730a 2020 2020 6465 7363  bles as.    desc
+00022b30: 7269 6265 6420 6279 2070 6172 616d 6574  ribed by paramet
+00022b40: 6572 2060 6076 6172 7360 6029 2e0a 0a20  er ``vars``)... 
+00022b50: 2020 2041 7267 730a 2020 2020 2d2d 2d2d     Args.    ----
+00022b60: 0a20 2020 2063 6f65 6666 735f 6c65 6674  .    coeffs_left
+00022b70: 203a 203a 636c 6173 733a 6041 7272 6179   : :class:`Array
+00022b80: 600a 2020 2020 2020 2020 5468 6520 636f  `.        The co
+00022b90: 6566 6669 6369 656e 7473 2066 6f72 2074  efficients for t
+00022ba0: 6865 206c 6566 7420 6f70 6572 616e 642e  he left operand.
+00022bb0: 2054 6865 206c 6173 7420 6178 6973 2069   The last axis i
+00022bc0: 7320 7472 6561 7465 6420 6173 2074 6865  s treated as the
+00022bd0: 0a20 2020 2020 2020 2063 6f65 6666 6963  .        coeffic
+00022be0: 6965 6e74 7320 6178 6973 2e0a 2020 2020  ients axis..    
+00022bf0: 636f 6566 6673 5f72 6967 6874 203a 203a  coeffs_right : :
+00022c00: 636c 6173 733a 6041 7272 6179 600a 2020  class:`Array`.  
+00022c10: 2020 2020 2020 5468 6520 636f 6566 6669        The coeffi
+00022c20: 6369 656e 7473 2066 6f72 2074 6865 2072  cients for the r
+00022c30: 6967 6874 206f 7065 7261 6e64 2e20 5468  ight operand. Th
+00022c40: 6520 6c61 7374 2061 7869 7320 6973 2074  e last axis is t
+00022c50: 7265 6174 6564 2061 7320 7468 650a 2020  reated as the.  
+00022c60: 2020 2020 2020 636f 6566 6669 6369 656e        coefficien
+00022c70: 7473 2061 7869 732e 0a20 2020 2076 6172  ts axis..    var
+00022c80: 7320 3a20 3a63 6c61 7373 3a60 7475 706c  s : :class:`tupl
+00022c90: 6560 206f 6620 6060 6e75 7469 6c73 5f70  e` of ``nutils_p
+00022ca0: 6f6c 792e 4d75 6c56 6172 6060 0a20 2020  oly.MulVar``.   
+00022cb0: 2020 2020 2046 6f72 2065 6163 6820 7661       For each va
+00022cc0: 7269 6162 6c65 206f 6620 7468 6973 2070  riable of this p
+00022cd0: 726f 6475 6374 2c20 6060 7661 7260 6020  roduct, ``var`` 
+00022ce0: 6465 6669 6e65 7320 6966 2074 6865 2076  defines if the v
+00022cf0: 6172 6961 626c 650a 2020 2020 2020 2020  ariable.        
+00022d00: 6578 6973 7473 2069 6e20 7468 6520 6c65  exists in the le
+00022d10: 6674 2070 6f6c 796e 6f6d 6961 6c2c 2074  ft polynomial, t
+00022d20: 6865 2072 6967 6874 206f 7220 626f 7468  he right or both
+00022d30: 2e0a 0a20 2020 204e 6f74 6573 0a20 2020  ...    Notes.   
+00022d40: 202d 2d2d 2d2d 0a0a 2020 2020 5365 6520   -----..    See 
+00022d50: 3a63 6c61 7373 3a60 506f 6c79 7661 6c60  :class:`Polyval`
+00022d60: 2066 6f72 2061 2064 6566 696e 6974 696f   for a definitio
+00022d70: 6e20 6f66 2074 6865 2070 6f6c 796e 6f6d  n of the polynom
+00022d80: 6961 6c2e 0a20 2020 2027 2727 0a0a 2020  ial..    '''..  
+00022d90: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+00022da0: 656c 662c 2063 6f65 6666 735f 6c65 6674  elf, coeffs_left
+00022db0: 3a20 4172 7261 792c 2063 6f65 6666 735f  : Array, coeffs_
+00022dc0: 7269 6768 743a 2041 7272 6179 2c20 7661  right: Array, va
+00022dd0: 7273 3a20 7479 7069 6e67 2e54 7570 6c65  rs: typing.Tuple
+00022de0: 5b70 6f6c 792e 4d75 6c56 6172 2c20 2e2e  [poly.MulVar, ..
+00022df0: 2e5d 293a 0a20 2020 2020 2020 2061 7373  .]):.        ass
+00022e00: 6572 7420 6973 696e 7374 616e 6365 2863  ert isinstance(c
+00022e10: 6f65 6666 735f 6c65 6674 2c20 4172 7261  oeffs_left, Arra
+00022e20: 7929 2061 6e64 2063 6f65 6666 735f 6c65  y) and coeffs_le
+00022e30: 6674 2e6e 6469 6d20 3e3d 2031 2061 6e64  ft.ndim >= 1 and
+00022e40: 2063 6f65 6666 735f 6c65 6674 2e64 7479   coeffs_left.dty
+00022e50: 7065 203d 3d20 666c 6f61 742c 2066 2763  pe == float, f'c
+00022e60: 6f65 6666 735f 6c65 6674 3d7b 636f 6566  oeffs_left={coef
+00022e70: 6673 5f6c 6566 7421 727d 270a 2020 2020  fs_left!r}'.    
+00022e80: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
+00022e90: 7461 6e63 6528 636f 6566 6673 5f72 6967  tance(coeffs_rig
+00022ea0: 6874 2c20 4172 7261 7929 2061 6e64 2063  ht, Array) and c
+00022eb0: 6f65 6666 735f 7269 6768 742e 6e64 696d  oeffs_right.ndim
+00022ec0: 203e 3d20 3120 616e 6420 636f 6566 6673   >= 1 and coeffs
+00022ed0: 5f72 6967 6874 2e64 7479 7065 203d 3d20  _right.dtype == 
+00022ee0: 666c 6f61 742c 2066 2763 6f65 6666 735f  float, f'coeffs_
+00022ef0: 7269 6768 743d 7b63 6f65 6666 735f 7269  right={coeffs_ri
+00022f00: 6768 7421 727d 270a 2020 2020 2020 2020  ght!r}'.        
+00022f10: 6173 7365 7274 2065 7175 616c 7368 6170  assert equalshap
+00022f20: 6528 636f 6566 6673 5f6c 6566 742e 7368  e(coeffs_left.sh
+00022f30: 6170 655b 3a2d 315d 2c20 636f 6566 6673  ape[:-1], coeffs
+00022f40: 5f72 6967 6874 2e73 6861 7065 5b3a 2d31  _right.shape[:-1
+00022f50: 5d29 2c20 2750 6f6c 794d 756c 287b 7d2c  ]), 'PolyMul({},
+00022f60: 207b 7d29 272e 666f 726d 6174 2863 6f65   {})'.format(coe
+00022f70: 6666 735f 6c65 6674 2c20 636f 6566 6673  ffs_left, coeffs
+00022f80: 5f72 6967 6874 290a 2020 2020 2020 2020  _right).        
+00022f90: 7365 6c66 2e63 6f65 6666 735f 6c65 6674  self.coeffs_left
+00022fa0: 203d 2063 6f65 6666 735f 6c65 6674 0a20   = coeffs_left. 
+00022fb0: 2020 2020 2020 2073 656c 662e 636f 6566         self.coef
+00022fc0: 6673 5f72 6967 6874 203d 2063 6f65 6666  fs_right = coeff
+00022fd0: 735f 7269 6768 740a 2020 2020 2020 2020  s_right.        
+00022fe0: 7365 6c66 2e76 6172 7320 3d20 7661 7273  self.vars = vars
+00022ff0: 0a20 2020 2020 2020 2073 656c 662e 6465  .        self.de
+00023000: 6772 6565 5f6c 6566 7420 3d20 506f 6c79  gree_left = Poly
+00023010: 4465 6772 6565 2863 6f65 6666 735f 6c65  Degree(coeffs_le
+00023020: 6674 2e73 6861 7065 5b2d 315d 2c20 6275  ft.shape[-1], bu
+00023030: 696c 7469 6e73 2e73 756d 2876 6172 2021  iltins.sum(var !
+00023040: 3d20 706f 6c79 2e4d 756c 5661 722e 5269  = poly.MulVar.Ri
+00023050: 6768 7420 666f 7220 7661 7220 696e 2076  ght for var in v
+00023060: 6172 7329 290a 2020 2020 2020 2020 7365  ars)).        se
+00023070: 6c66 2e64 6567 7265 655f 7269 6768 7420  lf.degree_right 
+00023080: 3d20 506f 6c79 4465 6772 6565 2863 6f65  = PolyDegree(coe
+00023090: 6666 735f 7269 6768 742e 7368 6170 655b  ffs_right.shape[
+000230a0: 2d31 5d2c 2062 7569 6c74 696e 732e 7375  -1], builtins.su
+000230b0: 6d28 7661 7220 213d 2070 6f6c 792e 4d75  m(var != poly.Mu
+000230c0: 6c56 6172 2e4c 6566 7420 666f 7220 7661  lVar.Left for va
+000230d0: 7220 696e 2076 6172 7329 290a 2020 2020  r in vars)).    
+000230e0: 2020 2020 6e63 6f65 6666 7320 3d20 506f      ncoeffs = Po
+000230f0: 6c79 4e43 6f65 6666 7328 6c65 6e28 7661  lyNCoeffs(len(va
+00023100: 7273 292c 2073 656c 662e 6465 6772 6565  rs), self.degree
+00023110: 5f6c 6566 7420 2b20 7365 6c66 2e64 6567  _left + self.deg
+00023120: 7265 655f 7269 6768 7429 0a20 2020 2020  ree_right).     
+00023130: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
+00023140: 745f 5f28 6172 6773 3d28 636f 6566 6673  t__(args=(coeffs
+00023150: 5f6c 6566 742c 2063 6f65 6666 735f 7269  _left, coeffs_ri
+00023160: 6768 7429 2c20 7368 6170 653d 282a 636f  ght), shape=(*co
+00023170: 6566 6673 5f6c 6566 742e 7368 6170 655b  effs_left.shape[
+00023180: 3a2d 315d 2c20 6e63 6f65 6666 7329 2c20  :-1], ncoeffs), 
+00023190: 6474 7970 653d 666c 6f61 7429 0a0a 2020  dtype=float)..  
+000231a0: 2020 4063 6163 6865 645f 7072 6f70 6572    @cached_proper
+000231b0: 7479 0a20 2020 2064 6566 2065 7661 6c66  ty.    def evalf
+000231c0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+000231d0: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
+000231e0: 2064 6567 7265 655f 6c65 6674 203d 2073   degree_left = s
+000231f0: 656c 662e 6465 6772 6565 5f6c 6566 742e  elf.degree_left.
+00023200: 5f5f 696e 6465 785f 5f28 290a 2020 2020  __index__().    
+00023210: 2020 2020 2020 2020 6465 6772 6565 5f72          degree_r
+00023220: 6967 6874 203d 2073 656c 662e 6465 6772  ight = self.degr
+00023230: 6565 5f72 6967 6874 2e5f 5f69 6e64 6578  ee_right.__index
+00023240: 5f5f 2829 0a20 2020 2020 2020 2065 7863  __().        exc
+00023250: 6570 7420 5479 7065 4572 726f 7220 6173  ept TypeError as
+00023260: 2065 3a0a 2020 2020 2020 2020 2020 2020   e:.            
+00023270: 7265 7475 726e 2066 756e 6374 6f6f 6c73  return functools
+00023280: 2e70 6172 7469 616c 2870 6f6c 792e 6d75  .partial(poly.mu
+00023290: 6c2c 2076 6172 733d 7365 6c66 2e76 6172  l, vars=self.var
+000232a0: 7329 0a20 2020 2020 2020 2065 6c73 653a  s).        else:
+000232b0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+000232c0: 7572 6e20 706f 6c79 2e4d 756c 506c 616e  urn poly.MulPlan
+000232d0: 2873 656c 662e 7661 7273 2c20 6465 6772  (self.vars, degr
+000232e0: 6565 5f6c 6566 742c 2064 6567 7265 655f  ee_left, degree_
+000232f0: 7269 6768 7429 0a0a 2020 2020 6465 6620  right)..    def 
+00023300: 5f73 696d 706c 6966 6965 6428 7365 6c66  _simplified(self
+00023310: 293a 0a20 2020 2020 2020 2069 6620 6973  ):.        if is
+00023320: 7a65 726f 2873 656c 662e 636f 6566 6673  zero(self.coeffs
+00023330: 5f6c 6566 7429 206f 7220 6973 7a65 726f  _left) or iszero
+00023340: 2873 656c 662e 636f 6566 6673 5f72 6967  (self.coeffs_rig
+00023350: 6874 293a 0a20 2020 2020 2020 2020 2020  ht):.           
+00023360: 2072 6574 7572 6e20 7a65 726f 735f 6c69   return zeros_li
+00023370: 6b65 2873 656c 6629 0a0a 2020 2020 6465  ke(self)..    de
+00023380: 6620 5f74 616b 6564 6961 6728 7365 6c66  f _takediag(self
+00023390: 2c20 6178 6973 312c 2061 7869 7332 293a  , axis1, axis2):
+000233a0: 0a20 2020 2020 2020 2069 6620 6178 6973  .        if axis
+000233b0: 3120 3c20 7365 6c66 2e6e 6469 6d20 2d20  1 < self.ndim - 
+000233c0: 3120 616e 6420 6178 6973 3220 3c20 7365  1 and axis2 < se
+000233d0: 6c66 2e6e 6469 6d20 2d20 313a 0a20 2020  lf.ndim - 1:.   
+000233e0: 2020 2020 2020 2020 2063 6f65 6666 735f           coeffs_
+000233f0: 6c65 6674 203d 2054 7261 6e73 706f 7365  left = Transpose
+00023400: 2e74 6f5f 656e 6428 5f74 616b 6564 6961  .to_end(_takedia
+00023410: 6728 7365 6c66 2e63 6f65 6666 735f 6c65  g(self.coeffs_le
+00023420: 6674 2c20 6178 6973 312c 2061 7869 7332  ft, axis1, axis2
+00023430: 292c 202d 3229 0a20 2020 2020 2020 2020  ), -2).         
+00023440: 2020 2063 6f65 6666 735f 7269 6768 7420     coeffs_right 
+00023450: 3d20 5472 616e 7370 6f73 652e 746f 5f65  = Transpose.to_e
+00023460: 6e64 285f 7461 6b65 6469 6167 2873 656c  nd(_takediag(sel
+00023470: 662e 636f 6566 6673 5f72 6967 6874 2c20  f.coeffs_right, 
+00023480: 6178 6973 312c 2061 7869 7332 292c 202d  axis1, axis2), -
+00023490: 3229 0a20 2020 2020 2020 2020 2020 2072  2).            r
+000234a0: 6574 7572 6e20 5472 616e 7370 6f73 652e  eturn Transpose.
+000234b0: 746f 5f65 6e64 2850 6f6c 794d 756c 2863  to_end(PolyMul(c
+000234c0: 6f65 6666 735f 6c65 6674 2c20 636f 6566  oeffs_left, coef
+000234d0: 6673 5f72 6967 6874 2c20 7365 6c66 2e76  fs_right, self.v
+000234e0: 6172 7329 2c20 2d32 290a 0a20 2020 2064  ars), -2)..    d
+000234f0: 6566 205f 7461 6b65 2873 656c 662c 2069  ef _take(self, i
+00023500: 6e64 6578 2c20 6178 6973 293a 0a20 2020  ndex, axis):.   
+00023510: 2020 2020 2069 6620 6178 6973 203c 2073       if axis < s
+00023520: 656c 662e 6e64 696d 202d 2031 3a0a 2020  elf.ndim - 1:.  
+00023530: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00023540: 2050 6f6c 794d 756c 285f 7461 6b65 2873   PolyMul(_take(s
+00023550: 656c 662e 636f 6566 6673 5f6c 6566 742c  elf.coeffs_left,
+00023560: 2069 6e64 6578 2c20 6178 6973 292c 205f   index, axis), _
+00023570: 7461 6b65 2873 656c 662e 636f 6566 6673  take(self.coeffs
+00023580: 5f72 6967 6874 2c20 696e 6465 782c 2061  _right, index, a
+00023590: 7869 7329 2c20 7365 6c66 2e76 6172 7329  xis), self.vars)
+000235a0: 0a0a 2020 2020 6465 6620 5f75 6e72 6176  ..    def _unrav
+000235b0: 656c 2873 656c 662c 2061 7869 732c 2073  el(self, axis, s
+000235c0: 6861 7065 293a 0a20 2020 2020 2020 2069  hape):.        i
+000235d0: 6620 6178 6973 203c 2073 656c 662e 6e64  f axis < self.nd
+000235e0: 696d 202d 2031 3a0a 2020 2020 2020 2020  im - 1:.        
+000235f0: 2020 2020 7265 7475 726e 2050 6f6c 794d      return PolyM
+00023600: 756c 2875 6e72 6176 656c 2873 656c 662e  ul(unravel(self.
+00023610: 636f 6566 6673 5f6c 6566 742c 2061 7869  coeffs_left, axi
+00023620: 732c 2073 6861 7065 292c 2075 6e72 6176  s, shape), unrav
+00023630: 656c 2873 656c 662e 636f 6566 6673 5f72  el(self.coeffs_r
+00023640: 6967 6874 2c20 6178 6973 2c20 7368 6170  ight, axis, shap
+00023650: 6529 2c20 7365 6c66 2e76 6172 7329 0a0a  e), self.vars)..
+00023660: 0a63 6c61 7373 2050 6f6c 7947 7261 6428  .class PolyGrad(
+00023670: 4172 7261 7929 3a0a 2020 2020 2727 2743  Array):.    '''C
+00023680: 6f6d 7075 7465 2074 6865 2063 6f65 6666  ompute the coeff
+00023690: 6963 6965 6e74 7320 666f 7220 7468 6520  icients for the 
+000236a0: 6772 6164 6965 6e74 206f 6620 6120 706f  gradient of a po
+000236b0: 6c79 6e6f 6d69 616c 0a0a 2020 2020 5468  lynomial..    Th
+000236c0: 6520 6c61 7374 2074 776f 2061 7865 7320  e last two axes 
+000236d0: 6f66 2074 6869 7320 6172 7261 7920 6172  of this array ar
+000236e0: 6520 7468 6520 6178 6973 206f 6620 7661  e the axis of va
+000236f0: 7269 6162 6c65 7320 616e 6420 7468 6520  riables and the 
+00023700: 6178 6973 206f 660a 2020 2020 636f 6566  axis of.    coef
+00023710: 6669 6369 656e 7473 2e0a 0a20 2020 2041  ficients...    A
+00023720: 7267 730a 2020 2020 2d2d 2d2d 0a20 2020  rgs.    ----.   
+00023730: 2063 6f65 6666 7320 3a20 3a63 6c61 7373   coeffs : :class
+00023740: 3a60 4172 7261 7960 0a20 2020 2020 2020  :`Array`.       
+00023750: 2054 6865 2063 6f65 6666 6963 6965 6e74   The coefficient
+00023760: 7320 6f66 2074 6865 2070 6f6c 796e 6f6d  s of the polynom
+00023770: 6961 6c20 746f 2063 6f6d 7075 7465 2074  ial to compute t
+00023780: 6865 2067 7261 6469 656e 7420 666f 722e  he gradient for.
+00023790: 2054 6865 0a20 2020 2020 2020 206c 6173   The.        las
+000237a0: 7420 6178 6973 2069 7320 7472 6561 7465  t axis is treate
+000237b0: 6420 6173 2074 6865 2063 6f65 6666 6963  d as the coeffic
+000237c0: 6965 6e74 7320 6178 6973 2e0a 2020 2020  ients axis..    
+000237d0: 6e76 6172 7320 3a20 3a63 6c61 7373 3a60  nvars : :class:`
+000237e0: 696e 7460 0a20 2020 2020 2020 2054 6865  int`.        The
+000237f0: 206e 756d 6265 7220 6f66 2076 6172 6961   number of varia
+00023800: 626c 6573 206f 6620 7468 6520 706f 6c79  bles of the poly
+00023810: 6e6f 6d69 616c 2e0a 0a20 2020 204e 6f74  nomial...    Not
+00023820: 6573 0a20 2020 202d 2d2d 2d2d 0a0a 2020  es.    -----..  
+00023830: 2020 5365 6520 3a63 6c61 7373 3a60 506f    See :class:`Po
+00023840: 6c79 7661 6c60 2066 6f72 2061 2064 6566  lyval` for a def
+00023850: 696e 6974 696f 6e20 6f66 2074 6865 2070  inition of the p
+00023860: 6f6c 796e 6f6d 6961 6c2e 0a20 2020 2027  olynomial..    '
+00023870: 2727 0a0a 2020 2020 6465 6620 5f5f 696e  ''..    def __in
+00023880: 6974 5f5f 2873 656c 662c 2063 6f65 6666  it__(self, coeff
+00023890: 733a 2041 7272 6179 2c20 6e76 6172 733a  s: Array, nvars:
+000238a0: 2069 6e74 293a 0a20 2020 2020 2020 2061   int):.        a
+000238b0: 7373 6572 7420 6973 696e 7374 616e 6365  ssert isinstance
+000238c0: 2863 6f65 6666 732c 2041 7272 6179 2920  (coeffs, Array) 
+000238d0: 616e 6420 636f 6566 6673 2e64 7479 7065  and coeffs.dtype
+000238e0: 203d 3d20 666c 6f61 7420 616e 6420 636f   == float and co
+000238f0: 6566 6673 2e6e 6469 6d20 3e3d 2031 2c20  effs.ndim >= 1, 
+00023900: 6627 636f 6566 6673 3d7b 636f 6566 6673  f'coeffs={coeffs
+00023910: 2172 7d27 0a20 2020 2020 2020 2061 7373  !r}'.        ass
+00023920: 6572 7420 6973 696e 7374 616e 6365 286e  ert isinstance(n
+00023930: 7661 7273 2c20 696e 7429 2061 6e64 206e  vars, int) and n
+00023940: 7661 7273 203e 3d20 302c 2066 276e 7661  vars >= 0, f'nva
+00023950: 7273 3d7b 6e76 6172 7321 727d 270a 2020  rs={nvars!r}'.  
+00023960: 2020 2020 2020 7365 6c66 2e63 6f65 6666        self.coeff
+00023970: 7320 3d20 636f 6566 6673 0a20 2020 2020  s = coeffs.     
+00023980: 2020 2073 656c 662e 6e76 6172 7320 3d20     self.nvars = 
+00023990: 6e76 6172 730a 2020 2020 2020 2020 7365  nvars.        se
+000239a0: 6c66 2e64 6567 7265 6520 3d20 506f 6c79  lf.degree = Poly
+000239b0: 4465 6772 6565 2863 6f65 6666 732e 7368  Degree(coeffs.sh
+000239c0: 6170 655b 2d31 5d2c 206e 7661 7273 290a  ape[-1], nvars).
+000239d0: 2020 2020 2020 2020 6e63 6f65 6666 7320          ncoeffs 
+000239e0: 3d20 506f 6c79 4e43 6f65 6666 7328 6e76  = PolyNCoeffs(nv
+000239f0: 6172 732c 204d 6178 696d 756d 2863 6f6e  ars, Maximum(con
+00023a00: 7374 616e 7428 3029 2c20 7365 6c66 2e64  stant(0), self.d
+00023a10: 6567 7265 6520 2d20 636f 6e73 7461 6e74  egree - constant
+00023a20: 2831 2929 290a 2020 2020 2020 2020 7368  (1))).        sh
+00023a30: 6170 6520 3d20 2a63 6f65 6666 732e 7368  ape = *coeffs.sh
+00023a40: 6170 655b 3a2d 315d 2c20 636f 6e73 7461  ape[:-1], consta
+00023a50: 6e74 286e 7661 7273 292c 206e 636f 6566  nt(nvars), ncoef
+00023a60: 6673 0a20 2020 2020 2020 2073 7570 6572  fs.        super
+00023a70: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
+00023a80: 3d28 636f 6566 6673 2c29 2c20 7368 6170  =(coeffs,), shap
+00023a90: 653d 7368 6170 652c 2064 7479 7065 3d66  e=shape, dtype=f
+00023aa0: 6c6f 6174 290a 0a20 2020 2040 6361 6368  loat)..    @cach
+00023ab0: 6564 5f70 726f 7065 7274 790a 2020 2020  ed_property.    
+00023ac0: 6465 6620 6576 616c 6628 7365 6c66 293a  def evalf(self):
+00023ad0: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
+00023ae0: 2020 2020 2020 2020 2020 6465 6772 6565            degree
+00023af0: 203d 2073 656c 662e 6465 6772 6565 2e5f   = self.degree._
+00023b00: 5f69 6e64 6578 5f5f 2829 0a20 2020 2020  _index__().     
+00023b10: 2020 2065 7863 6570 7420 5479 7065 4572     except TypeEr
+00023b20: 726f 7220 6173 2065 3a0a 2020 2020 2020  ror as e:.      
+00023b30: 2020 2020 2020 7265 7475 726e 2066 756e        return fun
+00023b40: 6374 6f6f 6c73 2e70 6172 7469 616c 2870  ctools.partial(p
+00023b50: 6f6c 792e 6772 6164 2c20 6e76 6172 733d  oly.grad, nvars=
+00023b60: 7365 6c66 2e6e 7661 7273 290a 2020 2020  self.nvars).    
+00023b70: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00023b80: 2020 2020 2020 7265 7475 726e 2070 6f6c        return pol
+00023b90: 792e 4772 6164 506c 616e 2873 656c 662e  y.GradPlan(self.
+00023ba0: 6e76 6172 732c 2064 6567 7265 6529 0a0a  nvars, degree)..
+00023bb0: 2020 2020 6465 6620 5f73 696d 706c 6966      def _simplif
+00023bc0: 6965 6428 7365 6c66 293a 0a20 2020 2020  ied(self):.     
+00023bd0: 2020 2069 6620 6973 7a65 726f 2873 656c     if iszero(sel
+00023be0: 662e 636f 6566 6673 2920 6f72 205f 6571  f.coeffs) or _eq
+00023bf0: 7561 6c73 5f73 6361 6c61 725f 636f 6e73  uals_scalar_cons
+00023c00: 7461 6e74 2873 656c 662e 6465 6772 6565  tant(self.degree
+00023c10: 2c20 3029 3a0a 2020 2020 2020 2020 2020  , 0):.          
+00023c20: 2020 7265 7475 726e 207a 6572 6f73 5f6c    return zeros_l
+00023c30: 696b 6528 7365 6c66 290a 2020 2020 2020  ike(self).      
+00023c40: 2020 656c 6966 205f 6571 7561 6c73 5f73    elif _equals_s
+00023c50: 6361 6c61 725f 636f 6e73 7461 6e74 2873  calar_constant(s
+00023c60: 656c 662e 6465 6772 6565 2c20 3129 3a0a  elf.degree, 1):.
+00023c70: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00023c80: 726e 2049 6e73 6572 7441 7869 7328 5461  rn InsertAxis(Ta
+00023c90: 6b65 2873 656c 662e 636f 6566 6673 2c20  ke(self.coeffs, 
+00023ca0: 636f 6e73 7461 6e74 2873 656c 662e 6e76  constant(self.nv
+00023cb0: 6172 7320 2d20 3129 202d 2052 616e 6765  ars - 1) - Range
+00023cc0: 2863 6f6e 7374 616e 7428 7365 6c66 2e6e  (constant(self.n
+00023cd0: 7661 7273 2929 292c 2063 6f6e 7374 616e  vars))), constan
+00023ce0: 7428 3129 290a 0a20 2020 2064 6566 205f  t(1))..    def _
+00023cf0: 7461 6b65 6469 6167 2873 656c 662c 2061  takediag(self, a
+00023d00: 7869 7331 2c20 6178 6973 3229 3a0a 2020  xis1, axis2):.  
+00023d10: 2020 2020 2020 6966 2061 7869 7331 203c        if axis1 <
+00023d20: 2073 656c 662e 6e64 696d 202d 2032 2061   self.ndim - 2 a
+00023d30: 6e64 2061 7869 7332 203c 2073 656c 662e  nd axis2 < self.
+00023d40: 6e64 696d 202d 2032 3a0a 2020 2020 2020  ndim - 2:.      
+00023d50: 2020 2020 2020 636f 6566 6673 203d 2054        coeffs = T
+00023d60: 7261 6e73 706f 7365 2e74 6f5f 656e 6428  ranspose.to_end(
+00023d70: 5f74 616b 6564 6961 6728 7365 6c66 2e63  _takediag(self.c
+00023d80: 6f65 6666 732c 2061 7869 7331 2c20 6178  oeffs, axis1, ax
+00023d90: 6973 3229 2c20 2d32 290a 2020 2020 2020  is2), -2).      
+00023da0: 2020 2020 2020 7265 7475 726e 2054 7261        return Tra
+00023db0: 6e73 706f 7365 2e66 726f 6d5f 656e 6428  nspose.from_end(
+00023dc0: 506f 6c79 4772 6164 2863 6f65 6666 732c  PolyGrad(coeffs,
+00023dd0: 2073 656c 662e 6e76 6172 7329 2c20 2d33   self.nvars), -3
+00023de0: 2c20 2d32 290a 0a20 2020 2064 6566 205f  , -2)..    def _
+00023df0: 7461 6b65 2873 656c 662c 2069 6e64 6578  take(self, index
+00023e00: 2c20 6178 6973 293a 0a20 2020 2020 2020  , axis):.       
+00023e10: 2069 6620 6178 6973 203c 2073 656c 662e   if axis < self.
+00023e20: 6e64 696d 202d 2032 3a0a 2020 2020 2020  ndim - 2:.      
+00023e30: 2020 2020 2020 7265 7475 726e 2050 6f6c        return Pol
+00023e40: 7947 7261 6428 5f74 616b 6528 7365 6c66  yGrad(_take(self
+00023e50: 2e63 6f65 6666 732c 2069 6e64 6578 2c20  .coeffs, index, 
+00023e60: 6178 6973 292c 2073 656c 662e 6e76 6172  axis), self.nvar
+00023e70: 7329 0a0a 2020 2020 6465 6620 5f75 6e72  s)..    def _unr
+00023e80: 6176 656c 2873 656c 662c 2061 7869 732c  avel(self, axis,
+00023e90: 2073 6861 7065 293a 0a20 2020 2020 2020   shape):.       
+00023ea0: 2069 6620 6178 6973 203c 2073 656c 662e   if axis < self.
+00023eb0: 6e64 696d 202d 2032 3a0a 2020 2020 2020  ndim - 2:.      
+00023ec0: 2020 2020 2020 7265 7475 726e 2050 6f6c        return Pol
+00023ed0: 7947 7261 6428 756e 7261 7665 6c28 7365  yGrad(unravel(se
+00023ee0: 6c66 2e63 6f65 6666 732c 2061 7869 732c  lf.coeffs, axis,
+00023ef0: 2073 6861 7065 292c 2073 656c 662e 6e76   shape), self.nv
+00023f00: 6172 7329 0a0a 0a63 6c61 7373 204c 6567  ars)...class Leg
+00023f10: 656e 6472 6528 4172 7261 7929 3a0a 2020  endre(Array):.  
+00023f20: 2020 2727 2753 6572 6965 7320 6f66 204c    '''Series of L
+00023f30: 6567 656e 6472 6520 706f 6c79 6e6f 6d69  egendre polynomi
+00023f40: 616c 2075 7020 746f 2061 6e64 2069 6e63  al up to and inc
+00023f50: 6c75 6469 6e67 2074 6865 2067 6976 656e  luding the given
+00023f60: 2064 6567 7265 652e 0a0a 2020 2020 5061   degree...    Pa
+00023f70: 7261 6d65 7465 7273 0a20 2020 202d 2d2d  rameters.    ---
+00023f80: 2d2d 2d2d 2d2d 0a20 2020 2078 203a 203a  ------.    x : :
+00023f90: 636c 6173 733a 6041 7272 6179 600a 2020  class:`Array`.  
+00023fa0: 2020 2020 2020 5468 6520 636f 6f72 6469        The coordi
+00023fb0: 6e61 7465 7320 746f 2065 7661 6c75 6174  nates to evaluat
+00023fc0: 6520 7468 6520 7365 7269 6573 2061 742e  e the series at.
+00023fd0: 0a20 2020 2064 6567 7265 6520 3a20 3a63  .    degree : :c
+00023fe0: 6c61 7373 3a60 696e 7460 0a20 2020 2020  lass:`int`.     
+00023ff0: 2020 2054 6865 2064 6567 7265 6520 6f66     The degree of
+00024000: 2074 6865 206c 6173 7420 706f 6c79 6e6f   the last polyno
+00024010: 6d69 616c 206f 6620 7468 6520 7365 7269  mial of the seri
+00024020: 6573 2e0a 2020 2020 2727 270a 0a20 2020  es..    '''..   
+00024030: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
+00024040: 6c66 2c20 783a 2041 7272 6179 2c20 6465  lf, x: Array, de
+00024050: 6772 6565 3a20 696e 7429 202d 3e20 4e6f  gree: int) -> No
+00024060: 6e65 3a0a 2020 2020 2020 2020 6173 7365  ne:.        asse
+00024070: 7274 2069 7369 6e73 7461 6e63 6528 782c  rt isinstance(x,
+00024080: 2041 7272 6179 2920 616e 6420 782e 6474   Array) and x.dt
+00024090: 7970 6520 3d3d 2066 6c6f 6174 2c20 6627  ype == float, f'
+000240a0: 783d 7b78 2172 7d27 0a20 2020 2020 2020  x={x!r}'.       
+000240b0: 2061 7373 6572 7420 6973 696e 7374 616e   assert isinstan
+000240c0: 6365 2864 6567 7265 652c 2069 6e74 2920  ce(degree, int) 
+000240d0: 616e 6420 6465 6772 6565 203e 3d20 302c  and degree >= 0,
+000240e0: 2066 2764 6567 7265 653d 7b64 6567 7265   f'degree={degre
+000240f0: 6521 727d 270a 2020 2020 2020 2020 7365  e!r}'.        se
+00024100: 6c66 2e5f 7820 3d20 780a 2020 2020 2020  lf._x = x.      
+00024110: 2020 7365 6c66 2e5f 6465 6772 6565 203d    self._degree =
+00024120: 2064 6567 7265 650a 2020 2020 2020 2020   degree.        
+00024130: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
+00024140: 2861 7267 733d 2878 2c29 2c20 7368 6170  (args=(x,), shap
+00024150: 653d 282a 782e 7368 6170 652c 2063 6f6e  e=(*x.shape, con
+00024160: 7374 616e 7428 6465 6772 6565 2b31 2929  stant(degree+1))
+00024170: 2c20 6474 7970 653d 666c 6f61 7429 0a0a  , dtype=float)..
+00024180: 2020 2020 6465 6620 6576 616c 6628 7365      def evalf(se
+00024190: 6c66 2c20 783a 206e 756d 7079 2e6e 6461  lf, x: numpy.nda
+000241a0: 7272 6179 2920 2d3e 206e 756d 7079 2e6e  rray) -> numpy.n
+000241b0: 6461 7272 6179 3a0a 2020 2020 2020 2020  darray:.        
+000241c0: 5020 3d20 6e75 6d70 792e 656d 7074 7928  P = numpy.empty(
+000241d0: 282a 782e 7368 6170 652c 2073 656c 662e  (*x.shape, self.
+000241e0: 5f64 6567 7265 652b 3129 2c20 6474 7970  _degree+1), dtyp
+000241f0: 653d 666c 6f61 7429 0a20 2020 2020 2020  e=float).       
+00024200: 2050 5b2e 2e2e 2c20 305d 203d 2031 0a20   P[..., 0] = 1. 
+00024210: 2020 2020 2020 2069 6620 7365 6c66 2e5f         if self._
+00024220: 6465 6772 6565 3a0a 2020 2020 2020 2020  degree:.        
+00024230: 2020 2020 505b 2e2e 2e2c 2031 5d20 3d20      P[..., 1] = 
+00024240: 780a 2020 2020 2020 2020 666f 7220 6920  x.        for i 
+00024250: 696e 2072 616e 6765 2832 2c20 7365 6c66  in range(2, self
+00024260: 2e5f 6465 6772 6565 2b31 293a 0a20 2020  ._degree+1):.   
+00024270: 2020 2020 2020 2020 2050 5b2e 2e2e 2c20           P[..., 
+00024280: 695d 203d 2028 322d 312f 6929 2a50 5b2e  i] = (2-1/i)*P[.
+00024290: 2e2e 2c20 315d 2a50 5b2e 2e2e 2c20 692d  .., 1]*P[..., i-
+000242a0: 315d 202d 2028 312d 312f 6929 2a50 5b2e  1] - (1-1/i)*P[.
+000242b0: 2e2e 2c20 692d 325d 0a20 2020 2020 2020  .., i-2].       
+000242c0: 2072 6574 7572 6e20 500a 0a20 2020 2064   return P..    d
+000242d0: 6566 205f 6465 7269 7661 7469 7665 2873  ef _derivative(s
+000242e0: 656c 662c 2076 6172 2c20 7365 656e 293a  elf, var, seen):
+000242f0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00024300: 2e64 7479 7065 203d 3d20 636f 6d70 6c65  .dtype == comple
+00024310: 783a 0a20 2020 2020 2020 2020 2020 2072  x:.            r
+00024320: 6169 7365 204e 6f74 496d 706c 656d 656e  aise NotImplemen
+00024330: 7465 6445 7272 6f72 2827 5468 6520 636f  tedError('The co
+00024340: 6d70 6c65 7820 6465 7269 7661 7469 7665  mplex derivative
+00024350: 2069 7320 6e6f 7420 696d 706c 656d 656e   is not implemen
+00024360: 7465 642e 2729 0a20 2020 2020 2020 2064  ted.').        d
+00024370: 203d 206e 756d 7079 2e7a 6572 6f73 2828   = numpy.zeros((
+00024380: 7365 6c66 2e5f 6465 6772 6565 2b31 2c29  self._degree+1,)
+00024390: 2a32 2c20 6474 7970 653d 696e 7429 0a20  *2, dtype=int). 
+000243a0: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+000243b0: 7261 6e67 6528 7365 6c66 2e5f 6465 6772  range(self._degr
+000243c0: 6565 2b31 293a 0a20 2020 2020 2020 2020  ee+1):.         
+000243d0: 2020 2064 5b69 2c20 692b 313a 3a32 5d20     d[i, i+1::2] 
+000243e0: 3d20 322a 692b 310a 2020 2020 2020 2020  = 2*i+1.        
+000243f0: 6473 656c 6620 3d20 6569 6e73 756d 2827  dself = einsum('
+00024400: 4169 2c69 6a2d 3e41 6a27 2c20 7365 6c66  Ai,ij->Aj', self
+00024410: 2c20 636f 6e73 7461 6e74 2864 2929 0a20  , constant(d)). 
+00024420: 2020 2020 2020 2072 6574 7572 6e20 6569         return ei
+00024430: 6e73 756d 2827 4169 2c41 422d 3e41 6942  nsum('Ai,AB->AiB
+00024440: 272c 2064 7365 6c66 2c20 6465 7269 7661  ', dself, deriva
+00024450: 7469 7665 2873 656c 662e 5f78 2c20 7661  tive(self._x, va
+00024460: 722c 2073 6565 6e29 290a 0a20 2020 2064  r, seen))..    d
+00024470: 6566 205f 7369 6d70 6c69 6669 6564 2873  ef _simplified(s
+00024480: 656c 6629 3a0a 2020 2020 2020 2020 756e  elf):.        un
+00024490: 616c 6967 6e65 642c 2077 6865 7265 203d  aligned, where =
+000244a0: 2075 6e61 6c69 676e 2873 656c 662e 5f78   unalign(self._x
+000244b0: 290a 2020 2020 2020 2020 6966 2077 6865  ).        if whe
+000244c0: 7265 2021 3d20 7475 706c 6528 7261 6e67  re != tuple(rang
+000244d0: 6528 7365 6c66 2e5f 782e 6e64 696d 2929  e(self._x.ndim))
+000244e0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+000244f0: 7475 726e 2061 6c69 676e 284c 6567 656e  turn align(Legen
+00024500: 6472 6528 756e 616c 6967 6e65 642c 2073  dre(unaligned, s
+00024510: 656c 662e 5f64 6567 7265 6529 2c20 282a  elf._degree), (*
+00024520: 7768 6572 652c 2073 656c 662e 6e64 696d  where, self.ndim
+00024530: 2d31 292c 2073 656c 662e 7368 6170 6529  -1), self.shape)
+00024540: 0a0a 2020 2020 6465 6620 5f74 616b 6564  ..    def _taked
+00024550: 6961 6728 7365 6c66 2c20 6178 6973 312c  iag(self, axis1,
+00024560: 2061 7869 7332 293a 0a20 2020 2020 2020   axis2):.       
+00024570: 2069 6620 6178 6973 3120 3c20 7365 6c66   if axis1 < self
+00024580: 2e6e 6469 6d20 2d20 3120 616e 6420 6178  .ndim - 1 and ax
+00024590: 6973 3220 3c20 7365 6c66 2e6e 6469 6d20  is2 < self.ndim 
+000245a0: 2d20 313a 0a20 2020 2020 2020 2020 2020  - 1:.           
+000245b0: 2072 6574 7572 6e20 5472 616e 7370 6f73   return Transpos
+000245c0: 652e 746f 5f65 6e64 284c 6567 656e 6472  e.to_end(Legendr
+000245d0: 6528 5f74 616b 6564 6961 6728 7365 6c66  e(_takediag(self
+000245e0: 2e5f 782c 2061 7869 7331 2c20 6178 6973  ._x, axis1, axis
+000245f0: 3229 2c20 7365 6c66 2e5f 6465 6772 6565  2), self._degree
+00024600: 292c 202d 3229 0a0a 2020 2020 6465 6620  ), -2)..    def 
+00024610: 5f74 616b 6528 7365 6c66 2c20 696e 6465  _take(self, inde
+00024620: 782c 2061 7869 7329 3a0a 2020 2020 2020  x, axis):.      
+00024630: 2020 6966 2061 7869 7320 3c20 7365 6c66    if axis < self
+00024640: 2e6e 6469 6d20 2d20 313a 0a20 2020 2020  .ndim - 1:.     
+00024650: 2020 2020 2020 2072 6574 7572 6e20 4c65         return Le
+00024660: 6765 6e64 7265 285f 7461 6b65 2873 656c  gendre(_take(sel
+00024670: 662e 5f78 2c20 696e 6465 782c 2061 7869  f._x, index, axi
+00024680: 7329 2c20 7365 6c66 2e5f 6465 6772 6565  s), self._degree
+00024690: 290a 0a20 2020 2064 6566 205f 756e 7261  )..    def _unra
+000246a0: 7665 6c28 7365 6c66 2c20 6178 6973 2c20  vel(self, axis, 
+000246b0: 7368 6170 6529 3a0a 2020 2020 2020 2020  shape):.        
+000246c0: 6966 2061 7869 7320 3c20 7365 6c66 2e6e  if axis < self.n
+000246d0: 6469 6d20 2d20 313a 0a20 2020 2020 2020  dim - 1:.       
+000246e0: 2020 2020 2072 6574 7572 6e20 4c65 6765       return Lege
+000246f0: 6e64 7265 2875 6e72 6176 656c 2873 656c  ndre(unravel(sel
+00024700: 662e 5f78 2c20 6178 6973 2c20 7368 6170  f._x, axis, shap
+00024710: 6529 2c20 7365 6c66 2e5f 6465 6772 6565  e), self._degree
+00024720: 290a 0a0a 636c 6173 7320 4368 6f6f 7365  )...class Choose
+00024730: 2841 7272 6179 293a 0a20 2020 2027 2727  (Array):.    '''
+00024740: 4675 6e63 7469 6f6e 2065 7175 6976 616c  Function equival
+00024750: 656e 7420 6f66 203a 6675 6e63 3a60 6e75  ent of :func:`nu
+00024760: 6d70 792e 6368 6f6f 7365 602e 2727 270a  mpy.choose`.'''.
+00024770: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+00024780: 5f28 7365 6c66 2c20 696e 6465 783a 2041  _(self, index: A
+00024790: 7272 6179 2c20 2a63 686f 6963 6573 3a20  rray, *choices: 
+000247a0: 4172 7261 7929 3a0a 2020 2020 2020 2020  Array):.        
+000247b0: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+000247c0: 6528 696e 6465 782c 2041 7272 6179 2920  e(index, Array) 
+000247d0: 616e 6420 696e 6465 782e 6474 7970 6520  and index.dtype 
+000247e0: 3d3d 2069 6e74 2c20 6627 696e 6465 783d  == int, f'index=
+000247f0: 7b69 6e64 6578 2172 7d27 0a20 2020 2020  {index!r}'.     
+00024800: 2020 2061 7373 6572 7420 6973 696e 7374     assert isinst
+00024810: 616e 6365 2863 686f 6963 6573 2c20 7475  ance(choices, tu
+00024820: 706c 6529 2061 6e64 2061 6c6c 2869 7369  ple) and all(isi
+00024830: 6e73 7461 6e63 6528 6368 6f69 6365 2c20  nstance(choice, 
+00024840: 4172 7261 7929 2066 6f72 2063 686f 6963  Array) for choic
+00024850: 6520 696e 2063 686f 6963 6573 292c 2066  e in choices), f
+00024860: 2763 686f 6963 6573 3d7b 6368 6f69 6365  'choices={choice
+00024870: 7321 727d 270a 2020 2020 2020 2020 6474  s!r}'.        dt
+00024880: 7970 6520 3d20 6368 6f69 6365 735b 305d  ype = choices[0]
+00024890: 2e64 7479 7065 0a20 2020 2020 2020 2061  .dtype.        a
+000248a0: 7373 6572 7420 616c 6c28 6368 6f69 6365  ssert all(choice
+000248b0: 2e64 7479 7065 203d 3d20 6474 7970 6520  .dtype == dtype 
+000248c0: 666f 7220 6368 6f69 6365 2069 6e20 6368  for choice in ch
+000248d0: 6f69 6365 735b 313a 5d29 0a20 2020 2020  oices[1:]).     
+000248e0: 2020 2073 6861 7065 203d 2069 6e64 6578     shape = index
+000248f0: 2e73 6861 7065 0a20 2020 2020 2020 2061  .shape.        a
+00024900: 7373 6572 7420 616c 6c28 6571 7561 6c73  ssert all(equals
+00024910: 6861 7065 2863 686f 6963 652e 7368 6170  hape(choice.shap
+00024920: 652c 2073 6861 7065 2920 666f 7220 6368  e, shape) for ch
+00024930: 6f69 6365 2069 6e20 6368 6f69 6365 7329  oice in choices)
+00024940: 0a20 2020 2020 2020 2073 656c 662e 696e  .        self.in
+00024950: 6465 7820 3d20 696e 6465 780a 2020 2020  dex = index.    
+00024960: 2020 2020 7365 6c66 2e63 686f 6963 6573      self.choices
+00024970: 203d 2063 686f 6963 6573 0a20 2020 2020   = choices.     
+00024980: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
+00024990: 745f 5f28 6172 6773 3d28 696e 6465 782c  t__(args=(index,
+000249a0: 292b 6368 6f69 6365 732c 2073 6861 7065  )+choices, shape
+000249b0: 3d73 6861 7065 2c20 6474 7970 653d 6474  =shape, dtype=dt
+000249c0: 7970 6529 0a0a 2020 2020 4073 7461 7469  ype)..    @stati
+000249d0: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
+000249e0: 6576 616c 6628 696e 6465 782c 202a 6368  evalf(index, *ch
+000249f0: 6f69 6365 7329 3a0a 2020 2020 2020 2020  oices):.        
+00024a00: 7265 7475 726e 206e 756d 7079 2e63 686f  return numpy.cho
+00024a10: 6f73 6528 696e 6465 782c 2063 686f 6963  ose(index, choic
+00024a20: 6573 290a 0a20 2020 2064 6566 205f 6465  es)..    def _de
+00024a30: 7269 7661 7469 7665 2873 656c 662c 2076  rivative(self, v
+00024a40: 6172 2c20 7365 656e 293a 0a20 2020 2020  ar, seen):.     
+00024a50: 2020 2072 6574 7572 6e20 4368 6f6f 7365     return Choose
+00024a60: 2861 7070 656e 6461 7865 7328 7365 6c66  (appendaxes(self
+00024a70: 2e69 6e64 6578 2c20 7661 722e 7368 6170  .index, var.shap
+00024a80: 6529 2c20 2a28 6465 7269 7661 7469 7665  e), *(derivative
+00024a90: 2863 686f 6963 652c 2076 6172 2c20 7365  (choice, var, se
+00024aa0: 656e 2920 666f 7220 6368 6f69 6365 2069  en) for choice i
+00024ab0: 6e20 7365 6c66 2e63 686f 6963 6573 2929  n self.choices))
+00024ac0: 0a0a 2020 2020 6465 6620 5f73 696d 706c  ..    def _simpl
+00024ad0: 6966 6965 6428 7365 6c66 293a 0a20 2020  ified(self):.   
+00024ae0: 2020 2020 2069 6620 616c 6c28 6368 6f69       if all(choi
+00024af0: 6365 203d 3d20 7365 6c66 2e63 686f 6963  ce == self.choic
+00024b00: 6573 5b30 5d20 666f 7220 6368 6f69 6365  es[0] for choice
+00024b10: 2069 6e20 7365 6c66 2e63 686f 6963 6573   in self.choices
+00024b20: 5b31 3a5d 293a 0a20 2020 2020 2020 2020  [1:]):.         
+00024b30: 2020 2072 6574 7572 6e20 7365 6c66 2e63     return self.c
+00024b40: 686f 6963 6573 5b30 5d0a 2020 2020 2020  hoices[0].      
+00024b50: 2020 696e 6465 782c 202a 6368 6f69 6365    index, *choice
+00024b60: 732c 2077 6865 7265 203d 2075 6e61 6c69  s, where = unali
+00024b70: 676e 2873 656c 662e 696e 6465 782c 202a  gn(self.index, *
+00024b80: 7365 6c66 2e63 686f 6963 6573 290a 2020  self.choices).  
+00024b90: 2020 2020 2020 6966 206c 656e 2877 6865        if len(whe
+00024ba0: 7265 2920 3c20 7365 6c66 2e6e 6469 6d3a  re) < self.ndim:
+00024bb0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00024bc0: 7572 6e20 616c 6967 6e28 4368 6f6f 7365  urn align(Choose
+00024bd0: 2869 6e64 6578 2c20 2a63 686f 6963 6573  (index, *choices
+00024be0: 292c 2077 6865 7265 2c20 7365 6c66 2e73  ), where, self.s
+00024bf0: 6861 7065 290a 0a20 2020 2064 6566 205f  hape)..    def _
+00024c00: 6d75 6c74 6970 6c79 2873 656c 662c 206f  multiply(self, o
+00024c10: 7468 6572 293a 0a20 2020 2020 2020 2069  ther):.        i
+00024c20: 6620 6973 696e 7374 616e 6365 286f 7468  f isinstance(oth
+00024c30: 6572 2c20 4368 6f6f 7365 2920 616e 6420  er, Choose) and 
+00024c40: 7365 6c66 2e69 6e64 6578 203d 3d20 6f74  self.index == ot
+00024c50: 6865 722e 696e 6465 783a 0a20 2020 2020  her.index:.     
+00024c60: 2020 2020 2020 2072 6574 7572 6e20 4368         return Ch
+00024c70: 6f6f 7365 2873 656c 662e 696e 6465 782c  oose(self.index,
+00024c80: 202a 6d61 7028 6d75 6c74 6970 6c79 2c20   *map(multiply, 
+00024c90: 7365 6c66 2e63 686f 6963 6573 2c20 6f74  self.choices, ot
+00024ca0: 6865 722e 6368 6f69 6365 7329 290a 0a20  her.choices)).. 
+00024cb0: 2020 2064 6566 205f 6765 7428 7365 6c66     def _get(self
+00024cc0: 2c20 692c 2069 7465 6d29 3a0a 2020 2020  , i, item):.    
+00024cd0: 2020 2020 7265 7475 726e 2043 686f 6f73      return Choos
+00024ce0: 6528 6765 7428 7365 6c66 2e69 6e64 6578  e(get(self.index
+00024cf0: 2c20 692c 2069 7465 6d29 2c20 2a28 6765  , i, item), *(ge
+00024d00: 7428 6368 6f69 6365 2c20 692c 2069 7465  t(choice, i, ite
+00024d10: 6d29 2066 6f72 2063 686f 6963 6520 696e  m) for choice in
+00024d20: 2073 656c 662e 6368 6f69 6365 7329 290a   self.choices)).
+00024d30: 0a20 2020 2064 6566 205f 7375 6d28 7365  .    def _sum(se
+00024d40: 6c66 2c20 6178 6973 293a 0a20 2020 2020  lf, axis):.     
+00024d50: 2020 2075 6e61 6c69 676e 6564 2c20 7768     unaligned, wh
+00024d60: 6572 6520 3d20 756e 616c 6967 6e28 7365  ere = unalign(se
+00024d70: 6c66 2e69 6e64 6578 290a 2020 2020 2020  lf.index).      
+00024d80: 2020 6966 2061 7869 7320 6e6f 7420 696e    if axis not in
+00024d90: 2077 6865 7265 3a0a 2020 2020 2020 2020   where:.        
+00024da0: 2020 2020 696e 6465 7820 3d20 616c 6967      index = alig
+00024db0: 6e28 756e 616c 6967 6e65 642c 205b 692d  n(unaligned, [i-
+00024dc0: 2869 203e 2061 7869 7329 2066 6f72 2069  (i > axis) for i
+00024dd0: 2069 6e20 7768 6572 655d 2c20 7365 6c66   in where], self
+00024de0: 2e73 6861 7065 5b3a 6178 6973 5d2b 7365  .shape[:axis]+se
+00024df0: 6c66 2e73 6861 7065 5b61 7869 732b 313a  lf.shape[axis+1:
+00024e00: 5d29 0a20 2020 2020 2020 2020 2020 2072  ]).            r
+00024e10: 6574 7572 6e20 4368 6f6f 7365 2869 6e64  eturn Choose(ind
+00024e20: 6578 2c20 2a28 7375 6d28 6368 6f69 6365  ex, *(sum(choice
+00024e30: 2c20 6178 6973 2920 666f 7220 6368 6f69  , axis) for choi
+00024e40: 6365 2069 6e20 7365 6c66 2e63 686f 6963  ce in self.choic
+00024e50: 6573 2929 0a0a 2020 2020 6465 6620 5f74  es))..    def _t
+00024e60: 616b 6528 7365 6c66 2c20 696e 6465 782c  ake(self, index,
+00024e70: 2061 7869 7329 3a0a 2020 2020 2020 2020   axis):.        
+00024e80: 7265 7475 726e 2043 686f 6f73 6528 5f74  return Choose(_t
+00024e90: 616b 6528 7365 6c66 2e69 6e64 6578 2c20  ake(self.index, 
+00024ea0: 696e 6465 782c 2061 7869 7329 2c20 2a28  index, axis), *(
+00024eb0: 5f74 616b 6528 6368 6f69 6365 2c20 696e  _take(choice, in
+00024ec0: 6465 782c 2061 7869 7329 2066 6f72 2063  dex, axis) for c
+00024ed0: 686f 6963 6520 696e 2073 656c 662e 6368  hoice in self.ch
+00024ee0: 6f69 6365 7329 290a 0a20 2020 2064 6566  oices))..    def
+00024ef0: 205f 7461 6b65 6469 6167 2873 656c 662c   _takediag(self,
+00024f00: 2061 7869 732c 2072 6d61 7869 7329 3a0a   axis, rmaxis):.
+00024f10: 2020 2020 2020 2020 7265 7475 726e 2043          return C
+00024f20: 686f 6f73 6528 7461 6b65 6469 6167 2873  hoose(takediag(s
+00024f30: 656c 662e 696e 6465 782c 2061 7869 732c  elf.index, axis,
+00024f40: 2072 6d61 7869 7329 2c20 2a28 7461 6b65   rmaxis), *(take
+00024f50: 6469 6167 2863 686f 6963 652c 2061 7869  diag(choice, axi
+00024f60: 732c 2072 6d61 7869 7329 2066 6f72 2063  s, rmaxis) for c
+00024f70: 686f 6963 6520 696e 2073 656c 662e 6368  hoice in self.ch
+00024f80: 6f69 6365 7329 290a 0a20 2020 2064 6566  oices))..    def
+00024f90: 205f 7072 6f64 7563 7428 7365 6c66 293a   _product(self):
+00024fa0: 0a20 2020 2020 2020 2075 6e61 6c69 676e  .        unalign
+00024fb0: 6564 2c20 7768 6572 6520 3d20 756e 616c  ed, where = unal
+00024fc0: 6967 6e28 7365 6c66 2e69 6e64 6578 290a  ign(self.index).
+00024fd0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00024fe0: 6e64 696d 2d31 206e 6f74 2069 6e20 7768  ndim-1 not in wh
+00024ff0: 6572 653a 0a20 2020 2020 2020 2020 2020  ere:.           
+00025000: 2069 6e64 6578 203d 2061 6c69 676e 2875   index = align(u
+00025010: 6e61 6c69 676e 6564 2c20 7768 6572 652c  naligned, where,
+00025020: 2073 656c 662e 7368 6170 655b 3a2d 315d   self.shape[:-1]
+00025030: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00025040: 7475 726e 2043 686f 6f73 6528 696e 6465  turn Choose(inde
+00025050: 782c 202a 6d61 7028 5072 6f64 7563 742c  x, *map(Product,
+00025060: 2073 656c 662e 6368 6f69 6365 7329 290a   self.choices)).
+00025070: 0a0a 636c 6173 7320 4e6f 726d 4469 6d28  ..class NormDim(
+00025080: 4172 7261 7929 3a0a 0a20 2020 2064 6566  Array):..    def
+00025090: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+000250a0: 6c65 6e67 7468 3a20 4172 7261 792c 2069  length: Array, i
+000250b0: 6e64 6578 3a20 4172 7261 7929 3a0a 2020  ndex: Array):.  
+000250c0: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+000250d0: 6e73 7461 6e63 6528 6c65 6e67 7468 2c20  nstance(length, 
+000250e0: 4172 7261 7929 2061 6e64 206c 656e 6774  Array) and lengt
+000250f0: 682e 6474 7970 6520 3d3d 2069 6e74 2c20  h.dtype == int, 
+00025100: 6627 6c65 6e67 7468 3d7b 6c65 6e67 7468  f'length={length
+00025110: 2172 7d27 0a20 2020 2020 2020 2061 7373  !r}'.        ass
+00025120: 6572 7420 6973 696e 7374 616e 6365 2869  ert isinstance(i
+00025130: 6e64 6578 2c20 4172 7261 7929 2061 6e64  ndex, Array) and
+00025140: 2069 6e64 6578 2e64 7479 7065 203d 3d20   index.dtype == 
+00025150: 696e 742c 2066 2769 6e64 6578 3d7b 696e  int, f'index={in
+00025160: 6465 7821 727d 270a 2020 2020 2020 2020  dex!r}'.        
+00025170: 6173 7365 7274 2065 7175 616c 7368 6170  assert equalshap
+00025180: 6528 6c65 6e67 7468 2e73 6861 7065 2c20  e(length.shape, 
+00025190: 696e 6465 782e 7368 6170 6529 0a20 2020  index.shape).   
+000251a0: 2020 2020 2023 2054 6865 2066 6f6c 6c6f       # The follo
+000251b0: 7769 6e67 2063 6f72 6e65 7220 6361 7365  wing corner case
+000251c0: 7320 6d61 6b65 7320 7468 6520 6173 7365  s makes the asse
+000251d0: 7274 696f 6e20 6661 696c 2c20 6865 6e63  rtion fail, henc
+000251e0: 6520 7765 2063 616e 206f 6e6c 790a 2020  e we can only.  
+000251f0: 2020 2020 2020 2320 6173 7365 7274 2074        # assert t
+00025200: 6865 2062 6f75 6e64 7320 6966 2074 6865  he bounds if the
+00025210: 2061 7272 6179 7320 6172 6520 6775 6172   arrays are guar
+00025220: 616e 7465 6564 2074 6f20 6265 2075 6e65  anteed to be une
+00025230: 6d70 7479 3a0a 2020 2020 2020 2020 230a  mpty:.        #.
+00025240: 2020 2020 2020 2020 2320 2020 2020 5461          #     Ta
+00025250: 6b65 2866 756e 632c 204e 6f72 6d44 696d  ke(func, NormDim
+00025260: 2866 756e 632e 7368 6170 655b 2d31 5d2c  (func.shape[-1],
+00025270: 2052 616e 6765 2830 2920 2b20 6675 6e63   Range(0) + func
+00025280: 2e73 6861 7065 5b2d 315d 2929 0a20 2020  .shape[-1])).   
+00025290: 2020 2020 2069 6620 616c 6c28 6e2e 5f69       if all(n._i
+000252a0: 6e74 626f 756e 6473 5b30 5d20 3e20 3020  ntbounds[0] > 0 
+000252b0: 666f 7220 6e20 696e 2069 6e64 6578 2e73  for n in index.s
+000252c0: 6861 7065 293a 0a20 2020 2020 2020 2020  hape):.         
+000252d0: 2020 2061 7373 6572 7420 2d6c 656e 6774     assert -lengt
+000252e0: 682e 5f69 6e74 626f 756e 6473 5b31 5d20  h._intbounds[1] 
+000252f0: 3c3d 2069 6e64 6578 2e5f 696e 7462 6f75  <= index._intbou
+00025300: 6e64 735b 305d 2061 6e64 2069 6e64 6578  nds[0] and index
+00025310: 2e5f 696e 7462 6f75 6e64 735b 315d 203c  ._intbounds[1] <
+00025320: 3d20 6c65 6e67 7468 2e5f 696e 7462 6f75  = length._intbou
+00025330: 6e64 735b 315d 202d 2031 0a20 2020 2020  nds[1] - 1.     
+00025340: 2020 2073 656c 662e 6c65 6e67 7468 203d     self.length =
+00025350: 206c 656e 6774 680a 2020 2020 2020 2020   length.        
+00025360: 7365 6c66 2e69 6e64 6578 203d 2069 6e64  self.index = ind
+00025370: 6578 0a20 2020 2020 2020 2073 7570 6572  ex.        super
+00025380: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
+00025390: 3d28 6c65 6e67 7468 2c20 696e 6465 7829  =(length, index)
+000253a0: 2c20 7368 6170 653d 696e 6465 782e 7368  , shape=index.sh
+000253b0: 6170 652c 2064 7479 7065 3d69 6e64 6578  ape, dtype=index
+000253c0: 2e64 7479 7065 290a 0a20 2020 2040 7374  .dtype)..    @st
+000253d0: 6174 6963 6d65 7468 6f64 0a20 2020 2064  aticmethod.    d
+000253e0: 6566 2065 7661 6c66 286c 656e 6774 682c  ef evalf(length,
+000253f0: 2069 6e64 6578 293a 0a20 2020 2020 2020   index):.       
+00025400: 2061 7373 6572 7420 6c65 6e67 7468 2e73   assert length.s
+00025410: 6861 7065 203d 3d20 696e 6465 782e 7368  hape == index.sh
+00025420: 6170 650a 2020 2020 2020 2020 6173 7365  ape.        asse
+00025430: 7274 206c 656e 6774 682e 6474 7970 652e  rt length.dtype.
+00025440: 6b69 6e64 203d 3d20 2769 270a 2020 2020  kind == 'i'.    
+00025450: 2020 2020 6173 7365 7274 2069 6e64 6578      assert index
+00025460: 2e64 7479 7065 2e6b 696e 6420 3d3d 2027  .dtype.kind == '
+00025470: 6927 0a20 2020 2020 2020 2072 6573 756c  i'.        resul
+00025480: 7420 3d20 6e75 6d70 792e 656d 7074 7928  t = numpy.empty(
+00025490: 696e 6465 782e 7368 6170 652c 2064 7479  index.shape, dty
+000254a0: 7065 3d69 6e74 290a 2020 2020 2020 2020  pe=int).        
+000254b0: 666f 7220 6920 696e 206e 756d 7079 2e6e  for i in numpy.n
+000254c0: 6469 6e64 6578 2869 6e64 6578 2e73 6861  dindex(index.sha
+000254d0: 7065 293a 0a20 2020 2020 2020 2020 2020  pe):.           
+000254e0: 2072 6573 756c 745b 695d 203d 206e 756d   result[i] = num
+000254f0: 6572 6963 2e6e 6f72 6d64 696d 286c 656e  eric.normdim(len
+00025500: 6774 685b 695d 2c20 696e 6465 785b 695d  gth[i], index[i]
+00025510: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00025520: 2072 6573 756c 740a 0a20 2020 2064 6566   result..    def
+00025530: 205f 7369 6d70 6c69 6669 6564 2873 656c   _simplified(sel
+00025540: 6629 3a0a 2020 2020 2020 2020 6c6f 7765  f):.        lowe
+00025550: 725f 6c65 6e67 7468 2c20 7570 7065 725f  r_length, upper_
+00025560: 6c65 6e67 7468 203d 2073 656c 662e 6c65  length = self.le
+00025570: 6e67 7468 2e5f 696e 7462 6f75 6e64 730a  ngth._intbounds.
+00025580: 2020 2020 2020 2020 6c6f 7765 725f 696e          lower_in
+00025590: 6465 782c 2075 7070 6572 5f69 6e64 6578  dex, upper_index
+000255a0: 203d 2073 656c 662e 696e 6465 782e 5f69   = self.index._i
+000255b0: 6e74 626f 756e 6473 0a20 2020 2020 2020  ntbounds.       
+000255c0: 2069 6620 3020 3c3d 206c 6f77 6572 5f69   if 0 <= lower_i
+000255d0: 6e64 6578 2061 6e64 2075 7070 6572 5f69  ndex and upper_i
+000255e0: 6e64 6578 203c 206c 6f77 6572 5f6c 656e  ndex < lower_len
+000255f0: 6774 683a 0a20 2020 2020 2020 2020 2020  gth:.           
+00025600: 2072 6574 7572 6e20 7365 6c66 2e69 6e64   return self.ind
+00025610: 6578 0a20 2020 2020 2020 2069 6620 6973  ex.        if is
+00025620: 696e 7374 616e 6365 286c 6f77 6572 5f6c  instance(lower_l
+00025630: 656e 6774 682c 2069 6e74 2920 616e 6420  ength, int) and 
+00025640: 6c6f 7765 725f 6c65 6e67 7468 203d 3d20  lower_length == 
+00025650: 7570 7065 725f 6c65 6e67 7468 2061 6e64  upper_length and
+00025660: 202d 6c6f 7765 725f 6c65 6e67 7468 203c   -lower_length <
+00025670: 3d20 6c6f 7765 725f 696e 6465 7820 616e  = lower_index an
+00025680: 6420 7570 7065 725f 696e 6465 7820 3c20  d upper_index < 
+00025690: 303a 0a20 2020 2020 2020 2020 2020 2072  0:.            r
+000256a0: 6574 7572 6e20 7365 6c66 2e69 6e64 6578  eturn self.index
+000256b0: 202b 206c 6f77 6572 5f6c 656e 6774 680a   + lower_length.
+000256c0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+000256d0: 6c65 6e67 7468 2e69 7363 6f6e 7374 616e  length.isconstan
+000256e0: 7420 616e 6420 7365 6c66 2e69 6e64 6578  t and self.index
+000256f0: 2e69 7363 6f6e 7374 616e 743a 0a20 2020  .isconstant:.   
+00025700: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00025710: 636f 6e73 7461 6e74 2873 656c 662e 6576  constant(self.ev
+00025720: 616c 2829 290a 0a20 2020 2064 6566 205f  al())..    def _
+00025730: 696e 7462 6f75 6e64 735f 696d 706c 2873  intbounds_impl(s
+00025740: 656c 6629 3a0a 2020 2020 2020 2020 6c6f  elf):.        lo
+00025750: 7765 725f 6c65 6e67 7468 2c20 7570 7065  wer_length, uppe
+00025760: 725f 6c65 6e67 7468 203d 2073 656c 662e  r_length = self.
+00025770: 6c65 6e67 7468 2e5f 696e 7462 6f75 6e64  length._intbound
+00025780: 730a 2020 2020 2020 2020 6c6f 7765 725f  s.        lower_
+00025790: 696e 6465 782c 2075 7070 6572 5f69 6e64  index, upper_ind
+000257a0: 6578 203d 2073 656c 662e 696e 6465 782e  ex = self.index.
+000257b0: 5f69 6e74 626f 756e 6473 0a20 2020 2020  _intbounds.     
+000257c0: 2020 2069 6620 6c6f 7765 725f 696e 6465     if lower_inde
+000257d0: 7820 3e3d 2030 3a0a 2020 2020 2020 2020  x >= 0:.        
+000257e0: 2020 2020 7265 7475 726e 206d 696e 286c      return min(l
+000257f0: 6f77 6572 5f69 6e64 6578 2c20 7570 7065  ower_index, uppe
+00025800: 725f 6c65 6e67 7468 202d 2031 292c 206d  r_length - 1), m
+00025810: 696e 2875 7070 6572 5f69 6e64 6578 2c20  in(upper_index, 
+00025820: 7570 7065 725f 6c65 6e67 7468 202d 2031  upper_length - 1
+00025830: 290a 2020 2020 2020 2020 656c 6966 2075  ).        elif u
+00025840: 7070 6572 5f69 6e64 6578 203c 2030 2061  pper_index < 0 a
+00025850: 6e64 2069 7369 6e73 7461 6e63 6528 6c6f  nd isinstance(lo
+00025860: 7765 725f 6c65 6e67 7468 2c20 696e 7429  wer_length, int)
+00025870: 2061 6e64 206c 6f77 6572 5f6c 656e 6774   and lower_lengt
+00025880: 6820 3d3d 2075 7070 6572 5f6c 656e 6774  h == upper_lengt
+00025890: 683a 0a20 2020 2020 2020 2020 2020 2072  h:.            r
+000258a0: 6574 7572 6e20 6d61 7828 6c6f 7765 725f  eturn max(lower_
+000258b0: 696e 6465 7820 2b20 6c6f 7765 725f 6c65  index + lower_le
+000258c0: 6e67 7468 2c20 3029 2c20 6d61 7828 7570  ngth, 0), max(up
+000258d0: 7065 725f 696e 6465 7820 2b20 6c6f 7765  per_index + lowe
+000258e0: 725f 6c65 6e67 7468 2c20 3029 0a20 2020  r_length, 0).   
+000258f0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00025900: 2020 2020 2020 2072 6574 7572 6e20 302c         return 0,
+00025910: 2075 7070 6572 5f6c 656e 6774 6820 2d20   upper_length - 
+00025920: 310a 0a0a 636c 6173 7320 5472 616e 7366  1...class Transf
+00025930: 6f72 6d43 6f6f 7264 7328 4172 7261 7929  ormCoords(Array)
+00025940: 3a0a 2020 2020 2727 2754 7261 6e73 666f  :.    '''Transfo
+00025950: 726d 2063 6f6f 7264 696e 6174 6573 2066  rm coordinates f
+00025960: 726f 6d20 6f6e 6520 636f 6f72 6469 6e61  rom one coordina
+00025970: 7465 2073 7973 7465 6d20 746f 2061 6e6f  te system to ano
+00025980: 7468 6572 2028 7370 6174 6961 6c20 7061  ther (spatial pa
+00025990: 7274 290a 0a20 2020 2041 7267 730a 2020  rt)..    Args.  
+000259a0: 2020 2d2d 2d2d 0a20 2020 2074 6172 6765    ----.    targe
+000259b0: 7420 3a20 3a63 6c61 7373 3a60 6e75 7469  t : :class:`nuti
+000259c0: 6c73 2e74 7261 6e73 666f 726d 7365 712e  ls.transformseq.
+000259d0: 5472 616e 7366 6f72 6d73 602c 206f 7074  Transforms`, opt
+000259e0: 696f 6e61 6c0a 2020 2020 2020 2020 5468  ional.        Th
+000259f0: 6520 7461 7267 6574 2063 6f6f 7264 696e  e target coordin
+00025a00: 6174 6520 7379 7374 656d 2e20 4966 2060  ate system. If `
+00025a10: 4e6f 6e65 6020 7468 6520 7461 7267 6574  None` the target
+00025a20: 2069 7320 726f 6f74 2063 6f6f 7264 696e   is root coordin
+00025a30: 6174 650a 2020 2020 2020 2020 7379 7374  ate.        syst
+00025a40: 656d 2e0a 2020 2020 736f 7572 6365 203a  em..    source :
+00025a50: 203a 636c 6173 733a 606e 7574 696c 732e   :class:`nutils.
+00025a60: 7472 616e 7366 6f72 6d73 6571 2e54 7261  transformseq.Tra
+00025a70: 6e73 666f 726d 7360 0a20 2020 2020 2020  nsforms`.       
+00025a80: 2054 6865 2073 6f75 7263 6520 636f 6f72   The source coor
+00025a90: 6469 6e61 7465 2073 7973 7465 6d2e 0a20  dinate system.. 
+00025aa0: 2020 2069 6e64 6578 203a 2073 6361 6c61     index : scala
+00025ab0: 722c 2069 6e74 6567 6572 203a 636c 6173  r, integer :clas
+00025ac0: 733a 6041 7272 6179 600a 2020 2020 2020  s:`Array`.      
+00025ad0: 2020 5468 6520 696e 6465 7820 7061 7274    The index part
+00025ae0: 206f 6620 7468 6520 736f 7572 6365 2063   of the source c
+00025af0: 6f6f 7264 696e 6174 6573 2e0a 2020 2020  oordinates..    
+00025b00: 636f 6f72 6473 203a 203a 636c 6173 733a  coords : :class:
+00025b10: 6041 7272 6179 600a 2020 2020 2020 2020  `Array`.        
+00025b20: 5468 6520 7370 6174 6961 6c20 7061 7274  The spatial part
+00025b30: 206f 6620 7468 6520 736f 7572 6365 2063   of the source c
+00025b40: 6f6f 7264 696e 6174 6573 2e0a 2020 2020  oordinates..    
+00025b50: 2727 270a 0a20 2020 2064 6566 205f 5f69  '''..    def __i
+00025b60: 6e69 745f 5f28 7365 6c66 2c20 7461 7267  nit__(self, targ
+00025b70: 6574 2c20 736f 7572 6365 2c20 696e 6465  et, source, inde
+00025b80: 783a 2041 7272 6179 2c20 636f 6f72 6473  x: Array, coords
+00025b90: 3a20 4172 7261 7929 3a0a 2020 2020 2020  : Array):.      
+00025ba0: 2020 6966 2069 6e64 6578 2e64 7479 7065    if index.dtype
+00025bb0: 2021 3d20 696e 7420 6f72 2069 6e64 6578   != int or index
+00025bc0: 2e6e 6469 6d20 213d 2030 3a0a 2020 2020  .ndim != 0:.    
+00025bd0: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00025be0: 6c75 6545 7272 6f72 2827 6172 6775 6d65  lueError('argume
+00025bf0: 6e74 2060 696e 6465 7860 206d 7573 7420  nt `index` must 
+00025c00: 6265 2061 2073 6361 6c61 722c 2069 6e74  be a scalar, int
+00025c10: 6567 6572 2060 6e75 7469 6c73 2e65 7661  eger `nutils.eva
+00025c20: 6c75 6162 6c65 2e41 7272 6179 6027 290a  luable.Array`').
+00025c30: 2020 2020 2020 2020 6966 2063 6f6f 7264          if coord
+00025c40: 732e 6474 7970 6520 213d 2066 6c6f 6174  s.dtype != float
+00025c50: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+00025c60: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
+00025c70: 6172 6775 6d65 6e74 2060 636f 6f72 6473  argument `coords
+00025c80: 6020 6d75 7374 2062 6520 6120 7265 616c  ` must be a real
+00025c90: 2d76 616c 7565 6420 6172 7261 7920 7769  -valued array wi
+00025ca0: 7468 2061 7420 6c65 6173 7420 6f6e 6520  th at least one 
+00025cb0: 6178 6973 2729 0a20 2020 2020 2020 2073  axis').        s
+00025cc0: 656c 662e 5f74 6172 6765 7420 3d20 7461  elf._target = ta
+00025cd0: 7267 6574 0a20 2020 2020 2020 2073 656c  rget.        sel
+00025ce0: 662e 5f73 6f75 7263 6520 3d20 736f 7572  f._source = sour
+00025cf0: 6365 0a20 2020 2020 2020 2073 656c 662e  ce.        self.
+00025d00: 5f69 6e64 6578 203d 2069 6e64 6578 0a20  _index = index. 
+00025d10: 2020 2020 2020 2073 656c 662e 5f63 6f6f         self._coo
+00025d20: 7264 7320 3d20 636f 6f72 6473 0a20 2020  rds = coords.   
+00025d30: 2020 2020 2074 6172 6765 745f 6469 6d20       target_dim 
+00025d40: 3d20 736f 7572 6365 2e74 6f64 696d 7320  = source.todims 
+00025d50: 6966 2074 6172 6765 7420 6973 204e 6f6e  if target is Non
+00025d60: 6520 656c 7365 2074 6172 6765 742e 6672  e else target.fr
+00025d70: 6f6d 6469 6d73 0a20 2020 2020 2020 2073  omdims.        s
+00025d80: 7570 6572 2829 2e5f 5f69 6e69 745f 5f28  uper().__init__(
+00025d90: 6172 6773 3d28 696e 6465 782c 2063 6f6f  args=(index, coo
+00025da0: 7264 7329 2c20 7368 6170 653d 282a 636f  rds), shape=(*co
+00025db0: 6f72 6473 2e73 6861 7065 5b3a 2d31 5d2c  ords.shape[:-1],
+00025dc0: 2063 6f6e 7374 616e 7428 7461 7267 6574   constant(target
+00025dd0: 5f64 696d 2929 2c20 6474 7970 653d 666c  _dim)), dtype=fl
+00025de0: 6f61 7429 0a0a 2020 2020 6465 6620 6576  oat)..    def ev
+00025df0: 616c 6628 7365 6c66 2c20 696e 6465 782c  alf(self, index,
+00025e00: 2063 6f6f 7264 7329 3a0a 2020 2020 2020   coords):.      
+00025e10: 2020 6368 6169 6e20 3d20 7365 6c66 2e5f    chain = self._
+00025e20: 736f 7572 6365 5b69 6e64 6578 2e5f 5f69  source[index.__i
+00025e30: 6e64 6578 5f5f 2829 5d0a 2020 2020 2020  ndex__()].      
+00025e40: 2020 6966 2073 656c 662e 5f74 6172 6765    if self._targe
+00025e50: 7420 6973 206e 6f74 204e 6f6e 653a 0a20  t is not None:. 
+00025e60: 2020 2020 2020 2020 2020 205f 2c20 6368             _, ch
+00025e70: 6169 6e20 3d20 7365 6c66 2e5f 7461 7267  ain = self._targ
+00025e80: 6574 2e69 6e64 6578 5f77 6974 685f 7461  et.index_with_ta
+00025e90: 696c 2863 6861 696e 290a 2020 2020 2020  il(chain).      
+00025ea0: 2020 7265 7475 726e 2066 756e 6374 6f6f    return functoo
+00025eb0: 6c73 2e72 6564 7563 6528 6c61 6d62 6461  ls.reduce(lambda
+00025ec0: 2063 2c20 743a 2074 2e61 7070 6c79 2863   c, t: t.apply(c
+00025ed0: 292c 2072 6576 6572 7365 6428 6368 6169  ), reversed(chai
+00025ee0: 6e29 2c20 636f 6f72 6473 290a 0a20 2020  n), coords)..   
+00025ef0: 2064 6566 205f 6465 7269 7661 7469 7665   def _derivative
+00025f00: 2873 656c 662c 2076 6172 2c20 7365 656e  (self, var, seen
+00025f10: 293a 0a20 2020 2020 2020 206c 696e 6561  ):.        linea
+00025f20: 7220 3d20 5472 616e 7366 6f72 6d4c 696e  r = TransformLin
+00025f30: 6561 7228 7365 6c66 2e5f 7461 7267 6574  ear(self._target
+00025f40: 2c20 7365 6c66 2e5f 736f 7572 6365 2c20  , self._source, 
+00025f50: 7365 6c66 2e5f 696e 6465 7829 0a20 2020  self._index).   
+00025f60: 2020 2020 2064 636f 6f72 6473 203d 2064       dcoords = d
+00025f70: 6572 6976 6174 6976 6528 7365 6c66 2e5f  erivative(self._
+00025f80: 636f 6f72 6473 2c20 7661 722c 2073 6565  coords, var, see
+00025f90: 6e29 0a20 2020 2020 2020 2072 6574 7572  n).        retur
+00025fa0: 6e20 6569 6e73 756d 2827 696a 2c41 6a42  n einsum('ij,AjB
+00025fb0: 2d3e 4169 4227 2c20 6c69 6e65 6172 2c20  ->AiB', linear, 
+00025fc0: 6463 6f6f 7264 732c 2041 3d73 656c 662e  dcoords, A=self.
+00025fd0: 5f63 6f6f 7264 732e 6e64 696d 202d 2031  _coords.ndim - 1
+00025fe0: 2c20 423d 7661 722e 6e64 696d 290a 0a20  , B=var.ndim).. 
+00025ff0: 2020 2064 6566 205f 7369 6d70 6c69 6669     def _simplifi
+00026000: 6564 2873 656c 6629 3a0a 2020 2020 2020  ed(self):.      
+00026010: 2020 6966 2073 656c 662e 5f74 6172 6765    if self._targe
+00026020: 7420 3d3d 2073 656c 662e 5f73 6f75 7263  t == self._sourc
+00026030: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+00026040: 6574 7572 6e20 7365 6c66 2e5f 636f 6f72  eturn self._coor
+00026050: 6473 0a20 2020 2020 2020 2063 6178 203d  ds.        cax =
+00026060: 2073 656c 662e 6e64 696d 202d 2031 0a20   self.ndim - 1. 
+00026070: 2020 2020 2020 2063 6f6f 7264 732c 2077         coords, w
+00026080: 6865 7265 203d 2075 6e61 6c69 676e 2873  here = unalign(s
+00026090: 656c 662e 5f63 6f6f 7264 732c 206e 6178  elf._coords, nax
+000260a0: 6573 3d63 6178 290a 2020 2020 2020 2020  es=cax).        
+000260b0: 6966 206c 656e 2877 6865 7265 2920 3c20  if len(where) < 
+000260c0: 6361 783a 0a20 2020 2020 2020 2020 2020  cax:.           
+000260d0: 2072 6574 7572 6e20 616c 6967 6e28 5472   return align(Tr
+000260e0: 616e 7366 6f72 6d43 6f6f 7264 7328 7365  ansformCoords(se
+000260f0: 6c66 2e5f 7461 7267 6574 2c20 7365 6c66  lf._target, self
+00026100: 2e5f 736f 7572 6365 2c20 7365 6c66 2e5f  ._source, self._
+00026110: 696e 6465 782c 2063 6f6f 7264 7329 2c20  index, coords), 
+00026120: 282a 7768 6572 652c 2063 6178 292c 2073  (*where, cax), s
+00026130: 656c 662e 7368 6170 6529 0a0a 0a63 6c61  elf.shape)...cla
+00026140: 7373 2054 7261 6e73 666f 726d 496e 6465  ss TransformInde
+00026150: 7828 4172 7261 7929 3a0a 2020 2020 2727  x(Array):.    ''
+00026160: 2754 7261 6e73 666f 726d 2063 6f6f 7264  'Transform coord
+00026170: 696e 6174 6573 2066 726f 6d20 6f6e 6520  inates from one 
+00026180: 636f 6f72 6469 6e61 7465 2073 7973 7465  coordinate syste
+00026190: 6d20 746f 2061 6e6f 7468 6572 2028 696e  m to another (in
+000261a0: 6465 7820 7061 7274 290a 0a20 2020 2041  dex part)..    A
+000261b0: 7267 730a 2020 2020 2d2d 2d2d 0a20 2020  rgs.    ----.   
+000261c0: 2074 6172 6765 7420 3a20 3a63 6c61 7373   target : :class
+000261d0: 3a60 6e75 7469 6c73 2e74 7261 6e73 666f  :`nutils.transfo
+000261e0: 726d 7365 712e 5472 616e 7366 6f72 6d73  rmseq.Transforms
+000261f0: 602c 206f 7074 696f 6e61 6c0a 2020 2020  `, optional.    
+00026200: 2020 2020 5468 6520 7461 7267 6574 2063      The target c
+00026210: 6f6f 7264 696e 6174 6520 7379 7374 656d  oordinate system
+00026220: 2e20 4966 2060 4e6f 6e65 6020 7468 6520  . If `None` the 
+00026230: 7461 7267 6574 2069 7320 7468 6520 726f  target is the ro
+00026240: 6f74 0a20 2020 2020 2020 2063 6f6f 7264  ot.        coord
+00026250: 696e 6174 6520 7379 7374 656d 2e0a 2020  inate system..  
+00026260: 2020 736f 7572 6365 203a 203a 636c 6173    source : :clas
+00026270: 733a 606e 7574 696c 732e 7472 616e 7366  s:`nutils.transf
+00026280: 6f72 6d73 6571 2e54 7261 6e73 666f 726d  ormseq.Transform
+00026290: 7360 0a20 2020 2020 2020 2054 6865 2073  s`.        The s
+000262a0: 6f75 7263 6520 636f 6f72 6469 6e61 7465  ource coordinate
+000262b0: 2073 7973 7465 6d2e 0a20 2020 2069 6e64   system..    ind
+000262c0: 6578 203a 2073 6361 6c61 722c 2069 6e74  ex : scalar, int
+000262d0: 6567 6572 203a 636c 6173 733a 6041 7272  eger :class:`Arr
+000262e0: 6179 600a 2020 2020 2020 2020 5468 6520  ay`.        The 
+000262f0: 696e 6465 7820 7061 7274 206f 6620 7468  index part of th
+00026300: 6520 736f 7572 6365 2063 6f6f 7264 696e  e source coordin
+00026310: 6174 6573 2e0a 2020 2020 2727 270a 0a20  ates..    '''.. 
+00026320: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
+00026330: 7365 6c66 2c20 7461 7267 6574 2c20 736f  self, target, so
+00026340: 7572 6365 2c20 696e 6465 783a 2041 7272  urce, index: Arr
+00026350: 6179 293a 0a20 2020 2020 2020 2069 6620  ay):.        if 
+00026360: 696e 6465 782e 6474 7970 6520 213d 2069  index.dtype != i
+00026370: 6e74 206f 7220 696e 6465 782e 6e64 696d  nt or index.ndim
+00026380: 2021 3d20 303a 0a20 2020 2020 2020 2020   != 0:.         
+00026390: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+000263a0: 726f 7228 2761 7267 756d 656e 7420 6069  ror('argument `i
+000263b0: 6e64 6578 6020 6d75 7374 2062 6520 6120  ndex` must be a 
+000263c0: 7363 616c 6172 2c20 696e 7465 6765 7220  scalar, integer 
+000263d0: 606e 7574 696c 732e 6576 616c 7561 626c  `nutils.evaluabl
+000263e0: 652e 4172 7261 7960 2729 0a20 2020 2020  e.Array`').     
+000263f0: 2020 2073 656c 662e 5f74 6172 6765 7420     self._target 
+00026400: 3d20 7461 7267 6574 0a20 2020 2020 2020  = target.       
+00026410: 2073 656c 662e 5f73 6f75 7263 6520 3d20   self._source = 
+00026420: 736f 7572 6365 0a20 2020 2020 2020 2073  source.        s
+00026430: 656c 662e 5f69 6e64 6578 203d 2069 6e64  elf._index = ind
+00026440: 6578 0a20 2020 2020 2020 2073 7570 6572  ex.        super
+00026450: 2829 2e5f 5f69 6e69 745f 5f28 6172 6773  ().__init__(args
+00026460: 3d28 696e 6465 782c 292c 2073 6861 7065  =(index,), shape
+00026470: 3d28 292c 2064 7479 7065 3d69 6e74 290a  =(), dtype=int).
+00026480: 0a20 2020 2064 6566 2065 7661 6c66 2873  .    def evalf(s
+00026490: 656c 662c 2069 6e64 6578 293a 0a20 2020  elf, index):.   
+000264a0: 2020 2020 2069 6620 7365 6c66 2e5f 7461       if self._ta
+000264b0: 7267 6574 2069 7320 6e6f 7420 4e6f 6e65  rget is not None
+000264c0: 3a0a 2020 2020 2020 2020 2020 2020 696e  :.            in
+000264d0: 6465 782c 205f 203d 2073 656c 662e 5f74  dex, _ = self._t
+000264e0: 6172 6765 742e 696e 6465 785f 7769 7468  arget.index_with
+000264f0: 5f74 6169 6c28 7365 6c66 2e5f 736f 7572  _tail(self._sour
+00026500: 6365 5b69 6e64 6578 2e5f 5f69 6e64 6578  ce[index.__index
+00026510: 5f5f 2829 5d29 0a20 2020 2020 2020 2065  __()]).        e
+00026520: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00026530: 2069 6e64 6578 203d 2030 0a20 2020 2020   index = 0.     
+00026540: 2020 2072 6574 7572 6e20 6e75 6d70 792e     return numpy.
+00026550: 6172 7261 7928 696e 6465 7829 0a0a 2020  array(index)..  
+00026560: 2020 6465 6620 5f69 6e74 626f 756e 6473    def _intbounds
+00026570: 5f69 6d70 6c28 7365 6c66 293a 0a20 2020  _impl(self):.   
+00026580: 2020 2020 206c 656e 5f74 6172 6765 7420       len_target 
+00026590: 3d20 3120 6966 2073 656c 662e 5f74 6172  = 1 if self._tar
+000265a0: 6765 7420 6973 204e 6f6e 6520 656c 7365  get is None else
+000265b0: 206c 656e 2873 656c 662e 5f74 6172 6765   len(self._targe
+000265c0: 7429 0a20 2020 2020 2020 2072 6574 7572  t).        retur
+000265d0: 6e20 302c 206c 656e 5f74 6172 6765 7420  n 0, len_target 
+000265e0: 2d20 310a 0a20 2020 2064 6566 205f 7369  - 1..    def _si
+000265f0: 6d70 6c69 6669 6564 2873 656c 6629 3a0a  mplified(self):.
+00026600: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00026610: 5f74 6172 6765 7420 6973 204e 6f6e 653a  _target is None:
+00026620: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00026630: 7572 6e20 6f6e 6573 2828 312c 292c 2064  urn ones((1,), d
+00026640: 7479 7065 3d69 6e74 290a 2020 2020 2020  type=int).      
+00026650: 2020 656c 6966 2073 656c 662e 5f74 6172    elif self._tar
+00026660: 6765 7420 3d3d 2073 656c 662e 5f73 6f75  get == self._sou
+00026670: 7263 653a 0a20 2020 2020 2020 2020 2020  rce:.           
+00026680: 2072 6574 7572 6e20 7365 6c66 2e5f 696e   return self._in
+00026690: 6465 780a 0a0a 636c 6173 7320 5472 616e  dex...class Tran
+000266a0: 7366 6f72 6d4c 696e 6561 7228 4172 7261  sformLinear(Arra
+000266b0: 7929 3a0a 2020 2020 2727 274c 696e 6561  y):.    '''Linea
+000266c0: 7220 7061 7274 206f 6620 6120 636f 6f72  r part of a coor
+000266d0: 6469 6e61 7465 2074 7261 6e73 666f 726d  dinate transform
+000266e0: 6174 696f 6e0a 0a20 2020 2041 7267 730a  ation..    Args.
+000266f0: 2020 2020 2d2d 2d2d 0a20 2020 2074 6172      ----.    tar
+00026700: 6765 7420 3a20 3a63 6c61 7373 3a60 6e75  get : :class:`nu
+00026710: 7469 6c73 2e74 7261 6e73 666f 726d 7365  tils.transformse
+00026720: 712e 5472 616e 7366 6f72 6d73 602c 206f  q.Transforms`, o
+00026730: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
+00026740: 5468 6520 7461 7267 6574 2063 6f6f 7264  The target coord
+00026750: 696e 6174 6520 7379 7374 656d 2e20 4966  inate system. If
+00026760: 2060 4e6f 6e65 6020 7468 6520 7461 7267   `None` the targ
+00026770: 6574 2069 7320 7468 6520 726f 6f74 0a20  et is the root. 
+00026780: 2020 2020 2020 2063 6f6f 7264 696e 6174         coordinat
+00026790: 6520 7379 7374 656d 2e0a 2020 2020 736f  e system..    so
+000267a0: 7572 6365 203a 203a 636c 6173 733a 606e  urce : :class:`n
+000267b0: 7574 696c 732e 7472 616e 7366 6f72 6d73  utils.transforms
+000267c0: 6571 2e54 7261 6e73 666f 726d 7360 0a20  eq.Transforms`. 
+000267d0: 2020 2020 2020 2054 6865 2073 6f75 7263         The sourc
+000267e0: 6520 636f 6f72 6469 6e61 7465 2073 7973  e coordinate sys
+000267f0: 7465 6d2e 0a20 2020 2069 6e64 6578 203a  tem..    index :
+00026800: 2073 6361 6c61 722c 2069 6e74 6567 6572   scalar, integer
+00026810: 203a 636c 6173 733a 6041 7272 6179 600a   :class:`Array`.
+00026820: 2020 2020 2020 2020 5468 6520 696e 6465          The inde
+00026830: 7820 7061 7274 206f 6620 7468 6520 736f  x part of the so
+00026840: 7572 6365 2063 6f6f 7264 696e 6174 6573  urce coordinates
+00026850: 2e0a 2020 2020 2727 270a 0a20 2020 2064  ..    '''..    d
+00026860: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+00026870: 2c20 7461 7267 6574 2c20 736f 7572 6365  , target, source
+00026880: 2c20 696e 6465 783a 2041 7272 6179 293a  , index: Array):
+00026890: 0a20 2020 2020 2020 2069 6620 696e 6465  .        if inde
+000268a0: 782e 6474 7970 6520 213d 2069 6e74 206f  x.dtype != int o
+000268b0: 7220 696e 6465 782e 6e64 696d 2021 3d20  r index.ndim != 
+000268c0: 303a 0a20 2020 2020 2020 2020 2020 2072  0:.            r
+000268d0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+000268e0: 2761 7267 756d 656e 7420 6069 6e64 6578  'argument `index
+000268f0: 6020 6d75 7374 2062 6520 6120 7363 616c  ` must be a scal
+00026900: 6172 2c20 696e 7465 6765 7220 606e 7574  ar, integer `nut
+00026910: 696c 732e 6576 616c 7561 626c 652e 4172  ils.evaluable.Ar
+00026920: 7261 7960 2729 0a20 2020 2020 2020 2073  ray`').        s
+00026930: 656c 662e 5f74 6172 6765 7420 3d20 7461  elf._target = ta
+00026940: 7267 6574 0a20 2020 2020 2020 2073 656c  rget.        sel
+00026950: 662e 5f73 6f75 7263 6520 3d20 736f 7572  f._source = sour
+00026960: 6365 0a20 2020 2020 2020 2074 6172 6765  ce.        targe
+00026970: 745f 6469 6d20 3d20 736f 7572 6365 2e74  t_dim = source.t
+00026980: 6f64 696d 7320 6966 2074 6172 6765 7420  odims if target 
+00026990: 6973 204e 6f6e 6520 656c 7365 2074 6172  is None else tar
+000269a0: 6765 742e 6672 6f6d 6469 6d73 0a20 2020  get.fromdims.   
+000269b0: 2020 2020 2073 7570 6572 2829 2e5f 5f69       super().__i
+000269c0: 6e69 745f 5f28 6172 6773 3d28 696e 6465  nit__(args=(inde
+000269d0: 782c 292c 2073 6861 7065 3d28 636f 6e73  x,), shape=(cons
+000269e0: 7461 6e74 2874 6172 6765 745f 6469 6d29  tant(target_dim)
+000269f0: 2c20 636f 6e73 7461 6e74 2873 6f75 7263  , constant(sourc
+00026a00: 652e 6672 6f6d 6469 6d73 2929 2c20 6474  e.fromdims)), dt
+00026a10: 7970 653d 666c 6f61 7429 0a0a 2020 2020  ype=float)..    
+00026a20: 6465 6620 6576 616c 6628 7365 6c66 2c20  def evalf(self, 
+00026a30: 696e 6465 7829 3a0a 2020 2020 2020 2020  index):.        
+00026a40: 6368 6169 6e20 3d20 7365 6c66 2e5f 736f  chain = self._so
+00026a50: 7572 6365 5b69 6e64 6578 2e5f 5f69 6e64  urce[index.__ind
+00026a60: 6578 5f5f 2829 5d0a 2020 2020 2020 2020  ex__()].        
+00026a70: 6966 2073 656c 662e 5f74 6172 6765 7420  if self._target 
+00026a80: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+00026a90: 2020 2020 2020 2020 205f 2c20 6368 6169           _, chai
+00026aa0: 6e20 3d20 7365 6c66 2e5f 7461 7267 6574  n = self._target
+00026ab0: 2e69 6e64 6578 5f77 6974 685f 7461 696c  .index_with_tail
+00026ac0: 2863 6861 696e 290a 2020 2020 2020 2020  (chain).        
+00026ad0: 6966 2063 6861 696e 3a0a 2020 2020 2020  if chain:.      
+00026ae0: 2020 2020 2020 7265 7475 726e 2066 756e        return fun
+00026af0: 6374 6f6f 6c73 2e72 6564 7563 6528 6c61  ctools.reduce(la
+00026b00: 6d62 6461 2072 2c20 693a 2069 2040 2072  mbda r, i: i @ r
+00026b10: 2c20 2869 7465 6d2e 6c69 6e65 6172 2066  , (item.linear f
+00026b20: 6f72 2069 7465 6d20 696e 2072 6576 6572  or item in rever
+00026b30: 7365 6428 6368 6169 6e29 2929 0a20 2020  sed(chain))).   
+00026b40: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00026b50: 2020 2020 2020 2072 6574 7572 6e20 6e75         return nu
+00026b60: 6d70 792e 6579 6528 7365 6c66 2e5f 736f  mpy.eye(self._so
+00026b70: 7572 6365 2e66 726f 6d64 696d 7329 0a0a  urce.fromdims)..
+00026b80: 2020 2020 6465 6620 5f73 696d 706c 6966      def _simplif
+00026b90: 6965 6428 7365 6c66 293a 0a20 2020 2020  ied(self):.     
+00026ba0: 2020 2069 6620 7365 6c66 2e5f 7461 7267     if self._targ
+00026bb0: 6574 203d 3d20 7365 6c66 2e5f 736f 7572  et == self._sour
+00026bc0: 6365 3a0a 2020 2020 2020 2020 2020 2020  ce:.            
+00026bd0: 7265 7475 726e 2064 6961 676f 6e61 6c69  return diagonali
+00026be0: 7a65 286f 6e65 7328 2863 6f6e 7374 616e  ze(ones((constan
+00026bf0: 7428 7365 6c66 2e5f 736f 7572 6365 2e66  t(self._source.f
+00026c00: 726f 6d64 696d 7329 2c29 2c20 6474 7970  romdims),), dtyp
+00026c10: 653d 666c 6f61 7429 290a 0a0a 636c 6173  e=float))...clas
+00026c20: 7320 5472 616e 7366 6f72 6d42 6173 6973  s TransformBasis
+00026c30: 2841 7272 6179 293a 0a20 2020 2027 2727  (Array):.    '''
+00026c40: 5665 6374 6f72 2062 6173 6973 2066 6f72  Vector basis for
+00026c50: 2074 6865 2072 6f6f 7420 616e 6420 6120   the root and a 
+00026c60: 736f 7572 6365 2063 6f6f 7264 696e 6174  source coordinat
+00026c70: 6520 7379 7374 656d 0a0a 2020 2020 5468  e system..    Th
+00026c80: 6520 636f 6c75 6d6e 7320 6f66 2074 6869  e columns of thi
+00026c90: 7320 6d61 7472 6978 2066 6f72 6d20 6120  s matrix form a 
+00026ca0: 7665 6374 6f72 2062 6173 6973 2066 6f72  vector basis for
+00026cb0: 2074 6865 2073 7061 6365 206f 6620 726f   the space of ro
+00026cc0: 6f74 0a20 2020 2063 6f6f 7264 696e 6174  ot.    coordinat
+00026cd0: 6573 2e20 5468 6520 6669 7273 7420 606e  es. The first `n
+00026ce0: 6020 7665 6374 6f72 7320 616c 736f 2073  ` vectors also s
+00026cf0: 7061 6e20 7468 6520 7370 6163 6520 6f66  pan the space of
+00026d00: 2073 6f75 7263 650a 2020 2020 636f 6f72   source.    coor
+00026d10: 6469 6e61 7465 7320 6d61 7070 6564 2074  dinates mapped t
+00026d20: 6f20 7468 6520 726f 6f74 2c20 7768 6572  o the root, wher
+00026d30: 6520 606e 6020 6973 2074 6865 2064 696d  e `n` is the dim
+00026d40: 656e 7369 6f6e 206f 6620 7468 6520 736f  ension of the so
+00026d50: 7572 6365 0a20 2020 2063 6f6f 7264 696e  urce.    coordin
+00026d60: 6174 6520 7379 7374 656d 2e20 5468 6520  ate system. The 
+00026d70: 7265 6d61 696e 6465 7220 6973 202a 6e6f  remainder is *no
+00026d80: 742a 2061 2073 7061 6e20 6f66 2074 6865  t* a span of the
+00026d90: 2063 6f6d 706c 656d 656e 7420 7370 6163   complement spac
+00026da0: 6520 696e 0a20 2020 2067 656e 6572 616c  e in.    general
+00026db0: 2e0a 0a20 2020 204e 6f20 6164 6469 7469  ...    No additi
+00026dc0: 6f6e 616c 2070 726f 7065 7274 6965 7320  onal properties 
+00026dd0: 6172 6520 6775 6172 616e 7465 6564 2062  are guaranteed b
+00026de0: 6579 6f6e 6420 7468 6520 6162 6f76 652e  eyond the above.
+00026df0: 2049 6e20 7061 7274 6963 756c 6172 2c20   In particular, 
+00026e00: 6966 0a20 2020 2074 6865 2073 6f75 7263  if.    the sourc
+00026e10: 6520 636f 6f72 6469 6e61 7465 2073 7973  e coordinate sys
+00026e20: 7465 6d20 6861 7320 7468 6520 7361 6d65  tem has the same
+00026e30: 2064 696d 656e 7369 6f6e 2061 7320 7468   dimension as th
+00026e40: 6520 726f 6f74 2c20 7468 650a 2020 2020  e root, the.    
+00026e50: 6261 7369 7320 6973 202a 6e6f 7420 6e65  basis is *not ne
+00026e60: 6365 7373 6172 696c 792a 2074 6865 2073  cessarily* the s
+00026e70: 616d 6520 6173 2060 6054 7261 6e73 666f  ame as ``Transfo
+00026e80: 726d 4c69 6e65 6172 284e 6f6e 652c 2073  rmLinear(None, s
+00026e90: 6f75 7263 652c 0a20 2020 2069 6e64 6578  ource,.    index
+00026ea0: 2960 602e 0a0a 2020 2020 4172 6773 0a20  )``...    Args. 
+00026eb0: 2020 202d 2d2d 2d0a 2020 2020 736f 7572     ----.    sour
+00026ec0: 6365 203a 203a 636c 6173 733a 606e 7574  ce : :class:`nut
+00026ed0: 696c 732e 7472 616e 7366 6f72 6d73 6571  ils.transformseq
+00026ee0: 2e54 7261 6e73 666f 726d 7360 0a20 2020  .Transforms`.   
+00026ef0: 2020 2020 2054 6865 2073 6f75 7263 6520       The source 
+00026f00: 636f 6f72 6469 6e61 7465 2073 7973 7465  coordinate syste
+00026f10: 6d2e 0a20 2020 2069 6e64 6578 203a 2073  m..    index : s
+00026f20: 6361 6c61 722c 2069 6e74 6567 6572 203a  calar, integer :
+00026f30: 636c 6173 733a 6041 7272 6179 600a 2020  class:`Array`.  
+00026f40: 2020 2020 2020 5468 6520 696e 6465 7820        The index 
+00026f50: 7061 7274 206f 6620 7468 6520 736f 7572  part of the sour
+00026f60: 6365 2063 6f6f 7264 696e 6174 6573 2e0a  ce coordinates..
+00026f70: 2020 2020 2727 270a 0a20 2020 2064 6566      '''..    def
+00026f80: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+00026f90: 736f 7572 6365 2c20 696e 6465 783a 2041  source, index: A
+00026fa0: 7272 6179 293a 0a20 2020 2020 2020 2069  rray):.        i
+00026fb0: 6620 696e 6465 782e 6474 7970 6520 213d  f index.dtype !=
+00026fc0: 2069 6e74 206f 7220 696e 6465 782e 6e64   int or index.nd
+00026fd0: 696d 2021 3d20 303a 0a20 2020 2020 2020  im != 0:.       
+00026fe0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00026ff0: 4572 726f 7228 2761 7267 756d 656e 7420  Error('argument 
+00027000: 6069 6e64 6578 6020 6d75 7374 2062 6520  `index` must be 
+00027010: 6120 7363 616c 6172 2c20 696e 7465 6765  a scalar, intege
+00027020: 7220 606e 7574 696c 732e 6576 616c 7561  r `nutils.evalua
+00027030: 626c 652e 4172 7261 7960 2729 0a20 2020  ble.Array`').   
+00027040: 2020 2020 2073 656c 662e 5f73 6f75 7263       self._sourc
+00027050: 6520 3d20 736f 7572 6365 0a20 2020 2020  e = source.     
+00027060: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
+00027070: 745f 5f28 6172 6773 3d28 696e 6465 782c  t__(args=(index,
+00027080: 292c 2073 6861 7065 3d28 636f 6e73 7461  ), shape=(consta
+00027090: 6e74 2873 6f75 7263 652e 746f 6469 6d73  nt(source.todims
+000270a0: 292c 2063 6f6e 7374 616e 7428 736f 7572  ), constant(sour
+000270b0: 6365 2e74 6f64 696d 7329 292c 2064 7479  ce.todims)), dty
+000270c0: 7065 3d66 6c6f 6174 290a 0a20 2020 2064  pe=float)..    d
+000270d0: 6566 2065 7661 6c66 2873 656c 662c 2069  ef evalf(self, i
+000270e0: 6e64 6578 293a 0a20 2020 2020 2020 2063  ndex):.        c
+000270f0: 6861 696e 203d 2073 656c 662e 5f73 6f75  hain = self._sou
+00027100: 7263 655b 696e 6465 782e 5f5f 696e 6465  rce[index.__inde
+00027110: 785f 5f28 295d 0a20 2020 2020 2020 206c  x__()].        l
+00027120: 696e 6561 7220 3d20 6e75 6d70 792e 6579  inear = numpy.ey
+00027130: 6528 7365 6c66 2e5f 736f 7572 6365 2e66  e(self._source.f
+00027140: 726f 6d64 696d 7329 0a20 2020 2020 2020  romdims).       
+00027150: 2066 6f72 2069 7465 6d20 696e 2072 6576   for item in rev
+00027160: 6572 7365 6428 6368 6169 6e29 3a0a 2020  ersed(chain):.  
+00027170: 2020 2020 2020 2020 2020 6c69 6e65 6172            linear
+00027180: 203d 2069 7465 6d2e 6c69 6e65 6172 2040   = item.linear @
+00027190: 206c 696e 6561 720a 2020 2020 2020 2020   linear.        
+000271a0: 2020 2020 6173 7365 7274 2069 7465 6d2e      assert item.
+000271b0: 6672 6f6d 6469 6d73 203c 3d20 6974 656d  fromdims <= item
+000271c0: 2e74 6f64 696d 7320 3c3d 2069 7465 6d2e  .todims <= item.
+000271d0: 6672 6f6d 6469 6d73 202b 2031 0a20 2020  fromdims + 1.   
+000271e0: 2020 2020 2020 2020 2069 6620 6974 656d           if item
+000271f0: 2e74 6f64 696d 7320 3d3d 2069 7465 6d2e  .todims == item.
+00027200: 6672 6f6d 6469 6d73 202b 2031 3a0a 2020  fromdims + 1:.  
+00027210: 2020 2020 2020 2020 2020 2020 2020 6c69                li
+00027220: 6e65 6172 203d 206e 756d 7079 2e63 6f6e  near = numpy.con
+00027230: 6361 7465 6e61 7465 285b 6c69 6e65 6172  catenate([linear
+00027240: 2c20 6974 656d 2e65 7874 5b3a 2c20 6e75  , item.ext[:, nu
+00027250: 6d70 792e 6e65 7761 7869 735d 5d2c 2061  mpy.newaxis]], a
+00027260: 7869 733d 3129 0a20 2020 2020 2020 2061  xis=1).        a
+00027270: 7373 6572 7420 6c69 6e65 6172 2e73 6861  ssert linear.sha
+00027280: 7065 203d 3d20 2873 656c 662e 5f73 6f75  pe == (self._sou
+00027290: 7263 652e 746f 6469 6d73 2c20 7365 6c66  rce.todims, self
+000272a0: 2e5f 736f 7572 6365 2e74 6f64 696d 7329  ._source.todims)
+000272b0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000272c0: 6c69 6e65 6172 0a0a 2020 2020 6465 6620  linear..    def 
+000272d0: 5f73 696d 706c 6966 6965 6428 7365 6c66  _simplified(self
+000272e0: 293a 0a20 2020 2020 2020 2069 6620 7365  ):.        if se
+000272f0: 6c66 2e5f 736f 7572 6365 2e74 6f64 696d  lf._source.todim
+00027300: 7320 3d3d 2073 656c 662e 5f73 6f75 7263  s == self._sourc
+00027310: 652e 6672 6f6d 6469 6d73 3a0a 2020 2020  e.fromdims:.    
+00027320: 2020 2020 2020 2020 2320 5369 6e63 6520          # Since 
+00027330: 7765 206f 6e6c 7920 6775 6172 616e 7465  we only guarante
+00027340: 6520 7468 6174 2074 6865 2062 6173 6973  e that the basis
+00027350: 2073 7061 6e73 2074 6865 2073 7061 6365   spans the space
+00027360: 206f 6620 736f 7572 6365 0a20 2020 2020   of source.     
+00027370: 2020 2020 2020 2023 2063 6f6f 7264 696e         # coordin
+00027380: 6174 6573 206d 6170 7065 6420 746f 2074  ates mapped to t
+00027390: 6865 2072 6f6f 7420 616e 6420 7468 6520  he root and the 
+000273a0: 6d61 7020 6973 2061 2062 696a 6563 7469  map is a bijecti
+000273b0: 6f6e 2028 6576 6572 790a 2020 2020 2020  on (every.      
+000273c0: 2020 2020 2020 2320 6054 7261 6e73 666f        # `Transfo
+000273d0: 726d 6020 6973 2061 7373 756d 6564 2074  rm` is assumed t
+000273e0: 6f20 6265 2069 6e6a 6563 7469 7665 292c  o be injective),
+000273f0: 2077 6520 6361 6e20 7265 7475 726e 2074   we can return t
+00027400: 6865 2075 6e69 740a 2020 2020 2020 2020  he unit.        
+00027410: 2020 2020 2320 7665 6374 6f72 7320 6865      # vectors he
+00027420: 7265 2e0a 2020 2020 2020 2020 2020 2020  re..            
+00027430: 7265 7475 726e 2064 6961 676f 6e61 6c69  return diagonali
+00027440: 7a65 286f 6e65 7328 2873 656c 662e 5f73  ze(ones((self._s
+00027450: 6f75 7263 652e 6672 6f6d 6469 6d73 2c29  ource.fromdims,)
+00027460: 2c20 6474 7970 653d 666c 6f61 7429 290a  , dtype=float)).
+00027470: 0a0a 636c 6173 7320 5f4c 6f6f 7049 6e64  ..class _LoopInd
+00027480: 6578 2841 7267 756d 656e 7429 3a0a 0a20  ex(Argument):.. 
+00027490: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
+000274a0: 7365 6c66 2c20 6e61 6d65 3a20 7374 722c  self, name: str,
+000274b0: 206c 656e 6774 683a 2041 7272 6179 293a   length: Array):
+000274c0: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+000274d0: 6973 696e 7374 616e 6365 286e 616d 652c  isinstance(name,
+000274e0: 2073 7472 292c 2066 276e 616d 653d 7b6e   str), f'name={n
+000274f0: 616d 6521 727d 270a 2020 2020 2020 2020  ame!r}'.        
+00027500: 6173 7365 7274 205f 6973 696e 6465 7828  assert _isindex(
+00027510: 6c65 6e67 7468 292c 2066 276c 656e 6774  length), f'lengt
+00027520: 683d 7b6c 656e 6774 6821 727d 270a 2020  h={length!r}'.  
+00027530: 2020 2020 2020 7365 6c66 2e6c 656e 6774        self.lengt
+00027540: 6820 3d20 6c65 6e67 7468 0a20 2020 2020  h = length.     
+00027550: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
+00027560: 745f 5f28 6e61 6d65 2c20 2829 2c20 696e  t__(name, (), in
+00027570: 7429 0a0a 2020 2020 6465 6620 5f5f 7374  t)..    def __st
+00027580: 725f 5f28 7365 6c66 293a 0a20 2020 2020  r__(self):.     
+00027590: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+000275a0: 2020 2020 6c65 6e67 7468 203d 2073 656c      length = sel
+000275b0: 662e 6c65 6e67 7468 2e5f 5f69 6e64 6578  f.length.__index
+000275c0: 5f5f 2829 0a20 2020 2020 2020 2065 7863  __().        exc
+000275d0: 6570 743a 0a20 2020 2020 2020 2020 2020  ept:.           
+000275e0: 206c 656e 6774 6820 3d20 273f 270a 2020   length = '?'.  
+000275f0: 2020 2020 2020 7265 7475 726e 2027 4c6f        return 'Lo
+00027600: 6f70 496e 6465 7828 7b7d 2c20 6c65 6e67  opIndex({}, leng
+00027610: 7468 3d7b 7d29 272e 666f 726d 6174 2873  th={})'.format(s
+00027620: 656c 662e 5f6e 616d 652c 206c 656e 6774  elf._name, lengt
+00027630: 6829 0a0a 2020 2020 6465 6620 5f6e 6f64  h)..    def _nod
+00027640: 6528 7365 6c66 2c20 6361 6368 652c 2073  e(self, cache, s
+00027650: 7562 6772 6170 682c 2074 696d 6573 293a  ubgraph, times):
+00027660: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00027670: 2069 6e20 6361 6368 653a 0a20 2020 2020   in cache:.     
+00027680: 2020 2020 2020 2072 6574 7572 6e20 6361         return ca
+00027690: 6368 655b 7365 6c66 5d0a 2020 2020 2020  che[self].      
+000276a0: 2020 6361 6368 655b 7365 6c66 5d20 3d20    cache[self] = 
+000276b0: 6e6f 6465 203d 2052 6567 756c 6172 4e6f  node = RegularNo
+000276c0: 6465 2827 4c6f 6f70 496e 6465 7827 2c20  de('LoopIndex', 
+000276d0: 2829 2c20 6469 6374 286c 656e 6774 683d  (), dict(length=
+000276e0: 7365 6c66 2e6c 656e 6774 682e 5f6e 6f64  self.length._nod
+000276f0: 6528 6361 6368 652c 2073 7562 6772 6170  e(cache, subgrap
+00027700: 682c 2074 696d 6573 2929 2c20 2874 7970  h, times)), (typ
+00027710: 6528 7365 6c66 292e 5f5f 6e61 6d65 5f5f  e(self).__name__
+00027720: 2c20 5f53 7461 7473 2829 292c 2073 7562  , _Stats()), sub
+00027730: 6772 6170 6829 0a20 2020 2020 2020 2072  graph).        r
+00027740: 6574 7572 6e20 6e6f 6465 0a0a 2020 2020  eturn node..    
+00027750: 6465 6620 5f69 6e74 626f 756e 6473 5f69  def _intbounds_i
+00027760: 6d70 6c28 7365 6c66 293a 0a20 2020 2020  mpl(self):.     
+00027770: 2020 206c 6f77 6572 5f6c 656e 6774 682c     lower_length,
+00027780: 2075 7070 6572 5f6c 656e 6774 6820 3d20   upper_length = 
+00027790: 7365 6c66 2e6c 656e 6774 682e 5f69 6e74  self.length._int
+000277a0: 626f 756e 6473 0a20 2020 2020 2020 2072  bounds.        r
+000277b0: 6574 7572 6e20 302c 206d 6178 2830 2c20  eturn 0, max(0, 
+000277c0: 7570 7065 725f 6c65 6e67 7468 202d 2031  upper_length - 1
+000277d0: 290a 0a20 2020 2064 6566 205f 7369 6d70  )..    def _simp
+000277e0: 6c69 6669 6564 2873 656c 6629 3a0a 2020  lified(self):.  
+000277f0: 2020 2020 2020 6966 205f 6571 7561 6c73        if _equals
+00027800: 5f73 6361 6c61 725f 636f 6e73 7461 6e74  _scalar_constant
+00027810: 2873 656c 662e 6c65 6e67 7468 2c20 3129  (self.length, 1)
+00027820: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00027830: 7475 726e 205a 6572 6f73 2828 292c 2069  turn Zeros((), i
+00027840: 6e74 290a 0a0a 636c 6173 7320 4c6f 6f70  nt)...class Loop
+00027850: 5375 6d28 4172 7261 7929 3a0a 0a20 2020  Sum(Array):..   
+00027860: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
+00027870: 6c66 2c20 6675 6e63 3a20 4172 7261 792c  lf, func: Array,
+00027880: 2073 6861 7065 3a20 7479 7069 6e67 2e54   shape: typing.T
+00027890: 7570 6c65 5b41 7272 6179 2c20 2e2e 2e5d  uple[Array, ...]
+000278a0: 2c20 696e 6465 785f 6e61 6d65 3a20 7374  , index_name: st
+000278b0: 722c 206c 656e 6774 683a 2041 7272 6179  r, length: Array
+000278c0: 293a 0a20 2020 2020 2020 2061 7373 6572  ):.        asser
+000278d0: 7420 6973 696e 7374 616e 6365 2866 756e  t isinstance(fun
+000278e0: 632c 2041 7272 6179 2920 616e 6420 6675  c, Array) and fu
+000278f0: 6e63 2e64 7479 7065 2021 3d20 626f 6f6c  nc.dtype != bool
+00027900: 2c20 6627 6675 6e63 3d7b 6675 6e63 2172  , f'func={func!r
+00027910: 7d27 0a20 2020 2020 2020 2061 7373 6572  }'.        asser
+00027920: 7420 6973 696e 7374 616e 6365 2873 6861  t isinstance(sha
+00027930: 7065 2c20 7475 706c 6529 2061 6e64 2061  pe, tuple) and a
+00027940: 6c6c 285f 6973 696e 6465 7828 6e29 2066  ll(_isindex(n) f
+00027950: 6f72 206e 2069 6e20 7368 6170 6529 2c20  or n in shape), 
+00027960: 6627 7368 6170 653d 7b73 6861 7065 2172  f'shape={shape!r
+00027970: 7d27 0a20 2020 2020 2020 2061 7373 6572  }'.        asser
+00027980: 7420 6973 696e 7374 616e 6365 2869 6e64  t isinstance(ind
+00027990: 6578 5f6e 616d 652c 2073 7472 292c 2066  ex_name, str), f
+000279a0: 2769 6e64 6578 5f6e 616d 653d 7b69 6e64  'index_name={ind
+000279b0: 6578 5f6e 616d 6521 727d 270a 2020 2020  ex_name!r}'.    
+000279c0: 2020 2020 6173 7365 7274 205f 6973 696e      assert _isin
+000279d0: 6465 7828 6c65 6e67 7468 292c 2066 276c  dex(length), f'l
+000279e0: 656e 6774 683d 7b6c 656e 6774 6821 727d  ength={length!r}
+000279f0: 270a 2020 2020 2020 2020 6173 7365 7274  '.        assert
+00027a00: 2066 756e 632e 6e64 696d 203d 3d20 6c65   func.ndim == le
+00027a10: 6e28 7368 6170 6529 0a20 2020 2020 2020  n(shape).       
+00027a20: 2073 656c 662e 696e 6465 7820 3d20 6c6f   self.index = lo
+00027a30: 6f70 5f69 6e64 6578 2869 6e64 6578 5f6e  op_index(index_n
+00027a40: 616d 652c 206c 656e 6774 6829 0a20 2020  ame, length).   
+00027a50: 2020 2020 2069 6620 616e 7928 7365 6c66       if any(self
+00027a60: 2e69 6e64 6578 2069 6e20 6e2e 6172 6775  .index in n.argu
+00027a70: 6d65 6e74 7320 666f 7220 6e20 696e 2073  ments for n in s
+00027a80: 6861 7065 293a 0a20 2020 2020 2020 2020  hape):.         
+00027a90: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00027aa0: 726f 7228 2774 6865 2073 6861 7065 206f  ror('the shape o
+00027ab0: 6620 7468 6520 6675 6e63 7469 6f6e 206d  f the function m
+00027ac0: 7573 7420 6e6f 7420 6465 7065 6e64 206f  ust not depend o
+00027ad0: 6e20 7468 6520 696e 6465 7827 290a 2020  n the index').  
+00027ae0: 2020 2020 2020 7365 6c66 2e66 756e 6320        self.func 
+00027af0: 3d20 6675 6e63 0a20 2020 2020 2020 2073  = func.        s
+00027b00: 656c 662e 5f69 6e76 6172 6961 6e74 732c  elf._invariants,
+00027b10: 2073 656c 662e 5f64 6570 656e 6465 6e63   self._dependenc
+00027b20: 6965 7320 3d20 5f64 6570 656e 6465 6e63  ies = _dependenc
+00027b30: 6965 735f 7361 6e73 5f69 6e76 6172 6961  ies_sans_invaria
+00027b40: 6e74 7328 6675 6e63 2c20 7365 6c66 2e69  nts(func, self.i
+00027b50: 6e64 6578 290a 2020 2020 2020 2020 7375  ndex).        su
+00027b60: 7065 7228 292e 5f5f 696e 6974 5f5f 2861  per().__init__(a
+00027b70: 7267 733d 2854 7570 6c65 2873 6861 7065  rgs=(Tuple(shape
+00027b80: 292c 206c 656e 6774 682c 202a 7365 6c66  ), length, *self
+00027b90: 2e5f 696e 7661 7269 616e 7473 292c 2073  ._invariants), s
+00027ba0: 6861 7065 3d73 6861 7065 2c20 6474 7970  hape=shape, dtyp
+00027bb0: 653d 6675 6e63 2e64 7479 7065 290a 0a20  e=func.dtype).. 
+00027bc0: 2020 2040 6361 6368 6564 5f70 726f 7065     @cached_prope
+00027bd0: 7274 790a 2020 2020 6465 6620 5f73 6572  rty.    def _ser
+00027be0: 6961 6c69 7a65 645f 6c6f 6f70 2873 656c  ialized_loop(sel
+00027bf0: 6629 3a0a 2020 2020 2020 2020 696e 6469  f):.        indi
+00027c00: 6365 7320 3d20 7b64 3a20 6920 666f 7220  ces = {d: i for 
+00027c10: 692c 2064 2069 6e20 656e 756d 6572 6174  i, d in enumerat
+00027c20: 6528 6974 6572 746f 6f6c 732e 6368 6169  e(itertools.chai
+00027c30: 6e28 5b73 656c 662e 696e 6465 785d 2c20  n([self.index], 
+00027c40: 7365 6c66 2e5f 696e 7661 7269 616e 7473  self._invariants
+00027c50: 2c20 7365 6c66 2e5f 6465 7065 6e64 656e  , self._dependen
+00027c60: 6369 6573 2929 7d0a 2020 2020 2020 2020  cies))}.        
+00027c70: 7265 7475 726e 2074 7570 6c65 2828 6465  return tuple((de
+00027c80: 702c 2074 7570 6c65 286d 6170 2869 6e64  p, tuple(map(ind
+00027c90: 6963 6573 2e5f 5f67 6574 6974 656d 5f5f  ices.__getitem__
+00027ca0: 2c20 6465 702e 5f45 7661 6c75 6162 6c65  , dep._Evaluable
+00027cb0: 5f5f 6172 6773 2929 2920 666f 7220 6465  __args))) for de
+00027cc0: 7020 696e 2073 656c 662e 5f64 6570 656e  p in self._depen
+00027cd0: 6465 6e63 6965 7329 0a0a 2020 2020 2320  dencies)..    # 
+00027ce0: 5468 6973 2070 726f 7065 7274 7920 6973  This property is
+00027cf0: 2061 2064 6572 6976 6174 696f 6e20 6f66   a derivation of
+00027d00: 2060 5f73 6572 6961 6c69 7a65 6460 2077   `_serialized` w
+00027d10: 6865 7265 2074 6865 2060 4576 616c 7561  here the `Evalua
+00027d20: 626c 6560 0a20 2020 2023 2069 6e73 7461  ble`.    # insta
+00027d30: 6e63 6573 2061 7265 206d 6170 7065 6420  nces are mapped 
+00027d40: 746f 2074 6865 2060 6576 616c 6660 206d  to the `evalf` m
+00027d50: 6574 686f 6473 206f 6620 7468 6520 696e  ethods of the in
+00027d60: 7374 616e 6365 732e 2041 7373 6572 7469  stances. Asserti
+00027d70: 6e67 0a20 2020 2023 2074 6861 7420 6675  ng.    # that fu
+00027d80: 6e63 7469 6f6e 7320 6172 6520 696d 6d75  nctions are immu
+00027d90: 7461 626c 6520 6973 2064 6966 6669 6375  table is difficu
+00027da0: 6c74 2061 6e64 2063 7572 7265 6e74 6c79  lt and currently
+00027db0: 0a20 2020 2023 2060 7479 7065 732e 5f69  .    # `types._i
+00027dc0: 7369 6d6d 7574 6162 6c65 6020 6d61 726b  simmutable` mark
+00027dd0: 7320 616c 6c20 6675 6e63 7469 6f6e 7320  s all functions 
+00027de0: 6173 206d 7574 6162 6c65 2e20 5369 6e63  as mutable. Sinc
+00027df0: 6520 7468 650a 2020 2020 2320 6074 7970  e the.    # `typ
+00027e00: 6573 2e43 6163 6865 4d65 7461 6020 6d61  es.CacheMeta` ma
+00027e10: 6368 696e 6572 7920 6173 7365 7274 7320  chinery asserts 
+00027e20: 696d 6d75 7461 6269 6c69 7479 206f 6620  immutability of 
+00027e30: 7468 6520 7072 6f70 6572 7479 2c20 7765  the property, we
+00027e40: 2068 6176 650a 2020 2020 2320 746f 2072   have.    # to r
+00027e50: 6573 6f72 7420 746f 2061 2072 6567 756c  esort to a regul
+00027e60: 6172 2060 6675 6e63 746f 6f6c 732e 6361  ar `functools.ca
+00027e70: 6368 6564 5f70 726f 7065 7274 7960 2e20  ched_property`. 
+00027e80: 4e65 7665 7274 6865 6c65 7373 2c20 7468  Nevertheless, th
+00027e90: 6973 0a20 2020 2023 2070 726f 7065 7274  is.    # propert
+00027ea0: 7920 7368 6f75 6c64 2062 6520 7472 6561  y should be trea
+00027eb0: 7465 6420 6173 2069 6620 6974 2069 7320  ted as if it is 
+00027ec0: 696d 6d75 7461 626c 652e 0a20 2020 2040  immutable..    @
+00027ed0: 6361 6368 6564 5f70 726f 7065 7274 790a  cached_property.
+00027ee0: 2020 2020 6465 6620 5f73 6572 6961 6c69      def _seriali
+00027ef0: 7a65 645f 6c6f 6f70 5f65 7661 6c66 2873  zed_loop_evalf(s
+00027f00: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00027f10: 7475 726e 2074 7570 6c65 2828 6465 702e  turn tuple((dep.
+00027f20: 6576 616c 662c 2069 6e64 6963 6573 2920  evalf, indices) 
+00027f30: 666f 7220 6465 702c 2069 6e64 6963 6573  for dep, indices
+00027f40: 2069 6e20 7365 6c66 2e5f 7365 7269 616c   in self._serial
+00027f50: 697a 6564 5f6c 6f6f 7029 0a0a 2020 2020  ized_loop)..    
+00027f60: 6465 6620 6576 616c 6628 7365 6c66 2c20  def evalf(self, 
+00027f70: 7368 6170 652c 206c 656e 6774 682c 202a  shape, length, *
+00027f80: 6172 6773 293a 0a20 2020 2020 2020 2073  args):.        s
+00027f90: 6572 6961 6c69 7a65 645f 6576 616c 6620  erialized_evalf 
+00027fa0: 3d20 7365 6c66 2e5f 7365 7269 616c 697a  = self._serializ
+00027fb0: 6564 5f6c 6f6f 705f 6576 616c 660a 2020  ed_loop_evalf.  
+00027fc0: 2020 2020 2020 7265 7375 6c74 203d 206e        result = n
+00027fd0: 756d 7079 2e7a 6572 6f73 2873 6861 7065  umpy.zeros(shape
+00027fe0: 2c20 7365 6c66 2e64 7479 7065 290a 2020  , self.dtype).  
+00027ff0: 2020 2020 2020 666f 7220 696e 6465 7820        for index 
+00028000: 696e 2072 616e 6765 286c 656e 6774 6829  in range(length)
+00028010: 3a0a 2020 2020 2020 2020 2020 2020 7661  :.            va
+00028020: 6c75 6573 203d 205b 6e75 6d70 792e 6172  lues = [numpy.ar
+00028030: 7261 7928 696e 6465 7829 5d0a 2020 2020  ray(index)].    
+00028040: 2020 2020 2020 2020 7661 6c75 6573 2e65          values.e
+00028050: 7874 656e 6428 6172 6773 290a 2020 2020  xtend(args).    
+00028060: 2020 2020 2020 2020 7661 6c75 6573 2e65          values.e
+00028070: 7874 656e 6428 6f70 5f65 7661 6c66 282a  xtend(op_evalf(*
+00028080: 5b76 616c 7565 735b 695d 2066 6f72 2069  [values[i] for i
+00028090: 2069 6e20 696e 6469 6365 735d 2920 666f   in indices]) fo
+000280a0: 7220 6f70 5f65 7661 6c66 2c20 696e 6469  r op_evalf, indi
+000280b0: 6365 7320 696e 2073 6572 6961 6c69 7a65  ces in serialize
+000280c0: 645f 6576 616c 6629 0a20 2020 2020 2020  d_evalf).       
+000280d0: 2020 2020 2072 6573 756c 7420 2b3d 2076       result += v
+000280e0: 616c 7565 735b 2d31 5d0a 2020 2020 2020  alues[-1].      
+000280f0: 2020 7265 7475 726e 2072 6573 756c 740a    return result.
+00028100: 0a20 2020 2064 6566 2065 7661 6c66 5f77  .    def evalf_w
+00028110: 6974 6874 696d 6573 2873 656c 662c 2074  ithtimes(self, t
+00028120: 696d 6573 2c20 7368 6170 652c 206c 656e  imes, shape, len
+00028130: 6774 682c 202a 6172 6773 293a 0a20 2020  gth, *args):.   
+00028140: 2020 2020 2073 6572 6961 6c69 7a65 6420       serialized 
+00028150: 3d20 7365 6c66 2e5f 7365 7269 616c 697a  = self._serializ
+00028160: 6564 5f6c 6f6f 700a 2020 2020 2020 2020  ed_loop.        
+00028170: 7375 6274 696d 6573 203d 2074 696d 6573  subtimes = times
+00028180: 2e73 6574 6465 6661 756c 7428 7365 6c66  .setdefault(self
+00028190: 2c20 636f 6c6c 6563 7469 6f6e 732e 6465  , collections.de
+000281a0: 6661 756c 7464 6963 7428 5f53 7461 7473  faultdict(_Stats
+000281b0: 2929 0a20 2020 2020 2020 2072 6573 756c  )).        resul
+000281c0: 7420 3d20 6e75 6d70 792e 7a65 726f 7328  t = numpy.zeros(
+000281d0: 7368 6170 652c 2073 656c 662e 6474 7970  shape, self.dtyp
+000281e0: 6529 0a20 2020 2020 2020 2066 6f72 2069  e).        for i
+000281f0: 6e64 6578 2069 6e20 7261 6e67 6528 6c65  ndex in range(le
+00028200: 6e67 7468 293a 0a20 2020 2020 2020 2020  ngth):.         
+00028210: 2020 2076 616c 7565 7320 3d20 5b6e 756d     values = [num
+00028220: 7079 2e61 7272 6179 2869 6e64 6578 295d  py.array(index)]
+00028230: 0a20 2020 2020 2020 2020 2020 2076 616c  .            val
+00028240: 7565 732e 6578 7465 6e64 2861 7267 7329  ues.extend(args)
+00028250: 0a20 2020 2020 2020 2020 2020 2076 616c  .            val
+00028260: 7565 732e 6578 7465 6e64 286f 702e 6576  ues.extend(op.ev
+00028270: 616c 665f 7769 7468 7469 6d65 7328 7375  alf_withtimes(su
+00028280: 6274 696d 6573 2c20 2a5b 7661 6c75 6573  btimes, *[values
+00028290: 5b69 5d20 666f 7220 6920 696e 2069 6e64  [i] for i in ind
+000282a0: 6963 6573 5d29 2066 6f72 206f 702c 2069  ices]) for op, i
+000282b0: 6e64 6963 6573 2069 6e20 7365 7269 616c  ndices in serial
+000282c0: 697a 6564 290a 2020 2020 2020 2020 2020  ized).          
+000282d0: 2020 7265 7375 6c74 202b 3d20 7661 6c75    result += valu
+000282e0: 6573 5b2d 315d 0a20 2020 2020 2020 2072  es[-1].        r
+000282f0: 6574 7572 6e20 7265 7375 6c74 0a0a 2020  eturn result..  
+00028300: 2020 6465 6620 5f64 6572 6976 6174 6976    def _derivativ
+00028310: 6528 7365 6c66 2c20 7661 722c 2073 6565  e(self, var, see
+00028320: 6e29 3a0a 2020 2020 2020 2020 7265 7475  n):.        retu
+00028330: 726e 206c 6f6f 705f 7375 6d28 6465 7269  rn loop_sum(deri
+00028340: 7661 7469 7665 2873 656c 662e 6675 6e63  vative(self.func
+00028350: 2c20 7661 722c 2073 6565 6e29 2c20 7365  , var, seen), se
+00028360: 6c66 2e69 6e64 6578 290a 0a20 2020 2064  lf.index)..    d
+00028370: 6566 205f 6e6f 6465 2873 656c 662c 2063  ef _node(self, c
+00028380: 6163 6865 2c20 7375 6267 7261 7068 2c20  ache, subgraph, 
+00028390: 7469 6d65 7329 3a0a 2020 2020 2020 2020  times):.        
+000283a0: 6966 2073 656c 6620 696e 2063 6163 6865  if self in cache
+000283b0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+000283c0: 7475 726e 2063 6163 6865 5b73 656c 665d  turn cache[self]
+000283d0: 0a20 2020 2020 2020 2073 7562 6361 6368  .        subcach
+000283e0: 6520 3d20 7b7d 0a20 2020 2020 2020 2066  e = {}.        f
+000283f0: 6f72 2061 7267 2069 6e20 7365 6c66 2e5f  or arg in self._
+00028400: 4576 616c 7561 626c 655f 5f61 7267 733a  Evaluable__args:
+00028410: 0a20 2020 2020 2020 2020 2020 2073 7562  .            sub
+00028420: 6361 6368 655b 6172 675d 203d 2061 7267  cache[arg] = arg
+00028430: 2e5f 6e6f 6465 2863 6163 6865 2c20 7375  ._node(cache, su
+00028440: 6267 7261 7068 2c20 7469 6d65 7329 0a20  bgraph, times). 
+00028450: 2020 2020 2020 206c 6f6f 7067 7261 7068         loopgraph
+00028460: 203d 2053 7562 6772 6170 6828 274c 6f6f   = Subgraph('Loo
+00028470: 7027 2c20 7375 6267 7261 7068 290a 2020  p', subgraph).  
+00028480: 2020 2020 2020 7375 6274 696d 6573 203d        subtimes =
+00028490: 2074 696d 6573 2e67 6574 2873 656c 662c   times.get(self,
+000284a0: 2063 6f6c 6c65 6374 696f 6e73 2e64 6566   collections.def
+000284b0: 6175 6c74 6469 6374 285f 5374 6174 7329  aultdict(_Stats)
+000284c0: 290a 2020 2020 2020 2020 7375 6d5f 6b77  ).        sum_kw
+000284d0: 6172 6773 203d 207b 2773 6861 7065 5b7b  args = {'shape[{
+000284e0: 7d5d 272e 666f 726d 6174 2869 293a 206e  }]'.format(i): n
+000284f0: 2e5f 6e6f 6465 2863 6163 6865 2c20 7375  ._node(cache, su
+00028500: 6267 7261 7068 2c20 7469 6d65 7329 2066  bgraph, times) f
+00028510: 6f72 2069 2c20 6e20 696e 2065 6e75 6d65  or i, n in enume
+00028520: 7261 7465 2873 656c 662e 7368 6170 6529  rate(self.shape)
+00028530: 7d0a 2020 2020 2020 2020 7375 6d5f 6b77  }.        sum_kw
+00028540: 6172 6773 5b27 6675 6e63 275d 203d 2073  args['func'] = s
+00028550: 656c 662e 6675 6e63 2e5f 6e6f 6465 2873  elf.func._node(s
+00028560: 7562 6361 6368 652c 206c 6f6f 7067 7261  ubcache, loopgra
+00028570: 7068 2c20 7375 6274 696d 6573 290a 2020  ph, subtimes).  
+00028580: 2020 2020 2020 6361 6368 655b 7365 6c66        cache[self
+00028590: 5d20 3d20 6e6f 6465 203d 2052 6567 756c  ] = node = Regul
+000285a0: 6172 4e6f 6465 2827 4c6f 6f70 5375 6d27  arNode('LoopSum'
+000285b0: 2c20 2829 2c20 7375 6d5f 6b77 6172 6773  , (), sum_kwargs
+000285c0: 2c20 2874 7970 6528 7365 6c66 292e 5f5f  , (type(self).__
+000285d0: 6e61 6d65 5f5f 2c20 7375 6274 696d 6573  name__, subtimes
+000285e0: 5b27 7375 6d27 5d29 2c20 6c6f 6f70 6772  ['sum']), loopgr
+000285f0: 6170 6829 0a20 2020 2020 2020 2072 6574  aph).        ret
+00028600: 7572 6e20 6e6f 6465 0a0a 2020 2020 6465  urn node..    de
+00028610: 6620 5f73 696d 706c 6966 6965 6428 7365  f _simplified(se
+00028620: 6c66 293a 0a20 2020 2020 2020 2069 6620  lf):.        if 
+00028630: 6973 7a65 726f 2873 656c 662e 6675 6e63  iszero(self.func
+00028640: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+00028650: 6574 7572 6e20 7a65 726f 735f 6c69 6b65  eturn zeros_like
+00028660: 2873 656c 6629 0a20 2020 2020 2020 2065  (self).        e
+00028670: 6c69 6620 7365 6c66 2e69 6e64 6578 206e  lif self.index n
+00028680: 6f74 2069 6e20 7365 6c66 2e66 756e 632e  ot in self.func.
+00028690: 6172 6775 6d65 6e74 733a 0a20 2020 2020  arguments:.     
+000286a0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+000286b0: 6c66 2e66 756e 6320 2a20 7365 6c66 2e69  lf.func * self.i
+000286c0: 6e64 6578 2e6c 656e 6774 680a 2020 2020  ndex.length.    
+000286d0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+000286e0: 6675 6e63 2e5f 6c6f 6f70 7375 6d28 7365  func._loopsum(se
+000286f0: 6c66 2e69 6e64 6578 290a 0a20 2020 2064  lf.index)..    d
+00028700: 6566 205f 7461 6b65 6469 6167 2873 656c  ef _takediag(sel
+00028710: 662c 2061 7869 7331 2c20 6178 6973 3229  f, axis1, axis2)
+00028720: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00028730: 206c 6f6f 705f 7375 6d28 5f74 616b 6564   loop_sum(_taked
+00028740: 6961 6728 7365 6c66 2e66 756e 632c 2061  iag(self.func, a
+00028750: 7869 7331 2c20 6178 6973 3229 2c20 7365  xis1, axis2), se
+00028760: 6c66 2e69 6e64 6578 290a 0a20 2020 2064  lf.index)..    d
+00028770: 6566 205f 7461 6b65 2873 656c 662c 2069  ef _take(self, i
+00028780: 6e64 6578 2c20 6178 6973 293a 0a20 2020  ndex, axis):.   
+00028790: 2020 2020 2072 6574 7572 6e20 6c6f 6f70       return loop
+000287a0: 5f73 756d 285f 7461 6b65 2873 656c 662e  _sum(_take(self.
+000287b0: 6675 6e63 2c20 696e 6465 782c 2061 7869  func, index, axi
+000287c0: 7329 2c20 7365 6c66 2e69 6e64 6578 290a  s), self.index).
+000287d0: 0a20 2020 2064 6566 205f 756e 7261 7665  .    def _unrave
+000287e0: 6c28 7365 6c66 2c20 6178 6973 2c20 7368  l(self, axis, sh
+000287f0: 6170 6529 3a0a 2020 2020 2020 2020 7265  ape):.        re
+00028800: 7475 726e 206c 6f6f 705f 7375 6d28 756e  turn loop_sum(un
+00028810: 7261 7665 6c28 7365 6c66 2e66 756e 632c  ravel(self.func,
+00028820: 2061 7869 732c 2073 6861 7065 292c 2073   axis, shape), s
+00028830: 656c 662e 696e 6465 7829 0a0a 2020 2020  elf.index)..    
+00028840: 6465 6620 5f73 756d 2873 656c 662c 2061  def _sum(self, a
+00028850: 7869 7329 3a0a 2020 2020 2020 2020 7265  xis):.        re
+00028860: 7475 726e 206c 6f6f 705f 7375 6d28 7375  turn loop_sum(su
+00028870: 6d28 7365 6c66 2e66 756e 632c 2061 7869  m(self.func, axi
+00028880: 7329 2c20 7365 6c66 2e69 6e64 6578 290a  s), self.index).
+00028890: 0a20 2020 2064 6566 205f 6164 6428 7365  .    def _add(se
+000288a0: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
+000288b0: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+000288c0: 6528 6f74 6865 722c 204c 6f6f 7053 756d  e(other, LoopSum
+000288d0: 2920 616e 6420 6f74 6865 722e 696e 6465  ) and other.inde
+000288e0: 7820 3d3d 2073 656c 662e 696e 6465 783a  x == self.index:
+000288f0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00028900: 7572 6e20 6c6f 6f70 5f73 756d 2873 656c  urn loop_sum(sel
+00028910: 662e 6675 6e63 202b 206f 7468 6572 2e66  f.func + other.f
+00028920: 756e 632c 2073 656c 662e 696e 6465 7829  unc, self.index)
+00028930: 0a0a 2020 2020 6465 6620 5f6d 756c 7469  ..    def _multi
+00028940: 706c 7928 7365 6c66 2c20 6f74 6865 7229  ply(self, other)
+00028950: 3a0a 2020 2020 2020 2020 2320 4966 2060  :.        # If `
+00028960: 6f74 6865 7260 2064 6570 656e 6473 206f  other` depends o
+00028970: 6e20 6073 656c 662e 696e 6465 7860 2c20  n `self.index`, 
+00028980: 652e 672e 2062 6563 6175 7365 2060 7365  e.g. because `se
+00028990: 6c66 6020 6973 2074 6865 2069 6e6e 6572  lf` is the inner
+000289a0: 0a20 2020 2020 2020 2023 206c 6f6f 7020  .        # loop 
+000289b0: 6f66 2074 776f 206e 6573 7465 6420 604c  of two nested `L
+000289c0: 6f6f 7053 756d 6073 206f 7665 7220 7468  oopSum`s over th
+000289d0: 6520 7361 6d65 2069 6e64 6578 2c20 7468  e same index, th
+000289e0: 656e 2077 6520 7368 6f75 6c64 206e 6f74  en we should not
+000289f0: 0a20 2020 2020 2020 2023 206d 6f76 6520  .        # move 
+00028a00: 606f 7468 6572 6020 696e 7369 6465 2074  `other` inside t
+00028a10: 6869 7320 6c6f 6f70 2e0a 2020 2020 2020  his loop..      
+00028a20: 2020 6966 2073 656c 662e 696e 6465 7820    if self.index 
+00028a30: 6e6f 7420 696e 206f 7468 6572 2e61 7267  not in other.arg
+00028a40: 756d 656e 7473 3a0a 2020 2020 2020 2020  uments:.        
+00028a50: 2020 2020 7265 7475 726e 206c 6f6f 705f      return loop_
+00028a60: 7375 6d28 7365 6c66 2e66 756e 6320 2a20  sum(self.func * 
+00028a70: 6f74 6865 722c 2073 656c 662e 696e 6465  other, self.inde
+00028a80: 7829 0a0a 2020 2020 4063 6163 6865 645f  x)..    @cached_
+00028a90: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00028aa0: 205f 6173 7370 6172 7365 2873 656c 6629   _assparse(self)
+00028ab0: 3a0a 2020 2020 2020 2020 6368 756e 6b73  :.        chunks
+00028ac0: 203d 205b 5d0a 2020 2020 2020 2020 666f   = [].        fo
+00028ad0: 7220 2a65 6c65 6d5f 696e 6469 6365 732c  r *elem_indices,
+00028ae0: 2065 6c65 6d5f 7661 6c75 6573 2069 6e20   elem_values in 
+00028af0: 7365 6c66 2e66 756e 632e 5f61 7373 7061  self.func._asspa
+00028b00: 7273 653a 0a20 2020 2020 2020 2020 2020  rse:.           
+00028b10: 2069 6620 7365 6c66 2e6e 6469 6d20 3d3d   if self.ndim ==
+00028b20: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00028b30: 2020 2020 7661 6c75 6573 203d 206c 6f6f      values = loo
+00028b40: 705f 636f 6e63 6174 656e 6174 6528 496e  p_concatenate(In
+00028b50: 7365 7274 4178 6973 2865 6c65 6d5f 7661  sertAxis(elem_va
+00028b60: 6c75 6573 2c20 636f 6e73 7461 6e74 2831  lues, constant(1
+00028b70: 2929 2c20 7365 6c66 2e69 6e64 6578 290a  )), self.index).
+00028b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028b90: 7768 696c 6520 7661 6c75 6573 2e6e 6469  while values.ndi
+00028ba0: 6d3a 0a20 2020 2020 2020 2020 2020 2020  m:.             
+00028bb0: 2020 2020 2020 2076 616c 7565 7320 3d20         values = 
+00028bc0: 5375 6d28 7661 6c75 6573 290a 2020 2020  Sum(values).    
+00028bd0: 2020 2020 2020 2020 2020 2020 6368 756e              chun
+00028be0: 6b73 2e61 7070 656e 6428 2876 616c 7565  ks.append((value
+00028bf0: 732c 2929 0a20 2020 2020 2020 2020 2020  s,)).           
+00028c00: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00028c10: 2020 2020 2020 2069 6620 656c 656d 5f76         if elem_v
+00028c20: 616c 7565 732e 6e64 696d 203d 3d20 303a  alues.ndim == 0:
+00028c30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00028c40: 2020 2020 202a 656c 656d 5f69 6e64 6963       *elem_indic
+00028c50: 6573 2c20 656c 656d 5f76 616c 7565 7320  es, elem_values 
+00028c60: 3d20 2849 6e73 6572 7441 7869 7328 6172  = (InsertAxis(ar
+00028c70: 722c 2063 6f6e 7374 616e 7428 3129 2920  r, constant(1)) 
+00028c80: 666f 7220 6172 7220 696e 2028 2a65 6c65  for arr in (*ele
+00028c90: 6d5f 696e 6469 6365 732c 2065 6c65 6d5f  m_indices, elem_
+00028ca0: 7661 6c75 6573 2929 0a20 2020 2020 2020  values)).       
+00028cb0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00028cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028cd0: 2020 2023 206d 696e 696d 697a 6520 7261     # minimize ra
+00028ce0: 7665 6c73 2062 7920 7472 616e 7370 6f73  vels by transpos
+00028cf0: 696e 6720 616c 6c20 7661 7269 6162 6c65  ing all variable
+00028d00: 206c 656e 6774 6820 6178 6573 2074 6f20   length axes to 
+00028d10: 7468 6520 656e 640a 2020 2020 2020 2020  the end.        
+00028d20: 2020 2020 2020 2020 2020 2020 7661 7269              vari
+00028d30: 6162 6c65 203d 2074 7570 6c65 2869 2066  able = tuple(i f
+00028d40: 6f72 2069 2c20 6e20 696e 2065 6e75 6d65  or i, n in enume
+00028d50: 7261 7465 2865 6c65 6d5f 7661 6c75 6573  rate(elem_values
+00028d60: 2e73 6861 7065 2920 6966 2073 656c 662e  .shape) if self.
+00028d70: 696e 6465 7820 696e 206e 2e61 7267 756d  index in n.argum
+00028d80: 656e 7473 290a 2020 2020 2020 2020 2020  ents).          
+00028d90: 2020 2020 2020 2020 2020 2a65 6c65 6d5f            *elem_
+00028da0: 696e 6469 6365 732c 2065 6c65 6d5f 7661  indices, elem_va
+00028db0: 6c75 6573 203d 2028 5472 616e 7370 6f73  lues = (Transpos
+00028dc0: 652e 746f 5f65 6e64 2861 7272 2c20 2a76  e.to_end(arr, *v
+00028dd0: 6172 6961 626c 6529 2066 6f72 2061 7272  ariable) for arr
+00028de0: 2069 6e20 282a 656c 656d 5f69 6e64 6963   in (*elem_indic
+00028df0: 6573 2c20 656c 656d 5f76 616c 7565 7329  es, elem_values)
+00028e00: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00028e10: 2020 2020 2020 666f 7220 6920 696e 2076        for i in v
+00028e20: 6172 6961 626c 655b 3a2d 315d 3a0a 2020  ariable[:-1]:.  
+00028e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028e40: 2020 2020 2020 2a65 6c65 6d5f 696e 6469        *elem_indi
+00028e50: 6365 732c 2065 6c65 6d5f 7661 6c75 6573  ces, elem_values
+00028e60: 203d 206d 6170 2852 6176 656c 2c20 282a   = map(Ravel, (*
+00028e70: 656c 656d 5f69 6e64 6963 6573 2c20 656c  elem_indices, el
+00028e80: 656d 5f76 616c 7565 7329 290a 2020 2020  em_values)).    
+00028e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028ea0: 6173 7365 7274 2061 6c6c 2873 656c 662e  assert all(self.
+00028eb0: 696e 6465 7820 6e6f 7420 696e 206e 2e61  index not in n.a
+00028ec0: 7267 756d 656e 7473 2066 6f72 206e 2069  rguments for n i
+00028ed0: 6e20 656c 656d 5f76 616c 7565 732e 7368  n elem_values.sh
+00028ee0: 6170 655b 3a2d 315d 290a 2020 2020 2020  ape[:-1]).      
+00028ef0: 2020 2020 2020 2020 2020 6368 756e 6b73            chunks
+00028f00: 2e61 7070 656e 6428 7475 706c 6528 6c6f  .append(tuple(lo
+00028f10: 6f70 5f63 6f6e 6361 7465 6e61 7465 2861  op_concatenate(a
+00028f20: 7272 2c20 7365 6c66 2e69 6e64 6578 2920  rr, self.index) 
+00028f30: 666f 7220 6172 7220 696e 2028 2a65 6c65  for arr in (*ele
+00028f40: 6d5f 696e 6469 6365 732c 2065 6c65 6d5f  m_indices, elem_
+00028f50: 7661 6c75 6573 2929 290a 2020 2020 2020  values))).      
+00028f60: 2020 7265 7475 726e 2074 7570 6c65 2863    return tuple(c
+00028f70: 6875 6e6b 7329 0a0a 0a63 6c61 7373 205f  hunks)...class _
+00028f80: 5369 7a65 7354 6f4f 6666 7365 7473 2841  SizesToOffsets(A
+00028f90: 7272 6179 293a 0a0a 2020 2020 6465 6620  rray):..    def 
+00028fa0: 5f5f 696e 6974 5f5f 2873 656c 662c 2073  __init__(self, s
+00028fb0: 697a 6573 293a 0a20 2020 2020 2020 2061  izes):.        a
+00028fc0: 7373 6572 7420 7369 7a65 732e 6e64 696d  ssert sizes.ndim
+00028fd0: 203d 3d20 310a 2020 2020 2020 2020 6173   == 1.        as
+00028fe0: 7365 7274 2073 697a 6573 2e64 7479 7065  sert sizes.dtype
+00028ff0: 203d 3d20 696e 740a 2020 2020 2020 2020   == int.        
+00029000: 6173 7365 7274 2073 697a 6573 2e5f 696e  assert sizes._in
+00029010: 7462 6f75 6e64 735b 305d 203e 3d20 300a  tbounds[0] >= 0.
+00029020: 2020 2020 2020 2020 7365 6c66 2e5f 7369          self._si
+00029030: 7a65 7320 3d20 7369 7a65 730a 2020 2020  zes = sizes.    
+00029040: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
+00029050: 6974 5f5f 2861 7267 733d 2873 697a 6573  it__(args=(sizes
+00029060: 2c29 2c20 7368 6170 653d 2873 697a 6573  ,), shape=(sizes
+00029070: 2e73 6861 7065 5b30 5d2b 312c 292c 2064  .shape[0]+1,), d
+00029080: 7479 7065 3d69 6e74 290a 0a20 2020 2040  type=int)..    @
+00029090: 7374 6174 6963 6d65 7468 6f64 0a20 2020  staticmethod.   
+000290a0: 2064 6566 2065 7661 6c66 2873 697a 6573   def evalf(sizes
+000290b0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+000290c0: 6e20 6e75 6d70 792e 6375 6d73 756d 285b  n numpy.cumsum([
+000290d0: 302c 202a 7369 7a65 735d 290a 0a20 2020  0, *sizes])..   
+000290e0: 2064 6566 205f 7369 6d70 6c69 6669 6564   def _simplified
+000290f0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00029100: 756e 616c 6967 6e65 642c 2077 6865 7265  unaligned, where
+00029110: 203d 2075 6e61 6c69 676e 2873 656c 662e   = unalign(self.
+00029120: 5f73 697a 6573 290a 2020 2020 2020 2020  _sizes).        
+00029130: 6966 206e 6f74 2077 6865 7265 3a0a 2020  if not where:.  
+00029140: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00029150: 2052 616e 6765 2873 656c 662e 7368 6170   Range(self.shap
+00029160: 655b 305d 2920 2a20 6170 7065 6e64 6178  e[0]) * appendax
+00029170: 6573 2875 6e61 6c69 676e 6564 2c20 7365  es(unaligned, se
+00029180: 6c66 2e73 6861 7065 5b3a 315d 290a 0a20  lf.shape[:1]).. 
+00029190: 2020 2064 6566 205f 696e 7462 6f75 6e64     def _intbound
+000291a0: 735f 696d 706c 2873 656c 6629 3a0a 2020  s_impl(self):.  
+000291b0: 2020 2020 2020 6e20 3d20 7365 6c66 2e5f        n = self._
+000291c0: 7369 7a65 732e 7368 6170 655b 305d 2e5f  sizes.shape[0]._
+000291d0: 696e 7462 6f75 6e64 735b 315d 0a20 2020  intbounds[1].   
+000291e0: 2020 2020 206d 203d 2073 656c 662e 5f73       m = self._s
+000291f0: 697a 6573 2e5f 696e 7462 6f75 6e64 735b  izes._intbounds[
+00029200: 315d 0a20 2020 2020 2020 2072 6574 7572  1].        retur
+00029210: 6e20 302c 2028 3020 6966 206e 203d 3d20  n 0, (0 if n == 
+00029220: 3020 6f72 206d 203d 3d20 3020 656c 7365  0 or m == 0 else
+00029230: 206e 202a 206d 290a 0a0a 636c 6173 7320   n * m)...class 
+00029240: 4c6f 6f70 436f 6e63 6174 656e 6174 6528  LoopConcatenate(
+00029250: 4172 7261 7929 3a0a 0a20 2020 2064 6566  Array):..    def
+00029260: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+00029270: 6675 6e63 6461 7461 3a20 7479 7069 6e67  funcdata: typing
+00029280: 2e54 7570 6c65 5b41 7272 6179 2c20 2e2e  .Tuple[Array, ..
+00029290: 2e5d 2c20 696e 6465 785f 6e61 6d65 3a20  .], index_name: 
+000292a0: 7374 722c 206c 656e 6774 683a 2041 7272  str, length: Arr
+000292b0: 6179 293a 0a20 2020 2020 2020 2061 7373  ay):.        ass
+000292c0: 6572 7420 6973 696e 7374 616e 6365 2866  ert isinstance(f
+000292d0: 756e 6364 6174 612c 2074 7570 6c65 2920  uncdata, tuple) 
+000292e0: 616e 6420 616c 6c28 6973 696e 7374 616e  and all(isinstan
+000292f0: 6365 2864 2c20 4172 7261 7929 2066 6f72  ce(d, Array) for
+00029300: 2064 2069 6e20 6675 6e63 6461 7461 292c   d in funcdata),
+00029310: 2066 2766 756e 6364 6174 613d 7b66 756e   f'funcdata={fun
+00029320: 6364 6174 6121 727d 270a 2020 2020 2020  cdata!r}'.      
+00029330: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+00029340: 6e63 6528 696e 6465 785f 6e61 6d65 2c20  nce(index_name, 
+00029350: 7374 7229 2c20 6627 696e 6465 785f 6e61  str), f'index_na
+00029360: 6d65 3d7b 696e 6465 785f 6e61 6d65 2172  me={index_name!r
+00029370: 7d27 0a20 2020 2020 2020 2061 7373 6572  }'.        asser
+00029380: 7420 5f69 7369 6e64 6578 286c 656e 6774  t _isindex(lengt
+00029390: 6829 2c20 6627 6c65 6e67 7468 3d7b 6c65  h), f'length={le
+000293a0: 6e67 7468 2172 7d27 0a20 2020 2020 2020  ngth!r}'.       
+000293b0: 2073 656c 662e 6675 6e63 6461 7461 203d   self.funcdata =
+000293c0: 2066 756e 6364 6174 610a 2020 2020 2020   funcdata.      
+000293d0: 2020 7365 6c66 2e66 756e 632c 2073 656c    self.func, sel
+000293e0: 662e 7374 6172 742c 2073 746f 702c 202a  f.start, stop, *
+000293f0: 7368 6170 6520 3d20 6675 6e63 6461 7461  shape = funcdata
+00029400: 0a20 2020 2020 2020 2073 656c 662e 696e  .        self.in
+00029410: 6465 7820 3d20 6c6f 6f70 5f69 6e64 6578  dex = loop_index
+00029420: 2869 6e64 6578 5f6e 616d 652c 206c 656e  (index_name, len
+00029430: 6774 6829 0a20 2020 2020 2020 2069 6620  gth).        if 
+00029440: 6e6f 7420 7365 6c66 2e66 756e 632e 6e64  not self.func.nd
+00029450: 696d 3a0a 2020 2020 2020 2020 2020 2020  im:.            
+00029460: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+00029470: 2827 6578 7065 6374 6564 2061 6e20 6172  ('expected an ar
+00029480: 7261 7920 7769 7468 2061 7420 6c65 6173  ray with at leas
+00029490: 7420 6f6e 6520 6178 6973 2729 0a20 2020  t one axis').   
+000294a0: 2020 2020 2069 6620 616e 7928 7365 6c66       if any(self
+000294b0: 2e69 6e64 6578 2069 6e20 6e2e 6172 6775  .index in n.argu
+000294c0: 6d65 6e74 7320 666f 7220 6e20 696e 2073  ments for n in s
+000294d0: 6861 7065 293a 0a20 2020 2020 2020 2020  hape):.         
+000294e0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+000294f0: 726f 7228 2774 6865 2073 6861 7065 206f  ror('the shape o
+00029500: 6620 7468 6520 6675 6e63 7469 6f6e 206d  f the function m
+00029510: 7573 7420 6e6f 7420 6465 7065 6e64 206f  ust not depend o
+00029520: 6e20 7468 6520 696e 6465 7827 290a 2020  n the index').  
+00029530: 2020 2020 2020 7365 6c66 2e5f 6c63 6320        self._lcc 
+00029540: 3d20 4c6f 6f70 436f 6e63 6174 656e 6174  = LoopConcatenat
+00029550: 6543 6f6d 6269 6e65 6428 2873 656c 662e  eCombined((self.
+00029560: 6675 6e63 6461 7461 2c29 2c20 696e 6465  funcdata,), inde
+00029570: 785f 6e61 6d65 2c20 6c65 6e67 7468 290a  x_name, length).
+00029580: 2020 2020 2020 2020 7375 7065 7228 292e          super().
+00029590: 5f5f 696e 6974 5f5f 2861 7267 733d 2873  __init__(args=(s
+000295a0: 656c 662e 5f6c 6363 2c29 2c20 7368 6170  elf._lcc,), shap
+000295b0: 653d 7475 706c 6528 7368 6170 6529 2c20  e=tuple(shape), 
+000295c0: 6474 7970 653d 7365 6c66 2e66 756e 632e  dtype=self.func.
+000295d0: 6474 7970 6529 0a0a 2020 2020 4073 7461  dtype)..    @sta
+000295e0: 7469 636d 6574 686f 640a 2020 2020 6465  ticmethod.    de
+000295f0: 6620 6576 616c 6628 6172 6729 3a0a 2020  f evalf(arg):.  
+00029600: 2020 2020 2020 7265 7475 726e 2061 7267        return arg
+00029610: 5b30 5d0a 0a20 2020 2064 6566 2065 7661  [0]..    def eva
+00029620: 6c66 5f77 6974 6874 696d 6573 2873 656c  lf_withtimes(sel
+00029630: 662c 2074 696d 6573 2c20 6172 6729 3a0a  f, times, arg):.
+00029640: 2020 2020 2020 2020 7769 7468 2074 696d          with tim
+00029650: 6573 5b73 656c 665d 3a0a 2020 2020 2020  es[self]:.      
+00029660: 2020 2020 2020 7265 7475 726e 2061 7267        return arg
+00029670: 5b30 5d0a 0a20 2020 2064 6566 205f 6465  [0]..    def _de
+00029680: 7269 7661 7469 7665 2873 656c 662c 2076  rivative(self, v
+00029690: 6172 2c20 7365 656e 293a 0a20 2020 2020  ar, seen):.     
+000296a0: 2020 2072 6574 7572 6e20 5472 616e 7370     return Transp
+000296b0: 6f73 652e 6672 6f6d 5f65 6e64 286c 6f6f  ose.from_end(loo
+000296c0: 705f 636f 6e63 6174 656e 6174 6528 5472  p_concatenate(Tr
+000296d0: 616e 7370 6f73 652e 746f 5f65 6e64 2864  anspose.to_end(d
+000296e0: 6572 6976 6174 6976 6528 7365 6c66 2e66  erivative(self.f
+000296f0: 756e 632c 2076 6172 2c20 7365 656e 292c  unc, var, seen),
+00029700: 2073 656c 662e 6e64 696d 2d31 292c 2073   self.ndim-1), s
+00029710: 656c 662e 696e 6465 7829 2c20 7365 6c66  elf.index), self
+00029720: 2e6e 6469 6d2d 3129 0a0a 2020 2020 6465  .ndim-1)..    de
+00029730: 6620 5f6e 6f64 6528 7365 6c66 2c20 6361  f _node(self, ca
+00029740: 6368 652c 2073 7562 6772 6170 682c 2074  che, subgraph, t
+00029750: 696d 6573 293a 0a20 2020 2020 2020 2069  imes):.        i
+00029760: 6620 7365 6c66 2069 6e20 6361 6368 653a  f self in cache:
+00029770: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00029780: 7572 6e20 6361 6368 655b 7365 6c66 5d0a  urn cache[self].
+00029790: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000297a0: 2020 2020 2020 2020 2020 6361 6368 655b            cache[
+000297b0: 7365 6c66 5d20 3d20 6e6f 6465 203d 2073  self] = node = s
+000297c0: 656c 662e 5f6c 6363 2e5f 6e6f 6465 5f74  elf._lcc._node_t
+000297d0: 7570 6c65 2863 6163 6865 2c20 7375 6267  uple(cache, subg
+000297e0: 7261 7068 2c20 7469 6d65 7329 5b30 5d0a  raph, times)[0].
+000297f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00029800: 726e 206e 6f64 650a 0a20 2020 2064 6566  rn node..    def
+00029810: 205f 7369 6d70 6c69 6669 6564 2873 656c   _simplified(sel
+00029820: 6629 3a0a 2020 2020 2020 2020 6966 2069  f):.        if i
+00029830: 737a 6572 6f28 7365 6c66 2e66 756e 6329  szero(self.func)
+00029840: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00029850: 7475 726e 207a 6572 6f73 5f6c 696b 6528  turn zeros_like(
+00029860: 7365 6c66 290a 2020 2020 2020 2020 656c  self).        el
+00029870: 6966 2073 656c 662e 696e 6465 7820 6e6f  if self.index no
+00029880: 7420 696e 2073 656c 662e 6675 6e63 2e61  t in self.func.a
+00029890: 7267 756d 656e 7473 3a0a 2020 2020 2020  rguments:.      
+000298a0: 2020 2020 2020 7265 7475 726e 2052 6176        return Rav
+000298b0: 656c 2854 7261 6e73 706f 7365 2e66 726f  el(Transpose.fro
+000298c0: 6d5f 656e 6428 496e 7365 7274 4178 6973  m_end(InsertAxis
+000298d0: 2873 656c 662e 6675 6e63 2c20 7365 6c66  (self.func, self
+000298e0: 2e69 6e64 6578 2e6c 656e 6774 6829 2c20  .index.length), 
+000298f0: 2d32 2929 0a20 2020 2020 2020 2075 6e61  -2)).        una
+00029900: 6c69 676e 6564 2c20 7768 6572 6520 3d20  ligned, where = 
+00029910: 756e 616c 6967 6e28 7365 6c66 2e66 756e  unalign(self.fun
+00029920: 6329 0a20 2020 2020 2020 2069 6620 7365  c).        if se
+00029930: 6c66 2e6e 6469 6d2d 3120 6e6f 7420 696e  lf.ndim-1 not in
+00029940: 2077 6865 7265 3a0a 2020 2020 2020 2020   where:.        
+00029950: 2020 2020 2320 7265 696e 7365 7274 2063      # reinsert c
+00029960: 6f6e 6361 7465 6e61 7469 6f6e 2061 7869  oncatenation axi
+00029970: 732c 2061 7420 756e 6974 206c 656e 6774  s, at unit lengt
+00029980: 6820 6966 2070 6f73 7369 626c 6520 736f  h if possible so
+00029990: 2077 6520 6361 6e0a 2020 2020 2020 2020   we can.        
+000299a0: 2020 2020 2320 696e 7365 7274 2074 6865      # insert the
+000299b0: 2072 656d 6169 6e64 6572 206f 7574 7369   remainder outsi
+000299c0: 6465 206f 6620 7468 6520 6c6f 6f70 0a20  de of the loop. 
+000299d0: 2020 2020 2020 2020 2020 2075 6e61 6c69             unali
+000299e0: 676e 6564 203d 2049 6e73 6572 7441 7869  gned = InsertAxi
+000299f0: 7328 756e 616c 6967 6e65 642c 2073 656c  s(unaligned, sel
+00029a00: 662e 6675 6e63 2e73 6861 7065 5b2d 315d  f.func.shape[-1]
+00029a10: 2069 6620 7365 6c66 2e69 6e64 6578 2069   if self.index i
+00029a20: 6e20 7365 6c66 2e66 756e 632e 7368 6170  n self.func.shap
+00029a30: 655b 2d31 5d2e 6172 6775 6d65 6e74 7320  e[-1].arguments 
+00029a40: 656c 7365 2063 6f6e 7374 616e 7428 3129  else constant(1)
+00029a50: 290a 2020 2020 2020 2020 2020 2020 7768  ).            wh
+00029a60: 6572 6520 2b3d 2073 656c 662e 6e64 696d  ere += self.ndim
+00029a70: 2d31 2c0a 2020 2020 2020 2020 656c 6966  -1,.        elif
+00029a80: 2077 6865 7265 5b2d 315d 2021 3d20 7365   where[-1] != se
+00029a90: 6c66 2e6e 6469 6d2d 313a 0a20 2020 2020  lf.ndim-1:.     
+00029aa0: 2020 2020 2020 2023 2062 7269 6e67 2063         # bring c
+00029ab0: 6f6e 6361 7465 6e61 7469 6f6e 2061 7869  oncatenation axi
+00029ac0: 7320 746f 2074 6865 2065 6e64 0a20 2020  s to the end.   
+00029ad0: 2020 2020 2020 2020 2075 6e61 6c69 676e           unalign
+00029ae0: 6564 203d 2054 7261 6e73 706f 7365 2e69  ed = Transpose.i
+00029af0: 6e76 2875 6e61 6c69 676e 6564 2c20 7768  nv(unaligned, wh
+00029b00: 6572 6529 0a20 2020 2020 2020 2020 2020  ere).           
+00029b10: 2077 6865 7265 203d 2074 7570 6c65 2873   where = tuple(s
+00029b20: 6f72 7465 6428 7768 6572 6529 290a 2020  orted(where)).  
+00029b30: 2020 2020 2020 6620 3d20 6c6f 6f70 5f63        f = loop_c
+00029b40: 6f6e 6361 7465 6e61 7465 2875 6e61 6c69  oncatenate(unali
+00029b50: 676e 6564 2c20 7365 6c66 2e69 6e64 6578  gned, self.index
+00029b60: 290a 2020 2020 2020 2020 6966 206e 6f74  ).        if not
+00029b70: 205f 6571 7561 6c73 5f73 696d 706c 6966   _equals_simplif
+00029b80: 6965 6428 7365 6c66 2e73 6861 7065 5b2d  ied(self.shape[-
+00029b90: 315d 2c20 662e 7368 6170 655b 2d31 5d29  1], f.shape[-1])
+00029ba0: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+00029bb0: 6c61 7374 2061 7869 7320 7761 7320 7265  last axis was re
+00029bc0: 696e 7365 7274 6564 2061 7420 756e 6974  inserted at unit
+00029bd0: 206c 656e 6774 6820 414e 4420 6974 2077   length AND it w
+00029be0: 6173 206e 6f74 2075 6e69 7420 6c65 6e67  as not unit leng
+00029bf0: 7468 0a20 2020 2020 2020 2020 2020 2023  th.            #
+00029c00: 206f 7269 6769 6e61 6c6c 7920 2d20 6966   originally - if
+00029c10: 2069 7420 7761 7320 756e 6974 206c 656e   it was unit len
+00029c20: 6774 6820 6f72 6967 696e 616c 6c79 2074  gth originally t
+00029c30: 6865 6e20 7765 2070 726f 6365 6564 206f  hen we proceed o
+00029c40: 6e6c 7920 6966 0a20 2020 2020 2020 2020  nly if.         
+00029c50: 2020 2023 2074 6865 7265 2061 7265 206f     # there are o
+00029c60: 7468 6572 2069 6e73 6572 7469 6f6e 7320  ther insertions 
+00029c70: 746f 2070 726f 6d6f 7465 2c20 6f74 6865  to promote, othe
+00029c80: 7277 6973 6520 7765 2764 2067 6574 2061  rwise we'd get a
+00029c90: 2072 6563 7572 7369 6f6e 2e0a 2020 2020   recursion..    
+00029ca0: 2020 2020 2020 2020 6620 3d20 5261 7665          f = Rave
+00029cb0: 6c28 496e 7365 7274 4178 6973 2866 2c20  l(InsertAxis(f, 
+00029cc0: 7365 6c66 2e66 756e 632e 7368 6170 655b  self.func.shape[
+00029cd0: 2d31 5d29 290a 2020 2020 2020 2020 656c  -1])).        el
+00029ce0: 6966 206c 656e 2877 6865 7265 2920 3d3d  if len(where) ==
+00029cf0: 2073 656c 662e 6e64 696d 3a0a 2020 2020   self.ndim:.    
+00029d00: 2020 2020 2020 2020 7265 7475 726e 0a20          return. 
+00029d10: 2020 2020 2020 2072 6574 7572 6e20 616c         return al
+00029d20: 6967 6e28 662c 2077 6865 7265 2c20 7365  ign(f, where, se
+00029d30: 6c66 2e73 6861 7065 290a 0a20 2020 2064  lf.shape)..    d
+00029d40: 6566 205f 7461 6b65 6469 6167 2873 656c  ef _takediag(sel
+00029d50: 662c 2061 7869 7331 2c20 6178 6973 3229  f, axis1, axis2)
+00029d60: 3a0a 2020 2020 2020 2020 6966 2061 7869  :.        if axi
+00029d70: 7331 203c 2073 656c 662e 6e64 696d 2d31  s1 < self.ndim-1
+00029d80: 2061 6e64 2061 7869 7332 203c 2073 656c   and axis2 < sel
+00029d90: 662e 6e64 696d 2d31 3a0a 2020 2020 2020  f.ndim-1:.      
+00029da0: 2020 2020 2020 7265 7475 726e 2054 7261        return Tra
+00029db0: 6e73 706f 7365 2e66 726f 6d5f 656e 6428  nspose.from_end(
+00029dc0: 6c6f 6f70 5f63 6f6e 6361 7465 6e61 7465  loop_concatenate
+00029dd0: 2854 7261 6e73 706f 7365 2e74 6f5f 656e  (Transpose.to_en
+00029de0: 6428 5f74 616b 6564 6961 6728 7365 6c66  d(_takediag(self
+00029df0: 2e66 756e 632c 2061 7869 7331 2c20 6178  .func, axis1, ax
+00029e00: 6973 3229 2c20 2d32 292c 2073 656c 662e  is2), -2), self.
+00029e10: 696e 6465 7829 2c20 2d32 290a 0a20 2020  index), -2)..   
+00029e20: 2064 6566 205f 7461 6b65 2873 656c 662c   def _take(self,
+00029e30: 2069 6e64 6578 2c20 6178 6973 293a 0a20   index, axis):. 
+00029e40: 2020 2020 2020 2069 6620 6178 6973 203c         if axis <
+00029e50: 2073 656c 662e 6e64 696d 2d31 3a0a 2020   self.ndim-1:.  
+00029e60: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00029e70: 206c 6f6f 705f 636f 6e63 6174 656e 6174   loop_concatenat
+00029e80: 6528 5f74 616b 6528 7365 6c66 2e66 756e  e(_take(self.fun
+00029e90: 632c 2069 6e64 6578 2c20 6178 6973 292c  c, index, axis),
+00029ea0: 2073 656c 662e 696e 6465 7829 0a0a 2020   self.index)..  
+00029eb0: 2020 6465 6620 5f75 6e72 6176 656c 2873    def _unravel(s
+00029ec0: 656c 662c 2061 7869 732c 2073 6861 7065  elf, axis, shape
+00029ed0: 293a 0a20 2020 2020 2020 2069 6620 6178  ):.        if ax
+00029ee0: 6973 203c 2073 656c 662e 6e64 696d 2d31  is < self.ndim-1
+00029ef0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00029f00: 7475 726e 206c 6f6f 705f 636f 6e63 6174  turn loop_concat
+00029f10: 656e 6174 6528 756e 7261 7665 6c28 7365  enate(unravel(se
+00029f20: 6c66 2e66 756e 632c 2061 7869 732c 2073  lf.func, axis, s
+00029f30: 6861 7065 292c 2073 656c 662e 696e 6465  hape), self.inde
+00029f40: 7829 0a0a 2020 2020 4063 6163 6865 645f  x)..    @cached_
+00029f50: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00029f60: 205f 6173 7370 6172 7365 2873 656c 6629   _assparse(self)
+00029f70: 3a0a 2020 2020 2020 2020 6368 756e 6b73  :.        chunks
+00029f80: 203d 205b 5d0a 2020 2020 2020 2020 666f   = [].        fo
+00029f90: 7220 2a69 6e64 6963 6573 2c20 6c61 7374  r *indices, last
+00029fa0: 5f69 6e64 6578 2c20 7661 6c75 6573 2069  _index, values i
+00029fb0: 6e20 7365 6c66 2e66 756e 632e 5f61 7373  n self.func._ass
+00029fc0: 7061 7273 653a 0a20 2020 2020 2020 2020  parse:.         
+00029fd0: 2020 206c 6173 745f 696e 6465 7820 3d20     last_index = 
+00029fe0: 6c61 7374 5f69 6e64 6578 202b 2070 7265  last_index + pre
+00029ff0: 7065 6e64 6178 6573 2873 656c 662e 7374  pendaxes(self.st
+0002a000: 6172 742c 206c 6173 745f 696e 6465 782e  art, last_index.
+0002a010: 7368 6170 6529 0a20 2020 2020 2020 2020  shape).         
+0002a020: 2020 2063 6875 6e6b 732e 6170 7065 6e64     chunks.append
+0002a030: 2874 7570 6c65 286c 6f6f 705f 636f 6e63  (tuple(loop_conc
+0002a040: 6174 656e 6174 6528 5f66 6c61 7428 6172  atenate(_flat(ar
+0002a050: 7229 2c20 7365 6c66 2e69 6e64 6578 2920  r), self.index) 
+0002a060: 666f 7220 6172 7220 696e 2028 2a69 6e64  for arr in (*ind
+0002a070: 6963 6573 2c20 6c61 7374 5f69 6e64 6578  ices, last_index
+0002a080: 2c20 7661 6c75 6573 2929 290a 2020 2020  , values))).    
+0002a090: 2020 2020 7265 7475 726e 2074 7570 6c65      return tuple
+0002a0a0: 2863 6875 6e6b 7329 0a0a 2020 2020 4070  (chunks)..    @p
+0002a0b0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+0002a0c0: 5f6c 6f6f 705f 636f 6e63 6174 656e 6174  _loop_concatenat
+0002a0d0: 655f 6465 7073 2873 656c 6629 3a0a 2020  e_deps(self):.  
+0002a0e0: 2020 2020 2020 7265 7475 726e 2028 7365        return (se
+0002a0f0: 6c66 2c29 202b 2073 7570 6572 2829 2e5f  lf,) + super()._
+0002a100: 6c6f 6f70 5f63 6f6e 6361 7465 6e61 7465  loop_concatenate
+0002a110: 5f64 6570 730a 0a20 2020 2064 6566 205f  _deps..    def _
+0002a120: 696e 7462 6f75 6e64 735f 696d 706c 2873  intbounds_impl(s
+0002a130: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0002a140: 7475 726e 2073 656c 662e 6675 6e63 2e5f  turn self.func._
+0002a150: 696e 7462 6f75 6e64 730a 0a0a 636c 6173  intbounds...clas
+0002a160: 7320 4c6f 6f70 436f 6e63 6174 656e 6174  s LoopConcatenat
+0002a170: 6543 6f6d 6269 6e65 6428 4576 616c 7561  eCombined(Evalua
+0002a180: 626c 6529 3a0a 0a20 2020 2064 6566 205f  ble):..    def _
+0002a190: 5f69 6e69 745f 5f28 7365 6c66 2c20 6675  _init__(self, fu
+0002a1a0: 6e63 6461 7461 733a 2074 7970 696e 672e  ncdatas: typing.
+0002a1b0: 5475 706c 655b 7479 7069 6e67 2e54 7570  Tuple[typing.Tup
+0002a1c0: 6c65 5b41 7272 6179 2c20 2e2e 2e5d 2c20  le[Array, ...], 
+0002a1d0: 2e2e 2e5d 2c20 696e 6465 785f 6e61 6d65  ...], index_name
+0002a1e0: 3a20 7374 722c 206c 656e 6774 683a 2041  : str, length: A
+0002a1f0: 7272 6179 293a 0a20 2020 2020 2020 2061  rray):.        a
+0002a200: 7373 6572 7420 6973 696e 7374 616e 6365  ssert isinstance
+0002a210: 2866 756e 6364 6174 6173 2c20 7475 706c  (funcdatas, tupl
+0002a220: 6529 2061 6e64 2061 6c6c 2869 7369 6e73  e) and all(isins
+0002a230: 7461 6e63 6528 6675 6e63 6461 7461 2c20  tance(funcdata, 
+0002a240: 7475 706c 6529 2061 6e64 2061 6c6c 2869  tuple) and all(i
+0002a250: 7369 6e73 7461 6e63 6528 642c 2041 7272  sinstance(d, Arr
+0002a260: 6179 2920 666f 7220 6420 696e 2066 756e  ay) for d in fun
+0002a270: 6364 6174 6129 2066 6f72 2066 756e 6364  cdata) for funcd
+0002a280: 6174 6120 696e 2066 756e 6364 6174 6173  ata in funcdatas
+0002a290: 292c 2066 2766 756e 6364 6174 6173 3d7b  ), f'funcdatas={
+0002a2a0: 6675 6e63 6461 7461 7321 727d 270a 2020  funcdatas!r}'.  
+0002a2b0: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+0002a2c0: 6e73 7461 6e63 6528 696e 6465 785f 6e61  nstance(index_na
+0002a2d0: 6d65 2c20 7374 7229 2c20 6627 696e 6465  me, str), f'inde
+0002a2e0: 785f 6e61 6d65 3d7b 696e 6465 785f 6e61  x_name={index_na
+0002a2f0: 6d65 7d27 0a20 2020 2020 2020 2061 7373  me}'.        ass
+0002a300: 6572 7420 5f69 7369 6e64 6578 286c 656e  ert _isindex(len
+0002a310: 6774 6829 2c20 6627 6c65 6e67 7468 3d7b  gth), f'length={
+0002a320: 6c65 6e67 7468 2172 7d27 0a20 2020 2020  length!r}'.     
+0002a330: 2020 2073 656c 662e 5f66 756e 6364 6174     self._funcdat
+0002a340: 6173 203d 2066 756e 6364 6174 6173 0a20  as = funcdatas. 
+0002a350: 2020 2020 2020 2073 656c 662e 5f66 756e         self._fun
+0002a360: 6373 203d 2074 7570 6c65 2866 756e 6320  cs = tuple(func 
+0002a370: 666f 7220 6675 6e63 2c20 7374 6172 742c  for func, start,
+0002a380: 2073 746f 702c 202a 7368 6170 6520 696e   stop, *shape in
+0002a390: 2066 756e 6364 6174 6173 290a 2020 2020   funcdatas).    
+0002a3a0: 2020 2020 7365 6c66 2e5f 696e 6465 785f      self._index_
+0002a3b0: 6e61 6d65 203d 2069 6e64 6578 5f6e 616d  name = index_nam
+0002a3c0: 650a 2020 2020 2020 2020 7365 6c66 2e5f  e.        self._
+0002a3d0: 696e 6465 7820 3d20 6c6f 6f70 5f69 6e64  index = loop_ind
+0002a3e0: 6578 2869 6e64 6578 5f6e 616d 652c 206c  ex(index_name, l
+0002a3f0: 656e 6774 6829 0a20 2020 2020 2020 2069  ength).        i
+0002a400: 6620 616e 7928 6e6f 7420 6675 6e63 2e6e  f any(not func.n
+0002a410: 6469 6d20 666f 7220 6675 6e63 2069 6e20  dim for func in 
+0002a420: 7365 6c66 2e5f 6675 6e63 7329 3a0a 2020  self._funcs):.  
+0002a430: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+0002a440: 5661 6c75 6545 7272 6f72 2827 6578 7065  ValueError('expe
+0002a450: 6374 6564 2061 6e20 6172 7261 7920 7769  cted an array wi
+0002a460: 7468 2061 7420 6c65 6173 7420 6f6e 6520  th at least one 
+0002a470: 6178 6973 2729 0a20 2020 2020 2020 2073  axis').        s
+0002a480: 6861 7065 7320 3d20 7475 706c 6528 5475  hapes = tuple(Tu
+0002a490: 706c 6528 7475 706c 6528 7368 6170 6529  ple(tuple(shape)
+0002a4a0: 2920 666f 7220 6675 6e63 2c20 7374 6172  ) for func, star
+0002a4b0: 742c 2073 746f 702c 202a 7368 6170 6520  t, stop, *shape 
+0002a4c0: 696e 2066 756e 6364 6174 6173 290a 2020  in funcdatas).  
+0002a4d0: 2020 2020 2020 6966 2061 6e79 2873 656c        if any(sel
+0002a4e0: 662e 5f69 6e64 6578 2069 6e20 7368 6170  f._index in shap
+0002a4f0: 652e 6172 6775 6d65 6e74 7320 666f 7220  e.arguments for 
+0002a500: 7368 6170 6520 696e 2073 6861 7065 7329  shape in shapes)
+0002a510: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+0002a520: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
+0002a530: 7468 6520 7368 6170 6520 6f66 2074 6865  the shape of the
+0002a540: 2066 756e 6374 696f 6e20 6d75 7374 206e   function must n
+0002a550: 6f74 2064 6570 656e 6420 6f6e 2074 6865  ot depend on the
+0002a560: 2069 6e64 6578 2729 0a20 2020 2020 2020   index').       
+0002a570: 2073 656c 662e 5f69 6e76 6172 6961 6e74   self._invariant
+0002a580: 732c 2073 656c 662e 5f64 6570 656e 6465  s, self._depende
+0002a590: 6e63 6965 7320 3d20 5f64 6570 656e 6465  ncies = _depende
+0002a5a0: 6e63 6965 735f 7361 6e73 5f69 6e76 6172  ncies_sans_invar
+0002a5b0: 6961 6e74 7328 0a20 2020 2020 2020 2020  iants(.         
+0002a5c0: 2020 2054 7570 6c65 2874 7570 6c65 2854     Tuple(tuple(T
+0002a5d0: 7570 6c65 2828 7374 6172 742c 2073 746f  uple((start, sto
+0002a5e0: 702c 2066 756e 6329 2920 666f 7220 6675  p, func)) for fu
+0002a5f0: 6e63 2c20 7374 6172 742c 2073 746f 702c  nc, start, stop,
+0002a600: 202a 7368 6170 6520 696e 2066 756e 6364   *shape in funcd
+0002a610: 6174 6173 2929 2c20 7365 6c66 2e5f 696e  atas)), self._in
+0002a620: 6465 7829 0a20 2020 2020 2020 2073 7570  dex).        sup
+0002a630: 6572 2829 2e5f 5f69 6e69 745f 5f28 6172  er().__init__(ar
+0002a640: 6773 3d28 5475 706c 6528 7368 6170 6573  gs=(Tuple(shapes
+0002a650: 292c 206c 656e 6774 682c 202a 7365 6c66  ), length, *self
+0002a660: 2e5f 696e 7661 7269 616e 7473 2929 0a0a  ._invariants))..
+0002a670: 2020 2020 4063 6163 6865 645f 7072 6f70      @cached_prop
+0002a680: 6572 7479 0a20 2020 2064 6566 205f 7365  erty.    def _se
+0002a690: 7269 616c 697a 6564 5f6c 6f6f 7028 7365  rialized_loop(se
+0002a6a0: 6c66 293a 0a20 2020 2020 2020 2069 6e64  lf):.        ind
+0002a6b0: 6963 6573 203d 207b 643a 2069 2066 6f72  ices = {d: i for
+0002a6c0: 2069 2c20 6420 696e 2065 6e75 6d65 7261   i, d in enumera
+0002a6d0: 7465 2869 7465 7274 6f6f 6c73 2e63 6861  te(itertools.cha
+0002a6e0: 696e 285b 7365 6c66 2e5f 696e 6465 785d  in([self._index]
+0002a6f0: 2c20 7365 6c66 2e5f 696e 7661 7269 616e  , self._invarian
+0002a700: 7473 2c20 7365 6c66 2e5f 6465 7065 6e64  ts, self._depend
+0002a710: 656e 6369 6573 2929 7d0a 2020 2020 2020  encies))}.      
+0002a720: 2020 7265 7475 726e 2074 7570 6c65 2828    return tuple((
+0002a730: 6465 702c 2074 7570 6c65 286d 6170 2869  dep, tuple(map(i
+0002a740: 6e64 6963 6573 2e5f 5f67 6574 6974 656d  ndices.__getitem
+0002a750: 5f5f 2c20 6465 702e 5f45 7661 6c75 6162  __, dep._Evaluab
+0002a760: 6c65 5f5f 6172 6773 2929 2920 666f 7220  le__args))) for 
+0002a770: 6465 7020 696e 2073 656c 662e 5f64 6570  dep in self._dep
+0002a780: 656e 6465 6e63 6965 7329 0a0a 2020 2020  endencies)..    
+0002a790: 2320 5468 6973 2070 726f 7065 7274 7920  # This property 
+0002a7a0: 6973 2061 2064 6572 6976 6174 696f 6e20  is a derivation 
+0002a7b0: 6f66 2060 5f73 6572 6961 6c69 7a65 6460  of `_serialized`
+0002a7c0: 2077 6865 7265 2074 6865 2060 4576 616c   where the `Eval
+0002a7d0: 7561 626c 6560 0a20 2020 2023 2069 6e73  uable`.    # ins
+0002a7e0: 7461 6e63 6573 2061 7265 206d 6170 7065  tances are mappe
+0002a7f0: 6420 746f 2074 6865 2060 6576 616c 6660  d to the `evalf`
+0002a800: 206d 6574 686f 6473 206f 6620 7468 6520   methods of the 
+0002a810: 696e 7374 616e 6365 732e 2041 7373 6572  instances. Asser
+0002a820: 7469 6e67 0a20 2020 2023 2074 6861 7420  ting.    # that 
+0002a830: 6675 6e63 7469 6f6e 7320 6172 6520 696d  functions are im
+0002a840: 6d75 7461 626c 6520 6973 2064 6966 6669  mutable is diffi
+0002a850: 6375 6c74 2061 6e64 2063 7572 7265 6e74  cult and current
+0002a860: 6c79 0a20 2020 2023 2060 7479 7065 732e  ly.    # `types.
+0002a870: 5f69 7369 6d6d 7574 6162 6c65 6020 6d61  _isimmutable` ma
+0002a880: 726b 7320 616c 6c20 6675 6e63 7469 6f6e  rks all function
+0002a890: 7320 6173 206d 7574 6162 6c65 2e20 5369  s as mutable. Si
+0002a8a0: 6e63 6520 7468 650a 2020 2020 2320 6074  nce the.    # `t
+0002a8b0: 7970 6573 2e43 6163 6865 4d65 7461 6020  ypes.CacheMeta` 
+0002a8c0: 6d61 6368 696e 6572 7920 6173 7365 7274  machinery assert
+0002a8d0: 7320 696d 6d75 7461 6269 6c69 7479 206f  s immutability o
+0002a8e0: 6620 7468 6520 7072 6f70 6572 7479 2c20  f the property, 
+0002a8f0: 7765 2068 6176 650a 2020 2020 2320 746f  we have.    # to
+0002a900: 2072 6573 6f72 7420 746f 2061 2072 6567   resort to a reg
+0002a910: 756c 6172 2060 6675 6e63 746f 6f6c 732e  ular `functools.
+0002a920: 6361 6368 6564 5f70 726f 7065 7274 7960  cached_property`
+0002a930: 2e20 4e65 7665 7274 6865 6c65 7373 2c20  . Nevertheless, 
+0002a940: 7468 6973 0a20 2020 2023 2070 726f 7065  this.    # prope
+0002a950: 7274 7920 7368 6f75 6c64 2062 6520 7472  rty should be tr
+0002a960: 6561 7465 6420 6173 2069 6620 6974 2069  eated as if it i
+0002a970: 7320 696d 6d75 7461 626c 652e 0a20 2020  s immutable..   
+0002a980: 2040 6361 6368 6564 5f70 726f 7065 7274   @cached_propert
+0002a990: 790a 2020 2020 6465 6620 5f73 6572 6961  y.    def _seria
+0002a9a0: 6c69 7a65 645f 6c6f 6f70 5f65 7661 6c66  lized_loop_evalf
+0002a9b0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0002a9c0: 7265 7475 726e 2074 7570 6c65 2828 6465  return tuple((de
+0002a9d0: 702e 6576 616c 662c 2069 6e64 6963 6573  p.evalf, indices
+0002a9e0: 2920 666f 7220 6465 702c 2069 6e64 6963  ) for dep, indic
+0002a9f0: 6573 2069 6e20 7365 6c66 2e5f 7365 7269  es in self._seri
+0002aa00: 616c 697a 6564 5f6c 6f6f 7029 0a0a 2020  alized_loop)..  
+0002aa10: 2020 6465 6620 6576 616c 6628 7365 6c66    def evalf(self
+0002aa20: 2c20 7368 6170 6573 2c20 6c65 6e67 7468  , shapes, length
+0002aa30: 2c20 2a61 7267 7329 3a0a 2020 2020 2020  , *args):.      
+0002aa40: 2020 7365 7269 616c 697a 6564 5f65 7661    serialized_eva
+0002aa50: 6c66 203d 2073 656c 662e 5f73 6572 6961  lf = self._seria
+0002aa60: 6c69 7a65 645f 6c6f 6f70 5f65 7661 6c66  lized_loop_evalf
+0002aa70: 0a20 2020 2020 2020 2072 6573 756c 7473  .        results
+0002aa80: 203d 205b 7061 7261 6c6c 656c 2e73 6865   = [parallel.she
+0002aa90: 6d70 7479 2874 7570 6c65 286d 6170 2869  mpty(tuple(map(i
+0002aaa0: 6e74 2c20 7368 6170 6529 292c 2064 7479  nt, shape)), dty
+0002aab0: 7065 3d66 756e 632e 6474 7970 6529 2066  pe=func.dtype) f
+0002aac0: 6f72 2066 756e 632c 2073 6861 7065 2069  or func, shape i
+0002aad0: 6e20 7a69 7028 7365 6c66 2e5f 6675 6e63  n zip(self._func
+0002aae0: 732c 2073 6861 7065 7329 5d0a 2020 2020  s, shapes)].    
+0002aaf0: 2020 2020 7769 7468 2070 6172 616c 6c65      with paralle
+0002ab00: 6c2e 6374 7872 616e 6765 2827 6c6f 6f70  l.ctxrange('loop
+0002ab10: 207b 7d27 2e66 6f72 6d61 7428 7365 6c66   {}'.format(self
+0002ab20: 2e5f 696e 6465 785f 6e61 6d65 292c 2069  ._index_name), i
+0002ab30: 6e74 286c 656e 6774 6829 2920 6173 2069  nt(length)) as i
+0002ab40: 6e64 6963 6573 3a0a 2020 2020 2020 2020  ndices:.        
+0002ab50: 2020 2020 666f 7220 696e 6465 7820 696e      for index in
+0002ab60: 2069 6e64 6963 6573 3a0a 2020 2020 2020   indices:.      
+0002ab70: 2020 2020 2020 2020 2020 7661 6c75 6573            values
+0002ab80: 203d 205b 6e75 6d70 792e 6172 7261 7928   = [numpy.array(
+0002ab90: 696e 6465 7829 5d0a 2020 2020 2020 2020  index)].        
+0002aba0: 2020 2020 2020 2020 7661 6c75 6573 2e65          values.e
+0002abb0: 7874 656e 6428 6172 6773 290a 2020 2020  xtend(args).    
+0002abc0: 2020 2020 2020 2020 2020 2020 7661 6c75              valu
+0002abd0: 6573 2e65 7874 656e 6428 6f70 5f65 7661  es.extend(op_eva
+0002abe0: 6c66 282a 5b76 616c 7565 735b 695d 2066  lf(*[values[i] f
+0002abf0: 6f72 2069 2069 6e20 696e 6469 6365 735d  or i in indices]
+0002ac00: 2920 666f 7220 6f70 5f65 7661 6c66 2c20  ) for op_evalf, 
+0002ac10: 696e 6469 6365 7320 696e 2073 6572 6961  indices in seria
+0002ac20: 6c69 7a65 645f 6576 616c 6629 0a20 2020  lized_evalf).   
+0002ac30: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0002ac40: 2072 6573 756c 742c 2028 7374 6172 742c   result, (start,
+0002ac50: 2073 746f 702c 2062 6c6f 636b 2920 696e   stop, block) in
+0002ac60: 207a 6970 2872 6573 756c 7473 2c20 7661   zip(results, va
+0002ac70: 6c75 6573 5b2d 315d 293a 0a20 2020 2020  lues[-1]):.     
+0002ac80: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0002ac90: 6573 756c 745b 2e2e 2e2c 2073 7461 7274  esult[..., start
+0002aca0: 3a73 746f 705d 203d 2062 6c6f 636b 0a20  :stop] = block. 
+0002acb0: 2020 2020 2020 2072 6574 7572 6e20 7475         return tu
+0002acc0: 706c 6528 7265 7375 6c74 7329 0a0a 2020  ple(results)..  
+0002acd0: 2020 6465 6620 6576 616c 665f 7769 7468    def evalf_with
+0002ace0: 7469 6d65 7328 7365 6c66 2c20 7469 6d65  times(self, time
+0002acf0: 732c 2073 6861 7065 732c 206c 656e 6774  s, shapes, lengt
+0002ad00: 682c 202a 6172 6773 293a 0a20 2020 2020  h, *args):.     
+0002ad10: 2020 2073 6572 6961 6c69 7a65 6420 3d20     serialized = 
+0002ad20: 7365 6c66 2e5f 7365 7269 616c 697a 6564  self._serialized
+0002ad30: 5f6c 6f6f 700a 2020 2020 2020 2020 7375  _loop.        su
+0002ad40: 6274 696d 6573 203d 2074 696d 6573 2e73  btimes = times.s
+0002ad50: 6574 6465 6661 756c 7428 7365 6c66 2c20  etdefault(self, 
+0002ad60: 636f 6c6c 6563 7469 6f6e 732e 6465 6661  collections.defa
+0002ad70: 756c 7464 6963 7428 5f53 7461 7473 2929  ultdict(_Stats))
+0002ad80: 0a20 2020 2020 2020 2072 6573 756c 7473  .        results
+0002ad90: 203d 205b 7061 7261 6c6c 656c 2e73 6865   = [parallel.she
+0002ada0: 6d70 7479 2874 7570 6c65 286d 6170 2869  mpty(tuple(map(i
+0002adb0: 6e74 2c20 7368 6170 6529 292c 2064 7479  nt, shape)), dty
+0002adc0: 7065 3d66 756e 632e 6474 7970 6529 2066  pe=func.dtype) f
+0002add0: 6f72 2066 756e 632c 2073 6861 7065 2069  or func, shape i
+0002ade0: 6e20 7a69 7028 7365 6c66 2e5f 6675 6e63  n zip(self._func
+0002adf0: 732c 2073 6861 7065 7329 5d0a 2020 2020  s, shapes)].    
+0002ae00: 2020 2020 666f 7220 696e 6465 7820 696e      for index in
+0002ae10: 2072 616e 6765 286c 656e 6774 6829 3a0a   range(length):.
+0002ae20: 2020 2020 2020 2020 2020 2020 7661 6c75              valu
+0002ae30: 6573 203d 205b 6e75 6d70 792e 6172 7261  es = [numpy.arra
+0002ae40: 7928 696e 6465 7829 5d0a 2020 2020 2020  y(index)].      
+0002ae50: 2020 2020 2020 7661 6c75 6573 2e65 7874        values.ext
+0002ae60: 656e 6428 6172 6773 290a 2020 2020 2020  end(args).      
+0002ae70: 2020 2020 2020 7661 6c75 6573 2e65 7874        values.ext
+0002ae80: 656e 6428 6f70 2e65 7661 6c66 5f77 6974  end(op.evalf_wit
+0002ae90: 6874 696d 6573 2873 7562 7469 6d65 732c  htimes(subtimes,
+0002aea0: 202a 5b76 616c 7565 735b 695d 2066 6f72   *[values[i] for
+0002aeb0: 2069 2069 6e20 696e 6469 6365 735d 2920   i in indices]) 
+0002aec0: 666f 7220 6f70 2c20 696e 6469 6365 7320  for op, indices 
+0002aed0: 696e 2073 6572 6961 6c69 7a65 6429 0a20  in serialized). 
+0002aee0: 2020 2020 2020 2020 2020 2066 6f72 2066             for f
+0002aef0: 756e 632c 2072 6573 756c 742c 2028 7374  unc, result, (st
+0002af00: 6172 742c 2073 746f 702c 2062 6c6f 636b  art, stop, block
+0002af10: 2920 696e 207a 6970 2873 656c 662e 5f66  ) in zip(self._f
+0002af20: 756e 6373 2c20 7265 7375 6c74 732c 2076  uncs, results, v
+0002af30: 616c 7565 735b 2d31 5d29 3a0a 2020 2020  alues[-1]):.    
+0002af40: 2020 2020 2020 2020 2020 2020 7769 7468              with
+0002af50: 2073 7562 7469 6d65 735b 2763 6f6e 6361   subtimes['conca
+0002af60: 7427 2c20 6675 6e63 5d3a 0a20 2020 2020  t', func]:.     
+0002af70: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0002af80: 6573 756c 745b 2e2e 2e2c 2073 7461 7274  esult[..., start
+0002af90: 3a73 746f 705d 203d 2062 6c6f 636b 0a20  :stop] = block. 
+0002afa0: 2020 2020 2020 2072 6574 7572 6e20 7475         return tu
+0002afb0: 706c 6528 7265 7375 6c74 7329 0a0a 2020  ple(results)..  
+0002afc0: 2020 6465 6620 5f6e 6f64 655f 7475 706c    def _node_tupl
+0002afd0: 6528 7365 6c66 2c20 6361 6368 652c 2073  e(self, cache, s
+0002afe0: 7562 6772 6170 682c 2074 696d 6573 293a  ubgraph, times):
+0002aff0: 0a20 2020 2020 2020 2069 6620 2873 656c  .        if (sel
+0002b000: 662c 2027 7475 706c 6527 2920 696e 2063  f, 'tuple') in c
+0002b010: 6163 6865 3a0a 2020 2020 2020 2020 2020  ache:.          
+0002b020: 2020 7265 7475 726e 2063 6163 6865 5b73    return cache[s
+0002b030: 656c 662c 2027 7475 706c 6527 5d0a 2020  elf, 'tuple'].  
+0002b040: 2020 2020 2020 7375 6263 6163 6865 203d        subcache =
+0002b050: 207b 7d0a 2020 2020 2020 2020 666f 7220   {}.        for 
+0002b060: 6172 6720 696e 2073 656c 662e 5f69 6e76  arg in self._inv
+0002b070: 6172 6961 6e74 733a 0a20 2020 2020 2020  ariants:.       
+0002b080: 2020 2020 2073 7562 6361 6368 655b 6172       subcache[ar
+0002b090: 675d 203d 2061 7267 2e5f 6e6f 6465 2863  g] = arg._node(c
+0002b0a0: 6163 6865 2c20 7375 6267 7261 7068 2c20  ache, subgraph, 
+0002b0b0: 7469 6d65 7329 0a20 2020 2020 2020 206c  times).        l
+0002b0c0: 6f6f 7067 7261 7068 203d 2053 7562 6772  oopgraph = Subgr
+0002b0d0: 6170 6828 274c 6f6f 7027 2c20 7375 6267  aph('Loop', subg
+0002b0e0: 7261 7068 290a 2020 2020 2020 2020 7375  raph).        su
+0002b0f0: 6274 696d 6573 203d 2074 696d 6573 2e67  btimes = times.g
+0002b100: 6574 2873 656c 662c 2063 6f6c 6c65 6374  et(self, collect
+0002b110: 696f 6e73 2e64 6566 6175 6c74 6469 6374  ions.defaultdict
+0002b120: 285f 5374 6174 7329 290a 2020 2020 2020  (_Stats)).      
+0002b130: 2020 636f 6e63 6174 7320 3d20 5b5d 0a20    concats = []. 
+0002b140: 2020 2020 2020 2066 6f72 2066 756e 632c         for func,
+0002b150: 2073 7461 7274 2c20 7374 6f70 2c20 2a73   start, stop, *s
+0002b160: 6861 7065 2069 6e20 7365 6c66 2e5f 6675  hape in self._fu
+0002b170: 6e63 6461 7461 733a 0a20 2020 2020 2020  ncdatas:.       
+0002b180: 2020 2020 2063 6f6e 6361 745f 6b77 6172       concat_kwar
+0002b190: 6773 203d 207b 2773 6861 7065 5b7b 7d5d  gs = {'shape[{}]
+0002b1a0: 272e 666f 726d 6174 2869 293a 206e 2e5f  '.format(i): n._
+0002b1b0: 6e6f 6465 2863 6163 6865 2c20 7375 6267  node(cache, subg
+0002b1c0: 7261 7068 2c20 7469 6d65 7329 2066 6f72  raph, times) for
+0002b1d0: 2069 2c20 6e20 696e 2065 6e75 6d65 7261   i, n in enumera
+0002b1e0: 7465 2873 6861 7065 297d 0a20 2020 2020  te(shape)}.     
+0002b1f0: 2020 2020 2020 2063 6f6e 6361 745f 6b77         concat_kw
+0002b200: 6172 6773 5b27 7374 6172 7427 5d20 3d20  args['start'] = 
+0002b210: 7374 6172 742e 5f6e 6f64 6528 7375 6263  start._node(subc
+0002b220: 6163 6865 2c20 6c6f 6f70 6772 6170 682c  ache, loopgraph,
+0002b230: 2073 7562 7469 6d65 7329 0a20 2020 2020   subtimes).     
+0002b240: 2020 2020 2020 2063 6f6e 6361 745f 6b77         concat_kw
+0002b250: 6172 6773 5b27 7374 6f70 275d 203d 2073  args['stop'] = s
+0002b260: 746f 702e 5f6e 6f64 6528 7375 6263 6163  top._node(subcac
+0002b270: 6865 2c20 6c6f 6f70 6772 6170 682c 2073  he, loopgraph, s
+0002b280: 7562 7469 6d65 7329 0a20 2020 2020 2020  ubtimes).       
+0002b290: 2020 2020 2063 6f6e 6361 745f 6b77 6172       concat_kwar
+0002b2a0: 6773 5b27 6675 6e63 275d 203d 2066 756e  gs['func'] = fun
+0002b2b0: 632e 5f6e 6f64 6528 7375 6263 6163 6865  c._node(subcache
+0002b2c0: 2c20 6c6f 6f70 6772 6170 682c 2073 7562  , loopgraph, sub
+0002b2d0: 7469 6d65 7329 0a20 2020 2020 2020 2020  times).         
+0002b2e0: 2020 2063 6f6e 6361 7473 2e61 7070 656e     concats.appen
+0002b2f0: 6428 5265 6775 6c61 724e 6f64 6528 274c  d(RegularNode('L
+0002b300: 6f6f 7043 6f6e 6361 7465 6e61 7465 272c  oopConcatenate',
+0002b310: 2028 292c 2063 6f6e 6361 745f 6b77 6172   (), concat_kwar
+0002b320: 6773 2c20 2874 7970 6528 7365 6c66 292e  gs, (type(self).
+0002b330: 5f5f 6e61 6d65 5f5f 2c20 7375 6274 696d  __name__, subtim
+0002b340: 6573 5b27 636f 6e63 6174 272c 2066 756e  es['concat', fun
+0002b350: 635d 292c 206c 6f6f 7067 7261 7068 2929  c]), loopgraph))
+0002b360: 0a20 2020 2020 2020 2063 6163 6865 5b73  .        cache[s
+0002b370: 656c 662c 2027 7475 706c 6527 5d20 3d20  elf, 'tuple'] = 
+0002b380: 636f 6e63 6174 7320 3d20 7475 706c 6528  concats = tuple(
+0002b390: 636f 6e63 6174 7329 0a20 2020 2020 2020  concats).       
+0002b3a0: 2072 6574 7572 6e20 636f 6e63 6174 730a   return concats.
+0002b3b0: 0a0a 636c 6173 7320 5365 6172 6368 536f  ..class SearchSo
+0002b3c0: 7274 6564 2841 7272 6179 293a 0a20 2020  rted(Array):.   
+0002b3d0: 2027 2727 4669 6e64 2069 6e64 6578 206f   '''Find index o
+0002b3e0: 6620 6576 616c 7561 626c 6520 6172 7261  f evaluable arra
+0002b3f0: 7920 696e 746f 2073 6f72 7465 6420 6e75  y into sorted nu
+0002b400: 6d70 7920 6172 7261 792e 2727 270a 0a20  mpy array.'''.. 
+0002b410: 2020 2023 204e 4f54 453a 2053 6561 7263     # NOTE: Searc
+0002b420: 6853 6f72 7465 6420 6973 2065 7373 656e  hSorted is essen
+0002b430: 7469 616c 6c79 2070 6f69 6e74 7769 7365  tially pointwise
+0002b440: 2069 6e20 6974 7320 6f6e 6c79 2065 7661   in its only eva
+0002b450: 6c75 6162 6c65 0a20 2020 2023 2061 7267  luable.    # arg
+0002b460: 756d 656e 742c 2062 7574 2074 6865 2050  ument, but the P
+0002b470: 6f69 6e74 7769 7365 2063 6c61 7373 2063  ointwise class c
+0002b480: 7572 7265 6e74 6c79 2064 6f65 7320 6e6f  urrently does no
+0002b490: 7420 616c 6c6f 7720 666f 720a 2020 2020  t allow for.    
+0002b4a0: 2320 6164 6469 7469 6f6e 616c 2c20 7374  # additional, st
+0002b4b0: 6174 6963 2061 7267 756d 656e 7473 2e20  atic arguments. 
+0002b4c0: 5468 6520 666f 6c6c 6f77 696e 6720 636f  The following co
+0002b4d0: 6e73 7472 7563 746f 7220 6d61 6b65 7320  nstructor makes 
+0002b4e0: 7468 6520 7374 6174 6963 0a20 2020 2023  the static.    #
+0002b4f0: 2061 7267 756d 656e 7473 206b 6579 776f   arguments keywo
+0002b500: 7264 2d6f 6e6c 7920 696e 2061 6e74 6963  rd-only in antic
+0002b510: 6970 6174 696f 6e20 6f66 2070 6f74 656e  ipation of poten
+0002b520: 7469 616c 2066 7574 7572 6520 7375 7070  tial future supp
+0002b530: 6f72 742e 0a0a 2020 2020 6465 6620 5f5f  ort...    def __
+0002b540: 696e 6974 5f5f 2873 656c 662c 2061 7267  init__(self, arg
+0002b550: 3a20 4172 7261 792c 202a 2c20 6172 7261  : Array, *, arra
+0002b560: 793a 2074 7970 6573 2e61 7272 6179 6461  y: types.arrayda
+0002b570: 7461 2c20 7369 6465 3a20 7374 722c 2073  ta, side: str, s
+0002b580: 6f72 7465 723a 2074 7970 696e 672e 4f70  orter: typing.Op
+0002b590: 7469 6f6e 616c 5b74 7970 6573 2e61 7272  tional[types.arr
+0002b5a0: 6179 6461 7461 5d29 3a0a 2020 2020 2020  aydata]):.      
+0002b5b0: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+0002b5c0: 6e63 6528 6172 672c 2041 7272 6179 292c  nce(arg, Array),
+0002b5d0: 2066 2761 7267 3d7b 6172 6721 727d 270a   f'arg={arg!r}'.
+0002b5e0: 2020 2020 2020 2020 6173 7365 7274 2069          assert i
+0002b5f0: 7369 6e73 7461 6e63 6528 6172 7261 792c  sinstance(array,
+0002b600: 2074 7970 6573 2e61 7272 6179 6461 7461   types.arraydata
+0002b610: 2920 616e 6420 6172 7261 792e 6e64 696d  ) and array.ndim
+0002b620: 203d 3d20 312c 2066 2761 7272 6179 3d7b   == 1, f'array={
+0002b630: 6172 7261 7921 727d 270a 2020 2020 2020  array!r}'.      
+0002b640: 2020 6173 7365 7274 2073 6964 6520 696e    assert side in
+0002b650: 2028 276c 6566 7427 2c20 2772 6967 6874   ('left', 'right
+0002b660: 2729 2c20 6627 7369 6465 3d7b 7369 6465  '), f'side={side
+0002b670: 2172 7d27 0a20 2020 2020 2020 2061 7373  !r}'.        ass
+0002b680: 6572 7420 736f 7274 6572 2069 7320 4e6f  ert sorter is No
+0002b690: 6e65 206f 7220 6973 696e 7374 616e 6365  ne or isinstance
+0002b6a0: 2873 6f72 7465 722c 2074 7970 6573 2e61  (sorter, types.a
+0002b6b0: 7272 6179 6461 7461 2920 616e 6420 736f  rraydata) and so
+0002b6c0: 7274 6572 2e64 7479 7065 203d 3d20 696e  rter.dtype == in
+0002b6d0: 7420 616e 6420 736f 7274 6572 2e73 6861  t and sorter.sha
+0002b6e0: 7065 203d 3d20 6172 7261 792e 7368 6170  pe == array.shap
+0002b6f0: 652c 2066 2773 6f72 7465 723d 7b73 6f72  e, f'sorter={sor
+0002b700: 7465 7221 727d 270a 2020 2020 2020 2020  ter!r}'.        
+0002b710: 7365 6c66 2e5f 6172 6720 3d20 6172 670a  self._arg = arg.
+0002b720: 2020 2020 2020 2020 7365 6c66 2e5f 6172          self._ar
+0002b730: 7261 7920 3d20 6172 7261 790a 2020 2020  ray = array.    
+0002b740: 2020 2020 7365 6c66 2e5f 7369 6465 203d      self._side =
+0002b750: 2073 6964 650a 2020 2020 2020 2020 7365   side.        se
+0002b760: 6c66 2e5f 736f 7274 6572 203d 2073 6f72  lf._sorter = sor
+0002b770: 7465 720a 2020 2020 2020 2020 7375 7065  ter.        supe
+0002b780: 7228 292e 5f5f 696e 6974 5f5f 2861 7267  r().__init__(arg
+0002b790: 733d 2861 7267 2c29 2c20 7368 6170 653d  s=(arg,), shape=
+0002b7a0: 6172 672e 7368 6170 652c 2064 7479 7065  arg.shape, dtype
+0002b7b0: 3d69 6e74 290a 0a20 2020 2064 6566 2065  =int)..    def e
+0002b7c0: 7661 6c66 2873 656c 662c 2076 616c 7565  valf(self, value
+0002b7d0: 7329 3a0a 2020 2020 2020 2020 696e 6465  s):.        inde
+0002b7e0: 7820 3d20 6e75 6d70 792e 7365 6172 6368  x = numpy.search
+0002b7f0: 736f 7274 6564 2873 656c 662e 5f61 7272  sorted(self._arr
+0002b800: 6179 2c20 7661 6c75 6573 2c20 7369 6465  ay, values, side
+0002b810: 3d73 656c 662e 5f73 6964 652c 2073 6f72  =self._side, sor
+0002b820: 7465 723d 7365 6c66 2e5f 736f 7274 6572  ter=self._sorter
+0002b830: 290a 2020 2020 2020 2020 2320 6f6e 2073  ).        # on s
+0002b840: 6f6d 6520 706c 6174 666f 726d 7320 2877  ome platforms (w
+0002b850: 696e 646f 7773 2920 7365 6172 6368 736f  indows) searchso
+0002b860: 7274 6564 2064 6f65 7320 6e6f 7420 7265  rted does not re
+0002b870: 7475 726e 2069 6e64 6963 6573 2061 730a  turn indices as.
+0002b880: 2020 2020 2020 2020 2320 6e75 6d70 792e          # numpy.
+0002b890: 6474 7970 6528 696e 7429 2c20 736f 2077  dtype(int), so w
+0002b8a0: 6520 7479 7065 2063 6173 7420 6974 2066  e type cast it f
+0002b8b0: 6f72 2063 6f6e 7369 7374 656e 6379 0a20  or consistency. 
+0002b8c0: 2020 2020 2020 2072 6574 7572 6e20 696e         return in
+0002b8d0: 6465 782e 6173 7479 7065 2869 6e74 2c20  dex.astype(int, 
+0002b8e0: 636f 7079 3d46 616c 7365 290a 0a20 2020  copy=False)..   
+0002b8f0: 2064 6566 205f 696e 7462 6f75 6e64 735f   def _intbounds_
+0002b900: 696d 706c 2873 656c 6629 3a0a 2020 2020  impl(self):.    
+0002b910: 2020 2020 7265 7475 726e 2030 2c20 7365      return 0, se
+0002b920: 6c66 2e5f 6172 7261 792e 7368 6170 655b  lf._array.shape[
+0002b930: 305d 0a0a 2020 2020 6465 6620 5f74 616b  0]..    def _tak
+0002b940: 6564 6961 6728 7365 6c66 2c20 6178 6973  ediag(self, axis
+0002b950: 312c 2061 7869 7332 293a 0a20 2020 2020  1, axis2):.     
+0002b960: 2020 2072 6574 7572 6e20 5365 6172 6368     return Search
+0002b970: 536f 7274 6564 285f 7461 6b65 6469 6167  Sorted(_takediag
+0002b980: 2873 656c 662e 5f61 7267 2c20 6178 6973  (self._arg, axis
+0002b990: 312c 2061 7869 7332 292c 2061 7272 6179  1, axis2), array
+0002b9a0: 3d73 656c 662e 5f61 7272 6179 2c20 7369  =self._array, si
+0002b9b0: 6465 3d73 656c 662e 5f73 6964 652c 2073  de=self._side, s
+0002b9c0: 6f72 7465 723d 7365 6c66 2e5f 736f 7274  orter=self._sort
+0002b9d0: 6572 290a 0a20 2020 2064 6566 205f 7461  er)..    def _ta
+0002b9e0: 6b65 2873 656c 662c 2069 6e64 6578 2c20  ke(self, index, 
+0002b9f0: 6178 6973 293a 0a20 2020 2020 2020 2072  axis):.        r
+0002ba00: 6574 7572 6e20 5365 6172 6368 536f 7274  eturn SearchSort
+0002ba10: 6564 285f 7461 6b65 2873 656c 662e 5f61  ed(_take(self._a
+0002ba20: 7267 2c20 696e 6465 782c 2061 7869 7329  rg, index, axis)
+0002ba30: 2c20 6172 7261 793d 7365 6c66 2e5f 6172  , array=self._ar
+0002ba40: 7261 792c 2073 6964 653d 7365 6c66 2e5f  ray, side=self._
+0002ba50: 7369 6465 2c20 736f 7274 6572 3d73 656c  side, sorter=sel
+0002ba60: 662e 5f73 6f72 7465 7229 0a0a 2020 2020  f._sorter)..    
+0002ba70: 6465 6620 5f75 6e72 6176 656c 2873 656c  def _unravel(sel
+0002ba80: 662c 2061 7869 732c 2073 6861 7065 293a  f, axis, shape):
+0002ba90: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0002baa0: 5365 6172 6368 536f 7274 6564 2875 6e72  SearchSorted(unr
+0002bab0: 6176 656c 2873 656c 662e 5f61 7267 2c20  avel(self._arg, 
+0002bac0: 6178 6973 2c20 7368 6170 6529 2c20 6172  axis, shape), ar
+0002bad0: 7261 793d 7365 6c66 2e5f 6172 7261 792c  ray=self._array,
+0002bae0: 2073 6964 653d 7365 6c66 2e5f 7369 6465   side=self._side
+0002baf0: 2c20 736f 7274 6572 3d73 656c 662e 5f73  , sorter=self._s
+0002bb00: 6f72 7465 7229 0a0a 0a23 2041 5558 494c  orter)...# AUXIL
+0002bb10: 4941 5259 2046 554e 4354 494f 4e53 2028  IARY FUNCTIONS (
+0002bb20: 464f 5220 494e 5445 524e 414c 2055 5345  FOR INTERNAL USE
+0002bb30: 290a 0a0a 5f61 7363 656e 6469 6e67 203d  )..._ascending =
+0002bb40: 206c 616d 6264 6120 6172 673a 206e 756d   lambda arg: num
+0002bb50: 7079 2e67 7265 6174 6572 286e 756d 7079  py.greater(numpy
+0002bb60: 2e64 6966 6628 6172 6729 2c20 3029 2e61  .diff(arg), 0).a
+0002bb70: 6c6c 2829 0a0a 0a64 6566 205f 6761 7468  ll()...def _gath
+0002bb80: 6572 626c 6f63 6b73 2862 6c6f 636b 7329  erblocks(blocks)
+0002bb90: 3a0a 2020 2020 7265 7475 726e 2074 7570  :.    return tup
+0002bba0: 6c65 2828 696e 642c 2075 7469 6c2e 7375  le((ind, util.su
+0002bbb0: 6d28 6675 6e63 7329 2920 666f 7220 696e  m(funcs)) for in
+0002bbc0: 642c 2066 756e 6373 2069 6e20 7574 696c  d, funcs in util
+0002bbd0: 2e67 6174 6865 7228 626c 6f63 6b73 2929  .gather(blocks))
+0002bbe0: 0a0a 0a64 6566 205f 6761 7468 6572 7370  ...def _gathersp
+0002bbf0: 6172 7365 6368 756e 6b73 2863 6875 6e6b  arsechunks(chunk
+0002bc00: 7329 3a0a 2020 2020 7265 7475 726e 2074  s):.    return t
+0002bc10: 7570 6c65 2828 2a69 6e64 2c20 7574 696c  uple((*ind, util
+0002bc20: 2e73 756d 2866 756e 6373 2929 2066 6f72  .sum(funcs)) for
+0002bc30: 2069 6e64 2c20 6675 6e63 7320 696e 2075   ind, funcs in u
+0002bc40: 7469 6c2e 6761 7468 6572 2828 7475 706c  til.gather((tupl
+0002bc50: 6528 696e 6429 2c20 6675 6e63 2920 666f  e(ind), func) fo
+0002bc60: 7220 2a69 6e64 2c20 6675 6e63 2069 6e20  r *ind, func in 
+0002bc70: 6368 756e 6b73 2929 0a0a 0a64 6566 205f  chunks))...def _
+0002bc80: 6e75 6d70 795f 616c 6967 6e28 612c 2062  numpy_align(a, b
+0002bc90: 293a 0a20 2020 2027 2727 6368 6563 6b20  ):.    '''check 
+0002bca0: 7368 6170 6520 636f 6e73 6973 7465 6e63  shape consistenc
+0002bcb0: 7920 616e 6420 696e 666c 6174 6520 7363  y and inflate sc
+0002bcc0: 616c 6172 7327 2727 0a0a 2020 2020 6120  alars'''..    a 
+0002bcd0: 3d20 6173 6172 7261 7928 6129 0a20 2020  = asarray(a).   
+0002bce0: 2062 203d 2061 7361 7272 6179 2862 290a   b = asarray(b).
+0002bcf0: 2020 2020 6966 2061 2e64 7479 7065 2021      if a.dtype !
+0002bd00: 3d20 622e 6474 7970 653a 0a20 2020 2020  = b.dtype:.     
+0002bd10: 2020 2069 6620 5f74 7970 655f 6f72 6465     if _type_orde
+0002bd20: 722e 696e 6465 7828 612e 6474 7970 6529  r.index(a.dtype)
+0002bd30: 203c 205f 7479 7065 5f6f 7264 6572 2e69   < _type_order.i
+0002bd40: 6e64 6578 2862 2e64 7479 7065 293a 0a20  ndex(b.dtype):. 
+0002bd50: 2020 2020 2020 2020 2020 2061 203d 2061             a = a
+0002bd60: 7374 7970 6528 612c 2062 2e64 7479 7065  stype(a, b.dtype
+0002bd70: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+0002bd80: 2020 2020 2020 2020 2020 2020 6220 3d20              b = 
+0002bd90: 6173 7479 7065 2862 2c20 612e 6474 7970  astype(b, a.dtyp
+0002bda0: 6529 0a20 2020 2069 6620 6e6f 7420 612e  e).    if not a.
+0002bdb0: 6e64 696d 3a0a 2020 2020 2020 2020 7265  ndim:.        re
+0002bdc0: 7475 726e 205f 696e 666c 6174 655f 7363  turn _inflate_sc
+0002bdd0: 616c 6172 2861 2c20 622e 7368 6170 6529  alar(a, b.shape)
+0002bde0: 2c20 620a 2020 2020 6966 206e 6f74 2062  , b.    if not b
+0002bdf0: 2e6e 6469 6d3a 0a20 2020 2020 2020 2072  .ndim:.        r
+0002be00: 6574 7572 6e20 612c 205f 696e 666c 6174  eturn a, _inflat
+0002be10: 655f 7363 616c 6172 2862 2c20 612e 7368  e_scalar(b, a.sh
+0002be20: 6170 6529 0a20 2020 2069 6620 6571 7561  ape).    if equa
+0002be30: 6c73 6861 7065 2861 2e73 6861 7065 2c20  lshape(a.shape, 
+0002be40: 622e 7368 6170 6529 3a0a 2020 2020 2020  b.shape):.      
+0002be50: 2020 7265 7475 726e 2061 2c20 620a 2020    return a, b.  
+0002be60: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+0002be70: 6f72 2827 696e 636f 6d70 6174 6962 6c65  or('incompatible
+0002be80: 2073 6861 7065 733a 207b 7d20 213d 207b   shapes: {} != {
+0002be90: 7d27 2e66 6f72 6d61 7428 2a5b 7475 706c  }'.format(*[tupl
+0002bea0: 6528 696e 7428 6e29 2069 6620 6e2e 6973  e(int(n) if n.is
+0002beb0: 636f 6e73 7461 6e74 2065 6c73 6520 6e20  constant else n 
+0002bec0: 666f 7220 6e20 696e 2061 7267 2e73 6861  for n in arg.sha
+0002bed0: 7065 2920 666f 7220 6172 6720 696e 2028  pe) for arg in (
+0002bee0: 612c 2062 295d 2929 0a0a 0a64 6566 205f  a, b)]))...def _
+0002bef0: 696e 666c 6174 655f 7363 616c 6172 2861  inflate_scalar(a
+0002bf00: 7267 2c20 7368 6170 6529 3a0a 2020 2020  rg, shape):.    
+0002bf10: 6172 6720 3d20 6173 6172 7261 7928 6172  arg = asarray(ar
+0002bf20: 6729 0a20 2020 2061 7373 6572 7420 6172  g).    assert ar
+0002bf30: 672e 6e64 696d 203d 3d20 300a 2020 2020  g.ndim == 0.    
+0002bf40: 666f 7220 6964 696d 2c20 6c65 6e67 7468  for idim, length
+0002bf50: 2069 6e20 656e 756d 6572 6174 6528 7368   in enumerate(sh
+0002bf60: 6170 6529 3a0a 2020 2020 2020 2020 6172  ape):.        ar
+0002bf70: 6720 3d20 696e 7365 7274 6178 6973 2861  g = insertaxis(a
+0002bf80: 7267 2c20 6964 696d 2c20 6c65 6e67 7468  rg, idim, length
+0002bf90: 290a 2020 2020 7265 7475 726e 2061 7267  ).    return arg
+0002bfa0: 0a0a 0a64 6566 205f 6973 756e 6971 7565  ...def _isunique
+0002bfb0: 2861 7272 6179 293a 0a20 2020 2072 6574  (array):.    ret
+0002bfc0: 7572 6e20 6e75 6d70 792e 756e 6971 7565  urn numpy.unique
+0002bfd0: 2861 7272 6179 292e 7369 7a65 203d 3d20  (array).size == 
+0002bfe0: 6172 7261 792e 7369 7a65 0a0a 0a64 6566  array.size...def
+0002bff0: 205f 6465 7065 6e64 656e 6369 6573 5f73   _dependencies_s
+0002c000: 616e 735f 696e 7661 7269 616e 7473 2866  ans_invariants(f
+0002c010: 756e 632c 2061 7267 293a 0a20 2020 2069  unc, arg):.    i
+0002c020: 6e76 6172 6961 6e74 7320 3d20 5b5d 0a20  nvariants = []. 
+0002c030: 2020 2064 6570 656e 6465 6e63 6965 7320     dependencies 
+0002c040: 3d20 5b5d 0a20 2020 205f 706f 7075 6c61  = [].    _popula
+0002c050: 7465 5f64 6570 656e 6465 6e63 6965 735f  te_dependencies_
+0002c060: 7361 6e73 5f69 6e76 6172 6961 6e74 7328  sans_invariants(
+0002c070: 6675 6e63 2c20 6172 672c 2069 6e76 6172  func, arg, invar
+0002c080: 6961 6e74 732c 2064 6570 656e 6465 6e63  iants, dependenc
+0002c090: 6965 732c 207b 6172 677d 290a 2020 2020  ies, {arg}).    
+0002c0a0: 6173 7365 7274 2028 6465 7065 6e64 656e  assert (dependen
+0002c0b0: 6369 6573 206f 7220 696e 7661 7269 616e  cies or invarian
+0002c0c0: 7473 206f 7220 5b61 7267 5d29 5b2d 315d  ts or [arg])[-1]
+0002c0d0: 203d 3d20 6675 6e63 0a20 2020 2072 6574   == func.    ret
+0002c0e0: 7572 6e20 7475 706c 6528 696e 7661 7269  urn tuple(invari
+0002c0f0: 616e 7473 292c 2074 7570 6c65 2864 6570  ants), tuple(dep
+0002c100: 656e 6465 6e63 6965 7329 0a0a 0a64 6566  endencies)...def
+0002c110: 205f 706f 7075 6c61 7465 5f64 6570 656e   _populate_depen
+0002c120: 6465 6e63 6965 735f 7361 6e73 5f69 6e76  dencies_sans_inv
+0002c130: 6172 6961 6e74 7328 6675 6e63 2c20 6172  ariants(func, ar
+0002c140: 672c 2069 6e76 6172 6961 6e74 732c 2064  g, invariants, d
+0002c150: 6570 656e 6465 6e63 6965 732c 2063 6163  ependencies, cac
+0002c160: 6865 293a 0a20 2020 2069 6620 6675 6e63  he):.    if func
+0002c170: 2069 6e20 6361 6368 653a 0a20 2020 2020   in cache:.     
+0002c180: 2020 2072 6574 7572 6e0a 2020 2020 6361     return.    ca
+0002c190: 6368 652e 6164 6428 6675 6e63 290a 2020  che.add(func).  
+0002c1a0: 2020 6966 2061 7267 2069 6e20 6675 6e63    if arg in func
+0002c1b0: 2e61 7267 756d 656e 7473 3a0a 2020 2020  .arguments:.    
+0002c1c0: 2020 2020 666f 7220 6368 696c 6420 696e      for child in
+0002c1d0: 2066 756e 632e 5f45 7661 6c75 6162 6c65   func._Evaluable
+0002c1e0: 5f5f 6172 6773 3a0a 2020 2020 2020 2020  __args:.        
+0002c1f0: 2020 2020 5f70 6f70 756c 6174 655f 6465      _populate_de
+0002c200: 7065 6e64 656e 6369 6573 5f73 616e 735f  pendencies_sans_
+0002c210: 696e 7661 7269 616e 7473 2863 6869 6c64  invariants(child
+0002c220: 2c20 6172 672c 2069 6e76 6172 6961 6e74  , arg, invariant
+0002c230: 732c 2064 6570 656e 6465 6e63 6965 732c  s, dependencies,
+0002c240: 2063 6163 6865 290a 2020 2020 2020 2020   cache).        
+0002c250: 6465 7065 6e64 656e 6369 6573 2e61 7070  dependencies.app
+0002c260: 656e 6428 6675 6e63 290a 2020 2020 656c  end(func).    el
+0002c270: 7365 3a0a 2020 2020 2020 2020 696e 7661  se:.        inva
+0002c280: 7269 616e 7473 2e61 7070 656e 6428 6675  riants.append(fu
+0002c290: 6e63 290a 0a0a 636c 6173 7320 5f53 7461  nc)...class _Sta
+0002c2a0: 7473 3a0a 0a20 2020 2064 6566 205f 5f69  ts:..    def __i
+0002c2b0: 6e69 745f 5f28 7365 6c66 2c20 6e63 616c  nit__(self, ncal
+0002c2c0: 6c73 3a20 696e 7420 3d20 302c 2074 696d  ls: int = 0, tim
+0002c2d0: 653a 2069 6e74 203d 2030 2920 2d3e 204e  e: int = 0) -> N
+0002c2e0: 6f6e 653a 0a20 2020 2020 2020 2073 656c  one:.        sel
+0002c2f0: 662e 6e63 616c 6c73 203d 206e 6361 6c6c  f.ncalls = ncall
+0002c300: 730a 2020 2020 2020 2020 7365 6c66 2e74  s.        self.t
+0002c310: 696d 6520 3d20 7469 6d65 0a20 2020 2020  ime = time.     
+0002c320: 2020 2073 656c 662e 5f73 7461 7274 203d     self._start =
+0002c330: 204e 6f6e 650a 0a20 2020 2064 6566 205f   None..    def _
+0002c340: 5f72 6570 725f 5f28 7365 6c66 293a 0a20  _repr__(self):. 
+0002c350: 2020 2020 2020 2072 6574 7572 6e20 275f         return '_
+0002c360: 5374 6174 7328 6e63 616c 6c73 3d7b 7d2c  Stats(ncalls={},
+0002c370: 2074 696d 653d 7b7d 2927 2e66 6f72 6d61   time={})'.forma
+0002c380: 7428 7365 6c66 2e6e 6361 6c6c 732c 2073  t(self.ncalls, s
+0002c390: 656c 662e 7469 6d65 290a 0a20 2020 2064  elf.time)..    d
+0002c3a0: 6566 205f 5f61 6464 5f5f 2873 656c 662c  ef __add__(self,
+0002c3b0: 206f 7468 6572 293a 0a20 2020 2020 2020   other):.       
+0002c3c0: 2069 6620 6e6f 7420 6973 696e 7374 616e   if not isinstan
+0002c3d0: 6365 286f 7468 6572 2c20 5f53 7461 7473  ce(other, _Stats
+0002c3e0: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+0002c3f0: 6574 7572 6e20 4e6f 7449 6d70 6c65 6d65  eturn NotImpleme
+0002c400: 6e74 6564 0a20 2020 2020 2020 2072 6574  nted.        ret
+0002c410: 7572 6e20 5f53 7461 7473 2873 656c 662e  urn _Stats(self.
+0002c420: 6e63 616c 6c73 2b6f 7468 6572 2e6e 6361  ncalls+other.nca
+0002c430: 6c6c 732c 2073 656c 662e 7469 6d65 2b6f  lls, self.time+o
+0002c440: 7468 6572 2e74 696d 6529 0a0a 2020 2020  ther.time)..    
+0002c450: 6465 6620 5f5f 656e 7465 725f 5f28 7365  def __enter__(se
+0002c460: 6c66 2920 2d3e 204e 6f6e 653a 0a20 2020  lf) -> None:.   
+0002c470: 2020 2020 2073 656c 662e 5f73 7461 7274       self._start
+0002c480: 203d 2074 696d 652e 7065 7266 5f63 6f75   = time.perf_cou
+0002c490: 6e74 6572 5f6e 7328 290a 0a20 2020 2064  nter_ns()..    d
+0002c4a0: 6566 205f 5f65 7869 745f 5f28 7365 6c66  ef __exit__(self
+0002c4b0: 2c20 2a65 7863 5f69 6e66 6f29 202d 3e20  , *exc_info) -> 
+0002c4c0: 4e6f 6e65 3a0a 2020 2020 2020 2020 7365  None:.        se
+0002c4d0: 6c66 2e74 696d 6520 2b3d 2074 696d 652e  lf.time += time.
+0002c4e0: 7065 7266 5f63 6f75 6e74 6572 5f6e 7328  perf_counter_ns(
+0002c4f0: 2920 2d20 7365 6c66 2e5f 7374 6172 740a  ) - self._start.
+0002c500: 2020 2020 2020 2020 7365 6c66 2e6e 6361          self.nca
+0002c510: 6c6c 7320 2b3d 2031 0a0a 2320 4655 4e43  lls += 1..# FUNC
+0002c520: 5449 4f4e 530a 0a0a 6465 6620 6973 6172  TIONS...def isar
+0002c530: 7261 7928 6172 6729 3a0a 2020 2020 7265  ray(arg):.    re
+0002c540: 7475 726e 2069 7369 6e73 7461 6e63 6528  turn isinstance(
+0002c550: 6172 672c 2041 7272 6179 290a 0a0a 6465  arg, Array)...de
+0002c560: 6620 5f63 6f6e 7461 696e 7361 7272 6179  f _containsarray
+0002c570: 2861 7267 293a 0a20 2020 2072 6574 7572  (arg):.    retur
+0002c580: 6e20 616e 7928 6d61 7028 5f63 6f6e 7461  n any(map(_conta
+0002c590: 696e 7361 7272 6179 2c20 6172 6729 2920  insarray, arg)) 
+0002c5a0: 6966 2069 7369 6e73 7461 6e63 6528 6172  if isinstance(ar
+0002c5b0: 672c 2028 6c69 7374 2c20 7475 706c 6529  g, (list, tuple)
+0002c5c0: 2920 656c 7365 2069 7361 7272 6179 2861  ) else isarray(a
+0002c5d0: 7267 290a 0a0a 6465 6620 636f 6e73 7461  rg)...def consta
+0002c5e0: 6e74 2876 293a 0a20 2020 2072 6574 7572  nt(v):.    retur
+0002c5f0: 6e20 436f 6e73 7461 6e74 2874 7970 6573  n Constant(types
+0002c600: 2e61 7272 6179 6461 7461 2876 2929 0a0a  .arraydata(v))..
+0002c610: 0a64 6566 2069 737a 6572 6f28 6172 6729  .def iszero(arg)
+0002c620: 3a0a 2020 2020 7265 7475 726e 2069 7369  :.    return isi
+0002c630: 6e73 7461 6e63 6528 6172 672e 7369 6d70  nstance(arg.simp
+0002c640: 6c69 6669 6564 2c20 5a65 726f 7329 0a0a  lified, Zeros)..
+0002c650: 0a64 6566 207a 6572 6f73 2873 6861 7065  .def zeros(shape
+0002c660: 2c20 6474 7970 653d 666c 6f61 7429 3a0a  , dtype=float):.
+0002c670: 2020 2020 7265 7475 726e 205a 6572 6f73      return Zeros
+0002c680: 2873 6861 7065 2c20 6474 7970 6529 0a0a  (shape, dtype)..
+0002c690: 0a64 6566 207a 6572 6f73 5f6c 696b 6528  .def zeros_like(
+0002c6a0: 6172 7229 3a0a 2020 2020 7265 7475 726e  arr):.    return
+0002c6b0: 207a 6572 6f73 2861 7272 2e73 6861 7065   zeros(arr.shape
+0002c6c0: 2c20 6172 722e 6474 7970 6529 0a0a 0a64  , arr.dtype)...d
+0002c6d0: 6566 206f 6e65 7328 7368 6170 652c 2064  ef ones(shape, d
+0002c6e0: 7479 7065 3d66 6c6f 6174 293a 0a20 2020  type=float):.   
+0002c6f0: 2072 6574 7572 6e20 5f69 6e66 6c61 7465   return _inflate
+0002c700: 5f73 6361 6c61 7228 636f 6e73 7461 6e74  _scalar(constant
+0002c710: 2864 7479 7065 2831 2929 2c20 7368 6170  (dtype(1)), shap
+0002c720: 6529 0a0a 0a64 6566 206f 6e65 735f 6c69  e)...def ones_li
+0002c730: 6b65 2861 7272 293a 0a20 2020 2072 6574  ke(arr):.    ret
+0002c740: 7572 6e20 6f6e 6573 2861 7272 2e73 6861  urn ones(arr.sha
+0002c750: 7065 2c20 6172 722e 6474 7970 6529 0a0a  pe, arr.dtype)..
+0002c760: 0a64 6566 2072 6563 6970 726f 6361 6c28  .def reciprocal(
+0002c770: 6172 6729 3a0a 2020 2020 7265 7475 726e  arg):.    return
+0002c780: 2070 6f77 6572 2861 7267 2c20 6173 7479   power(arg, asty
+0002c790: 7065 282d 312c 2066 6c6f 6174 2929 0a0a  pe(-1, float))..
+0002c7a0: 0a64 6566 206e 6567 6174 6976 6528 6172  .def negative(ar
+0002c7b0: 6729 3a0a 2020 2020 7265 7475 726e 206d  g):.    return m
+0002c7c0: 756c 7469 706c 7928 6172 672c 202d 3129  ultiply(arg, -1)
+0002c7d0: 0a0a 0a64 6566 2073 696e 2878 293a 0a20  ...def sin(x):. 
+0002c7e0: 2020 2072 6574 7572 6e20 5369 6e28 7829     return Sin(x)
+0002c7f0: 0a0a 0a64 6566 2063 6f73 2878 293a 0a20  ...def cos(x):. 
+0002c800: 2020 2072 6574 7572 6e20 436f 7328 7829     return Cos(x)
+0002c810: 0a0a 0a64 6566 2074 616e 2878 293a 0a20  ...def tan(x):. 
+0002c820: 2020 2072 6574 7572 6e20 5461 6e28 7829     return Tan(x)
+0002c830: 0a0a 0a64 6566 2061 7263 7369 6e28 7829  ...def arcsin(x)
+0002c840: 3a0a 2020 2020 7265 7475 726e 2041 7263  :.    return Arc
+0002c850: 5369 6e28 7829 0a0a 0a64 6566 2061 7263  Sin(x)...def arc
+0002c860: 636f 7328 7829 3a0a 2020 2020 7265 7475  cos(x):.    retu
+0002c870: 726e 2041 7263 436f 7328 7829 0a0a 0a64  rn ArcCos(x)...d
+0002c880: 6566 2061 7263 7461 6e28 7829 3a0a 2020  ef arctan(x):.  
+0002c890: 2020 7265 7475 726e 2041 7263 5461 6e28    return ArcTan(
+0002c8a0: 7829 0a0a 0a64 6566 2073 696e 6328 7829  x)...def sinc(x)
+0002c8b0: 3a0a 2020 2020 7265 7475 726e 2053 696e  :.    return Sin
+0002c8c0: 6328 782c 206e 3d30 290a 0a0a 6465 6620  c(x, n=0)...def 
+0002c8d0: 6578 7028 7829 3a0a 2020 2020 7265 7475  exp(x):.    retu
+0002c8e0: 726e 2045 7870 2878 290a 0a0a 6465 6620  rn Exp(x)...def 
+0002c8f0: 6c6e 2878 293a 0a20 2020 2072 6574 7572  ln(x):.    retur
+0002c900: 6e20 4c6f 6728 7829 0a0a 0a64 6566 2064  n Log(x)...def d
+0002c910: 6976 6d6f 6428 782c 2079 293a 0a20 2020  ivmod(x, y):.   
+0002c920: 2064 6976 203d 2046 6c6f 6f72 4469 7669   div = FloorDivi
+0002c930: 6465 282a 5f6e 756d 7079 5f61 6c69 676e  de(*_numpy_align
+0002c940: 2878 2c20 7929 290a 2020 2020 6d6f 6420  (x, y)).    mod 
+0002c950: 3d20 7820 2d20 6469 7620 2a20 790a 2020  = x - div * y.  
+0002c960: 2020 7265 7475 726e 2064 6976 2c20 6d6f    return div, mo
+0002c970: 640a 0a0a 6465 6620 6d6f 6428 6172 6731  d...def mod(arg1
+0002c980: 2c20 6172 6732 293a 0a20 2020 2072 6574  , arg2):.    ret
+0002c990: 7572 6e20 4d6f 6428 2a5f 6e75 6d70 795f  urn Mod(*_numpy_
+0002c9a0: 616c 6967 6e28 6172 6731 2c20 6172 6732  align(arg1, arg2
+0002c9b0: 2929 0a0a 0a64 6566 206c 6f67 3228 6172  ))...def log2(ar
+0002c9c0: 6729 3a0a 2020 2020 7265 7475 726e 206c  g):.    return l
+0002c9d0: 6e28 6172 6729 202f 2063 6f6e 7374 616e  n(arg) / constan
+0002c9e0: 7428 6e75 6d70 792e 6c6f 6728 3229 290a  t(numpy.log(2)).
+0002c9f0: 0a0a 6465 6620 6c6f 6731 3028 6172 6729  ..def log10(arg)
+0002ca00: 3a0a 2020 2020 7265 7475 726e 206c 6e28  :.    return ln(
+0002ca10: 6172 6729 202f 2063 6f6e 7374 616e 7428  arg) / constant(
+0002ca20: 6e75 6d70 792e 6c6f 6728 3130 2929 0a0a  numpy.log(10))..
+0002ca30: 0a64 6566 2073 7172 7428 6172 6729 3a0a  .def sqrt(arg):.
+0002ca40: 2020 2020 7265 7475 726e 2070 6f77 6572      return power
+0002ca50: 2861 7267 2c20 636f 6e73 7461 6e74 282e  (arg, constant(.
+0002ca60: 3529 290a 0a0a 6465 6620 6172 6374 616e  5))...def arctan
+0002ca70: 3228 6172 6731 2c20 6172 6732 293a 0a20  2(arg1, arg2):. 
+0002ca80: 2020 2072 6574 7572 6e20 4172 6354 616e     return ArcTan
+0002ca90: 3228 2a5f 6e75 6d70 795f 616c 6967 6e28  2(*_numpy_align(
+0002caa0: 6172 6731 2c20 6172 6732 2929 0a0a 0a64  arg1, arg2))...d
+0002cab0: 6566 2061 6273 2861 7267 293a 0a20 2020  ef abs(arg):.   
+0002cac0: 2069 6620 6172 672e 6474 7970 6520 3d3d   if arg.dtype ==
+0002cad0: 2063 6f6d 706c 6578 3a0a 2020 2020 2020   complex:.      
+0002cae0: 2020 7265 7475 726e 2073 7172 7428 6172    return sqrt(ar
+0002caf0: 672e 7265 616c 2a2a 3220 2b20 6172 672e  g.real**2 + arg.
+0002cb00: 696d 6167 2a2a 3229 0a20 2020 2065 6c73  imag**2).    els
+0002cb10: 653a 0a20 2020 2020 2020 2072 6574 7572  e:.        retur
+0002cb20: 6e20 6172 6720 2a20 7369 676e 2861 7267  n arg * sign(arg
+0002cb30: 290a 0a0a 6465 6620 7369 6e68 2861 7267  )...def sinh(arg
+0002cb40: 293a 0a20 2020 2072 6574 7572 6e20 5369  ):.    return Si
+0002cb50: 6e48 2861 7267 290a 0a0a 6465 6620 636f  nH(arg)...def co
+0002cb60: 7368 2861 7267 293a 0a20 2020 2072 6574  sh(arg):.    ret
+0002cb70: 7572 6e20 436f 7348 2861 7267 290a 0a0a  urn CosH(arg)...
+0002cb80: 6465 6620 7461 6e68 2861 7267 293a 0a20  def tanh(arg):. 
+0002cb90: 2020 2072 6574 7572 6e20 5461 6e48 2861     return TanH(a
+0002cba0: 7267 290a 0a0a 6465 6620 6172 6374 616e  rg)...def arctan
+0002cbb0: 6828 6172 6729 3a0a 2020 2020 7265 7475  h(arg):.    retu
+0002cbc0: 726e 2041 7263 5461 6e48 2861 7267 290a  rn ArcTanH(arg).
+0002cbd0: 0a0a 6465 6620 6469 7669 6465 2861 7267  ..def divide(arg
+0002cbe0: 312c 2061 7267 3229 3a0a 2020 2020 7265  1, arg2):.    re
+0002cbf0: 7475 726e 206d 756c 7469 706c 7928 6172  turn multiply(ar
+0002cc00: 6731 2c20 7265 6369 7072 6f63 616c 2861  g1, reciprocal(a
+0002cc10: 7267 3229 290a 0a0a 6465 6620 7375 6274  rg2))...def subt
+0002cc20: 7261 6374 2861 7267 312c 2061 7267 3229  ract(arg1, arg2)
+0002cc30: 3a0a 2020 2020 7265 7475 726e 2061 6464  :.    return add
+0002cc40: 2861 7267 312c 206e 6567 6174 6976 6528  (arg1, negative(
+0002cc50: 6172 6732 2929 0a0a 0a64 6566 2069 6e73  arg2))...def ins
+0002cc60: 6572 7461 7869 7328 6172 672c 206e 2c20  ertaxis(arg, n, 
+0002cc70: 6c65 6e67 7468 293a 0a20 2020 2072 6574  length):.    ret
+0002cc80: 7572 6e20 5472 616e 7370 6f73 652e 6672  urn Transpose.fr
+0002cc90: 6f6d 5f65 6e64 2849 6e73 6572 7441 7869  om_end(InsertAxi
+0002cca0: 7328 6172 672c 206c 656e 6774 6829 2c20  s(arg, length), 
+0002ccb0: 6e29 0a0a 0a64 6566 2063 6f6e 6361 7465  n)...def concate
+0002ccc0: 6e61 7465 2861 7267 732c 2061 7869 733d  nate(args, axis=
+0002ccd0: 3029 3a0a 2020 2020 6c65 6e67 7468 7320  0):.    lengths 
+0002cce0: 3d20 5b61 7267 2e73 6861 7065 5b61 7869  = [arg.shape[axi
+0002ccf0: 735d 2066 6f72 2061 7267 2069 6e20 6172  s] for arg in ar
+0002cd00: 6773 5d0a 2020 2020 2a6f 6666 7365 7473  gs].    *offsets
+0002cd10: 2c20 746f 746c 656e 6774 6820 3d20 7574  , totlength = ut
+0002cd20: 696c 2e63 756d 7375 6d28 6c65 6e67 7468  il.cumsum(length
+0002cd30: 7320 2b20 5b30 5d29 0a20 2020 2072 6574  s + [0]).    ret
+0002cd40: 7572 6e20 5472 616e 7370 6f73 652e 6672  urn Transpose.fr
+0002cd50: 6f6d 5f65 6e64 2875 7469 6c2e 7375 6d28  om_end(util.sum(
+0002cd60: 496e 666c 6174 6528 5472 616e 7370 6f73  Inflate(Transpos
+0002cd70: 652e 746f 5f65 6e64 2861 7267 2c20 6178  e.to_end(arg, ax
+0002cd80: 6973 292c 2052 616e 6765 286c 656e 6774  is), Range(lengt
+0002cd90: 6829 202b 206f 6666 7365 742c 2074 6f74  h) + offset, tot
+0002cda0: 6c65 6e67 7468 2920 666f 7220 6172 672c  length) for arg,
+0002cdb0: 206c 656e 6774 682c 206f 6666 7365 7420   length, offset 
+0002cdc0: 696e 207a 6970 2861 7267 732c 206c 656e  in zip(args, len
+0002cdd0: 6774 6873 2c20 6f66 6673 6574 7329 292c  gths, offsets)),
+0002cde0: 2061 7869 7329 0a0a 0a64 6566 2073 7461   axis)...def sta
+0002cdf0: 636b 2861 7267 732c 2061 7869 733d 3029  ck(args, axis=0)
+0002ce00: 3a0a 2020 2020 7265 7475 726e 2054 7261  :.    return Tra
+0002ce10: 6e73 706f 7365 2e66 726f 6d5f 656e 6428  nspose.from_end(
+0002ce20: 7574 696c 2e73 756d 2849 6e66 6c61 7465  util.sum(Inflate
+0002ce30: 2861 7267 2c20 636f 6e73 7461 6e74 2869  (arg, constant(i
+0002ce40: 292c 2063 6f6e 7374 616e 7428 6c65 6e28  ), constant(len(
+0002ce50: 6172 6773 2929 2920 666f 7220 692c 2061  args))) for i, a
+0002ce60: 7267 2069 6e20 656e 756d 6572 6174 6528  rg in enumerate(
+0002ce70: 6172 6773 2929 2c20 6178 6973 290a 0a0a  args)), axis)...
+0002ce80: 6465 6620 7265 7065 6174 2861 7267 2c20  def repeat(arg, 
+0002ce90: 6c65 6e67 7468 2c20 6178 6973 293a 0a20  length, axis):. 
+0002cea0: 2020 2061 7267 203d 2061 7361 7272 6179     arg = asarray
+0002ceb0: 2861 7267 290a 2020 2020 6173 7365 7274  (arg).    assert
+0002cec0: 205f 6571 7561 6c73 5f73 6361 6c61 725f   _equals_scalar_
+0002ced0: 636f 6e73 7461 6e74 2861 7267 2e73 6861  constant(arg.sha
+0002cee0: 7065 5b61 7869 735d 2c20 3129 0a20 2020  pe[axis], 1).   
+0002cef0: 2072 6574 7572 6e20 696e 7365 7274 6178   return insertax
+0002cf00: 6973 2867 6574 2861 7267 2c20 6178 6973  is(get(arg, axis
+0002cf10: 2c20 636f 6e73 7461 6e74 2830 2929 2c20  , constant(0)), 
+0002cf20: 6178 6973 2c20 6c65 6e67 7468 290a 0a0a  axis, length)...
+0002cf30: 6465 6620 6765 7428 6172 672c 2069 6178  def get(arg, iax
+0002cf40: 2c20 6974 656d 293a 0a20 2020 2069 6620  , item):.    if 
+0002cf50: 6e75 6d65 7269 632e 6973 696e 7428 6974  numeric.isint(it
+0002cf60: 656d 293a 0a20 2020 2020 2020 2069 6620  em):.        if 
+0002cf70: 6e75 6d65 7269 632e 6973 696e 7428 6172  numeric.isint(ar
+0002cf80: 672e 7368 6170 655b 6961 785d 293a 0a20  g.shape[iax]):. 
+0002cf90: 2020 2020 2020 2020 2020 2069 7465 6d20             item 
+0002cfa0: 3d20 6e75 6d65 7269 632e 6e6f 726d 6469  = numeric.normdi
+0002cfb0: 6d28 6172 672e 7368 6170 655b 6961 785d  m(arg.shape[iax]
+0002cfc0: 2c20 6974 656d 290a 2020 2020 2020 2020  , item).        
+0002cfd0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0002cfe0: 2020 6173 7365 7274 2069 7465 6d20 3e3d    assert item >=
+0002cff0: 2030 0a20 2020 2072 6574 7572 6e20 5461   0.    return Ta
+0002d000: 6b65 2854 7261 6e73 706f 7365 2e74 6f5f  ke(Transpose.to_
+0002d010: 656e 6428 6172 672c 2069 6178 292c 2069  end(arg, iax), i
+0002d020: 7465 6d29 0a0a 0a64 6566 2064 6574 6572  tem)...def deter
+0002d030: 6d69 6e61 6e74 2861 7267 2c20 6178 6573  minant(arg, axes
+0002d040: 3d28 2d32 2c20 2d31 2929 3a0a 2020 2020  =(-2, -1)):.    
+0002d050: 7265 7475 726e 2044 6574 6572 6d69 6e61  return Determina
+0002d060: 6e74 2854 7261 6e73 706f 7365 2e74 6f5f  nt(Transpose.to_
+0002d070: 656e 6428 6172 672c 202a 6178 6573 2929  end(arg, *axes))
+0002d080: 0a0a 0a64 6566 2067 7261 6d6d 6975 6d28  ...def grammium(
+0002d090: 6172 672c 2061 7865 733d 282d 322c 202d  arg, axes=(-2, -
+0002d0a0: 3129 293a 0a20 2020 2061 7267 203d 2054  1)):.    arg = T
+0002d0b0: 7261 6e73 706f 7365 2e74 6f5f 656e 6428  ranspose.to_end(
+0002d0c0: 6172 672c 202a 6178 6573 290a 2020 2020  arg, *axes).    
+0002d0d0: 6772 616d 6d69 756d 203d 2065 696e 7375  grammium = einsu
+0002d0e0: 6d28 2741 6b69 2c41 6b6a 2d3e 4169 6a27  m('Aki,Akj->Aij'
+0002d0f0: 2c20 6172 672c 2061 7267 290a 2020 2020  , arg, arg).    
+0002d100: 7265 7475 726e 2054 7261 6e73 706f 7365  return Transpose
+0002d110: 2e66 726f 6d5f 656e 6428 6772 616d 6d69  .from_end(grammi
+0002d120: 756d 2c20 2a61 7865 7329 0a0a 0a64 6566  um, *axes)...def
+0002d130: 2073 7172 745f 6162 735f 6465 745f 6772   sqrt_abs_det_gr
+0002d140: 616d 2861 7267 2c20 6178 6573 3d28 2d32  am(arg, axes=(-2
+0002d150: 2c20 2d31 2929 3a0a 2020 2020 6172 6720  , -1)):.    arg 
+0002d160: 3d20 5472 616e 7370 6f73 652e 746f 5f65  = Transpose.to_e
+0002d170: 6e64 2861 7267 2c20 2a61 7865 7329 0a20  nd(arg, *axes). 
+0002d180: 2020 2069 6620 5f65 7175 616c 735f 7369     if _equals_si
+0002d190: 6d70 6c69 6669 6564 2861 7267 2e73 6861  mplified(arg.sha
+0002d1a0: 7065 5b2d 315d 2c20 6172 672e 7368 6170  pe[-1], arg.shap
+0002d1b0: 655b 2d32 5d29 3a0a 2020 2020 2020 2020  e[-2]):.        
+0002d1c0: 7265 7475 726e 2061 6273 2844 6574 6572  return abs(Deter
+0002d1d0: 6d69 6e61 6e74 2861 7267 2929 0a20 2020  minant(arg)).   
+0002d1e0: 2065 6c73 653a 0a20 2020 2020 2020 2072   else:.        r
+0002d1f0: 6574 7572 6e20 7371 7274 2861 6273 2844  eturn sqrt(abs(D
+0002d200: 6574 6572 6d69 6e61 6e74 2867 7261 6d6d  eterminant(gramm
+0002d210: 6975 6d28 6172 6729 2929 290a 0a0a 6465  ium(arg))))...de
+0002d220: 6620 696e 7665 7273 6528 6172 672c 2061  f inverse(arg, a
+0002d230: 7865 733d 282d 322c 202d 3129 293a 0a20  xes=(-2, -1)):. 
+0002d240: 2020 2072 6574 7572 6e20 5472 616e 7370     return Transp
+0002d250: 6f73 652e 6672 6f6d 5f65 6e64 2849 6e76  ose.from_end(Inv
+0002d260: 6572 7365 2854 7261 6e73 706f 7365 2e74  erse(Transpose.t
+0002d270: 6f5f 656e 6428 6172 672c 202a 6178 6573  o_end(arg, *axes
+0002d280: 2929 2c20 2a61 7865 7329 0a0a 0a64 6566  )), *axes)...def
+0002d290: 2074 616b 6564 6961 6728 6172 672c 2061   takediag(arg, a
+0002d2a0: 7869 733d 2d32 2c20 726d 6178 6973 3d2d  xis=-2, rmaxis=-
+0002d2b0: 3129 3a0a 2020 2020 6172 6720 3d20 6173  1):.    arg = as
+0002d2c0: 6172 7261 7928 6172 6729 0a20 2020 2061  array(arg).    a
+0002d2d0: 7869 7320 3d20 6e75 6d65 7269 632e 6e6f  xis = numeric.no
+0002d2e0: 726d 6469 6d28 6172 672e 6e64 696d 2c20  rmdim(arg.ndim, 
+0002d2f0: 6178 6973 290a 2020 2020 726d 6178 6973  axis).    rmaxis
+0002d300: 203d 206e 756d 6572 6963 2e6e 6f72 6d64   = numeric.normd
+0002d310: 696d 2861 7267 2e6e 6469 6d2c 2072 6d61  im(arg.ndim, rma
+0002d320: 7869 7329 0a20 2020 2061 7373 6572 7420  xis).    assert 
+0002d330: 6178 6973 203c 2072 6d61 7869 730a 2020  axis < rmaxis.  
+0002d340: 2020 7265 7475 726e 2054 7261 6e73 706f    return Transpo
+0002d350: 7365 2e66 726f 6d5f 656e 6428 5f74 616b  se.from_end(_tak
+0002d360: 6564 6961 6728 6172 672c 2061 7869 732c  ediag(arg, axis,
+0002d370: 2072 6d61 7869 7329 2c20 6178 6973 290a   rmaxis), axis).
+0002d380: 0a0a 6465 6620 5f74 616b 6564 6961 6728  ..def _takediag(
+0002d390: 6172 672c 2061 7869 7331 3d2d 322c 2061  arg, axis1=-2, a
+0002d3a0: 7869 7332 3d2d 3129 3a0a 2020 2020 7265  xis2=-1):.    re
+0002d3b0: 7475 726e 2054 616b 6544 6961 6728 5472  turn TakeDiag(Tr
+0002d3c0: 616e 7370 6f73 652e 746f 5f65 6e64 2861  anspose.to_end(a
+0002d3d0: 7267 2c20 6178 6973 312c 2061 7869 7332  rg, axis1, axis2
+0002d3e0: 2929 0a0a 0a64 6566 2064 6572 6976 6174  ))...def derivat
+0002d3f0: 6976 6528 6675 6e63 2c20 7661 722c 2073  ive(func, var, s
+0002d400: 6565 6e3d 4e6f 6e65 293a 0a20 2020 2027  een=None):.    '
+0002d410: 6465 7269 7661 7469 7665 270a 0a20 2020  derivative'..   
+0002d420: 2061 7373 6572 7420 6973 696e 7374 616e   assert isinstan
+0002d430: 6365 2876 6172 2c20 4465 7269 7661 7469  ce(var, Derivati
+0002d440: 7665 5461 7267 6574 4261 7365 292c 2027  veTargetBase), '
+0002d450: 696e 7661 6c69 6420 6465 7269 7661 7469  invalid derivati
+0002d460: 7665 2074 6172 6765 7420 7b21 727d 272e  ve target {!r}'.
+0002d470: 666f 726d 6174 2876 6172 290a 2020 2020  format(var).    
+0002d480: 6966 2076 6172 2e64 7479 7065 2069 6e20  if var.dtype in 
+0002d490: 2862 6f6f 6c2c 2069 6e74 2920 6f72 2076  (bool, int) or v
+0002d4a0: 6172 206e 6f74 2069 6e20 6675 6e63 2e61  ar not in func.a
+0002d4b0: 7267 756d 656e 7473 3a0a 2020 2020 2020  rguments:.      
+0002d4c0: 2020 7265 7475 726e 205a 6572 6f73 2866    return Zeros(f
+0002d4d0: 756e 632e 7368 6170 6520 2b20 7661 722e  unc.shape + var.
+0002d4e0: 7368 6170 652c 2064 7479 7065 3d66 756e  shape, dtype=fun
+0002d4f0: 632e 6474 7970 6529 0a20 2020 2069 6620  c.dtype).    if 
+0002d500: 7365 656e 2069 7320 4e6f 6e65 3a0a 2020  seen is None:.  
+0002d510: 2020 2020 2020 7365 656e 203d 207b 7d0a        seen = {}.
+0002d520: 2020 2020 6966 2066 756e 6320 696e 2073      if func in s
+0002d530: 6565 6e3a 0a20 2020 2020 2020 2072 6573  een:.        res
+0002d540: 756c 7420 3d20 7365 656e 5b66 756e 635d  ult = seen[func]
+0002d550: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+0002d560: 2020 2072 6573 756c 7420 3d20 6675 6e63     result = func
+0002d570: 2e5f 6465 7269 7661 7469 7665 2876 6172  ._derivative(var
+0002d580: 2c20 7365 656e 290a 2020 2020 2020 2020  , seen).        
+0002d590: 7365 656e 5b66 756e 635d 203d 2072 6573  seen[func] = res
+0002d5a0: 756c 740a 2020 2020 6173 7365 7274 2065  ult.    assert e
+0002d5b0: 7175 616c 7368 6170 6528 7265 7375 6c74  qualshape(result
+0002d5c0: 2e73 6861 7065 2c20 6675 6e63 2e73 6861  .shape, func.sha
+0002d5d0: 7065 2b76 6172 2e73 6861 7065 2920 616e  pe+var.shape) an
+0002d5e0: 6420 7265 7375 6c74 2e64 7479 7065 203d  d result.dtype =
+0002d5f0: 3d20 6675 6e63 2e64 7479 7065 2c20 2762  = func.dtype, 'b
+0002d600: 7567 2069 6e20 7b7d 2e5f 6465 7269 7661  ug in {}._deriva
+0002d610: 7469 7665 272e 666f 726d 6174 2874 7970  tive'.format(typ
+0002d620: 6528 6675 6e63 292e 5f5f 6e61 6d65 5f5f  e(func).__name__
+0002d630: 290a 2020 2020 7265 7475 726e 2072 6573  ).    return res
+0002d640: 756c 740a 0a0a 6465 6620 6469 6167 6f6e  ult...def diagon
+0002d650: 616c 697a 6528 6172 672c 2061 7869 733d  alize(arg, axis=
+0002d660: 2d31 2c20 6e65 7761 7869 733d 2d31 293a  -1, newaxis=-1):
+0002d670: 0a20 2020 2061 7267 203d 2061 7361 7272  .    arg = asarr
+0002d680: 6179 2861 7267 290a 2020 2020 6178 6973  ay(arg).    axis
+0002d690: 203d 206e 756d 6572 6963 2e6e 6f72 6d64   = numeric.normd
+0002d6a0: 696d 2861 7267 2e6e 6469 6d2c 2061 7869  im(arg.ndim, axi
+0002d6b0: 7329 0a20 2020 206e 6577 6178 6973 203d  s).    newaxis =
+0002d6c0: 206e 756d 6572 6963 2e6e 6f72 6d64 696d   numeric.normdim
+0002d6d0: 2861 7267 2e6e 6469 6d2b 312c 206e 6577  (arg.ndim+1, new
+0002d6e0: 6178 6973 290a 2020 2020 6173 7365 7274  axis).    assert
+0002d6f0: 2061 7869 7320 3c20 6e65 7761 7869 730a   axis < newaxis.
+0002d700: 2020 2020 7265 7475 726e 2054 7261 6e73      return Trans
+0002d710: 706f 7365 2e66 726f 6d5f 656e 6428 4469  pose.from_end(Di
+0002d720: 6167 6f6e 616c 697a 6528 5472 616e 7370  agonalize(Transp
+0002d730: 6f73 652e 746f 5f65 6e64 2861 7267 2c20  ose.to_end(arg, 
+0002d740: 6178 6973 2929 2c20 6178 6973 2c20 6e65  axis)), axis, ne
+0002d750: 7761 7869 7329 0a0a 0a64 6566 2073 6967  waxis)...def sig
+0002d760: 6e28 6172 6729 3a0a 2020 2020 6172 6720  n(arg):.    arg 
+0002d770: 3d20 6173 6172 7261 7928 6172 6729 0a20  = asarray(arg). 
+0002d780: 2020 2069 6620 6172 672e 6474 7970 6520     if arg.dtype 
+0002d790: 3d3d 2063 6f6d 706c 6578 3a0a 2020 2020  == complex:.    
+0002d7a0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
+0002d7b0: 7272 6f72 2827 7369 676e 2069 7320 6e6f  rror('sign is no
+0002d7c0: 7420 6465 6669 6e65 6420 666f 7220 636f  t defined for co
+0002d7d0: 6d70 6c65 7820 6e75 6d62 6572 7327 290a  mplex numbers').
+0002d7e0: 2020 2020 7265 7475 726e 2053 6967 6e28      return Sign(
+0002d7f0: 6172 6729 0a0a 0a64 6566 2065 6967 2861  arg)...def eig(a
+0002d800: 7267 2c20 6178 6573 3d28 2d32 2c20 2d31  rg, axes=(-2, -1
+0002d810: 292c 2073 796d 6d65 7472 6963 3d46 616c  ), symmetric=Fal
+0002d820: 7365 293a 0a20 2020 2065 6967 7661 6c2c  se):.    eigval,
+0002d830: 2065 6967 7665 6320 3d20 4569 6728 5472   eigvec = Eig(Tr
+0002d840: 616e 7370 6f73 652e 746f 5f65 6e64 2861  anspose.to_end(a
+0002d850: 7267 2c20 2a61 7865 7329 2c20 7379 6d6d  rg, *axes), symm
+0002d860: 6574 7269 6329 0a20 2020 2072 6574 7572  etric).    retur
+0002d870: 6e20 5475 706c 6528 7475 706c 6528 5472  n Tuple(tuple(Tr
+0002d880: 616e 7370 6f73 652e 6672 6f6d 5f65 6e64  anspose.from_end
+0002d890: 2876 2c20 2a61 7865 7329 2066 6f72 2076  (v, *axes) for v
+0002d8a0: 2069 6e20 5b64 6961 676f 6e61 6c69 7a65   in [diagonalize
+0002d8b0: 2865 6967 7661 6c29 2c20 6569 6776 6563  (eigval), eigvec
+0002d8c0: 5d29 290a 0a0a 6465 6620 5f74 616b 6573  ]))...def _takes
+0002d8d0: 6c69 6365 2861 7267 3a20 4172 7261 792c  lice(arg: Array,
+0002d8e0: 2073 3a20 736c 6963 652c 2061 7869 733a   s: slice, axis:
+0002d8f0: 2069 6e74 293a 0a20 2020 2061 7373 6572   int):.    asser
+0002d900: 7420 6973 696e 7374 616e 6365 2861 7267  t isinstance(arg
+0002d910: 2c20 4172 7261 7929 2c20 6627 6172 673d  , Array), f'arg=
+0002d920: 7b61 7267 2172 7d27 0a20 2020 2061 7373  {arg!r}'.    ass
+0002d930: 6572 7420 6973 696e 7374 616e 6365 2873  ert isinstance(s
+0002d940: 2c20 736c 6963 6529 2c20 6627 733d 7b73  , slice), f's={s
+0002d950: 2172 7d27 0a20 2020 2061 7373 6572 7420  !r}'.    assert 
+0002d960: 6973 696e 7374 616e 6365 2861 7869 732c  isinstance(axis,
+0002d970: 2069 6e74 292c 2066 2761 7869 733d 7b61   int), f'axis={a
+0002d980: 7869 7321 727d 270a 2020 2020 6e20 3d20  xis!r}'.    n = 
+0002d990: 6172 672e 7368 6170 655b 6178 6973 5d0a  arg.shape[axis].
+0002d9a0: 2020 2020 6966 2073 2e73 7465 7020 3d3d      if s.step ==
+0002d9b0: 204e 6f6e 6520 6f72 2073 2e73 7465 7020   None or s.step 
+0002d9c0: 3d3d 2031 3a0a 2020 2020 2020 2020 7374  == 1:.        st
+0002d9d0: 6172 7420 3d20 3020 6966 2073 2e73 7461  art = 0 if s.sta
+0002d9e0: 7274 2069 7320 4e6f 6e65 2065 6c73 6520  rt is None else 
+0002d9f0: 732e 7374 6172 7420 6966 2073 2e73 7461  s.start if s.sta
+0002da00: 7274 203e 3d20 3020 656c 7365 2073 2e73  rt >= 0 else s.s
+0002da10: 7461 7274 202b 206e 0a20 2020 2020 2020  tart + n.       
+0002da20: 2073 746f 7020 3d20 6e20 6966 2073 2e73   stop = n if s.s
+0002da30: 746f 7020 6973 204e 6f6e 6520 656c 7365  top is None else
+0002da40: 2073 2e73 746f 7020 6966 2073 2e73 746f   s.stop if s.sto
+0002da50: 7020 3e3d 2030 2065 6c73 6520 732e 7374  p >= 0 else s.st
+0002da60: 6f70 202b 206e 0a20 2020 2020 2020 2069  op + n.        i
+0002da70: 6620 7374 6172 7420 3d3d 2030 2061 6e64  f start == 0 and
+0002da80: 2073 746f 7020 3d3d 206e 3a0a 2020 2020   stop == n:.    
+0002da90: 2020 2020 2020 2020 7265 7475 726e 2061          return a
+0002daa0: 7267 0a20 2020 2020 2020 2069 6e64 6578  rg.        index
+0002dab0: 203d 2052 616e 6765 2861 7361 7272 6179   = Range(asarray
+0002dac0: 2873 746f 702d 7374 6172 7429 2920 2b20  (stop-start)) + 
+0002dad0: 7374 6172 740a 2020 2020 656c 6966 206e  start.    elif n
+0002dae0: 2e69 7363 6f6e 7374 616e 743a 0a20 2020  .isconstant:.   
+0002daf0: 2020 2020 2069 6e64 6578 203d 2063 6f6e       index = con
+0002db00: 7374 616e 7428 6e75 6d70 792e 6172 616e  stant(numpy.aran
+0002db10: 6765 282a 732e 696e 6469 6365 7328 6172  ge(*s.indices(ar
+0002db20: 672e 7368 6170 655b 6178 6973 5d29 2929  g.shape[axis])))
+0002db30: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+0002db40: 2020 2072 6169 7365 2045 7863 6570 7469     raise Excepti
+0002db50: 6f6e 2827 6120 6e6f 6e2d 756e 6974 2073  on('a non-unit s
+0002db60: 6c69 6365 2072 6571 7569 7265 7320 6120  lice requires a 
+0002db70: 636f 6e73 7461 6e74 2d6c 656e 6774 6820  constant-length 
+0002db80: 6178 6973 2729 0a20 2020 2072 6574 7572  axis').    retur
+0002db90: 6e20 7461 6b65 2861 7267 2c20 696e 6465  n take(arg, inde
+0002dba0: 782c 2061 7869 7329 0a0a 0a64 6566 2074  x, axis)...def t
+0002dbb0: 616b 6528 6172 673a 2041 7272 6179 2c20  ake(arg: Array, 
+0002dbc0: 696e 6465 783a 2041 7272 6179 2c20 6178  index: Array, ax
+0002dbd0: 6973 3a20 696e 7429 3a0a 2020 2020 6173  is: int):.    as
+0002dbe0: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
+0002dbf0: 6172 672c 2041 7272 6179 292c 2066 2761  arg, Array), f'a
+0002dc00: 7267 3d7b 6172 6721 727d 270a 2020 2020  rg={arg!r}'.    
+0002dc10: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+0002dc20: 6528 696e 6465 782c 2041 7272 6179 2920  e(index, Array) 
+0002dc30: 616e 6420 696e 6465 782e 6474 7970 6520  and index.dtype 
+0002dc40: 696e 2028 626f 6f6c 2c20 696e 7429 2061  in (bool, int) a
+0002dc50: 6e64 2069 6e64 6578 2e6e 6469 6d20 3d3d  nd index.ndim ==
+0002dc60: 2031 2c20 6627 696e 6465 783d 7b69 6e64   1, f'index={ind
+0002dc70: 6578 2172 7d27 0a20 2020 2061 7373 6572  ex!r}'.    asser
+0002dc80: 7420 6973 696e 7374 616e 6365 2861 7869  t isinstance(axi
+0002dc90: 732c 2069 6e74 292c 2066 2761 7869 733d  s, int), f'axis=
+0002dca0: 7b61 7869 7321 727d 270a 2020 2020 6c65  {axis!r}'.    le
+0002dcb0: 6e67 7468 203d 2061 7267 2e73 6861 7065  ngth = arg.shape
+0002dcc0: 5b61 7869 735d 0a20 2020 2069 6620 696e  [axis].    if in
+0002dcd0: 6465 782e 6474 7970 6520 3d3d 2062 6f6f  dex.dtype == boo
+0002dce0: 6c3a 0a20 2020 2020 2020 2061 7373 6572  l:.        asser
+0002dcf0: 7420 5f65 7175 616c 735f 7369 6d70 6c69  t _equals_simpli
+0002dd00: 6669 6564 2869 6e64 6578 2e73 6861 7065  fied(index.shape
+0002dd10: 5b30 5d2c 206c 656e 6774 6829 0a20 2020  [0], length).   
+0002dd20: 2020 2020 2069 6e64 6578 203d 2046 696e       index = Fin
+0002dd30: 6428 696e 6465 7829 0a20 2020 2065 6c69  d(index).    eli
+0002dd40: 6620 696e 6465 782e 6973 636f 6e73 7461  f index.isconsta
+0002dd50: 6e74 3a0a 2020 2020 2020 2020 696e 6465  nt:.        inde
+0002dd60: 785f 203d 2069 6e64 6578 2e65 7661 6c28  x_ = index.eval(
+0002dd70: 290a 2020 2020 2020 2020 696e 6567 203d  ).        ineg =
+0002dd80: 206e 756d 7079 2e6c 6573 7328 696e 6465   numpy.less(inde
+0002dd90: 785f 2c20 3029 0a20 2020 2020 2020 2069  x_, 0).        i
+0002dda0: 6620 6e6f 7420 6c65 6e67 7468 2e69 7363  f not length.isc
+0002ddb0: 6f6e 7374 616e 743a 0a20 2020 2020 2020  onstant:.       
+0002ddc0: 2020 2020 2069 6620 696e 6567 2e61 6e79       if ineg.any
+0002ddd0: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+0002dde0: 2020 2020 7261 6973 6520 496e 6465 7845      raise IndexE
+0002ddf0: 7272 6f72 2827 6e65 6761 7469 7665 2069  rror('negative i
+0002de00: 6e64 6963 6573 206f 6e6c 7920 616c 6c6f  ndices only allo
+0002de10: 7765 6420 666f 7220 636f 6e73 7461 6e74  wed for constant
+0002de20: 2d6c 656e 6774 6820 6178 6573 2729 0a20  -length axes'). 
+0002de30: 2020 2020 2020 2065 6c69 6620 696e 6567         elif ineg
+0002de40: 2e61 6e79 2829 3a0a 2020 2020 2020 2020  .any():.        
+0002de50: 2020 2020 6966 206e 756d 7079 2e6c 6573      if numpy.les
+0002de60: 7328 696e 6465 785f 2c20 2d69 6e74 286c  s(index_, -int(l
+0002de70: 656e 6774 6829 292e 616e 7928 293a 0a20  ength)).any():. 
+0002de80: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0002de90: 6169 7365 2049 6e64 6578 4572 726f 7228  aise IndexError(
+0002dea0: 2769 6e64 6963 6573 206f 7574 206f 6620  'indices out of 
+0002deb0: 626f 756e 6473 3a20 7b7d 203c 207b 7d27  bounds: {} < {}'
+0002dec0: 2e66 6f72 6d61 7428 696e 6465 785f 2c20  .format(index_, 
+0002ded0: 2d69 6e74 286c 656e 6774 6829 2929 0a20  -int(length))). 
+0002dee0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0002def0: 6e20 5f74 616b 6528 6172 672c 2063 6f6e  n _take(arg, con
+0002df00: 7374 616e 7428 696e 6465 785f 202b 2069  stant(index_ + i
+0002df10: 6e65 6720 2a20 696e 7428 6c65 6e67 7468  neg * int(length
+0002df20: 2929 2c20 6178 6973 290a 2020 2020 2020  )), axis).      
+0002df30: 2020 656c 6966 206e 756d 7079 2e67 7265    elif numpy.gre
+0002df40: 6174 6572 5f65 7175 616c 2869 6e64 6578  ater_equal(index
+0002df50: 5f2c 2069 6e74 286c 656e 6774 6829 292e  _, int(length)).
+0002df60: 616e 7928 293a 0a20 2020 2020 2020 2020  any():.         
+0002df70: 2020 2072 6169 7365 2049 6e64 6578 4572     raise IndexEr
+0002df80: 726f 7228 2769 6e64 6963 6573 206f 7574  ror('indices out
+0002df90: 206f 6620 626f 756e 6473 3a20 7b7d 203e   of bounds: {} >
+0002dfa0: 3d20 7b7d 272e 666f 726d 6174 2869 6e64  = {}'.format(ind
+0002dfb0: 6578 5f2c 2069 6e74 286c 656e 6774 6829  ex_, int(length)
+0002dfc0: 2929 0a20 2020 2020 2020 2065 6c69 6620  )).        elif 
+0002dfd0: 6e75 6d70 792e 6772 6561 7465 7228 6e75  numpy.greater(nu
+0002dfe0: 6d70 792e 6469 6666 2869 6e64 6578 5f29  mpy.diff(index_)
+0002dff0: 2c20 3029 2e61 6c6c 2829 3a0a 2020 2020  , 0).all():.    
+0002e000: 2020 2020 2020 2020 7265 7475 726e 206d          return m
+0002e010: 6173 6b28 6172 672c 206e 756d 6572 6963  ask(arg, numeric
+0002e020: 2e61 7362 6f6f 6c65 616e 2869 6e64 6578  .asboolean(index
+0002e030: 5f2c 2069 6e74 286c 656e 6774 6829 292c  _, int(length)),
+0002e040: 2061 7869 7329 0a20 2020 2072 6574 7572   axis).    retur
+0002e050: 6e20 5f74 616b 6528 6172 672c 2069 6e64  n _take(arg, ind
+0002e060: 6578 2c20 6178 6973 290a 0a0a 6465 6620  ex, axis)...def 
+0002e070: 5f74 616b 6528 6172 673a 2041 7272 6179  _take(arg: Array
+0002e080: 2c20 696e 6465 783a 2041 7272 6179 2c20  , index: Array, 
+0002e090: 6178 6973 3a20 696e 7429 3a0a 2020 2020  axis: int):.    
+0002e0a0: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+0002e0b0: 6528 6172 672c 2041 7272 6179 292c 2066  e(arg, Array), f
+0002e0c0: 2761 7267 3d7b 6172 6721 727d 270a 2020  'arg={arg!r}'.  
+0002e0d0: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+0002e0e0: 6e63 6528 696e 6465 782c 2041 7272 6179  nce(index, Array
+0002e0f0: 2920 616e 6420 696e 6465 782e 6474 7970  ) and index.dtyp
+0002e100: 6520 3d3d 2069 6e74 2c20 6627 696e 6465  e == int, f'inde
+0002e110: 783d 7b69 6e64 6578 2172 7d27 0a20 2020  x={index!r}'.   
+0002e120: 2061 7373 6572 7420 6973 696e 7374 616e   assert isinstan
+0002e130: 6365 2861 7869 732c 2069 6e74 292c 2066  ce(axis, int), f
+0002e140: 2761 7869 733d 7b61 7869 7321 727d 270a  'axis={axis!r}'.
+0002e150: 2020 2020 6178 6973 203d 206e 756d 6572      axis = numer
+0002e160: 6963 2e6e 6f72 6d64 696d 2861 7267 2e6e  ic.normdim(arg.n
+0002e170: 6469 6d2c 2061 7869 7329 0a20 2020 2072  dim, axis).    r
+0002e180: 6574 7572 6e20 5472 616e 7370 6f73 652e  eturn Transpose.
+0002e190: 6672 6f6d 5f65 6e64 2854 616b 6528 5472  from_end(Take(Tr
+0002e1a0: 616e 7370 6f73 652e 746f 5f65 6e64 2861  anspose.to_end(a
+0002e1b0: 7267 2c20 6178 6973 292c 2069 6e64 6578  rg, axis), index
+0002e1c0: 292c 202a 7261 6e67 6528 6178 6973 2c20  ), *range(axis, 
+0002e1d0: 6178 6973 2b69 6e64 6578 2e6e 6469 6d29  axis+index.ndim)
+0002e1e0: 290a 0a0a 6465 6620 5f69 6e66 6c61 7465  )...def _inflate
+0002e1f0: 2861 7267 3a20 4172 7261 792c 2064 6f66  (arg: Array, dof
+0002e200: 6d61 703a 2041 7272 6179 2c20 6c65 6e67  map: Array, leng
+0002e210: 7468 3a20 4172 7261 792c 2061 7869 733a  th: Array, axis:
+0002e220: 2069 6e74 293a 0a20 2020 2061 7373 6572   int):.    asser
+0002e230: 7420 6973 696e 7374 616e 6365 2861 7267  t isinstance(arg
+0002e240: 2c20 4172 7261 7929 2c20 6627 6172 673d  , Array), f'arg=
+0002e250: 7b61 7267 2172 7d27 0a20 2020 2061 7373  {arg!r}'.    ass
+0002e260: 6572 7420 6973 696e 7374 616e 6365 2864  ert isinstance(d
+0002e270: 6f66 6d61 702c 2041 7272 6179 2920 616e  ofmap, Array) an
+0002e280: 6420 646f 666d 6170 2e64 7479 7065 203d  d dofmap.dtype =
+0002e290: 3d20 696e 742c 2066 2764 6f66 6d61 703d  = int, f'dofmap=
+0002e2a0: 7b64 6f66 6d61 7021 727d 270a 2020 2020  {dofmap!r}'.    
+0002e2b0: 6173 7365 7274 205f 6973 696e 6465 7828  assert _isindex(
+0002e2c0: 6c65 6e67 7468 292c 2066 276c 656e 6774  length), f'lengt
+0002e2d0: 683d 7b6c 656e 6774 6821 727d 270a 2020  h={length!r}'.  
+0002e2e0: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+0002e2f0: 6e63 6528 6178 6973 2c20 696e 7429 2c20  nce(axis, int), 
+0002e300: 6627 6178 6973 3d7b 6178 6973 2172 7d27  f'axis={axis!r}'
+0002e310: 0a20 2020 2061 7869 7320 3d20 6e75 6d65  .    axis = nume
+0002e320: 7269 632e 6e6f 726d 6469 6d28 6172 672e  ric.normdim(arg.
+0002e330: 6e64 696d 2b31 2d64 6f66 6d61 702e 6e64  ndim+1-dofmap.nd
+0002e340: 696d 2c20 6178 6973 290a 2020 2020 6173  im, axis).    as
+0002e350: 7365 7274 2065 7175 616c 7368 6170 6528  sert equalshape(
+0002e360: 646f 666d 6170 2e73 6861 7065 2c20 6172  dofmap.shape, ar
+0002e370: 672e 7368 6170 655b 6178 6973 3a61 7869  g.shape[axis:axi
+0002e380: 732b 646f 666d 6170 2e6e 6469 6d5d 290a  s+dofmap.ndim]).
+0002e390: 2020 2020 7265 7475 726e 2054 7261 6e73      return Trans
+0002e3a0: 706f 7365 2e66 726f 6d5f 656e 6428 496e  pose.from_end(In
+0002e3b0: 666c 6174 6528 5472 616e 7370 6f73 652e  flate(Transpose.
+0002e3c0: 746f 5f65 6e64 2861 7267 2c20 2a72 616e  to_end(arg, *ran
+0002e3d0: 6765 2861 7869 732c 2061 7869 732b 646f  ge(axis, axis+do
+0002e3e0: 666d 6170 2e6e 6469 6d29 292c 2064 6f66  fmap.ndim)), dof
+0002e3f0: 6d61 702c 206c 656e 6774 6829 2c20 6178  map, length), ax
+0002e400: 6973 290a 0a0a 6465 6620 6d61 736b 2861  is)...def mask(a
+0002e410: 7267 2c20 6d61 736b 3a20 4172 7261 792c  rg, mask: Array,
+0002e420: 2061 7869 733a 2069 6e74 203d 2030 293a   axis: int = 0):
+0002e430: 0a20 2020 2061 7373 6572 7420 6973 696e  .    assert isin
+0002e440: 7374 616e 6365 2861 7267 2c20 4172 7261  stance(arg, Arra
+0002e450: 7929 2c20 6627 6172 673d 7b61 7267 2172  y), f'arg={arg!r
+0002e460: 7d27 0a20 2020 2061 7373 6572 7420 6973  }'.    assert is
+0002e470: 696e 7374 616e 6365 286d 6173 6b2c 206e  instance(mask, n
+0002e480: 756d 7079 2e6e 6461 7272 6179 2920 616e  umpy.ndarray) an
+0002e490: 6420 6d61 736b 2e64 7479 7065 203d 3d20  d mask.dtype == 
+0002e4a0: 626f 6f6c 2061 6e64 206d 6173 6b2e 6e64  bool and mask.nd
+0002e4b0: 696d 203d 3d20 3120 616e 6420 5f65 7175  im == 1 and _equ
+0002e4c0: 616c 735f 7363 616c 6172 5f63 6f6e 7374  als_scalar_const
+0002e4d0: 616e 7428 6172 672e 7368 6170 655b 6178  ant(arg.shape[ax
+0002e4e0: 6973 5d2c 206c 656e 286d 6173 6b29 292c  is], len(mask)),
+0002e4f0: 2066 276d 6173 6b3d 7b6d 6173 6b21 727d   f'mask={mask!r}
+0002e500: 270a 2020 2020 696e 6465 782c 203d 206d  '.    index, = m
+0002e510: 6173 6b2e 6e6f 6e7a 6572 6f28 290a 2020  ask.nonzero().  
+0002e520: 2020 7265 7475 726e 205f 7461 6b65 2861    return _take(a
+0002e530: 7267 2c20 636f 6e73 7461 6e74 2869 6e64  rg, constant(ind
+0002e540: 6578 292c 2061 7869 7329 0a0a 0a64 6566  ex), axis)...def
+0002e550: 2075 6e72 6176 656c 2866 756e 632c 2061   unravel(func, a
+0002e560: 7869 732c 2073 6861 7065 293a 0a20 2020  xis, shape):.   
+0002e570: 2066 756e 6320 3d20 6173 6172 7261 7928   func = asarray(
+0002e580: 6675 6e63 290a 2020 2020 6178 6973 203d  func).    axis =
+0002e590: 206e 756d 6572 6963 2e6e 6f72 6d64 696d   numeric.normdim
+0002e5a0: 2866 756e 632e 6e64 696d 2c20 6178 6973  (func.ndim, axis
+0002e5b0: 290a 2020 2020 6173 7365 7274 206c 656e  ).    assert len
+0002e5c0: 2873 6861 7065 2920 3d3d 2032 0a20 2020  (shape) == 2.   
+0002e5d0: 2072 6574 7572 6e20 5472 616e 7370 6f73   return Transpos
+0002e5e0: 652e 6672 6f6d 5f65 6e64 2855 6e72 6176  e.from_end(Unrav
+0002e5f0: 656c 2854 7261 6e73 706f 7365 2e74 6f5f  el(Transpose.to_
+0002e600: 656e 6428 6675 6e63 2c20 6178 6973 292c  end(func, axis),
+0002e610: 202a 7368 6170 6529 2c20 6178 6973 2c20   *shape), axis, 
+0002e620: 6178 6973 2b31 290a 0a0a 6465 6620 7261  axis+1)...def ra
+0002e630: 7665 6c28 6675 6e63 2c20 6178 6973 293a  vel(func, axis):
+0002e640: 0a20 2020 2066 756e 6320 3d20 6173 6172  .    func = asar
+0002e650: 7261 7928 6675 6e63 290a 2020 2020 6178  ray(func).    ax
+0002e660: 6973 203d 206e 756d 6572 6963 2e6e 6f72  is = numeric.nor
+0002e670: 6d64 696d 2866 756e 632e 6e64 696d 2d31  mdim(func.ndim-1
+0002e680: 2c20 6178 6973 290a 2020 2020 7265 7475  , axis).    retu
+0002e690: 726e 2054 7261 6e73 706f 7365 2e66 726f  rn Transpose.fro
+0002e6a0: 6d5f 656e 6428 5261 7665 6c28 5472 616e  m_end(Ravel(Tran
+0002e6b0: 7370 6f73 652e 746f 5f65 6e64 2866 756e  spose.to_end(fun
+0002e6c0: 632c 2061 7869 732c 2061 7869 732b 3129  c, axis, axis+1)
+0002e6d0: 292c 2061 7869 7329 0a0a 0a64 6566 205f  ), axis)...def _
+0002e6e0: 666c 6174 2866 756e 6329 3a0a 2020 2020  flat(func):.    
+0002e6f0: 6675 6e63 203d 2061 7361 7272 6179 2866  func = asarray(f
+0002e700: 756e 6329 0a20 2020 2069 6620 6675 6e63  unc).    if func
+0002e710: 2e6e 6469 6d20 3d3d 2030 3a0a 2020 2020  .ndim == 0:.    
+0002e720: 2020 2020 7265 7475 726e 2049 6e73 6572      return Inser
+0002e730: 7441 7869 7328 6675 6e63 2c20 636f 6e73  tAxis(func, cons
+0002e740: 7461 6e74 2831 2929 0a20 2020 2077 6869  tant(1)).    whi
+0002e750: 6c65 2066 756e 632e 6e64 696d 203e 2031  le func.ndim > 1
+0002e760: 3a0a 2020 2020 2020 2020 6675 6e63 203d  :.        func =
+0002e770: 2052 6176 656c 2866 756e 6329 0a20 2020   Ravel(func).   
+0002e780: 2072 6574 7572 6e20 6675 6e63 0a0a 0a64   return func...d
+0002e790: 6566 2070 7265 7065 6e64 6178 6573 2866  ef prependaxes(f
+0002e7a0: 756e 632c 2073 6861 7065 293a 0a20 2020  unc, shape):.   
+0002e7b0: 2027 5072 6570 656e 6420 6178 6573 2077   'Prepend axes w
+0002e7c0: 6974 6820 7370 6563 6966 6965 6420 6073  ith specified `s
+0002e7d0: 6861 7065 6020 746f 2060 6675 6e63 602e  hape` to `func`.
+0002e7e0: 270a 0a20 2020 2066 756e 6320 3d20 6173  '..    func = as
+0002e7f0: 6172 7261 7928 6675 6e63 290a 2020 2020  array(func).    
+0002e800: 666f 7220 692c 206e 2069 6e20 656e 756d  for i, n in enum
+0002e810: 6572 6174 6528 7368 6170 6529 3a0a 2020  erate(shape):.  
+0002e820: 2020 2020 2020 6675 6e63 203d 2069 6e73        func = ins
+0002e830: 6572 7461 7869 7328 6675 6e63 2c20 692c  ertaxis(func, i,
+0002e840: 206e 290a 2020 2020 7265 7475 726e 2066   n).    return f
+0002e850: 756e 630a 0a0a 6465 6620 6170 7065 6e64  unc...def append
+0002e860: 6178 6573 2866 756e 632c 2073 6861 7065  axes(func, shape
+0002e870: 293a 0a20 2020 2027 4170 7065 6e64 2061  ):.    'Append a
+0002e880: 7865 7320 7769 7468 2073 7065 6369 6669  xes with specifi
+0002e890: 6564 2060 7368 6170 6560 2074 6f20 6066  ed `shape` to `f
+0002e8a0: 756e 6360 2e27 0a0a 2020 2020 6675 6e63  unc`.'..    func
+0002e8b0: 203d 2061 7361 7272 6179 2866 756e 6329   = asarray(func)
+0002e8c0: 0a20 2020 2066 6f72 206e 2069 6e20 7368  .    for n in sh
+0002e8d0: 6170 653a 0a20 2020 2020 2020 2066 756e  ape:.        fun
+0002e8e0: 6320 3d20 496e 7365 7274 4178 6973 2866  c = InsertAxis(f
+0002e8f0: 756e 632c 206e 290a 2020 2020 7265 7475  unc, n).    retu
+0002e900: 726e 2066 756e 630a 0a0a 6465 6620 6c6f  rn func...def lo
+0002e910: 6f70 5f69 6e64 6578 286e 616d 652c 206c  op_index(name, l
+0002e920: 656e 6774 6829 3a0a 2020 2020 7265 7475  ength):.    retu
+0002e930: 726e 205f 4c6f 6f70 496e 6465 7828 6e61  rn _LoopIndex(na
+0002e940: 6d65 2c20 6173 6172 7261 7928 6c65 6e67  me, asarray(leng
+0002e950: 7468 2929 0a0a 0a64 6566 206c 6f6f 705f  th))...def loop_
+0002e960: 7375 6d28 6675 6e63 2c20 696e 6465 7829  sum(func, index)
+0002e970: 3a0a 2020 2020 6675 6e63 203d 2061 7361  :.    func = asa
+0002e980: 7272 6179 2866 756e 6329 0a20 2020 2069  rray(func).    i
+0002e990: 6620 6e6f 7420 6973 696e 7374 616e 6365  f not isinstance
+0002e9a0: 2869 6e64 6578 2c20 5f4c 6f6f 7049 6e64  (index, _LoopInd
+0002e9b0: 6578 293a 0a20 2020 2020 2020 2072 6169  ex):.        rai
+0002e9c0: 7365 2054 7970 6545 7272 6f72 2866 2765  se TypeError(f'e
+0002e9d0: 7870 6563 7465 6420 5f4c 6f6f 7049 6e64  xpected _LoopInd
+0002e9e0: 6578 2c20 676f 7420 7b69 6e64 6578 2172  ex, got {index!r
+0002e9f0: 7d27 290a 2020 2020 7265 7475 726e 204c  }').    return L
+0002ea00: 6f6f 7053 756d 2866 756e 632c 2066 756e  oopSum(func, fun
+0002ea10: 632e 7368 6170 652c 2069 6e64 6578 2e5f  c.shape, index._
+0002ea20: 6e61 6d65 2c20 696e 6465 782e 6c65 6e67  name, index.leng
+0002ea30: 7468 290a 0a0a 6465 6620 5f6c 6f6f 705f  th)...def _loop_
+0002ea40: 636f 6e63 6174 656e 6174 655f 6461 7461  concatenate_data
+0002ea50: 2866 756e 632c 2069 6e64 6578 293a 0a20  (func, index):. 
+0002ea60: 2020 2066 756e 6320 3d20 6173 6172 7261     func = asarra
+0002ea70: 7928 6675 6e63 290a 2020 2020 6966 206e  y(func).    if n
+0002ea80: 6f74 2069 7369 6e73 7461 6e63 6528 696e  ot isinstance(in
+0002ea90: 6465 782c 205f 4c6f 6f70 496e 6465 7829  dex, _LoopIndex)
+0002eaa0: 3a0a 2020 2020 2020 2020 7261 6973 6520  :.        raise 
+0002eab0: 5479 7065 4572 726f 7228 6627 6578 7065  TypeError(f'expe
+0002eac0: 6374 6564 205f 4c6f 6f70 496e 6465 782c  cted _LoopIndex,
+0002ead0: 2067 6f74 207b 696e 6465 7821 727d 2729   got {index!r}')
+0002eae0: 0a20 2020 2063 6875 6e6b 5f73 697a 6520  .    chunk_size 
+0002eaf0: 3d20 6675 6e63 2e73 6861 7065 5b2d 315d  = func.shape[-1]
+0002eb00: 0a20 2020 2069 6620 6368 756e 6b5f 7369  .    if chunk_si
+0002eb10: 7a65 2e69 7363 6f6e 7374 616e 743a 0a20  ze.isconstant:. 
+0002eb20: 2020 2020 2020 2063 6875 6e6b 5f73 697a         chunk_siz
+0002eb30: 6573 203d 2049 6e73 6572 7441 7869 7328  es = InsertAxis(
+0002eb40: 6368 756e 6b5f 7369 7a65 2c20 696e 6465  chunk_size, inde
+0002eb50: 782e 6c65 6e67 7468 290a 2020 2020 656c  x.length).    el
+0002eb60: 7365 3a0a 2020 2020 2020 2020 6368 756e  se:.        chun
+0002eb70: 6b5f 7369 7a65 7320 3d20 6c6f 6f70 5f63  k_sizes = loop_c
+0002eb80: 6f6e 6361 7465 6e61 7465 2849 6e73 6572  oncatenate(Inser
+0002eb90: 7441 7869 7328 6675 6e63 2e73 6861 7065  tAxis(func.shape
+0002eba0: 5b2d 315d 2c20 636f 6e73 7461 6e74 2831  [-1], constant(1
+0002ebb0: 2929 2c20 696e 6465 7829 0a20 2020 206f  )), index).    o
+0002ebc0: 6666 7365 7473 203d 205f 5369 7a65 7354  ffsets = _SizesT
+0002ebd0: 6f4f 6666 7365 7473 2863 6875 6e6b 5f73  oOffsets(chunk_s
+0002ebe0: 697a 6573 290a 2020 2020 7374 6172 7420  izes).    start 
+0002ebf0: 3d20 5461 6b65 286f 6666 7365 7473 2c20  = Take(offsets, 
+0002ec00: 696e 6465 7829 0a20 2020 2073 746f 7020  index).    stop 
+0002ec10: 3d20 5461 6b65 286f 6666 7365 7473 2c20  = Take(offsets, 
+0002ec20: 696e 6465 782b 3129 0a20 2020 2072 6574  index+1).    ret
+0002ec30: 7572 6e20 2866 756e 632c 2073 7461 7274  urn (func, start
+0002ec40: 2c20 7374 6f70 2c20 2a66 756e 632e 7368  , stop, *func.sh
+0002ec50: 6170 655b 3a2d 315d 2c20 5461 6b65 286f  ape[:-1], Take(o
+0002ec60: 6666 7365 7473 2c20 696e 6465 782e 6c65  ffsets, index.le
+0002ec70: 6e67 7468 2929 0a0a 0a64 6566 206c 6f6f  ngth))...def loo
+0002ec80: 705f 636f 6e63 6174 656e 6174 6528 6675  p_concatenate(fu
+0002ec90: 6e63 2c20 696e 6465 7829 3a0a 2020 2020  nc, index):.    
+0002eca0: 6675 6e63 6461 7461 203d 205f 6c6f 6f70  funcdata = _loop
+0002ecb0: 5f63 6f6e 6361 7465 6e61 7465 5f64 6174  _concatenate_dat
+0002ecc0: 6128 6675 6e63 2c20 696e 6465 7829 0a20  a(func, index). 
+0002ecd0: 2020 2072 6574 7572 6e20 4c6f 6f70 436f     return LoopCo
+0002ece0: 6e63 6174 656e 6174 6528 6675 6e63 6461  ncatenate(funcda
+0002ecf0: 7461 2c20 696e 6465 782e 5f6e 616d 652c  ta, index._name,
+0002ed00: 2069 6e64 6578 2e6c 656e 6774 6829 0a0a   index.length)..
+0002ed10: 0a64 6566 206c 6f6f 705f 636f 6e63 6174  .def loop_concat
+0002ed20: 656e 6174 655f 636f 6d62 696e 6564 2866  enate_combined(f
+0002ed30: 756e 6373 2c20 696e 6465 7829 3a0a 2020  uncs, index):.  
+0002ed40: 2020 756e 6971 7565 5f66 756e 6373 203d    unique_funcs =
+0002ed50: 205b 5d0a 2020 2020 756e 6971 7565 5f66   [].    unique_f
+0002ed60: 756e 6373 2e65 7874 656e 6428 6675 6e63  uncs.extend(func
+0002ed70: 2066 6f72 2066 756e 6320 696e 2066 756e   for func in fun
+0002ed80: 6373 2069 6620 6675 6e63 206e 6f74 2069  cs if func not i
+0002ed90: 6e20 756e 6971 7565 5f66 756e 6373 290a  n unique_funcs).
+0002eda0: 2020 2020 756e 6971 7565 5f66 756e 635f      unique_func_
+0002edb0: 6461 7461 203d 2074 7570 6c65 285f 6c6f  data = tuple(_lo
+0002edc0: 6f70 5f63 6f6e 6361 7465 6e61 7465 5f64  op_concatenate_d
+0002edd0: 6174 6128 6675 6e63 2c20 696e 6465 7829  ata(func, index)
+0002ede0: 2066 6f72 2066 756e 6320 696e 2075 6e69   for func in uni
+0002edf0: 7175 655f 6675 6e63 7329 0a20 2020 206c  que_funcs).    l
+0002ee00: 6f6f 7020 3d20 4c6f 6f70 436f 6e63 6174  oop = LoopConcat
+0002ee10: 656e 6174 6543 6f6d 6269 6e65 6428 756e  enateCombined(un
+0002ee20: 6971 7565 5f66 756e 635f 6461 7461 2c20  ique_func_data, 
+0002ee30: 696e 6465 782e 5f6e 616d 652c 2069 6e64  index._name, ind
+0002ee40: 6578 2e6c 656e 6774 6829 0a20 2020 2072  ex.length).    r
+0002ee50: 6574 7572 6e20 7475 706c 6528 4172 7261  eturn tuple(Arra
+0002ee60: 7946 726f 6d54 7570 6c65 286c 6f6f 702c  yFromTuple(loop,
+0002ee70: 2075 6e69 7175 655f 6675 6e63 732e 696e   unique_funcs.in
+0002ee80: 6465 7828 6675 6e63 292c 2074 7570 6c65  dex(func), tuple
+0002ee90: 2873 6861 7065 292c 2066 756e 632e 6474  (shape), func.dt
+0002eea0: 7970 6529 2066 6f72 2066 756e 632c 2073  ype) for func, s
+0002eeb0: 7461 7274 2c20 7374 6f70 2c20 2a73 6861  tart, stop, *sha
+0002eec0: 7065 2069 6e20 756e 6971 7565 5f66 756e  pe in unique_fun
+0002eed0: 635f 6461 7461 290a 0a0a 4072 6570 6c61  c_data)...@repla
+0002eee0: 6365 0a64 6566 2072 6570 6c61 6365 5f61  ce.def replace_a
+0002eef0: 7267 756d 656e 7473 2876 616c 7565 2c20  rguments(value, 
+0002ef00: 6172 6775 6d65 6e74 7329 3a0a 2020 2020  arguments):.    
+0002ef10: 2727 2752 6570 6c61 6365 203a 636c 6173  '''Replace :clas
+0002ef20: 733a 6041 7267 756d 656e 7460 206f 626a  s:`Argument` obj
+0002ef30: 6563 7473 2069 6e20 6060 7661 6c75 6560  ects in ``value`
+0002ef40: 602e 0a0a 2020 2020 5265 706c 6163 6520  `...    Replace 
+0002ef50: 3a63 6c61 7373 3a60 4172 6775 6d65 6e74  :class:`Argument
+0002ef60: 6020 6f62 6a65 6374 7320 696e 2060 6076  ` objects in ``v
+0002ef70: 616c 7565 6060 2061 6363 6f72 6469 6e67  alue`` according
+0002ef80: 2074 6f20 7468 6520 6060 6172 6775 6d65   to the ``argume
+0002ef90: 6e74 7360 600a 2020 2020 6d61 702c 2074  nts``.    map, t
+0002efa0: 616b 696e 6720 696e 746f 2061 6363 6f75  aking into accou
+0002efb0: 6e74 2064 6572 6976 6174 6976 6573 2074  nt derivatives t
+0002efc0: 6f20 7468 6520 6c6f 6361 6c20 636f 6f72  o the local coor
+0002efd0: 6469 6e61 7465 732e 0a0a 2020 2020 4172  dinates...    Ar
+0002efe0: 6773 0a20 2020 202d 2d2d 2d0a 2020 2020  gs.    ----.    
+0002eff0: 7661 6c75 6520 3a20 3a63 6c61 7373 3a60  value : :class:`
+0002f000: 4172 7261 7960 0a20 2020 2020 2020 2041  Array`.        A
+0002f010: 7272 6179 2074 6f20 6265 2065 6469 7465  rray to be edite
+0002f020: 642e 0a20 2020 2061 7267 756d 656e 7473  d..    arguments
+0002f030: 203a 203a 636c 6173 733a 6063 6f6c 6c65   : :class:`colle
+0002f040: 6374 696f 6e73 2e61 6263 2e4d 6170 7069  ctions.abc.Mappi
+0002f050: 6e67 6020 7769 7468 203a 636c 6173 733a  ng` with :class:
+0002f060: 6041 7272 6179 605c 5c73 2061 7320 7661  `Array`\\s as va
+0002f070: 6c75 6573 0a20 2020 2020 2020 203a 636c  lues.        :cl
+0002f080: 6173 733a 6041 7267 756d 656e 7460 5c5c  ass:`Argument`\\
+0002f090: 7320 7265 706c 6163 656d 656e 7473 2e20  s replacements. 
+0002f0a0: 2054 6865 206b 6579 2063 6f72 7265 7370   The key corresp
+0002f0b0: 6f6e 6420 746f 2074 6865 2060 606e 616d  ond to the ``nam
+0002f0c0: 6560 600a 2020 2020 2020 2020 7061 7373  e``.        pass
+0002f0d0: 6564 2074 6f20 616e 203a 636c 6173 733a  ed to an :class:
+0002f0e0: 6041 7267 756d 656e 7460 2061 6e64 2074  `Argument` and t
+0002f0f0: 6865 2076 616c 7565 2069 7320 7468 6520  he value is the 
+0002f100: 7265 706c 6163 656d 656e 742e 0a0a 2020  replacement...  
+0002f110: 2020 5265 7475 726e 730a 2020 2020 2d2d    Returns.    --
+0002f120: 2d2d 2d2d 2d0a 2020 2020 3a63 6c61 7373  -----.    :class
+0002f130: 3a60 4172 7261 7960 0a20 2020 2020 2020  :`Array`.       
+0002f140: 2054 6865 2065 6469 7465 6420 6060 7661   The edited ``va
+0002f150: 6c75 6560 602e 0a20 2020 2027 2727 0a20  lue``..    '''. 
+0002f160: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+0002f170: 2876 616c 7565 2c20 4172 6775 6d65 6e74  (value, Argument
+0002f180: 2920 616e 6420 7661 6c75 652e 5f6e 616d  ) and value._nam
+0002f190: 6520 696e 2061 7267 756d 656e 7473 3a0a  e in arguments:.
+0002f1a0: 2020 2020 2020 2020 7620 3d20 6173 6172          v = asar
+0002f1b0: 7261 7928 6172 6775 6d65 6e74 735b 7661  ray(arguments[va
+0002f1c0: 6c75 652e 5f6e 616d 655d 290a 2020 2020  lue._name]).    
+0002f1d0: 2020 2020 6173 7365 7274 2065 7175 616c      assert equal
+0002f1e0: 7368 6170 6528 7661 6c75 652e 7368 6170  shape(value.shap
+0002f1f0: 652c 2076 2e73 6861 7065 292c 2028 7661  e, v.shape), (va
+0002f200: 6c75 652e 7368 6170 652c 2076 2e73 6861  lue.shape, v.sha
+0002f210: 7065 290a 2020 2020 2020 2020 6173 7365  pe).        asse
+0002f220: 7274 2076 616c 7565 2e64 7479 7065 203d  rt value.dtype =
+0002f230: 3d20 762e 6474 7970 652c 2028 7661 6c75  = v.dtype, (valu
+0002f240: 652e 6474 7970 652c 2076 2e64 7479 7065  e.dtype, v.dtype
+0002f250: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0002f260: 2076 0a0a 0a64 6566 2065 696e 7375 6d28   v...def einsum(
+0002f270: 666d 742c 202a 6172 6773 2c20 2a2a 6469  fmt, *args, **di
+0002f280: 6d73 293a 0a20 2020 2027 2727 4d75 6c74  ms):.    '''Mult
+0002f290: 6970 6c79 2061 6e64 2f6f 7220 636f 6e74  iply and/or cont
+0002f2a0: 7261 6374 2061 7272 6179 7320 7669 6120  ract arrays via 
+0002f2b0: 666f 726d 6174 2073 7472 696e 672e 0a0a  format string...
+0002f2c0: 2020 2020 5468 6520 666f 726d 6174 2073      The format s
+0002f2d0: 7472 696e 6720 636f 6e73 6973 7473 206f  tring consists o
+0002f2e0: 6620 6120 636f 6d6d 6120 7365 7061 7261  f a comma separa
+0002f2f0: 7465 6420 6c69 7374 206f 6620 6178 6973  ted list of axis
+0002f300: 206c 6162 656c 732c 2066 6f6c 6c6f 7765   labels, followe
+0002f310: 640a 2020 2020 6279 2060 602d 3e60 6020  d.    by ``->`` 
+0002f320: 616e 6420 7468 6520 6178 6973 206c 6162  and the axis lab
+0002f330: 656c 7320 6f66 2074 6865 2072 6574 7572  els of the retur
+0002f340: 6e20 7661 6c75 652e 2046 6f72 2065 7861  n value. For exa
+0002f350: 6d70 6c65 2c20 7468 6520 666f 6c6c 6f77  mple, the follow
+0002f360: 696e 670a 2020 2020 7377 6170 7320 7468  ing.    swaps th
+0002f370: 6520 6178 6573 206f 6620 6120 6d61 7472  e axes of a matr
+0002f380: 6978 3a0a 0a20 2020 203e 3e3e 2061 3435  ix:..    >>> a45
+0002f390: 203d 206f 6e65 7328 7475 706c 6528 6d61   = ones(tuple(ma
+0002f3a0: 7028 636f 6e73 7461 6e74 2c20 5b34 2c35  p(constant, [4,5
+0002f3b0: 5d29 2929 2023 2034 7835 206d 6174 7269  ]))) # 4x5 matri
+0002f3c0: 780a 2020 2020 3e3e 3e20 6569 6e73 756d  x.    >>> einsum
+0002f3d0: 2827 696a 2d3e 6a69 272c 2061 3435 290a  ('ij->ji', a45).
+0002f3e0: 2020 2020 6e75 7469 6c73 2e65 7661 6c75      nutils.evalu
+0002f3f0: 6162 6c65 2e54 7261 6e73 706f 7365 3c66  able.Transpose<f
+0002f400: 3a28 3529 2c28 3429 3e0a 0a20 2020 2041  :(5),(4)>..    A
+0002f410: 7869 7320 6c61 6265 6c73 2074 6861 7420  xis labels that 
+0002f420: 646f 206e 6f74 206f 6363 7572 2069 6e20  do not occur in 
+0002f430: 7468 6520 7265 7475 726e 2076 616c 7565  the return value
+0002f440: 2061 7265 2073 756d 6d65 642e 2046 6f72   are summed. For
+0002f450: 2065 7861 6d70 6c65 2c0a 2020 2020 7468   example,.    th
+0002f460: 6520 666f 6c6c 6f77 696e 6720 7065 7266  e following perf
+0002f470: 6f72 6d73 2061 206d 6174 7269 782d 7665  orms a matrix-ve
+0002f480: 6374 6f72 2070 726f 6475 6374 3a0a 0a20  ctor product:.. 
+0002f490: 2020 203e 3e3e 2061 3520 3d20 6f6e 6573     >>> a5 = ones
+0002f4a0: 2874 7570 6c65 286d 6170 2863 6f6e 7374  (tuple(map(const
+0002f4b0: 616e 742c 205b 355d 2929 2920 2320 7665  ant, [5]))) # ve
+0002f4c0: 6374 6f72 2077 6974 6820 6c65 6e67 7468  ctor with length
+0002f4d0: 2035 0a20 2020 203e 3e3e 2065 696e 7375   5.    >>> einsu
+0002f4e0: 6d28 2769 6a2c 6a2d 3e69 272c 2061 3435  m('ij,j->i', a45
+0002f4f0: 2c20 6135 290a 2020 2020 6e75 7469 6c73  , a5).    nutils
+0002f500: 2e65 7661 6c75 6162 6c65 2e53 756d 3c66  .evaluable.Sum<f
+0002f510: 3a34 3e0a 0a20 2020 2054 6865 2066 6f6c  :4>..    The fol
+0002f520: 6c6f 7769 6e67 2063 6f6e 7472 6163 7473  lowing contracts
+0002f530: 2061 2074 6869 7264 206f 7264 6572 2074   a third order t
+0002f540: 656e 736f 722c 2061 206d 6174 7269 782c  ensor, a matrix,
+0002f550: 2061 6e64 2061 2076 6563 746f 722c 2061   and a vector, a
+0002f560: 6e64 0a20 2020 2074 7261 6e73 706f 7365  nd.    transpose
+0002f570: 7320 7468 6520 7265 7375 6c74 3a0a 0a20  s the result:.. 
+0002f580: 2020 203e 3e3e 2061 3233 3420 3d20 6f6e     >>> a234 = on
+0002f590: 6573 2874 7570 6c65 286d 6170 2863 6f6e  es(tuple(map(con
+0002f5a0: 7374 616e 742c 205b 322c 332c 345d 2929  stant, [2,3,4]))
+0002f5b0: 2920 2320 3278 3378 3420 7465 6e73 6f72  ) # 2x3x4 tensor
+0002f5c0: 0a20 2020 203e 3e3e 2065 696e 7375 6d28  .    >>> einsum(
+0002f5d0: 2769 6a6b 2c6b 6c2c 6c2d 3e6a 6927 2c20  'ijk,kl,l->ji', 
+0002f5e0: 6132 3334 2c20 6134 352c 2061 3529 0a20  a234, a45, a5). 
+0002f5f0: 2020 206e 7574 696c 732e 6576 616c 7561     nutils.evalua
+0002f600: 626c 652e 5375 6d3c 663a 332c 323e 0a0a  ble.Sum<f:3,2>..
+0002f610: 2020 2020 496e 2063 6173 6520 7468 6520      In case the 
+0002f620: 6469 6d65 6e73 696f 6e20 6f66 2074 6865  dimension of the
+0002f630: 2069 6e70 7574 2061 6e64 206f 7574 7075   input and outpu
+0002f640: 7420 6172 7261 7973 206d 6179 2076 6172  t arrays may var
+0002f650: 792c 2061 2076 6172 6961 626c 650a 2020  y, a variable.  
+0002f660: 2020 6c65 6e67 7468 2061 7865 7320 6772    length axes gr
+0002f670: 6f75 7020 6361 6e20 6265 2064 656e 6f74  oup can be denot
+0002f680: 6564 2062 7920 6120 6361 7069 7461 6c2e  ed by a capital.
+0002f690: 2049 7473 206c 656e 6774 6820 6973 2061   Its length is a
+0002f6a0: 7574 6f6d 6174 6963 616c 6c79 0a20 2020  utomatically.   
+0002f6b0: 2065 7374 6162 6c69 7368 6564 2062 6173   established bas
+0002f6c0: 6564 206f 6e20 7468 6520 6469 6d65 6e73  ed on the dimens
+0002f6d0: 696f 6e20 6f66 2074 6865 2069 6e70 7574  ion of the input
+0002f6e0: 2061 7272 6179 732e 2054 6865 2066 6f6c   arrays. The fol
+0002f6f0: 6c6f 7769 6e67 2065 7861 6d70 6c65 0a20  lowing example. 
+0002f700: 2020 2070 6572 666f 726d 7320 6120 7465     performs a te
+0002f710: 6e73 6f72 2070 726f 6475 6374 206f 6620  nsor product of 
+0002f720: 616e 2061 7272 6179 2061 6e64 2061 2076  an array and a v
+0002f730: 6563 746f 723a 0a0a 2020 2020 3e3e 3e20  ector:..    >>> 
+0002f740: 6569 6e73 756d 2827 412c 692d 3e41 6927  einsum('A,i->Ai'
+0002f750: 2c20 6132 3334 2c20 6135 290a 2020 2020  , a234, a5).    
+0002f760: 6e75 7469 6c73 2e65 7661 6c75 6162 6c65  nutils.evaluable
+0002f770: 2e4d 756c 7469 706c 793c 663a 322c 332c  .Multiply<f:2,3,
+0002f780: 342c 353e 0a0a 2020 2020 5468 6520 666f  4,5>..    The fo
+0002f790: 726d 6174 2073 7472 696e 6720 6d61 7920  rmat string may 
+0002f7a0: 636f 6e74 6169 6e20 6d75 6c74 6970 6c65  contain multiple
+0002f7b0: 2076 6172 6961 626c 6520 6c65 6e67 7468   variable length
+0002f7c0: 2061 7865 7320 6772 6f75 7073 2c20 6275   axes groups, bu
+0002f7d0: 7420 7468 6569 720a 2020 2020 6c65 6e67  t their.    leng
+0002f7e0: 7468 7320 6d75 7374 2062 6520 7265 736f  ths must be reso
+0002f7f0: 6c76 6162 6c65 2066 726f 6d20 6c65 6674  lvable from left
+0002f800: 2074 6f20 7269 6768 742e 2049 6e20 6361   to right. In ca
+0002f810: 7365 2074 6869 7320 6973 206e 6f74 2070  se this is not p
+0002f820: 6f73 7369 626c 652c 0a20 2020 206c 656e  ossible,.    len
+0002f830: 6774 6873 206d 6179 2062 6520 7370 6563  gths may be spec
+0002f840: 6966 6965 6420 6173 206b 6579 776f 7264  ified as keyword
+0002f850: 2061 7267 756d 656e 7473 2e0a 0a20 2020   arguments...   
+0002f860: 203e 3e3e 2065 696e 7375 6d28 2741 6a42   >>> einsum('AjB
+0002f870: 2c69 2d3e 4169 6a42 272c 2061 3233 342c  ,i->AijB', a234,
+0002f880: 2061 352c 2042 3d31 290a 2020 2020 6e75   a5, B=1).    nu
+0002f890: 7469 6c73 2e65 7661 6c75 6162 6c65 2e4d  tils.evaluable.M
+0002f8a0: 756c 7469 706c 793c 663a 322c 352c 332c  ultiply<f:2,5,3,
+0002f8b0: 343e 0a20 2020 2027 2727 0a0a 2020 2020  4>.    '''..    
+0002f8c0: 6966 206e 6f74 2061 6c6c 2869 7369 6e73  if not all(isins
+0002f8d0: 7461 6e63 6528 6172 672c 2041 7272 6179  tance(arg, Array
+0002f8e0: 2920 666f 7220 6172 6720 696e 2061 7267  ) for arg in arg
+0002f8f0: 7329 3a0a 2020 2020 2020 2020 7261 6973  s):.        rais
+0002f900: 6520 5661 6c75 6545 7272 6f72 2827 6172  e ValueError('ar
+0002f910: 6775 6d65 6e74 7320 6d75 7374 2062 6520  guments must be 
+0002f920: 4172 7261 7920 7661 6c75 6564 2729 0a0a  Array valued')..
+0002f930: 2020 2020 7369 6e2c 2073 6f75 7420 3d20      sin, sout = 
+0002f940: 666d 742e 7370 6c69 7428 272d 3e27 290a  fmt.split('->').
+0002f950: 2020 2020 7369 6e20 3d20 7369 6e2e 7370      sin = sin.sp
+0002f960: 6c69 7428 272c 2729 0a0a 2020 2020 6966  lit(',')..    if
+0002f970: 206c 656e 2873 696e 2920 213d 206c 656e   len(sin) != len
+0002f980: 2861 7267 7329 3a0a 2020 2020 2020 2020  (args):.        
+0002f990: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+0002f9a0: 2827 6e75 6d62 6572 206f 6620 6172 6775  ('number of argu
+0002f9b0: 6d65 6e74 7320 646f 6573 206e 6f74 206d  ments does not m
+0002f9c0: 6174 6368 2066 6f72 6d61 7420 7374 7269  atch format stri
+0002f9d0: 6e67 2729 0a0a 2020 2020 6966 2061 6e79  ng')..    if any
+0002f9e0: 286c 656e 2873 2920 213d 206c 656e 2873  (len(s) != len(s
+0002f9f0: 6574 2873 2929 2066 6f72 2073 2069 6e20  et(s)) for s in 
+0002fa00: 282a 7369 6e2c 2073 6f75 7429 293a 0a20  (*sin, sout)):. 
+0002fa10: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+0002fa20: 7565 4572 726f 7228 2769 6e74 6572 6e61  ueError('interna
+0002fa30: 6c20 7265 7065 7469 7469 6f6e 7320 6172  l repetitions ar
+0002fa40: 6520 6e6f 7420 7375 7070 6f72 7465 6427  e not supported'
+0002fa50: 290a 0a20 2020 2069 6620 616e 7928 6e20  )..    if any(n 
+0002fa60: 3c20 3020 666f 7220 6e20 696e 2064 696d  < 0 for n in dim
+0002fa70: 732e 7661 6c75 6573 2829 293a 0a20 2020  s.values()):.   
+0002fa80: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+0002fa90: 4572 726f 7228 2761 7869 7320 6772 6f75  Error('axis grou
+0002faa0: 7020 6469 6d65 6e73 696f 6e73 2063 616e  p dimensions can
+0002fab0: 6e6f 7420 6265 206e 6567 6174 6976 6527  not be negative'
+0002fac0: 290a 0a20 2020 2066 6f72 2063 2069 6e20  )..    for c in 
+0002fad0: 2761 6263 6465 6667 6869 6a6b 6c6d 6e6f  'abcdefghijklmno
+0002fae0: 7071 7273 7475 7677 7879 7a27 3a0a 2020  pqrstuvwxyz':.  
+0002faf0: 2020 2020 2020 6469 6d73 2e73 6574 6465        dims.setde
+0002fb00: 6661 756c 7428 632c 2031 2920 2023 206c  fault(c, 1)  # l
+0002fb10: 6f77 6572 6361 7365 2063 6861 7261 6374  owercase charact
+0002fb20: 6572 7320 6465 6661 756c 7420 746f 2073  ers default to s
+0002fb30: 696e 676c 6520 6469 6d65 6e73 696f 6e0a  ingle dimension.
+0002fb40: 0a20 2020 2066 6f72 2073 2c20 6172 6720  .    for s, arg 
+0002fb50: 696e 207a 6970 2873 696e 2c20 6172 6773  in zip(sin, args
+0002fb60: 293a 0a20 2020 2020 2020 206d 6973 7369  ):.        missi
+0002fb70: 6e67 5f64 696d 7320 3d20 6172 672e 6e64  ng_dims = arg.nd
+0002fb80: 696d 202d 2062 7569 6c74 696e 732e 7375  im - builtins.su
+0002fb90: 6d28 6469 6d73 2e67 6574 2863 2c20 3029  m(dims.get(c, 0)
+0002fba0: 2066 6f72 2063 2069 6e20 7329 0a20 2020   for c in s).   
+0002fbb0: 2020 2020 2075 6e6b 6e6f 776e 5f61 7865       unknown_axe
+0002fbc0: 7320 3d20 5b63 2066 6f72 2063 2069 6e20  s = [c for c in 
+0002fbd0: 7320 6966 2063 206e 6f74 2069 6e20 6469  s if c not in di
+0002fbe0: 6d73 5d0a 2020 2020 2020 2020 6966 206c  ms].        if l
+0002fbf0: 656e 2875 6e6b 6e6f 776e 5f61 7865 7329  en(unknown_axes)
+0002fc00: 203d 3d20 3120 616e 6420 6d69 7373 696e   == 1 and missin
+0002fc10: 675f 6469 6d73 203e 3d20 303a 0a20 2020  g_dims >= 0:.   
+0002fc20: 2020 2020 2020 2020 2064 696d 735b 756e           dims[un
+0002fc30: 6b6e 6f77 6e5f 6178 6573 5b30 5d5d 203d  known_axes[0]] =
+0002fc40: 206d 6973 7369 6e67 5f64 696d 730a 2020   missing_dims.  
+0002fc50: 2020 2020 2020 656c 6966 206c 656e 2875        elif len(u
+0002fc60: 6e6b 6e6f 776e 5f61 7865 7329 203e 2031  nknown_axes) > 1
+0002fc70: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+0002fc80: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
+0002fc90: 6361 6e6e 6f74 2065 7374 6162 6c69 7368  cannot establish
+0002fca0: 206c 656e 6774 6820 6f66 2076 6172 6961   length of varia
+0002fcb0: 626c 6520 6772 6f75 7073 207b 7d27 2e66  ble groups {}'.f
+0002fcc0: 6f72 6d61 7428 272c 2027 2e6a 6f69 6e28  ormat(', '.join(
+0002fcd0: 756e 6b6e 6f77 6e5f 6178 6573 2929 290a  unknown_axes))).
+0002fce0: 2020 2020 2020 2020 656c 6966 206d 6973          elif mis
+0002fcf0: 7369 6e67 5f64 696d 733a 0a20 2020 2020  sing_dims:.     
+0002fd00: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+0002fd10: 7565 4572 726f 7228 2761 7267 756d 656e  ueError('argumen
+0002fd20: 7420 6469 6d65 6e73 696f 6e73 2061 7265  t dimensions are
+0002fd30: 2069 6e63 6f6e 7369 7374 656e 7420 7769   inconsistent wi
+0002fd40: 7468 2066 6f72 6d61 7420 7374 7269 6e67  th format string
+0002fd50: 2729 0a0a 2020 2020 2320 6578 7061 6e64  ')..    # expand
+0002fd60: 2063 6861 7261 6374 6572 7320 746f 206d   characters to m
+0002fd70: 6174 6368 2061 7267 756d 656e 7420 6469  atch argument di
+0002fd80: 6d65 6e73 696f 6e0a 2020 2020 2a73 696e  mension.    *sin
+0002fd90: 2c20 736f 7574 203d 205b 5b28 632c 2064  , sout = [[(c, d
+0002fda0: 2920 666f 7220 6320 696e 2073 2066 6f72  ) for c in s for
+0002fdb0: 2064 2069 6e20 7261 6e67 6528 6469 6d73   d in range(dims
+0002fdc0: 5b63 5d29 5d20 666f 7220 7320 696e 2028  [c])] for s in (
+0002fdd0: 2a73 696e 2c20 736f 7574 295d 0a20 2020  *sin, sout)].   
+0002fde0: 2073 616c 6c20 3d20 736f 7574 202b 2073   sall = sout + s
+0002fdf0: 6f72 7465 6428 7b63 2066 6f72 2073 2069  orted({c for s i
+0002fe00: 6e20 7369 6e20 666f 7220 6320 696e 2073  n sin for c in s
+0002fe10: 2069 6620 6320 6e6f 7420 696e 2073 6f75   if c not in sou
+0002fe20: 747d 290a 0a20 2020 2073 6861 7065 7320  t})..    shapes 
+0002fe30: 3d20 7b7d 0a20 2020 2066 6f72 2073 2c20  = {}.    for s, 
+0002fe40: 6172 6720 696e 207a 6970 2873 696e 2c20  arg in zip(sin, 
+0002fe50: 6172 6773 293a 0a20 2020 2020 2020 2061  args):.        a
+0002fe60: 7373 6572 7420 6c65 6e28 7329 203d 3d20  ssert len(s) == 
+0002fe70: 6172 672e 6e64 696d 0a20 2020 2020 2020  arg.ndim.       
+0002fe80: 2066 6f72 2063 2c20 7368 2069 6e20 7a69   for c, sh in zi
+0002fe90: 7028 732c 2061 7267 2e73 6861 7065 293a  p(s, arg.shape):
+0002fea0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0002feb0: 6e6f 7420 5f65 7175 616c 735f 7369 6d70  not _equals_simp
+0002fec0: 6c69 6669 6564 2873 6861 7065 732e 7365  lified(shapes.se
+0002fed0: 7464 6566 6175 6c74 2863 2c20 7368 292c  tdefault(c, sh),
+0002fee0: 2073 6829 3a0a 2020 2020 2020 2020 2020   sh):.          
+0002fef0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+0002ff00: 6545 7272 6f72 2827 7368 6170 6573 2064  eError('shapes d
+0002ff10: 6f20 6e6f 7420 6d61 7463 6820 666f 7220  o not match for 
+0002ff20: 6178 6973 207b 305b 305d 7d7b 305b 315d  axis {0[0]}{0[1]
+0002ff30: 7d27 2e66 6f72 6d61 7428 6329 290a 0a20  }'.format(c)).. 
+0002ff40: 2020 2072 6574 203d 204e 6f6e 650a 2020     ret = None.  
+0002ff50: 2020 666f 7220 732c 2061 7267 2069 6e20    for s, arg in 
+0002ff60: 7a69 7028 7369 6e2c 2061 7267 7329 3a0a  zip(sin, args):.
+0002ff70: 2020 2020 2020 2020 696e 6465 7820 3d20          index = 
+0002ff80: 7b63 3a20 6920 666f 7220 692c 2063 2069  {c: i for i, c i
+0002ff90: 6e20 656e 756d 6572 6174 6528 7329 7d0a  n enumerate(s)}.
+0002ffa0: 2020 2020 2020 2020 666f 7220 6320 696e          for c in
+0002ffb0: 2073 616c 6c3a 0a20 2020 2020 2020 2020   sall:.         
+0002ffc0: 2020 2069 6620 6320 6e6f 7420 696e 2069     if c not in i
+0002ffd0: 6e64 6578 3a0a 2020 2020 2020 2020 2020  ndex:.          
+0002ffe0: 2020 2020 2020 696e 6465 785b 635d 203d        index[c] =
+0002fff0: 2061 7267 2e6e 6469 6d0a 2020 2020 2020   arg.ndim.      
+00030000: 2020 2020 2020 2020 2020 6172 6720 3d20            arg = 
+00030010: 496e 7365 7274 4178 6973 2861 7267 2c20  InsertAxis(arg, 
+00030020: 7368 6170 6573 5b63 5d29 0a20 2020 2020  shapes[c]).     
+00030030: 2020 2076 203d 2054 7261 6e73 706f 7365     v = Transpose
+00030040: 2861 7267 2c20 7475 706c 6528 696e 6465  (arg, tuple(inde
+00030050: 785b 635d 2066 6f72 2063 2069 6e20 7361  x[c] for c in sa
+00030060: 6c6c 2929 0a20 2020 2020 2020 2072 6574  ll)).        ret
+00030070: 203d 2076 2069 6620 7265 7420 6973 204e   = v if ret is N
+00030080: 6f6e 6520 656c 7365 2072 6574 202a 2076  one else ret * v
+00030090: 0a20 2020 2066 6f72 2069 2069 6e20 7261  .    for i in ra
+000300a0: 6e67 6528 6c65 6e28 736f 7574 292c 206c  nge(len(sout), l
+000300b0: 656e 2873 616c 6c29 293a 0a20 2020 2020  en(sall)):.     
+000300c0: 2020 2072 6574 203d 2053 756d 2872 6574     ret = Sum(ret
+000300d0: 290a 2020 2020 7265 7475 726e 2072 6574  ).    return ret
+000300e0: 0a0a 0a40 7574 696c 2e73 696e 676c 655f  ...@util.single_
+000300f0: 6f72 5f6d 756c 7469 706c 650a 6465 6620  or_multiple.def 
+00030100: 6576 616c 5f73 7061 7273 6528 6675 6e63  eval_sparse(func
+00030110: 733a 2041 7345 7661 6c75 6162 6c65 4172  s: AsEvaluableAr
+00030120: 7261 792c 202a 2a61 7267 756d 656e 7473  ray, **arguments
+00030130: 3a20 7479 7069 6e67 2e4d 6170 7069 6e67  : typing.Mapping
+00030140: 5b73 7472 2c20 6e75 6d70 792e 6e64 6172  [str, numpy.ndar
+00030150: 7261 795d 2920 2d3e 2074 7970 696e 672e  ray]) -> typing.
+00030160: 5475 706c 655b 6e75 6d70 792e 6e64 6172  Tuple[numpy.ndar
+00030170: 7261 792c 202e 2e2e 5d3a 0a20 2020 2027  ray, ...]:.    '
+00030180: 2727 4576 616c 7561 7465 206f 6e65 206f  ''Evaluate one o
+00030190: 7220 7365 7665 7261 6c20 4172 7261 7920  r several Array 
+000301a0: 6f62 6a65 6374 7320 6173 2073 7061 7273  objects as spars
+000301b0: 6520 6461 7461 2e0a 0a20 2020 2041 7267  e data...    Arg
+000301c0: 730a 2020 2020 2d2d 2d2d 0a20 2020 2066  s.    ----.    f
+000301d0: 756e 6373 203a 203a 636c 6173 733a 6074  uncs : :class:`t
+000301e0: 7570 6c65 6020 6f66 2041 7272 6179 206f  uple` of Array o
+000301f0: 626a 6563 7473 0a20 2020 2020 2020 2041  bjects.        A
+00030200: 7272 6179 7320 746f 2062 6520 6576 616c  rrays to be eval
+00030210: 7561 7465 642e 0a20 2020 2061 7267 756d  uated..    argum
+00030220: 656e 7473 203a 203a 636c 6173 733a 6064  ents : :class:`d
+00030230: 6963 7460 2028 6465 6661 756c 743a 204e  ict` (default: N
+00030240: 6f6e 6529 0a20 2020 2020 2020 204f 7074  one).        Opt
+00030250: 696f 6e61 6c20 6172 6775 6d65 6e74 7320  ional arguments 
+00030260: 666f 7220 6675 6e63 7469 6f6e 2065 7661  for function eva
+00030270: 6c75 6174 696f 6e2e 0a0a 2020 2020 5265  luation...    Re
+00030280: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
+00030290: 2d0a 2020 2020 7265 7375 6c74 7320 3a20  -.    results : 
+000302a0: 3a63 6c61 7373 3a60 7475 706c 6560 206f  :class:`tuple` o
+000302b0: 6620 7370 6172 7365 2064 6174 6120 6172  f sparse data ar
+000302c0: 7261 7973 0a20 2020 2027 2727 0a0a 2020  rays.    '''..  
+000302d0: 2020 6675 6e63 7320 3d20 5b66 756e 632e    funcs = [func.
+000302e0: 6173 5f65 7661 6c75 6162 6c65 5f61 7272  as_evaluable_arr
+000302f0: 6179 2066 6f72 2066 756e 6320 696e 2066  ay for func in f
+00030300: 756e 6373 5d0a 2020 2020 7368 6170 655f  uncs].    shape_
+00030310: 6368 756e 6b73 203d 2054 7570 6c65 2874  chunks = Tuple(t
+00030320: 7570 6c65 2854 7570 6c65 2862 7569 6c74  uple(Tuple(built
+00030330: 696e 732e 7375 6d28 6675 6e63 2e73 696d  ins.sum(func.sim
+00030340: 706c 6966 6965 642e 5f61 7373 7061 7273  plified._asspars
+00030350: 652c 2066 756e 632e 7368 6170 6529 2920  e, func.shape)) 
+00030360: 666f 7220 6675 6e63 2069 6e20 6675 6e63  for func in func
+00030370: 7329 290a 2020 2020 7769 7468 2073 6861  s)).    with sha
+00030380: 7065 5f63 6875 6e6b 732e 6f70 7469 6d69  pe_chunks.optimi
+00030390: 7a65 645f 666f 725f 6e75 6d70 792e 7365  zed_for_numpy.se
+000303a0: 7373 696f 6e28 6772 6170 6876 697a 3d67  ssion(graphviz=g
+000303b0: 7261 7068 7669 7a29 2061 7320 6576 616c  raphviz) as eval
+000303c0: 3a0a 2020 2020 2020 2020 666f 7220 6675  :.        for fu
+000303d0: 6e63 2c20 6172 6773 2069 6e20 7a69 7028  nc, args in zip(
+000303e0: 6675 6e63 732c 2065 7661 6c28 2a2a 6172  funcs, eval(**ar
+000303f0: 6775 6d65 6e74 7329 293a 0a20 2020 2020  guments)):.     
+00030400: 2020 2020 2020 2073 6861 7065 203d 2074         shape = t
+00030410: 7570 6c65 286d 6170 2869 6e74 2c20 6172  uple(map(int, ar
+00030420: 6773 5b3a 6675 6e63 2e6e 6469 6d5d 2929  gs[:func.ndim]))
+00030430: 0a20 2020 2020 2020 2020 2020 2063 6875  .            chu
+00030440: 6e6b 7320 3d20 5b61 7267 735b 693a 692b  nks = [args[i:i+
+00030450: 6675 6e63 2e6e 6469 6d2b 315d 2066 6f72  func.ndim+1] for
+00030460: 2069 2069 6e20 7261 6e67 6528 6675 6e63   i in range(func
+00030470: 2e6e 6469 6d2c 206c 656e 2861 7267 7329  .ndim, len(args)
+00030480: 2c20 6675 6e63 2e6e 6469 6d2b 3129 5d0a  , func.ndim+1)].
+00030490: 2020 2020 2020 2020 2020 2020 6c65 6e67              leng
+000304a0: 7468 203d 2062 7569 6c74 696e 732e 7375  th = builtins.su
+000304b0: 6d28 7661 6c75 6573 2e73 697a 6520 666f  m(values.size fo
+000304c0: 7220 2a69 6e64 6963 6573 2c20 7661 6c75  r *indices, valu
+000304d0: 6573 2069 6e20 6368 756e 6b73 290a 2020  es in chunks).  
+000304e0: 2020 2020 2020 2020 2020 6461 7461 203d            data =
+000304f0: 206e 756d 7079 2e65 6d70 7479 2828 6c65   numpy.empty((le
+00030500: 6e67 7468 2c29 2c20 6474 7970 653d 7370  ngth,), dtype=sp
+00030510: 6172 7365 2e64 7479 7065 2873 6861 7065  arse.dtype(shape
+00030520: 2c20 6675 6e63 2e64 7479 7065 2929 0a20  , func.dtype)). 
+00030530: 2020 2020 2020 2020 2020 2073 7461 7274             start
+00030540: 203d 2030 0a20 2020 2020 2020 2020 2020   = 0.           
+00030550: 2066 6f72 202a 696e 6469 6365 732c 2076   for *indices, v
+00030560: 616c 7565 7320 696e 2063 6875 6e6b 733a  alues in chunks:
+00030570: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00030580: 2073 746f 7020 3d20 7374 6172 7420 2b20   stop = start + 
+00030590: 7661 6c75 6573 2e73 697a 650a 2020 2020  values.size.    
+000305a0: 2020 2020 2020 2020 2020 2020 6420 3d20              d = 
+000305b0: 6461 7461 5b73 7461 7274 3a73 746f 705d  data[start:stop]
+000305c0: 2e72 6573 6861 7065 2876 616c 7565 732e  .reshape(values.
+000305d0: 7368 6170 6529 0a20 2020 2020 2020 2020  shape).         
+000305e0: 2020 2020 2020 2064 5b27 7661 6c75 6527         d['value'
+000305f0: 5d20 3d20 7661 6c75 6573 0a20 2020 2020  ] = values.     
+00030600: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
+00030610: 6469 6d2c 2069 6920 696e 2065 6e75 6d65  dim, ii in enume
+00030620: 7261 7465 2869 6e64 6963 6573 293a 0a20  rate(indices):. 
+00030630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00030640: 2020 2064 5b27 696e 6465 7827 5d5b 2769     d['index']['i
+00030650: 272b 7374 7228 6964 696d 295d 203d 2069  '+str(idim)] = i
+00030660: 690a 2020 2020 2020 2020 2020 2020 2020  i.              
+00030670: 2020 7374 6172 7420 3d20 7374 6f70 0a20    start = stop. 
+00030680: 2020 2020 2020 2020 2020 2079 6965 6c64             yield
+00030690: 2064 6174 610a 0a0a 6966 205f 5f6e 616d   data...if __nam
+000306a0: 655f 5f20 3d3d 2027 5f5f 6d61 696e 5f5f  e__ == '__main__
+000306b0: 273a 0a20 2020 2023 2044 6961 676e 6f73  ':.    # Diagnos
+000306c0: 7469 6373 2066 6f72 2074 6865 2064 6576  tics for the dev
+000306d0: 656c 6f70 6d65 6e74 2066 6f72 2073 696d  elopment for sim
+000306e0: 706c 6966 7920 6f70 6572 6174 696f 6e73  plify operations
+000306f0: 2e0a 2020 2020 7369 6d70 6c69 6679 5f70  ..    simplify_p
+00030700: 7269 6f72 6974 7920 3d20 280a 2020 2020  riority = (.    
+00030710: 2020 2020 5472 616e 7370 6f73 652c 2052      Transpose, R
+00030720: 6176 656c 2c20 2023 2072 6569 6e74 6572  avel,  # reinter
+00030730: 7072 6574 6174 696f 6e0a 2020 2020 2020  pretation.      
+00030740: 2020 496e 7365 7274 4178 6973 2c20 496e    InsertAxis, In
+00030750: 666c 6174 652c 2044 6961 676f 6e61 6c69  flate, Diagonali
+00030760: 7a65 2c20 2023 2073 697a 6520 696e 6372  ze,  # size incr
+00030770: 6561 7369 6e67 0a20 2020 2020 2020 204d  easing.        M
+00030780: 756c 7469 706c 792c 2041 6464 2c20 4c6f  ultiply, Add, Lo
+00030790: 6f70 5375 6d2c 2053 6967 6e2c 2050 6f77  opSum, Sign, Pow
+000307a0: 6572 2c20 496e 7665 7273 652c 2055 6e72  er, Inverse, Unr
+000307b0: 6176 656c 2c20 2023 2073 697a 6520 7072  avel,  # size pr
+000307c0: 6573 6572 7669 6e67 0a20 2020 2020 2020  eserving.       
+000307d0: 2050 726f 6475 6374 2c20 4465 7465 726d   Product, Determ
+000307e0: 696e 616e 742c 2054 616b 6544 6961 672c  inant, TakeDiag,
+000307f0: 2054 616b 652c 2053 756d 2920 2023 2073   Take, Sum)  # s
+00030800: 697a 6520 6465 6372 6561 7369 6e67 0a20  ize decreasing. 
+00030810: 2020 2023 2054 6865 2073 696d 706c 6966     # The simplif
+00030820: 7920 7072 696f 7269 7479 2064 6566 696e  y priority defin
+00030830: 6573 2074 6865 2070 7265 6665 7272 6564  es the preferred
+00030840: 206f 7264 6572 2069 6e20 7768 6963 6820   order in which 
+00030850: 6f70 6572 6174 696f 6e73 2061 7265 0a20  operations are. 
+00030860: 2020 2023 2070 6572 666f 726d 6564 3a20     # performed: 
+00030870: 7368 6170 6520 6465 6372 6561 7369 6e67  shape decreasing
+00030880: 206f 7065 7261 7469 6f6e 7320 7375 6368   operations such
+00030890: 2061 7320 5375 6d20 616e 6420 5461 6b65   as Sum and Take
+000308a0: 2073 686f 756c 6420 6265 2064 6f6e 650a   should be done.
+000308b0: 2020 2020 2320 6173 2073 6f6f 6e20 6173      # as soon as
+000308c0: 2070 6f73 7369 626c 652c 2061 6e64 2073   possible, and s
+000308d0: 6861 7065 2069 6e63 7265 6173 696e 6720  hape increasing 
+000308e0: 6f70 6572 6174 696f 6e73 2073 7563 6820  operations such 
+000308f0: 6173 2049 6e66 6c61 7465 2061 6e64 0a20  as Inflate and. 
+00030900: 2020 2023 2044 6961 676f 6e61 6c69 7a65     # Diagonalize
+00030910: 2061 7320 6c61 7465 2061 7320 706f 7373   as late as poss
+00030920: 6962 6c65 2e20 496e 2073 6875 6666 6c69  ible. In shuffli
+00030930: 6e67 2074 6865 206f 7264 6572 206f 6620  ng the order of 
+00030940: 6f70 6572 6174 696f 6e73 2074 6865 0a20  operations the. 
+00030950: 2020 2023 2074 776f 2063 6c61 7373 6573     # two classes
+00030960: 206d 6967 6874 2061 6e6e 6968 696c 6174   might annihilat
+00030970: 6520 6561 6368 206f 7468 6572 2c20 666f  e each other, fo
+00030980: 7220 6578 616d 706c 6520 7768 656e 2061  r example when a
+00030990: 2053 756d 2070 6173 7365 730a 2020 2020   Sum passes.    
+000309a0: 2320 7468 726f 7567 6820 6120 4469 6167  # through a Diag
+000309b0: 6f6e 616c 697a 652e 2041 6e79 2073 6861  onalize. Any sha
+000309c0: 7065 2069 6e63 7265 6173 696e 6720 6f70  pe increasing op
+000309d0: 6572 6174 696f 6e73 2074 6861 7420 7265  erations that re
+000309e0: 6d61 696e 2073 686f 756c 640a 2020 2020  main should.    
+000309f0: 2320 656e 6420 7570 2061 7420 7468 6520  # end up at the 
+00030a00: 7375 7266 6163 652c 2065 7870 6f73 696e  surface, exposin
+00030a10: 6720 7370 6172 7369 7479 2062 7920 6d65  g sparsity by me
+00030a20: 616e 7320 6f66 2074 6865 205f 6173 7370  ans of the _assp
+00030a30: 6172 7365 206d 6574 686f 642e 0a20 2020  arse method..   
+00030a40: 2061 7474 7273 203d 205b 275f 272b 636c   attrs = ['_'+cl
+00030a50: 732e 5f5f 6e61 6d65 5f5f 2e6c 6f77 6572  s.__name__.lower
+00030a60: 2829 2066 6f72 2063 6c73 2069 6e20 7369  () for cls in si
+00030a70: 6d70 6c69 6679 5f70 7269 6f72 6974 795d  mplify_priority]
+00030a80: 0a20 2020 2023 2054 6865 2073 696d 706c  .    # The simpl
+00030a90: 6966 7920 6f70 6572 6174 696f 6e73 2072  ify operations r
+00030aa0: 6573 706f 6e73 6962 6c65 2066 6f72 2073  esponsible for s
+00030ab0: 7761 7070 696e 6720 2861 2e6f 2e29 2061  wapping (a.o.) a
+00030ac0: 7265 206d 6574 686f 6473 206e 616d 6564  re methods named
+00030ad0: 0a20 2020 2023 2027 5f61 6464 272c 2027  .    # '_add', '
+00030ae0: 5f6d 756c 7469 706c 7927 2c20 6574 632e  _multiply', etc.
+00030af0: 2049 6e20 6f72 6465 7220 746f 2061 766f   In order to avo
+00030b00: 6964 2072 6563 7572 7369 6f6e 7320 7468  id recursions th
+00030b10: 6520 6f70 6572 6174 696f 6e73 0a20 2020  e operations.   
+00030b20: 2023 2073 686f 756c 6420 6f6e 6c79 2062   # should only b
+00030b30: 6520 6465 6669 6e65 6420 696e 2074 6865  e defined in the
+00030b40: 2064 6972 6563 7469 6f6e 2064 6566 696e   direction defin
+00030b50: 6564 2062 7920 6f70 6572 6174 6f72 2070  ed by operator p
+00030b60: 7269 6f72 6974 792e 2054 6865 0a20 2020  riority. The.   
+00030b70: 2023 2066 6f6c 6c6f 7769 6e67 2063 6f64   # following cod
+00030b80: 6520 7761 726e 7320 6761 696e 7374 2076  e warns gainst v
+00030b90: 696f 6c61 7469 6f6e 7320 6f66 2074 6869  iolations of thi
+00030ba0: 7320 7275 6c65 2061 6e64 206c 6973 7473  s rule and lists
+00030bb0: 2070 6572 6d69 7373 6962 6c65 0a20 2020   permissible.   
+00030bc0: 2023 2073 696d 706c 6966 6963 6174 696f   # simplificatio
+00030bd0: 6e73 2074 6861 7420 6861 7665 206e 6f74  ns that have not
+00030be0: 2079 6574 2062 6565 6e20 696d 706c 656d   yet been implem
+00030bf0: 656e 7465 642e 0a20 2020 2066 6f72 2069  ented..    for i
+00030c00: 2c20 636c 7320 696e 2065 6e75 6d65 7261  , cls in enumera
+00030c10: 7465 2873 696d 706c 6966 795f 7072 696f  te(simplify_prio
+00030c20: 7269 7479 293a 0a20 2020 2020 2020 2077  rity):.        w
+00030c30: 6172 6e20 3d20 5b61 7474 7220 666f 7220  arn = [attr for 
+00030c40: 6174 7472 2069 6e20 6174 7472 735b 3a69  attr in attrs[:i
+00030c50: 5d20 6966 2067 6574 6174 7472 2863 6c73  ] if getattr(cls
+00030c60: 2c20 6174 7472 2920 6973 206e 6f74 2067  , attr) is not g
+00030c70: 6574 6174 7472 2841 7272 6179 2c20 6174  etattr(Array, at
+00030c80: 7472 295d 0a20 2020 2020 2020 2069 6620  tr)].        if 
+00030c90: 7761 726e 3a0a 2020 2020 2020 2020 2020  warn:.          
+00030ca0: 2020 7072 696e 7428 275b 215d 207b 7d20    print('[!] {} 
+00030cb0: 7368 6f75 6c64 206e 6f74 2064 6566 696e  should not defin
+00030cc0: 6520 7b7d 272e 666f 726d 6174 2863 6c73  e {}'.format(cls
+00030cd0: 2e5f 5f6e 616d 655f 5f2c 2027 2c20 272e  .__name__, ', '.
+00030ce0: 6a6f 696e 2877 6172 6e29 2929 0a20 2020  join(warn))).   
+00030cf0: 2020 2020 206d 6973 7369 6e67 203d 205b       missing = [
+00030d00: 6174 7472 2066 6f72 2061 7474 7220 696e  attr for attr in
+00030d10: 2061 7474 7273 5b69 2b31 3a5d 2069 6620   attrs[i+1:] if 
+00030d20: 6e6f 7420 6765 7461 7474 7228 636c 732c  not getattr(cls,
+00030d30: 2061 7474 7229 2069 7320 6e6f 7420 6765   attr) is not ge
+00030d40: 7461 7474 7228 4172 7261 792c 2061 7474  tattr(Array, att
+00030d50: 7229 5d0a 2020 2020 2020 2020 6966 206d  r)].        if m
+00030d60: 6973 7369 6e67 3a0a 2020 2020 2020 2020  issing:.        
+00030d70: 2020 2020 7072 696e 7428 275b 205d 207b      print('[ ] {
+00030d80: 7d20 636f 756c 6420 6465 6669 6e65 207b  } could define {
+00030d90: 7d27 2e66 6f72 6d61 7428 636c 732e 5f5f  }'.format(cls.__
+00030da0: 6e61 6d65 5f5f 2c20 272c 2027 2e6a 6f69  name__, ', '.joi
+00030db0: 6e28 6d69 7373 696e 6729 2929 0a0a 2320  n(missing)))..# 
+00030dc0: 7669 6d3a 7377 3d34 3a73 7473 3d34 3a65  vim:sw=4:sts=4:e
+00030dd0: 740a                                     t.
```

### Comparing `nutils-7.3/nutils/expression_v1.py` & `nutils-8.0/nutils/expression_v1.py`

 * *Files 2% similar despite different names*

```diff
@@ -132,14 +132,15 @@
 .. _`Einstein Summation Convection`: https://en.wikipedia.org/wiki/Einstein_notation
 '''
 
 import re
 import collections
 import functools
 import itertools
+import numpy
 import operator
 import types as builtin_types
 from typing import Any, Callable, Dict, List, Mapping, Optional, overload, Tuple, Union
 from . import function, types, warnings
 
 
 # Convenience function to create a constant in ExpressionAST (details in
@@ -1431,15 +1432,15 @@
     '''evaluate ``ast`` generated by :func:`parse`'''
 
     op, *args = ast
     if op is None:
         value, = args
         return value
 
-    args = (_eval_ast(arg, functions) for arg in args)
+    args = [_eval_ast(arg, functions) for arg in args]
     if op == 'group':
         array, = args
         return array
     elif op == 'arg':
         name, *shape = args
         return function.Argument(name, shape)
     elif op == 'substitute':
@@ -1473,35 +1474,35 @@
         geom, = args
         return function.normal(geom)
     elif op == 'getitem':
         array, dim, index = args
         return function.get(array, dim, index)
     elif op == 'trace':
         array, n1, n2 = args
-        return function.trace(array, n1, n2)
+        return numpy.trace(array, axis1=n1, axis2=n2)
     elif op == 'sum':
         array, axis = args
-        return function.sum(array, axis)
+        return numpy.sum(array, axis)
     elif op == 'concatenate':
-        return function.concatenate(args, axis=0)
+        return numpy.concatenate(args, axis=0)
     elif op == 'grad':
         array, geom = args
         return function.grad(array, geom)
     elif op == 'surfgrad':
         array, geom = args
         return function.grad(array, geom, len(geom)-1)
     elif op == 'derivative':
         func, target = args
         return function.derivative(func, target)
     elif op == 'append_axis':
         array, length = args
         return function.insertaxis(array, -1, length)
     elif op == 'transpose':
         array, trans = args
-        return function.transpose(array, trans)
+        return numpy.transpose(array, trans)
     elif op == 'jump':
         array, = args
         return function.jump(array)
     elif op == 'mean':
         array, = args
         return function.mean(array)
     elif op == 'neg':
@@ -1513,21 +1514,21 @@
     else:
         raise ValueError('unknown opcode: {!r}'.format(op))
 
 
 def _sum_expr(arg: function.Array, *, consumes: int = 0) -> function.Array:
     if consumes == 0:
         raise ValueError('sum must consume at least one axis but got zero')
-    return function.sum(arg, range(arg.ndim-consumes, arg.ndim))
+    return numpy.sum(arg, range(arg.ndim-consumes, arg.ndim))
 
 
 def _norm2_expr(arg: function.Array, *, consumes: int = 0) -> function.Array:
     if consumes == 0:
         raise ValueError('sum must consume at least one axis but got zero')
-    return function.norm2(arg, range(arg.ndim-consumes, arg.ndim))
+    return numpy.sqrt(numpy.sum(arg * numpy.conjugate(arg), range(arg.ndim-consumes, arg.ndim)))
 
 
 def _J_expr(geom: function.Array, *, consumes: int = 0) -> function.Array:
     if geom.ndim == 0:
         return function.J(function.insertaxis(geom, 0, 1))
     if consumes > 1:
         raise ValueError('J consumes at most one axis but got {}'.format(consumes))
@@ -1535,15 +1536,15 @@
         raise NotImplementedError('currently J cannot be vectorized')
     return function.J(geom)
 
 
 def _arctan2_expr(_a: function.Array, _b: function.Array) -> function.Array:
     a = function.Array.cast(_a)
     b = function.Array.cast(_b)
-    return function.arctan2(function._append_axes(a, b.shape), function._prepend_axes(b, a.shape))
+    return numpy.arctan2(function._append_axes(a, b.shape), function._prepend_axes(b, a.shape))
 
 
 class Namespace:
     '''Namespace for :class:`~nutils.function.Array` objects supporting assignments with tensor expressions.
 
     The :class:`Namespace` object is used to store
     :class:`~nutils.function.Array` objects.
@@ -1667,21 +1668,21 @@
     '''
 
     __slots__ = '_attributes', '_arg_shapes', 'default_geometry_name', '_fixed_lengths', '_fallback_length', '_functions'
 
     _re_assign = re.compile('^([a-zA-Zα-ωΑ-Ω][a-zA-Zα-ωΑ-Ω0-9]*)(_[a-z]+)?$')
 
     _default_functions = dict(
-        opposite=function.opposite, sin=function.sin, cos=function.cos,
-        tan=function.tan, sinh=function.sinh, cosh=function.cosh,
-        tanh=function.tanh, arcsin=function.arcsin, arccos=function.arccos,
-        arctan=function.arctan, arctan2=_arctan2_expr,
-        arctanh=function.arctanh, exp=function.exp, abs=function.abs,
-        ln=function.ln, log=function.ln, log2=function.log2, log10=function.log10,
-        sqrt=function.sqrt, sign=function.sign, d=function.d,
+        opposite=function.opposite, sin=numpy.sin, cos=numpy.cos,
+        tan=numpy.tan, sinh=numpy.sinh, cosh=numpy.cosh,
+        tanh=numpy.tanh, arcsin=numpy.arcsin, arccos=numpy.arccos,
+        arctan=numpy.arctan, arctan2=_arctan2_expr,
+        arctanh=numpy.arctanh, exp=numpy.exp, abs=numpy.abs,
+        ln=numpy.log, log=numpy.log, log2=numpy.log2, log10=numpy.log10,
+        sqrt=numpy.sqrt, sign=numpy.sign, d=function.d,
         surfgrad=function.surfgrad, n=function.normal, sum=_sum_expr,
         norm2=_norm2_expr, J=_J_expr,
     )
 
     def __init__(self, *, default_geometry_name: str = 'x', fallback_length: Optional[int] = None, functions: Optional[Mapping[str, Callable]] = None, **kwargs: Any) -> None:
         if not isinstance(default_geometry_name, str):
             raise ValueError('default_geometry_name: Expected a str, got {!r}.'.format(default_geometry_name))
@@ -1812,8 +1813,8 @@
             return NotImplemented
         try:
             ast = parse(expr, variables=self._attributes, indices=None, arg_shapes=self._arg_shapes, default_geometry_name=self.default_geometry_name, fixed_lengths=self._fixed_lengths, fallback_length=self._fallback_length)[0]
         except AmbiguousAlignmentError:
             raise ValueError('`expression @ Namespace` cannot be used because the expression has more than one dimension.  Use `Namespace.eval_...(expression)` instead')
         return _eval_ast(ast, self._functions)
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/expression_v2.py` & `nutils-8.0/nutils/expression_v2.py`

 * *Files 3% similar despite different names*

```diff
@@ -531,14 +531,22 @@
                 summed_indices.add(index)
                 j -= 1
             else:
                 j += 1
         return array, shape, indices, frozenset(summed_indices)
 
 
+def _grad(geom: function.Array, func: function.Array) -> function.Array:
+    return function.grad(func, geom)
+
+
+def _curl(geom: function.Array, func: function.Array) -> function.Array:
+    return numpy.sum(function.levicivita(3) * function.grad(func, geom)[..., numpy.newaxis, :, numpy.newaxis], axis=-2)
+
+
 class Namespace:
     '''Namespace for :class:`~nutils.function.Array` objects supporting assignments with tensor expressions.
 
     The :class:`Namespace` object is used to store :class:`~nutils.function.Array` objects.
 
     >>> from nutils import function
     >>> ns = Namespace()
@@ -691,28 +699,46 @@
         >>> ns.v = function.dotarg('v', ns.basis)
         >>> res = topo.integral('-∇_i(v) ∇_i(u) dV' @ ns, degree=2)
         >>> res += topo.boundary.integral('∇_i(v) u n_i dS' @ ns, degree=2)
         '''
 
         geom = getattr(self, __name)
         if gradient:
-            setattr(self, gradient, lambda arg: function.grad(arg, geom))
+            setattr(self, gradient, functools.partial(_grad, geom))
         if curl:
             if numpy.shape(geom) != (3,):
                 raise ValueError('The curl can only be defined for a geometry with shape (3,) but got {}.'.format(numpy.shape(geom)))
             # Definition: `curl_ki(u_...)` := `ε_kji ∇_j(u_...)`. Should be used as
             # `curl_ki(u_i)`, which is equivalent to `ε_kji ∇_j(u_i)`.
-            setattr(self, curl, lambda arg: numpy.sum(function.levicivita(3) * function.grad(arg, geom)[..., numpy.newaxis, :, numpy.newaxis], axis=-2))
+            setattr(self, curl, functools.partial(_curl, geom))
         if normal:
             setattr(self, normal, function.normal(geom))
         for i, jacobian in enumerate(jacobians):
             if i > numpy.size(geom):
                 raise ValueError('Cannot define the jacobian {!r}: dimension is negative.'.format(jacobian))
             setattr(self, jacobian, function.jacobian(geom, numpy.size(geom) - i))
 
+    def add_field(self, __names: Union[str, Sequence[str]], *__bases, shape: Tuple[int, ...] = (), dtype: function.DType = float):
+        '''Add field(s) of the form ns.u = function.dotarg('u', ...)
+
+        Parameters
+        ----------
+        names : :class:`str` or iterable thereof
+            Name of both the generated field and the function argument.
+        bases : :class:`nutils.function.Array` or something that can be :meth:`nutils.function.Array.cast` into one
+            The arrays to take inner products with.
+        shape : :class:`tuple` of :class:`int`, optional
+            The shape to be appended to the argument.
+        dtype : :class:`bool`, :class:`int`, :class:`float` or :class:`complex`
+            The dtype of the argument.
+        '''
+
+        for name in (__names,) if isinstance(__names, str) else __names:
+            setattr(self, name, function.dotarg(name, *__bases, shape=shape, dtype=dtype))
+
     def copy_(self, **replacements: Mapping[str, function.Array]) -> 'Namespace':
         '''Return a copy of this namespace.
 
         Parameters
         ----------
         **replacements : :class:`nutils.function.Array`
             Argument replacements to apply to the copy of this namespace.
```

### Comparing `nutils-7.3/nutils/function.py` & `nutils-8.0/nutils/function.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,65 +1,100 @@
 import typing
 if typing.TYPE_CHECKING:
     from typing_extensions import Protocol
 else:
     Protocol = object
 
-from typing import Tuple, Union, Type, Callable, Sequence, Any, Optional, Iterator, Iterable, Dict, Mapping, List, FrozenSet
-from . import evaluable, numeric, util, types, warnings, debug_flags, sparse
-from .transform import EvaluableTransformChain
+from typing import Tuple, Union, Type, Callable, Sequence, Any, Optional, Iterator, Iterable, Dict, Mapping, List, FrozenSet, NamedTuple
+from . import evaluable, numeric, _util as util, types, warnings, debug_flags, sparse, matrix
+from ._util import nutils_dispatch
+from ._backports import cached_property
 from .transformseq import Transforms
+import nutils_poly as poly
 import builtins
 import numpy
 import functools
 import operator
 import numbers
+import inspect
+import fractions
 
 IntoArray = Union['Array', numpy.ndarray, bool, int, float, complex]
 Shape = Sequence[int]
 DType = Type[Union[bool, int, float, complex]]
 _dtypes = bool, int, float, complex
 
-_PointsShape = Tuple[evaluable.Array, ...]
-_TransformChainsMap = Mapping[str, Tuple[EvaluableTransformChain, EvaluableTransformChain]]
-_CoordinatesMap = Mapping[str, evaluable.Array]
+class LowerArgs(NamedTuple):
+    '''Arguments for Lowerable.lower
+
+    Parameters
+    ----------
+    points_shape : :class:`tuple` of scalar, integer :class:`nutils.evaluable.Array`
+        The shape of the leading points axes that are to be added to the
+        lowered :class:`nutils.evaluable.Array`.
+    transform_chains : mapping of :class:`str` to tuples of :class:`nutils.transformseq.Transforms` and :class:`nutils.evaluable.Array`
+        A mapping of spaces to transforms sequences and evaluable indices.
+    coordinates : mapping of :class:`str` to :class:`nutils.evaluable.Array` objects
+        The coordinates at which the function will be evaluated.
+    '''
+
+    points_shape: Tuple[evaluable.Array, ...]
+    transform_chains: Mapping[str, Tuple[Transforms, evaluable.Array]]
+    coordinates: Mapping[str, evaluable.Array]
+
+    def consistent(self):
+        return all(
+            evaluable.equalshape(coords.shape[:-1], self.points_shape)
+            and space in self.transform_chains
+                for space, coords in self.coordinates.items())
+
+    @classmethod
+    def for_space(cls, space: str, transforms: Tuple[Transforms, ...], index: evaluable.Array, coordinates: evaluable.Array) -> 'LowerArgs':
+        if index.dtype != int or index.ndim != 0:
+            raise ValueError('argument `index` must be a scalar, integer `nutils.evaluable.Array`')
+        return cls(coordinates.shape[:-1], {space: (transforms, index)}, {space: coordinates})
+
+    def __or__(self, other: 'LowerArgs') -> 'LowerArgs':
+        duplicates = set(self.transform_chains) & set(other.transform_chains)
+        if duplicates:
+            raise ValueError(f'Nested integrals or samples in the same space: {", ".join(sorted(duplicates))}.')
+        transform_chains = self.transform_chains.copy()
+        transform_chains.update(other.transform_chains)
+        coordinates = {space: evaluable.Transpose.to_end(evaluable.appendaxes(coords, other.points_shape), coords.ndim - 1) for space, coords in self.coordinates.items()}
+        coordinates.update({space: evaluable.prependaxes(coords, self.points_shape) for space, coords in other.coordinates.items()})
+        points_shape = self.points_shape + other.points_shape
+        return LowerArgs(points_shape, transform_chains, coordinates)
 
 
 class Lowerable(Protocol):
     'Protocol for lowering to :class:`nutils.evaluable.Array`.'
 
     @property
     def spaces(self) -> FrozenSet[str]: ...
 
     @property
     def arguments(self) -> Mapping[str, Tuple[Shape, DType]]: ...
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
+    def lower(self, args: LowerArgs) -> evaluable.Array:
         '''Lower this object to a :class:`nutils.evaluable.Array`.
 
         Parameters
         ----------
-        points_shape : :class:`tuple` of scalar, integer :class:`nutils.evaluable.Array`
-            The shape of the leading points axes that are to be added to the
-            lowered :class:`nutils.evaluable.Array`.
-        transform_chains : mapping of :class:`str` to :class:`nutils.transform.EvaluableTransformChain` pairs
-        coordinates : mapping of :class:`str` to :class:`nutils.evaluable.Array` objects
-            The coordinates at which the function will be evaluated.
+        args : :class:`LowerArgs`
         '''
 
 
 _ArrayMeta = type
 
 if debug_flags.lower:
-    def _debug_lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        result = self._ArrayMeta__debug_lower_orig(points_shape, transform_chains, coordinates)
+    def _debug_lower(self, args: LowerArgs) -> evaluable.Array:
+        assert args.consistent()
+        result = self._ArrayMeta__debug_lower_orig(args)
         assert isinstance(result, evaluable.Array)
-        assert all(evaluable.equalshape(coords.shape[:-1], points_shape) for coords in coordinates.values())
-        assert all(space in transform_chains for space in coordinates)
-        offset = 0 if type(self) == _WithoutPoints else len(points_shape)
+        offset = 0 if type(self) == _WithoutPoints else len(args.points_shape)
         assert result.ndim == self.ndim + offset
         assert tuple(int(sh) for sh in result.shape[offset:]) == self.shape, 'shape mismatch'
         assert result.dtype == self.dtype, ('dtype mismatch', self.__class__)
         return result
 
     class _ArrayMeta(_ArrayMeta):
         def __new__(mcls, name, bases, namespace):
@@ -68,24 +103,23 @@
                 namespace['lower'] = _debug_lower
             return super().__new__(mcls, name, bases, namespace)
 
 # The lower cache introduced below should stay below the debug wrapper added
 # above. Otherwise the cached results are debugge again and again.
 
 
-def _cache_lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-    key = points_shape, transform_chains, coordinates
-    cached_key, cached_result = getattr(self, '_ArrayMeta__cached_lower', (None, None))
-    if cached_key == key:
+def _cache_lower(self, args: LowerArgs) -> evaluable.Array:
+    cached_args, cached_result = getattr(self, '_ArrayMeta__cached_lower', (None, None))
+    if cached_args == args:
         return cached_result
-    missing_spaces = self.spaces - set(transform_chains)
+    missing_spaces = self.spaces - set(args.transform_chains)
     if missing_spaces:
         raise ValueError('Cannot lower {} because the following spaces are unspecified: {}.'.format(self, missing_spaces))
-    result = self._ArrayMeta__cache_lower_orig(points_shape, transform_chains, coordinates)
-    self._ArrayMeta__cached_lower = key, result
+    result = self._ArrayMeta__cache_lower_orig(args)
+    self._ArrayMeta__cached_lower = args, result
     return result
 
 
 class _ArrayMeta(_ArrayMeta):
     def __new__(mcls, name, bases, namespace):
         if 'lower' in namespace:
             namespace['_ArrayMeta__cache_lower_orig'] = namespace.pop('lower')
@@ -125,15 +159,15 @@
 
     __array_priority__ = 1.  # http://stackoverflow.com/questions/7042496/numpy-coercion-problem-for-left-sided-binary-operator/7057530#7057530
 
     def __array_ufunc__(self, ufunc, method, *inputs, out=None, **kwargs):
         if method != '__call__' or ufunc not in HANDLED_FUNCTIONS:
             return NotImplemented
         try:
-            arrays = [v if isinstance(v, (Array, bool, int, float, complex, numpy.ndarray)) else Array.cast(v) for v in inputs]
+            arrays = [Array.cast(v) for v in inputs]
         except ValueError:
             return NotImplemented
         return HANDLED_FUNCTIONS[ufunc](*arrays, **kwargs)
 
     def __array_function__(self, func, types, args, kwargs):
         if func not in HANDLED_FUNCTIONS:
             return NotImplemented
@@ -145,53 +179,63 @@
 
         Parameters
         ----------
         value : :class:`Array`, or a :class:`numpy.ndarray` or similar
             The value to cast.
         '''
 
-        if isinstance(__value, Array):
-            value = __value
-        else:
-            try:
-                value = _Constant(__value)
-            except:
-                if isinstance(__value, (list, tuple)):
-                    value = stack(__value, axis=0)
-                else:
-                    raise ValueError('cannot convert {}.{} to Array'.format(type(__value).__module__, type(__value).__qualname__))
+        # We use deep_reduce to stack nested structures depth-first.
+        # Objects that are already Array are ignored. Lists or tuples
+        # containing at least one Array will cause all other items to be
+        # cast as well, before being stacked into a new Array, setting off
+        # a cascade down to the outermost list. Those that do not contain
+        # Array objects will bypass Nutils' array dispatches entirely.
+
+        # NOTE: it may seem that the same can be achieved without deep_reduce
+        # by simply stacking __value if it is a list or tuple: if any of its
+        # items are Array then it will be nutils-stacked; if all are numeric
+        # then it will be numpy-stacked. However, if no items are Array, but
+        # some are lists that contains Arrays, then Numpy's dispatch mechanism
+        # will not pick up on this and an object array will be formed instead.
+        # Hence the need for depth-first.
+        try:
+            value = util.deep_reduce(numpy.stack, __value)
+        except Exception as e: # something went wrong, e.g. incompatible shapes
+            raise ValueError(f'cannot convert {__value!r} to Array: {e}')
+
+        # If __value does not contain any Array then the result will not be
+        # Array either, in which case we wrap it in a _Constant. Since stack
+        # did most of the work already, we have only a handful of object types
+        # left that we know can be wrapped. We test for those here rather than
+        # have _Constant figure things out at potentially higher cost.
+        if isinstance(value, fractions.Fraction):
+            value = float(value)
+        if isinstance(value, (numpy.ndarray, bool, int, float, complex)):
+            value = _Constant(value)
+        elif not isinstance(value, Array):
+            raise ValueError(f'cannot convert {__value!r} to Array: unsupported data type')
+
         if dtype is not None and _dtypes.index(value.dtype) > _dtypes.index(dtype):
             raise ValueError('expected an array with dtype `{}` but got `{}`'.format(dtype.__name__, value.dtype.__name__))
         if ndim is not None and value.ndim != ndim:
             raise ValueError('expected an array with dimension `{}` but got `{}`'.format(ndim, value.ndim))
         return value
 
-    @classmethod
-    def cast_withscale(cls, __value: IntoArray, dtype: Optional[DType] = None, ndim: Optional[int] = None):
-        try:
-            scale = type(__value).reference_quantity
-        except AttributeError:
-            value = cls.cast(__value, dtype=dtype, ndim=ndim)
-            scale = value.dtype(1)
-        else:
-            value = cls.cast(__value / scale, dtype=dtype, ndim=ndim)
-        return value, scale
-
     def __init__(self, shape: Shape, dtype: DType, spaces: FrozenSet[str], arguments: Mapping[str, Tuple[Shape, DType]]) -> None:
         self.shape = tuple(sh.__index__() for sh in shape)
         self.dtype = dtype
         self.spaces = frozenset(spaces)
         self.arguments = dict(arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
+    def lower(self, args: LowerArgs) -> evaluable.Array:
         raise NotImplementedError
 
-    @util.cached_property
+    @cached_property
     def as_evaluable_array(self) -> evaluable.Array:
-        return self.lower((), {}, {})
+        return self.lower(LowerArgs((), {}, {}))
 
     def __index__(self):
         if self.arguments or self.spaces:
             raise ValueError('cannot convert non-constant array to index: arguments={}'.format(','.join(self.arguments)))
         elif self.ndim:
             raise ValueError('cannot convert non-scalar array to index: shape={}'.format(self.shape))
         elif self.dtype != int:
@@ -213,26 +257,28 @@
                 assert iell is None, 'at most one ellipsis allowed'
                 iell = i
             elif it is numpy.newaxis:
                 nx += 1
         array = self
         axis = 0
         for it in item + (slice(None),)*nx if iell is None else item[:iell] + (slice(None),)*(nx+1) + item[iell+1:]:
-            if isinstance(it, numbers.Integral):
-                array = get(array, axis, it)
-            else:
-                array = expand_dims(array, axis) if it is numpy.newaxis \
-                    else _takeslice(array, it, axis) if isinstance(it, slice) \
-                    else take(array, it, axis)
+            if it is numpy.newaxis:
+                array = expand_dims(array, axis)
+                axis += 1
+            elif isinstance(it, slice):
+                array = _takeslice(array, it, axis)
                 axis += 1
+            else:
+                array = numpy.take(array, it, axis)
+                axis += numpy.ndim(it)
         assert axis == array.ndim
         return array
 
     def __bool__(self) -> bool:
-        return True
+        raise ValueError('The truth value of a nutils Array is ambiguous')
 
     def __len__(self) -> int:
         'Length of the first axis.'
 
         if self.ndim == 0:
             raise TypeError('len() of unsized object')
         return self.shape[0]
@@ -250,53 +296,128 @@
 
         return util.product(self.shape, 1)
 
     @property
     def T(self) -> 'Array':
         'The transposed array.'
 
-        return transpose(self)
+        return numpy.transpose(self)
 
     def astype(self, dtype):
         if dtype == self.dtype:
             return self
         else:
             return _Wrapper(functools.partial(evaluable.astype, dtype=dtype), self, shape=self.shape, dtype=dtype)
 
     def sum(self, axis: Optional[Union[int, Sequence[int]]] = None) -> 'Array':
-        'See :func:`sum`.'
-        return sum(self, axis)
+        '''Return the sum of array elements over the given axes.
+
+        .. warning::
+
+           This method will change in future to match Numpy's equivalent
+           method, which sums over all axes by default. During transition, use
+           of this method without an axis argument will raise a warning, and
+           later an error, if the input array is of ndim >= 2.
+
+        Parameters
+        ----------
+        arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
+        axis : :class:`int`, a sequence of :class:`int`, or ``None``
+            The axis or axes to sum. ``None``, the default, implies summation
+            over the last axis.
+
+        Returns
+        -------
+        :class:`Array`
+        '''
+        if axis is None and self.ndim != 1:
+            warnings.deprecation(
+                "The default summation axis will change from being the last axis (old behaviour)\n"
+                "to being ALL axes (numpy's behaviour). To facilitate the transition, the axis\n"
+                "argument will be made MANDATORY for arrays with dimension > 1, for the duration\n"
+                "of at least one release cycle.")
+            axis = -1
+
+        return numpy.sum(self, axis)
 
     def prod(self, __axis: int) -> 'Array':
-        'See :func:`prod`.'
-        return product(self, __axis)
+        '''Return the product of array elements over the given axes.
+
+        Parameters
+        ----------
+        axis : :class:`int`, a sequence of :class:`int`, or ``None``
+            The axis or axes along which the product is performed. ``None``, the
+            default, implies all axes.
+
+        Returns
+        -------
+        :class:`Array`
+        '''
+
+        return numpy.product(self, __axis)
 
     def dot(self, __other: IntoArray, axes: Optional[Union[int, Sequence[int]]] = None) -> 'Array':
-        'See :func:`dot`.'
-        return dot(self, __other, axes)
+        '''Return the inner product of the arguments over the given axes, elementwise over the remanining axes.
+
+        .. warning::
+
+           This method will change in future to match Numpy's equivalent
+           method, which does not support an axis argument and has different
+           behaviour in case of higher dimensional input. During transition,
+           use of this method for any situation other than the contraction of
+           two vectors will raise a warning, and later an error. For
+           continuity, use numpy.dot, numpy.matmul, or the @ operator instead.
+
+        Parameters
+        ----------
+        arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
+        axis : :class:`int`, a sequence of :class:`int`, or ``None``
+            The axis or axes along which the inner product is performed. If the
+            second argument has one dimension and axes is ``None``, the default, the
+            inner product of the second argument with the first axis of the first
+            argument is computed. Otherwise ``axes=None`` is not allowed.
+
+        Returns
+        -------
+        :class:`Array`
+        '''
+        other = Array.cast(__other)
+        if axes is None and self.ndim == other.ndim == 1:
+            # this is the only scenario in which the old implementation of dot
+            # was compatible with that of numpy
+            return numpy.dot(self, other)
+        warnings.warn(
+            'The implementation of Array.dot will change in the next release cycle to make\n'
+            'it equal to that of Numpy: the axis argument will be removed and contraction\n'
+            'will happen over the last axis of the first argument, rather than the first.\n'
+            'To prepare for this transition, please update your code to use numpy.dot,\n'
+            'numpy.matmul, the @ operator, or a combination of multiply and sum instead.')
+        if axes is None:
+            assert other.ndim == 1 and other.shape[0] == self.shape[0]
+            other = _append_axes(other, self.shape[1:])
+            axes = 0,
+        return numpy.sum(self * other, axes)
 
     def normalized(self, __axis: int = -1) -> 'Array':
         'See :func:`normalized`.'
         return normalized(self, __axis)
 
     def normal(self, refgeom: Optional['Array'] = None) -> 'Array':
         'See :func:`normal`.'
         return normal(self, refgeom)
 
     def curvature(self, ndims: int = -1) -> 'Array':
         'See :func:`curvature`.'
         return curvature(self, ndims)
 
     def swapaxes(self, __axis1: int, __axis2: int) -> 'Array':
-        'See :func:`swapaxes`.'
-        return swapaxes(self, __axis1, __axis2)
+        return numpy.swapaxes(self, __axis1, __axis2)
 
     def transpose(self, __axes: Optional[Sequence[int]]) -> 'Array':
-        'See :func:`transpose`.'
-        return transpose(self, __axes)
+        return numpy.transpose(self, __axes)
 
     def add_T(self, axes: Tuple[int, int]) -> 'Array':
         'See :func:`add_T`.'
         return add_T(self, axes)
 
     def grad(self, __geom: IntoArray, ndims: int = 0) -> 'Array':
         'See :func:`grad`.'
@@ -332,34 +453,34 @@
 
     def nsymgrad(self, __geom: IntoArray, ndims: int = 0) -> 'Array':
         'See :func:`nsymgrad`.'
         return nsymgrad(self, __geom, ndims)
 
     def choose(self, __choices: Sequence[IntoArray]) -> 'Array':
         'See :func:`choose`.'
-        return choose(self, __choices)
+        return numpy.choose(self, __choices)
 
     def vector(self, ndims):
         if not self.ndim:
             raise Exception('a scalar function cannot be vectorized')
-        return ravel(diagonalize(insertaxis(self, 1, ndims), 1), 0)
+        return numpy.reshape(diagonalize(insertaxis(self, 1, ndims), 1), (self.shape[0] * ndims, ndims, *self.shape[1:]))
 
     def __repr__(self) -> str:
         return 'Array<{}>'.format(','.join(str(n) for n in self.shape))
 
     @property
     def simplified(self):
         warnings.deprecation('`nutils.function.Array.simplified` is deprecated. This property returns the array unmodified and can safely be omitted.')
         return self
 
-    def eval(self, **arguments: Any) -> numpy.ndarray:
+    @util.positional_only
+    def eval(self, arguments=...) -> numpy.ndarray:
         'Evaluate this function.'
 
-        from .sample import eval_integrals
-        return eval_integrals(self, **arguments)[0]
+        return evaluate(self, _post=_convert, arguments=arguments)[0]
 
     def derivative(self, __var: Union[str, 'Argument']) -> 'Array':
         'See :func:`derivative`.'
         return derivative(self, __var)
 
     def replace(self, __arguments: Mapping[str, IntoArray]) -> 'Array':
         'Return a copy with arguments applied.'
@@ -370,42 +491,58 @@
         return __name in self.arguments
 
     @property
     def argshapes(self) -> Mapping[str, Tuple[int, ...]]:
         return {name: shape for name, (shape, dtype) in self.arguments.items()}
 
     def conjugate(self):
-        'See :func:`conjugate`.'
-        return conjugate(self)
+        '''Return the complex conjugate, elementwise.
+
+        Returns
+        -------
+        :class:`Array`
+            The complex conjugate.
+        '''
+        return numpy.conjugate(self)
 
     conj = conjugate
 
     @property
     def real(self):
-        'See :func:`real`.'
-        return real(self)
+        '''Return the real part of the complex argument.
+
+        Returns
+        -------
+        :class:`Array`
+            The real part of the complex argument.
+        '''
+        return numpy.real(self)
 
     @property
     def imag(self):
-        'See :func:`imag`.'
-        return imag(self)
+        '''Return the imaginary part of the complex argument.
+
+        Returns
+        -------
+        :class:`Array`
+            The imaginary part of the complex argument.
+        '''
+        return numpy.imag(self)
 
 
 class _Unlower(Array):
 
-    def __init__(self, array: evaluable.Array, spaces: FrozenSet[str], arguments: Mapping[str, Tuple[Shape, DType]], points_shape: Tuple[evaluable.Array, ...], transform_chains: Tuple[EvaluableTransformChain, ...], coordinates: Tuple[evaluable.Array, ...]) -> None:
+    def __init__(self, array: evaluable.Array, spaces: FrozenSet[str], arguments: Mapping[str, Tuple[Shape, DType]], lower_args: LowerArgs) -> None:
         self._array = array
-        self._points_shape = points_shape
-        self._transform_chains = transform_chains
-        self._coordinates = coordinates
-        shape = tuple(n.__index__() for n in array.shape[len(points_shape):])
+        self._lower_args = lower_args
+        shape = tuple(n.__index__() for n in array.shape[len(lower_args.points_shape):])
         super().__init__(shape=shape, dtype=array.dtype, spaces=spaces, arguments=arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        if self._points_shape != points_shape or self._transform_chains != transform_chains or self._coordinates != coordinates:
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        if args != self._lower_args:
             raise ValueError('_Unlower must be lowered with the same arguments as those with which it is instantiated.')
         return self._array
 
 
 class Custom(Array):
     '''Combined :mod:`nutils.function` and :mod:`nutils.evaluable` array base class.
 
@@ -542,29 +679,29 @@
             # Apply singleton expansion to the leading points axes.
             points_shapes = tuple(arg.shape[:npointwise] for arg in args if isinstance(arg, Array))
             if not all(len(points_shape) == npointwise for points_shape in points_shapes):
                 raise ValueError('All arrays must have at least {} axes.'.format(npointwise))
             if len(points_shapes) == 0:
                 raise ValueError('Pointwise axes can only be used in combination with at least one `function.Array` argument.')
             points_shape = broadcast_shapes(*points_shapes)
-            args = tuple(broadcast_to(arg, points_shape + arg.shape[npointwise:]) if isinstance(arg, Array) else arg for arg in args)
+            args = tuple(numpy.broadcast_to(arg, points_shape + arg.shape[npointwise:]) if isinstance(arg, Array) else arg for arg in args)
         else:
             points_shape = ()
         self._args = args
         self._npointwise = npointwise
         spaces = frozenset(space for arg in args if isinstance(arg, Array) for space in arg.spaces)
         arguments = _join_arguments(arg.arguments for arg in args if isinstance(arg, Array))
         super().__init__(shape=(*points_shape, *shape), dtype=dtype, spaces=spaces, arguments=arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        args = tuple(arg.lower(points_shape, transform_chains, coordinates) if isinstance(arg, Array) else evaluable.EvaluableConstant(arg) for arg in self._args)  # type: Tuple[Union[evaluable.Array, evaluable.EvaluableConstant], ...]
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        evalargs = tuple(arg.lower(args) if isinstance(arg, Array) else evaluable.EvaluableConstant(arg) for arg in self._args)  # type: Tuple[Union[evaluable.Array, evaluable.EvaluableConstant], ...]
         add_points_shape = tuple(map(evaluable.asarray, self.shape[:self._npointwise]))
-        points_shape += add_points_shape
-        coordinates = {space: evaluable.Transpose.to_end(evaluable.appendaxes(coords, add_points_shape), coords.ndim-1) for space, coords in coordinates.items()}
-        return _CustomEvaluable(type(self).__name__, self.evalf, self.partial_derivative, args, self.shape[self._npointwise:], self.dtype, self.spaces, types.frozendict(self.arguments), points_shape, tuple(transform_chains.items()), tuple(coordinates.items()))
+        points_shape = args.points_shape + add_points_shape
+        coordinates = {space: evaluable.Transpose.to_end(evaluable.appendaxes(coords, add_points_shape), coords.ndim-1) for space, coords in args.coordinates.items()}
+        return _CustomEvaluable(type(self).__name__, self.evalf, self.partial_derivative, evalargs, self.shape[self._npointwise:], self.dtype, self.spaces, types.frozendict(self.arguments), LowerArgs(points_shape, types.frozendict(args.transform_chains), types.frozendict(coordinates)))
 
     @classmethod
     def evalf(cls, *args: Any) -> numpy.ndarray:
         '''Evaluate this function for the given evaluated arguments.
 
         This function is called with arguments that correspond to the arguments
         that are passed to the constructor of :class:`Custom`: every instance of
@@ -623,25 +760,25 @@
         '''
 
         raise NotImplementedError('The partial derivative of {} to argument {} (counting from 0) is not defined.'.format(cls.__name__, iarg))  # pragma: nocover
 
 
 class _CustomEvaluable(evaluable.Array):
 
-    def __init__(self, name, evalf, partial_derivative, args: Tuple[Union[evaluable.Array, evaluable.EvaluableConstant], ...], shape: Tuple[int, ...], dtype: DType, spaces: FrozenSet[str], arguments: types.frozendict, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> None:
+    def __init__(self, name, evalf, partial_derivative, args: Tuple[Union[evaluable.Array, evaluable.EvaluableConstant], ...], shape: Tuple[int, ...], dtype: DType, spaces: FrozenSet[str], arguments: types.frozendict, lower_args: LowerArgs) -> None:
         assert all(isinstance(arg, (evaluable.Array, evaluable.EvaluableConstant)) for arg in args)
         self.name = name
         self.custom_evalf = evalf
         self.custom_partial_derivative = partial_derivative
         self.args = args
-        self.points_dim = len(points_shape)
-        self.lower_args = points_shape, dict(transform_chains), dict(coordinates)
+        self.points_dim = len(lower_args.points_shape)
+        self.lower_args = lower_args
         self.spaces = spaces
         self.function_arguments = arguments
-        super().__init__((evaluable.Tuple(points_shape), *args), shape=points_shape+shape, dtype=dtype)
+        super().__init__((evaluable.Tuple(lower_args.points_shape), *args), shape=(*lower_args.points_shape, *map(evaluable.constant, shape)), dtype=dtype)
 
     @property
     def _node_details(self) -> str:
         return self.name
 
     def evalf(self, points_shape: Tuple[numpy.ndarray, ...], *args: Any) -> numpy.ndarray:
         points_shape = tuple(n.__index__() for n in points_shape)
@@ -660,38 +797,38 @@
         else:
             return result.reshape(points_shape + result.shape[1:])
 
     def _derivative(self, var: evaluable.Array, seen: Dict[evaluable.Array, evaluable.Array]) -> evaluable.Array:
         if self.dtype in (bool, int):
             return super()._derivative(var, seen)
         result = evaluable.Zeros(self.shape + var.shape, dtype=self.dtype)
-        unlowered_args = tuple(_Unlower(arg, self.spaces, self.function_arguments, *self.lower_args) if isinstance(arg, evaluable.Array) else arg.value for arg in self.args)
+        unlowered_args = tuple(_Unlower(arg, self.spaces, self.function_arguments, self.lower_args) if isinstance(arg, evaluable.Array) else arg.value for arg in self.args)
         for iarg, arg in enumerate(self.args):
             if not isinstance(arg, evaluable.Array) or arg.dtype in (bool, int) or var not in arg.arguments and var != arg:
                 continue
             fpd = Array.cast(self.custom_partial_derivative(iarg, *unlowered_args))
             fpd_expected_shape = tuple(n.__index__() for n in self.shape[self.points_dim:] + arg.shape[self.points_dim:])
             if fpd.shape != fpd_expected_shape:
                 raise ValueError('`partial_derivative` to argument {} returned an array with shape {} but {} was expected.'.format(iarg, fpd.shape, fpd_expected_shape))
-            epd = evaluable.appendaxes(fpd.lower(*self.lower_args), var.shape)
+            epd = evaluable.appendaxes(fpd.lower(self.lower_args), var.shape)
             eda = evaluable.derivative(arg, var, seen)
             eda = evaluable.Transpose.from_end(evaluable.appendaxes(eda, self.shape[self.points_dim:]), *range(self.points_dim, self.ndim))
             result += (epd * eda).sum(range(self.ndim, self.ndim + arg.ndim - self.points_dim))
         return result
 
 
 class _WithoutPoints:
 
     def __init__(self, __arg: Array) -> None:
         self._arg = __arg
         self.spaces = __arg.spaces
         self.arguments = __arg.arguments
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        return self._arg.lower((), transform_chains, {})
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        return self._arg.lower(LowerArgs((), args.transform_chains, {}))
 
 
 class _Wrapper(Array):
 
     @classmethod
     def broadcasted_arrays(cls, lower: Callable[..., evaluable.Array], *args: IntoArray, min_dtype: DType = bool, force_dtype: Optional[DType] = None) -> '_Wrapper':
         broadcasted = broadcast_arrays(*typecast_arrays(*args, min_dtype=min_dtype))
@@ -701,38 +838,38 @@
         self._lower = lower
         self._args = args
         assert all(hasattr(arg, 'lower') for arg in self._args)
         spaces = frozenset(space for arg in args for space in arg.spaces)
         arguments = _join_arguments(arg.arguments for arg in self._args)
         super().__init__(shape, dtype, spaces, arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        return self._lower(*(arg.lower(points_shape, transform_chains, coordinates) for arg in self._args))
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        return self._lower(*(arg.lower(args) for arg in self._args))
 
 
 class _Zeros(Array):
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        return evaluable.Zeros((*points_shape, *self.shape), self.dtype)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        return evaluable.Zeros((*args.points_shape, *map(evaluable.constant, self.shape)), self.dtype)
 
 
 class _Ones(Array):
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        return evaluable.ones((*points_shape, *self.shape), self.dtype)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        return evaluable.ones(args.points_shape + tuple(evaluable.constant(n) for n in self.shape), self.dtype)
 
 
 class _Constant(Array):
 
     def __init__(self, value: Any) -> None:
         self._value = types.arraydata(value)
         super().__init__(self._value.shape, self._value.dtype, frozenset(()), {})
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        return evaluable.prependaxes(evaluable.Constant(self._value), points_shape)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        return evaluable.prependaxes(evaluable.Constant(self._value), args.points_shape)
 
 
 class Argument(Array):
     '''Array valued function argument.
 
     Parameters
     ----------
@@ -745,46 +882,51 @@
 
     Attributes
     ----------
     name : str
         The name of this argument.
     '''
 
-    def __init__(self, name: str, shape: Shape, *, dtype: DType = float) -> None:
+    def __init__(self, name: str, shape: Shape, dtype: DType = float) -> None:
         self.name = name
         super().__init__(shape, dtype, frozenset(()), {name: (tuple(shape), dtype)})
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        return evaluable.prependaxes(evaluable.Argument(self.name, self.shape, self.dtype), points_shape)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        return evaluable.prependaxes(evaluable.Argument(self.name, tuple(evaluable.constant(n) for n in self.shape), self.dtype), args.points_shape)
 
 
 class _Replace(Array):
 
     def __init__(self, arg: Array, replacements: Dict[str, Array]) -> None:
         self._arg = arg
-        # TODO: verify that the replacements have empty spaces
-        self._replacements = replacements
+        self._replacements = {}
         # Build arguments map with replacements.
         unreplaced = {}
-        arguments = [unreplaced]
         for name, (shape, dtype) in arg.arguments.items():
-            replacement = replacements.get(name, None)
-            if replacement is None:
-                unreplaced[name] = shape, dtype
-            elif replacement.shape != shape:
-                raise ValueError('Argument {!r} has shape {} but the replacement has shape {}.'.format(name, shape, replacement.shape))
-            elif replacement.dtype != dtype:
-                raise ValueError('Argument {!r} has dtype {} but the replacement has dtype {}.'.format(name, dtype.__name__ if dtype in _dtypes else dtype, replacement.dtype.__name__ if replacement.dtype in _dtypes else replacement.dtype))
+            if name in replacements:
+                replacement = replacements[name]
+                if isinstance(replacement, str):
+                    replacement = Argument(replacement, shape, dtype)
+                else:
+                    replacement = Array.cast(replacement)
+                    if replacement.shape != shape:
+                        raise ValueError(f'Argument {name!r} has shape {shape} but the replacement has shape {replacement.shape}.')
+                    if replacement.dtype != dtype:
+                        raise ValueError(f'Argument {name!r} has dtype {dtype.__name__} but the replacement has dtype {replacement.dtype.__name__}.')
+                    if replacement.spaces:
+                        raise ValueError(f'replacement functions cannot contain spaces, but replacement for Argument {name!r} contains space {", ".join(replacement.spaces)}.')
+                self._replacements[name] = replacement
             else:
-                arguments.append(replacement.arguments)
-        super().__init__(arg.shape, arg.dtype, arg.spaces, _join_arguments(arguments))
+                unreplaced[name] = shape, dtype
+        arguments = _join_arguments([unreplaced] + [replacement.arguments for replacement in self._replacements.values()])
+        super().__init__(arg.shape, arg.dtype, arg.spaces, arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        arg = self._arg.lower(points_shape, transform_chains, coordinates)
-        replacements = {name: _WithoutPoints(value).lower(points_shape, transform_chains, coordinates) for name, value in self._replacements.items()}
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        arg = self._arg.lower(args)
+        replacements = {name: _WithoutPoints(value).lower(args) for name, value in self._replacements.items()}
         return evaluable.replace_arguments(arg, replacements)
 
 
 class _Transpose(Array):
 
     @classmethod
     def _end(cls, array: Array, axes: Tuple[int, ...], invert: bool = False) -> Array:
@@ -803,155 +945,157 @@
 
     @classmethod
     def to_end(cls, array: Array, *axes: int) -> Array:
         return cls._end(array, axes, invert=False)
 
     def __init__(self, arg: Array, axes: Tuple[int, ...]) -> None:
         self._arg = arg
-        self._axes = axes
+        self._axes = tuple(n.__index__() for n in axes)
         super().__init__(tuple(arg.shape[axis] for axis in axes), arg.dtype, arg.spaces, arg.arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        arg = self._arg.lower(points_shape, transform_chains, coordinates)
-        offset = len(points_shape)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        arg = self._arg.lower(args)
+        offset = len(args.points_shape)
         axes = (*range(offset), *(i+offset for i in self._axes))
         return evaluable.Transpose(arg, axes)
 
 
 class _Opposite(Array):
 
     def __init__(self, arg: Array, space: str) -> None:
         self._arg = arg
         self._space = space
         super().__init__(arg.shape, arg.dtype, arg.spaces, arg.arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        transform_chains = dict(transform_chains)
-        transform_chains[self._space] = transform_chains[self._space][::-1]
-        return self._arg.lower(points_shape, transform_chains, coordinates)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        oppargs = LowerArgs(args.points_shape, dict(args.transform_chains), args.coordinates)
+        transforms, index = args.transform_chains[self._space]
+        oppargs.transform_chains[self._space] = transforms[::-1], index
+        return self._arg.lower(oppargs)
 
 
 class _RootCoords(Array):
 
     def __init__(self, space: str, ndims: int) -> None:
         self._space = space
         super().__init__((ndims,), float, frozenset({space}), {})
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        inv_linear = evaluable.diagonalize(evaluable.ones(self.shape))
-        inv_linear = evaluable.prependaxes(inv_linear, points_shape)
-        tip_coords = coordinates[self._space]
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        inv_linear = evaluable.diagonalize(evaluable.ones(tuple(evaluable.constant(n) for n in self.shape)))
+        inv_linear = evaluable.prependaxes(inv_linear, args.points_shape)
+        tip_coords = args.coordinates[self._space]
         tip_coords = evaluable.WithDerivative(tip_coords, _tip_derivative_target(self._space, tip_coords.shape[-1]), evaluable.Diagonalize(evaluable.ones(tip_coords.shape)))
-        coords = transform_chains[self._space][0].apply(tip_coords)
-        return evaluable.WithDerivative(coords, _root_derivative_target(self._space, self.shape[0]), inv_linear)
+        transforms, index = args.transform_chains[self._space]
+        coords = evaluable.TransformCoords(None, transforms[0], index, tip_coords)
+        return evaluable.WithDerivative(coords, _root_derivative_target(self._space, evaluable.constant(self.shape[0])), inv_linear)
 
 
 class _TransformsIndex(Array):
 
     def __init__(self, space: str, transforms: Transforms) -> None:
         self._space = space
         self._transforms = transforms
         super().__init__((), int, frozenset({space}), {})
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        index, tail = transform_chains[self._space][0].index_with_tail_in(self._transforms)
-        return evaluable.prependaxes(index, points_shape)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        transforms, index = args.transform_chains[self._space]
+        return evaluable.prependaxes(evaluable.TransformIndex(self._transforms, transforms[0], index), args.points_shape)
 
 
 class _TransformsCoords(Array):
 
     def __init__(self, space: str, transforms: Transforms) -> None:
         self._space = space
         self._transforms = transforms
         super().__init__((transforms.fromdims,), float, frozenset({space}), {})
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        index, tail = transform_chains[self._space][0].index_with_tail_in(self._transforms)
-        head = self._transforms.get_evaluable(index)
-        L = head.linear
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        transforms, tip_index = args.transform_chains[self._space]
+        index = evaluable.TransformIndex(self._transforms, transforms[0], tip_index)
+        L = evaluable.TransformLinear(None, self._transforms, index)
         if self._transforms.todims > self._transforms.fromdims:
             LTL = evaluable.einsum('ki,kj->ij', L, L)
             Linv = evaluable.einsum('ik,jk->ij', evaluable.inverse(LTL), L)
         else:
             Linv = evaluable.inverse(L)
-        Linv = evaluable.prependaxes(Linv, points_shape)
-        tip_coords = coordinates[self._space]
+        Linv = evaluable.prependaxes(Linv, args.points_shape)
+        tip_coords = args.coordinates[self._space]
         tip_coords = evaluable.WithDerivative(tip_coords, _tip_derivative_target(self._space, tip_coords.shape[-1]), evaluable.Diagonalize(evaluable.ones(tip_coords.shape)))
-        coords = tail.apply(tip_coords)
-        return evaluable.WithDerivative(coords, _root_derivative_target(self._space, self._transforms.todims), Linv)
+        coords = evaluable.TransformCoords(self._transforms, transforms[0], tip_index, tip_coords)
+        return evaluable.WithDerivative(coords, _root_derivative_target(self._space, evaluable.constant(self._transforms.todims)), Linv)
 
 
 class _Derivative(Array):
 
     def __init__(self, arg: Array, var: Argument) -> None:
         assert isinstance(var, Argument)
         self._arg = arg
         self._var = var
-        self._eval_var = evaluable.Argument(var.name, var.shape, var.dtype)
+        self._eval_var = evaluable.Argument(var.name, tuple(evaluable.constant(n) for n in var.shape), var.dtype)
         arguments = _join_arguments((arg.arguments, var.arguments))
         super().__init__(arg.shape+var.shape, complex if var.dtype == complex else arg.dtype, arg.spaces | var.spaces, arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        arg = self._arg.lower(points_shape, transform_chains, coordinates)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        arg = self._arg.lower(args)
         return evaluable.derivative(arg, self._eval_var)
 
 
-def _tip_derivative_target(space: str, dim: int) -> evaluable.DerivativeTargetBase:
+def _tip_derivative_target(space: str, dim) -> evaluable.DerivativeTargetBase:
     return evaluable.IdentifierDerivativeTarget((space, 'tip'), (dim,))
 
 
 def _root_derivative_target(space: str, dim: int) -> evaluable.DerivativeTargetBase:
     return evaluable.IdentifierDerivativeTarget((space, 'root'), (dim,))
 
 
 class _Gradient(Array):
     # Derivative of `func` to `geom` using the root coords as reference.
 
     def __init__(self, func: Array, geom: Array) -> None:
         assert geom.spaces, '0d array'
         assert geom.dtype == float
         common_shape = broadcast_shapes(func.shape, geom.shape[:-1])
-        self._func = broadcast_to(func, common_shape)
-        self._geom = broadcast_to(geom, (*common_shape, geom.shape[-1]))
+        self._func = numpy.broadcast_to(func, common_shape)
+        self._geom = numpy.broadcast_to(geom, (*common_shape, geom.shape[-1]))
         arguments = _join_arguments((func.arguments, geom.arguments))
         super().__init__(self._geom.shape, complex if func.dtype == complex else float, func.spaces | geom.spaces, arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        func = self._func.lower(points_shape, transform_chains, coordinates)
-        geom = self._geom.lower(points_shape, transform_chains, coordinates)
-        ref_dim = builtins.sum(transform_chains[space][0].todims for space in self._geom.spaces)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        func = self._func.lower(args)
+        geom = self._geom.lower(args)
+        ref_dim = builtins.sum(args.transform_chains[space][0][0].todims for space in self._geom.spaces)
         if self._geom.shape[-1] != ref_dim:
             raise Exception('cannot invert {}x{} jacobian'.format(self._geom.shape[-1], ref_dim))
-        refs = tuple(_root_derivative_target(space, chain.todims) for space, (chain, opposite) in transform_chains.items() if space in self._geom.spaces)
+        refs = tuple(_root_derivative_target(space, evaluable.constant(chain.todims)) for space, ((chain, *_), index) in args.transform_chains.items() if space in self._geom.spaces)
         dfunc_dref = evaluable.concatenate([evaluable.derivative(func, ref) for ref in refs], axis=-1)
         dgeom_dref = evaluable.concatenate([evaluable.derivative(geom, ref) for ref in refs], axis=-1)
         dref_dgeom = evaluable.inverse(dgeom_dref)
         return evaluable.einsum('Ai,Aij->Aj', dfunc_dref, dref_dgeom)
 
 
 class _SurfaceGradient(Array):
     # Surface gradient of `func` to `geom` using the tip coordinates as
     # reference.
 
     def __init__(self, func: Array, geom: Array) -> None:
         assert geom.spaces, '0d array'
         assert geom.dtype == float
         common_shape = broadcast_shapes(func.shape, geom.shape[:-1])
-        self._func = broadcast_to(func, common_shape)
-        self._geom = broadcast_to(geom, (*common_shape, geom.shape[-1]))
+        self._func = numpy.broadcast_to(func, common_shape)
+        self._geom = numpy.broadcast_to(geom, (*common_shape, geom.shape[-1]))
         arguments = _join_arguments((func.arguments, geom.arguments))
         super().__init__(self._geom.shape, complex if func.dtype == complex else float, func.spaces | geom.spaces, arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        func = self._func.lower(points_shape, transform_chains, coordinates)
-        geom = self._geom.lower(points_shape, transform_chains, coordinates)
-        ref_dim = builtins.sum(transform_chains[space][0].fromdims for space in self._geom.spaces)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        func = self._func.lower(args)
+        geom = self._geom.lower(args)
+        ref_dim = builtins.sum(args.transform_chains[space][0][0].fromdims for space in self._geom.spaces)
         if self._geom.shape[-1] != ref_dim + 1:
             raise ValueError('expected a {}d geometry but got a {}d geometry'.format(ref_dim + 1, self._geom.shape[-1]))
-        refs = tuple((_root_derivative_target if chain.todims == chain.fromdims else _tip_derivative_target)(space, chain.fromdims) for space, (chain, opposite) in transform_chains.items() if space in self._geom.spaces)
+        refs = tuple((_root_derivative_target if chain.todims == chain.fromdims else _tip_derivative_target)(space, evaluable.constant(chain.fromdims)) for space, ((chain, *_), index) in args.transform_chains.items() if space in self._geom.spaces)
         dfunc_dref = evaluable.concatenate([evaluable.derivative(func, ref) for ref in refs], axis=-1)
         dgeom_dref = evaluable.concatenate([evaluable.derivative(geom, ref) for ref in refs], axis=-1)
         dref_dgeom = evaluable.einsum('Ajk,Aik->Aij', dgeom_dref, evaluable.inverse(evaluable.grammium(dgeom_dref)))
         return evaluable.einsum('Ai,Aij->Aj', dfunc_dref, dref_dgeom)
 
 
 class _Jacobian(Array):
@@ -966,72 +1110,72 @@
         if tip_dim is not None and tip_dim > geom.shape[-1]:
             raise ValueError('Expected a dimension of the tip coordinate system '
                              'not greater than the dimension of the geometry.')
         self._tip_dim = tip_dim
         self._geom = geom
         super().__init__((), float, geom.spaces, geom.arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        geom = self._geom.lower(points_shape, transform_chains, coordinates)
-        tip_dim = builtins.sum(transform_chains[space][0].fromdims for space in self._geom.spaces)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        geom = self._geom.lower(args)
+        tip_dim = builtins.sum(args.transform_chains[space][0][0].fromdims for space in self._geom.spaces)
         if self._tip_dim is not None and self._tip_dim != tip_dim:
             raise ValueError('Expected a tip dimension of {} but got {}.'.format(self._tip_dim, tip_dim))
         if self._geom.shape[-1] < tip_dim:
             raise ValueError('the dimension of the geometry cannot be lower than the dimension of the tip coords')
         if not self._geom.spaces:
             return evaluable.ones(geom.shape[:-1])
-        tips = [_tip_derivative_target(space, chain.fromdims) for space, (chain, opposite) in transform_chains.items() if space in self._geom.spaces]
+        tips = [_tip_derivative_target(space, evaluable.constant(chain.fromdims)) for space, ((chain, *_), index) in args.transform_chains.items() if space in self._geom.spaces]
         J = evaluable.concatenate([evaluable.derivative(geom, tip) for tip in tips], axis=-1)
         return evaluable.sqrt_abs_det_gram(J)
 
 
 class _Normal(Array):
 
     def __init__(self, geom: Array) -> None:
         self._geom = geom
         assert geom.dtype == float
         super().__init__(geom.shape, float, geom.spaces, geom.arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        geom = self._geom.lower(points_shape, transform_chains, coordinates)
-        spaces_dim = builtins.sum(transform_chains[space][0].todims for space in self._geom.spaces)
-        normal_dim = spaces_dim - builtins.sum(transform_chains[space][0].fromdims for space in self._geom.spaces)
-        if self._geom.shape[-1] != spaces_dim:
-            raise ValueError('The dimension of geometry must equal the sum of the dimensions of the given spaces.')
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        geom = self._geom.lower(args)
+        spaces_dim = builtins.sum(args.transform_chains[space][0][0].todims for space in self._geom.spaces)
+        normal_dim = spaces_dim - builtins.sum(args.transform_chains[space][0][0].fromdims for space in self._geom.spaces)
+        if self._geom.shape[-1] < spaces_dim:
+            raise ValueError('The dimension of geometry must equal or larger than the sum of the dimensions of the given spaces.')
         if normal_dim == 0:
             raise ValueError('Cannot compute the normal because the dimension of the normal space is zero.')
         elif normal_dim > 1:
             raise ValueError('Cannot unambiguously compute the normal because the dimension of the normal space is larger than one.')
         tangents = []
         normal = None
-        for space, (chain, opposite) in transform_chains.items():
+        for space, ((chain, *_), index) in args.transform_chains.items():
             if space not in self._geom.spaces:
                 continue
-            rgrad = evaluable.derivative(geom, _root_derivative_target(space, chain.todims))
+            rgrad = evaluable.derivative(geom, _root_derivative_target(space, evaluable.constant(chain.todims)))
             if chain.todims == chain.fromdims:
                 # `chain.basis` is `eye(chain.todims)`
                 tangents.append(rgrad)
             else:
                 assert normal is None and chain.todims == chain.fromdims + 1
-                basis = evaluable.einsum('Aij,jk->Aik', rgrad, chain.basis)
+                basis = evaluable.einsum('Aij,jk->Aik', rgrad, evaluable.TransformBasis(chain, index))
                 tangents.append(basis[..., :chain.fromdims])
-                normal = basis[..., chain.fromdims:]
+                normal = basis[..., chain.fromdims]
         assert normal is not None
-        return evaluable.Normal(evaluable.concatenate((*tangents, normal), axis=-1))
+        return evaluable.Orthonormal(evaluable.concatenate(tangents, axis=-1), normal)
 
 
 class _ExteriorNormal(Array):
 
     def __init__(self, rgrad: Array) -> None:
         assert rgrad.dtype == float and rgrad.shape[-2] == rgrad.shape[-1] + 1
         self._rgrad = rgrad
         super().__init__(rgrad.shape[:-1], float, rgrad.spaces, rgrad.arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        rgrad = self._rgrad.lower(points_shape, transform_chains, coordinates)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        rgrad = self._rgrad.lower(args)
         if self._rgrad.shape[-2] == 2:
             normal = evaluable.stack([rgrad[..., 1, 0], -rgrad[..., 0, 0]], axis=-1)
         elif self._rgrad.shape[-2] == 3:
             i = evaluable.asarray([1, 2, 0])
             j = evaluable.asarray([2, 0, 1])
             normal = evaluable.Take(rgrad[..., 0], i) * evaluable.Take(rgrad[..., 1], j) - evaluable.Take(rgrad[..., 1], i) * evaluable.Take(rgrad[..., 0], j)
         else:
@@ -1049,16 +1193,16 @@
             raise ValueError('all the input array dimensions except for the concatenation axis must match exactly')
         super().__init__(
             shape=(*shape0[:self.axis], builtins.sum(array.shape[self.axis] for array in self.arrays), *shape0[self.axis+1:]),
             dtype=self.arrays[0].dtype,
             spaces=functools.reduce(operator.or_, (array.spaces for array in self.arrays)),
             arguments=_join_arguments(array.arguments for array in self.arrays))
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        return util.sum(evaluable._inflate(array.lower(points_shape, transform_chains, coordinates), evaluable.Range(array.shape[self.axis]) + offset, self.shape[self.axis], self.axis-self.ndim)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        return util.sum(evaluable._inflate(array.lower(args), evaluable.Range(evaluable.constant(array.shape[self.axis])) + offset, evaluable.constant(self.shape[self.axis]), self.axis-self.ndim)
                         for array, offset in zip(self.arrays, util.cumsum(array.shape[self.axis] for array in self.arrays)))
 
 
 def _join_arguments(args_list: Iterable[Mapping[str, Argument]]) -> Dict[str, Argument]:
     joined = {}  # type: Dict[str, Argument]
     for arguments in args_list:
         for name, (shape1, dtype1) in arguments.items():
@@ -1071,23 +1215,22 @@
                 elif dtype1 != dtype2:
                     raise ValueError('Argument {!r} has two different dtypes: {}, {}.'.format(name, dtype1.__name__ if dtype1 in _dtypes else dtype1, dtype2.__name__ if dtype2 in _dtypes else dtype2))
     return joined
 
 # CONSTRUCTORS
 
 
-HANDLED_FUNCTIONS = {}
-
-
-def implements(np_function):
-    'Register an ``__array_function__`` or ``__array_ufunc__`` implementation for Array objects.'
-    def decorator(func):
-        HANDLED_FUNCTIONS[np_function] = func
-        return func
-    return decorator
+def _use_instead(alternative):
+    def wrapper(f):
+        @functools.wraps(f)
+        def wrapped(*args, **kwargs):
+            warnings.deprecation(f'function.{f.__name__} is deprecated; use {alternative} instead')
+            return f(*args, **kwargs)
+        return wrapped
+    return wrapper
 
 
 def asarray(__arg: IntoArray) -> Array:
     '''Cast a value to an :class:`Array`.
 
     Parameters
     ----------
@@ -1098,25 +1241,25 @@
     -------
     :class:`Array`
     '''
 
     return Array.cast(__arg)
 
 
-@implements(numpy.shape)
+@_use_instead('numpy.shape')
 def shape(__arg: IntoArray) -> Tuple[int, ...]:
     return asarray(__arg).shape
 
 
-@implements(numpy.ndim)
+@_use_instead('numpy.ndim')
 def ndim(__arg: IntoArray) -> int:
     return asarray(__arg).ndim
 
 
-@implements(numpy.size)
+@_use_instead('numpy.size')
 def size(__arg: IntoArray) -> int:
     return asarray(__arg).size
 
 
 def zeros(shape: Shape, dtype: DType = float) -> Array:
     '''Create a new :class:`Array` of given shape and dtype, filled with zeros.
 
@@ -1187,15 +1330,15 @@
     '''
 
     return _Constant(numeric.levicivita(__n))
 
 # ARITHMETIC
 
 
-@implements(numpy.add)
+@_use_instead('numpy.add')
 def add(__left: IntoArray, __right: IntoArray) -> Array:
     '''Return the sum of the arguments, elementwise.
 
     Parameters
     ----------
     left, right : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1203,15 +1346,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.add, __left, __right)
 
 
-@implements(numpy.subtract)
+@_use_instead('numpy.subtract')
 def subtract(__left: IntoArray, __right: IntoArray) -> Array:
     '''Return the difference of the arguments, elementwise.
 
     Parameters
     ----------
     left, right : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1219,15 +1362,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.subtract, __left, __right)
 
 
-@implements(numpy.positive)
+@_use_instead('numpy.positive')
 def positive(__arg: IntoArray) -> Array:
     '''Return the argument unchanged.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1235,15 +1378,15 @@
     -------
     :class:`Array`
     '''
 
     return Array.cast(__arg)
 
 
-@implements(numpy.negative)
+@_use_instead('numpy.negative')
 def negative(__arg: IntoArray) -> Array:
     '''Return the negation of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1251,53 +1394,47 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.negative, __arg)
 
 
-@implements(numpy.multiply)
+@_use_instead('numpy.multiply')
 def multiply(__left: IntoArray, __right: IntoArray) -> Array:
     '''Return the product of the arguments, elementwise.
 
     Parameters
     ----------
     left, right : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
     Returns
     -------
     :class:`Array`
     '''
 
-    left, right = typecast_arrays(__left, __right)
-    return right if _is_unit_scalar(__left) \
-        else left if _is_unit_scalar(__right) \
-        else _Wrapper.broadcasted_arrays(evaluable.multiply, left, right)
+    return _Wrapper.broadcasted_arrays(evaluable.multiply, __left, __right)
 
 
-@implements(numpy.true_divide)
+@_use_instead('numpy.divide')
 def divide(__dividend: IntoArray, __divisor: IntoArray) -> Array:
     '''Return the true-division of the arguments, elementwise.
 
     Parameters
     ----------
     dividend, divisor : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
     Returns
     -------
     :class:`Array`
     '''
 
-    dividend, divisor = typecast_arrays(__dividend, __divisor, min_dtype=float)
-    return dividend if _is_unit_scalar(__divisor) \
-        else reciprocal(divisor) if _is_unit_scalar(__dividend) \
-        else _Wrapper.broadcasted_arrays(evaluable.divide, dividend, divisor)
+    return _Wrapper.broadcasted_arrays(evaluable.divide, __dividend, __divisor, min_dtype=float)
 
 
-@implements(numpy.floor_divide)
+@_use_instead('numpy.floor_divide')
 def floor_divide(__dividend: IntoArray, __divisor: IntoArray) -> Array:
     '''Return the floor-division of the arguments, elementwise.
 
     Parameters
     ----------
     dividend, divisor : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1305,15 +1442,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.FloorDivide, __dividend, __divisor)
 
 
-@implements(numpy.reciprocal)
+@_use_instead('numpy.reciprocal')
 def reciprocal(__arg: IntoArray) -> Array:
     '''Return the reciprocal of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1321,15 +1458,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.reciprocal, __arg)
 
 
-@implements(numpy.power)
+@_use_instead('numpy.power')
 def power(__base: IntoArray, __exponent: IntoArray) -> Array:
     '''Return the exponentiation of the arguments, elementwise.
 
     Parameters
     ----------
     base, exponent : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1337,15 +1474,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.power, __base, __exponent, min_dtype=int)
 
 
-@implements(numpy.sqrt)
+@_use_instead('numpy.sqrt')
 def sqrt(__arg: IntoArray) -> Array:
     '''Return the square root of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1353,25 +1490,26 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.sqrt, __arg, min_dtype=float)
 
 
-@implements(numpy.square)
+@_use_instead('numpy.square')
 def square(__arg: IntoArray) -> Array:
-    return power(__arg, 2)
+    warnings.deprecation('function.square is deprecated; use numpy.square instead')
+    return Array.cast(numpy.square(__arg))
 
 
-@implements(numpy.hypot)
+@_use_instead('numpy.hypot')
 def hypot(__array1: IntoArray, __array2: IntoArray) -> Array:
-    return sqrt(square(__array1) + square(__array2))
+    return numpy.sqrt(numpy.square(__array1) + numpy.square(__array2))
 
 
-@implements(numpy.absolute)
+@_use_instead('abs or numpy.abs')
 def abs(__arg: IntoArray) -> Array:
     '''Return the absolute value of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1380,15 +1518,15 @@
     :class:`Array`
     '''
 
     arg = Array.cast(__arg)
     return _Wrapper(evaluable.abs, arg, shape=arg.shape, dtype=float if arg.dtype == complex else arg.dtype)
 
 
-@implements(numpy.matmul)
+@_use_instead('numpy.matmul or the @ operator')
 def matmul(__arg1: IntoArray, __arg2: IntoArray) -> Array:
     '''Return the matrix product of two arrays.
 
     Parameters
     ----------
     arg1, arg2 : :class:`Array` or something that can be :meth:`~Array.cast` into one
         Input arrays.
@@ -1411,15 +1549,15 @@
         return (arg1 * arg2).sum(-1)
     elif arg1.ndim == 1:
         return (arg1[:, numpy.newaxis] * arg2).sum(-2)
     else:
         return (arg1[..., :, :, numpy.newaxis] * arg2[..., numpy.newaxis, :, :]).sum(-2)
 
 
-@implements(numpy.sign)
+@_use_instead('numpy.sign')
 def sign(__arg: IntoArray) -> Array:
     '''Return the sign of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1430,15 +1568,15 @@
 
     arg = Array.cast(__arg)
     if arg.dtype == complex:
         raise ValueError('sign is not defined for complex numbers')
     return _Wrapper.broadcasted_arrays(evaluable.Sign, __arg)
 
 
-@implements(numpy.mod)
+@_use_instead('numpy.mod')
 def mod(__dividend: IntoArray, __divisor: IntoArray) -> Array:
     '''Return the remainder of the floored division, elementwise.
 
     Parameters
     ----------
     dividend, divisor : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1446,15 +1584,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.Mod, __dividend, __divisor)
 
 
-@implements(numpy.divmod)
+@_use_instead('numpy.divmod')
 def divmod(__dividend: IntoArray, __divisor: IntoArray) -> Tuple[Array, Array]:
     '''Return the floor-division and remainder, elementwise.
 
     Parameters
     ----------
     dividend, divisor : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1464,15 +1602,15 @@
     '''
 
     return floor_divide(__dividend, __divisor), mod(__dividend, __divisor)
 
 # TRIGONOMETRIC
 
 
-@implements(numpy.cos)
+@_use_instead('numpy.cos')
 def cos(__arg: IntoArray) -> Array:
     '''Return the trigonometric cosine of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1480,15 +1618,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.Cos, __arg, min_dtype=float)
 
 
-@implements(numpy.sin)
+@_use_instead('numpy.sin')
 def sin(__arg: IntoArray) -> Array:
     '''Return the trigonometric sine of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1496,15 +1634,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.Sin, __arg, min_dtype=float)
 
 
-@implements(numpy.tan)
+@_use_instead('numpy.tab')
 def tan(__arg: IntoArray) -> Array:
     '''Return the trigonometric tangent of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1512,15 +1650,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.Tan, __arg, min_dtype=float)
 
 
-@implements(numpy.arccos)
+@_use_instead('numpy.arccos')
 def arccos(__arg: IntoArray) -> Array:
     '''Return the trigonometric inverse cosine of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1528,15 +1666,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.ArcCos, __arg, min_dtype=float)
 
 
-@implements(numpy.arcsin)
+@_use_instead('numpy.arcsin')
 def arcsin(__arg: IntoArray) -> Array:
     '''Return the trigonometric inverse sine of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1544,15 +1682,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.ArcSin, __arg, min_dtype=float)
 
 
-@implements(numpy.arctan)
+@_use_instead('numpy.arctan')
 def arctan(__arg: IntoArray) -> Array:
     '''Return the trigonometric inverse tangent of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1560,15 +1698,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.ArcTan, __arg, min_dtype=float)
 
 
-@implements(numpy.arctan2)
+@_use_instead('numpy.arctan2')
 def arctan2(__dividend: IntoArray, __divisor: IntoArray) -> Array:
     '''Return the trigonometric inverse tangent of the ``dividend / divisor``, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1579,15 +1717,15 @@
 
     dividend, divisor = broadcast_arrays(*typecast_arrays(__dividend, __divisor, min_dtype=float))
     if dividend.dtype == complex:
         raise ValueError('arctan2 is not defined for complex numbers')
     return _Wrapper(evaluable.ArcTan2, dividend, divisor, shape=dividend.shape, dtype=float)
 
 
-@implements(numpy.cosh)
+@_use_instead('numpy.cosh')
 def cosh(__arg: IntoArray) -> Array:
     '''Return the hyperbolic cosine of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1595,15 +1733,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.cosh, __arg, min_dtype=float)
 
 
-@implements(numpy.sinh)
+@_use_instead('numpy.sinh')
 def sinh(__arg: IntoArray) -> Array:
     '''Return the hyperbolic sine of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1611,15 +1749,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.sinh, __arg, min_dtype=float)
 
 
-@implements(numpy.tanh)
+@_use_instead('numpy.tanh')
 def tanh(__arg: IntoArray) -> Array:
     '''Return the hyperbolic tangent of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1627,15 +1765,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.tanh, __arg, min_dtype=float)
 
 
-@implements(numpy.arctanh)
+@_use_instead('numpy.arctanh')
 def arctanh(__arg: IntoArray) -> Array:
     '''Return the hyperbolic inverse tangent of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1643,15 +1781,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.arctanh, __arg, min_dtype=float)
 
 
-@implements(numpy.exp)
+@_use_instead('numpy.exp')
 def exp(__arg: IntoArray) -> Array:
     '''Return the exponential of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1659,15 +1797,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.Exp, __arg, min_dtype=float)
 
 
-@implements(numpy.log)
+@_use_instead('numpy.log')
 def log(__arg: IntoArray) -> Array:
     '''Return the natural logarithm of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1678,15 +1816,15 @@
 
     return _Wrapper.broadcasted_arrays(evaluable.Log, __arg, min_dtype=float)
 
 
 ln = log
 
 
-@implements(numpy.log2)
+@_use_instead('numpy.log2')
 def log2(__arg: IntoArray) -> Array:
     '''Return the base 2 logarithm of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1694,15 +1832,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.log2, __arg, min_dtype=float)
 
 
-@implements(numpy.log10)
+@_use_instead('numpy.log10')
 def log10(__arg: IntoArray) -> Array:
     '''Return the base 10 logarithm of the argument, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1712,15 +1850,15 @@
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.log10, __arg, min_dtype=float)
 
 # COMPARISON
 
 
-@implements(numpy.greater)
+@_use_instead('numpy.greater or the > operator')
 def greater(__left: IntoArray, __right: IntoArray) -> Array:
     '''Return if the first argument is greater than the second, elementwise.
 
     Parameters
     ----------
     left, right : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1731,15 +1869,15 @@
 
     left, right = map(Array.cast, (__left, __right))
     if left.dtype == complex or right.dtype == complex:
         raise ValueError('Complex numbers have no total order.')
     return _Wrapper.broadcasted_arrays(evaluable.Greater, left, right, force_dtype=bool)
 
 
-@implements(numpy.equal)
+@_use_instead('numpy.equal or the == operator')
 def equal(__left: IntoArray, __right: IntoArray) -> Array:
     '''Return if the first argument equals the second, elementwise.
 
     Parameters
     ----------
     left, right : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1747,15 +1885,15 @@
     -------
     :class:`Array`
     '''
 
     return _Wrapper.broadcasted_arrays(evaluable.Equal, __left, __right, force_dtype=bool)
 
 
-@implements(numpy.less)
+@_use_instead('numpy.less or the < operator')
 def less(__left: IntoArray, __right: IntoArray) -> Array:
     '''Return if the first argument is less than the second, elementwise.
 
     Parameters
     ----------
     left, right : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1766,15 +1904,15 @@
 
     left, right = map(Array.cast, (__left, __right))
     if left.dtype == complex or right.dtype == complex:
         raise ValueError('Complex numbers have no total order.')
     return _Wrapper.broadcasted_arrays(evaluable.Less, left, right, force_dtype=bool)
 
 
-@implements(numpy.min)
+@_use_instead('numpy.minimum')
 def min(__a: IntoArray, __b: IntoArray) -> Array:
     '''Return the minimum of the arguments, elementwise.
 
     Parameters
     ----------
     a, b : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1785,15 +1923,15 @@
 
     a, b = map(Array.cast, (__a, __b))
     if a.dtype == complex or b.dtype == complex:
         raise ValueError('Complex numbers have no total order.')
     return _Wrapper.broadcasted_arrays(evaluable.Minimum, a, b)
 
 
-@implements(numpy.max)
+@_use_instead('numpy.maximum')
 def max(__a: IntoArray, __b: IntoArray) -> Array:
     '''Return the maximum of the arguments, elementwise.
 
     Parameters
     ----------
     a, b : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1803,17 +1941,19 @@
     '''
 
     a, b = map(Array.cast, (__a, __b))
     if a.dtype == complex or b.dtype == complex:
         raise ValueError('Complex numbers have no total order.')
     return _Wrapper.broadcasted_arrays(evaluable.Maximum, a, b)
 
+
 # OPPOSITE
 
 
+@nutils_dispatch
 def opposite(__arg: IntoArray) -> Array:
     '''Evaluate this function at the opposite side.
 
     When evaluating a function ``arg`` at an interface, the function will be
     evaluated at one side of the interface. :func:`opposite` selects the opposite
     side.
 
@@ -1854,20 +1994,21 @@
     See Also
     --------
 
     :func:`mean` : the mean at an interface
     :func:`jump` : the jump at an interface
     '''
 
-    arg, scale = Array.cast_withscale(__arg)
+    arg = Array.cast(__arg)
     for space in sorted(arg.spaces):
         arg = _Opposite(arg, space)
-    return arg * scale
+    return arg
 
 
+@nutils_dispatch
 def mean(__arg: IntoArray) -> Array:
     '''Return the mean of the argument at an interface.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -1890,14 +2031,15 @@
     >>> topo.interfaces.sample('bezier', 1).eval(function.mean(f))
     array([ 1.5])
     '''
 
     return .5 * (__arg + opposite(__arg))
 
 
+@nutils_dispatch
 def jump(__arg: IntoArray) -> Array:
     '''Return the jump of the argument at an interface.
 
     The sign of the jump depends on the orientation of the interfaces in a
     :class:`~nutils.topology.Topology`. Usually the jump is used as part of an
     inner product with the :func:`normal` of the geometry is used, which is
     independent of the orientation of the interfaces.
@@ -1928,15 +2070,15 @@
     '''
 
     return opposite(__arg) - __arg
 
 # REDUCTION
 
 
-@implements(numpy.sum)
+@_use_instead('numpy.sum')
 def sum(__arg: IntoArray, axis: Optional[Union[int, Sequence[int]]] = None) -> Array:
     '''Return the sum of array elements over the given axes.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`, a sequence of :class:`int`, or ``None``
@@ -1957,15 +2099,15 @@
     axes = typing.cast(Sequence[int], (axis,) if isinstance(axis, numbers.Integral) else axis)
     summed = _Transpose.to_end(arg, *axes)
     for i in range(len(axes)):
         summed = _Wrapper(evaluable.Sum, summed, shape=summed.shape[:-1], dtype=summed.dtype)
     return summed
 
 
-@implements(numpy.product)
+@_use_instead('numpy.product')
 def product(__arg: IntoArray, axis: int) -> Array:
     '''Return the product of array elements over the given axes.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`, a sequence of :class:`int`, or ``None``
@@ -1982,15 +2124,15 @@
         arg = arg.astype(int)
     transposed = _Transpose.to_end(arg, axis)
     return _Wrapper(evaluable.Product, transposed, shape=transposed.shape[:-1], dtype=arg.dtype)
 
 # LINEAR ALGEBRA
 
 
-@implements(numpy.conjugate)
+@_use_instead('numpy.conjugate')
 def conjugate(__arg: IntoArray) -> Array:
     '''Return the complex conjugate, elementwise.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -2003,15 +2145,15 @@
     arg = Array.cast(__arg)
     return _Wrapper(evaluable.conjugate, arg, shape=arg.shape, dtype=arg.dtype)
 
 
 conj = conjugate
 
 
-@implements(numpy.real)
+@_use_instead('numpy.real')
 def real(__arg: IntoArray) -> Array:
     '''Return the real part of the complex argument.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -2021,15 +2163,15 @@
         The real part of the complex argument.
     '''
 
     arg = Array.cast(__arg)
     return _Wrapper(evaluable.real, arg, shape=arg.shape, dtype=float if arg.dtype == complex else arg.dtype)
 
 
-@implements(numpy.imag)
+@_use_instead('numpy.imag')
 def imag(__arg: IntoArray) -> Array:
     '''Return the imaginary part of the complex argument.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -2039,21 +2181,23 @@
         The imaginary part of the complex argument.
     '''
 
     arg = Array.cast(__arg)
     return _Wrapper(evaluable.imag, arg, shape=arg.shape, dtype=float if arg.dtype == complex else arg.dtype)
 
 
+@_use_instead('numpy.dot, matmul or a combination of multiply and sum')
 def dot(__a: IntoArray, __b: IntoArray, axes: Optional[Union[int, Sequence[int]]] = None) -> Array:
     '''Return the inner product of the arguments over the given axes, elementwise over the remanining axes.
 
     Parameters
     ----------
-    arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
-    axis : :class:`int`, a sequence of :class:`int`, or ``None``
+    a : :class:`Array` or something that can be :meth:`~Array.cast` into one
+    b : :class:`Array` or something that can be :meth:`~Array.cast` into one
+    axes : :class:`int`, a sequence of :class:`int`, or ``None``
         The axis or axes along which the inner product is performed. If the
         second argument has one dimension and axes is ``None``, the default, the
         inner product of the second argument with the first axis of the first
         argument is computed. Otherwise ``axes=None`` is not allowed.
 
     Returns
     -------
@@ -2062,18 +2206,18 @@
 
     a = Array.cast(__a)
     b = Array.cast(__b)
     if axes is None:
         assert b.ndim == 1 and b.shape[0] == a.shape[0]
         b = _append_axes(b, a.shape[1:])
         axes = 0,
-    return sum(multiply(a, b), axes)
+    return numpy.sum(a * b, axes)
 
 
-@implements(numpy.vdot)
+@_use_instead('numpy.vdot')
 def vdot(__a: IntoArray, __b: IntoArray, axes: Optional[Union[int, Sequence[int]]] = None) -> Array:
     '''Return the dot product of two vectors.
 
     If the arguments are not 1D, the arguments are flattened. The dot product is
     then defined as
 
         sum(conjugate(a) * b)
@@ -2085,24 +2229,18 @@
 
     Returns
     -------
     :class:`Array`
     '''
 
     a, b = broadcast_arrays(__a, __b)
-    return sum(multiply(conjugate(a), b), range(a.ndim))
-
-
-@implements(numpy.trace)
-def _trace(__arg: IntoArray, offset: int = 0, axis1: int = -2, axis2: int = -1) -> Array:
-    if offset != 0:
-        raise NotImplementedError('traces over offset diagonal are not yet supported')
-    return trace(__arg, axis1, axis2)
+    return numpy.sum(numpy.conjugate(a) * b, range(a.ndim))
 
 
+@_use_instead('numpy.trace')
 def trace(__arg: IntoArray, axis1: int = -2, axis2: int = -1) -> Array:
     '''Return the trace, the sum of the diagonal, of an array over the two given axes, elementwise over the remanining axes.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis1 : :class:`int`
@@ -2111,17 +2249,18 @@
         The second axis. Defaults to the last axis.
 
     Returns
     -------
     :class:`Array`
     '''
 
-    return sum(_takediag(__arg, axis1, axis2), -1)
+    return numpy.sum(_takediag(__arg, axis1, axis2), -1)
 
 
+@_use_instead('numpy.linalg.norm')
 def norm2(__arg: IntoArray, axis: Union[int, Sequence[int]] = -1) -> Array:
     '''Return the 2-norm of the argument over the given axis, elementwise over the remanining axes.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`
@@ -2129,49 +2268,47 @@
 
     Returns
     -------
     :class:`Array`
     '''
 
     arg = Array.cast(__arg)
-    return sqrt(sum(multiply(arg, conjugate(arg)), axis))
+    return numpy.sqrt(numpy.sum(arg * numpy.conjugate(arg), axis))
 
 
+@nutils_dispatch
 def normalized(__arg: IntoArray, axis: int = -1) -> Array:
     '''Return the argument normalized over the given axis, elementwise over the remanining axes.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`
         The axis along which the norm is computed. Defaults to the last axis.
 
     Returns
     -------
     :class:`Array`
-
-    See Also
-    --------
-    :func:`norm2` : The 2-norm.
     '''
 
     arg = Array.cast(__arg)
-    return divide(arg, insertaxis(norm2(arg, axis), axis, 1))
+    return arg / insertaxis(numpy.linalg.norm(arg, axis=axis), axis, 1)
 
 
 def matmat(__arg0: IntoArray, *args: IntoArray) -> Array:
     'helper function, contracts last axis of arg0 with first axis of arg1, etc'
     retval = Array.cast(__arg0)
     for arg in map(Array.cast, args):
         if retval.shape[-1] != arg.shape[0]:
             raise ValueError('incompatible shapes')
-        retval = dot(retval[(...,)+(numpy.newaxis,)*(arg.ndim-1)], arg[(numpy.newaxis,)*(retval.ndim-1)], retval.ndim-1)
+        retval = numpy.sum(_append_axes(retval, arg.shape[1:]) * arg, retval.ndim-1)
     return retval
 
 
+@_use_instead('numpy.linalg.inv')
 def inverse(__arg: IntoArray, __axes: Tuple[int, int] = (-2, -1)) -> Array:
     '''Return the inverse of the argument along the given axes, elementwise over the remaining axes.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axes : :class:`tuple` of two :class:`int`
@@ -2187,14 +2324,15 @@
     transposed = _Transpose.to_end(arg, *__axes)
     if transposed.shape[-2] != transposed.shape[-1]:
         raise ValueError('cannot compute the inverse along two axes with different lengths')
     inverted = _Wrapper(evaluable.Inverse, transposed, shape=transposed.shape, dtype=arg.dtype)
     return _Transpose.from_end(inverted, *__axes)
 
 
+@_use_instead('numpy.linalg.det')
 def determinant(__arg: IntoArray, __axes: Tuple[int, int] = (-2, -1)) -> Array:
     '''Return the determinant of the argument along the given axes, elementwise over the remaining axes.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axes : :class:`tuple` of two :class:`int`
@@ -2216,14 +2354,15 @@
 
 
 def _eval_eigvec(arg: evaluable.Array, symmetric: bool) -> evaluable.Array:
     val, vec = evaluable.Eig(arg, symmetric)
     return vec
 
 
+@_use_instead('numpy.linalg.eig or numpy.linalg.eigh')
 def eig(__arg: IntoArray, __axes: Tuple[int, int] = (-2, -1), symmetric: bool = False) -> Tuple[Array, Array]:
     '''Return the eigenvalues and right eigenvectors of the argument along the given axes, elementwise over the remaining axes.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axes : :class:`tuple` of two :class:`int`
@@ -2251,14 +2390,15 @@
     arg = Array.cast(__arg)
     transposed = _Transpose.to_end(arg, _axis1, _axis2)
     if transposed.shape[-2] != transposed.shape[-1]:
         raise ValueError('cannot take the diagonal along two axes with different lengths')
     return _Wrapper(evaluable.TakeDiag, transposed, shape=transposed.shape[:-1], dtype=transposed.dtype)
 
 
+@_use_instead('numpy.diagonal')
 def takediag(__arg: IntoArray, __axis: int = -2, __rmaxis: int = -1) -> Array:
     '''Return the diagonal of the argument along the given axes.
 
     Parameters
     ----------
     arg : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`
@@ -2306,14 +2446,15 @@
     newaxis = numeric.normdim(arg.ndim+1, __newaxis)
     assert axis < newaxis
     transposed = _Transpose.to_end(arg, axis)
     diagonalized = _Wrapper(evaluable.Diagonalize, transposed, shape=(*transposed.shape, transposed.shape[-1]), dtype=transposed.dtype)
     return _Transpose.from_end(diagonalized, axis, newaxis)
 
 
+@_use_instead('numpy.cross')
 def cross(__arg1: IntoArray, __arg2: IntoArray, axis: int = -1) -> Array:
     '''Return the cross product of the arguments over the given axis, elementwise over the remaining axes.
 
     Parameters
     ----------
     arg1, arg2 : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`
@@ -2329,15 +2470,15 @@
     '''
 
     arg1, arg2 = broadcast_arrays(*typecast_arrays(__arg1, __arg2, min_dtype=int))
     axis = numeric.normdim(arg1.ndim, axis)
     assert arg1.shape[axis] == 3
     i = Array.cast(types.frozenarray([1, 2, 0]))
     j = Array.cast(types.frozenarray([2, 0, 1]))
-    return take(arg1, i, axis) * take(arg2, j, axis) - take(arg2, i, axis) * take(arg1, j, axis)
+    return numpy.take(arg1, i, axis) * numpy.take(arg2, j, axis) - numpy.take(arg2, i, axis) * numpy.take(arg1, j, axis)
 
 
 def outer(arg1, arg2=None, axis=0):
     'outer product'
 
     if arg2 is None:
         arg2 = arg1
@@ -2345,15 +2486,15 @@
         raise ValueError('arg1 and arg2 have different dimensions')
     axis = numeric.normdim(arg1.ndim, axis)
     return expand_dims(arg1, axis+1) * expand_dims(arg2, axis)
 
 # ARRAY OPS
 
 
-@implements(numpy.transpose)
+@_use_instead('numpy.transpose')
 def transpose(__array: IntoArray, __axes: Optional[Sequence[int]] = None) -> Array:
     '''Permute the axes of an array.
 
     Parameters
     ----------
     array : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axes : sequence of :class:`int`
@@ -2420,15 +2561,15 @@
     -------
     :class:`Array`
     '''
 
     return insertaxis(__array, axis, 1)
 
 
-@implements(numpy.repeat)
+@_use_instead('numpy.repeat')
 def repeat(__array: IntoArray, __n: IntoArray, axis: int) -> Array:
     '''Repeat the given axis of an array `n` times.
 
     Parameters
     ----------
     array : :class:`Array` or something that can be :meth:`~Array.cast` into one
     n : :class:`int` or :class:`Array`
@@ -2443,15 +2584,15 @@
 
     array = Array.cast(__array)
     if array.shape[axis] != 1:
         raise NotImplementedError('only axes with length 1 can be repeated')
     return insertaxis(get(array, axis, 0), axis, __n)
 
 
-@implements(numpy.swapaxes)
+@_use_instead('numpy.swapaxes')
 def swapaxes(__array: IntoArray, __axis1: int, __axis2: int) -> Array:
     '''Swap two axes of an array.
 
     Parameters
     ----------
     array : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis1, axis2 : :class:`int`
@@ -2466,14 +2607,15 @@
     axis1 = __axis1
     axis2 = __axis2
     trans = list(range(array.ndim))
     trans[axis1], trans[axis2] = trans[axis2], trans[axis1]
     return transpose(array, trans)
 
 
+@_use_instead('numpy.ravel or numpy.reshape')
 def ravel(__array: IntoArray, axis: int) -> Array:
     '''Ravel two consecutive axes of an array.
 
     Parameters
     ----------
     array : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`
@@ -2523,15 +2665,15 @@
                          _WithoutPoints(Array.cast(shape[0])),
                          _WithoutPoints(Array.cast(shape[1])),
                          shape=(*transposed.shape[:-1], *shape),
                          dtype=transposed.dtype)
     return _Transpose.from_end(unraveled, axis, axis+1)
 
 
-@implements(numpy.take)
+@_use_instead('numpy.take')
 def take(__array: IntoArray, __indices: IntoArray, axis: int) -> Array:
     '''Take elements from an array along an axis.
 
     Parameters
     ----------
     array : :class:`Array` or something that can be :meth:`~Array.cast` into one
     indices : :class:`Array` with dtype :class:`int` or :class:`bool` or something that can be :meth:`~Array.cast` into one
@@ -2584,18 +2726,15 @@
 
     See Also
     --------
     :func:`take` : Take elements from an array along an axis.
     :func:`kronecker` : The complement operation.
     '''
 
-    array = Array.cast(__array)
-    axis = __axis
-    index = Array.cast(__index, dtype=int, ndim=0)
-    return take(array, index, axis)
+    return numpy.take(Array.cast(__array), Array.cast(__index, dtype=int, ndim=0), __axis)
 
 
 def _range(__length: int, __offset: int) -> Array:
     length = Array.cast(__length, dtype=int, ndim=0)
     offset = Array.cast(__offset, dtype=int, ndim=0)
     return _Wrapper(lambda l, o: evaluable.Range(l) + o, _WithoutPoints(length), _WithoutPoints(offset), shape=(__length,), dtype=int)
 
@@ -2611,17 +2750,18 @@
         if start == 0 and stop == n:
             return array
         index = _range(stop-start, start)
     elif isinstance(n, numbers.Integral):
         index = Array.cast(numpy.arange(*s.indices(int(n))))
     else:
         raise Exception('a non-unit slice requires a constant-length axis')
-    return take(array, index, axis)
+    return numpy.take(array, index, axis)
 
 
+@nutils_dispatch
 def scatter(__array: IntoArray, length: int, indices: IntoArray) -> Array:
     '''Distribute the last dimensions of an array over a new axis.
 
     Parameters
     ----------
     array : :class:`Array` or something that can be :meth:`~Array.cast` into one
     length : :class:`int`
@@ -2650,14 +2790,15 @@
                     array,
                     _WithoutPoints(indices),
                     _WithoutPoints(Array.cast(length)),
                     shape=array.shape[:array.ndim-indices.ndim] + (length,),
                     dtype=array.dtype)
 
 
+@nutils_dispatch
 def kronecker(__array: IntoArray, axis: int, length: int, pos: IntoArray) -> Array:
     '''Position an element in an axis of given length.
 
     Parameters
     ----------
     array : :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`
@@ -2676,15 +2817,15 @@
     --------
     :func:`get` : The complement operation.
     '''
 
     return _Transpose.from_end(scatter(__array, length, pos), axis)
 
 
-@implements(numpy.concatenate)
+@_use_instead('numpy.concatenate')
 def concatenate(__arrays: Sequence[IntoArray], axis: int = 0) -> Array:
     '''Join arrays along an existing axis.
 
     Parameters
     ----------
     arrays : sequence of :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`
@@ -2698,15 +2839,15 @@
     --------
     :func:`stack` : Join arrays along an new axis.
     '''
 
     return _Concatenate(__arrays, axis)
 
 
-@implements(numpy.stack)
+@_use_instead('numpy.stack')
 def stack(__arrays: Sequence[IntoArray], axis: int = 0) -> Array:
     '''Join arrays along a new axis.
 
     Parameters
     ----------
     arrays : sequence of :class:`Array` or something that can be :meth:`~Array.cast` into one
     axis : :class:`int`
@@ -2721,30 +2862,71 @@
     :func:`stack` : Join arrays along an new axis.
     '''
 
     aligned = broadcast_arrays(*typecast_arrays(*__arrays))
     return util.sum(kronecker(array, axis, len(aligned), i) for i, array in enumerate(aligned))
 
 
-def replace_arguments(__array: IntoArray, __arguments: Mapping[str, IntoArray]) -> Array:
+@nutils_dispatch
+def replace_arguments(__array: IntoArray, __arguments: Mapping[str, Union[IntoArray, str]]) -> Array:
     '''Replace arguments with :class:`Array` objects.
 
     Parameters
     ----------
     array : :class:`Array` or something that can be :meth:`~Array.cast` into one
     arguments : :class:`dict` of :class:`str` and :class:`Array`
         The argument name to array mapping.
 
     Returns
     -------
     :class:`Array`
     '''
 
-    array, scale = Array.cast_withscale(__array)
-    return _Replace(array, {k: Array.cast(v) for k, v in __arguments.items()}) * scale
+    return _Replace(Array.cast(__array), __arguments)
+
+
+@nutils_dispatch
+def linearize(__array: IntoArray, __arguments: Union[str, Dict[str, str], Iterable[str], Iterable[Tuple[str, str]]]):
+    '''Linearize functional.
+
+    Similar to :func:`derivative`, linearize takes the derivative of an array
+    to one or more arguments, but with the derivative directions represented by
+    arguments rather than array axes. The result is by definition linear in the
+    new arguments.
+
+    Parameters
+    ----------
+    array : :class:`Array` or something that can be :meth:`~Array.cast` into one
+    arguments : :class:`str`, :class:`dict` or iterable of strings
+
+    Example
+    -------
+
+    The following example demonstrates the use of linearize with four
+    equivalent argument specifications:
+
+    >>> u, v, p, q = [Argument(s, (), float) for s in 'uvpq']
+    >>> f = u**2 + p
+    >>> lin1 = linearize(f, 'u:v,p:q')
+    >>> lin2 = linearize(f, dict(u='v', p='q'))
+    >>> lin3 = linearize(f, ('u:v', 'p:q'))
+    >>> lin4 = linearize(f, (('u', 'v'), ('p', 'q')))
+    >>> # lin1 = lin2 == lin3 == lin4 == 2 * u * v + q
+    '''
+
+    array = Array.cast(__array)
+    args = __arguments.split(',') if isinstance(__arguments, str) \
+      else __arguments.items() if isinstance(__arguments, dict) \
+      else __arguments
+    parts = []
+    for kv in args:
+        k, v = kv.split(':', 1) if isinstance(kv, str) else kv
+        f = derivative(array, k)
+        parts.append(numpy.sum(f * Argument(v, f.shape[array.ndim:]), tuple(range(array.ndim, f.ndim))))
+    return util.sum(parts)
 
 
 def broadcast_arrays(*arrays: IntoArray) -> Tuple[Array, ...]:
     '''Broadcast the given arrays.
 
     Parameters
     ----------
@@ -2754,15 +2936,15 @@
     -------
     :class:`tuple` of :class:`Array`
         The broadcasted arrays.
     '''
 
     arrays_ = tuple(map(Array.cast, arrays))
     shape = broadcast_shapes(*(arg.shape for arg in arrays_))
-    return tuple(broadcast_to(arg, shape) for arg in arrays_)
+    return tuple(numpy.broadcast_to(arg, shape) for arg in arrays_)
 
 
 def typecast_arrays(*arrays: IntoArray, min_dtype: DType = bool):
     '''Cast the given arrays to the same dtype.
 
     Parameters
     ----------
@@ -2802,15 +2984,15 @@
             lengths.discard(1)
         if len(lengths) != 1:
             raise ValueError('cannot broadcast shapes {} because at least one or more axes have multiple lengths (excluding singletons)'.format(', '.join(map(str, shapes))))
         broadcasted.append(next(iter(lengths)))
     return tuple(broadcasted)
 
 
-@implements(numpy.broadcast_to)
+@_use_instead('numpy.broadcast_to')
 def broadcast_to(array: IntoArray, shape: Shape) -> Array:
     '''Broadcast an array to a new shape.
 
     Parameters
     ----------
     array : :class:`Array` or similar
         The array to broadcast.
@@ -2829,83 +3011,81 @@
         raise ValueError('cannot broadcast array with shape {} to {} because the dimension decreases'.format(orig_shape, shape))
     nnew = len(shape) - broadcasted.ndim
     broadcasted = _prepend_axes(broadcasted, shape[:nnew])
     for axis, (actual, desired) in enumerate(zip(broadcasted.shape[nnew:], shape[nnew:])):
         if actual == desired:
             continue
         elif actual == 1:
-            broadcasted = repeat(broadcasted, desired, axis + nnew)
+            broadcasted = numpy.repeat(broadcasted, desired, axis + nnew)
         else:
             raise ValueError('cannot broadcast array with shape {} to {} because input axis {} is neither singleton nor has the desired length'.format(orig_shape, shape, axis))
     return broadcasted
 
 # DERIVATIVES
 
 
+@nutils_dispatch
 def derivative(__arg: IntoArray, __var: Union[str, 'Argument']) -> Array:
     '''Differentiate `arg` to `var`.
 
     Parameters
     ----------
     arg, var : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
     Returns
     -------
     :class:`Array`
     '''
 
-    arg, argscale = Array.cast_withscale(__arg)
+    arg = Array.cast(__arg)
     if isinstance(__var, str):
         if __var not in arg.arguments:
             raise ValueError('no such argument: {}'.format(__var))
         shape, dtype = arg.arguments[__var]
         __var = Argument(__var, shape, dtype=dtype)
     elif not isinstance(__var, Argument):
         raise ValueError('Expected an instance of `Argument` as second argument of `derivative` but got a `{}.{}`.'.format(type(__var).__module__, type(__var).__qualname__))
     if __var.name in arg.arguments:
         shape, dtype = arg.arguments[__var.name]
         if __var.shape != shape:
             raise ValueError('Argument {!r} has shape {} in the function, but the derivative to {!r} with shape {} was requested.'.format(__var.name, shape, __var.name, __var.shape))
         if __var.dtype != dtype:
             raise ValueError('Argument {!r} has dtype {} in the function, but the derivative to {!r} with dtype {} was requested.'.format(__var.name, dtype.__name__ if dtype in _dtypes else dtype, __var.name, __var.dtype.__name__ if __var.dtype in _dtypes else __var.dtype))
-    return _Derivative(arg, __var) * argscale
+    return _Derivative(arg, __var)
 
 
+@nutils_dispatch
 def grad(__arg: IntoArray, __geom: IntoArray, ndims: int = 0) -> Array:
     '''Return the gradient of the argument to the given geometry.
 
     Parameters
     ----------
     arg, geom : :class:`Array` or something that can be :meth:`~Array.cast` into one
     ndims : :class:`int`
         The dimension of the local coordinate system.
 
     Returns
     -------
     :class:`Array`
     '''
 
-    arg, argscale = Array.cast_withscale(__arg)
-    geom, geomscale = Array.cast_withscale(__geom)
+    arg = Array.cast(__arg)
+    geom = Array.cast(__geom)
     if geom.dtype != float:
         raise ValueError('The geometry must be real-valued.')
-    if geom.ndim == 0:
-        ret = grad(arg, _append_axes(geom, (1,)))[..., 0]
-    elif geom.ndim > 1:
-        sh = geom.shape[-2:]
-        ret = unravel(grad(arg, ravel(geom, geom.ndim-2)), arg.ndim+geom.ndim-2, sh)
-    elif ndims == 0 or ndims == geom.shape[0]:
-        ret = _Gradient(arg, geom)
-    elif ndims == -1 or ndims == geom.shape[0] - 1:
-        ret = _SurfaceGradient(arg, geom)
+    if ndims == 0 or ndims == geom.size:
+        op = _Gradient
+    elif ndims == -1 or ndims == geom.size - 1:
+        op = _SurfaceGradient
     else:
         raise NotImplementedError
-    return ret * (argscale / geomscale)
+    return numpy.reshape(op(arg, numpy.ravel(geom)), arg.shape + geom.shape)
 
 
+@nutils_dispatch
 def curl(__arg: IntoArray, __geom: IntoArray) -> Array:
     '''Return the curl of the argument w.r.t. the given geometry.
 
     Parameters
     ----------
     arg, geom : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -2923,14 +3103,15 @@
     if not arg.ndim:
         raise ValueError('Expected a function with at least 1 axis but got 0.')
     if arg.shape[-1] != 3:
         raise ValueError('Expected a function with a trailing axis of length 3 but got {}.'.format(arg.shape[-1]))
     return (levicivita(3).T * _append_axes(grad(arg, geom), (3,))).sum((-3, -2))
 
 
+@nutils_dispatch
 def normal(__geom: IntoArray, refgeom: Optional[Array] = None) -> Array:
     '''Return the normal of the geometry.
 
     Parameters
     ----------
     geom : :class:`Array` or something that can be :meth:`~Array.cast` into one
     refgeom : :class:`Array`, optional`
@@ -2940,30 +3121,26 @@
         dimension of the geometry.
 
     Returns
     -------
     :class:`Array`
     '''
 
-    geom, geomscale_ = Array.cast_withscale(__geom)
+    geom = Array.cast(__geom)
     if geom.dtype != float:
         raise ValueError('The geometry must be real-valued.')
-    if geom.ndim == 0:
-        return normal(insertaxis(geom, 0, 1), refgeom)[..., 0]
-    elif geom.ndim > 1:
-        sh = geom.shape[-2:]
-        return unravel(normal(ravel(geom, geom.ndim-2), refgeom), geom.ndim-2, sh)
-    elif refgeom is None:
-        return _Normal(geom)
-    elif refgeom.dtype != float:
-        raise ValueError('The reference geometry must be real-valued.')
-    elif refgeom.shape != (geom.shape[0]-1,):
-        raise ValueError('The reference geometry must have shape ({},) but got {}.'.format(geom.shape[0]-1, refgeom.shape))
+    if refgeom is None:
+        normal = _Normal(numpy.ravel(geom))
     else:
-        return _ExteriorNormal(grad(geom, refgeom))
+        if refgeom.dtype != float:
+            raise ValueError('The reference geometry must be real-valued.')
+        if refgeom.size != geom.size-1:
+            raise ValueError(f'The reference geometry must have size {geom.size-1}, but got {refgeom.size}.')
+        normal = _ExteriorNormal(grad(numpy.ravel(geom), numpy.ravel(refgeom)))
+    return numpy.reshape(normal, geom.shape)
 
 
 def dotnorm(__arg: IntoArray, __geom: IntoArray, axis: int = -1) -> Array:
     '''Return the inner product of an array with the normal of the given geometry.
 
     Parameters
     ----------
@@ -2976,66 +3153,52 @@
         Defaults to the last axis.
 
     Returns
     -------
     :class:`Array`
     '''
 
-    arg = _Transpose.to_end(Array.cast(__arg), axis)
-    geom = Array.cast(__geom, ndim=1)
-    assert geom.shape[0] == arg.shape[-1]
-    return dot(arg, _prepend_axes(normal(geom), arg.shape[:-1]), -1)
+    return _Transpose.to_end(Array.cast(__arg), axis) @ normal(__geom)
 
 
 def tangent(__geom: IntoArray, __vec: IntoArray) -> Array:
     '''Return the tangent.
 
     Parameters
     ----------
     geom, vec : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
     Returns
     -------
     :class:`Array`
     '''
 
-    geom = Array.cast(__geom)
+    norm = normal(__geom)
     vec = Array.cast(__vec)
-    return subtract(vec, multiply(dot(vec, normal(geom), -1)[..., None], normal(geom)))
+    return vec - (vec @ norm)[..., None] * norm
 
 
+@nutils_dispatch
 def jacobian(__geom: IntoArray, __ndims: Optional[int] = None) -> Array:
     '''Return the absolute value of the determinant of the Jacobian matrix of the given geometry.
 
     Parameters
     ----------
     geom : :class:`Array` or something that can be :meth:`~Array.cast` into one
         The geometry.
 
     Returns
     -------
     :class:`Array`
     '''
 
-    geom, geomscale = Array.cast_withscale(__geom)
+    geom = Array.cast(__geom)
     if geom.dtype != float:
         raise ValueError('The geometry must be real-valued.')
-    if __ndims is not None:
-        scale = geomscale**__ndims
-    elif _is_unit_scalar(geomscale):
-        scale = 1.
-    else:
-        raise ValueError('scaled arrays require an explicit dimension')
-    if geom.ndim == 0:
-        J = jacobian(insertaxis(geom, 0, 1), __ndims)
-    elif geom.ndim > 1:
-        J = jacobian(ravel(geom, geom.ndim-2), __ndims)
-    else:
-        J = _Jacobian(geom, __ndims)
-    return J * scale
+    return _Jacobian(numpy.ravel(geom), __ndims)
 
 
 def J(__geom: IntoArray, __ndims: Optional[int] = None) -> Array:
     '''Return the absolute value of the determinant of the Jacobian matrix of the given geometry.
 
     Alias of :func:`jacobian`.
     '''
@@ -3047,14 +3210,15 @@
     return derivative(arg, var) if isinstance(var, Argument) else grad(arg, var)
 
 
 def d(__arg: IntoArray, *vars: IntoArray) -> Array:
     return functools.reduce(_d1, vars, Array.cast(__arg))
 
 
+@nutils_dispatch
 def surfgrad(__arg: IntoArray, geom: IntoArray) -> Array:
     '''Return the surface gradient of the argument to the given geometry.
 
     Parameters
     ----------
     arg, geom : :class:`Array` or something that can be :meth:`~Array.cast` into one
 
@@ -3062,14 +3226,15 @@
     -------
     :class:`Array`
     '''
 
     return grad(__arg, geom, -1)
 
 
+@nutils_dispatch
 def curvature(__geom: IntoArray, ndims: int = -1) -> Array:
     '''Return the curvature of the given geometry.
 
     Parameters
     ----------
     geom : :class:`Array` or something that can be :meth:`~Array.cast` into one
     ndims : :class:`int`
@@ -3079,31 +3244,33 @@
     :class:`Array`
     '''
 
     geom = Array.cast(__geom)
     return geom.normal().div(geom, ndims=ndims)
 
 
+@nutils_dispatch
 def div(__arg: IntoArray, __geom: IntoArray, ndims: int = 0) -> Array:
     '''Return the divergence of ``arg`` w.r.t. the given geometry.
 
     Parameters
     ----------
     arg, geom : :class:`Array` or something that can be :meth:`~Array.cast` into one
     ndims : :class:`int`
 
     Returns
     -------
     :class:`Array`
     '''
 
     geom = Array.cast(__geom, ndim=1)
-    return trace(grad(__arg, geom, ndims))
+    return numpy.trace(grad(__arg, geom, ndims), axis1=-2, axis2=-1)
 
 
+@nutils_dispatch
 def laplace(__arg: IntoArray, __geom: IntoArray, ndims: int = 0) -> Array:
     '''Return the Laplacian of ``arg`` w.r.t. the given geometry.
 
     Parameters
     ----------
     arg, geom : :class:`Array` or something that can be :meth:`~Array.cast` into one
     ndims : :class:`int`
@@ -3129,15 +3296,15 @@
     Returns
     -------
     :class:`Array`
     '''
 
     arg = Array.cast(__arg)
     geom = Array.cast(__geom)
-    return multiply(.5, add_T(arg.grad(geom, ndims)))
+    return .5 * add_T(arg.grad(geom, ndims))
 
 
 def ngrad(__arg: IntoArray, __geom: IntoArray, ndims: int = 0) -> Array:
     '''Return the inner product of the gradient of ``arg`` with the normal of the given geometry.
 
     Parameters
     ----------
@@ -3170,32 +3337,85 @@
     arg = Array.cast(__arg)
     geom = Array.cast(__geom)
     return dotnorm(symgrad(arg, geom, ndims), geom)
 
 # MISC
 
 
+def _convert(data: numpy.ndarray, inplace: bool = True) -> Union[numpy.ndarray, matrix.Matrix]:
+    '''Convert a two-dimensional sparse object to an appropriate object.
+
+    The return type is determined based on dimension: a zero-dimensional object
+    becomes a scalar, a one-dimensional object a (dense) Numpy vector, a
+    two-dimensional object a Nutils matrix, and any higher dimensional object a
+    deduplicated and pruned sparse object.
+    '''
+
+    ndim = sparse.ndim(data)
+    return sparse.toarray(data) if ndim < 2 \
+        else matrix.fromsparse(data, inplace=inplace) if ndim == 2 \
+        else sparse.prune(sparse.dedup(data, inplace=inplace), inplace=True)
+
+
 @util.single_or_multiple
-def eval(funcs: evaluable.AsEvaluableArray, **arguments: Mapping[str, numpy.ndarray]) -> Tuple[numpy.ndarray, ...]:
+@util.positional_only
+def eval(funcs: evaluable.AsEvaluableArray, arguments: Mapping[str, numpy.ndarray] = ...) -> Tuple[numpy.ndarray, ...]:
     '''Evaluate one or several Array objects.
 
     Args
     ----
     funcs : :class:`tuple` of Array objects
         Arrays to be evaluated.
     arguments : :class:`dict` (default: None)
         Optional arguments for function evaluation.
 
     Returns
     -------
     results : :class:`tuple` of arrays
     '''
 
-    funcs, funcscales = zip(*map(Array.cast_withscale, funcs))
-    return tuple(sparse.toarray(data) * scale for data, scale in zip(evaluable.eval_sparse(funcs, **arguments), funcscales))
+    return evaluate(*funcs, arguments=arguments)
+
+
+@nutils_dispatch
+def evaluate(*arrays, _post=sparse.toarray, arguments={}):
+    if len(arguments) == 1 and 'arguments' in arguments and isinstance(arguments['arguments'], dict):
+        arguments = arguments['arguments']
+    sparse_arrays = evaluable.eval_sparse(map(Array.cast, arrays), **arguments)
+    return tuple(map(_post, sparse_arrays))
+
+
+@nutils_dispatch
+def integral(func: IntoArray, sample) -> Array:
+    '''Integrate a function over a sample.
+
+    Args
+    ----
+    func : :class:`nutils.function.Array`
+        Integrand.
+    sample
+        The integration sample.
+    '''
+
+    return sample._integral(Array.cast(func))
+
+
+@nutils_dispatch
+def sample(func: IntoArray, sample) -> Array:
+    '''Evaluate a function in all sample points.
+
+    Args
+    ----
+    func : :class:`nutils.function.Array`
+        Integrand.
+    sample
+        The integration sample.
+    '''
+
+    return sample._sample(Array.cast(func))
 
 
 def isarray(__arg: Any) -> bool:
     'Test if the argument is an instance of :class:`Array`.'
     return isinstance(__arg, Array)
 
 
@@ -3218,15 +3438,15 @@
     warnings.deprecation('function.Elemwise is deprecated; use function.get instead')
     return get(numpy.asarray(__data), 0, __index)
 
 
 def piecewise(level: IntoArray, intervals: Sequence[IntoArray], *funcs: IntoArray) -> Array:
     'piecewise'
     level = Array.cast(level)
-    return util.sum(greater(level, interval).astype(int) for interval in intervals).choose(funcs)
+    return util.sum((level > interval).astype(int) for interval in intervals).choose(funcs)
 
 
 def partition(f: IntoArray, *levels: float) -> Sequence[Array]:
     '''Create a partition of unity for a scalar function f.
 
     When ``n`` levels are specified, ``n+1`` indicator functions are formed that
     evaluate to one if and only if the following condition holds::
@@ -3261,17 +3481,16 @@
     Returns
     -------
     :class:`list` of scalar :class:`Array`\\s
         The indicator functions.
     '''
 
     f = Array.cast(f)
-    signs = [sign(f - level) for level in levels]
-    steps = map(subtract, signs[:-1], signs[1:])
-    return [.5 - .5 * signs[0]] + [.5 * step for step in steps] + [.5 + .5 * signs[-1]]
+    signs = [numpy.sign(f - level) for level in levels]
+    return [.5 - .5 * signs[0]] + [.5 * (a - b) for a, b in zip(signs[:-1], signs[1:])] + [.5 + .5 * signs[-1]]
 
 
 def heaviside(f: IntoArray):
     '''Create a heaviside step-function based on a scalar function f.
 
     .. math:: H(f) &= 0     && f < 0
 
@@ -3292,41 +3511,38 @@
     See Also
     --------
 
     :func:`partition`: generalized version of :func:`heaviside`
     :func:`sign`: like :func:`heaviside` but with different levels
     '''
 
-    return sign(f) * .5 + .5
-
-
-def _eval_choose(_index: evaluable.Array, *_choices: evaluable.Array) -> evaluable.Array:
-    return evaluable.Choose(_index, _choices)
+    return Array.cast(numpy.sign(f) * .5 + .5)
 
 
+@_use_instead('numpy.choose')
 def choose(__index: IntoArray, __choices: Sequence[IntoArray]) -> Array:
     'Function equivalent of :func:`numpy.choose`.'
     index = Array.cast(__index)
     if index.ndim != 0:
         raise ValueError
     choices = broadcast_arrays(*typecast_arrays(*__choices))
     shape = choices[0].shape
     dtype = choices[0].dtype
     index = _append_axes(index, shape)
     spaces = functools.reduce(operator.or_, (arg.spaces for arg in choices), index.spaces)
-    return _Wrapper(_eval_choose, index, *choices, shape=shape, dtype=dtype)
+    return _Wrapper(evaluable.Choose, index, *choices, shape=shape, dtype=dtype)
 
 
 def chain(_funcs: Sequence[IntoArray]) -> Sequence[Array]:
     'chain'
 
     funcs = tuple(map(Array.cast, _funcs))
     shapes = [func.shape[0] for func in funcs]
-    return [concatenate([func if i == j else zeros((sh,) + func.shape[1:])
-                         for j, sh in enumerate(shapes)], axis=0)
+    return [numpy.concatenate([func if i == j else zeros((sh,) + func.shape[1:])
+        for j, sh in enumerate(shapes)], axis=0)
             for i, func in enumerate(funcs)]
 
 
 def vectorize(args: Sequence[IntoArray]) -> Array:
     '''
     Combine scalar-valued bases into a vector-valued basis.
 
@@ -3335,15 +3551,15 @@
     args : iterable of 1-dimensional :class:`nutils.function.Array` objects
 
     Returns
     -------
     :class:`Array`
     '''
 
-    return concatenate([kronecker(arg, axis=-1, length=len(args), pos=iarg) for iarg, arg in enumerate(args)])
+    return numpy.concatenate([kronecker(arg, axis=-1, length=len(args), pos=iarg) for iarg, arg in enumerate(args)])
 
 
 def simplified(__arg: IntoArray) -> Array:
     warnings.deprecation('`nutils.function.simplified` is deprecated. This function returns the argument unmodified and can safely be omitted.')
     return Array.cast(__arg)
 
 
@@ -3351,32 +3567,30 @@
     warnings.deprecation('`nutils.function.iszero` is deprecated. Use `evaluable.iszero` on the lowered function instead.')
     return False
 
 
 def add_T(__arg: IntoArray, axes: Tuple[int, int] = (-2, -1)) -> Array:
     'add transposed'
     arg = Array.cast(__arg)
-    return swapaxes(arg, *axes) + arg
+    return numpy.swapaxes(arg, *axes) + arg
 
 
 def trignormal(_angle: IntoArray) -> Array:
-    angle = Array.cast(_angle)
-    return stack([cos(angle), sin(angle)], axis=-1)
+    return Array.cast(numpy.stack([numpy.cos(_angle), numpy.sin(_angle)], axis=-1))
 
 
 def trigtangent(_angle: IntoArray) -> Array:
-    angle = Array.cast(_angle)
-    return stack([-sin(angle), cos(angle)], axis=-1)
+    return Array.cast(numpy.stack([-numpy.sin(_angle), numpy.cos(_angle)], axis=-1))
 
 
 def rotmat(__arg: IntoArray) -> Array:
-    arg = Array.cast(__arg)
-    return stack([trignormal(arg), trigtangent(arg)], 0)
+    return Array.cast(numpy.stack([trignormal(__arg), trigtangent(__arg)], 0))
 
 
+@nutils_dispatch
 def dotarg(__argname: str, *arrays: IntoArray, shape: Tuple[int, ...] = (), dtype: DType = float) -> Array:
     '''Return the inner product of the first axes of the given arrays with an argument with the given name.
 
     An argument with shape ``(arrays[0].shape[0], ..., arrays[-1].shape[0]) +
     shape`` will be created. Repeatedly the inner product of the result, starting
     with the argument, with every array from ``arrays`` is taken, where all but
     the first axis are treated as an outer product.
@@ -3466,25 +3680,25 @@
         self.coords = coords
         arguments = _join_arguments((index.arguments, coords.arguments))
         super().__init__((ndofs,), float, spaces=index.spaces | coords.spaces, arguments=arguments)
 
         _index = evaluable.Argument('_index', shape=(), dtype=int)
         self._arg_dofs, self._arg_coeffs = [f.optimized_for_numpy for f in self.f_dofs_coeffs(_index)]
         assert self._arg_dofs.ndim == 1
-        assert self._arg_coeffs.ndim == 1 + coords.shape[0]
-        assert evaluable.equalindex(self._arg_dofs.shape[0], self._arg_coeffs.shape[0])
+        assert self._arg_coeffs.ndim == 2
+        assert evaluable._equals_simplified(self._arg_dofs.shape[0], self._arg_coeffs.shape[0])
         self._arg_ndofs = evaluable.asarray(self._arg_dofs.shape[0])
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        index = _WithoutPoints(self.index).lower(points_shape, transform_chains, coordinates)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        index = _WithoutPoints(self.index).lower(args)
         dofs, coeffs = self.f_dofs_coeffs(index)
-        coords = self.coords.lower(points_shape, transform_chains, coordinates)
-        return evaluable.Inflate(evaluable.Polyval(coeffs, coords), dofs, self.ndofs)
+        coords = self.coords.lower(args)
+        return evaluable.Inflate(evaluable.Polyval(coeffs, coords), dofs, evaluable.constant(self.ndofs))
 
-    @util.cached_property
+    @cached_property
     def _computed_support(self) -> Tuple[numpy.ndarray, ...]:
         support = [[] for i in range(self.ndofs)]  # type: List[List[int]]
         for ielem in range(self.nelems):
             for dof in numpy.unique(self.get_dofs(ielem)):
                 support[dof].append(ielem)
         return tuple(types.frozenarray(ielems, dtype=int) for ielems in support)
 
@@ -3594,15 +3808,15 @@
         The element local coordinates.
     '''
 
     def __init__(self, coefficients: Sequence[numpy.ndarray], dofs: Sequence[numpy.ndarray], ndofs: int, index: Array, coords: Array) -> None:
         self._coeffs = tuple(types.arraydata(numpy.asarray(c, dtype=float)) for c in coefficients)
         self._dofs = tuple(map(types.arraydata, dofs))
         assert len(self._coeffs) == len(self._dofs)
-        assert all(c.ndim == 1+coords.shape[0] for c in self._coeffs)
+        assert all(c.ndim == 2 for c in self._coeffs)
         assert all(c.shape[0] == d.shape[0] for c, d in zip(self._coeffs, self._dofs))
         super().__init__(ndofs, len(coefficients), index, coords)
 
     def f_dofs_coeffs(self, index: evaluable.Array) -> Tuple[evaluable.Array, evaluable.Array]:
         dofs = evaluable.Elemwise(self._dofs, index, dtype=int)
         coeffs = evaluable.Elemwise(self._coeffs, index, dtype=float)
         return dofs, coeffs
@@ -3620,26 +3834,26 @@
         The element index.
     coords : :class:`Array`
         The element local coordinates.
     '''
 
     def __init__(self, coefficients: Sequence[numpy.ndarray], index: Array, coords: Array) -> None:
         self._coeffs = tuple(types.arraydata(c) for c in coefficients)
-        assert all(c.ndim == 1+coords.shape[0] for c in self._coeffs)
+        assert all(c.ndim == 2 for c in self._coeffs)
         self._offsets = numpy.cumsum([0] + [c.shape[0] for c in self._coeffs])
         super().__init__(self._offsets[-1], len(coefficients), index, coords)
 
     @_int_or_vec_dof
     def get_support(self, dof: Union[int, numpy.ndarray]) -> numpy.ndarray:
         ielem = numpy.searchsorted(self._offsets[:-1], numeric.normdim(self.ndofs, dof), side='right')-1
         return numpy.array([ielem], dtype=int)
 
     def f_dofs_coeffs(self, index: evaluable.Array) -> Tuple[evaluable.Array, evaluable.Array]:
         coeffs = evaluable.Elemwise(self._coeffs, index, dtype=float)
-        dofs = evaluable.Range(coeffs.shape[0]) + evaluable.get(self._offsets, 0, index)
+        dofs = evaluable.Range(coeffs.shape[0]) + evaluable.get(evaluable.constant(self._offsets), 0, index)
         return dofs, coeffs
 
 
 class LegendreBasis(Basis):
     '''A discontinuous Legendre basis.
 
     Parameters
@@ -3663,28 +3877,27 @@
     @_int_or_vec_dof
     def get_support(self, dof: Union[int, numpy.ndarray]) -> numpy.ndarray:
         if isinstance(dof, int):
             dof = numpy.array([dof])
         return numpy.unique(dof // (self._degree+1))
 
     def f_dofs_coeffs(self, index: evaluable.Array) -> Tuple[evaluable.Array, evaluable.Array]:
-        dofs = evaluable.Range(self._degree+1) + index * (self._degree+1)
+        dofs = evaluable.Range(evaluable.constant(self._degree+1)) + index * (self._degree+1)
         coeffs = numpy.zeros((self._degree+1,)*2, dtype=int)
         for n in range(self._degree+1):
             for k in range(n+1):
-                coeffs[n, k] = (-1 if (n+k) % 2 else 1) * numeric.binom(n, k) * numeric.binom(n+k, k)
+                coeffs[n, self._degree - k] = (-1 if (n+k) % 2 else 1) * numeric.binom(n, k) * numeric.binom(n+k, k)
         return dofs, evaluable.astype(evaluable.asarray(coeffs), float)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        index = _WithoutPoints(self.index).lower(points_shape, transform_chains, coordinates)
-        coords = self.coords.lower(points_shape, transform_chains, coordinates)
-        assert evaluable.equalindex(coords.shape[-1], 1)
-        leg = evaluable.Legendre(evaluable.get(coords, coords.ndim-1, 0) * 2 - 1, self._degree)
-        dofs = evaluable.Range(self._degree+1) + index * (self._degree+1)
-        return evaluable.Inflate(leg, dofs, self.ndofs)
+    def lower(self, args: LowerArgs) -> evaluable.Array:
+        index = _WithoutPoints(self.index).lower(args)
+        coords = self.coords.lower(args)
+        leg = evaluable.Legendre(evaluable.get(coords, coords.ndim-1, evaluable.constant(0)) * 2 - 1, self._degree)
+        dofs = evaluable.Range(evaluable.constant(self._degree+1)) + index * (self._degree+1)
+        return evaluable.Inflate(leg, dofs, evaluable.constant(self.ndofs))
 
 
 class MaskedBasis(Basis):
     '''An order preserving subset of another :class:`Basis`.
 
     Parameters
     ----------
@@ -3701,26 +3914,26 @@
             raise ValueError('`indices` should have one dimension but got {}'.format(indices.ndim))
         if len(indices) and not numpy.all(numpy.greater(numpy.diff(indices), 0)):
             raise ValueError('`indices` should be strictly monotonic increasing')
         if len(indices) and (indices[0] < 0 or indices[-1] >= len(parent)):
             raise ValueError('`indices` out of range \x5b0,{}\x29'.format(len(parent)))
         self._parent = parent
         self._indices = indices
-        self._renumber = types.frozenarray(numeric.invmap(indices, length=parent.ndofs, missing=len(indices)), copy=False)
+        self._renumber = evaluable.constant(numeric.invmap(indices, length=parent.ndofs, missing=len(indices)))
         super().__init__(len(indices), parent.nelems, parent.index, parent.coords)
 
     def get_support(self, dof: Union[int, numpy.ndarray]) -> numpy.ndarray:
         if numeric.isintarray(dof) and dof.ndim == 1 and numpy.any(numpy.less(dof, 0)):
             raise IndexError('dof out of bounds')
         return self._parent.get_support(self._indices[dof])
 
     def f_dofs_coeffs(self, index: evaluable.Array) -> Tuple[evaluable.Array, evaluable.Array]:
         p_dofs, p_coeffs = self._parent.f_dofs_coeffs(index)
         renumber = evaluable.Take(self._renumber, p_dofs)
-        selection = evaluable.Find(evaluable.Less(renumber, evaluable.InsertAxis(self.ndofs, p_dofs.shape[0])))
+        selection = evaluable.Find(evaluable.Less(renumber, evaluable.InsertAxis(evaluable.constant(self.ndofs), p_dofs.shape[0])))
         dofs = evaluable.take(renumber, selection, axis=0)
         coeffs = evaluable.take(p_coeffs, selection, axis=0)
         return dofs, coeffs
 
 
 class StructuredBasis(Basis):
     '''A basis for class:`nutils.transformseq.StructuredTransforms`.
@@ -3776,23 +3989,27 @@
     def f_dofs_coeffs(self, index: evaluable.Array) -> Tuple[evaluable.Array, evaluable.Array]:
         indices = []
         for n in reversed(self._transforms_shape[1:]):
             index, ielem = evaluable.divmod(index, n)
             indices.append(ielem)
         indices.append(index)
         indices.reverse()
-        ranges = [evaluable.Range(evaluable.get(lengths_i, 0, index_i)) + evaluable.get(offsets_i, 0, index_i)
+        ranges = [evaluable.Range(evaluable.get(evaluable.constant(lengths_i), 0, index_i)) + evaluable.get(evaluable.constant(offsets_i), 0, index_i)
                   for lengths_i, offsets_i, index_i in zip(self._ndofs, self._start_dofs, indices)]
         ndofs = self._dofs_shape[0]
         dofs = ranges[0] % ndofs
         for range_i, ndofs_i in zip(ranges[1:], self._dofs_shape[1:]):
-            dofs = evaluable.Ravel(evaluable.RavelIndex(dofs, range_i % ndofs_i, ndofs, ndofs_i))
+            dofs = evaluable.Ravel(evaluable.RavelIndex(dofs, range_i % ndofs_i, evaluable.constant(ndofs), evaluable.constant(ndofs_i)))
             ndofs = ndofs * ndofs_i
-        coeffs = functools.reduce(evaluable.PolyOuterProduct,
-                                  [evaluable.Elemwise(coeffs_i, index_i, float) for coeffs_i, index_i in zip(self._coeffs, indices)])
+        coeffs_per_dim = iter(evaluable.Elemwise(coeffs_i, index_i, float) for coeffs_i, index_i in zip(self._coeffs, indices))
+        coeffs = next(coeffs_per_dim)
+        for i, c in enumerate(coeffs_per_dim, 1):
+            coeffs, c = evaluable.insertaxis(coeffs, 1, c.shape[0]), evaluable.insertaxis(c, 0, coeffs.shape[0])
+            coeffs = evaluable.PolyMul(coeffs, c, (poly.MulVar.Left,) * i + (poly.MulVar.Right,))
+            coeffs = evaluable.ravel(coeffs, 0)
         return dofs, coeffs
 
 
 class PrunedBasis(Basis):
     '''A subset of another :class:`Basis`.
 
     Parameters
@@ -3816,20 +4033,519 @@
 
     def get_support(self, dof: Union[int, numpy.ndarray]) -> numpy.ndarray:
         if numeric.isintarray(dof) and dof.ndim == 1 and numpy.any(numpy.less(dof, 0)):
             raise IndexError('dof out of bounds')
         return numeric.sorted_index(self._transmap, self._parent.get_support(self._dofmap[dof]), missing='mask')
 
     def f_dofs_coeffs(self, index: evaluable.Array) -> Tuple[evaluable.Array, evaluable.Array]:
-        p_dofs, p_coeffs = self._parent.f_dofs_coeffs(evaluable.get(self._transmap, 0, index))
-        dofs = evaluable.take(self._renumber, p_dofs, axis=0)
+        p_dofs, p_coeffs = self._parent.f_dofs_coeffs(evaluable.get(evaluable.constant(self._transmap), 0, index))
+        dofs = evaluable.take(evaluable.constant(self._renumber), p_dofs, axis=0)
         return dofs, p_coeffs
 
 
 def Namespace(*args, **kwargs):
     from .expression_v1 import Namespace
     return Namespace(*args, **kwargs)
 
 
-def _is_unit_scalar(v):
-    T = type(v)
-    return T in _dtypes and v == T(1)
+HANDLED_FUNCTIONS = {}
+
+class __implementations__:
+
+    def implements(np_function):
+        'Register an ``__array_function__`` or ``__array_ufunc__`` implementation for Array objects.'
+        def decorator(func):
+            HANDLED_FUNCTIONS[np_function] = func
+            return func
+        return decorator
+
+    @implements(numpy.shape)
+    def shape(arg: Array) -> Tuple[int, ...]:
+        return arg.shape
+
+    @implements(numpy.ndim)
+    def ndim(arg: Array) -> int:
+        return arg.ndim
+    
+    @implements(numpy.size)
+    def size(arg: Array) -> int:
+        return arg.size
+
+    @implements(numpy.add)
+    def add(left: IntoArray, right: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.add, left, right)
+    
+    @implements(numpy.subtract)
+    def subtract(left: IntoArray, right: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.subtract, left, right)
+
+    @implements(numpy.positive)
+    def positive(arg: Array) -> Array:
+        return arg
+
+    @implements(numpy.negative)
+    def negative(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.negative, arg)
+
+    @implements(numpy.multiply)
+    def multiply(left: IntoArray, right: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.multiply, left, right)
+    
+    @implements(numpy.true_divide)
+    def divide(dividend: IntoArray, divisor: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.divide, dividend, divisor, min_dtype=float)
+
+    @implements(numpy.reciprocal)
+    def reciprocal(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.reciprocal, arg)
+
+    @implements(numpy.floor_divide)
+    def floor_divide(dividend: IntoArray, divisor: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.FloorDivide, dividend, divisor)
+
+    @implements(numpy.mod)
+    def mod(dividend: IntoArray, divisor: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.Mod, dividend, divisor)
+
+    @implements(numpy.divmod)
+    def divmod(dividend: IntoArray, divisor: IntoArray) -> Tuple[Array, Array]:
+        return numpy.floor_divide(dividend, divisor), numpy.mod(dividend, divisor)
+
+    @implements(numpy.power)
+    def power(base: IntoArray, exponent: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.power, base, exponent, min_dtype=int)
+
+    @implements(numpy.sqrt)
+    def sqrt(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.sqrt, arg, min_dtype=float)
+
+    @implements(numpy.square)
+    def square(arg: Array) -> Array:
+        return numpy.power(arg, 2)
+
+    @implements(numpy.hypot)
+    def hypot(array1: IntoArray, array2: IntoArray) -> Array:
+        return numpy.sqrt(numpy.square(array1) + numpy.square(array2))
+
+    @implements(numpy.absolute)
+    def abs(arg: IntoArray) -> Array:
+        arg = Array.cast(arg)
+        return _Wrapper(evaluable.abs, arg, shape=arg.shape, dtype=float if arg.dtype == complex else arg.dtype)
+
+    @implements(numpy.sign)
+    def sign(arg: IntoArray) -> Array:
+        arg = Array.cast(arg)
+        if arg.dtype == complex:
+            raise ValueError('sign is not defined for complex numbers')
+        return _Wrapper.broadcasted_arrays(evaluable.Sign, arg)
+
+    @implements(numpy.matmul)
+    def matmul(arg1: IntoArray, arg2: IntoArray) -> Array:
+        arg1 = Array.cast(arg1)
+        arg2 = Array.cast(arg2)
+        if not arg1.ndim or not arg2.ndim:
+            raise ValueError('cannot contract zero-dimensional array')
+        if arg2.ndim == 1:
+            return (arg1 * arg2).sum(-1)
+        elif arg1.ndim == 1:
+            return (arg1[:, numpy.newaxis] * arg2).sum(-2)
+        else:
+            return (arg1[..., :, :, numpy.newaxis] * arg2[..., numpy.newaxis, :, :]).sum(-2)
+
+    @implements(numpy.sin)
+    def sin(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.Sin, arg, min_dtype=float)
+
+    @implements(numpy.cos)
+    def cos(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.Cos, arg, min_dtype=float)
+
+    @implements(numpy.tan)
+    def tan(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.Tan, arg, min_dtype=float)
+
+    @implements(numpy.arcsin)
+    def arcsin(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.ArcSin, arg, min_dtype=float)
+
+    @implements(numpy.arccos)
+    def arccos(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.ArcCos, arg, min_dtype=float)
+
+    @implements(numpy.arctan)
+    def arctan(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.ArcTan, arg, min_dtype=float)
+
+    @implements(numpy.arctan2)
+    def arctan2(dividend: IntoArray, divisor: IntoArray) -> Array:
+        dividend, divisor = broadcast_arrays(*typecast_arrays(dividend, divisor, min_dtype=float))
+        if dividend.dtype == complex:
+            raise ValueError('arctan2 is not defined for complex numbers')
+        return _Wrapper(evaluable.ArcTan2, dividend, divisor, shape=dividend.shape, dtype=float)
+
+    @implements(numpy.sinc)
+    def sinc(arg: Array) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.sinc, arg * numpy.pi, min_dtype=float)
+
+    @implements(numpy.cosh)
+    def cosh(arg: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.cosh, arg, min_dtype=float)
+
+    @implements(numpy.sinh)
+    def sinh(arg: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.sinh, arg, min_dtype=float)
+
+    @implements(numpy.tanh)
+    def tanh(arg: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.tanh, arg, min_dtype=float)
+
+    @implements(numpy.arctanh)
+    def arctanh(arg: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.arctanh, arg, min_dtype=float)
+
+    @implements(numpy.exp)
+    def exp(arg: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.Exp, arg, min_dtype=float)
+
+    @implements(numpy.log)
+    def log(arg: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.Log, arg, min_dtype=float)
+
+    @implements(numpy.log2)
+    def log2(arg: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.log2, arg, min_dtype=float)
+
+    @implements(numpy.log10)
+    def log10(arg: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.log10, arg, min_dtype=float)
+
+    @implements(numpy.greater)
+    def greater(left: IntoArray, right: IntoArray) -> Array:
+        left, right = map(Array.cast, (left, right))
+        if left.dtype == complex or right.dtype == complex:
+            raise ValueError('Complex numbers have no total order.')
+        return _Wrapper.broadcasted_arrays(evaluable.Greater, left, right, force_dtype=bool)
+
+    @implements(numpy.equal)
+    def equal(left: IntoArray, right: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.Equal, left, right, force_dtype=bool)
+
+    @implements(numpy.less)
+    def less(left: IntoArray, right: IntoArray) -> Array:
+        left, right = map(Array.cast, (left, right))
+        if left.dtype == complex or right.dtype == complex:
+            raise ValueError('Complex numbers have no total order.')
+        return _Wrapper.broadcasted_arrays(evaluable.Less, left, right, force_dtype=bool)
+
+    @implements(numpy.minimum)
+    def minimum(a: IntoArray, b: IntoArray) -> Array:
+        a, b = map(Array.cast, (a, b))
+        if a.dtype == complex or b.dtype == complex:
+            raise ValueError('Complex numbers have no total order.')
+        return _Wrapper.broadcasted_arrays(evaluable.Minimum, a, b)
+
+    @implements(numpy.maximum)
+    def maximum(a: IntoArray, b: IntoArray) -> Array:
+        a, b = map(Array.cast, (a, b))
+        if a.dtype == complex or b.dtype == complex:
+            raise ValueError('Complex numbers have no total order.')
+        return _Wrapper.broadcasted_arrays(evaluable.Maximum, a, b)
+
+    @implements(numpy.sum)
+    def sum(arg: IntoArray, axis: Optional[Union[int, Sequence[int]]] = None) -> Array:
+        arg = Array.cast(arg)
+        if arg.dtype == bool:
+            arg = arg.astype(int)
+        axes = range(arg.ndim) if axis is None else [axis] if isinstance(axis, numbers.Integral) else axis
+        summed = _Transpose.to_end(arg, *axes)
+        for i in range(len(axes)):
+            summed = _Wrapper(evaluable.Sum, summed, shape=summed.shape[:-1], dtype=summed.dtype)
+        return summed
+
+    @implements(numpy.product)
+    def product(arg: IntoArray, axis: int) -> Array:
+        arg = Array.cast(arg)
+        if arg.dtype == bool:
+            arg = arg.astype(int)
+        axes = range(arg.ndim) if axis is None else [axis] if isinstance(axis, numbers.Integral) else axis
+        multiplied = _Transpose.to_end(arg, *axes)
+        for i in range(len(axes)):
+            multiplied = _Wrapper(evaluable.Product, multiplied, shape=multiplied.shape[:-1], dtype=multiplied.dtype)
+        return multiplied
+
+    @implements(numpy.conjugate)
+    def conjugate(arg: IntoArray) -> Array:
+        return _Wrapper.broadcasted_arrays(evaluable.conjugate, arg)
+
+    @implements(numpy.real)
+    def real(arg: IntoArray) -> Array:
+        arg = Array.cast(arg)
+        return _Wrapper(evaluable.real, arg, shape=arg.shape, dtype=float if arg.dtype == complex else arg.dtype)
+
+    @implements(numpy.imag)
+    def imag(arg: IntoArray) -> Array:
+        arg = Array.cast(arg)
+        return _Wrapper(evaluable.imag, arg, shape=arg.shape, dtype=float if arg.dtype == complex else arg.dtype)
+
+    @implements(numpy.vdot)
+    def vdot(a: IntoArray, b: IntoArray, axes: Optional[Union[int, Sequence[int]]] = None) -> Array:
+        a, b = broadcast_arrays(a, b)
+        return numpy.sum(numpy.conjugate(a) * b, range(a.ndim))
+
+    @implements(numpy.dot)
+    def dot(a: IntoArray, b: IntoArray) -> Array:
+        a = Array.cast(a)
+        b = Array.cast(b)
+        if a.ndim == 0 or b.ndim == 0:
+            return (a * b)
+        if a.shape[-1] != b.shape[-1 if b.ndim == 1 else -2]:
+            raise ValueError(f'shapes {a.shape} and {b.shape} are not aligned')
+        if b.ndim > 1:
+            b = _Transpose.to_end(b, -2)
+            a = _Transpose.to_end(_append_axes(a, b.shape[:-1]), a.ndim-1)
+            assert a.shape[-b.ndim:] == b.shape
+        return numpy.sum(a * b, -1)
+
+    @implements(numpy.reshape)
+    def reshape(arg: Array, newshape):
+        if isinstance(newshape, numbers.Integral):
+            newshape = newshape,
+        if -1 in newshape:
+            i = newshape.index(-1)
+            if -1 in newshape[i+1:]:
+                raise ValueError('can only specify one unknown dimension')
+            length, remainder = builtins.divmod(arg.size, numpy.prod(newshape, initial=-1))
+            if remainder:
+                raise ValueError(f'cannot reshape array of size {arg.size} into shape {newshape}')
+            newshape = (*newshape[:i], length, *newshape[i+1:])
+        elif numpy.prod(newshape, initial=1) != arg.size:
+            raise ValueError(f'cannot reshape array of size {arg.size} into shape {newshape}')
+        ncommon = 0
+        while arg.ndim > ncommon and len(newshape) > ncommon and arg.shape[ncommon] == newshape[ncommon]:
+            ncommon += 1
+        # The first ncommon axes are already of the right shape, so these we
+        # will not touch. The remaining axes will be ravelled and unravelled
+        # until an axis of the desired length is formed, working from end to
+        # beginning, and rolling finished axes to the front to reduce the
+        # number of transposes.
+        for i, s in enumerate(reversed(newshape[ncommon:])):
+            if arg.ndim == ncommon + i: # the first i axes are finished so we need to append a new singleton axis to continue
+                assert s == 1
+                arg = _Wrapper(evaluable.InsertAxis, arg, _WithoutPoints(Array.cast(1)), shape=(*arg.shape, 1), dtype=arg.dtype)
+            else:
+                while arg.shape[-1] % s:
+                    assert arg.ndim > ncommon + i + 1
+                    arg = _Wrapper(evaluable.Ravel, arg, shape=(*arg.shape[:-2], arg.shape[-2]*arg.shape[-1]), dtype=arg.dtype)
+                if arg.shape[-1] != s:
+                    n = arg.shape[-1] // s
+                    arg = _Wrapper(evaluable.Unravel, arg, _WithoutPoints(Array.cast(n)), _WithoutPoints(Array.cast(s)), shape=(*arg.shape[:-1], n, s), dtype=arg.dtype)
+            arg = _Transpose.from_end(arg, ncommon) # move axis to front so that we can continue to operate on the end
+        # If the original array had a surplus of singleton axes, these may
+        # still be present in the tail. We take them away one by one.
+        while arg.ndim > len(newshape):
+            assert arg.shape[-1] == 1
+            arg = _Wrapper(evaluable.Take, arg, _WithoutPoints(Array.cast(0)), shape=arg.shape[:-1], dtype=arg.dtype)
+        assert arg.shape == newshape
+        return arg
+
+    @implements(numpy.ravel)
+    def ravel(arg: Array):
+        return numpy.reshape(arg, -1)
+
+    @implements(numpy.trace)
+    def trace(arg: Array, offset: int = 0, axis1: int = 0, axis2: int = 1) -> Array:
+        if offset != 0:
+            raise NotImplementedError('traces over offset diagonal are not yet supported')
+        return numpy.sum(_takediag(arg, axis1, axis2), -1)
+
+    @implements(numpy.transpose)
+    def transpose(array: Array, axes: Optional[Sequence[int]] = None) -> Array:
+        return _Transpose(array, tuple(reversed(range(array.ndim)) if axes is None else axes))
+
+    @implements(numpy.repeat)
+    def repeat(array: IntoArray, n: IntoArray, axis: int) -> Array:
+        array = Array.cast(array)
+        if array.shape[axis] != 1:
+            raise NotImplementedError('only axes with length 1 can be repeated')
+        return insertaxis(get(array, axis, 0), axis, n)
+
+    @implements(numpy.swapaxes)
+    def swapaxes(array: Array, axis1: int, axis2: int) -> Array:
+        trans = list(range(array.ndim))
+        trans[axis1], trans[axis2] = trans[axis2], trans[axis1]
+        return numpy.transpose(array, trans)
+
+    @implements(numpy.take)
+    def take(array: IntoArray, indices: IntoArray, axis: Optional[int] = None) -> Array:
+        array = Array.cast(array)
+        if axis is None:
+            array = numpy.ravel(array)
+            axis = 0
+        else:
+            axis = numeric.normdim(array.ndim, axis)
+        length = array.shape[axis]
+        indices = util.deep_reduce(numpy.stack, indices)
+        if isinstance(indices, Array):
+            indices = _Wrapper.broadcasted_arrays(evaluable.NormDim, length, indices)
+        else:
+            indices = numpy.array(indices)
+            indices[indices < 0] += length
+            if (indices < 0).any() or (indices >= length).any():
+                raise ValueError('indices out of bounds')
+            indices = _Constant(indices)
+        transposed = _Transpose.to_end(array, axis)
+        taken = _Wrapper(evaluable.Take, transposed, _WithoutPoints(indices), shape=(*transposed.shape[:-1], *indices.shape), dtype=array.dtype)
+        return _Transpose.from_end(taken, *range(axis, axis+indices.ndim))
+
+    @implements(numpy.compress)
+    def compress(condition: Sequence[bool], array: Array, axis: Optional[int] = None) -> Array:
+        length = array.size if axis is None else array.shape[axis]
+        if len(condition) != length:
+            # NOTE: we are a bit stricter here than numpy, which does not check
+            # the length of the condition but only whether the selected indices
+            # are within bounds.
+            raise ValueError(f'expected a condition of length {length} but received {len(condition)}')
+        indices, = numpy.nonzero(condition)
+        return numpy.take(array, indices, axis)
+
+    @implements(numpy.concatenate)
+    def concatenate(__arrays: Sequence[IntoArray], axis: int = 0) -> Array:
+        return _Concatenate(__arrays, axis)
+
+    @implements(numpy.stack)
+    def stack(__arrays: Sequence[IntoArray], axis: int = 0) -> Array:
+        aligned = broadcast_arrays(*typecast_arrays(*__arrays))
+        return util.sum(kronecker(array, axis, len(aligned), i) for i, array in enumerate(aligned))
+
+    @implements(numpy.broadcast_to)
+    def broadcast_to(array: IntoArray, shape: Shape) -> Array:
+        broadcasted = Array.cast(array)
+        orig_shape = broadcasted.shape
+        if broadcasted.ndim > len(shape):
+            raise ValueError('cannot broadcast array with shape {} to {} because the dimension decreases'.format(orig_shape, shape))
+        nnew = len(shape) - broadcasted.ndim
+        broadcasted = _prepend_axes(broadcasted, shape[:nnew])
+        for axis, (actual, desired) in enumerate(zip(broadcasted.shape[nnew:], shape[nnew:])):
+            if actual == desired:
+                continue
+            elif actual == 1:
+                broadcasted = numpy.repeat(broadcasted, desired, axis + nnew)
+            else:
+                raise ValueError('cannot broadcast array with shape {} to {} because input axis {} is neither singleton nor has the desired length'.format(orig_shape, shape, axis))
+        return broadcasted
+
+    @implements(numpy.searchsorted)
+    def searchsorted(a, v: IntoArray, side='left', sorter=None):
+        values = Array.cast(v)
+        array = types.arraydata(a)
+        if side not in ('left', 'right'):
+            raise ValueError(f'expected "left" or "right", got {side}')
+        if sorter is not None:
+            sorter = types.arraydata(sorter)
+            if sorter.shape != array.shape or sorter.dtype != int:
+                raise ValueError('invalid sorter array')
+        lower = functools.partial(evaluable.SearchSorted, array=array, side=side, sorter=sorter)
+        return _Wrapper(lower, values, shape=values.shape, dtype=int)
+
+    @implements(numpy.interp)
+    def interp(x, xp, fp, left=None, right=None):
+        index = numpy.searchsorted(xp, x)
+        _xp = numpy.concatenate([[xp[0]], xp])
+        _fp = numpy.concatenate([[fp[0]], fp])
+        _gp = numpy.concatenate([[0.], numpy.diff(fp) / numpy.diff(xp), [0.]])
+        if left is not None:
+            _fp[0] = left
+        if right is not None:
+            _fp[-1] = right
+        return _Constant(_fp)[index] + _Constant(_gp)[index] * (x - _Constant(_xp)[index])
+
+    @implements(numpy.choose)
+    def choose(a, choices):
+        a, *choices = broadcast_arrays(a, *typecast_arrays(*choices))
+        return _Wrapper(evaluable.Choose, a, *choices, shape=a.shape, dtype=choices[0].dtype)
+
+    @implements(numpy.linalg.norm)
+    def norm(x, ord=None, axis=None):
+        if ord is not None:
+            raise NotImplementedError('only "ord" values of None are supported for now')
+        if axis is None:
+            axis = range(x.ndim)
+        return numpy.sqrt(numpy.sum(x * numpy.conjugate(x), axis))
+
+    def _eig(symmetric, index, a):
+        return evaluable.Eig(a, symmetric)[index]
+
+    @implements(numpy.linalg.eig)
+    def eig(a):
+        return _Wrapper(functools.partial(__implementations__._eig, False, 0), a, shape=a.shape[:-1], dtype=complex), \
+               _Wrapper(functools.partial(__implementations__._eig, False, 1), a, shape=a.shape, dtype=complex)
+
+    @implements(numpy.linalg.eigh)
+    def eigh(a):
+        return _Wrapper(functools.partial(__implementations__._eig, True, 0), a, shape=a.shape[:-1], dtype=float), \
+               _Wrapper(functools.partial(__implementations__._eig, True, 1), a, shape=a.shape, dtype=float if a.dtype != complex else complex)
+
+    @implements(numpy.linalg.det)
+    def det(a):
+        if a.ndim < 2 or a.shape[-2] != a.shape[-1]:
+            raise ValueError('Last 2 dimensions of the array must be square')
+        return _Wrapper(evaluable.Determinant, a, shape=a.shape[:-2], dtype=complex if a.dtype == complex else float)
+
+    @implements(numpy.linalg.inv)
+    def inv(a):
+        if a.ndim < 2 or a.shape[-2] != a.shape[-1]:
+            raise ValueError('Last 2 dimensions of the array must be square')
+        return _Wrapper(evaluable.Inverse, a, shape=a.shape, dtype=complex if a.dtype == complex else float)
+
+    @implements(numpy.ndim)
+    def ndim(a):
+        return a.ndim
+
+    @implements(numpy.size)
+    def size(a):
+        return a.size
+
+    @implements(numpy.shape)
+    def shape(a):
+        return a.shape
+
+    @implements(numpy.diagonal)
+    def diagonal(a, offset=0, axis1=0, axis2=1):
+        if a.shape[axis1] != a.shape[axis2]:
+            raise ValueError('axis lengths do not match')
+        arg = _Transpose.to_end(a, axis1, axis2)
+        if offset > 0:
+            arg = arg[...,:-offset,offset:]
+        elif offset < 0:
+            arg = arg[...,-offset:,:offset]
+        return _Wrapper(evaluable.TakeDiag, arg, shape=arg.shape[:-1], dtype=a.dtype)
+
+    @implements(numpy.einsum)
+    def einsum(subscripts, *operands):
+        *in_, out = numeric.sanitize_einsum_subscripts(subscripts, *map(numpy.shape, operands))
+        axes = list(out)
+        factors = []
+        for s, operand in zip(in_, operands):
+            for i, c in reversed(list(enumerate(s))):
+                if c in s[i+1:]: # duplicate label -> diagonal
+                    j = i + 1 + s[i+1:].index(c)
+                    operand = numpy.diagonal(operand, 0, i, j)
+                    s = s[:i] + s[i+1:j] + s[j+1:] + c
+                elif c not in axes:
+                    axes.insert(0, c) # prepended output axes will be summed
+            transpose = sorted(range(numpy.ndim(operand)), key=lambda i: axes.index(s[i]))
+            insert = tuple(slice(None) if c in s else numpy.newaxis for c in axes)
+            factors.append(numpy.transpose(operand, transpose)[insert])
+        return numpy.sum(util.product(factors), range(len(axes)-len(out)))
+
+    @implements(numpy.cross)
+    def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):
+        if axis is not None:
+            axisa = axisb = axisc = axis
+        a = _Transpose.to_end(a, axisa)
+        b = _Transpose.to_end(b, axisb)
+        if a.shape[-1] == b.shape[-1] == 2:
+            return numpy.einsum('ij,...i,...j', levicivita(2), a, b)
+        elif a.shape[-1] == b.shape[-1] == 3:
+            return _Transpose.from_end(numpy.einsum('ijk,...j,...k', levicivita(3), a, b), axisc)
+        else:
+            raise ValueError('dimension must be 2 or 3')
```

### Comparing `nutils-7.3/nutils/matrix/__init__.py` & `nutils-8.0/nutils/matrix/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -2,58 +2,52 @@
 The matrix module defines an abstract :class:`Matrix` object and several
 implementations.  Matrix objects support basic addition and subtraction
 operations and provide a consistent insterface for solving linear systems.
 Matrices can be converted into other forms suitable for external processing via
 the ``export`` method.
 """
 
-from .. import util, sparse, warnings
+from .. import _util as util, sparse, warnings
 import numpy
 import importlib
 import os
 
 from ._base import Matrix, MatrixError, BackendNotAvailable, ToleranceNotReached
 for cls in Matrix, MatrixError, BackendNotAvailable, ToleranceNotReached:
     cls.__module__ = __name__  # make it appear as if cls was defined here
 del cls  # clean up for sphinx
 
-_assemble = util.settable(importlib.import_module('._'+(os.environ.get('NUTILS_MATRIX') or 'auto').lower(), __name__).assemble)
 
-
-def backend(s):
-    if callable(s):
-        return _assemble.sets(s)
-    elif isinstance(s, str):
-        backend = importlib.import_module('._'+s.lower(), __name__)
-        return _assemble.sets(backend.assemble)
-    else:
-        raise MatrixError('backend should be either a string or a callable')
+@util.set_current
+@util.defaults_from_env
+def backend(matrix: str = 'auto'):
+    return importlib.import_module('._'+matrix.lower(), __name__)
 
 
 def assemble(data, index, shape):
     if not isinstance(data, numpy.ndarray) or data.ndim != 1 or len(index) != 2 or len(shape) != 2:
         raise MatrixError('assemble received invalid input')
     n, = (index[0][1:] <= index[0][:-1]).nonzero()  # index[0][n+1] <= index[0][n]
     if (index[0][n+1] < index[0][n]).any() or (index[1][n+1] <= index[1][n]).any():
         raise MatrixError('assemble input must be sorted')
-    return _assemble.value(data, index, shape)
+    return backend.current.assemble(data, index, shape)
 
 
 def fromsparse(data, inplace=False):
     indices, values, shape = sparse.extract(sparse.prune(sparse.dedup(data, inplace=inplace), inplace=True))
-    return _assemble.value(values, indices, shape)
+    return backend.current.assemble(values, indices, shape)
 
 
 def empty(shape):
-    return _assemble.value(data=numpy.empty([0], dtype=float), index=numpy.empty([len(shape), 0], dtype=int), shape=shape)
+    return backend.current.assemble(data=numpy.empty([0], dtype=float), index=numpy.empty([len(shape), 0], dtype=int), shape=shape)
 
 
 def diag(d):
     assert d.ndim == 1
-    return _assemble.value(d, index=numpy.arange(len(d))[numpy.newaxis].repeat(2, axis=0), shape=d.shape*2)
+    return backend.current.assemble(d, index=numpy.arange(len(d))[numpy.newaxis].repeat(2, axis=0), shape=d.shape*2)
 
 
 def eye(n):
     return diag(numpy.ones(n))
 
 
 def _helper(name):
```

### Comparing `nutils-7.3/nutils/matrix/_base.py` & `nutils-8.0/nutils/matrix/_base.py`

 * *Files 1% similar despite different names*

```diff
@@ -239,15 +239,18 @@
             v2 = _vdot(v)
             c = _vdot(v, res) / v2  # min_c |res - c v| => c = v.res / v.v
             newlhs = lhs + k * c
             res = rhs - self @ newlhs  # recompute rather than update to avoid drift
             newresnorm = numpy.linalg.norm(res, axis=0).max()
             if not numpy.isfinite(newresnorm) or newresnorm >= resnorm:
                 break
-            treelog.debug('residual decreased by {:.1f} orders using {} krylov vectors'.format(numpy.log10(resnorm/newresnorm), len(krylov)))
+            if newresnorm == 0.0:
+                treelog.debug('solution is exact')
+            else:
+                treelog.debug('residual decreased by {:.1f} orders using {} krylov vectors'.format(numpy.log10(resnorm/newresnorm), len(krylov)))
             lhs = newlhs
             resnorm = newresnorm
             krylov.append((k, v, v2))
         return lhs
 
     def submatrix(self, rows, cols):
         '''Create submatrix from selected rows, columns.
@@ -345,8 +348,8 @@
         ab = numpy.square(a.real, order='F')
         if a.dtype.kind == 'c':
             ab += numpy.square(a.imag, order='F')
     else:
         ab = numpy.multiply(a.conj(), b, order='F')
     return ab.sum(0)
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/matrix/_mkl.py` & `nutils-8.0/nutils/matrix/_mkl.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from ._base import Matrix, MatrixError, BackendNotAvailable
-from .. import numeric, util, warnings
+from .. import numeric, _util as util, warnings
 from contextlib import contextmanager
 from ctypes import c_int, byref, CDLL
 import treelog as log
 import os
 import numpy
 
 libmkl_path = os.environ.get('NUTILS_MATRIX_MKL_LIB', None)
@@ -267,14 +267,21 @@
     def _precon_direct(self, **args):
         return Pardiso(mtype=dict(f=11, c=13)[self.dtype.kind], a=self.data, ia=self.rowptr, ja=self.colidx, **args)
 
     def _precon_sym_direct(self, **args):
         upper = numpy.zeros(len(self.data), dtype=bool)
         rowptr = numpy.empty_like(self.rowptr)
         rowptr[0] = 1
-        for irow, (n, m) in enumerate(numeric.overlapping(self.rowptr-1)):
-            n += self.colidx[n:m].searchsorted(irow+1)
-            upper[n:m] = True
-            rowptr[irow+1] = rowptr[irow] + (m-n)
-        return Pardiso(mtype=dict(f=-2, c=6)[self.dtype.kind], a=self.data[upper], ia=rowptr, ja=self.colidx[upper], **args)
+        diagdom = True
+        for irow, (n, m) in enumerate(numeric.overlapping(self.rowptr-1), start=1):
+            d = n + self.colidx[n:m].searchsorted(irow)
+            upper[d:m] = True
+            rowptr[irow] = rowptr[irow-1] + (m-d)
+            diagdom = diagdom and d < m and self.colidx[d] == irow and abs(self.data[n:m]).sum() < 2 * abs(self.data[d])
+        if diagdom:
+            log.debug('matrix is diagonally dominant, solving as SPD')
+            mtype = dict(f=2, c=4)
+        else:
+            mtype = dict(f=-2, c=6)
+        return Pardiso(mtype=mtype[self.dtype.kind], a=self.data[upper], ia=rowptr, ja=self.colidx[upper], **args)
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/matrix/_numpy.py` & `nutils-8.0/nutils/matrix/_numpy.py`

 * *Files 0% similar despite different names*

```diff
@@ -69,8 +69,8 @@
 
     def _precon_direct(self):
         return functools.partial(numpy.linalg.solve, self.core)
 
     def _submatrix(self, rows, cols):
         return NumpyMatrix(self.core[numpy.ix_(rows, cols)])
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/matrix/_scipy.py` & `nutils-8.0/nutils/matrix/_scipy.py`

 * *Files 1% similar despite different names*

```diff
@@ -101,8 +101,8 @@
 
     def _submatrix(self, rows, cols):
         return ScipyMatrix(self.core[rows, :][:, cols])
 
     def diagonal(self):
         return self.core.diagonal()
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/mesh.py` & `nutils-8.0/nutils/mesh.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,18 +2,19 @@
 The mesh module provides mesh generators: methods that return a topology and an
 accompanying geometry function. Meshes can either be generated on the fly, e.g.
 :func:`rectilinear`, or read from external an externally prepared file,
 :func:`gmsh`, and converted to nutils format. Note that no mesh writers are
 provided at this point.
 """
 
-from . import topology, function, util, element, numeric, transform, transformseq, warnings, types, cache
+from . import topology, function, _util as util, element, numeric, transform, transformseq, warnings, types, cache
 from .elementseq import References
 from .transform import TransformItem
 from .topology import Topology
+from ._backports import comb
 from typing import Optional, Sequence, Tuple, Union
 import numpy
 import os
 import itertools
 import re
 import math
 import treelog as log
@@ -49,38 +50,38 @@
 
     return topo, geom
 
 
 _oldrectilinear = rectilinear  # reference for internal unittests
 
 
-def line(nodes: Union[int, Sequence[float]], periodic: bool = False, bnames: Optional[Sequence[Tuple[str, str]]] = None, *, name: Optional[str] = None, space: str = 'X', root: Optional[TransformItem] = None) -> Tuple[Topology, function.Array]:
+def line(nodes: Union[int, Sequence[float]], periodic: bool = False, bnames: Optional[Tuple[str, str]] = None, *, name: Optional[str] = None, space: str = 'X', root: Optional[TransformItem] = None) -> Tuple[Topology, function.Array]:
     if name is not None:
         warnings.deprecation('Argument `name` is deprecated; use `root` with a `transform.transformitem` instead.')
         if root is not None:
             raise ValueError('Arguments `name` and `root` cannot be used simultaneously.')
         root = transform.Index(hash(name))
     elif root is None:
         root = transform.Index(1, 0)
     if isinstance(nodes, int):
         nodes = numpy.arange(nodes + 1)
     domain = topology.StructuredLine(space, root, 0, len(nodes) - 1, periodic=periodic, bnames=bnames)
     geom = domain.basis('std', degree=1, periodic=[]).dot(nodes)
     return domain, geom
 
 
-def newrectilinear(nodes: Sequence[Union[int, Sequence[float]]], periodic: Optional[Sequence[int]] = None, name: Optional[str] = None, bnames=[['left', 'right'], ['bottom', 'top'], ['front', 'back']], spaces: Optional[Sequence[str]] = None, root: Optional[TransformItem] = None) -> Tuple[Topology, function.Array]:
+def newrectilinear(nodes: Sequence[Union[int, Sequence[float]]], periodic: Optional[Sequence[int]] = None, name: Optional[str] = None, bnames: Sequence[Optional[Tuple[str, str]]] = [('left', 'right'), ('bottom', 'top'), ('front', 'back')], spaces: Optional[Sequence[str]] = None, root: Optional[TransformItem] = None) -> Tuple[Topology, function.Array]:
     if periodic is None:
         periodic = []
     if not spaces:
         spaces = 'XYZ' if len(nodes) <= 3 else map('R{}'.format, range(len(nodes)))
     else:
         assert len(spaces) == len(nodes)
     domains, geoms = zip(*(line(nodesi, i in periodic, bnamesi, name=name, space=spacei, root=root) for i, (nodesi, bnamesi, spacei) in enumerate(zip(nodes, tuple(bnames)+(None,)*len(nodes), spaces))))
-    return util.product(domains), function.stack(geoms)
+    return util.product(domains), numpy.stack(geoms)
 
 
 if os.environ.get('NUTILS_TENSORIAL'):
     def rectilinear(richshape: Sequence[Union[int, Sequence[float]]], periodic: Sequence[int] = (), name: Optional[str] = None, space: str = 'X', root: Optional[TransformItem] = None) -> Tuple[Topology, function.Array]:
         spaces = tuple(space+str(i) for i in range(len(richshape)))
         return newrectilinear(richshape, periodic, name=name, spaces=spaces, root=root)
 
@@ -442,16 +443,15 @@
                          + [name + ' groups: ' + ', '.join('{} #{}'.format(n, len(e)) for n, e in tags.items())
                             for name, tags in (('volume', vtags), ('boundary', btags), ('point', ptags)) if tags]))
 
     return dict(nodes=vnodes, cnodes=cnodes, coords=coords, tags=vtags, btags=btags, ptags=ptags)
 
 
 @log.withcontext
-@types.apply_annotations
-def gmsh(fname: util.binaryfile, name='gmsh', *, space='X'):
+def gmsh(fname, name='gmsh', *, space='X'):
     """Gmsh parser
 
     Parser for Gmsh files in `.msh` format. Only files with physical groups are
     supported. See the `Gmsh manual
     <http://geuz.org/gmsh/doc/texinfo/gmsh.html>`_ for details.
 
     Parameters
@@ -465,15 +465,15 @@
     -------
     topo : :class:`nutils.topology.SimplexTopology`
         Topology of parsed Gmsh file.
     geom : :class:`nutils.function.Array`
         Isoparametric map.
     """
 
-    with fname as f:
+    with util.binaryfile(fname) as f:
         return simplex(name=name, **parsegmsh(f), space=space)
 
 
 def simplex(nodes, cnodes, coords, tags, btags, ptags, name='simplex', *, space='X'):
     '''Simplex topology.
 
     Parameters
@@ -512,15 +512,15 @@
     nverts = len(coords)
     nelems, ncnodes = cnodes.shape
     ndims = nodes.shape[1] - 1
     degree = 1 if ncnodes == ndims+1 else int((ncnodes * math.factorial(ndims))**(1/ndims))-1
 
     assert len(nodes) == nelems, 'number of simplex vertices and coordinates do not match'
     assert numpy.greater(nodes[:, 1:], nodes[:, :-1]).all(), 'nodes must be sorted'
-    assert ncnodes == _comb(ndims + degree, degree), 'number of coordinate nodes does not correspond to uniformly refined simplex'
+    assert ncnodes == comb(ndims + degree, degree), 'number of coordinate nodes does not correspond to uniformly refined simplex'
 
     transforms = transformseq.IndexTransforms(ndims=ndims, length=nelems)
     topo = topology.SimplexTopology(space, nodes, transforms, transforms)
     coeffs = element.getsimplex(ndims).get_poly_coeffs('lagrange', degree=degree)
     basis = function.PlainBasis([coeffs] * nelems, cnodes, nverts, topo.f_index, topo.f_coords)
     geom = (basis[:, _] * coords).sum(0)
 
@@ -536,24 +536,24 @@
             simplices, transforms, opposites = bitems if ioppelem == -1 else iitems
             simplices.append(tuple(nodes[ielem][:iedge])+tuple(nodes[ielem][iedge+1:]))
             transforms.append(topo.transforms[ielem] + (transform.SimplexEdge(ndims, iedge),))
             if opposites is not None:
                 opposites.append(topo.transforms[ioppelem] + (transform.SimplexEdge(ndims, tuple(connectivity[ioppelem]).index(ielem)),))
         for groups, (simplices, transforms, opposites) in (bgroups, bitems), (igroups, iitems):
             if simplices:
-                transforms = transformseq.PlainTransforms(transforms, ndims, ndims-1)
-                opposites = transforms if opposites is None else transformseq.PlainTransforms(opposites, ndims, ndims-1)
-                groups[name] = topology.SimplexTopology(space, simplices, transforms, opposites)
+                transforms = transformseq.PlainTransforms(tuple(transforms), ndims, ndims-1)
+                opposites = transforms if opposites is None else transformseq.PlainTransforms(tuple(opposites), ndims, ndims-1)
+                groups[name] = topology.SimplexTopology(space, numpy.asarray(simplices), transforms, opposites)
 
     pgroups = {}
     if ptags:
-        ptrans = [transform.Point(offset) for offset in numpy.eye(ndims+1)[:, 1:]]
+        ptrans = [transform.Point(types.arraydata(offset)) for offset in numpy.eye(ndims+1)[:, 1:]]
         pmap = {inode: numpy.array(numpy.equal(nodes, inode).nonzero()).T for inode in set.union(*map(set, ptags.values()))}
         for pname, inodes in ptags.items():
-            ptransforms = transformseq.PlainTransforms([topo.transforms[ielem] + (ptrans[ivertex],) for inode in inodes for ielem, ivertex in pmap[inode]], ndims, 0)
+            ptransforms = transformseq.PlainTransforms(tuple((*topo.transforms[ielem], ptrans[ivertex]) for inode in inodes for ielem, ivertex in pmap[inode]), ndims, 0)
             preferences = References.uniform(element.getsimplex(0), len(ptransforms))
             pgroups[pname] = topology.TransformChainsTopology(space, preferences, ptransforms, ptransforms)
 
     vgroups = {}
     for name, ielems in tags.items():
         if len(ielems) == nelems and numpy.equal(ielems, numpy.arange(nelems)).all():
             vgroups[name] = topo.withgroups(bgroups=bgroups, igroups=igroups, pgroups=pgroups)
@@ -584,20 +584,20 @@
                     continue
                 simplices.append(tuple(nodes[ielem][:iedge])+tuple(nodes[ielem][iedge+1:]))
                 transforms.append(topo.transforms[ielem] + (transform.SimplexEdge(ndims, iedge),))
                 if ioppelem != -1:
                     opposites.append(topo.transforms[ioppelem] + (transform.SimplexEdge(ndims, ioppedge),))
             for groups, (simplices, transforms, opposites) in (vbgroups, bitems), (vigroups, iitems):
                 if simplices:
-                    transforms = transformseq.PlainTransforms(transforms, ndims, ndims-1)
-                    opposites = transformseq.PlainTransforms(opposites, ndims, ndims-1) if len(opposites) == len(transforms) else transforms
-                    groups[bname] = topology.SimplexTopology(space, simplices, transforms, opposites)
+                    transforms = transformseq.PlainTransforms(tuple(transforms), ndims, ndims-1)
+                    opposites = transformseq.PlainTransforms(tuple(opposites), ndims, ndims-1) if len(opposites) == len(transforms) else transforms
+                    groups[bname] = topology.SimplexTopology(space, numpy.asarray(simplices), transforms, opposites)
         vpgroups = {}
         for pname, inodes in ptags.items():
-            ptransforms = transformseq.PlainTransforms([topo.transforms[ielem] + (ptrans[ivertex],) for inode in inodes for ielem, ivertex in pmap[inode] if keep[ielem]], ndims, 0)
+            ptransforms = transformseq.PlainTransforms(tuple((*topo.transforms[ielem], ptrans[ivertex]) for inode in inodes for ielem, ivertex in pmap[inode] if keep[ielem]), ndims, 0)
             preferences = References.uniform(element.getsimplex(0), len(ptransforms))
             vpgroups[pname] = topology.TransformChainsTopology(space, preferences, ptransforms, ptransforms)
         vgroups[name] = vtopo.withgroups(bgroups=vbgroups, igroups=vigroups, pgroups=vpgroups)
 
     return topo.withgroups(vgroups=vgroups, bgroups=bgroups, igroups=igroups, pgroups=pgroups), geom
 
 
@@ -619,31 +619,44 @@
     Args
     ----
     nelems : :class:`int`
         Number of elements along boundary
     etype : :class:`str`
         Type of element used for meshing. Supported are:
 
-        * ``"square"``: structured mesh of squares.
+        * ``"square"`` or ``"rectilinear"``: structured mesh of squares.
 
         * ``"triangle"``: unstructured mesh of triangles.
 
         * ``"mixed"``: unstructured mesh of triangles and squares.
 
+        * ``"multipatch"``: multipatch mesh consisting of five patches with the
+            following structure:
+
+            .. code-block:: none
+
+               *─────*
+               │╲   ╱│
+               │ *─* │
+               │ │ │ │
+               │ *─* │
+               │╱   ╲│
+               *─────*
+
     Returns
     -------
     :class:`nutils.topology.TransformChainsTopology`:
         The structured/unstructured topology.
     :class:`nutils.function.Array`:
         The geometry function.
     '''
 
     space = 'X'
 
-    if etype == 'square':
+    if etype in ('square', 'rectilinear'):
         topo, geom = rectilinear([nelems, nelems], space=space)
         return topo, geom / nelems
 
     elif etype in ('triangle', 'mixed'):
         simplices = numpy.concatenate([
             numpy.take([i*(nelems+1)+j, i*(nelems+1)+j+1, (i+1)*(nelems+1)+j, (i+1)*(nelems+1)+j+1], [[0, 1, 2], [1, 2, 3]] if i % 2 == j % 2 else [[0, 1, 3], [0, 2, 3]], axis=0)
             for i in range(nelems) for j in range(nelems)])
@@ -665,23 +678,106 @@
                 connectivity[n*2:(n+1)*2] = numpy.concatenate(connectivity[n*2:(n+1)*2])[[3, 2, 4, 1] if i % 2 == j % 2 else [3, 2, 0, 5]],
                 connectivity = [c-numpy.greater(c, n*2) for c in connectivity]
                 dofs[n*2:(n+1)*2] = numpy.unique([*dofs[n*2], *dofs[n*2+1]]),
             coords = coords[numpy.argsort(numpy.unique(numpy.concatenate(dofs), return_index=True)[1])]
             transforms = transformseq.IndexTransforms(2, len(connectivity))
             topo = topology.ConnectedTopology(space, References.from_iter(references, 2), transforms, transforms, connectivity)
 
-        geom = (topo.basis('std', degree=1) * coords.T).sum(-1)
+        geom = topo.basis('std', degree=1) @ coords
         x, y = topo.boundary.sample('_centroid', None).eval(geom).T
-        bgroups = dict(left=x < .1, right=x > nelems-.1, bottom=y < .1, top=y > nelems-.1)
-        topo = topo.withboundary(**{name: topo.boundary[numpy.where(mask)[0]] for name, mask in bgroups.items()})
+        btopo = topo.boundary
+        topo = topo.withboundary(left=btopo[x<.1], right=btopo[x>nelems-.1], bottom=btopo[y<.1], top=btopo[y>nelems-.1])
         return topo, geom / nelems
 
+    elif etype == 'multipatch':
+        # 2─────3
+        # │╲   ╱│
+        # │ 6─7 │
+        # │ │ │ │
+        # │ 4─5 │
+        # │╱   ╲│
+        # 0─────1
+        topo, geom = multipatch(
+            patches=[[0, 4, 1, 5], [2, 6, 3, 7], [0, 4, 2, 6], [1, 5, 3, 7], [4, 6, 5, 7]],
+            patchverts=[[0, 0], [3, 0], [0, 3], [3, 3], [1, 1], [2, 1], [1, 2], [2, 2]],
+            nelems=nelems)
+        topo = topo.withboundary(
+            bottom=topo['patch0'].boundary['bottom'],
+            top=topo['patch1'].boundary['bottom'],
+            left=topo['patch2'].boundary['bottom'],
+            right=topo['patch3'].boundary['bottom'])
+        return topo, geom / 3
+
     else:
         raise Exception('invalid element type {!r}'.format(etype))
 
 
-try:
-    from math import comb as _comb  # new in Python 3.8
-except ImportError:
-    _comb = lambda n, k: numpy.arange(1+max(k, n-k), 1+n).prod() // math.factorial(min(k, n-k))
+def unitcircle(nelems: int, variant: str) -> Tuple[Topology, function.Array]:
+    '''Unit circle mesh.
+
+    The circle is centered at coordinate ``(0, 0)`` and has unit radius.
+
+    Args
+    ----
+    nelems : :class:`int`
+        Number of elements along boundary
+    variant : :class:`str`
+        Mesh variant. Supported are:
+
+        *   ``"rectilinear"``: structured mesh of squares, blown-up to a circle.
+
+        *   ``"multipatch"``: multipatch mesh consisting of five patches with
+            the same topological structure as :func:`unitsquare` with
+            ``etype='multipatch'``.
+
+    Returns
+    -------
+    :class:`nutils.topology.TransformChainsTopology`:
+        The structured/unstructured topology.
+    :class:`nutils.function.Array`:
+        The geometry function.
+    '''
+
+    if variant == 'rectilinear':
+        topo, geom = unitsquare(nelems, 'square')
+        angle = (geom - 0.5) * (numpy.pi / 2)
+        return topo, numpy.sqrt(2) * numpy.sin(angle) * numpy.cos(angle)[[1, 0]]
+
+    elif variant == 'multipatch':
+        topo, geom = unitsquare(nelems, 'multipatch')
+
+        B, T, L, R, C = topo.basis('patch')
+        x, y = geom * 2 - 1
+
+        xlin = x / numpy.maximum(abs(y), 1/3) # -1 / 1
+        ylin = y / numpy.maximum(abs(x), 1/3) # -1 / 1
+        xcup = numpy.maximum(1.5 * abs(x) - .5, 0) # 1 \ 0 / 1
+        ycup = numpy.maximum(1.5 * abs(y) - .5, 0) # 1 \ 0 / 1
+
+        b = numpy.sqrt(1/3) # scales inner square
+        xx = (b + (1-b) * xcup)**2
+        yy = (b + (1-b) * ycup)**2
+
+        c = .5 * (numpy.sqrt(2) - 1) # scales outer radius
+        X = (R-L) * (xx + c * xcup**2 * (1 - ylin**2)) + (T+C+B) * xlin * yy
+        Y = (T-B) * (yy + c * ycup**2 * (1 - xlin**2)) + (L+C+R) * ylin * xx
+        W = 1 + c * (L+R) * xcup**2 * (1 + ylin**2) + c * (T+B) * ycup**2 * (1 + xlin**2)
+
+        # Rather than returning [X, Y] / W, we project the numerator and
+        # denominator onto a second order basis for efficient evaluation and
+        # correct boundary gradients at the patch interfaces.
+
+        basis = topo.basis('spline', 2)
+        # Minimize e = (f - B c)^2 = f^2 - 2 f B c + cT BT B c -> BT B c = BT f
+        BB, BX, BY, BW, XX, YY, WW = topo.integrate([basis[:,None] * basis[None,:],
+            basis * X, basis * Y, basis * W, X**2, Y**2, W**2], degree=4)
+        cx, cy, cw = [BB.solve(BF) for BF in (BX, BY, BW)]
+        ex, ey, ew = [FF + (BB @ cf - 2 * BF) @ cf for (cf, BF, FF) in ((cx, BX, XX), (cy, BY, YY), (cw, BW, WW))]
+        log.debug(f'NURBS projection errors: x={ex:.0e}, y={ey:.0e}, w={ew:.0e}')
+
+        return topo, (basis @ numpy.stack([cx, cy], 1)) / (basis @ cw)
+
+    else:
+        raise Exception('invalid variant {!r}'.format(variant))
+
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/numeric.py` & `nutils-8.0/nutils/numeric.py`

 * *Files 4% similar despite different names*

```diff
@@ -218,15 +218,15 @@
     return diagonalized
 
 
 def inv(A):
     '''Matrix inverse.
 
     Fully equivalent to :func:`numpy.linalg.inv`, with the exception that upon
-    singular systems :func:`inv` does not raise a ``LinAlgError``, but rather
+    singular systems :func:`~nutils.numeric.inv` does not raise a ``LinAlgError``, but rather
     issues a ``RuntimeWarning`` and returns NaN (not a number) values. For
     arguments of dimension >2 the return array contains NaN values only for those
     entries that correspond to singular matrices.
     '''
 
     try:
         Ainv = numpy.linalg.inv(A)
@@ -427,93 +427,14 @@
     a = b = 1
     for i in range(1, k+1):
         a *= n+1-i
         b *= i
     return a // b
 
 
-@types.lru_cache
-def poly_outer_product(left, right):
-    left, right = numpy.asarray(left), numpy.asarray(right)
-    nleft, nright = left.ndim-1, right.ndim-1
-    pshape = left.shape[1:] if not nright else right.shape[1:] if not nleft else (max(left.shape[1:])+max(right.shape[1:])-1,) * (nleft + nright)
-    outer = numpy.zeros((left.shape[0], right.shape[0], *pshape), dtype=numpy.common_type(left, right))
-    a = slice(None)
-    outer[(a, a, *(map(slice, left.shape[1:]+right.shape[1:])))] = left[(a, None)+(a,)*nleft+(None,)*nright]*right[(None, a)+(None,)*nleft+(a,)*nright]
-    return types.frozenarray(outer.reshape(left.shape[0] * right.shape[0], *pshape), copy=False)
-
-
-@types.lru_cache
-def poly_concatenate(*coeffs):
-    n = max(c.shape[1] for c in coeffs)
-    coeffs = [numpy.pad(c, [(0, 0)]+[(0, n-c.shape[1])]*(c.ndim-1), 'constant', constant_values=0) if c.shape[1] < n else c for c in coeffs]
-    return types.frozenarray(numpy.concatenate(coeffs), copy=False)
-
-
-@types.lru_cache
-def poly_grad(coeffs, ndim):
-    coeffs = numpy.asarray(coeffs)
-    I = range(ndim)
-    dcoeffs = [coeffs[(..., *(slice(1, None) if i == j else slice(0, -1) for j in I))] for i in I]
-    if coeffs.shape[-1] > 2:
-        a = numpy.arange(1, coeffs.shape[-1])
-        dcoeffs = [a[tuple(slice(None) if i == j else numpy.newaxis for j in I)] * c for i, c in enumerate(dcoeffs)]
-    return types.frozenarray(numpy.stack(dcoeffs, axis=coeffs.ndim-ndim), copy=False)
-
-
-@types.lru_cache
-def poly_eval(coeffs, points):
-    coeffs = numpy.asarray(coeffs)
-    points = numpy.asarray(points)
-    assert points.ndim >= 1
-    coorddim = points.shape[-1]
-    if not coeffs.size:
-        return full(points.shape[:-1]+coeffs.shape[:coeffs.ndim-points.shape[-1]], fill_value=0, dtype=float)
-    if coeffs.ndim == 0:
-        return full(points.shape[:-1], fill_value=coeffs, dtype=float)
-    result = numpy.empty(points.shape[:-1]+coeffs.shape, dtype=float)
-    result[:] = coeffs
-    coeffs = result
-    for dim in reversed(range(coorddim)):
-        result = numpy.array(coeffs[..., -1], copy=True, dtype=float)
-        points_dim = points[(..., dim, *(numpy.newaxis,)*(result.ndim-points.ndim+1))]
-        for j in reversed(range(coeffs.shape[-1]-1)):
-            result *= points_dim
-            result += coeffs[..., j]
-        coeffs = result
-    return types.frozenarray(coeffs, copy=False)
-
-
-@types.lru_cache
-def poly_mul(p, q):
-    p = numpy.asarray(p)
-    q = numpy.asarray(q)
-    assert p.ndim == q.ndim
-    pq = numpy.zeros([n+m-1 for n, m in zip(p.shape, q.shape)])
-    if q.size < p.size:
-        p, q = q, p  # loop over the smallest of the two arrays
-    for i, pi in numpy.ndenumerate(p):
-        if pi:
-            pq[tuple(slice(o, o+m) for o, m in zip(i, q.shape))] += pi * q
-    return types.frozenarray(pq, copy=False)
-
-
-@types.lru_cache
-def poly_pow(p, n):
-    assert isint(n) and n >= 0
-    if n == 0:
-        return full([1]*p.ndim, fill_value=1, dtype=float)
-    if n == 1:
-        return p
-    q = poly_pow(poly_mul(p, p), n//2)
-    if n % 2:
-        return poly_mul(q, p)
-    return q
-
-
 def accumulate(data, index, shape):
     '''accumulate scattered data in dense array.
 
     Accumulates values from ``data`` in an array of shape ``shape`` at positions
     ``index``, equivalent with:
 
     >>> def accumulate(data, index, shape):
@@ -666,8 +587,95 @@
     for k in reversed(range(n-1)):
         I[k+1:][numpy.equal(I[k+1:], I[k, None])] = k
     # Inflate with `1` if `nperms` is even and `-1` if odd.
     result = numpy.zeros((n,)*n, dtype=dtype)
     result[tuple(I)] = 1 - 2*(nperms % 2)
     return result
 
-# vim:sw=2:sts=2:et
+
+def sinc(x, n=0):
+    '''
+    Evaluates the n-th derivative of the unnormalized sinc function:
+
+        sinc(x) = sin(x) / x
+    '''
+
+    x = numpy.asarray(x)
+    f = numpy.asarray(numpy.sinc(x / numpy.pi)) # Numpy's implementation is normalized to π
+    if n == 0:
+        return f
+    # Derivatives are evaluated using either a recurrence relation or a Taylor
+    # series expansion, depending on proximity to the origin.
+    m = abs(x) >= 1
+    if m.any(): # points outside unit ball
+        # sinc'i(x) = (sin'i(x) - i sinc'i-1(x)) / x
+        fm = f[m]
+        xm = x[m]
+        for i in range(1, n+1): # traverse derivatives
+            fm *= -i
+            fm += [numpy.sin, numpy.cos][i%2](xm) * [1, 1, -1, -1][i % 4]
+            fm /= xm
+        f[m] = fm
+    if not m.all(): # points inside unit ball
+        # sinc'n(x) = Σ_i cos(½π(i+n)) x^i / i! / (i+n+1)
+        xm = x[~m]
+        xm2 = xm**2
+        fm = numpy.zeros(xm.shape, dtype=f.dtype)
+        imax = 32 # 1/32! = 4e-36
+        for i in reversed(range(n % 2, imax, 4)):
+            fm *= xm2 / ((i + 4) * (i + 3))
+            fm -= 1 / (i + n + 3)
+            fm *= xm2 / ((i + 2) * (i + 1))
+            fm += 1 / (i + n + 1)
+        if n % 2:
+            fm *= xm
+        if 1 <= n % 4 <= 2:
+            fm = -fm
+        f[~m] = fm
+    return f
+
+
+def sanitize_einsum_subscripts(subscripts, *shapes):
+    '''Sanitize einsum's subscript labels.
+
+    This helper function checks that a subscripts string is consistent with
+    argument shapes to be used by Numpy's einsum function, and expands implicit
+    output and/or ellipses. The expanded subscript labels are returned as a
+    tuple of strings, the last of which contains the output labels.'''
+
+    einsum_symbols_set = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') # from Numpy's source code
+    if not isinstance(subscripts, str):
+        raise ValueError('first einsum argument must be a string of subscript labels')
+    in_, explicit, out = subscripts.partition('->')
+    if not explicit:
+        out = ''.join(sorted(c for c in einsum_symbols_set.intersection(subscripts) if subscripts.count(c) == 1))
+    in_ = in_.split(',')
+    if len(in_) != len(shapes):
+        raise ValueError('number of arguments does not match subscript labels')
+    if '...' in subscripts: # expand ellipses
+        unused_symbol = iter(sorted(einsum_symbols_set.difference(subscripts)))
+        ell = ''
+        for i, shape in enumerate(shapes):
+            if '...' in in_[i]:
+                n = builtins.max(len(shape) - (len(in_[i])-3), 0)
+                while len(ell) < n:
+                    ell += next(unused_symbol)
+                in_[i] = in_[i].replace('...', ell[:n][::-1], 1)
+        if not explicit:
+            out = ell[::-1] + out
+        elif '...' in out:
+            out = out.replace('...', ell[::-1], 1)
+        elif ell:
+            raise ValueError('non-empty ellipses in input require ellipsis in output')
+    if not all(einsum_symbols_set.issuperset(s) for s in (*in_, out)):
+        raise ValueError('invalid subscripts argument')
+    if any(len(s) != len(shape) for s, shape in zip(in_, shapes)):
+        raise ValueError('argument dimensions are inconsistent with subscript labels')
+    axis_shapes = {}
+    if any(axis_shapes.setdefault(c, n) != n for s, shape in zip(in_, shapes) for c, n in zip(s, shape) if n != 1):
+        raise ValueError('argument shapes are inconsistent with subscript labels')
+    for index in set(out) - set(''.join(in_)):
+        raise ValueError(f'einstein sum subscripts string included output subscript {index!r} which never appeared in an input')
+    return (*in_, out)
+
+
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/parallel.py` & `nutils-8.0/nutils/parallel.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,48 +1,45 @@
 """
 The parallel module provides tools aimed at parallel computing. At this point
 all parallel solutions use the ``fork`` system call and are supported on limited
 platforms, notably excluding Windows. On unsupported platforms parallel features
 will disable and a warning is printed.
 """
 
-from . import numeric, warnings, util
+from . import numeric, warnings, _util as util
 import os
 import multiprocessing
 import mmap
 import signal
 import contextlib
 import builtins
 import numpy
 import treelog
 
-_maxprocs = util.settable(int(os.environ.get('NUTILS_NPROCS') or 1))
 
-
-@util.positional_only
-def maxprocs(new: int):
-    '''limit number of processes for fork.'''
-
-    if not isinstance(new, int) or new < 1:
+@util.set_current
+@util.defaults_from_env
+def maxprocs(nprocs: int = 1):
+    if not isinstance(nprocs, int) or nprocs < 1:
         raise ValueError('nprocs requires a positive integer argument')
-    return _maxprocs.sets(new)
+    return nprocs
 
 
 @contextlib.contextmanager
 def fork(nprocs=None):
     '''continue as ``nprocs`` parallel processes by forking ``nprocs-1`` times
 
     If ``nprocs`` exceeds the configured ``maxprocs`` than it will silently be
     capped. It is up to the user to prepare shared memory and/or locks for
     inter-process communication. As a safety measure nested forks are blocked by
     limiting nprocs to 1; all secondary forks will be silently ignored.
     '''
 
-    if nprocs is None or nprocs > _maxprocs.value:
-        nprocs = _maxprocs.value
+    if nprocs is None or nprocs > maxprocs.current:
+        nprocs = maxprocs.current
     if nprocs <= 1:
         yield 0
         return
     if not hasattr(os, 'fork'):
         warnings.warn('fork is unavailable on this platform')
         yield 0
         return
@@ -90,15 +87,15 @@
 
     if numeric.isint(shape):
         shape = shape,
     else:
         assert all(numeric.isint(sh) for sh in shape)
     dtype = numpy.dtype(dtype)
     size = util.product(map(int, shape), int(dtype.itemsize))
-    if size == 0 or _maxprocs.value == 1:
+    if size == 0 or maxprocs.current == 1:
         return numpy.empty(shape, dtype)
     # `mmap(-1,...)` will allocate *anonymous* memory.  Although linux' man page
     # mmap(2) states that anonymous memory is initialized to zero, we can't rely
     # on this to be true for all platforms (see [SO-mmap]).  [SO-mmap]:
     # https://stackoverflow.com/a/17896084
     return numpy.frombuffer(mmap.mmap(-1, size), dtype).reshape(shape)
 
@@ -165,8 +162,8 @@
         s = os.WSTOPSIG(status)
         msg = 'was stopped with signal {} ({})'.format(s, signal.Signals(s).name)
     else:
         msg = 'died of unnatural causes'
     treelog.error('process {} {}'.format(pid, msg))
     return False
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/points.py` & `nutils-8.0/nutils/points.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,18 @@
 The points module defines the :class:`Points` base class, which bundles point
 coordinates, point weights, a local triangulation and a hull triangulation. The
 module provides several different implementations such as :class:`TensorPoints`
 and :class:`SimplexGaussPoints` that reflect the variety of elements in the
 :mod:`nutils.element` module.
 '''
 
-from . import types, transform, numeric, util
+from . import types, transform, numeric, _util as util
+from ._backports import cached_property
+from typing import Tuple, FrozenSet
+from numbers import Integral
 import numpy
 import functools
 import itertools
 import warnings
 import math
 _ = numpy.newaxis
 
@@ -36,18 +39,17 @@
     ----
     npoints : :class:`int`
       Number of discrete points.
     ndims : :class:`int`
       Number of spatial dimensions.
     '''
 
-    __cache__ = 'tri', 'hull', 'onhull'
-
-    @types.apply_annotations
-    def __init__(self, npoints: types.strictint, ndims: types.strictint):
+    def __init__(self, npoints: Integral, ndims: Integral):
+        assert isinstance(npoints, Integral), f'npoints={npoints!r}'
+        assert isinstance(ndims, Integral), f'ndims={ndims!r}'
         self.npoints = npoints
         self.ndims = ndims
 
     def __mul__(self, other):
         '''Return ``self*other``.'''
 
         if not isinstance(other, Points):
@@ -65,27 +67,27 @@
         -------
         product : :class:`Points`
             The product.
         '''
 
         return TensorPoints(self, other)
 
-    @property
+    @cached_property
     def tri(self):
         '''Triangulation of interior.
 
         A two-dimensional integer array with ``ndims+1`` columns, of which every
         row defines a simplex by mapping vertices into the list of points.
         '''
 
         if self.ndims == 0 and self.npoints == 1:
             return types.frozenarray([[0]])
         raise Exception('tri not defined for {}'.format(self))
 
-    @property
+    @cached_property
     def hull(self):
         '''Triangulation of the exterior hull.
 
         A two-dimensional integer array with ``ndims`` columns, of which every row
         defines a simplex by mapping vertices into the list of points.
         '''
 
@@ -93,83 +95,78 @@
         edge_vertices = numpy.arange(self.ndims+1).repeat(self.ndims).reshape(self.ndims, self.ndims+1).T  # ndims+1 x ndims
         edge_simplices = numpy.sort(self.tri, axis=1)[:, edge_vertices]  # nelems x ndims+1 x ndims
         elems, edges = divmod(numpy.lexsort(edge_simplices.reshape(-1, self.ndims).T), self.ndims+1)
         sorted_edge_simplices = edge_simplices[elems, edges]  # (nelems x ndims+1) x ndims; matching edges are now adjacent
         notequal = numpy.not_equal(sorted_edge_simplices[1:], sorted_edge_simplices[:-1]).any(axis=1)
         return types.frozenarray(sorted_edge_simplices[numpy.hstack([True, notequal]) & numpy.hstack([notequal, True])], copy=False)
 
-    @property
+    @cached_property
     def onhull(self):
         '''Boolean mask marking boundary points.
 
         The array of length ``npoints`` is ``True`` where the corresponding point
         is part of the :attr:`hull`, and ``False`` where it is not.
         '''
 
         onhull = numpy.zeros(self.npoints, dtype=bool)
         onhull[numpy.ravel(self.hull)] = True  # not clear why ravel is necessary but setitem seems to require it
         return types.frozenarray(onhull, copy=False)
 
 
-strictpoints = types.strict[Points]
-
-
 class CoordsPoints(Points):
     '''Manually supplied points.'''
 
-    @types.apply_annotations
     def __init__(self, coords: types.arraydata):
-        assert coords.dtype == float
+        assert isinstance(coords, types.arraydata) and coords.ndim == 2 and coords.dtype == float, f'coords={coords!r}'
         self.coords = numpy.asarray(coords)
         super().__init__(*coords.shape)
 
 
 class CoordsWeightsPoints(CoordsPoints):
     '''Manually supplied points and weights.'''
 
-    @types.apply_annotations
     def __init__(self, coords: types.arraydata, weights: types.arraydata):
-        assert coords.dtype == float
-        assert weights.dtype == float
+        assert isinstance(coords, types.arraydata) and coords.ndim == 2 and coords.dtype == float, f'coords={coords!r}'
+        assert isinstance(weights, types.arraydata) and weights.ndim == 1 and weights.dtype == float, f'weights={weights!r}'
         self.weights = numpy.asarray(weights)
         super().__init__(coords)
 
 
 class CoordsUniformPoints(CoordsPoints):
     '''Manually supplied points with uniform weights.'''
 
-    @types.apply_annotations
     def __init__(self, coords: types.arraydata, volume: float):
+        assert isinstance(coords, types.arraydata) and coords.ndim == 2 and coords.dtype == float, f'coords={coords!r}'
+        assert isinstance(volume, float), f'volume={volume!r}'
         self.weights = numeric.full(coords.shape[:1], fill_value=volume/coords.shape[0], dtype=float)
         super().__init__(coords)
 
 
 class TensorPoints(Points):
     '''Tensor product of two Points instances.'''
 
-    __cache__ = 'coords', 'weights', 'tri', 'hull'
-
-    @types.apply_annotations
-    def __init__(self, points1: strictpoints, points2: strictpoints):
+    def __init__(self, points1: Points, points2: Points):
+        assert isinstance(points1, Points), f'points1={points1!r}'
+        assert isinstance(points2, Points), f'points2={points2!r}'
         self.points1 = points1
         self.points2 = points2
         super().__init__(points1.npoints * points2.npoints, points1.ndims + points2.ndims)
 
-    @property
+    @cached_property
     def coords(self):
         coords = numpy.empty((self.points1.npoints, self.points2.npoints, self.ndims))
         coords[:, :, :self.points1.ndims] = self.points1.coords[:, _, :]
         coords[:, :, self.points1.ndims:] = self.points2.coords[_, :, :]
         return types.frozenarray(coords.reshape(self.npoints, self.ndims), copy=False)
 
-    @property
+    @cached_property
     def weights(self):
         return types.frozenarray((self.points1.weights[:, _] * self.points2.weights[_, :]).ravel(), copy=False)
 
-    @property
+    @cached_property
     def tri(self):
         if self.points1.npoints == 1:
             return self.points2.tri
         elif self.points2.npoints == 1:
             return self.points1.tri
         elif self.points1.ndims == 1:
             # For an n-dimensional simplex with vertices a0,a1,..,an, the extruded
@@ -179,62 +176,62 @@
             # algorithm below this is achieved by first taking the tensorial product
             # of triangulations and raveling, effectively achieving vectorized
             # concatenation. The overlapping vertex subsets then follow directly from
             # numeric.overlapping.
             tri12 = self.points1.tri[:, _, :, _] * self.points2.npoints + self.points2.tri[_, :, _, :]  # ntri1 x ntri2 x 2 x ndims
             return types.frozenarray(numeric.overlapping(tri12.reshape(-1, 2*self.ndims), n=self.ndims+1).reshape(-1, self.ndims+1), copy=False)
         else:
-            return super().tri
+            return super().tri.func()
 
-    @property
+    @cached_property
     def hull(self):
         if self.points1.npoints == 1:
             return self.points2.hull
         elif self.points2.npoints == 1:
             return self.points1.hull
         elif self.points1.ndims == 1:
             hull1 = self.points1.hull[:, _, :, _] * self.points2.npoints + self.points2.tri[_, :, _, :]  # 2 x ntri2 x 1 x ndims
             hull2 = self.points1.tri[:, _, :, _] * self.points2.npoints + self.points2.hull[_, :, _, :]  # ntri1 x nhull2 x 2 x ndims-1
             # The subdivision of hull2 into simplices follows identical logic to that
             # used in the construction of self.tri.
             hull = numpy.concatenate([hull1.reshape(-1, self.ndims), numeric.overlapping(hull2.reshape(-1, 2*(self.ndims-1)), n=self.ndims).reshape(-1, self.ndims)])
             return types.frozenarray(hull, copy=False)
         else:
-            return super().hull
+            return super().hull.func()
 
     def product(self, other):
         return self.points1.product(self.points2.product(other))
 
 
 class SimplexGaussPoints(CoordsWeightsPoints):
     '''Gauss quadrature points on a simplex.'''
 
-    @types.apply_annotations
-    def __init__(self, ndims: types.strictint, degree: types.strictint):
+    def __init__(self, ndims: Integral, degree: Integral):
+        assert isinstance(ndims, Integral), f'ndims={ndims!r}'
+        assert isinstance(degree, Integral), f'degree={degree!r}'
         super().__init__(*gaussn[ndims](degree))
 
 
 class SimplexBezierPoints(CoordsUniformPoints):
     '''Bezier points on a simplex.'''
 
-    __cache__ = 'tri'
-
-    @types.apply_annotations
-    def __init__(self, ndims: types.strictint, n: types.strictint):
+    def __init__(self, ndims: Integral, n: Integral):
+        assert isinstance(ndims, Integral), f'ndims={ndims!r}'
+        assert isinstance(n, Integral), f'n={n!r}'
         self.n = n
         self._indices = numpy.array([index[::-1] for index in numpy.ndindex(*[n] * ndims) if sum(index) < n])
-        super().__init__(self._indices/(n-1), 1/math.factorial(ndims))
+        super().__init__(types.arraydata(self._indices/(n-1)), 1/math.factorial(ndims))
 
     @property
     def _indexgrid(self):
         grid = numpy.full([self.n]*self.ndims, self.npoints, dtype=int)  # initialize with out of bounds
         grid[tuple(self._indices.T)] = numpy.arange(self.npoints)
         return grid
 
-    @property
+    @cached_property
     def tri(self):
         if self.n == 2:
             tri = numpy.arange(self.npoints)[_]
         elif self.ndims == 1:
             tri = numeric.overlapping(self._indexgrid)
         elif self.ndims == 2:
             grid = self._indexgrid
@@ -249,34 +246,33 @@
                 [bba, abb, bab, aab],  # 3-6: arbitrarily connected to vertex aab
                 [baa, bab, bba, aab],
                 [bba, aba, baa, aab],
                 [aba, abb, bba, aab]])
             ws, wx, wy, wz = (tri < self.npoints).all(axis=1).nonzero()
             tri = tri[ws, :, wx, wy, wz]  # remove all x+y+z>1 simplices
         else:
-            return super().tri
+            return super().tri.func()
         return types.frozenarray(tri, copy=False)
 
 
 class TransformPoints(Points):
     '''Affinely transformed Points.'''
 
-    __cache__ = 'coords', 'weights'
-
-    @types.apply_annotations
-    def __init__(self, points: strictpoints, trans: transform.stricttransformitem):
+    def __init__(self, points: Points, trans: transform.TransformItem):
+        assert isinstance(points, Points), f'points={points!r}'
+        assert isinstance(trans, transform.TransformItem), f'trans={trans!r}'
         self.points = points
         self.trans = trans
         super().__init__(points.npoints, points.ndims)
 
-    @property
+    @cached_property
     def coords(self):
         return self.trans.apply(self.points.coords)
 
-    @property
+    @cached_property
     def weights(self):
         return types.frozenarray(self.points.weights * abs(float(self.trans.det)), copy=False)
 
     @property
     def tri(self):
         return self.points.tri
 
@@ -288,45 +284,44 @@
 class ConcatPoints(Points):
     '''Concatenation of several Points objects.
 
     An optional ``duplicates`` argument lists all points that are equal,
     triggering deduplication and resulting in a smaller total point count.
     '''
 
-    __cache__ = 'coords', 'weights', 'tri', 'masks'
-
-    @types.apply_annotations
-    def __init__(self, allpoints: types.tuple[strictpoints], duplicates: frozenset = frozenset()):
+    def __init__(self, allpoints: Tuple[Points,...], duplicates: FrozenSet[Tuple[Tuple[Integral,Integral],...]]):
+        assert isinstance(allpoints, tuple) and all(isinstance(p, Points) for p in allpoints), 'allpoints={allpoints!r}'
+        assert isinstance(duplicates, frozenset) and all(isinstance(d, tuple) and all(isinstance(n, tuple) and len(n) == 2 and all(isinstance(ni, Integral) for ni in n) for n in d) for d in duplicates), f'duplicates={duplicates!r}'
         self.allpoints = allpoints
         self.duplicates = duplicates
         super().__init__(sum(points.npoints for points in allpoints) - sum(len(d)-1 for d in duplicates), allpoints[0].ndims)
 
-    @property
+    @cached_property
     def masks(self):
         masks = [numpy.ones(points.npoints, dtype=bool) for points in self.allpoints]
         for pairs in self.duplicates:
             for i, j in pairs[1:]:
                 masks[i][j] = False
         return tuple(types.frozenarray(m, copy=False) for m in masks)
 
-    @property
+    @cached_property
     def coords(self):
         return types.frozenarray(numpy.concatenate([points.coords[mask] for mask, points in zip(self.masks, self.allpoints)] if self.duplicates else [points.coords for points in self.allpoints]), copy=False)
 
-    @property
+    @cached_property
     def weights(self):
         if not self.duplicates:
             return types.frozenarray(numpy.concatenate([points.weights for points in self.allpoints]), copy=False)
         weights = [points.weights[mask] for mask, points in zip(self.masks, self.allpoints)]
         for pairs in self.duplicates:
             I, J = pairs[0]
             weights[I][self.masks[I][:J].sum()] += sum(self.allpoints[i].weights[j] for i, j in pairs[1:])
         return types.frozenarray(numpy.concatenate(weights), copy=False)
 
-    @property
+    @cached_property
     def tri(self):
         if not self.duplicates:
             offsets = util.cumsum(points.npoints for points in self.allpoints)
             return types.frozenarray(numpy.concatenate([points.tri + offset for offset, points in zip(offsets, self.allpoints)]), copy=False)
         renumber = []
         n = 0
         for mask in self.masks:
@@ -337,57 +332,30 @@
         for pairs in self.duplicates:
             I, J = pairs[0]
             for i, j in pairs[1:]:
                 renumber[i][j] = renumber[I][J]
         return types.frozenarray(numpy.concatenate([renum.take(points.tri) for renum, points in zip(renumber, self.allpoints)]), copy=False)
 
 
-class ConePoints(Points):
-    '''Affinely transformed lower-dimensional points plus tip.
-
-    The point count is incremented by one regardless of the nature of the point
-    set; no effort is made to introduce extra points between base plane and tip.
-    Likewise, the simplex count stays equal, with all simplices obtaining an
-    extra vertex in tip.
-    '''
-
-    __cache__ = 'coords', 'tri'
-
-    @types.apply_annotations
-    def __init__(self, edgepoints: strictpoints, edgeref: transform.stricttransformitem, tip: types.arraydata):
-        self.edgepoints = edgepoints
-        self.edgeref = edgeref
-        self.tip = numpy.asarray(tip)
-        super().__init__(edgepoints.npoints+1, edgepoints.ndims+1)
-
-    @property
-    def coords(self):
-        return types.frozenarray(numpy.concatenate([self.edgeref.apply(self.edgepoints.coords), self.tip[_, :]]), copy=False)
-
-    @property
-    def tri(self):
-        tri = numpy.concatenate([self.edgepoints.tri, [[self.edgepoints.npoints]]*len(self.edgepoints.tri)], axis=1)
-        return types.frozenarray(tri, copy=False)
-
 # UTILITY FUNCTIONS
 
 
 @functools.lru_cache(8)
 def gauss(n):
     k = numpy.arange(n) + 1
     d = k / numpy.sqrt(4*k**2-1)
     x, w = numpy.linalg.eigh(numpy.diagflat(d, -1))  # eigh operates (by default) on lower triangle
-    return types.frozenarray((x+1) * .5, copy=False), types.frozenarray(w[0]**2, copy=False)
+    return types.arraydata((x+1) * .5), types.arraydata(w[0]**2)
 
 
 def gauss1(degree):
     '''Gauss quadrature for line.'''
 
     x, w = gauss(degree//2)
-    return x[:, _], w
+    return x.reshape(*x.shape, 1), w
 
 
 @functools.lru_cache(8)
 def gauss2(degree):
     '''Gauss quadrature for triangle.
 
     Reference: http://www.cs.rpi.edu/~flaherje/pdf/fea6.pdf'''
@@ -422,16 +390,16 @@
         (J, [0.869739794195568, 0.065130102902216], 0.053347235608839),
         (K, [0.638444188569809, 0.312865496004875, 0.048690315425316], 0.077113760890257),
     ]
 
     if degree > 6:
         warnings.warn('inexact integration for polynomial of degree {}'.format(degree))
 
-    return types.frozenarray(numpy.concatenate([numpy.take(c, i) for i, c, w in icw]), copy=False), \
-        types.frozenarray(numpy.concatenate([[w/2] * len(i) for i, c, w in icw]), copy=False)
+    return types.arraydata(numpy.concatenate([numpy.take(c, i) for i, c, w in icw])), \
+        types.arraydata(numpy.concatenate([[w/2] * len(i) for i, c, w in icw]))
 
 
 @functools.lru_cache(8)
 def gauss3(degree):
     '''Gauss quadrature for tetrahedron.
 
     Reference http://www.cs.rpi.edu/~flaherje/pdf/fea6.pdf'''
@@ -480,22 +448,22 @@
         (L, [0.0229177878448171, 0.2319010893971509, 0.5132800333608811], 0.0254426245481023),
         (L, [0.7303134278075384, 0.0379700484718286, 0.1937464752488044], 0.0134324384376852),
     ]
 
     if degree > 7:
         warnings.warn('inexact integration for polynomial of degree {}'.format(degree))
 
-    return types.frozenarray(numpy.concatenate([numpy.take(c, i) for i, c, w in icw]), copy=False), \
-        types.frozenarray(numpy.concatenate([[w/6] * len(i) for i, c, w in icw]), copy=False)
+    return types.arraydata(numpy.concatenate([numpy.take(c, i) for i, c, w in icw])), \
+        types.arraydata(numpy.concatenate([[w/6] * len(i) for i, c, w in icw]))
 
 
 gaussn = None, gauss1, gauss2, gauss3
 
 
 def find_duplicates(allpoints):
     coords = {}
     for i, points in enumerate(allpoints):
         for j in points.onhull.nonzero()[0]:
             coords.setdefault(tuple(points.coords[j]), []).append((i, j))
-    return [tuple(pairs) for pairs in coords.values() if len(pairs) > 1]
+    return frozenset(tuple(pairs) for pairs in coords.values() if len(pairs) > 1)
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/pointsseq.py` & `nutils-8.0/nutils/pointsseq.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 '''Sequences of :class:`~nutils.points.Points`.'''
 
 from . import types, numeric, evaluable
 from .points import Points
+from ._backports import cached_property
 from typing import Tuple, Sequence, Iterable, Iterator, Optional, Union, overload
 import abc
 import itertools
 import numpy
 
 
 class PointsSequence(types.Singleton):
@@ -22,17 +23,14 @@
         The dimension of the point coordinates.
 
     Notes
     -----
     Subclasses must implement :meth:`__len__` and :meth:`get`.
     '''
 
-    __slots__ = 'ndims'
-    __cache__ = 'npoints', 'tri', 'hull'
-
     @staticmethod
     def from_iter(value: Iterable[Points], ndims: int) -> 'PointsSequence':
         '''Create a :class:`PointsSequence` from an iterator.
 
         Parameters
         ----------
         value : iterable of :class:`~nutils.points.Points` objects
@@ -92,15 +90,15 @@
         else:
             return _Empty(ndims)
 
     def __init__(self, ndims: int) -> None:
         self.ndims = ndims
         super().__init__()
 
-    @property
+    @cached_property
     def npoints(self) -> int:
         '''The total number of points in this sequence.'''
 
         return sum(p.npoints for p in self)
 
     def __bool__(self) -> bool:
         '''Return ``bool(self)``.'''
@@ -287,30 +285,30 @@
             # `otheritems` cannot be empty by the above tests.
             merged = _merge_chain(selfitems[-1], otheritems[0])
             if merged:
                 return _balanced_chain(selfitems[:-1] + [merged] + otheritems[1:])
             else:
                 return _balanced_chain(selfitems + otheritems)
 
-    @property
+    @cached_property
     def tri(self) -> numpy.ndarray:
         '''Triangulation of interior.
 
         A two-dimensional integer array with ``ndims+1`` columns, of which every
         row defines a simplex by mapping vertices into the list of points.
         '''
 
         tri = []
         offset = 0
         for points in self:
             tri.append(points.tri + offset)
             offset += points.npoints
         return types.frozenarray(numpy.concatenate(tri) if tri else numpy.zeros((0, self.ndims+1), int), copy=False)
 
-    @property
+    @cached_property
     def hull(self) -> numpy.ndarray:
         '''Triangulation of the exterior hull.
 
         A two-dimensional integer array with ``ndims`` columns, of which every row
         defines a simplex by mapping vertices into the list of points. Note that
         the hull often does contain internal element boundaries as the
         triangulations originating from separate elements are disconnected.
@@ -332,27 +330,23 @@
         if index.ndim != 0 or index.dtype != int:
             raise ValueError('expected an index array with dimension zero and dtype int but got {}'.format(index))
         return _EvaluablePointsFromSequence(self, index).weights
 
 
 class _Empty(PointsSequence):
 
-    __slots__ = ()
-
     def __len__(self) -> int:
         return 0
 
     def get(self, index: int) -> Points:
         raise IndexError('sequence index out of range')
 
 
 class _Plain(PointsSequence):
 
-    __slots__ = 'items'
-
     def __init__(self, items: Tuple[Points, ...], ndims: int) -> None:
         assert len(items), 'inefficient; this should have been `_Empty`'
         assert not all(item == items[0] for item in items), 'inefficient; this should have been `_Uniform`'
         assert all(item.ndims == ndims for item in items), 'not all items have ndims equal to {}'.format(ndims)
         self.items = items
         super().__init__(ndims)
 
@@ -364,17 +358,14 @@
 
     def get(self, index: int) -> Points:
         return self.items[index]
 
 
 class _Uniform(PointsSequence):
 
-    __slots__ = 'item', 'length'
-    __cache__ = 'tri', 'hull'
-
     def __init__(self, item, length):
         assert length >= 0, 'length should be nonnegative'
         assert length > 0, 'inefficient; this should have been `_Empty`'
         self.item = item
         self.length = length
         super().__init__(item.ndims)
 
@@ -414,37 +405,35 @@
             return super().product(other)
 
     def _mk_indices(self, item: numpy.ndarray) -> numpy.ndarray:
         npoints = self.item.npoints
         ind = item[None] + numpy.arange(0, len(self)*npoints, npoints)[:, None, None]
         return types.frozenarray(ind.reshape(len(self)*item.shape[0], item.shape[1]), copy=False)
 
-    @property
+    @cached_property
     def tri(self) -> numpy.ndarray:
         return self._mk_indices(self.item.tri)
 
-    @property
+    @cached_property
     def hull(self) -> numpy.ndarray:
         return self._mk_indices(self.item.hull)
 
     def get_evaluable_coords(self, index: evaluable.Array) -> evaluable.Array:
         if index.ndim != 0 or index.dtype != int:
             raise ValueError('expected an index array with dimension zero and dtype int but got {}'.format(index))
-        return evaluable.Constant(self.item.coords)
+        return evaluable.constant(self.item.coords)
 
     def get_evaluable_weights(self, index: evaluable.Array) -> evaluable.Array:
         if index.ndim != 0 or index.dtype != int:
             raise ValueError('expected an index array with dimension zero and dtype int but got {}'.format(index))
-        return evaluable.Constant(self.item.weights)
+        return evaluable.constant(self.item.weights)
 
 
 class _Take(PointsSequence):
 
-    __slots__ = 'parent', 'indices'
-
     def __init__(self, parent, indices):
         assert indices.shape[0] > 1, 'inefficient; this should have been `_Empty` or `_Uniform`'
         assert not isinstance(parent, _Uniform), 'inefficient; this should have been `_Uniform`'
         self.parent = parent
         self.indices = numpy.asarray(indices)
         _check_take(len(parent), self.indices)
         super().__init__(parent.ndims)
@@ -465,17 +454,14 @@
     def compress(self, mask: numpy.ndarray) -> PointsSequence:
         _check_compress(len(self), mask)
         return self.parent.take(numpy.compress(mask, self.indices))
 
 
 class _Repeat(PointsSequence):
 
-    __slots__ = 'parent', 'count'
-    __cache__ = 'tri', 'hull'
-
     def __init__(self, parent, count):
         assert count >= 0, 'count should be nonnegative'
         assert count > 0, 'inefficient; this should have been `_Empty`'
         assert not isinstance(parent, _Uniform), 'inefficient; this should have been `_Uniform`'
         self.parent = parent
         self.count = count
         super().__init__(parent.ndims)
@@ -502,29 +488,28 @@
             return _Repeat(self.parent, self.count * count)
 
     def _mk_indices(self, parent: numpy.ndarray) -> numpy.ndarray:
         npoints = self.parent.npoints
         ind = parent[None] + numpy.arange(0, self.count*npoints, npoints)[:, None, None]
         return types.frozenarray(ind.reshape(self.count*parent.shape[0], parent.shape[1]), copy=False)
 
-    @property
+    @cached_property
     def tri(self) -> numpy.ndarray:
         return self._mk_indices(self.parent.tri)
 
-    @property
+    @cached_property
     def hull(self) -> numpy.ndarray:
         return self._mk_indices(self.parent.hull)
 
 
 class _Product(PointsSequence):
 
-    __slots__ = 'sequence1', 'sequence2'
-
-    @types.apply_annotations
-    def __init__(self, sequence1, sequence2):
+    def __init__(self, sequence1: PointsSequence, sequence2: PointsSequence):
+        assert isinstance(sequence1, PointsSequence), f'sequence1={sequence1!r}'
+        assert isinstance(sequence2, PointsSequence), f'sequence2={sequence2!r}'
         assert not (isinstance(sequence1, _Uniform) and isinstance(sequence2, _Uniform)), 'inefficient; this should have been `_Uniform`'
         self.sequence1 = sequence1
         self.sequence2 = sequence2
         super().__init__(sequence1.ndims + sequence2.ndims)
 
     @property
     def npoints(self) -> int:
@@ -542,17 +527,14 @@
 
     def product(self, other: PointsSequence) -> PointsSequence:
         return self.sequence1.product(self.sequence2.product(other))
 
 
 class _Chain(PointsSequence):
 
-    __slots__ = 'sequence1', 'sequence2'
-    __cache__ = 'tri', 'hull'
-
     def __init__(self, sequence1, sequence2):
         assert sequence1.ndims == sequence2.ndims, 'cannot chain sequences with different ndims'
         assert sequence1 and sequence2, 'inefficient; at least one of the sequences is empty'
         assert not _merge_chain(sequence1, sequence2), 'inefficient; this should have been `_Uniform` or `_Repeat`'
         self.sequence1 = sequence1
         self.sequence2 = sequence2
         super().__init__(sequence1.ndims)
@@ -582,21 +564,21 @@
         return self.sequence1.take(numpy.compress(mask, indices)).chain(self.sequence2.take(numpy.compress(~mask, indices) - n))
 
     def compress(self, mask: numpy.ndarray) -> PointsSequence:
         _check_compress(len(self), mask)
         n = len(self.sequence1)
         return self.sequence1.compress(mask[:n]).chain(self.sequence2.compress(mask[n:]))
 
-    @property
+    @cached_property
     def tri(self) -> numpy.ndarray:
         tri1 = self.sequence1.tri
         tri2 = self.sequence2.tri
         return types.frozenarray(numpy.concatenate([tri1, tri2 + self.sequence1.npoints]), copy=False)
 
-    @property
+    @cached_property
     def hull(self) -> numpy.ndarray:
         hull1 = self.sequence1.hull
         hull2 = self.sequence2.hull
         return types.frozenarray(numpy.concatenate([hull1, hull2 + self.sequence1.npoints]), copy=False)
 
 
 def _unchain(seq: PointsSequence) -> Iterator[PointsSequence]:
@@ -656,26 +638,26 @@
         raise IndexError('expected an array with length {} but got {}'.format(length, len(mask)))
 
 
 class _EvaluablePointsFromSequence(evaluable.Evaluable):
 
     def __init__(self, seq: PointsSequence, index: evaluable.Array) -> None:
         self._seq = seq
-        super().__init__(args=[index])
+        super().__init__(args=(index,))
 
     def evalf(self, index: numpy.ndarray) -> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]:
         pnts = self._seq.get(index.__index__())
         return pnts.coords, getattr(pnts, 'weights', None), numpy.array(pnts.npoints)
 
     @property
     def coords(self) -> evaluable.Array:
-        return evaluable.ArrayFromTuple(self, index=0, shape=(self.npoints, self._seq.ndims), dtype=float)
+        return evaluable.ArrayFromTuple(self, index=0, shape=(self.npoints, evaluable.constant(self._seq.ndims)), dtype=float)
 
     @property
     def weights(self) -> evaluable.Array:
         return evaluable.ArrayFromTuple(self, index=1, shape=(self.npoints,), dtype=float)
 
     @property
     def npoints(self) -> evaluable.Array:
         return evaluable.ArrayFromTuple(self, index=2, shape=(), dtype=int, _lower=0)
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/sample.py` & `nutils-8.0/nutils/sample.py`

 * *Files 23% similar despite different names*

```diff
@@ -11,37 +11,30 @@
 connectivity through its :attr:`Sample.tri` and :attr:`Sample.hull`
 properties, representing a (n-dimensional) triangulation of the interior and
 boundary, respectively. Availability of these properties depends on the
 selected sample points, and is typically used in combination with the "bezier"
 set.
 '''
 
-from . import types, points, util, function, evaluable, parallel, matrix, sparse, warnings
+from . import types, _util as util, function, evaluable, warnings
 from .pointsseq import PointsSequence
 from .transformseq import Transforms
-from .transform import EvaluableTransformChain
+from ._backports import cached_property
 from typing import Iterable, Mapping, Optional, Sequence, Tuple, Union
 import numpy
 import numbers
-import collections.abc
 import os
 import treelog as log
 import abc
 
 _PointsShape = Tuple[evaluable.Array, ...]
-_TransformChainsMap = Mapping[str, Tuple[EvaluableTransformChain, EvaluableTransformChain]]
+_TransformChainsMap = Mapping[str, Tuple[Tuple[Transforms, ...], int]]
 _CoordinatesMap = Mapping[str, evaluable.Array]
 
 
-def argdict(arguments) -> Mapping[str, numpy.ndarray]:
-    if len(arguments) == 1 and 'arguments' in arguments and isinstance(arguments['arguments'], collections.abc.Mapping):
-        return arguments['arguments']
-    return arguments
-
-
 class Sample(types.Singleton):
     '''Collection of points on a topology.
 
     The :class:`Sample` class represents a collection of discrete points on a
     topology and is typically formed via :func:`nutils.topology.Topology.sample`.
     Any function evaluation starts from this sampling step, which drops element
     information and other topological properties such as boundaries and groups,
@@ -52,16 +45,14 @@
     Besides the location of points, ``Sample`` also keeps track of point
     connectivity through its :attr:`tri` and :attr:`hull` properties,
     representing a (n-dimensional) triangulation of the interior and boundary,
     respectively. Availability of these properties depends on the selected sample
     points, and is typically used in combination with the "bezier" set.
     '''
 
-    __slots__ = 'spaces', 'ndims', 'nelems', 'npoints'
-
     @staticmethod
     def new(space: str, transforms: Iterable[Transforms], points: PointsSequence, index: Optional[Union[numpy.ndarray, Sequence[numpy.ndarray]]] = None) -> 'Sample':
         '''Create a new :class:`Sample`.
 
         Parameters
         ----------
         transforms : :class:`tuple` or transformation chains
@@ -156,107 +147,121 @@
         '''
 
         raise NotImplementedError
 
     def get_evaluable_weights(self, __ielem: evaluable.Array) -> evaluable.Array:
         raise NotImplementedError
 
-    def update_lower_args(self, __ielem: evaluable.Array, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> Tuple[_PointsShape, _TransformChainsMap, _CoordinatesMap]:
+    def get_lower_args(self, __ielem: evaluable.Array) -> function.LowerArgs:
         raise NotImplementedError
 
-    @util.positional_only
     @util.single_or_multiple
-    def integrate(self, funcs: Iterable[function.IntoArray], arguments: Mapping[str, numpy.ndarray] = ...) -> Tuple[numpy.ndarray, ...]:
+    @util.positional_only
+    def integrate(self, funcs, arguments=...):
         '''Integrate functions.
 
         Args
         ----
         funcs : :class:`nutils.function.Array` object or :class:`tuple` thereof.
             The integrand(s).
         arguments : :class:`dict` (default: None)
             Optional arguments for function evaluation.
         '''
 
-        funcs, funcscales = zip(*map(function.Array.cast_withscale, funcs))
-        datas = self.integrate_sparse(funcs, argdict(arguments))
-        with log.iter.fraction('assembling', datas) as items:
-            return tuple(_convert(data, inplace=True) * scale for data, scale in zip(items, funcscales))
+
+        return function.evaluate(*map(self.integral, funcs), _post=function._convert, arguments=arguments)
 
     @util.single_or_multiple
-    def integrate_sparse(self, funcs: Iterable[function.IntoArray], arguments: Optional[Mapping[str, numpy.ndarray]] = None) -> Tuple[numpy.ndarray, ...]:
+    @util.positional_only
+    def integrate_sparse(self, funcs, arguments=...):
         '''Integrate functions into sparse data.
 
         Args
         ----
         funcs : :class:`nutils.function.Array` object or :class:`tuple` thereof.
             The integrand(s).
         arguments : :class:`dict` (default: None)
             Optional arguments for function evaluation.
         '''
 
-        return evaluable.eval_sparse(map(self.integral, funcs), **(arguments or {}))
+        return function.evaluate(*map(self.integral, funcs), _post=lambda x: x, arguments=arguments)
 
     def integral(self, __func: function.IntoArray) -> function.Array:
         '''Create Integral object for postponed integration.
 
         Args
         ----
         func : :class:`nutils.function.Array`
             Integrand.
         '''
 
-        func, funcscale = function.Array.cast_withscale(__func)
-        return _Integral(func, self) * funcscale
+        return function.integral(__func, self)
 
-    @util.positional_only
     @util.single_or_multiple
-    def eval(self, funcs: Iterable[function.IntoArray], arguments: Mapping[str, numpy.ndarray] = ...) -> Tuple[numpy.ndarray, ...]:
+    @util.positional_only
+    def eval(self, funcs, arguments=...):
         '''Evaluate function.
 
         Args
         ----
         funcs : :class:`nutils.function.Array` object or :class:`tuple` thereof.
             The integrand(s).
         arguments : :class:`dict` (default: None)
             Optional arguments for function evaluation.
         '''
 
-        funcs, funcscales = zip(*map(function.Array.cast_withscale, funcs))
-        datas = self.eval_sparse(funcs, arguments)
-        with log.iter.fraction('assembling', datas) as items:
-            return tuple(sparse.toarray(data) * funcscale for data, funcscale in zip(datas, funcscales))
+        return function.evaluate(*map(self, funcs), arguments=arguments)
 
-    @util.positional_only
     @util.single_or_multiple
-    def eval_sparse(self, funcs: Iterable[function.IntoArray], arguments: Optional[Mapping[str, numpy.ndarray]] = None) -> Tuple[numpy.ndarray, ...]:
+    @util.positional_only
+    def eval_sparse(self, funcs, arguments=...):
         '''Evaluate function.
 
         Args
         ----
         funcs : :class:`nutils.function.Array` object or :class:`tuple` thereof.
             The integrand(s).
         arguments : :class:`dict` (default: None)
             Optional arguments for function evaluation.
         '''
 
-        return evaluable.eval_sparse(map(self, funcs), **(arguments or {}))
+        return function.evaluate(*map(self, funcs), _post=lambda x: x, arguments=arguments)
+
+    def _integral(self, func: function.Array) -> function.Array:
+        '''Create Integral object for postponed integration.
+
+        Args
+        ----
+        func : :class:`nutils.function.Array`
+            Integrand.
+        '''
+
+        return _Integral(func, self)
 
     def __call__(self, __func: function.IntoArray) -> function.Array:
-        func, funcscale = function.Array.cast_withscale(__func)
+        return function.sample(__func, self)
+
+    def _sample(self, func: function.Array) -> function.Array:
         ielem = evaluable.loop_index('_sample_' + '_'.join(self.spaces), self.nelems)
         indices = evaluable.loop_concatenate(evaluable._flat(self.get_evaluable_indices(ielem)), ielem)
-        return _ReorderPoints(_ConcatenatePoints(func, self), indices) * funcscale
+        return _ReorderPoints(_ConcatenatePoints(func, self), indices)
 
-    def basis(self) -> function.Array:
+    def basis(self, interpolation: str = 'none') -> function.Array:
         '''Basis-like function that for every point in the sample evaluates to the
-        unit vector corresponding to its index.'''
+        unit vector corresponding to its index.
+
+        Args
+        ----
+        interpolation : :class:`str`
+            Same as in :meth:`asfunction`.
+        '''
 
         raise NotImplementedError
 
-    def asfunction(self, array: numpy.ndarray) -> function.Array:
+    def asfunction(self, array: numpy.ndarray, interpolation: str = 'none') -> function.Array:
         '''Convert sampled data to evaluable array.
 
         Using the result of :func:`Sample.eval`, create a sampled array that upon
         evaluation recovers the original function in the set of points matching the
         original sampling.
 
         >>> from nutils import mesh
@@ -267,17 +272,21 @@
         >>> domain.integrate(sampled, degree=2)
         array([ 1.,  2.])
 
         Args
         ----
         array :
             The sampled data.
+        interpolation : :class:`str`
+            Interpolation scheme used to map sample values to the evaluating
+            sample. Valid values are "none", demanding that the evaluating
+            sample mathes self, or "nearest" for nearest-neighbour mapping.
         '''
 
-        return function.matmat(self.basis(), array)
+        return function.matmat(self.basis(interpolation=interpolation), array)
 
     @property
     def tri(self) -> numpy.ndarray:
         '''Triangulation of interior.
 
         A two-dimensional integer array with ``ndims+1`` columns, of which every
         row defines a simplex by mapping vertices into the list of points.
@@ -367,16 +376,14 @@
         '''
 
         return _Zip(*samples)
 
 
 class _TransformChainsSample(Sample):
 
-    __slots__ = 'space', 'transforms', 'points'
-
     def __init__(self, space: str, transforms: Tuple[Transforms, ...], points: PointsSequence) -> None:
         '''
         parameters
         ----------
         space : ::class:`str`
             The name of the space on which this sample is defined.
         transforms : :class:`tuple` or transformation chains
@@ -392,32 +399,19 @@
         self.transforms = transforms
         self.points = points
         super().__init__((space,), transforms[0].fromdims, len(points), points.npoints)
 
     def get_evaluable_weights(self, __ielem: evaluable.Array) -> evaluable.Array:
         return self.points.get_evaluable_weights(__ielem)
 
-    def update_lower_args(self, __ielem: evaluable.Array, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> Tuple[_PointsShape, _TransformChainsMap, _CoordinatesMap]:
-        if self.space in transform_chains or self.space in coordinates:
-            raise ValueError('Nested integrals or samples in the same space are not supported.')
-
-        transform_chains = dict(transform_chains)
-        transform_chains[self.space] = space_transform_chains = tuple(t.get_evaluable(__ielem) for t in (self.transforms*2)[:2])
-
-        space_coordinates = self.points.get_evaluable_coords(__ielem)
-        assert space_coordinates.ndim == 2  # axes: points, coord dim
-        coordinates = {space: evaluable.Transpose.to_end(evaluable.appendaxes(coords, space_coordinates.shape[:-1]), coords.ndim - 1) for space, coords in coordinates.items()}
-        coordinates[self.space] = evaluable.prependaxes(space_coordinates, points_shape)
+    def get_lower_args(self, __ielem: evaluable.Array) -> function.LowerArgs:
+        return function.LowerArgs.for_space(self.space, self.transforms, __ielem, self.points.get_evaluable_coords(__ielem))
 
-        points_shape = points_shape + space_coordinates.shape[:-1]
-
-        return points_shape, transform_chains, coordinates
-
-    def basis(self) -> function.Array:
-        return _Basis(self)
+    def basis(self, interpolation: str = 'none') -> function.Array:
+        return _Basis(self, interpolation)
 
     def subset(self, mask: numpy.ndarray) -> Sample:
         selection = types.frozenarray([ielem for ielem in range(self.nelems) if mask[self.getindex(ielem)].any()])
         transforms = tuple(transform[selection] for transform in self.transforms)
         return Sample.new(self.space, transforms, self.points.take(selection))
 
     def get_element_tri(self, ielem: int) -> numpy.ndarray:
@@ -429,18 +423,15 @@
         if not 0 <= ielem < self.nelems:
             raise IndexError('index ouf of range')
         return self.points.get(ielem).hull
 
 
 class _DefaultIndex(_TransformChainsSample):
 
-    __slots__ = ()
-    __cache__ = 'offsets'
-
-    @property
+    @cached_property
     def offsets(self) -> numpy.ndarray:
         return types.frozenarray(numpy.cumsum([0]+[p.npoints for p in self.points]), copy=False)
 
     def getindex(self, ielem: int) -> numpy.ndarray:
         if not 0 <= ielem < self.nelems:
             raise IndexError('index out of range')
         return types.frozenarray(numpy.arange(*self.offsets[ielem:ielem+2]), copy=False)
@@ -454,34 +445,32 @@
         return self.points.hull
 
     def get_evaluable_indices(self, ielem: evaluable.Array) -> evaluable.Array:
         npoints = self.points.get_evaluable_coords(ielem).shape[0]
         offset = evaluable.get(_offsets(self.points), 0, ielem)
         return evaluable.Range(npoints) + offset
 
-    def __call__(self, __func: function.IntoArray) -> function.Array:
-        func, funcscale = function.Array.cast_withscale(__func)
-        return _ConcatenatePoints(func, self) * funcscale
+    def _sample(self, func: function.Array) -> function.Array:
+        return _ConcatenatePoints(func, self)
 
 
 class _CustomIndex(_TransformChainsSample):
 
-    __slots__ = '_parent', '_index'
-
-    def __init__(self, parent: Sample, index: numpy.ndarray) -> None:
+    def __init__(self, parent: Sample, index: types.arraydata) -> None:
+        assert isinstance(index, types.arraydata)
         assert index.shape == (parent.npoints,)
         self._parent = parent
         self._index = index
         super().__init__(parent.space, parent.transforms, parent.points)
 
     def getindex(self, ielem: int) -> numpy.ndarray:
         return numpy.take(self._index, self._parent.getindex(ielem))
 
     def get_evaluable_indices(self, ielem: evaluable.Array) -> evaluable.Array:
-        return evaluable.Take(self._index, self._parent.get_evaluable_indices(ielem))
+        return evaluable.Take(evaluable.Constant(self._index), self._parent.get_evaluable_indices(ielem))
 
     @property
     def tri(self) -> numpy.ndarray:
         return numpy.take(self._index, self._parent.tri)
 
     @property
     def hull(self) -> numpy.ndarray:
@@ -499,26 +488,26 @@
 
         def get_evaluable_indices(self, __ielem: evaluable.Array) -> evaluable.Array:
             raise SkipTest('`{}` does not implement `Sample.get_evaluable_indices`'.format(type(self).__qualname__))
 
         def get_evaluable_weights(self, __ielem: evaluable.Array) -> evaluable.Array:
             raise SkipTest('`{}` does not implement `Sample.get_evaluable_weights`'.format(type(self).__qualname__))
 
-        def update_lower_args(self, __ielem: evaluable.Array, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> Tuple[_PointsShape, _TransformChainsMap, _CoordinatesMap]:
-            raise SkipTest('`{}` does not implement `Sample.update_lower_args`'.format(type(self).__qualname__))
+        def get_lower_args(self, __ielem: evaluable.Array) -> function.LowerArgs:
+            raise SkipTest('`{}` does not implement `Sample.get_lower_args`'.format(type(self).__qualname__))
 
         @property
         def transforms(self) -> Tuple[Transforms, ...]:
             raise SkipTest('`{}` does not implement `Sample.transforms`'.format(type(self).__qualname__))
 
         @property
         def points(self) -> Tuple[Transforms, ...]:
             raise SkipTest('`{}` does not implement `Sample.points`'.format(type(self).__qualname__))
 
-        def basis(self) -> function.Array:
+        def basis(self, interpolation: str = 'none') -> function.Array:
             raise SkipTest('`{}` does not implement `Sample.basis`'.format(type(self).__qualname__))
 
 else:
     _TensorialSample = Sample
 
 
 class _Empty(_TensorialSample):
@@ -526,40 +515,38 @@
     def __init__(self, spaces: Tuple[str, ...], ndims: int) -> None:
         super().__init__(spaces, ndims, 0, 0)
 
     def getindex(self, __ielem: int) -> numpy.ndarray:
         raise IndexError('index out of range')
 
     def get_evaluable_indices(self, __ielem: evaluable.Array) -> evaluable.Array:
-        return evaluable.Zeros((0,) * len(self.spaces), dtype=int)
+        return evaluable.Zeros((evaluable.constant(0),) * len(self.spaces), dtype=int)
 
     def get_evaluable_weights(self, __ielem: evaluable.Array) -> evaluable.Array:
-        return evaluable.Zeros((0,) * len(self.spaces), dtype=float)
+        return evaluable.Zeros((evaluable.constant(0),) * len(self.spaces), dtype=float)
 
-    def update_lower_args(self, __ielem: evaluable.Array, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> Tuple[_PointsShape, _TransformChainsMap, _CoordinatesMap]:
-        return points_shape, transform_chains, coordinates
+    def get_lower_args(self, __ielem: evaluable.Array) -> function.LowerArgs:
+        return function.LowerArgs((), {}, {})
 
     def get_element_tri(self, ielem: int) -> numpy.ndarray:
         raise IndexError('index out of range')
 
     def get_element_hull(self, ielem: int) -> numpy.ndarray:
         raise IndexError('index out of range')
 
     def take_elements(self, __indices: numpy.ndarray) -> Sample:
         return self
 
-    def integral(self, __func: function.IntoArray) -> function.Array:
-        func = function.Array.cast(__func)
+    def _integral(self, func: function.Array) -> function.Array:
         return function.zeros(func.shape, func.dtype)
 
-    def __call__(self, __func: function.IntoArray) -> function.Array:
-        func, funcscale = function.Array.cast_withscale(__func)
-        return function.zeros((0, *func.shape), func.dtype) * funcscale
+    def _sample(self, func: function.Array) -> function.Array:
+        return function.zeros((0, *func.shape), func.dtype)
 
-    def basis(self) -> function.Array:
+    def basis(self, interpolation: str = 'none') -> function.Array:
         return function.zeros((0,), float)
 
 
 class _Add(_TensorialSample):
 
     def __init__(self, sample1: Sample, sample2: Sample) -> None:
         assert sample1.spaces == sample2.spaces
@@ -595,19 +582,19 @@
 
     def take_elements(self, __indices: numpy.ndarray) -> Sample:
         mask = numpy.less(__indices, self._sample1.nelems)
         sample1 = self._sample1.take_elements(__indices[mask])
         sample2 = self._sample2.take_elements(__indices[~mask] - self._sample1.nelems)
         return sample1 + sample2
 
-    def integral(self, func: function.IntoArray) -> function.Array:
+    def _integral(self, func: function.Array) -> function.Array:
         return self._sample1.integral(func) + self._sample2.integral(func)
 
-    def __call__(self, func: function.IntoArray) -> function.Array:
-        return function.concatenate([self._sample1(func), self._sample2(func)])
+    def _sample(self, func: function.Array) -> function.Array:
+        return numpy.concatenate([self._sample1(func), self._sample2(func)])
 
 
 def _simplex_strip(strip):
     # Helper function that creates simplices for an extruded simplex, with
     # vertices arranged in a [2,n] shape (prepended with an arbitrary number of
     # axes). The Strategy is to create the first simplex from the first vertex
     # in layer 1 and all vertices from layer 2, the second from all but the
@@ -712,18 +699,17 @@
 
     def get_evaluable_weights(self, __ielem: evaluable.Array) -> evaluable.Array:
         ielem1, ielem2 = evaluable.divmod(__ielem, self._sample2.nelems)
         weights1 = self._sample1.get_evaluable_weights(ielem1)
         weights2 = self._sample2.get_evaluable_weights(ielem2)
         return evaluable.einsum('A,B->AB', weights1, weights2)
 
-    def update_lower_args(self, __ielem: evaluable.Array, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> Tuple[_PointsShape, _TransformChainsMap, _CoordinatesMap]:
+    def get_lower_args(self, __ielem: evaluable.Array) -> function.LowerArgs:
         ielem1, ielem2 = evaluable.divmod(__ielem, self._sample2.nelems)
-        points_shape, transform_chains, coordinates = self._sample1.update_lower_args(ielem1, points_shape, transform_chains, coordinates)
-        return self._sample2.update_lower_args(ielem2, points_shape, transform_chains, coordinates)
+        return self._sample1.get_lower_args(ielem1) | self._sample2.get_lower_args(ielem2)
 
     @property
     def _reversed_factors(self):
         # Helper method that generates the factors of arbitrarily nested
         # multiplications in reverse order.
 
         for s in self._sample2, self._sample1:
@@ -796,24 +782,25 @@
     def tri(self) -> numpy.ndarray:
         return self._tri_hull(with_hull=False)[0]
 
     @property
     def hull(self) -> numpy.ndarray:
         return self._tri_hull(with_hull=True)[1]
 
-    def integral(self, func: function.IntoArray) -> function.Array:
+    def _integral(self, func: function.Array) -> function.Array:
         return self._sample1.integral(self._sample2.integral(func))
 
-    def __call__(self, func: function.IntoArray) -> function.Array:
-        return function.ravel(self._sample1(self._sample2(func)), axis=0)
+    def _sample(self, func: function.Array) -> function.Array:
+        return numpy.reshape(self._sample1(self._sample2(func)), (-1, *func.shape))
 
-    def basis(self) -> Sample:
-        basis1 = self._sample1.basis()
-        basis2 = self._sample2.basis()
-        return function.ravel(basis1[:, None] * basis2[None, :], axis=0)
+    def basis(self, interpolation: str = 'none') -> Sample:
+        basis1 = self._sample1.basis(interpolation)
+        basis2 = self._sample2.basis(interpolation)
+        assert basis1.ndim == basis2.ndim == 1
+        return numpy.ravel(basis1[:, None] * basis2[None, :])
 
 
 class _Zip(Sample):
 
     def __init__(self, *samples):
         npoints = samples[0].npoints
         spaces = util.sum(sample.spaces for sample in samples)
@@ -831,90 +818,89 @@
                 indices = sample.getindex(ielem)
                 ielems[isample, indices] = ielem
                 ilocals[isample, indices] = numpy.arange(indices.shape[0])
 
         nelems = tuple(sample.nelems for sample in samples)
         flat_ielems = numpy.ravel_multi_index(ielems, nelems)
         flat_ielems, inverse, sizes = numpy.unique(flat_ielems, return_inverse=True, return_counts=True)
-        self._offsets = types.frozenarray(numpy.cumsum([0, *sizes]), copy=False)
-        self._sizes = types.frozenarray(sizes, copy=False)
-        self._indices = types.frozenarray(numpy.argsort(inverse), copy=False)
-        self._ielems = tuple(types.frozenarray(array, copy=False) for array in numpy.unravel_index(flat_ielems, nelems))
-        self._ilocals = types.frozenarray(numpy.take(ilocals, self._indices, axis=1), copy=False)
+        self._offsets = types.arraydata(numpy.cumsum([0, *sizes]))
+        self._sizes = types.arraydata(sizes)
+        self._indices = types.arraydata(numpy.argsort(inverse))
+        self._ielems = tuple(types.arraydata(array) for array in numpy.unravel_index(flat_ielems, nelems))
+        self._ilocals = tuple(types.arraydata(numpy.take(ilocal, self._indices, axis=0)) for ilocal in ilocals)
 
-        super().__init__(spaces=spaces, ndims=samples[0].ndims, nelems=len(self._sizes), npoints=npoints)
+        super().__init__(spaces=spaces, ndims=samples[0].ndims, nelems=self._sizes.shape[0], npoints=npoints)
 
     def getindex(self, ielem):
-        return self._indices[self._offsets[ielem]:self._offsets[ielem+1]]
+        return numpy.asarray(self._indices)[slice(*numpy.asarray(self._offsets)[ielem:ielem+2])]
+
+    def _getslice(self, ielem):
+        return evaluable.Take(evaluable.Constant(self._offsets), ielem) + evaluable.Range(evaluable.Take(evaluable.Constant(self._sizes), ielem))
 
-    def _getslice(self, array, ielem):
-        s = evaluable.Take(self._offsets, ielem) + evaluable.Range(evaluable.Take(self._sizes, ielem))
-        return evaluable.Take(array, s)
-
-    def update_lower_args(self, ielem, points_shape, transform_chains, coordinates):
-        if set(self.spaces) & set(transform_chains):
-            raise ValueError('Nested integrals or samples in the same space are not supported.')
-        size = evaluable.Take(self._sizes, ielem)
-        coordinates = {space: evaluable.insertaxis(coords, -2, size) for space, coords in coordinates.items()}
+    def get_lower_args(self, __ielem: evaluable.Array) -> function.LowerArgs:
+        points_shape = evaluable.Take(evaluable.Constant(self._sizes), __ielem),
+        coordinates = {}
+        transform_chains = {}
         for samplei, ielemsi, ilocalsi in zip(self._samples, self._ielems, self._ilocals):
-            _, transform_chains, coordinatesi = samplei.update_lower_args(evaluable.Take(ielemsi, ielem), (), transform_chains, {})
-            for space, coords in coordinatesi.items():
-                coordinates[space] = evaluable.prependaxes(evaluable._take(coords, self._getslice(ilocalsi, ielem), axis=0), points_shape)
-        return (*points_shape, size), transform_chains, coordinates
+            argsi = samplei.get_lower_args(evaluable.Take(evaluable.Constant(ielemsi), __ielem))
+            slicei = evaluable.Take(evaluable.Constant(ilocalsi), self._getslice(__ielem))
+            transform_chains.update(argsi.transform_chains)
+            coordinates.update({space: evaluable._take(coords, slicei, axis=0) for space, coords in argsi.coordinates.items()})
+        return function.LowerArgs(points_shape, transform_chains, coordinates)
 
     def get_evaluable_indices(self, ielem):
-        return self._getslice(self._indices, ielem)
+        return evaluable.Take(evaluable.Constant(self._indices), self._getslice(ielem))
 
     def get_evaluable_weights(self, ielem):
-        ielem0 = evaluable.Take(self._ielems[0], ielem)
-        slice0 = self._getslice(self._ilocals[0], ielem)
+        ielem0 = evaluable.Take(evaluable.Constant(self._ielems[0]), ielem)
+        slice0 = evaluable.Take(evaluable.Constant(self._ilocals[0]), self._getslice(ielem))
         weights = self._samples[0].get_evaluable_weights(ielem0)
         return evaluable._take(weights, slice0, axis=0)
 
 
 class _TakeElements(_TensorialSample):
 
-    __cache__ = '_offsets'
-
     def __init__(self, parent: Sample, indices: types.arraydata) -> None:
-        assert indices.ndim == 1 and indices.shape[0]
+        assert isinstance(indices, types.arraydata) and indices.ndim == 1 and indices.shape[0] > 0, f'indices={indices!r}'
         self._parent = parent
-        self._indices = numpy.asarray(indices)
-        super().__init__(parent.spaces, parent.ndims, len(self._indices), self._offsets[-1])
+        self._indices = indices
+        super().__init__(parent.spaces, parent.ndims, self._indices.shape[0], self._offsets[-1])
 
-    @property
+    @cached_property
     def _offsets(self) -> numpy.ndarray:
-        return types.frozenarray(numpy.cumsum([0]+[len(self._parent.getindex(i)) for i in self._indices]))
+        return types.frozenarray(numpy.cumsum([0]+[len(self._parent.getindex(i)) for i in numpy.asarray(self._indices)]))
 
     def getindex(self, ielem: int) -> numpy.ndarray:
         if not 0 <= ielem < self.nelems:
             raise IndexError('index out of range')
         return numpy.arange(self._offsets[ielem], self._offsets[ielem+1])
 
+    def _getshape(self, index):
+        iparent = evaluable.Take(evaluable.Constant(self._indices), index)
+        return self._parent.get_evaluable_indices(iparent).shape
+
     def get_evaluable_indices(self, __ielem: evaluable.Array) -> evaluable.Array:
         i = evaluable.loop_index('_i', self.nelems)
-        iparent = evaluable.Take(self._indices, i)
-        sizes = evaluable.loop_concatenate(evaluable.InsertAxis(self._parent.get_evaluable_indices(iparent).size, 1), i)
+        sizes = evaluable.loop_concatenate(evaluable.InsertAxis(util.product(self._getshape(i)), evaluable.constant(1)), i)
         offsets = evaluable._SizesToOffsets(sizes)
 
-        iparent = evaluable.Take(self._indices, __ielem)
-        shape = self._parent.get_evaluable_indices(iparent).shape
+        shape = self._getshape(__ielem)
         pshape = [shape[-1]]
         for n in reversed(shape[:-1]):
             pshape.insert(0, pshape[0] * n)
         indices = evaluable.Range(pshape[0]) + evaluable.Take(offsets, __ielem)
         for a, b in zip(shape[:-1], pshape[1:]):
             indices = evaluable.Unravel(indices, a, b)
         return indices
 
     def get_evaluable_weights(self, __ielem: evaluable.Array) -> evaluable.Array:
-        return self._parent.get_evaluable_weights(evaluable.Take(self._indices, __ielem))
+        return self._parent.get_evaluable_weights(evaluable.Take(evaluable.Constant(self._indices), __ielem))
 
-    def update_lower_args(self, __ielem: evaluable.Array, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> Tuple[_PointsShape, _TransformChainsMap, _CoordinatesMap]:
-        return self._parent.update_lower_args(evaluable.Take(self._indices, __ielem), points_shape, transform_chains, coordinates)
+    def get_lower_args(self, __ielem: evaluable.Array) -> function.LowerArgs:
+        return self._parent.get_lower_args(evaluable.Take(evaluable.Constant(self._indices), __ielem))
 
     def get_element_tri(self, __ielem: int) -> numpy.ndarray:
         if not 0 <= __ielem < self.nelems:
             raise IndexError('index ouf of range')
         return self._parent.get_element_tri(numpy.take(self._indices, __ielem))
 
     def get_element_hull(self, __ielem: int) -> numpy.ndarray:
@@ -922,16 +908,21 @@
             raise IndexError('index ouf of range')
         return self._parent.get_element_hull(numpy.take(self._indices, __ielem))
 
     def take_elements(self, __indices: numpy.ndarray) -> Sample:
         return self._parent.take_elements(numpy.take(self._indices, __indices))
 
 
-def eval_integrals(*integrals: evaluable.AsEvaluableArray, **arguments: Mapping[str, numpy.ndarray]) -> Tuple[Union[numpy.ndarray, matrix.Matrix], ...]:
-    '''Evaluate integrals.
+@util.positional_only
+def eval_integrals(*integrals: evaluable.AsEvaluableArray, arguments: Mapping[str, numpy.ndarray] = ...) -> Tuple[Union[numpy.ndarray, 'matrix.Matrix'], ...]:
+    '''
+    .. deprecated:: 7.0
+        sample.eval_integrals is deprecated, use function.eval instead
+
+    Evaluate integrals.
 
     Evaluate one or several postponed integrals. By evaluating them
     simultaneously, rather than using :meth:`nutils.function.Array.eval` on each
     integral individually, integrations will be grouped per Sample and jointly
     executed, potentially increasing efficiency.
 
     Args
@@ -942,19 +933,20 @@
         Optional arguments for function evaluation.
 
     Returns
     -------
     results : :class:`tuple` of arrays and/or :class:`nutils.matrix.Matrix` objects.
     '''
 
-    with log.iter.fraction('assembling', evaluable.eval_sparse(integrals, **argdict(arguments))) as retvals:
-        return tuple(_convert(retval, inplace=True) for retval in retvals)
+    warnings.deprecation('sample.eval_integrals_sparse is deprecated, use function.eval instead')
+    return function.evaluate(*integrals, _post=function._convert, arguments=arguments)
 
 
-def eval_integrals_sparse(*integrals: evaluable.AsEvaluableArray, **arguments: Mapping[str, numpy.ndarray]) -> Tuple[numpy.ndarray, ...]:
+@util.positional_only
+def eval_integrals_sparse(*integrals: evaluable.AsEvaluableArray, arguments: Mapping[str, numpy.ndarray] = ...) -> Tuple[numpy.ndarray, ...]:
     '''
     .. deprecated:: 7.0
         sample.eval_integrals_sparse is deprecated, use function.eval_sparse instead
 
     Evaluate integrals into sparse data.
 
     Evaluate one or several postponed integrals. By evaluating them
@@ -970,113 +962,100 @@
         Optional arguments for function evaluation.
 
     Returns
     -------
     results : :class:`tuple` of arrays and/or :class:`nutils.matrix.Matrix` objects.
     '''
 
-    warnings.deprecation('sample.eval_integrals_sparse is deprecated, use evaluable.eval_sparse instead')
-    return evaluable.eval_sparse(integrals, **argdict(arguments))
-
-
-def _convert(data: numpy.ndarray, inplace: bool = False) -> Union[numpy.ndarray, matrix.Matrix]:
-    '''Convert a two-dimensional sparse object to an appropriate object.
-
-    The return type is determined based on dimension: a zero-dimensional object
-    becomes a scalar, a one-dimensional object a (dense) Numpy vector, a
-    two-dimensional object a Nutils matrix, and any higher dimensional object a
-    deduplicated and pruned sparse object.
-    '''
-
-    ndim = sparse.ndim(data)
-    return sparse.toarray(data) if ndim < 2 \
-        else matrix.fromsparse(data, inplace=inplace) if ndim == 2 \
-        else sparse.prune(sparse.dedup(data, inplace=inplace), inplace=True)
+    warnings.deprecation('sample.eval_integrals_sparse is deprecated, use function.eval instead')
+    return function.evaluate(*integrals, _post=lambda x: x, arguments=arguments)
 
 
 class _Integral(function.Array):
 
     def __init__(self, integrand: function.Array, sample: Sample) -> None:
         self._integrand = integrand
         self._sample = sample
         super().__init__(shape=integrand.shape, dtype=float if integrand.dtype in (bool, int) else integrand.dtype, spaces=integrand.spaces - frozenset(sample.spaces), arguments=integrand.arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
+    def lower(self, args: function.LowerArgs) -> evaluable.Array:
         ielem = evaluable.loop_index('_sample_' + '_'.join(self._sample.spaces), self._sample.nelems)
-        points_shape, transform_chains, coordinates = self._sample.update_lower_args(ielem, points_shape, transform_chains, coordinates)
         weights = self._sample.get_evaluable_weights(ielem)
-        integrand = self._integrand.lower(points_shape, transform_chains, coordinates)
+        integrand = self._integrand.lower(args | self._sample.get_lower_args(ielem))
         elem_integral = evaluable.einsum('B,ABC->AC', weights, integrand, B=weights.ndim, C=self.ndim)
         return evaluable.loop_sum(elem_integral, ielem)
 
 
 class _ConcatenatePoints(function.Array):
 
     def __init__(self, func: function.Array, sample: _TransformChainsSample) -> None:
         self._func = func
         self._sample = sample
         super().__init__(shape=(sample.npoints, *func.shape), dtype=func.dtype, spaces=func.spaces - frozenset(sample.spaces), arguments=func.arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        axis = len(points_shape)
+    def lower(self, args: function.LowerArgs) -> evaluable.Array:
+        axis = len(args.points_shape)
         ielem = evaluable.loop_index('_sample_' + '_'.join(self._sample.spaces), self._sample.nelems)
-        points_shape, transform_chains, coordinates = self._sample.update_lower_args(ielem, points_shape, transform_chains, coordinates)
-        func = self._func.lower(points_shape, transform_chains, coordinates)
-        func = evaluable.Transpose.to_end(func, *range(axis, len(points_shape)))
-        for i in range(len(points_shape) - axis - 1):
+        args |= self._sample.get_lower_args(ielem)
+        func = self._func.lower(args)
+        func = evaluable.Transpose.to_end(func, *range(axis, len(args.points_shape)))
+        for i in range(len(args.points_shape) - axis - 1):
             func = evaluable.Ravel(func)
         func = evaluable.loop_concatenate(func, ielem)
         return evaluable.Transpose.from_end(func, axis)
 
 
 class _ReorderPoints(function.Array):
 
     def __init__(self, func: function.Array, indices: evaluable.Array) -> None:
         self._func = func
         self._indices = indices
         assert indices.ndim == 1 and func.shape[0] == indices.shape[0].__index__()
         super().__init__(shape=func.shape, dtype=func.dtype, spaces=func.spaces, arguments=func.arguments)
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        func = self._func.lower(points_shape, transform_chains, coordinates)
-        axis = len(points_shape)
+    def lower(self, args: function.LowerArgs) -> evaluable.Array:
+        func = self._func.lower(args)
+        axis = len(args.points_shape)
         return evaluable.Transpose.from_end(evaluable.Inflate(evaluable.Transpose.to_end(func, axis), self._indices, self._indices.shape[0]), axis)
 
 
 class _Basis(function.Array):
 
-    def __init__(self, sample: _TransformChainsSample) -> None:
+    def __init__(self, sample: _TransformChainsSample, interpolation: str) -> None:
         self._sample = sample
+        if interpolation not in ('none', 'nearest'):
+            raise ValueError(f'invalid interpolation {interpolation!r}; valid values are "none" and "nearest"')
+        self._interpolation = interpolation
         super().__init__(shape=(sample.npoints,), dtype=float, spaces=frozenset({sample.space}), arguments={})
 
-    def lower(self, points_shape: _PointsShape, transform_chains: _TransformChainsMap, coordinates: _CoordinatesMap) -> evaluable.Array:
-        aligned_space_coords = coordinates[self._sample.space]
-        assert aligned_space_coords.ndim == len(points_shape) + 1
+    def lower(self, args: function.LowerArgs) -> evaluable.Array:
+        aligned_space_coords = args.coordinates[self._sample.space]
+        assert aligned_space_coords.ndim == len(args.points_shape) + 1
         space_coords, where = evaluable.unalign(aligned_space_coords)
         # Reinsert the coordinate axis, the last axis of `aligned_space_coords`, or
         # make sure this is the last axis of `space_coords`.
-        if len(points_shape) not in where:
+        if len(args.points_shape) not in where:
             space_coords = evaluable.InsertAxis(space_coords, aligned_space_coords.shape[-1])
             where += len(points_shape),
-        elif where[-1] != len(points_shape):
+        elif where[-1] != len(args.points_shape):
             space_coords = evaluable.Transpose(space_coords, numpy.argsort(where))
             where = tuple(sorted(where))
 
-        chain = transform_chains[self._sample.space][0]
-        index, tail = chain.index_with_tail_in(self._sample.transforms[0])
-        coords = tail.apply(space_coords)
+        (chain, *_), tip_index = args.transform_chains[self._sample.space]
+        index = evaluable.TransformIndex(self._sample.transforms[0], chain, tip_index)
+        coords = evaluable.TransformCoords(self._sample.transforms[0], chain, tip_index, space_coords)
         expect = self._sample.points.get_evaluable_coords(index)
-        sampled = evaluable.Sampled(coords, expect)
+        sampled = evaluable.Sampled(coords, expect, self._interpolation)
         indices = self._sample.get_evaluable_indices(index)
-        basis = evaluable.Inflate(sampled, dofmap=indices, length=self._sample.npoints)
+        basis = evaluable.Inflate(sampled, dofmap=indices, length=evaluable.constant(self._sample.npoints))
 
         # Realign the points axes. The coordinate axis of `aligned_space_coords` is
         # replaced by a dofs axis in the aligned basis, hence we can reuse `where`.
-        return evaluable.align(basis, where, (*points_shape, self._sample.npoints))
+        return evaluable.align(basis, where, (*args.points_shape, evaluable.constant(self._sample.npoints)))
 
 
 def _offsets(pointsseq: PointsSequence) -> evaluable.Array:
     ielem = evaluable.loop_index('_ielem', len(pointsseq))
     npoints, ndims = pointsseq.get_evaluable_coords(ielem).shape
-    return evaluable._SizesToOffsets(evaluable.loop_concatenate(evaluable.InsertAxis(npoints, 1), ielem))
+    return evaluable._SizesToOffsets(evaluable.loop_concatenate(evaluable.InsertAxis(npoints, evaluable.constant(1)), ielem))
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/solver.py` & `nutils-8.0/nutils/solver.py`

 * *Files 12% similar despite different names*

```diff
@@ -26,168 +26,35 @@
 The coefficients ``lhs`` represent the solution to the Poisson problem.
 
 In addition to ``solve_linear`` the solver module defines ``newton`` and
 ``pseudotime`` for solving nonlinear problems, as well as ``impliciteuler`` for
 time dependent problems.
 """
 
-from . import function, evaluable, cache, numeric, types, util, matrix, warnings, sparse
+from . import function, evaluable, cache, numeric, types, _util as util, matrix, warnings, sparse
+from dataclasses import dataclass
 import abc
 import numpy
 import itertools
 import functools
-import numbers
 import collections
 import math
-import inspect
 import treelog as log
 
 
-# TYPE COERCION
-
-argdict = types.frozendict[types.strictstr, types.arraydata]
-
-
-def integraltuple(arg):
-    return tuple(a.as_evaluable_array for a in arg)
-
-
-def optionalintegraltuple(arg):
-    return tuple(None if a is None else a.as_evaluable_array for a in arg)
-
-
-def arrayordict(arg):
-    return types.arraydata(arg) if numeric.isarray(arg) else argdict(arg)
-
-
-# DECORATORS
-
-def single_or_multiple(f):
-    '''add support for legacy string target + array return value'''
-
-    sig = inspect.signature(f)
-    tuple_params = tuple(p.name for p in sig.parameters.values() if p.annotation in (integraltuple, optionalintegraltuple))
-
-    @functools.wraps(f)
-    def wrapper(target, *args, **kwargs):
-        if isinstance(target, str):
-            ba = sig.bind((target,), *args, **kwargs)
-            for name in tuple_params:
-                if name in ba.arguments:
-                    ba.arguments[name] = ba.arguments[name],
-            return f(*ba.args, **ba.kwargs)[target]
-        else:
-            return f(target, *args, **kwargs)
-    return wrapper
-
-
-class iterable:
-    '''iterable equivalent of single_or_multiple'''
-
-    @classmethod
-    def single_or_multiple(cls, wrapped):
-        tuple_params = tuple(p.name for p in inspect.signature(wrapped).parameters.values() if p.annotation in (integraltuple, optionalintegraltuple))
-        return type(wrapped.__name__, (cls,), dict(__wrapped__=wrapped, __doc__=cls.__doc__, _tuple_params=tuple_params))
-
-    def __init__(self, target, *args, **kwargs):
-        self._target = target
-        self._single = isinstance(target, str)
-        if self._single:
-            ba = inspect.signature(self.__wrapped__).bind((target,), *args, **kwargs)
-            for name in self._tuple_params:
-                if name in ba.arguments:
-                    ba.arguments[name] = ba.arguments[name],
-            self._wrapped = self.__wrapped__(*ba.args, **ba.kwargs)
-        else:
-            self._wrapped = self.__wrapped__(target, *args, **kwargs)
-
-    @property
-    def __nutils_hash__(self):
-        return types.nutils_hash(self._wrapped)
-
-    def __iter__(self):
-        return (retval[self._target] for retval in self._wrapped) if self._single else iter(self._wrapped)
-
-
-class withsolve(iterable):
-    '''add a .solve method to (lhs,resnorm) iterators'''
-
-    def __iter__(self):
-        return ((retval[self._target], info) for retval, info in self._wrapped) if self._single else iter(self._wrapped)
-
-    def solve(self, tol=0., maxiter=float('inf')):
-        '''execute nonlinear solver, return lhs
-
-        Iterates over nonlinear solver until tolerance is reached. Example::
-
-            lhs = newton(target, residual).solve(tol=1e-5)
-
-        Parameters
-        ----------
-        tol : :class:`float`
-            Target residual norm
-        maxiter : :class:`int`
-            Maximum number of iterations
-
-        Returns
-        -------
-        :class:`numpy.ndarray`
-            Coefficient vector that corresponds to a smaller than ``tol`` residual.
-        '''
-
-        lhs, info = self.solve_withinfo(tol=tol, maxiter=maxiter)
-        return lhs
-
-    @types.apply_annotations
-    @cache.function
-    def solve_withinfo(self, tol, maxiter=float('inf')):
-        '''execute nonlinear solver, return lhs and info
-
-        Like :func:`solve`, but return a 2-tuple of the solution and the
-        corresponding info object which holds information about the final residual
-        norm and other generator-dependent information.
-        '''
-
-        with log.iter.wrap(_progress(self.__class__.__name__, tol), self) as items:
-            i = 0
-            for lhs, info in items:
-                if info.resnorm <= tol:
-                    break
-                if i > maxiter:
-                    raise SolverError('failed to reach target tolerance')
-                i += 1
-            log.info('converged in {} steps to residual {:.1e}'.format(i, info.resnorm))
-        return lhs, info
-
-
 # EXCEPTIONS
 
 class SolverError(Exception):
     pass
 
 
 # LINE SEARCH
 
-class LineSearch(types.Immutable):
-    '''
-    Line search abstraction for gradient based optimization.
-
-    A line search object is a callable that takes four arguments: the current
-    residual and directional derivative, and the candidate residual and
-    directional derivative, with derivatives normalized to unit length; and
-    returns the optimal scaling and a boolean flag that marks whether the
-    candidate should be accepted.
-    '''
-
-    @abc.abstractmethod
-    def __call__(self, res0, dres0, res1, dres1):
-        raise NotImplementedError
-
-
-class NormBased(LineSearch):
+@dataclass(eq=True, frozen=True)
+class NormBased:
     '''
     Line search abstraction for Newton-like iterations, computing relaxation
     values that correspond to greatest reduction of the residual norm.
 
     Parameters
     ----------
     minscale : :class:`float`
@@ -198,26 +65,34 @@
         to accept the current Newton update. Must lie between minscale and one.
     maxscale : :class:`float`
         Maximum relaxation scaling per update. Must be greater than one, and
         therefore always coincides with acceptance, determining how fast
         relaxation values rebound to one if not bounded by optimality.
     '''
 
-    @types.apply_annotations
-    def __init__(self, minscale: float = .01, acceptscale: float = 2/3, maxscale: float = 2.):
-        assert 0 < minscale < acceptscale < 1 < maxscale
-        self.minscale = minscale
-        self.acceptscale = acceptscale
-        self.maxscale = maxscale
+    minscale: float = .01
+    acceptscale: float = 2/3
+    maxscale: float = 2.
+
+    def __post_init__(self):
+        assert isinstance(self.minscale, float), f'minscale={self.minscale!r}'
+        assert isinstance(self.acceptscale, float), f'acceptscale={self.acceptscale!r}'
+        assert isinstance(self.maxscale, float), f'maxscale={self.maxscale!r}'
+        assert 0 < self.minscale < self.acceptscale < 1 < self.maxscale
 
     @classmethod
     def legacy(cls, kwargs):
-        minscale, acceptscale = kwargs.pop('searchrange', (.01, 2/3))
-        maxscale = kwargs.pop('rebound', 2.)
-        return cls(minscale=minscale, acceptscale=acceptscale, maxscale=maxscale)
+        args = {}
+        if 'searchrange' in kwargs:
+            args['minscale'], args['acceptscale'] = kwargs.pop('searchrange')
+        if 'rebound' in kwargs:
+            args['maxscale'] = kwargs.pop('rebound')
+        if args:
+            warnings.deprecation('the searchrange and rebound arguments are deprecated; use linesearch=solver.NormBased(minscale=searchrange[0], acceptscale=searchrange[1], maxscale=rebound) instead')
+        return cls(**args)
 
     def __call__(self, res0, dres0, res1, dres1):
         if not numpy.isfinite(res1).all():
             log.info('non-finite residual')
             return self.minscale, False
         # To determine optimal relaxation we minimize a polynomial estimation for
         # the residual norm: P(x) = p0 + q0 x + c x^2 + d x^3
@@ -242,15 +117,16 @@
         if scale >= 1 and p1 > p0:  # this should not happen, but just in case
             log.info('failed to estimate scale factor')
             return self.minscale, False
         log.info('estimated residual minimum at {:.0f}% of update vector'.format(scale*100))
         return min(max(scale, self.minscale), self.maxscale), scale >= self.acceptscale and p1 < p0
 
 
-class MedianBased(LineSearch, version=1):
+@dataclass(eq=True, frozen=True)
+class MedianBased:
     '''
     Line search abstraction for Newton-like iterations, computing relaxation
     values such that half (or any other configurable quantile) of the residual
     vector has its optimal reduction beyond it. Unline the :class:`NormBased`
     approach this is invariant to constant scaling of the residual items.
 
     Parameters
@@ -268,22 +144,26 @@
     quantile : :class:`float`
         Fraction of the residual vector that is aimed to have its optimal
         reduction at a smaller relaxation value. The default value of one half
         corresponds to the median. A value close to zero means tighter control,
         resulting in strong relaxation.
     '''
 
-    @types.apply_annotations
-    def __init__(self, minscale: float = .01, acceptscale: float = 2/3, maxscale: float = 2., quantile: float = .5):
-        assert 0 < minscale < acceptscale < 1 < maxscale
-        assert 0 < quantile < 1
-        self.minscale = minscale
-        self.acceptscale = acceptscale
-        self.maxscale = maxscale
-        self.quantile = quantile
+    minscale: float = .01
+    acceptscale: float = 2/3
+    maxscale: float = 2.
+    quantile: float = .5
+
+    def __post_init__(self):
+        assert isinstance(self.minscale, float), f'minscale={self.minscale!r}'
+        assert isinstance(self.acceptscale, float), f'acceptscale={self.acceptscale!r}'
+        assert isinstance(self.maxscale, float), f'maxscale={self.maxscale!r}'
+        assert isinstance(self.quantile, float), f'quantile={self.quantile!r}'
+        assert 0 < self.minscale < self.acceptscale < 1 < self.maxscale
+        assert 0 < self.quantile < 1
 
     def __call__(self, res0, dres0, res1, dres1):
         if not numpy.isfinite(res1).all():
             log.info('non-finite residual')
             return self.minscale, False
         # To determine optimal relaxation we minimize a polynomial estimation for
         # the squared residual: P(x) = p0 + q0 x + c x^2 + d x^3
@@ -309,19 +189,15 @@
             scale = numpy.inf
         log.info('estimated {}-quantile at {:.0f}% of update vector'.format(self.quantile, scale*100))
         return min(max(scale, self.minscale), self.maxscale), scale >= self.acceptscale
 
 
 # SOLVERS
 
-
-@single_or_multiple
-@types.apply_annotations
-@cache.function
-def solve_linear(target, residual: integraltuple, *, constrain: arrayordict = None, lhs0: types.arraydata = None, arguments: argdict = {}, **kwargs):
+def solve_linear(target, residual, *, constrain = None, lhs0: types.arraydata = None, arguments = {}, **kwargs):
     '''solve linear problem
 
     Parameters
     ----------
     target : :class:`str`
         Name of the target: a :class:`nutils.function.Argument` in ``residual``.
     residual : :class:`nutils.evaluable.AsEvaluableArray`
@@ -334,31 +210,44 @@
         Optional.
 
     Returns
     -------
     :class:`numpy.ndarray`
         Array of ``target`` values for which ``residual == 0``'''
 
+    if isinstance(target, str) and ',' not in target and ':' not in target:
+        return solve_linear([target], [residual], constrain={} if constrain is None else {target: constrain},
+            lhs0=lhs0, arguments=arguments if lhs0 is None else {**arguments, target: lhs0}, **kwargs)[target]
+    if lhs0 is not None:
+        raise ValueError('lhs0 argument is invalid for a non-string target; define the initial guess via arguments instead')
+    target, residual = _target_helper(target, residual)
     solveargs = _strip(kwargs, 'lin')
     if kwargs:
         raise TypeError('unexpected keyword arguments: {}'.format(', '.join(kwargs)))
-    lhs0, constrain = _parse_lhs_cons(lhs0, constrain, target, _argobjs(residual), arguments)
-    jacobian = _derivative(residual, target)
-    if not set(target).isdisjoint(_argobjs(jacobian)):
+    return _solve_linear(target, residual,
+        types.frozendict((k, types.arraydata(v)) for k, v in (constrain or {}).items()),
+        types.frozendict((k, types.arraydata(v)) for k, v in (arguments or {}).items()),
+        types.frozendict(solveargs))
+
+
+@cache.function
+def _solve_linear(target, residual: tuple, constraints: dict, arguments: dict, solveargs: dict):
+    arguments, constraints = _parse_lhs_cons(constraints, target, _argobjs(residual), arguments)
+    jacobians = _derivative(residual, target)
+    if not set(target).isdisjoint(_argobjs(jacobians)):
         raise SolverError('problem is not linear')
-    dtype = _determine_dtype(target, residual, lhs0, constrain)
-    lhs, vlhs = _redict(lhs0, target, dtype)
-    mask, vmask = _invert(constrain, target)
-    res, jac = _integrate_blocks(residual, jacobian, arguments=lhs, mask=mask)
+    dtype = _determine_dtype(target, residual, arguments, constraints)
+    lhs, vlhs = _redict(arguments, target, dtype)
+    mask, vmask = _invert(constraints, target)
+    res, jac = _integrate_blocks(residual, jacobians, arguments=lhs, mask=mask)
     vlhs[vmask] -= jac.solve(res, **solveargs)
     return lhs
 
 
-@withsolve.single_or_multiple
-class newton(cache.Recursion, length=1):
+def newton(target, residual, *, jacobian = None, lhs0 = None, relax0: float = 1., constrain = None, linesearch='__legacy__', failrelax: float = 1e-6, arguments = {}, **kwargs):
     '''iteratively solve nonlinear problem by gradient descent
 
     Generates targets such that residual approaches 0 using Newton procedure with
     line search based on the residual norm. Suitable to be used inside ``solve``.
 
     An optimal relaxation value is computed based on the following cubic
     assumption::
@@ -370,53 +259,71 @@
     found to be close to 1 then the newton update is accepted.
 
     Parameters
     ----------
     target : :class:`str`
         Name of the target: a :class:`nutils.function.Argument` in ``residual``.
     residual : :class:`nutils.evaluable.AsEvaluableArray`
-    lhs0 : :class:`numpy.ndarray`
-        Coefficient vector, starting point of the iterative procedure.
     relax0 : :class:`float`
         Initial relaxation value.
     constrain : :class:`numpy.ndarray` with dtype :class:`bool` or :class:`float`
-        Equal length to ``lhs0``, masks the free vector entries as ``False``
-        (boolean) or NaN (float). In the remaining positions the values of
-        ``lhs0`` are returned unchanged (boolean) or overruled by the values in
-        `constrain` (float).
-    linesearch : :class:`nutils.solver.LineSearch`
-        Callable that defines relaxation logic.
+        Masks the free vector entries as ``False`` (boolean) or NaN (float). In
+        the remaining positions the values of ``lhs0`` are returned unchanged
+        (boolean) or overruled by the values in `constrain` (float).
+    linesearch : Callable[[float, float, float, float], Tuple[float, bool]]
+        Callable that defines relaxation logic. The callable takes four
+        arguments: the current residual and directional derivative, and the
+        candidate residual and directional derivative, with derivatives
+        normalized to unit length; and returns the optimal scaling and a
+        boolean flag that marks whether the candidate should be accepted.
     failrelax : :class:`float`
         Fail with exception if relaxation reaches this lower limit.
     arguments : :class:`collections.abc.Mapping`
         Defines the values for :class:`nutils.function.Argument` objects in
-        `residual`.  The ``target`` should not be present in ``arguments``.
-        Optional.
+        `residual`. If ``target`` is present in ``arguments`` then it is used
+        as the initial guess for the iterative procedure.
 
     Yields
     ------
     :class:`numpy.ndarray`
         Coefficient vector that approximates residual==0 with increasing accuracy
     '''
 
-    @types.apply_annotations
-    def __init__(self, target, residual: integraltuple, jacobian: integraltuple = None, lhs0: types.arraydata = None, relax0: float = 1., constrain: arrayordict = None, linesearch=None, failrelax: types.strictfloat = 1e-6, arguments: argdict = {}, **kwargs):
+    if isinstance(target, str) and ',' not in target and ':' not in target:
+        return newton([target], [residual], jacobian=None if jacobian is None else [jacobian],
+            relax0=relax0, constrain={} if constrain is None else {target: constrain}, linesearch=linesearch,
+            failrelax=failrelax, arguments=arguments if lhs0 is None else {**arguments, target: lhs0}, **kwargs)[target]
+    if lhs0 is not None:
+        raise ValueError('lhs0 argument is invalid for a non-string target; define the initial guess via arguments instead')
+    target, residual = _target_helper(target, residual)
+    if linesearch == '__legacy__':
+        linesearch = NormBased.legacy(kwargs)
+    solveargs = _strip(kwargs, 'lin')
+    solveargs.setdefault('rtol', 1e-3)
+    if kwargs:
+        raise TypeError('unexpected keyword arguments: {}'.format(', '.join(kwargs)))
+    return _with_solve(_newton(target, residual, None if jacobian is None else tuple(jacobian),
+        types.frozendict((k, types.arraydata(v)) for k, v in (constrain or {}).items()),
+        types.frozendict((k, types.arraydata(v)) for k, v in (arguments or {}).items()),
+        linesearch, relax0, failrelax, types.frozendict(solveargs)))
+
+
+class _newton(cache.Recursion, length=1):
+
+    def __init__(self, target, residual, jacobian, constrain, arguments, linesearch, relax0: float, failrelax: float, solveargs):
         super().__init__()
         self.target = target
         self.residual = residual
         self.jacobian = _derivative(residual, target, jacobian)
-        self.lhs0, self.constrain = _parse_lhs_cons(lhs0, constrain, target, _argobjs(residual), arguments)
+        self.lhs0, self.constrain = _parse_lhs_cons(constrain, target, _argobjs(residual), arguments)
         self.dtype = _determine_dtype(target, residual, self.lhs0, self.constrain)
         self.relax0 = relax0
-        self.linesearch = linesearch or NormBased.legacy(kwargs)
+        self.linesearch = linesearch
         self.failrelax = failrelax
-        self.solveargs = _strip(kwargs, 'lin')
-        if kwargs:
-            raise TypeError('unexpected keyword arguments: {}'.format(', '.join(kwargs)))
-        self.solveargs.setdefault('rtol', 1e-3)
+        self.solveargs = solveargs
 
     def _eval(self, lhs, mask):
         return _integrate_blocks(self.residual, self.jacobian, arguments=lhs, mask=mask)
 
     def resume(self, history):
         mask, vmask = _invert(self.constrain, self.target)
         if history:
@@ -432,31 +339,31 @@
             yield lhs, types.attributes(resnorm=numpy.linalg.norm(res), relax=relax)
         while True:
             dlhs = -jac.solve_leniently(res, **self.solveargs)  # compute new search vector
             res0 = res
             dres = jac@dlhs  # == -res if dlhs was solved to infinite precision
             vlhs[vmask] += relax * dlhs
             res, jac = self._eval(lhs, mask)
-            scale, accept = self.linesearch(res0, relax*dres, res, relax*(jac@dlhs))
-            while not accept:  # line search
-                assert scale < 1
-                oldrelax = relax
-                relax *= scale
-                if relax <= self.failrelax:
-                    raise SolverError('stuck in local minimum')
-                vlhs[vmask] += (relax - oldrelax) * dlhs
-                res, jac = self._eval(lhs, mask)
+            if self.linesearch:
                 scale, accept = self.linesearch(res0, relax*dres, res, relax*(jac@dlhs))
-            log.info('update accepted at relaxation', round(relax, 5))
-            relax = min(relax * scale, 1)
+                while not accept:  # line search
+                    assert scale < 1
+                    oldrelax = relax
+                    relax *= scale
+                    if relax <= self.failrelax:
+                        raise SolverError('stuck in local minimum')
+                    vlhs[vmask] += (relax - oldrelax) * dlhs
+                    res, jac = self._eval(lhs, mask)
+                    scale, accept = self.linesearch(res0, relax*dres, res, relax*(jac@dlhs))
+                log.info('update accepted at relaxation', round(relax, 5))
+                relax = min(relax * scale, 1)
             yield lhs, types.attributes(resnorm=numpy.linalg.norm(res), relax=relax)
 
 
-@withsolve.single_or_multiple
-class minimize(cache.Recursion, length=1, version=3):
+def minimize(target, energy: evaluable.asarray, *, lhs0: types.arraydata = None, constrain = None, rampup: float = .5, rampdown: float = -1., failrelax: float = -10., arguments = {}, **kwargs):
     '''iteratively minimize nonlinear functional by gradient descent
 
     Generates targets such that residual approaches 0 using Newton procedure with
     line search based on the energy. Suitable to be used inside ``solve``.
 
     An optimal relaxation value is computed based on the following assumption::
 
@@ -467,56 +374,68 @@
     close to 1 then the newton update is accepted.
 
     Parameters
     ----------
     target : :class:`str`
         Name of the target: a :class:`nutils.function.Argument` in ``residual``.
     residual : :class:`nutils.evaluable.AsEvaluableArray`
-    lhs0 : :class:`numpy.ndarray`
-        Coefficient vector, starting point of the iterative procedure.
     constrain : :class:`numpy.ndarray` with dtype :class:`bool` or :class:`float`
-        Equal length to ``lhs0``, masks the free vector entries as ``False``
-        (boolean) or NaN (float). In the remaining positions the values of
-        ``lhs0`` are returned unchanged (boolean) or overruled by the values in
-        `constrain` (float).
+        Masks the free vector entries as ``False`` (boolean) or NaN (float). In
+        the remaining positions the values of ``lhs0`` are returned unchanged
+        (boolean) or overruled by the values in `constrain` (float).
     rampup : :class:`float`
         Value to increase the relaxation power by in case energy is decreasing.
     rampdown : :class:`float`
         Value to decrease the relaxation power by in case energy is increasing.
     failrelax : :class:`float`
         Fail with exception if relaxation reaches this lower limit.
     arguments : :class:`collections.abc.Mapping`
         Defines the values for :class:`nutils.function.Argument` objects in
-        `residual`.  The ``target`` should not be present in ``arguments``.
-        Optional.
+        `residual`. If ``target`` is present in ``arguments`` then it is used
+        as the initial guess for the iterative procedure.
 
     Yields
     ------
     :class:`numpy.ndarray`
         Coefficient vector that approximates residual==0 with increasing accuracy
     '''
 
-    @types.apply_annotations
-    def __init__(self, target, energy: evaluable.asarray, lhs0: types.arraydata = None, constrain: arrayordict = None, rampup: types.strictfloat = .5, rampdown: types.strictfloat = -1., failrelax: types.strictfloat = -10., arguments: argdict = {}, **kwargs):
+    if isinstance(target, str) and ',' not in target:
+        return minimize([target], energy, constrain={} if constrain is None else {target: constrain}, rampup=rampup, rampdown=rampdown,
+            failrelax=failrelax, arguments=arguments if lhs0 is None else {**arguments, target: lhs0}, **kwargs)[target]
+    if lhs0 is not None:
+        raise ValueError('lhs0 argument is invalid for a non-string target; define the initial guess via arguments instead')
+    if isinstance(target, str):
+        target = target.rstrip(',').split(',')
+    solveargs = _strip(kwargs, 'lin')
+    solveargs['symmetric'] = True
+    if kwargs:
+        raise TypeError('unexpected keyword arguments: {}'.format(', '.join(kwargs)))
+    return _with_solve(_minimize(tuple(target), energy.as_evaluable_array,
+        types.frozendict((k, types.arraydata(v)) for k, v in (constrain or {}).items()),
+        types.frozendict((k, types.arraydata(v)) for k, v in (arguments or {}).items()),
+        rampup, rampdown, failrelax, types.frozendict(solveargs)))
+
+
+class _minimize(cache.Recursion, length=1, version=3):
+
+    def __init__(self, target, energy: evaluable.asarray, constrain, arguments, rampup: float, rampdown: float, failrelax: float, solveargs):
         super().__init__()
         if energy.shape != ():
             raise ValueError('`energy` should be scalar')
         self.target = target
         self.energy = energy
         self.residual = _derivative((energy,), target)
         self.jacobian = _derivative(self.residual, target)
-        self.lhs0, self.constrain = _parse_lhs_cons(lhs0, constrain, target, _argobjs((energy,)), arguments)
+        self.lhs0, self.constrain = _parse_lhs_cons(constrain, target, _argobjs((energy,)), arguments)
         self.dtype = _determine_dtype(target, (energy,), self.lhs0, self.constrain)
         self.rampup = rampup
         self.rampdown = rampdown
         self.failrelax = failrelax
-        self.solveargs = _strip(kwargs, 'lin')
-        self.solveargs['symmetric'] = True
-        if kwargs:
-            raise TypeError('unexpected keyword arguments: {}'.format(', '.join(kwargs)))
+        self.solveargs = solveargs
 
     def _eval(self, lhs, mask):
         return _integrate_blocks(self.energy, self.residual, self.jacobian, arguments=lhs, mask=mask)
 
     def resume(self, history):
         mask, vmask = _invert(self.constrain, self.target)
         if history:
@@ -568,70 +487,80 @@
                 relax += self.rampdown
                 if relax <= self.failrelax:
                     raise SolverError('stuck in local minimum')
 
             yield lhs, types.attributes(resnorm=numpy.linalg.norm(res), energy=nrg, relax=relax)
 
 
-@withsolve.single_or_multiple
-class pseudotime(cache.Recursion, length=1):
+def pseudotime(target, residual, inertia, timestep: float, *, lhs0: types.arraydata = None, constrain = None, arguments = {}, **kwargs):
     '''iteratively solve nonlinear problem by pseudo time stepping
 
     Generates targets such that residual approaches 0 using hybrid of Newton and
     time stepping. Requires an inertia term and initial timestep. Suitable to be
     used inside ``solve``.
 
     Parameters
     ----------
     target : :class:`str`
         Name of the target: a :class:`nutils.function.Argument` in ``residual``.
     residual : :class:`nutils.evaluable.AsEvaluableArray`
     inertia : :class:`nutils.evaluable.AsEvaluableArray`
     timestep : :class:`float`
         Initial time step, will scale up as residual decreases
-    lhs0 : :class:`numpy.ndarray`
-        Coefficient vector, starting point of the iterative procedure.
     constrain : :class:`numpy.ndarray` with dtype :class:`bool` or :class:`float`
-        Equal length to ``lhs0``, masks the free vector entries as ``False``
-        (boolean) or NaN (float). In the remaining positions the values of
-        ``lhs0`` are returned unchanged (boolean) or overruled by the values in
-        `constrain` (float).
+        Masks the free vector entries as ``False`` (boolean) or NaN (float). In
+        the remaining positions the values of ``lhs0`` are returned unchanged
+        (boolean) or overruled by the values in `constrain` (float).
     arguments : :class:`collections.abc.Mapping`
         Defines the values for :class:`nutils.function.Argument` objects in
-        `residual`.  The ``target`` should not be present in ``arguments``.
-        Optional.
+        `residual`. If ``target`` is present in ``arguments`` then it is used
+        as the initial guess for the iterative procedure.
 
     Yields
     ------
     :class:`numpy.ndarray` with dtype :class:`float`
         Tuple of coefficient vector and residual norm
     '''
 
-    @types.apply_annotations
-    def __init__(self, target, residual: integraltuple, inertia: optionalintegraltuple, timestep: types.strictfloat, lhs0: types.arraydata = None, constrain: arrayordict = None, arguments: argdict = {}, **kwargs):
+    if isinstance(target, str) and ',' not in target and ':' not in target:
+        return pseudotime([target], [residual], [inertia], timestep, constrain={} if constrain is None else {target: constrain},
+            arguments=arguments if lhs0 is None else {**arguments, target: lhs0}, **kwargs)[target]
+    if lhs0 is not None:
+        raise ValueError('lhs0 argument is invalid for a non-string target; define the initial guess via arguments instead')
+    target, residual, inertia = _target_helper(target, residual, inertia)
+    solveargs = _strip(kwargs, 'lin')
+    solveargs.setdefault('rtol', 1e-3)
+    if kwargs:
+        raise TypeError('unexpected keyword arguments: {}'.format(', '.join(kwargs)))
+    return _with_solve(_pseudotime(target, residual, inertia, timestep,
+        types.frozendict((k, types.arraydata(v)) for k, v in (constrain or {}).items()),
+        types.frozendict((k, types.arraydata(v)) for k, v in (arguments or {}).items()),
+        types.frozendict(solveargs)))
+
+
+class _pseudotime(cache.Recursion, length=1):
+
+    def __init__(self, target, residual, inertia, timestep: float, constrain, arguments, solveargs: dict):
         super().__init__()
         if target in arguments:
             raise ValueError('`target` should not be defined in `arguments`')
         if len(residual) != len(inertia):
             raise Exception('length of residual and inertia do no match')
         for inert, res in zip(inertia, residual):
             if inert and not evaluable.equalshape(inert.shape, res.shape):
                 raise ValueError('expected `inertia` with shape {} but got {}'.format(res.shape, inert.shape))
         self.target = target
         self.timesteptarget = '_pseudotime_timestep'
         dt = evaluable.Argument(self.timesteptarget, ())
         self.residuals = residual
         self.jacobians = _derivative(tuple(res + (inert/dt if inert else 0) for res, inert in zip(residual, inertia)), target)
-        self.lhs0, self.constrain = _parse_lhs_cons(lhs0, constrain, target, _argobjs(residual+inertia), arguments)
+        self.lhs0, self.constrain = _parse_lhs_cons(constrain, target, _argobjs(residual+inertia), arguments)
         self.dtype = _determine_dtype(target, residual+inertia, self.lhs0, self.constrain)
         self.timestep = timestep
-        self.solveargs = _strip(kwargs, 'lin')
-        if kwargs:
-            raise TypeError('unexpected keyword arguments: {}'.format(', '.join(kwargs)))
-        self.solveargs.setdefault('rtol', 1e-3)
+        self.solveargs = solveargs
 
     def _eval(self, lhs, mask, timestep):
         return _integrate_blocks(self.residuals, self.jacobians, arguments=dict({self.timesteptarget: timestep}, **lhs), mask=mask)
 
     def resume(self, history):
         mask, vmask = _invert(self.constrain, self.target)
         if history:
@@ -654,81 +583,91 @@
             timestep = self.timestep * (resnorm0/resnorm)
             log.info('timestep: {:.0e}'.format(timestep))
             res, jac = self._eval(lhs, mask, timestep)
             resnorm = numpy.linalg.norm(res)
             yield lhs, types.attributes(resnorm=resnorm, timestep=timestep, resnorm0=resnorm0)
 
 
-@iterable.single_or_multiple
-class thetamethod(cache.Recursion, length=1, version=1):
+def thetamethod(target, residual, inertia, timestep: float, theta: float, *, lhs0: types.arraydata = None, target0: str = None, constrain = None, newtontol: float = 1e-10, arguments = {}, newtonargs: types.frozendict = {}, timetarget: str = '_thetamethod_time', time0: float = 0., historysuffix: str = '0'):
     '''solve time dependent problem using the theta method
 
     Parameters
     ----------
     target : :class:`str`
         Name of the target: a :class:`nutils.function.Argument` in ``residual``.
     residual : :class:`nutils.evaluable.AsEvaluableArray`
     inertia : :class:`nutils.evaluable.AsEvaluableArray`
     timestep : :class:`float`
         The time step.
-    lhs0 : :class:`numpy.ndarray`
-        Coefficient vector, starting point of the iterative procedure.
     theta : :class:`float`
         Theta value (theta=1 for implicit Euler, theta=0.5 for Crank-Nicolson)
     residual0 : :class:`nutils.evaluable.AsEvaluableArray`
         Optional additional residual component evaluated in previous timestep
     constrain : :class:`numpy.ndarray` with dtype :class:`bool` or :class:`float`
-        Equal length to ``lhs0``, masks the free vector entries as ``False``
-        (boolean) or NaN (float). In the remaining positions the values of
-        ``lhs0`` are returned unchanged (boolean) or overruled by the values in
-        `constrain` (float).
+        Masks the free vector entries as ``False`` (boolean) or NaN (float). In
+        the remaining positions the values of ``lhs0`` are returned unchanged
+        (boolean) or overruled by the values in `constrain` (float).
     newtontol : :class:`float`
         Residual tolerance of individual timesteps
     arguments : :class:`collections.abc.Mapping`
         Defines the values for :class:`nutils.function.Argument` objects in
-        `residual`.  The ``target`` should not be present in ``arguments``.
-        Optional.
+        `residual`. If ``target`` is present in ``arguments`` then it is used
+        as the initial condition.
     timetarget : :class:`str`
         Name of the :class:`nutils.function.Argument` that represents time.
         Optional.
     time0 : :class:`float`
         The intial time.  Default: ``0.0``.
 
     Yields
     ------
     :class:`numpy.ndarray`
         Coefficient vector for all timesteps after the initial condition.
     '''
+    if isinstance(target, str) and ',' not in target and ':' not in target:
+        return (res[target] for res in thetamethod([target], [residual], [inertia], timestep, theta, target0=target0,
+            constrain={} if constrain is None else {target: constrain}, newtontol=newtontol,
+            arguments=arguments if lhs0 is None else {**arguments, target: lhs0}, newtonargs=newtonargs,
+            timetarget=timetarget, time0=time0, historysuffix=historysuffix))
+    if lhs0 is not None:
+        raise ValueError('lhs0 argument is invalid for a non-string target; define the initial condition via arguments instead')
+    target, residual, inertia = _target_helper(target, residual, inertia)
+    return _thetamethod(target, residual, inertia, timestep,
+        types.frozendict((k, types.arraydata(v)) for k, v in (constrain or {}).items()),
+        types.frozendict((k, types.arraydata(v)) for k, v in (arguments or {}).items()),
+        theta, target0, newtontol, types.frozendict(newtonargs), timetarget, time0, historysuffix)
+
 
-    @types.apply_annotations
-    def __init__(self, target, residual: integraltuple, inertia: optionalintegraltuple, timestep: types.strictfloat, theta: types.strictfloat, lhs0: types.arraydata = None, target0: types.strictstr = None, constrain: arrayordict = None, newtontol: types.strictfloat = 1e-10, arguments: argdict = {}, newtonargs: types.frozendict = {}, timetarget: types.strictstr = '_thetamethod_time', time0: types.strictfloat = 0., historysuffix: types.strictstr = '0'):
+class _thetamethod(cache.Recursion, length=1, version=1):
+
+    def __init__(self, target, residual, inertia, timestep: float, constrain, arguments, theta: float, target0: str, newtontol: float, newtonargs: types.frozendict, timetarget: str, time0: float, historysuffix: str):
         super().__init__()
         if len(residual) != len(inertia):
             raise Exception('length of residual and inertia do no match')
         for inert, res in zip(inertia, residual):
-            if inert and not evaluable.equalshape(inert.shape, res.shape):
+            if not evaluable.equalshape(inert.shape, res.shape):
                 raise ValueError('expected `inertia` with shape {} but got {}'.format(res.shape, inert.shape))
         self.target = target
         self.newtonargs = newtonargs
         self.newtontol = newtontol
         self.timestep = timestep
         self.timetarget = timetarget
-        self.lhs0, self.constrain = _parse_lhs_cons(lhs0, constrain, target, _argobjs(residual+inertia), arguments)
+        self.lhs0, self.constrain = _parse_lhs_cons(constrain, target, _argobjs(residual+inertia), arguments)
         self.lhs0[timetarget] = numpy.array(time0)
         if target0 is None:
             self.old_new = [(t+historysuffix, t) for t in target]
         elif len(target) == 1:
             warnings.deprecation('target0 is deprecated; use historysuffix instead (target0=target+historysuffix)')
             self.old_new = [(target0, target[0])]
         else:
             raise Exception('target0 is not supported in combination with multiple targets; use historysuffix instead')
         self.old_new.append((timetarget+historysuffix, timetarget))
-        subs0 = {new: evaluable.Argument(old, self.lhs0[new].shape) for old, new in self.old_new}
+        subs0 = {new: evaluable.Argument(old, tuple(map(evaluable.constant, self.lhs0[new].shape))) for old, new in self.old_new}
         dt = evaluable.Argument(timetarget, ()) - subs0[timetarget]
-        self.residuals = tuple(res * theta + evaluable.replace_arguments(res, subs0) * (1-theta) + ((inert - evaluable.replace_arguments(inert, subs0)) / dt if inert else 0) for res, inert in zip(residual, inertia))
+        self.residuals = tuple(res * theta + evaluable.replace_arguments(res, subs0) * (1-theta) + (inert - evaluable.replace_arguments(inert, subs0)) / dt for res, inert in zip(residual, inertia))
         self.jacobians = _derivative(self.residuals, target)
 
     def _step(self, lhs0, dt):
         arguments = lhs0.copy()
         arguments.update((old, lhs0[new]) for old, new in self.old_new)
         arguments[self.timetarget] = lhs0[self.timetarget] + dt
         try:
@@ -748,82 +687,97 @@
             yield lhs
 
 
 impliciteuler = functools.partial(thetamethod, theta=1)
 cranknicolson = functools.partial(thetamethod, theta=0.5)
 
 
-@log.withcontext
-@single_or_multiple
-@types.apply_annotations
-@cache.function(version=1)
-def optimize(target, functional: evaluable.asarray, *, tol: types.strictfloat = 0., arguments: argdict = {}, droptol: float = None, constrain: arrayordict = None, lhs0: types.arraydata = None, relax0: float = 1., linesearch=None, failrelax: types.strictfloat = 1e-6, **kwargs):
+def optimize(target, functional: evaluable.asarray, *, tol: float = 0., arguments = {}, droptol: float = None, constrain = None, lhs0: types.arraydata = None, relax0: float = 1., linesearch=None, failrelax: float = 1e-6, **kwargs):
     '''find the minimizer of a given functional
 
     Parameters
     ----------
     target : :class:`str`
         Name of the target: a :class:`nutils.function.Argument` in ``residual``.
     functional : scalar :class:`nutils.evaluable.AsEvaluableArray`
         The functional the should be minimized by varying target
     tol : :class:`float`
         Target residual norm.
     arguments : :class:`collections.abc.Mapping`
         Defines the values for :class:`nutils.function.Argument` objects in
-        `residual`.  The ``target`` should not be present in ``arguments``.
-        Optional.
+        `residual`. If ``target`` is present in ``arguments`` then it is used
+        as the initial guess.
     droptol : :class:`float`
         Threshold for leaving entries in the return value at NaN if they do not
         contribute to the value of the functional.
     constrain : :class:`numpy.ndarray` with dtype :class:`float`
         Defines the fixed entries of the coefficient vector
-    lhs0 : :class:`numpy.ndarray`
-        Coefficient vector, starting point of the iterative procedure.
     relax0 : :class:`float`
         Initial relaxation value.
-    linesearch : :class:`nutils.solver.LineSearch`
-        Callable that defines relaxation logic.
+    linesearch : Callable[[float, float, float, float], Tuple[float, bool]]
+        Callable that defines relaxation logic. The callable takes four
+        arguments: the current residual and directional derivative, and the
+        candidate residual and directional derivative, with derivatives
+        normalized to unit length; and returns the optimal scaling and a
+        boolean flag that marks whether the candidate should be accepted.
     failrelax : :class:`float`
         Fail with exception if relaxation reaches this lower limit.
 
     Yields
     ------
     :class:`numpy.ndarray`
         Coefficient vector corresponding to the functional optimum
     '''
 
+    if isinstance(target, str) and ',' not in target:
+        return optimize([target], functional, tol=tol, arguments=arguments if lhs0 is None else {**arguments, target: lhs0}, droptol=droptol,
+            constrain={} if constrain is None else {target: constrain}, relax0=relax0, linesearch=linesearch, failrelax=failrelax, **kwargs)[target]
+    if lhs0 is not None:
+        raise ValueError('lhs0 argument is invalid for a non-string target; define the initial guess via arguments instead')
+    if isinstance(target, str):
+        target = target.rstrip(',').split(',')
     if linesearch is None:
         linesearch = NormBased.legacy(kwargs)
     solveargs = _strip(kwargs, 'lin')
     solveargs['symmetric'] = True
     if kwargs:
         raise TypeError('unexpected keyword arguments: {}'.format(', '.join(kwargs)))
+    with log.context('optimize'):
+        return _optimize(tuple(target), functional.as_evaluable_array,
+            types.frozendict((k, types.arraydata(v)) for k, v in (constrain or {}).items()),
+            types.frozendict((k, types.arraydata(v)) for k, v in (arguments or {}).items()),
+            tol, droptol, relax0, linesearch, failrelax, types.frozendict(solveargs))
+
+
+@cache.function(version=1)
+def _optimize(target, functional: evaluable.asarray, constrain, arguments, tol: float, droptol: float, relax0: float, linesearch, failrelax: float, solveargs):
     argobjs = _argobjs((functional,))
     if any(t not in argobjs for t in target):
         if not droptol:
             raise ValueError('target {} does not occur in integrand; consider setting droptol>0'.format(', '.join(t for t in target if t not in argobjs)))
         target = [t for t in target if t in argobjs]
         if not target:
             return {}
     residual = _derivative((functional,), target)
     jacobian = _derivative(residual, target)
-    lhs0, constrain = _parse_lhs_cons(lhs0, constrain, target, argobjs, arguments)
+    lhs0, constrain = _parse_lhs_cons(constrain, target, argobjs, arguments)
     dtype = _determine_dtype(target, (functional,), lhs0, constrain)
     mask, vmask = _invert(constrain, target)
     lhs, vlhs = _redict(lhs0, target, dtype)
     val, res, jac = _integrate_blocks(functional, residual, jacobian, arguments=lhs, mask=mask)
     if droptol is not None:
         supp = jac.rowsupp(droptol)
         res = res[supp]
         jac = jac.submatrix(supp, supp)
         nan = numpy.zeros_like(vmask)
         nan[vmask] = ~supp  # return value is set to nan if dof is not supported and not constrained
         vmask[vmask] = supp  # dof is computed if it is supported and not constrained
         assert vmask.sum() == len(res)
     resnorm = numpy.linalg.norm(res)
+    solveargs = dict(solveargs)
     if not set(target).isdisjoint(_argobjs(jacobian)):
         if tol <= 0:
             raise ValueError('nonlinear optimization problem requires a nonzero "tol" argument')
         solveargs.setdefault('rtol', 1e-3)
         firstresnorm = resnorm
         relax = relax0
         accept = True
@@ -858,29 +812,17 @@
 
 # HELPER FUNCTIONS
 
 def _strip(kwargs, prefix):
     return {key[len(prefix):]: kwargs.pop(key) for key in list(kwargs) if key.startswith(prefix)}
 
 
-def _parse_lhs_cons(lhs0, constrain, targets, argobjs, arguments):
+def _parse_lhs_cons(constrain, targets, argobjs, arguments):
     arguments = {t: numpy.asarray(a) for t, a in arguments.items()}
-    if lhs0 is not None:
-        assert lhs0.dtype == float
-        if len(targets) != 1:
-            raise SolverError('lhs0 argument cannot be used in combination with multiple targets')
-        arguments[targets[0]] = numpy.asarray(lhs0)
-    if isinstance(constrain, types.arraydata):
-        if len(targets) != 1:
-            raise SolverError('constrain argument must be a dictionary in combination with multiple targets')
-        constrain = {targets[0]: numpy.asarray(constrain)}
-    elif constrain:
-        constrain = {t: numpy.asarray(c) for t, c in constrain.items()}
-    else:
-        constrain = {}
+    constrain = {t: numpy.asarray(c) for t, c in constrain.items()}
     for target in targets:
         if target not in argobjs:
             raise SolverError('target does not occur in functional: {!r}'.format(target))
         shape = tuple(map(int, argobjs[target].shape))
         if target not in arguments:
             arguments[target] = numpy.zeros(shape)
         elif arguments[target].shape != shape:
@@ -903,23 +845,14 @@
     elif len(jacobian) != len(residual) * len(target):
         raise ValueError('jacobian has incorrect length')
     elif not all(evaluable.equalshape(jacobian[i*len(target)+j].shape, res.shape + argobjs[t].shape) for i, res in enumerate(residual) for j, t in enumerate(target)):
         raise ValueError('jacobian has incorrect shape')
     return jacobian
 
 
-def _progress(name, tol):
-    '''helper function for iter.wrap'''
-
-    lhs, info = yield name
-    resnorm0 = info.resnorm
-    while True:
-        lhs, info = yield (name + ' {:.0f}%').format(100 * numpy.log(resnorm0/max(info.resnorm, tol)) / numpy.log(resnorm0/tol) if tol else 0 if info.resnorm else 100)
-
-
 def _redict(lhs, targets, dtype=float):
     '''copy argument dictionary referencing a newly allocated contiguous array'''
 
     vlhs = numpy.empty(sum(lhs[target].size for target in targets), dtype)
     lhs = lhs.copy()
     offset = 0
     for target in targets:
@@ -986,8 +919,92 @@
         or any(vec.dtype.kind == 'c' for vec in lhs0.values())
         or any(vec.dtype.kind == 'c' for vec in constrain.values())
     ) else float
     if not all(argobjs[target].dtype == dtype for target in targets):
         raise ValueError('All targets must have dtype {}.'.format(dtype.__name__))
     return dtype
 
-# vim:sw=2:sts=2:et
+
+def _target_helper(target, *args):
+    targets = target.rstrip(',').split(',') if isinstance(target, str) else list(target)
+    is_functional = [':' in target for target in targets]
+    if all(is_functional):
+        targets, tests = zip(*[t.split(':', 1) for t in targets])
+        arguments = function._join_arguments(arg.arguments for arg in args)
+        testargs = [function.Argument(t, *arguments[t]) for t in tests]
+        args = [map(arg.derivative, testargs) for arg in args]
+    elif any(is_functional):
+        raise ValueError('inconsistent targets')
+    elif len(args) > 1:
+        shapes = [{f.shape for f in ziparg if f is not None} for ziparg in zip(*args)]
+        if any(len(arg) != len(shapes) for arg in args) or any(len(shape) != 1 for shape in shapes):
+            raise ValueError('inconsistent residuals')
+        args = [[function.zeros(shape) if f is None else f for f, (shape,) in zip(arg, shapes)] for arg in args]
+    return (tuple(targets), *[tuple(f.as_evaluable_array for f in arg) for arg in args])
+
+
+class _with_solve(types.Immutable):
+    '''add a .solve method to iterables'''
+
+    def __init__(self, wrapped, item = None):
+        self._wrapped = wrapped
+        self._item = item
+
+    def __iter__(self):
+        return iter(self._wrapped) if self._item is None else ((res[self._item], info) for (res, info) in self._wrapped)
+
+    def __getitem__(self, item):
+        assert self._item is None
+        return _with_solve(self._wrapped, item)
+
+    def solve(self, tol, maxiter=float('inf'), miniter=0):
+        '''execute nonlinear solver, return lhs
+
+        Iterates over nonlinear solver until tolerance is reached. Example::
+
+            lhs = newton(target, residual).solve(tol=1e-5)
+
+        Parameters
+        ----------
+        tol : :class:`float`
+            Target residual norm
+        maxiter : :class:`int`
+            Maximum number of iterations
+        miniter : :class:`int`
+            Minimum number of iterations
+
+        Returns
+        -------
+        :class:`numpy.ndarray`
+            Coefficient vector that corresponds to a smaller than ``tol`` residual.
+        '''
+
+        lhs, info = self.solve_withinfo(tol=tol, maxiter=maxiter, miniter=miniter)
+        return lhs
+
+    @cache.function
+    def solve_withinfo(self, tol, maxiter=float('inf'), miniter=0):
+        '''execute nonlinear solver, return lhs and info
+
+        Like :func:`solve`, but return a 2-tuple of the solution and the
+        corresponding info object which holds information about the final residual
+        norm and other generator-dependent information.
+        '''
+
+        if miniter > maxiter:
+            raise ValueError('The minimum number of iterations cannot be larger than the maximum.')
+        with log.context(self._wrapped.__class__.__name__.strip('_')):
+            with log.context('iter {}', 0) as recontext:
+                it = enumerate(self)
+                iiter, (lhs, info) = next(it)
+                resnorm0 = info.resnorm
+                while info.resnorm > tol or iiter < miniter:
+                    if iiter >= maxiter:
+                        raise SolverError(f'failed to reach target tolerance in {maxiter} iterations')
+                    recontext(f'{iiter+1} ({100 * numpy.log(resnorm0 / max(info.resnorm, tol)) / numpy.log(resnorm0 / tol):.0f}%)')
+                    iiter, (lhs, info) = next(it)
+            log.info(f'converged in {iiter} iterations to residual {info.resnorm:.1e}')
+        info.niter = iiter
+        return lhs, info
+
+
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/sparse.py` & `nutils-8.0/nutils/sparse.py`

 * *Files 0% similar despite different names*

```diff
@@ -355,8 +355,8 @@
 
 def _resize(data, n):
     if data.base is not None:
         return data[:n]
     data.resize(n, refcheck=False)
     return data
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/testing.py` & `nutils-8.0/nutils/testing.py`

 * *Files 0% similar despite different names*

```diff
@@ -312,8 +312,8 @@
                 elif token == ']':
                     return data
                 else:
                     raise ValueError('unexpected token: {}'.format(token))
         else:
             return float(token)
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/topology.py` & `nutils-8.0/nutils/topology.py`

 * *Files 8% similar despite different names*

```diff
@@ -10,38 +10,39 @@
 objects, like the geometry function and function bases for analysis, as well as
 provide tools for their construction. It also offers methods for integration and
 sampling, thus providing a high level interface to operations otherwise written
 out in element loops. For lower level operations topologies can be used as
 :mod:`nutils.element` iterators.
 """
 
-from . import element, function, evaluable, util, parallel, numeric, cache, transform, transformseq, warnings, matrix, types, points, sparse
-from .sample import Sample
+from . import element, function, evaluable, _util as util, parallel, numeric, cache, transform, transformseq, warnings, types, points, sparse
+from ._util import single_or_multiple
+from ._backports import cached_property
 from .elementseq import References
 from .pointsseq import PointsSequence
-from typing import Any, FrozenSet, Iterable, Iterator, List, Mapping, Optional, Sequence, Tuple, Union
-import numpy
-import functools
-import collections.abc
+from .sample import Sample
+
+from dataclasses import dataclass
+from functools import reduce
+from os import environ
+from typing import Any, FrozenSet, Iterable, Iterator, List, Mapping, Optional, Sequence, Tuple, Union, Sequence
+
 import itertools
-import functools
+import numpy
+import nutils_poly as poly
 import operator
-import numbers
-import pathlib
-import abc
 import treelog as log
-import os
-_ = numpy.newaxis
 
+
+_ = numpy.newaxis
 _identity = lambda x: x
-_strictspace = types.strictstr
 _ArgDict = Mapping[str, numpy.ndarray]
 
 
-class Topology(types.Singleton):
+class Topology:
     '''topology base class
 
     Parameters
     ----------
     spaces : :class:`tuple` of :class:`str`
         The unique, ordered list of spaces on which this topology is defined.
     space_dims : :class:`tuple` of :class:`int`
@@ -57,16 +58,14 @@
         The dimension of each space in :attr:`spaces`.
     references : :class:`nutils.elementseq.References`
         The references.
     ndims : :class:`int`
         The dimension of this topology.
     '''
 
-    __slots__ = 'spaces', 'space_dims', 'references', 'ndims'
-
     @staticmethod
     def empty(spaces: Iterable[str], space_dims: Iterable[int], ndims: int) -> 'Topology':
         '''Return an empty topology.
 
         Parameters
         ----------
         spaces : :class:`tuple` of :class:`str`
@@ -122,21 +121,24 @@
                         Suggestion: include an empty topology (see \
                         `Topology.empty_like`).')
         empty = Topology.empty_like(topos[0])
         if not all(topo.spaces == empty.spaces and topo.space_dims == empty.space_dims and topo.ndims == empty.ndims for topo in topos):
             raise ValueError('The topologies must have the same spaces and dimensions.')
         unempty = tuple(filter(None, topos))
         if unempty:
-            return functools.reduce(_DisjointUnion, unempty)
+            return reduce(_DisjointUnion, unempty)
         else:
             return empty
 
-    def __init__(self, spaces: Tuple[str, ...], space_dims: Tuple[int, ...], references: References) -> None:
-        self.spaces = spaces
-        self.space_dims = space_dims
+    def __init__(self, spaces: Sequence[str], space_dims: Sequence[int], references: References) -> None:
+        assert isinstance(spaces, Sequence) and all(isinstance(space, str) for space in spaces), f'spaces={spaces!r}'
+        assert isinstance(space_dims, Sequence) and all(isinstance(space_dim, int) for space_dim in space_dims), f'space_dims={space_dims!r}'
+        assert isinstance(references, References), f'references={references!r}'
+        self.spaces = tuple(spaces)
+        self.space_dims = tuple(space_dims)
         self.references = references
         self.ndims = references.ndims
         super().__init__()
 
     def __str__(self) -> str:
         'string representation'
 
@@ -190,15 +192,15 @@
             return self.empty_like()
         indices = numpy.unique(indices.astype(int, casting='same_kind'))
         if indices[0] < 0 or indices[-1] >= len(self):
             raise IndexError('element index out of range')
         return self.take_unchecked(indices)
 
     def take_unchecked(self, __indices: numpy.ndarray) -> 'Topology':
-        return _Take(self, types.arraydata(__indices))
+        return _Take(self, __indices)
 
     def compress(self, __mask: Union[numpy.ndarray, Sequence[bool]]) -> 'Topology':
         '''Return the selected elements as a disconnected topology.
 
         The mask refers to the raveled list of elements in this topology.
 
         Parameters
@@ -340,49 +342,49 @@
         raise NotImplementedError
 
     def basis(self, name: str, *args, **kwargs) -> function.Basis:
         '''
         Create a basis.
         '''
         if self.ndims == 0:
-            return function.PlainBasis([[1]], [[0]], 1, self.f_index, self.f_coords)
+            return function.PlainBasis([[[1]]], [[0]], 1, self.f_index, self.f_coords)
         split = name.split('-', 1)
         if len(split) == 2 and split[0] in ('h', 'th'):
             name = split[1]  # default to non-hierarchical bases
             if split[0] == 'th':
                 kwargs.pop('truncation_tolerance', None)
         f = getattr(self, 'basis_' + name)
         return f(*args, **kwargs)
 
     def sample(self, ischeme: str, degree: int) -> Sample:
         'Create sample.'
 
         raise NotImplementedError
 
-    @util.single_or_multiple
+    @single_or_multiple
     def integrate_elementwise(self, funcs: Iterable[function.Array], *, degree: int, asfunction: bool = False, ischeme: str = 'gauss', arguments: Optional[_ArgDict] = None) -> Union[List[numpy.ndarray], List[function.Array]]:
         'element-wise integration'
 
         retvals = [sparse.toarray(retval) for retval in self.sample(ischeme, degree).integrate_sparse(
             [function.kronecker(func, pos=self.f_index, length=len(self), axis=0) for func in funcs], arguments=arguments)]
         if asfunction:
             return [function.get(retval, 0, self.f_index) for retval in retvals]
         else:
             return retvals
 
-    @util.single_or_multiple
+    @single_or_multiple
     def elem_mean(self, funcs: Iterable[function.Array], geometry: Optional[function.Array] = None, ischeme: str = 'gauss', degree: Optional[int] = None, **kwargs) -> List[numpy.ndarray]:
         ischeme, degree = element.parse_legacy_ischeme(ischeme if degree is None else ischeme + str(degree))
         funcs = (1,)+funcs
         if geometry is not None:
             funcs = [func * function.J(geometry) for func in funcs]
         area, *integrals = self.integrate_elementwise(funcs, ischeme=ischeme, degree=degree, **kwargs)
         return [integral / area[(slice(None),)+(_,)*(integral.ndim-1)] for integral in integrals]
 
-    @util.single_or_multiple
+    @single_or_multiple
     def integrate(self, funcs: Iterable[function.IntoArray], ischeme: str = 'gauss', degree: Optional[int] = None, edit=None, *, arguments: Optional[_ArgDict] = None) -> Tuple[numpy.ndarray, ...]:
         'integrate functions'
 
         ischeme, degree = element.parse_legacy_ischeme(ischeme if degree is None else ischeme + str(degree))
         if edit is not None:
             funcs = [edit(func) for func in funcs]
         return self.sample(ischeme, degree).integrate(funcs, **arguments or {})
@@ -394,16 +396,15 @@
         if edit is not None:
             funcs = edit(func)
         return self.sample(ischeme, degree).integral(func)
 
     def projection(self, fun: function.Array, onto: function.Array, geometry: function.Array, **kwargs) -> function.Array:
         'project and return as function'
 
-        weights = self.project(fun, onto, geometry, **kwargs)
-        return onto.dot(weights)
+        return self.project(fun, onto, geometry, **kwargs) @ onto
 
     @log.withcontext
     def project(self, fun: function.Array, onto: function.Array, geometry: function.Array, ischeme: str = 'gauss', degree: Optional[int] = None, droptol: float = 1e-12, exact_boundaries: bool = False, constrain=None, verify=None, ptype='lsqr', edit=None, *, arguments: Optional[_ArgDict] = None, **solverargs) -> numpy.ndarray:
         'L2 projection of function onto function space'
 
         log.debug('projection type:', ptype)
 
@@ -478,20 +479,56 @@
             info += ', error {:.2e}/area'.format(avg_error)
         log.info(info)
         if verify is not None:
             assert numcons == verify, 'number of constraints does not meet expectation: {} != {}'.format(numcons, verify)
 
         return constrain
 
-    def refined_by(self, refine: Iterable[int]) -> 'Topology':
-        'create refined space by refining dofs in existing one'
+    def refined_by(self, refine: Union['Topology', Iterable[int], Iterable[Tuple[transform.TransformItem,...]]]) -> 'Topology':
+        '''Create hierarchically refined topology by selectively refining
+        elements.
+
+        Parameters
+        ----------
+        refine : :class:`Topology` or iterable of :class:`int` or transformation chains
+            The elements to refine, specified either as a subtopology or by
+            their indices or locations in the topology.
+
+        Returns
+        -------
+        :class:`Topology`
+            The refined topology.
+        '''
 
+        if isinstance(refine, Topology):
+            refine = refine.transforms
+        elif not isinstance(refine, numpy.ndarray):
+            # We convert refine to a tuple below both as a test for iterability
+            # and to account for the possibility that it is a generator
+            try:
+                refine = tuple(refine)
+            except:
+                raise ValueError('refined_by expects an iterable argument') from None
+        if len(refine) == 0:
+            return self
+        if isinstance(refine[0], tuple): # use first element for detection
+            try:
+                transforms = self.transforms
+            except:
+                raise TypeError('topology supports only refinement by element indices') from None
+            refine = [transforms.index_with_tail(item)[0] for item in refine]
+        refine = numpy.asarray(refine)
+        if refine.dtype != int:
+            raise ValueError(f'expected an array of dtype int, got {refine.dtype}')
+        return self._refined_by(numpy.unique(refine))
+
+    def _refined_by(self, refine: Iterable[int]) -> 'Topology':
         raise NotImplementedError
 
-    @property
+    @cached_property
     def refined(self) -> 'Topology':
         return self.refine_spaces(self.spaces)
 
     def refine(self, __arg: Union[int, Iterable[str], Mapping[str, int]]) -> 'Topology':
         '''Return the refined topology.
 
         If the argument is an :class:`int`, then this method behaves like
@@ -682,15 +719,15 @@
 
     def select(self, indicator: function.Array, ischeme: str = 'bezier2', **kwargs: numpy.ndarray) -> 'Topology':
         # Select elements where `indicator` is strict positive at any of the
         # integration points defined by `ischeme`. We sample `indicator > 0`
         # together with the element index (`self.f_index`) and keep all indices
         # with at least one positive result.
         sample = self.sample(*element.parse_legacy_ischeme(ischeme))
-        isactive, ielem = sample.eval([function.greater(indicator, 0), self.f_index], **kwargs)
+        isactive, ielem = sample.eval([indicator > 0, self.f_index], **kwargs)
         selected = types.frozenarray(numpy.unique(ielem[isactive]))
         return self[selected]
 
     def locate(self, geom, coords, *, tol=0, eps=0, maxiter=0, arguments=None, weights=None, maxdist=None, ischeme=None, scale=None, skip_missing=False) -> Sample:
         '''Create a sample based on physical coordinates.
 
         In a finite element application, functions are commonly evaluated in points
@@ -746,15 +783,15 @@
         Returns
         -------
         located : :class:`nutils.sample.Sample`
         '''
 
         raise NotImplementedError
 
-    @property
+    @cached_property
     def boundary(self) -> 'Topology':
         '''
         :class:`Topology`:
           The boundary of this topology.
         '''
 
         return self.boundary_spaces(self.spaces)
@@ -806,15 +843,15 @@
         This method does not check the validity of the arguments or the dimension
         of the topology. Use :meth:`boundary_spaces` instead unless you're
         absolutely sure what you are doing.
         '''
 
         raise NotImplementedError
 
-    @property
+    @cached_property
     def interfaces(self) -> 'Topology':
         return self.interfaces_spaces(self.spaces)
 
     def interfaces_spaces(self, __spaces: Iterable[str]) -> 'Topology':
         '''Return the interfaces in the given spaces.
 
         Parameters
@@ -872,15 +909,15 @@
         if self.references.isuniform:
             coeffs = [self.references[0].get_poly_coeffs('bernstein', degree=degree)]*len(self.references)
         else:
             coeffs = [ref.get_poly_coeffs('bernstein', degree=degree) for ref in self.references]
         return function.DiscontBasis(coeffs, self.f_index, self.f_coords)
 
 
-if os.environ.get('NUTILS_TENSORIAL', None) == 'test':  # pragma: nocover
+if environ.get('NUTILS_TENSORIAL', None) == 'test':  # pragma: nocover
 
     from unittest import SkipTest
 
     class _TensorialTopology(Topology):
 
         def __and__(self, other: Any) -> Topology:
             result = super().__and__(other)
@@ -953,21 +990,21 @@
 
 else:
     _TensorialTopology = Topology
 
 
 class _EmptyUnlowerable(function.Array):
 
-    def lower(self, points_shape, transform_chains, coordinates) -> evaluable.Array:
+    def lower(self, args: function.LowerArgs) -> evaluable.Array:
         raise ValueError('cannot lower')
 
 
 class _Empty(_TensorialTopology):
 
-    def __init__(self, spaces: Tuple[str, ...], space_dims: Tuple[int, ...], ndims: int) -> None:
+    def __init__(self, spaces: Sequence[str], space_dims: Sequence[int], ndims: int) -> None:
         super().__init__(spaces, space_dims, References.empty(ndims))
 
     def __invert__(self) -> Topology:
         return self
 
     @property
     def connectivity(self) -> Sequence[Sequence[int]]:
@@ -1020,15 +1057,15 @@
         elif self.spaces != other.spaces or self.space_dims != other.space_dims or self.ndims != other.ndims:
             raise ValueError('The topologies must have the same spaces and dimensions.')
         else:
             return Topology.disjoint_union(self.topo1 & other, self.topo2 & other)
 
     __rand__ = __and__
 
-    @property
+    @cached_property
     def connectivity(self) -> Sequence[Sequence[int]]:
         o = len(self.topo1)
         return tuple(self.topo1.connectivity) + tuple(tuple(-1 if n < 0 else n + o for n in N) for N in self.topo2.connectivity)
 
     def get_groups(self, *groups: str) -> Topology:
         return Topology.disjoint_union(self.topo1.get_groups(*groups), self.topo2.get_groups(*groups))
 
@@ -1044,15 +1081,15 @@
 
     def boundary_spaces_unchecked(self, spaces: FrozenSet[str]) -> Topology:
         return Topology.disjoint_union(self.topo1.boundary_spaces(spaces), self.topo2.boundary_spaces(spaces))
 
     def interfaces_spaces_unchecked(self, spaces: FrozenSet[str]) -> Topology:
         return Topology.disjoint_union(self.topo1.interfaces_spaces(spaces), self.topo2.interfaces_spaces(spaces))
 
-    @util.single_or_multiple
+    @single_or_multiple
     def integrate_elementwise(self, funcs: Iterable[function.Array], *, degree: int, asfunction: bool = False, ischeme: str = 'gauss', arguments: Optional[_ArgDict] = None) -> Union[List[numpy.ndarray], List[function.Array]]:
         return list(map(numpy.concatenate, zip(*(topo.integrate_elementwise(funcs, degree=degree, ischeme=ischeme, arguments=arguments) for topo in (self.topo1, self.topo2)))))
 
     def sample(self, ischeme: str, degree: int) -> Sample:
         return self.topo1.sample(ischeme, degree) + self.topo2.sample(ischeme, degree)
 
     def trim(self, levelset: function.Array, maxrefine: int, ndivisions: int = 8, name: str = 'trimmed', leveltopo: Optional[Topology] = None, *, arguments: Optional[_ArgDict] = None) -> Topology:
@@ -1083,17 +1120,17 @@
 
     @property
     def f_index(self) -> function.Array:
         return self.topo1.f_index * len(self.topo2) + self.topo2.f_index
 
     @property
     def f_coords(self) -> function.Array:
-        return function.concatenate([self.topo1.f_coords, self.topo2.f_coords])
+        return numpy.concatenate([self.topo1.f_coords, self.topo2.f_coords])
 
-    @property
+    @cached_property
     def connectivity(self) -> Sequence[Sequence[int]]:
         connectivity1 = self.topo1.connectivity
         connectivity2 = self.topo2.connectivity
         s = len(self.topo2)
         return tuple(tuple(-1 if n1 < 0 else n1 * s + i2 for n1 in N1) + tuple(-1 if n2 < 0 else i1 * s + n2 for n2 in N2) for i1, N1 in enumerate(connectivity1) for i2, N2 in enumerate(connectivity2))
 
     def get_groups(self, *groups: str) -> Topology:
@@ -1194,26 +1231,28 @@
                 raise ValueError('argument `{}` must be `None`, a sequence or a sequence of sequence'.format(attr))
 
         kwargs1.update(kwargs)
         kwargs2.update(kwargs)
 
         basis1 = self.topo1.basis(name, **kwargs1)
         basis2 = self.topo2.basis(name, **kwargs2)
-        basis = function.insertaxis(basis1, 1, basis2.shape[0]) * function.insertaxis(basis2, 0, basis1.shape[0])
-        return function.ravel(basis, axis=0)
+        assert basis1.ndim == basis2.ndim == 1
+        return numpy.ravel(basis1[:,None] * basis2[None,:])
 
     def sample(self, ischeme: str, degree: int) -> Sample:
         return self.topo1.sample(ischeme, degree) * self.topo2.sample(ischeme, degree)
 
 
 class _Take(_TensorialTopology):
 
-    def __init__(self, parent: Topology, indices: types.arraydata) -> None:
+    def __init__(self, parent: Topology, indices: numpy.ndarray) -> None:
+        assert isinstance(parent, Topology), f'parent={parent!r}'
+        assert isinstance(indices, numpy.ndarray), f'indices={indices!r}'
         self.parent = parent
-        self.indices = indices = numpy.asarray(indices)
+        self.indices = indices = types.frozenarray(indices)
         assert indices.ndim == 1 and indices.size
         assert numpy.greater(indices[1:], indices[:-1]).all()
         assert 0 <= indices[0] and indices[-1] < len(self.parent)
         super().__init__(parent.spaces, parent.space_dims, parent.references.take(self.indices))
 
     def sample(self, ischeme: str, degree: int) -> Sample:
         return self.parent.sample(ischeme, degree).take_elements(self.indices)
@@ -1282,19 +1321,19 @@
     def interfaces_spaces_unchecked(self, spaces: FrozenSet[str]) -> Topology:
         return _WithGroupAliases(self.parent.interfaces_spaces_unchecked(spaces), self.igroups, types.frozendict({}), types.frozendict({}))
 
 
 class TransformChainsTopology(Topology):
     'base class for topologies with transform chains'
 
-    __slots__ = 'space', 'transforms', 'opposites'
-    __cache__ = 'border_transforms', 'boundary', 'interfaces'
-
-    @types.apply_annotations
-    def __init__(self, space: _strictspace, references: types.strict[References], transforms: transformseq.stricttransforms, opposites: transformseq.stricttransforms):
+    def __init__(self, space: str, references: References, transforms: transformseq.Transforms, opposites: transformseq.Transforms):
+        assert isinstance(space, str), f'space={space!r}'
+        assert isinstance(references, References), f'references={references!r}'
+        assert isinstance(transforms, transformseq.Transforms), f'transforms={transforms!r}'
+        assert isinstance(opposites, transformseq.Transforms), f'opposites={opposites!r}'
         assert transforms.todims == opposites.todims
         assert references.ndims == opposites.fromdims == transforms.fromdims
         assert len(references) == len(transforms) == len(opposites)
         self.space = space
         self.transforms = transforms
         self.opposites = opposites
         super().__init__((space,), (transforms.todims,), references)
@@ -1350,15 +1389,15 @@
         assert isinstance(other, TransformChainsTopology) and other.space == self.space and other.ndims == self.ndims
         return other.__rsub__(self)
 
     def __rsub__(self, other):
         assert isinstance(other, TransformChainsTopology) and other.space == self.space and other.ndims == self.ndims
         return other - other.subset(self, newboundary=getattr(self, 'boundary', None))
 
-    @property
+    @cached_property
     def border_transforms(self):
         indices = set()
         for btrans in self.boundary.transforms:
             try:
                 ielem, tail = self.transforms.index_with_tail(btrans)
             except ValueError:
                 pass
@@ -1386,18 +1425,23 @@
         points = PointsSequence.from_iter((ischeme(reference, degree) for reference in self.references), self.ndims) if callable(ischeme) \
             else self.references.getpoints(ischeme, degree)
         transforms = self.transforms,
         if len(self.transforms) == 0 or self.opposites != self.transforms:
             transforms += self.opposites,
         return Sample.new(self.space, transforms, points)
 
-    def refined_by(self, refine):
-        return HierarchicalTopology(self, [numpy.arange(len(self))]).refined_by(refine)
+    def _refined_by(self, refine):
+        fine = self.refined.transforms
+        indices0 = numpy.setdiff1d(numpy.arange(len(self)), refine, assume_unique=True)
+        indices1 = numpy.array([fine.index((*self.transforms[i], ctrans))
+            for i in refine for ctrans, cref in self.references[i].children if cref])
+        indices1.sort()
+        return HierarchicalTopology(self, (indices0, indices1))
 
-    @property
+    @cached_property
     def refined(self):
         return RefinedTopology(self)
 
     def refine_spaces_unchecked(self, spaces: Iterable[str]) -> 'TransformChainsTopology':
         # Since every `TransformChainsTopology` has exactly one space, we implement
         # `refine_spaces` here for all subclasses and return `self.refined` if the
         # space of this topology is in the given `spaces`. Subclasses can redefine
@@ -1417,39 +1461,40 @@
         if arguments is None:
             arguments = {}
 
         refs = []
         if leveltopo is None:
             ielem_arg = evaluable.Argument('_trim_index', (), dtype=int)
             coordinates = self.references.getpoints('vertex', maxrefine).get_evaluable_coords(ielem_arg)
-            levelset = levelset.lower(coordinates.shape[:-1], {self.space: (self.transforms.get_evaluable(ielem_arg), self.opposites.get_evaluable(ielem_arg))}, {self.space: coordinates}).optimized_for_numpy
+            levelset = levelset.lower(function.LowerArgs.for_space(self.space, (self.transforms, self.opposites), ielem_arg, coordinates)).optimized_for_numpy
             with log.iter.percentage('trimming', range(len(self)), self.references) as items:
                 for ielem, ref in items:
                     levels = levelset.eval(_trim_index=ielem, **arguments)
                     refs.append(ref.trim(levels, maxrefine=maxrefine, ndivisions=ndivisions))
         else:
             log.info('collecting leveltopo elements')
-            coordinates = evaluable.Points(evaluable.NPoints(), self.ndims)
-            transform_chain = transform.EvaluableTransformChain.from_argument('trans', self.transforms.todims, self.transforms.fromdims)
-            levelset = levelset.lower(coordinates.shape[:-1], {self.space: (transform_chain, transform_chain)}, {self.space: coordinates}).optimized_for_numpy
+            coordinates = evaluable.Points(evaluable.NPoints(), evaluable.constant(self.ndims))
+            ielem = evaluable.Argument('_leveltopo_ielem', (), int)
+            levelset = levelset.lower(function.LowerArgs.for_space(self.space, (leveltopo.transforms, leveltopo.opposites), ielem, coordinates)).optimized_for_numpy
             bins = [set() for ielem in range(len(self))]
             for trans in leveltopo.transforms:
                 ielem, tail = self.transforms.index_with_tail(trans)
                 bins[ielem].add(tail)
             fcache = cache.WrapperCache()
             with log.iter.percentage('trimming', self.references, self.transforms, bins) as items:
                 for ref, trans, ctransforms in items:
-                    levels = numpy.empty(ref.nvertices_by_level(maxrefine))
-                    cover = list(fcache[ref.vertex_cover](frozenset(ctransforms), maxrefine))
+                    levels = numpy.empty(ref._nlinear_by_level(maxrefine))
+                    cover = list(fcache[ref._linear_cover](frozenset(ctransforms), maxrefine))
                     # confirm cover and greedily optimize order
                     mask = numpy.ones(len(levels), dtype=bool)
                     while mask.any():
                         imax = numpy.argmax([mask[indices].sum() for tail, points, indices in cover])
                         tail, points, indices = cover.pop(imax)
-                        levels[indices] = levelset.eval(trans=trans + tail, _points=points, **arguments)
+                        ielem = leveltopo.transforms.index(trans + tail)
+                        levels[indices] = levelset.eval(_leveltopo_ielem=ielem, _points=points, **arguments)
                         mask[indices] = False
                     refs.append(ref.trim(levels, maxrefine=maxrefine, ndivisions=ndivisions))
             log.debug('cache', fcache.stats)
         return SubsetTopology(self, refs, newboundary=name)
 
     def subset(self, topo, newboundary=None, strict=False):
         refs = [ref.empty for ref in self.references]
@@ -1489,23 +1534,23 @@
         if geom.ndim == 0:
             geom = geom[_]
             coords = coords[..., _]
         if not geom.shape == coords.shape[1:] == (self.ndims,):
             raise ValueError('invalid geometry or point shape for {}D topology'.format(self.ndims))
         if skip_missing and weights is not None:
             raise ValueError('weights and skip_missing are mutually exclusive')
-        centroids = self.sample('_centroid', None).eval(geom)
+        arguments = dict(arguments or ())
+        centroids = self.sample('_centroid', None).eval(geom, **arguments)
         assert len(centroids) == len(self)
         ielems = parallel.shempty(len(coords), dtype=int)
         points = parallel.shempty((len(coords), len(geom)), dtype=float)
         _ielem = evaluable.Argument('_locate_ielem', shape=(), dtype=int)
-        _point = evaluable.Argument('_locate_point', shape=(self.ndims,))
-        egeom = geom.lower((), {self.space: (self.transforms.get_evaluable(_ielem), self.opposites.get_evaluable(_ielem))}, {self.space: _point})
+        _point = evaluable.Argument('_locate_point', shape=(evaluable.constant(self.ndims),))
+        egeom = geom.lower(function.LowerArgs.for_space(self.space, (self.transforms, self.opposites), _ielem, _point))
         xJ = evaluable.Tuple((egeom, evaluable.derivative(egeom, _point))).simplified
-        arguments = dict(arguments or ())
         with parallel.ctxrange('locating', len(coords)) as ipoints:
             for ipoint in ipoints:
                 xt = coords[ipoint]  # target
                 dist = numpy.linalg.norm(centroids - xt, axis=1)
                 for ielem in numpy.argsort(dist) if maxdist is None \
                         else sorted((dist < maxdist).nonzero()[0], key=dist.__getitem__):
                     ref = self.references[ielem]
@@ -1558,23 +1603,23 @@
 
         unique_ielems = sorted_ielems[offsets[:-1]]
         transforms = self.transforms[unique_ielems],
         if len(self.transforms) == 0 or self.opposites != self.transforms:
             transforms += self.opposites[unique_ielems],
 
         slices = [index[n:m] for n, m in zip(offsets[:-1], offsets[1:])]
-        points_ = PointsSequence.from_iter([points.CoordsPoints(coords[s]) for s in slices] if weights is None
-                                           else [points.CoordsWeightsPoints(coords[s], weights[s]) for s in slices], self.ndims)
+        points_ = PointsSequence.from_iter([points.CoordsPoints(types.arraydata(coords[s])) for s in slices] if weights is None
+            else [points.CoordsWeightsPoints(types.arraydata(coords[s]), types.arraydata(weights[s])) for s in slices], self.ndims)
 
         return Sample.new(self.space, transforms, points_, index)
 
     def boundary_spaces_unchecked(self, spaces: FrozenSet[str]) -> 'TransformChainsTopology':
         return self.boundary
 
-    @property
+    @cached_property
     @log.withcontext
     def boundary(self):
         references = []
         selection = []
         iglobaledgeiter = itertools.count()
         refs_touched = False
         for ielem, (ioppelems, elemref, elemtrans) in enumerate(zip(self.connectivity, self.references, self.transforms)):
@@ -1597,15 +1642,15 @@
             references = self.references.edges[selection]
         transforms = self.transforms.edges(self.references)[selection]
         return TransformChainsTopology(self.space, references, transforms, transforms)
 
     def interfaces_spaces_unchecked(self, spaces: FrozenSet[str]) -> 'TransformChainsTopology':
         return self.interfaces
 
-    @property
+    @cached_property
     @log.withcontext
     def interfaces(self):
         references = []
         selection = []
         oppselection = []
         iglobaledgeiter = itertools.count()
         refs_touched = False
@@ -1671,35 +1716,33 @@
     def basis_bernstein(self, degree):
         'bernstein shape functions'
         return self._basis_c0_structured('bernstein', degree)
 
     basis_std = basis_bernstein
 
 
-stricttopology = types.strict[Topology]
-
-
 class LocateError(Exception):
     pass
 
 
 class WithGroupsTopology(TransformChainsTopology):
     'item topology'
 
-    __slots__ = 'basetopo', 'vgroups', 'bgroups', 'igroups', 'pgroups'
-    __cache__ = 'refined',
-
-    @types.apply_annotations
-    def __init__(self, basetopo: stricttopology, vgroups: types.frozendict = {}, bgroups: types.frozendict = {}, igroups: types.frozendict = {}, pgroups: types.frozendict = {}):
+    def __init__(self, basetopo: Topology, vgroups: Mapping[str, Union[str, Topology]] = {}, bgroups: Mapping[str, Union[str, Topology]] = {}, igroups: Mapping[str, Union[str, Topology]] = {}, pgroups: Mapping[str, Union[str, Topology]] = {}):
+        assert isinstance(basetopo, Topology), f'basetopo={basetopo!r}'
+        assert isinstance(vgroups, Mapping) and all(isinstance(key, str) and (isinstance(value, str) or isinstance(value, Topology) and value.ndims == basetopo.ndims) for key, value in vgroups.items()), f'vgroups={vgroups!r}'
+        assert isinstance(bgroups, Mapping) and all(isinstance(key, str) and (isinstance(value, str) or isinstance(value, Topology) and value.ndims == basetopo.ndims-1) for key, value in bgroups.items()), f'bgroups={bgroups!r}'
+        assert isinstance(igroups, Mapping) and all(isinstance(key, str) and (isinstance(value, str) or isinstance(value, Topology) and value.ndims == basetopo.ndims-1) for key, value in igroups.items()), f'igroups={igroups!r}'
+        assert isinstance(pgroups, Mapping) and all(isinstance(key, str) and (isinstance(value, str) or isinstance(value, Topology) and value.ndims == 0) for key, value in pgroups.items()), f'pgroups={pgroups!r}'
         assert vgroups or bgroups or igroups or pgroups
         self.basetopo = basetopo
-        self.vgroups = vgroups
-        self.bgroups = bgroups
-        self.igroups = igroups
-        self.pgroups = pgroups
+        self.vgroups = types.frozendict(vgroups)
+        self.bgroups = types.frozendict(bgroups)
+        self.igroups = types.frozendict(igroups)
+        self.pgroups = types.frozendict(pgroups)
         super().__init__(basetopo.space, basetopo.references, basetopo.transforms, basetopo.opposites)
         assert all(topo is Ellipsis or isinstance(topo, str) or isinstance(topo, TransformChainsTopology) and topo.ndims == basetopo.ndims for topo in self.vgroups.values())
 
     def __len__(self):
         return len(self.basetopo)
 
     def get_groups(self, *groups: str) -> TransformChainsTopology:
@@ -1713,15 +1756,15 @@
                     topos.append(item)
                 else:
                     basegroups.extend(item.split(','))
             else:
                 basegroups.append(group)
         if basegroups:
             topos.append(self.basetopo.get_groups(*basegroups))
-        return functools.reduce(operator.or_, topos, self.empty_like())
+        return reduce(operator.or_, topos, self.empty_like())
 
     def take_unchecked(self, __indices: numpy.ndarray) -> TransformChainsTopology:
         return self.basetopo.take_unchecked(__indices)
 
     def slice_unchecked(self, __s: slice, __idim: int) -> TransformChainsTopology:
         return self.basetopo.slice_unchecked(__s, __idim)
 
@@ -1770,25 +1813,26 @@
                     ptopos.append(ptopo)
             topo = topo.basetopo
         return UnionTopology(ptopos, pnames)
 
     def basis(self, name, *args, **kwargs):
         return self.basetopo.basis(name, *args, **kwargs)
 
-    @property
+    @cached_property
     def refined(self):
         groups = [{name: topo.refined if isinstance(topo, TransformChainsTopology) else topo for name, topo in groups.items()} for groups in (self.vgroups, self.bgroups, self.igroups, self.pgroups)]
         return self.basetopo.refined.withgroups(*groups)
 
+    def locate(self, geom, coords, **kwargs):
+        return self.basetopo.locate(geom, coords, **kwargs)
+
 
 class OppositeTopology(TransformChainsTopology):
     'opposite topology'
 
-    __slots__ = 'basetopo',
-
     def __init__(self, basetopo):
         self.basetopo = basetopo
         super().__init__(basetopo.space, basetopo.references, basetopo.opposites, basetopo.transforms)
 
     def get_groups(self, *groups: str) -> TransformChainsTopology:
         return ~(self.basetopo.get_groups(*groups))
 
@@ -1804,60 +1848,62 @@
     def __invert__(self):
         return self.basetopo
 
 
 class EmptyTopology(TransformChainsTopology):
     'empty topology'
 
-    __slots__ = ()
-
-    @types.apply_annotations
-    def __init__(self, space: _strictspace, todims: types.strictint, fromdims: types.strictint):
+    def __init__(self, space: str, todims: int, fromdims: int):
+        assert isinstance(space, str), f'space={space!r}'
+        assert isinstance(todims, int), f'todims={todims!r}'
+        assert isinstance(fromdims, int), f'fromdims={fromdims!r}'
         super().__init__(space, References.empty(fromdims), transformseq.EmptyTransforms(todims, fromdims), transformseq.EmptyTransforms(todims, fromdims))
 
     def __or__(self, other):
         if self.space != other.space or self.ndims != other.ndims:
             return NotImplemented
         return other
 
     def __rsub__(self, other):
         return other
 
 
-def StructuredLine(space, root: transform.stricttransformitem, i: types.strictint, j: types.strictint, periodic: bool = False, bnames: types.tuple[types.strictstr] = None):
+def StructuredLine(space, root: transform.TransformItem, i: int, j: int, periodic: bool = False, bnames: Optional[Tuple[str, str]] = None):
+    assert isinstance(i, int), f'i={i!r}'
+    assert isinstance(j, int), f'j={j!r}'
+    assert isinstance(periodic, bool), f'periodic={periodic!r}'
+    assert bnames is None or isinstance(bnames, Sequence) and len(bnames) == 2 and all(isinstance(bname, str) for bname in bnames), f'bnames={bnames!r}'
     if bnames is None:
         bnames = '_structured_line_dummy_boundary_left', '_structured_line_dummy_boundary_right'
-    return StructuredTopology(space, root, axes=(transformseq.DimAxis(i, j, j if periodic else 0, periodic),), nrefine=0, bnames=(bnames,))
+    return StructuredTopology(space, root, axes=(transformseq.DimAxis(i, j, j if periodic else 0, periodic),), nrefine=0, bnames=(tuple(bnames),))
 
 
 class StructuredTopology(TransformChainsTopology):
     'structured topology'
 
-    __slots__ = 'root', 'axes', 'nrefine', 'shape', '_bnames'
-    __cache__ = 'connectivity', 'boundary', 'interfaces'
-
-    @types.apply_annotations
-    def __init__(self, space, root: transform.stricttransformitem, axes: types.tuple[types.strict[transformseq.Axis]], nrefine: types.strictint = 0, bnames: types.tuple[types.tuple[types.strictstr]] = (('left', 'right'), ('bottom', 'top'), ('front', 'back'))):
-        'constructor'
-
-        assert all(len(bname) == 2 for bname in bnames)
+    def __init__(self, space: str, root: transform.TransformItem, axes: Sequence[transformseq.Axis], nrefine: int = 0, bnames: Sequence[Tuple[str, str]] = (('left', 'right'), ('bottom', 'top'), ('front', 'back'))):
+        assert isinstance(space, str), f'space={space!r}'
+        assert isinstance(root, transform.TransformItem), f'root={root!r}'
+        assert isinstance(axes, Sequence) and all(isinstance(axis, transformseq.Axis) for axis in axes), f'axes={axes!r}'
+        assert isinstance(nrefine, int), f'nrefine={nrefine!r}'
+        assert isinstance(bnames, Sequence) and all(isinstance(pair, tuple) and len(pair) == 2 and all(isinstance(name, str) for name in pair) for pair in bnames), f'bnames={bnames!r}'
 
         self.root = root
-        self.axes = axes
-        self.nrefine = nrefine
+        self.axes = tuple(axes)
+        self.nrefine = nrefine.__index__()
         self.shape = tuple(axis.j - axis.i for axis in self.axes if axis.isdim)
-        self._bnames = bnames
+        self._bnames = tuple(bnames)
 
         references = References.uniform(util.product(element.getsimplex(1 if axis.isdim else 0) for axis in self.axes), len(self))
         transforms = transformseq.StructuredTransforms(self.root, self.axes, self.nrefine)
         nbounds = len(self.axes) - len(self.shape)
         if nbounds == 0:
             opposites = transforms
         else:
-            axes = [axis.opposite(nbounds-1) for axis in self.axes]
+            axes = tuple(axis.opposite(nbounds-1) for axis in self.axes)
             opposites = transformseq.StructuredTransforms(self.root, axes, self.nrefine)
 
         super().__init__(space, references, transforms, opposites)
 
     def __repr__(self):
         return '{}<{}>'.format(type(self).__qualname__, 'x'.join(str(axis.j-axis.i)+('p' if axis.isperiodic else '') for axis in self.axes if axis.isdim))
 
@@ -1877,15 +1923,15 @@
         return StructuredTopology(self.space, self.root, axes, self.nrefine, bnames=self._bnames)
 
     @property
     def periodic(self):
         dimaxes = (axis for axis in self.axes if axis.isdim)
         return tuple(idim for idim, axis in enumerate(dimaxes) if axis.isdim and axis.isperiodic)
 
-    @property
+    @cached_property
     def connectivity(self):
         connectivity = numpy.empty(self.shape+(self.ndims, 2), dtype=int)
         connectivity[...] = -1
         ielems = numpy.arange(len(self)).reshape(self.shape)
         for idim in range(self.ndims):
             s = (slice(None),)*idim
             s1 = s + (slice(1, None),)
@@ -1893,28 +1939,28 @@
             connectivity[s2+(..., idim, 0)] = ielems[s1]
             connectivity[s1+(..., idim, 1)] = ielems[s2]
             if idim in self.periodic:
                 connectivity[s+(-1, ..., idim, 0)] = ielems[s+(0,)]
                 connectivity[s+(0, ..., idim, 1)] = ielems[s+(-1,)]
         return types.frozenarray(connectivity.reshape(len(self), self.ndims*2), copy=False)
 
-    @property
+    @cached_property
     def boundary(self):
         'boundary'
 
         nbounds = len(self.axes) - self.ndims
         btopos = [StructuredTopology(self.space, root=self.root, axes=self.axes[:idim] + (bndaxis,) + self.axes[idim+1:], nrefine=self.nrefine, bnames=self._bnames)
                   for idim, axis in enumerate(self.axes)
                   for bndaxis in axis.boundaries(nbounds)]
         if not btopos:
             return EmptyTopology(self.space, self.transforms.todims, self.ndims-1)
         bnames = [bname for bnames, axis in zip(self._bnames, self.axes) if axis.isdim and not axis.isperiodic for bname in bnames]
         return DisjointUnionTopology(btopos, bnames)
 
-    @property
+    @cached_property
     def interfaces(self):
         'interfaces'
 
         assert self.ndims > 0, 'zero-D topology has no interfaces'
         itopos = []
         nbounds = len(self.axes) - self.ndims
         for idim, axis in enumerate(self.axes):
@@ -2046,18 +2092,18 @@
 
         # Cache effectivity
         log.debug('Local knot vector cache effectivity: {}'.format(100*(1.-len(cache)/float(sum(self.shape)))))
 
         # deduplicate stdelems and compute tensorial products `unique` with indices `index`
         # such that unique[index[i,j]] == poly_outer_product(stdelems[0][i], stdelems[1][j])
         index = numpy.array(0)
-        for stdelems_i in stdelems:
+        for dim, stdelems_i in enumerate(stdelems):
             unique_i, index_i = util.unique(stdelems_i, key=types.arraydata)
             unique = unique_i if not index.ndim \
-                else [numeric.poly_outer_product(a, b) for a in unique for b in unique_i]
+                else [poly.mul_different_vars(a[:,None], b[None], dim, 1).reshape(a.shape[0] * b.shape[0], -1) for a in unique for b in unique_i]
             index = index[..., _] * len(unique_i) + index_i
 
         coeffs = [unique[i] for i in index.flat]
         dofmap = [types.frozenarray(vertex_structure[S].ravel(), copy=False) for S in itertools.product(*slices)]
         return coeffs, dofmap, dofshape
 
     def basis_spline(self, degree, removedofs=None, knotvalues=None, knotmultiplicities=None, continuity=-1, periodic=None):
@@ -2208,58 +2254,67 @@
                     temp = N[r]/(lknots[p+r]-lknots[p+r-i-1])
                     N[r] = saved+right[r]*temp
                     saved = left[i-r]*temp
                 N[i+1] = saved
 
         assert all(Ni.order == p for Ni in N)
 
-        return types.frozenarray([Ni.coeffs[::-1] for Ni in N])
+        return types.frozenarray([Ni.coeffs for Ni in N])
 
     def basis_std(self, *args, **kwargs):
         return __class__.basis_spline(self, *args, continuity=0, **kwargs)
 
     def basis_legendre(self, degree: int):
         if self.ndims != 1:
             raise NotImplementedError('legendre is only implemented for 1D topologies')
         return function.LegendreBasis(degree, len(self), self.f_index, self.f_coords)
 
-    @property
+    @cached_property
     def refined(self):
         'refine non-uniformly'
 
         axes = [axis.refined for axis in self.axes]
         return StructuredTopology(self.space, self.root, axes, self.nrefine+1, bnames=self._bnames)
 
-    def locate(self, geom, coords, *, tol, eps=0, weights=None, skip_missing=False, **kwargs):
+    def locate(self, geom, coords, *, tol=0, eps=0, weights=None, skip_missing=False, arguments=None, **kwargs):
         coords = numpy.asarray(coords, dtype=float)
         if geom.ndim == 0:
             geom = geom[_]
             coords = coords[..., _]
         if not geom.shape == coords.shape[1:] == (self.ndims,):
             raise Exception('invalid geometry or point shape for {}D topology'.format(self.ndims))
-        geom0, scale, index = self._asaffine(geom)
-        e = self.sample('uniform', 2).eval(function.norm2(geom0 + index * scale - geom)).max()  # inf-norm on non-gauss sample
-        if e > tol:
-            return super().locate(geom, coords, eps=eps, tol=tol, weights=weights, skip_missing=skip_missing, **kwargs)
-        log.info('locate detected linear geometry: x = {} + {} xi ~{:+.1e}'.format(geom0, scale, e))
-        return self._locate(geom0, scale, coords, eps=eps, weights=weights, skip_missing=skip_missing)
-
-    def _asaffine(self, geom):
-        p0 = p1 = self
-        for (b0, b1), axis in zip(self._bnames, self.axes):
-            if axis.isdim:
-                p0 = p0[:].boundary[b0]
-                p1 = p1[:].boundary[b1]
-        geom0, = p0.sample('gauss', 0).eval(geom)
-        geom1, = p1.sample('gauss', 0).eval(geom)
-        funcsp = self.basis('std', degree=1, periodic=())
-        verts = numeric.meshgrid(*map(numpy.arange, numpy.array(self.shape)+1)).reshape(self.ndims, -1)
-        index = (funcsp * verts).sum(-1)
-        scale = (geom1 - geom0) / numpy.array(self.shape)
-        return geom0, scale, index
+        if tol or eps:
+            if arguments:
+                geom0, scale, error = self._asaffine(geom, arguments)
+            elif geom is getattr(self, '_asaffine_geom', None):
+                log.debug('locate found previously computed affine values')
+                geom0, scale, error = self._asaffine_retval
+            else:
+                self._asaffine_geom = geom
+                geom0, scale, error = self._asaffine_retval = self._asaffine(geom, {})
+            if all(error <= numpy.maximum(tol, eps * scale)):
+                log.debug('locate detected linear geometry: x = {} + {} xi ~{}'.format(geom0, scale, error))
+                return self._locate(geom0, scale, coords, eps=eps, weights=weights, skip_missing=skip_missing)
+        return super().locate(geom, coords, eps=eps, tol=tol, weights=weights, skip_missing=skip_missing, arguments=arguments, **kwargs)
+
+    def _asaffine(self, geom, arguments):
+        # determine geom0, scale, error such that geom ~= geom0 + index * scale + error
+        n = 2 + (1 in self.shape) # number of sample points required to establish nonlinearity
+        sampleshape = numpy.multiply(self.shape, n) # shape of uniform sample
+        geom_ = self.sample('uniform', n).eval(geom, **arguments) \
+            .reshape(*self.shape, *[n] * self.ndims, self.ndims) \
+            .transpose(*(i+j for i in range(self.ndims) for j in (0, self.ndims)), self.ndims*2) \
+            .reshape(*sampleshape, self.ndims)
+        # strategy: fit an affine plane through the minima and maxima of a uniform sample,
+        # and evaluate the error as the largest difference on the remaining sample points
+        xmin, xmax = geom_.reshape(-1, self.ndims)[[0, -1]]
+        dx = (xmax - xmin) / (sampleshape-1) # x = x0 + dx * (i + .5) => xmax - xmin = dx * (sampleshape-1)
+        for idim in range(self.ndims):
+            geom_[...,idim] -= xmin[idim] + dx[idim] * numpy.arange(sampleshape[idim]).reshape([-1 if i == idim else 1 for i in range(self.ndims)])
+        return xmin - dx/2, dx * n, numpy.abs(geom_).reshape(-1, self.ndims).max(axis=0)
 
     def _locate(self, geom0, scale, coords, *, eps=0, weights=None, skip_missing=False):
         mincoords, maxcoords = numpy.sort([geom0, geom0 + scale * self.shape], axis=0)
         missing = numpy.any(numpy.less(coords, mincoords - eps) | numpy.greater(coords, maxcoords + eps), axis=1)
         if not skip_missing and missing.any():
             raise LocateError('failed to locate {}/{} points'.format(missing.sum(), len(coords)))
         xi = (coords - geom0) / scale
@@ -2276,45 +2331,60 @@
 
         return '{}({})'.format(self.__class__.__name__, 'x'.join(str(n) for n in self.shape))
 
 
 class ConnectedTopology(TransformChainsTopology):
     'unstructured topology with connectivity'
 
-    __slots__ = 'connectivity',
-
-    @types.apply_annotations
-    def __init__(self, space, references: types.strict[References], transforms: transformseq.stricttransforms, opposites: transformseq.stricttransforms, connectivity: types.tuple[types.arraydata]):
+    def __init__(self, space: str, references: References, transforms: transformseq.Transforms, opposites: transformseq.Transforms, connectivity: Sequence[numpy.ndarray]):
+        assert isinstance(space, str), f'space={space!r}'
+        assert isinstance(references, References), f'references={references!r}'
+        assert isinstance(transforms, transformseq.Transforms), f'transforms={transforms!r}'
+        assert isinstance(opposites, transformseq.Transforms), f'opposites={opposites!r}'
+        assert isinstance(connectivity, numpy.ndarray) and connectivity.ndim == 2 and connectivity.dtype.kind == 'i' or isinstance(connectivity, Sequence) and all(isinstance(item, numpy.ndarray) and item.ndim == 1 and item.dtype.kind == 'i' for item in connectivity), f'connectivity={connectivity!r}'
         assert len(connectivity) == len(references) and all(c.shape[0] == e.nedges for c, e in zip(connectivity, references))
-        self.connectivity = tuple(map(numpy.asarray, connectivity))
+
+        self.connectivity = types.frozenarray(connectivity) if isinstance(connectivity, numpy.ndarray) else tuple(map(types.frozenarray, connectivity))
         super().__init__(space, references, transforms, opposites)
 
 
 class SimplexTopology(TransformChainsTopology):
     'simpex topology'
 
-    __slots__ = 'simplices', 'references', 'transforms', 'opposites'
-    __cache__ = 'connectivity'
-
     def _renumber(simplices):
         simplices = numpy.asarray(simplices)
         keep = numpy.zeros(simplices.max()+1, dtype=bool)
         keep[simplices.flat] = True
         return types.arraydata(simplices if keep.all() else (numpy.cumsum(keep)-1)[simplices])
 
-    @types.apply_annotations
-    def __init__(self, space, simplices: _renumber, transforms: transformseq.stricttransforms, opposites: transformseq.stricttransforms):
+    def __init__(self, space: str, simplices: numpy.ndarray, transforms: transformseq.Transforms, opposites: transformseq.Transforms):
+        assert isinstance(space, str), f'space={space!r}'
+        assert isinstance(simplices, numpy.ndarray), f'simplices={simplices!r}'
         assert simplices.shape == (len(transforms), transforms.fromdims+1)
         self.simplices = numpy.asarray(simplices)
         assert numpy.greater(self.simplices[:, 1:], self.simplices[:, :-1]).all(), 'nodes should be sorted'
         assert not numpy.equal(self.simplices[:, 1:], self.simplices[:, :-1]).all(), 'duplicate nodes'
         references = References.uniform(element.getsimplex(transforms.fromdims), len(transforms))
         super().__init__(space, references, transforms, opposites)
 
-    @property
+    def take_unchecked(self, indices):
+        space, = self.spaces
+        return SimplexTopology(space, self.simplices[indices], self.transforms[indices], self.opposites[indices])
+
+    @cached_property
+    def boundary(self):
+        space, = self.spaces
+        ielem, iedge = (self.connectivity == -1).nonzero()
+        nd = self.ndims
+        edges = numpy.arange(nd+1).repeat(nd).reshape(nd,nd+1).T[::-1]
+        simplices = self.simplices[ielem, edges[iedge].T].T
+        transforms = self.transforms.edges(self.references)[ielem * (nd+1) + iedge]
+        return SimplexTopology(space, simplices, transforms, transforms)
+
+    @cached_property
     def connectivity(self):
         nverts = self.ndims + 1
         edge_vertices = numpy.arange(nverts).repeat(self.ndims).reshape(self.ndims, nverts)[:, ::-1].T  # nverts x ndims
         simplices_edges = self.simplices.take(edge_vertices, axis=1)  # nelems x nverts x ndims
         elems, edges = divmod(numpy.lexsort(simplices_edges.reshape(-1, self.ndims).T), nverts)
         sorted_simplices_edges = simplices_edges[elems, edges]  # (nelems x nverts) x ndims; matching edges are now adjacent
         i, = numpy.equal(sorted_simplices_edges[1:], sorted_simplices_edges[:-1]).all(axis=1).nonzero()
@@ -2331,35 +2401,33 @@
             return function.PlainBasis([coeffs] * len(self), self.simplices, self.simplices.max()+1, self.f_index, self.f_coords)
         return super().basis_std(degree)
 
     def basis_bubble(self):
         'bubble from vertices'
 
         bernstein = element.getsimplex(self.ndims).get_poly_coeffs('bernstein', degree=1)
-        bubble = functools.reduce(numeric.poly_mul, bernstein)
-        coeffs = numpy.zeros((len(bernstein)+1,) + bubble.shape)
-        coeffs[(slice(-1),)+(slice(2),)*self.ndims] = bernstein
+        bubble = reduce(lambda l, r: poly.mul_same_vars(l, r, self.ndims), bernstein)
+        coeffs = numpy.zeros((len(bernstein)+1, poly.ncoeffs(self.ndims, 1 + self.ndims)))
+        coeffs[:-1] = poly.change_degree(bernstein, self.ndims, 1 + self.ndims) - bubble[None] / (self.ndims+1)
         coeffs[-1] = bubble
-        coeffs[:-1] -= bubble / (self.ndims+1)
         coeffs = types.frozenarray(coeffs, copy=False)
         nverts = self.simplices.max() + 1
         ndofs = nverts + len(self)
         nmap = [types.frozenarray(numpy.hstack([idofs, nverts+ielem]), copy=False) for ielem, idofs in enumerate(self.simplices)]
         return function.PlainBasis([coeffs] * len(self), nmap, ndofs, self.f_index, self.f_coords)
 
 
 class UnionTopology(TransformChainsTopology):
     'grouped topology'
 
-    __slots__ = '_topos', '_names', 'references', 'transforms', 'opposites'
-
-    @types.apply_annotations
-    def __init__(self, topos: types.tuple[stricttopology], names: types.tuple[types.strictstr] = ()):
-        self._topos = topos
-        self._names = tuple(names)[:len(self._topos)]
+    def __init__(self, topos: Sequence[Topology], names: Sequence[str] = ()):
+        assert isinstance(topos, Sequence) and all(isinstance(topo, Topology) for topo in topos), f'topos={topos!r}'
+        assert isinstance(names, Sequence) and all(isinstance(name, str) for name in names), f'names={names!r}'
+        self._topos = tuple(topos)
+        self._names = tuple(names[:len(topos)])
         assert len(set(self._names)) == len(self._names), 'duplicate name'
         ndims = self._topos[0].ndims
         assert all(topo.ndims == ndims for topo in self._topos)
         space = self._topos[0].space
         assert all(topo.space == space for topo in self._topos)
 
         references = []
@@ -2394,37 +2462,36 @@
             space,
             References.from_iter(references, ndims),
             transformseq.chain((topo.transforms[selection] for topo, selection in zip(topos, selections)), topos[0].transforms.todims, ndims),
             transformseq.chain((topo.opposites[selection] for topo, selection in zip(topos, selections)), topos[0].transforms.todims, ndims))
 
     def get_groups(self, *groups: str) -> TransformChainsTopology:
         topos = (topo if name in groups else topo.get_groups(*groups) for topo, name in itertools.zip_longest(self._topos, self._names))
-        return functools.reduce(operator.or_, filter(None, topos), self.empty_like())
+        return reduce(operator.or_, filter(None, topos), self.empty_like())
 
     def __or__(self, other):
         if not isinstance(other, TransformChainsTopology):
             return super().__or__(other)
         if not isinstance(other, UnionTopology):
             return UnionTopology(self._topos + (other,), self._names)
         return UnionTopology(self._topos[:len(self._names)] + other._topos + self._topos[len(self._names):], self._names + other._names)
 
-    @property
+    @cached_property
     def refined(self):
         return UnionTopology([topo.refined for topo in self._topos], self._names)
 
 
 class DisjointUnionTopology(TransformChainsTopology):
     'grouped topology'
 
-    __slots__ = '_topos', '_names'
-
-    @types.apply_annotations
-    def __init__(self, topos: types.tuple[stricttopology], names: types.tuple[types.strictstr] = ()):
-        self._topos = topos
-        self._names = tuple(names)[:len(self._topos)]
+    def __init__(self, topos: Sequence[Topology], names: Sequence[str] = ()):
+        assert isinstance(topos, Sequence) and all(isinstance(topo, Topology) for topo in topos), f'topos={topos!r}'
+        assert isinstance(names, Sequence) and all(isinstance(name, str) for name in names), f'names={names!r}'
+        self._topos = tuple(topos)
+        self._names = tuple(names[:len(topos)])
         assert len(set(self._names)) == len(self._names), 'duplicate name'
         ndims = self._topos[0].ndims
         assert all(topo.ndims == ndims for topo in self._topos)
         space = self._topos[0].space
         assert all(topo.space == space for topo in self._topos)
         super().__init__(
             space,
@@ -2438,31 +2505,28 @@
         if len(topos) == 0:
             return self.empty_like()
         elif len(topos) == 1:
             return topos[0]
         else:
             return DisjointUnionTopology(topos)
 
-    @property
+    @cached_property
     def refined(self):
         return DisjointUnionTopology([topo.refined for topo in self._topos], self._names)
 
 
 class SubsetTopology(TransformChainsTopology):
     'trimmed'
 
-    __slots__ = 'refs', 'basetopo', 'newboundary', '_indices'
-    __cache__ = 'connectivity', 'boundary', 'interfaces', 'refined'
-
-    @types.apply_annotations
-    def __init__(self, basetopo: stricttopology, refs: types.tuple[element.strictreference], newboundary=None):
-        if newboundary is not None:
-            assert isinstance(newboundary, str) or isinstance(newboundary, TransformChainsTopology) and newboundary.ndims == basetopo.ndims-1
+    def __init__(self, basetopo: Topology, refs: Sequence[element.Reference], newboundary: Optional[Union[str,TransformChainsTopology]] = None):
+        assert isinstance(basetopo, Topology), f'basetopo={basetopo!r}'
+        assert isinstance(refs, Sequence) and all(isinstance(ref, element.Reference) for ref in refs), f'refs={refs!r}'
+        assert newboundary is None or isinstance(newboundary, str) or isinstance(newboundary, TransformChainsTopology) and newboundary.ndims == basetopo.ndims-1, f'newboundary={newboundary!r}'
         assert len(refs) == len(basetopo)
-        self.refs = refs
+        self.refs = tuple(refs)
         self.basetopo = basetopo
         self.newboundary = newboundary
 
         self._indices = types.frozenarray(numpy.array([i for i, ref in enumerate(self.refs) if ref], dtype=int), copy=False)
         references = References.from_iter(self.refs, self.basetopo.ndims).take(self._indices)
         transforms = self.basetopo.transforms[self._indices]
         opposites = self.basetopo.opposites[self._indices]
@@ -2481,29 +2545,29 @@
         if not isinstance(other, SubsetTopology) or self.basetopo != other.basetopo:
             return super().__or__(other)
         refs = [ref1 | ref2 for ref1, ref2 in zip(self.refs, other.refs)]
         if all(baseref == ref for baseref, ref in zip(self.basetopo.references, refs)):
             return self.basetopo
         return SubsetTopology(self.basetopo, refs)  # TODO boundary
 
-    @property
+    @cached_property
     def connectivity(self):
         renumber = numeric.invmap([i for i, ref in enumerate(self.refs) if ref], length=len(self.refs)+1, missing=-1)  # length=..+1 serves to map -1 to -1
         return tuple(types.frozenarray(numpy.concatenate([renumber.take(ioppelems), numpy.repeat(-1, ref.nedges-len(ioppelems))]), copy=False)
                      for ref, ioppelems in zip(self.refs, self.basetopo.connectivity) if ref)
 
-    @property
+    @cached_property
     def refined(self):
         child_refs = self.references.children
         indices = types.frozenarray(numpy.array([i for i, ref in enumerate(child_refs) if ref], dtype=int), copy=False)
         refined_transforms = self.transforms.refined(self.references)[indices]
         self_refined = TransformChainsTopology(self.space, child_refs[indices], refined_transforms, refined_transforms)
         return self.basetopo.refined.subset(self_refined, self.newboundary.refined if isinstance(self.newboundary, TransformChainsTopology) else self.newboundary, strict=True)
 
-    @property
+    @cached_property
     def boundary(self):
         baseboundary = self.basetopo.boundary
         baseconnectivity = self.basetopo.connectivity
         brefs = [ref.empty for ref in baseboundary.references]
         trimmedreferences = []
         trimmedtransforms = []
         trimmedopposites = []
@@ -2527,33 +2591,33 @@
                     # possibility this opposite (partially) disappeared, in which case
                     # the exposed part is added to the trimmed group.
                     ioppedge = util.index(baseconnectivity[ioppelem], ielem)
                     oppref = self.refs[ioppelem]
                     edgeref -= oppref.edge_refs[ioppedge]
                     if edgeref:
                         trimmedreferences.append(edgeref)
-                        trimmedtransforms.append(elemtrans+(edgetrans,))
-                        trimmedopposites.append(self.basetopo.transforms[ioppelem]+(oppref.edge_transforms[ioppedge],))
+                        trimmedtransforms.append(transform.canonical((*elemtrans, edgetrans)))
+                        trimmedopposites.append(transform.canonical((*self.basetopo.transforms[ioppelem], oppref.edge_transforms[ioppedge])))
             # The last edges of newref (beyond the number of edges of the original)
             # cannot have opposites and are added to the trimmed group directly.
             for edgetrans, edgeref in newref.edges[len(ioppelems):]:
                 trimmedreferences.append(edgeref)
-                trimmedtransforms.append(elemtrans+(edgetrans,))
-                trimmedopposites.append(elemtrans+(edgetrans.flipped,))
+                trimmedtransforms.append(transform.canonical((*elemtrans, edgetrans)))
+                trimmedopposites.append(transform.canonical((*elemtrans, edgetrans.flipped)))
         origboundary = SubsetTopology(baseboundary, brefs)
         if isinstance(self.newboundary, TransformChainsTopology):
             trimmedbrefs = [ref.empty for ref in self.newboundary.references]
             for ref, trans in zip(trimmedreferences, trimmedtransforms):
                 trimmedbrefs[self.newboundary.transforms.index(trans)] = ref
             trimboundary = SubsetTopology(self.newboundary, trimmedbrefs)
         else:
-            trimboundary = TransformChainsTopology(self.space, References.from_iter(trimmedreferences, self.ndims-1), transformseq.PlainTransforms(trimmedtransforms, self.transforms.todims, self.ndims-1), transformseq.PlainTransforms(trimmedopposites, self.transforms.todims, self.ndims-1))
+            trimboundary = TransformChainsTopology(self.space, References.from_iter(trimmedreferences, self.ndims-1), transformseq.PlainTransforms(tuple(trimmedtransforms), self.transforms.todims, self.ndims-1), transformseq.PlainTransforms(tuple(trimmedopposites), self.transforms.todims, self.ndims-1))
         return DisjointUnionTopology([trimboundary, origboundary], names=[self.newboundary] if isinstance(self.newboundary, str) else [])
 
-    @property
+    @cached_property
     def interfaces(self):
         baseinterfaces = self.basetopo.interfaces
         superinterfaces = super().interfaces
         irefs = [ref.empty for ref in baseinterfaces.references]
         for ref, trans, opp in zip(superinterfaces.references, superinterfaces.transforms, superinterfaces.opposites):
             try:
                 iielem = baseinterfaces.transforms.index(trans)
@@ -2601,34 +2665,31 @@
         assert not missing
         return Sample.new(sample.space, [trans[selection] for trans in sample.transforms], PointsSequence.from_iter(newpoints, sample.ndims))
 
 
 class RefinedTopology(TransformChainsTopology):
     'refinement'
 
-    __slots__ = 'basetopo',
-    __cache__ = 'boundary', 'connectivity'
-
-    @types.apply_annotations
-    def __init__(self, basetopo: stricttopology):
+    def __init__(self, basetopo: Topology):
+        assert isinstance(basetopo, Topology), f'basetopo={basetopo!r}'
         self.basetopo = basetopo
         super().__init__(
             self.basetopo.space,
             self.basetopo.references.children,
             self.basetopo.transforms.refined(self.basetopo.references),
             self.basetopo.opposites.refined(self.basetopo.references))
 
     def get_groups(self, *groups: str) -> TransformChainsTopology:
         return self.basetopo.get_groups(*groups).refined
 
-    @property
+    @cached_property
     def boundary(self):
         return self.basetopo.boundary.refined
 
-    @property
+    @cached_property
     def connectivity(self):
         offsets = numpy.cumsum([0] + [ref.nchildren for ref in self.basetopo.references])
         connectivity = [offset + edges for offset, ref in zip(offsets, self.basetopo.references) for edges in ref.connectivity]
         for ielem, edges in enumerate(self.basetopo.connectivity):
             for iedge, jelem in enumerate(edges):
                 if jelem == -1:
                     for ichild, ichildedge in self.basetopo.references[ielem].edgechildren[iedge]:
@@ -2640,25 +2701,19 @@
                         connectivity[offsets[jelem]+jchild][jchildedge] = offsets[ielem]+ichild
         return tuple(types.frozenarray(c, copy=False) for c in connectivity)
 
 
 class HierarchicalTopology(TransformChainsTopology):
     'collection of nested topology elments'
 
-    __slots__ = 'basetopo', 'levels', '_indices_per_level', '_offsets'
-    __cache__ = 'refined', 'boundary', 'interfaces'
-
-    @types.apply_annotations
-    def __init__(self, basetopo: stricttopology, indices_per_level: types.tuple[types.arraydata]):
-        'constructor'
-
-        assert all(ind.dtype == int for ind in indices_per_level)
-        assert not isinstance(basetopo, HierarchicalTopology)
+    def __init__(self, basetopo: Topology, indices_per_level: Sequence[numpy.ndarray]):
+        assert isinstance(basetopo, Topology) and not isinstance(basetopo, HierarchicalTopology), f'basetopo={basetopo!r}'
+        assert isinstance(indices_per_level, Sequence) and all(isinstance(indices, numpy.ndarray) and indices.ndim == 1 and indices.dtype.kind == 'i' for indices in indices_per_level), f'indices_per_level={indices_per_level!r}'
         self.basetopo = basetopo
-        self._indices_per_level = tuple(map(numpy.asarray, indices_per_level))
+        self._indices_per_level = tuple(map(types.frozenarray, indices_per_level))
         self._offsets = numpy.cumsum([0, *map(len, self._indices_per_level)], dtype=int)
 
         level = None
         levels = []
         references = References.empty(basetopo.ndims)
         transforms = []
         opposites = []
@@ -2703,49 +2758,42 @@
 
     def slice_unchecked(self, __s: slice, __idim: int) -> 'HierarchicalTopology':
         return self._rebase(self.basetopo.slice_unchecked(__s, __idim))
 
     def get_groups(self, *groups: str) -> 'HierarchicalTopology':
         return self._rebase(self.basetopo.get_groups(*groups))
 
-    def refined_by(self, refine):
-        if isinstance(refine, Topology):
-            refine = refine.transforms
-        else:
-            refine = tuple(refine)
-        if not all(map(numeric.isint, refine)):
-            refine = tuple(self.transforms.index_with_tail(item)[0] for item in refine)
-        refine = numpy.unique(numpy.array(refine, dtype=int))
+    def _refined_by(self, refine):
         splits = numpy.searchsorted(refine, self._offsets, side='left')
         indices_per_level = list(map(list, self._indices_per_level))+[[]]
         fine = self.basetopo
         for ilevel, (start, stop) in enumerate(zip(splits[:-1], splits[1:])):
             coarse, fine = fine, fine.refined
             coarse_indices = tuple(map(indices_per_level[ilevel].pop, reversed(refine[start:stop]-self._offsets[ilevel])))
             coarse_transforms = map(coarse.transforms.__getitem__, coarse_indices)
             coarse_references = map(coarse.references.__getitem__, coarse_indices)
             fine_transforms = (trans+(ctrans,) for trans, ref in zip(coarse_transforms, coarse_references) for ctrans, cref in ref.children if cref)
             indices_per_level[ilevel+1].extend(map(fine.transforms.index, fine_transforms))
         if not indices_per_level[-1]:
             indices_per_level.pop(-1)
         return HierarchicalTopology(self.basetopo, ([numpy.unique(numpy.array(i, dtype=int)) for i in indices_per_level]))
 
-    @property
+    @cached_property
     def refined(self):
         refined_indices_per_level = [numpy.array([], dtype=int)]
         fine = self.basetopo
         for coarse_indices in self._indices_per_level:
             coarse, fine = fine, fine.refined
             coarse_transforms = map(coarse.transforms.__getitem__, coarse_indices)
             coarse_references = map(coarse.references.__getitem__, coarse_indices)
             fine_transforms = (trans+(ctrans,) for trans, ref in zip(coarse_transforms, coarse_references) for ctrans, cref in ref.children if cref)
             refined_indices_per_level.append(numpy.unique(numpy.fromiter(map(fine.transforms.index, fine_transforms), dtype=int)))
         return HierarchicalTopology(self.basetopo, refined_indices_per_level)
 
-    @property
+    @cached_property
     @log.withcontext
     def boundary(self):
         'boundary elements'
 
         basebtopo = self.basetopo.boundary
         bindices_per_level = []
         for indices, level, blevel in zip(self._indices_per_level, self.basetopo.refine_iter, basebtopo.refine_iter):
@@ -2762,15 +2810,15 @@
             bindices = numpy.array(bindices, dtype=int)
             if len(bindices) > 1:
                 bindices.sort()
                 assert not numpy.equal(bindices[1:], bindices[:-1]).any()
             bindices_per_level.append(bindices)
         return HierarchicalTopology(basebtopo, bindices_per_level)
 
-    @property
+    @cached_property
     @log.withcontext
     def interfaces(self):
         'interfaces'
 
         hreferences = References.empty(self.ndims-1)
         htransforms = []
         hopposites = []
@@ -2914,15 +2962,15 @@
                 else:  # truncated hierarchical basis
 
                     for h, ilocal in reversed(tuple(enumerate(local_indices))):  # loop from fine to coarse
                         mydofs = ubases[h].get_dofs(ilocal)
                         mypoly = ubases[h].get_coefficients(ilocal)
 
                         truncpoly = mypoly if h == len(tail) \
-                            else numpy.tensordot(numpy.tensordot(tail[h].transform_poly(mypoly), project[..., mypassive], self.ndims), truncpoly[mypassive], 1)
+                            else tail[h].transform_poly(mypoly) @ project[..., mypassive] @ truncpoly[mypassive]
 
                         imyactive = numeric.sorted_index(ubasis_active[h], mydofs, missing=-1)
                         myactive = numpy.greater_equal(imyactive, 0) & numpy.greater(abs(truncpoly), truncation_tolerance).any(axis=tuple(range(1, truncpoly.ndim)))
                         if myactive.any():
                             trans_dofs.append(offsets[h]+imyactive[myactive])
                             trans_coeffs.append(truncpoly[myactive])
 
@@ -2936,54 +2984,44 @@
                             P = mypoly.reshape(len(mypoly), -1)
                             U, S, V = numpy.linalg.svd(P)  # (U * S).dot(V[:len(S)]) == P
                             project = (V.T[:, :len(S)] / S).dot(U.T).reshape(mypoly.shape[1:]+mypoly.shape[:1])
                             projectcache[id(mypoly)] = project, mypoly  # NOTE: mypoly serves to keep array alive
 
                 # add the dofs and coefficients to the hierarchical basis
                 hbasis_dofs.append(numpy.concatenate(trans_dofs))
-                hbasis_coeffs.append(numeric.poly_concatenate(*trans_coeffs))
+                degree = poly.degree(self.ndims, max(c.shape[-1] for c in trans_coeffs))
+                hbasis_coeffs.append(numpy.concatenate([poly.change_degree(c, self.ndims, degree) for c in trans_coeffs], axis=0))
 
         return function.PlainBasis(hbasis_coeffs, hbasis_dofs, ndofs, self.f_index, self.f_coords)
 
 
-class PatchBoundary(types.Singleton):
+@dataclass(eq=True, frozen=True)
+class PatchBoundary:
 
-    __slots__ = 'id', 'dim', 'side', 'reverse', 'transpose'
-
-    @types.apply_annotations
-    def __init__(self, id: types.tuple[types.strictint], dim, side, reverse: types.tuple[bool], transpose: types.tuple[types.strictint]):
-        super().__init__()
-        self.id = id
-        self.dim = dim
-        self.side = side
-        self.reverse = reverse
-        self.transpose = transpose
+    id: Tuple[int, ...]
+    dim: int
+    side: int
+    reverse: Tuple[bool, ...]
+    transpose: Tuple[int, ...]
 
     def apply_transform(self, array):
         return array[tuple(slice(None, None, -1) if i else slice(None) for i in self.reverse)].transpose(self.transpose)
 
 
-class Patch(types.Singleton):
-
-    __slots__ = 'topo', 'verts', 'boundaries'
+@dataclass(eq=True, frozen=True)
+class Patch:
 
-    @types.apply_annotations
-    def __init__(self, topo: stricttopology, verts: types.arraydata, boundaries: types.tuple[types.strict[PatchBoundary]]):
-        super().__init__()
-        self.topo = topo
-        self.verts = numpy.asarray(verts)
-        self.boundaries = boundaries
+    topo: Topology
+    verts: types.arraydata
+    boundaries: Tuple[PatchBoundary, ...]
 
 
 class MultipatchTopology(TransformChainsTopology):
     'multipatch topology'
 
-    __slots__ = 'patches',
-    __cache__ = '_patchinterfaces', 'boundary', 'interfaces', 'refined', 'connectivity'
-
     @staticmethod
     def build_boundarydata(connectivity):
         'build boundary data based on connectivity'
 
         boundarydata = []
         for patch in connectivity:
             ndims = len(patch.shape)
@@ -3005,19 +3043,17 @@
                 # boundarid
                 boundaryid = tuple(verts[..., 0].flat)
                 patchboundarydata.append(PatchBoundary(boundaryid, dim, side, reverse, transpose))
             boundarydata.append(tuple(patchboundarydata))
 
         return boundarydata
 
-    @types.apply_annotations
-    def __init__(self, patches: types.tuple[types.strict[Patch]]):
-        'constructor'
-
-        self.patches = patches
+    def __init__(self, patches: Sequence[Patch]):
+        assert isinstance(patches, Sequence) and all(isinstance(patch, Patch) for patch in patches), f'patches={patches!r}'
+        self.patches = tuple(patches)
 
         space = patches[0].topo.space
         assert all(patch.topo.space == space for patch in patches)
 
         for boundaryid, patchdata in self._patchinterfaces.items():
             if len(patchdata) == 1:
                 continue
@@ -3032,15 +3068,15 @@
 
         super().__init__(
             space,
             util.sum(patch.topo.references for patch in self.patches),
             transformseq.chain([patch.topo.transforms for patch in self.patches], self.patches[0].topo.transforms.todims, self.patches[0].topo.ndims),
             transformseq.chain([patch.topo.opposites for patch in self.patches], self.patches[0].topo.transforms.todims, self.patches[0].topo.ndims))
 
-    @property
+    @cached_property
     def _patchinterfaces(self):
         patchinterfaces = {}
         for patch in self.patches:
             for boundary in patch.boundaries:
                 patchinterfaces.setdefault(boundary.id, []).append((patch.topo, boundary))
         return types.frozendict({
             boundaryid: tuple(data)
@@ -3158,17 +3194,17 @@
 
     def basis_patch(self):
         'degree zero patchwise discontinuous basis'
 
         transforms = transformseq.PlainTransforms(tuple((patch.topo.root,) for patch in self.patches), self.ndims, self.ndims)
         index = function.transforms_index(self.space, transforms)
         coords = function.transforms_coords(self.space, transforms)
-        return function.DiscontBasis([types.frozenarray(1, dtype=float).reshape(1, *(1,)*self.ndims)]*len(self.patches), index, coords)
+        return function.DiscontBasis([types.frozenarray([[1]], dtype=float)]*len(self.patches), index, coords)
 
-    @property
+    @cached_property
     def boundary(self):
         'boundary'
 
         subtopos = []
         subnames = []
         for i, patch in enumerate(self.patches):
             for boundary in patch.boundaries:
@@ -3178,25 +3214,25 @@
                 subtopos.append(patch.topo.boundary[name])
                 subnames.append('patch{}-{}'.format(i, name))
         if len(subtopos) == 0:
             return EmptyTopology(self.space, self.transforms.todims, self.ndims-1)
         else:
             return DisjointUnionTopology(subtopos, subnames)
 
-    @property
+    @cached_property
     def interfaces(self):
         '''interfaces
 
         Return a topology with all element interfaces.  The patch interfaces are
         accessible via the group ``'interpatch'`` and the interfaces *inside* a
         patch via ``'intrapatch'``.
         '''
 
         intrapatchtopo = EmptyTopology(self.space, self.transforms.todims, self.ndims-1) if not self.patches else \
-            DisjointUnionTopology(patch.topo.interfaces for patch in self.patches)
+            DisjointUnionTopology([patch.topo.interfaces for patch in self.patches])
 
         btopos = []
         bconnectivity = []
         for boundaryid, patchdata in self._patchinterfaces.items():
             if len(patchdata) > 2:
                 raise ValueError('Cannot create interfaces of multipatch topologies with more than two interface connections.')
             pairs = []
@@ -3207,28 +3243,28 @@
                     references = numeric.asobjvector(btopo.references).reshape(btopo.shape)
                     references = references[tuple(_ if i == boundary.dim else slice(None) for i in range(self.ndims))]
                     references = boundary.apply_transform(references)[..., 0]
                     references = tuple(references.flat)
                 transforms = numeric.asobjvector(btopo.transforms).reshape(btopo.shape)
                 transforms = transforms[tuple(_ if i == boundary.dim else slice(None) for i in range(self.ndims))]
                 transforms = boundary.apply_transform(transforms)[..., 0]
-                pairs.append(tuple(transforms.flat))
+                pairs.append(tuple(map(transform.canonical, transforms.flat)))
             # create structured topology of joined element pairs
             references = References.from_iter(references, self.ndims-1)
             transforms, opposites = pairs
             transforms = transformseq.PlainTransforms(transforms, self.transforms.todims, self.ndims-1)
             opposites = transformseq.PlainTransforms(opposites, self.transforms.todims, self.ndims-1)
             btopos.append(TransformChainsTopology(self.space, references, transforms, opposites))
             bconnectivity.append(numpy.array(boundaryid).reshape((2,)*(self.ndims-1)))
         # create multipatch topology of interpatch boundaries
         interpatchtopo = MultipatchTopology(tuple(map(Patch, btopos, bconnectivity, self.build_boundarydata(bconnectivity))))
 
         return DisjointUnionTopology((intrapatchtopo, interpatchtopo), ('intrapatch', 'interpatch'))
 
-    @property
+    @cached_property
     def connectivity(self):
         connectivity = []
         patchinterfaces = {}
         for patch in self.patches:  # len(connectivity) represents the element offset for the current patch
             ielems = numpy.arange(len(patch.topo)).reshape(patch.topo.shape) + len(connectivity)
             for boundary in patch.boundaries:
                 patchinterfaces.setdefault(boundary.id, []).append((boundary.apply_transform(ielems)[..., 0], boundary.dim * 2 + (boundary.side == 0)))
@@ -3242,14 +3278,14 @@
                 assert ielem.shape == jelem.shape
                 assert numpy.equal(connectivity[ielem, iedge], -1).all()
                 assert numpy.equal(connectivity[jelem, jedge], -1).all()
                 connectivity[ielem, iedge] = jelem
                 connectivity[jelem, jedge] = ielem
         return types.frozenarray(connectivity, copy=False)
 
-    @property
+    @cached_property
     def refined(self):
         'refine'
 
-        return MultipatchTopology(Patch(patch.topo.refined, patch.verts, patch.boundaries) for patch in self.patches)
+        return MultipatchTopology(tuple(Patch(patch.topo.refined, patch.verts, patch.boundaries) for patch in self.patches))
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/transformseq.py` & `nutils-8.0/nutils/transformseq.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 """The transformseq module."""
 
 from typing import Tuple
-from . import types, numeric, util, transform, element, evaluable
+from numbers import Integral
+from . import types, numeric, _util as util, transform, element
+from ._backports import cached_property
 from .elementseq import References
-from .transform import TransformChain, EvaluableTransformChain
+from .transform import TransformChain
 import abc
 import itertools
 import operator
 import numpy
 
 
 class Transforms(types.Singleton):
@@ -38,18 +40,17 @@
 
     Notes
     -----
     Subclasses must implement :meth:`__getitem__`, :meth:`__len__` and
     :meth:`index_with_tail`.
     '''
 
-    __slots__ = 'todims', 'fromdims'
-
-    @types.apply_annotations
-    def __init__(self, todims: types.strictint, fromdims: types.strictint):
+    def __init__(self, todims: Integral, fromdims: Integral):
+        assert isinstance(todims, Integral), f'todims={todims!r}'
+        assert isinstance(fromdims, Integral), f'fromdims={fromdims!r}'
         if not 0 <= fromdims <= todims:
             raise ValueError('invalid dimensions')
         self.todims = todims
         self.fromdims = fromdims
         super().__init__()
 
     @abc.abstractmethod
@@ -65,42 +66,42 @@
             raise NotImplementedError
         elif isinstance(index, slice):
             index = range(len(self))[index]
             if index == range(len(self)):
                 return self
             if index.step < 0:
                 raise NotImplementedError('reordering the sequence is not yet implemented')
-            return MaskedTransforms(self, numpy.arange(index.start, index.stop, index.step))
+            return MaskedTransforms(self, types.arraydata(numpy.arange(index.start, index.stop, index.step)))
         elif numeric.isintarray(index):
             if index.ndim != 1:
                 raise IndexError('invalid index')
             if numpy.any(numpy.less(index, 0)) or numpy.any(numpy.greater_equal(index, len(self))):
                 raise IndexError('index out of range')
             dindex = numpy.diff(index)
             if len(index) == len(self) and (len(self) == 0 or (index[0] == 0 and numpy.all(numpy.equal(dindex, 1)))):
                 return self
             if numpy.any(numpy.equal(dindex, 0)):
                 raise ValueError('repeating an element is not allowed')
             if not numpy.all(numpy.greater(dindex, 0)):
                 s = numpy.argsort(index)
-                return ReorderedTransforms(self[index[s]], numpy.argsort(s))
+                return ReorderedTransforms(self[index[s]], types.arraydata(numpy.argsort(s)))
             if len(index) == 0:
                 return EmptyTransforms(self.todims, self.fromdims)
             if len(index) == len(self):
                 return self
-            return MaskedTransforms(self, index)
+            return MaskedTransforms(self, types.arraydata(index))
         elif numeric.isboolarray(index):
             if index.shape != (len(self),):
                 raise IndexError('mask has invalid shape')
             if not numpy.any(index):
                 return EmptyTransforms(self.todims, self.fromdims)
             if numpy.all(index):
                 return self
             index, = numpy.where(index)
-            return MaskedTransforms(self, index)
+            return MaskedTransforms(self, types.arraydata(index))
         else:
             raise IndexError('invalid index')
 
     @abc.abstractmethod
     def index_with_tail(self, trans):
         '''Return the index of ``trans[:n]`` and the tail ``trans[n:]``.
 
@@ -129,15 +130,15 @@
 
         Example
         -------
 
         Consider the following plain sequence of two index transforms:
 
         >>> from nutils.transform import Index, SimplexChild
-        >>> transforms = PlainTransforms([(Index(1, 0),), (Index(1, 1),)], 1, 1)
+        >>> transforms = PlainTransforms(((Index(1, 0),), (Index(1, 1),)), 1, 1)
 
         Calling :meth:`index_with_tail` with the first transform gives index ``0``
         and no tail:
 
         >>> transforms.index_with_tail((Index(1, 0),))
         (0, ())
 
@@ -174,15 +175,15 @@
 
         Example
         -------
 
         Consider the following plain sequence of two index transforms:
 
         >>> from nutils.transform import Index, SimplexChild
-        >>> transforms = PlainTransforms([(Index(1, 0),), (Index(1, 1),)], 1, 1)
+        >>> transforms = PlainTransforms(((Index(1, 0),), (Index(1, 1),)), 1, 1)
 
         Calling :meth:`index` with the first transform gives index ``0``:
 
         >>> transforms.index((Index(1, 0),))
         0
 
         Calling with an additional scale raises an exception, because the transform
@@ -301,33 +302,14 @@
         ------
         :class:`Transforms`
             Unchained items.
         '''
 
         yield self
 
-    def get_evaluable(self, index: evaluable.Array) -> EvaluableTransformChain:
-        '''Return the evaluable transform chain at the given index.
-
-        Parameters
-        ----------
-        index : a scalar, integer :class:`nutils.evaluable.Array`
-            The index of the transform chain to return.
-
-        Returns
-        -------
-        :class:`nutils.transform.EvaluableTransformChain`
-            The evaluable transform chain at the given ``index``.
-        '''
-
-        return _EvaluableTransformChainFromSequence(self, index)
-
-
-stricttransforms = types.strict[Transforms]
-
 
 class EmptyTransforms(Transforms):
     '''An empty sequence.'''
 
     def __getitem__(self, index):
         if not numeric.isint(index):
             return super().__getitem__(index)
@@ -356,23 +338,23 @@
 
     Use this class only if there exists no specific implementation of
     :class:`Transforms` for the transforms at hand.
 
     Parameters
     ----------
     transforms : :class:`tuple` of :class:`~nutils.transform.TransformItem` objects
-        The sequence of transforms.
+        The sequence of transforms in canonical order.
     fromdims : :class:`int`
         The number of dimensions all ``transforms`` map from.
     '''
 
-    __slots__ = '_transforms', '_sorted', '_indices'
-
-    @types.apply_annotations
-    def __init__(self, transforms: types.tuple[transform.canonical], todims: types.strictint, fromdims: types.strictint):
+    def __init__(self, transforms: Tuple[Tuple[transform.TransformItem, ...], ...], todims: Integral, fromdims: Integral):
+        assert isinstance(transforms, tuple) and all(isinstance(items, tuple) and all(isinstance(item, transform.TransformItem) for item in items) and transform.iscanonical(items) for items in transforms), f'transforms={transforms!r}'
+        assert isinstance(todims, Integral), f'todims={todims!r}'
+        assert isinstance(fromdims, Integral), f'fromdims={fromdims!r}'
         transforms_todims = set(trans[0].todims for trans in transforms)
         transforms_fromdims = set(trans[-1].fromdims for trans in transforms)
         if not (transforms_todims <= {todims}):
             raise ValueError('expected transforms with todims={}, but got {}'.format(todims, transforms_todims))
         if not (transforms_fromdims <= {fromdims}):
             raise ValueError('expected transforms with fromdims={}, but got {}'.format(fromdims, transforms_fromdims))
         self._transforms = transforms
@@ -416,46 +398,44 @@
         Dimension of the transformation.
     length : :class:`int`
         Length of the sequence.
     offset : :class:`int`
         The index of the first :class:`nutils.transform.Index` in this sequence.
     '''
 
-    __slots__ = '_length', '_offset'
-
-    @types.apply_annotations
-    def __init__(self, ndims: types.strictint, length: int, offset: int = 0):
+    def __init__(self, ndims: Integral, length: Integral, offset: Integral = 0):
+        assert isinstance(ndims, Integral), f'ndims={ndims!r}'
+        assert isinstance(length, Integral), f'length={length!r}'
+        assert isinstance(offset, Integral), f'offset={offset!r}'
         self._length = length
         self._offset = offset
         super().__init__(ndims, ndims)
 
     def __getitem__(self, index):
         if not numeric.isint(index):
             return super().__getitem__(index)
         return transform.Index(self.fromdims, self._offset + numeric.normdim(self._length, index.__index__())),
 
-    def get_evaluable(self, index: evaluable.Array) -> EvaluableTransformChain:
-        return _EvaluableIndexChain(self.fromdims, self._offset + evaluable.InRange(index, self._length))
-
     def __len__(self):
         return self._length
 
     def index_with_tail(self, trans):
         root = trans[0]
         if root.fromdims == self.fromdims and isinstance(root, transform.Index) and 0 <= root.index - self._offset < self._length:
             return root.index - self._offset, trans[1:]
         raise ValueError
 
 
 class Axis(types.Singleton):
     '''Base class for axes of :class:`~nutils.topology.StructuredTopology`.'''
 
-    __slots__ = 'i', 'j', 'mod'
-
-    def __init__(self, i: types.strictint, j: types.strictint, mod: types.strictint):
+    def __init__(self, i: Integral, j: Integral, mod: Integral):
+        assert isinstance(i, Integral), f'i={i!r}'
+        assert isinstance(j, Integral), f'j={j!r}'
+        assert isinstance(mod, Integral), f'mod={mod!r}'
         assert i <= j
         self.i = i
         self.j = j
         self.mod = mod
 
     def __len__(self):
         return self.j - self.i
@@ -474,19 +454,18 @@
         if self.mod:
             index %= self.mod
         return index
 
 
 class DimAxis(Axis):
 
-    __slots__ = 'isperiodic'
     isdim = True
 
-    @types.apply_annotations
-    def __init__(self, i: types.strictint, j: types.strictint, mod: types.strictint, isperiodic: bool):
+    def __init__(self, i: Integral, j: Integral, mod: Integral, isperiodic: bool):
+        assert isinstance(isperiodic, bool), f'isperiodic={isperiodic!r}'
         super().__init__(i, j, mod)
         self.isperiodic = isperiodic
 
     @property
     def refined(self):
         return DimAxis(self.i*2, self.j*2, self.mod*2, self.isperiodic)
 
@@ -510,19 +489,19 @@
 
     def intaxis(self, ibound, side):
         return IntAxis(self.i-side+1-self.isperiodic, self.j-side, self.mod, ibound, side)
 
 
 class IntAxis(Axis):
 
-    __slots__ = 'ibound', 'side'
     isdim = False
 
-    @types.apply_annotations
-    def __init__(self, i: types.strictint, j: types.strictint, mod: types.strictint, ibound: types.strictint, side: bool):
+    def __init__(self, i: Integral, j: Integral, mod: Integral, ibound: Integral, side: bool):
+        assert isinstance(ibound, Integral), f'ibound={ibound!r}'
+        assert isinstance(side, Integral), f'side={side!r}'
         super().__init__(i, j, mod)
         self.ibound = ibound
         self.side = side
 
     @property
     def refined(self):
         return IntAxis(self.i*2+self.side, self.j*2+self.side-1, self.mod*2, self.ibound, self.side)
@@ -543,18 +522,19 @@
         Root transform of the :class:`~nutils.topology.StructuredTopology`.
     axes : :class:`tuple` of :class:`Axis` objects
         The axes defining the :class:`~nutils.topology.StructuredTopology`.
     nrefine : :class:`int`
         Number of structured refinements.
     '''
 
-    __slots__ = '_root', '_axes', '_nrefine', '_etransforms', '_ctransforms', '_cindices'
+    def __init__(self, root: transform.TransformItem, axes: Tuple[Axis, ...], nrefine: Integral):
+        assert isinstance(root, transform.TransformItem), f'root={root!r}'
+        assert isinstance(axes, tuple) and all(isinstance(axis, Axis) for axis in axes), f'axes={axes!r}'
+        assert isinstance(nrefine, Integral), f'nrefine={nrefine!r}'
 
-    @types.apply_annotations
-    def __init__(self, root: transform.stricttransformitem, axes: types.tuple[types.strict[Axis]], nrefine: types.strictint):
         self._root = root
         self._axes = axes
         self._nrefine = nrefine
 
         ref = element.LineReference()**len(self._axes)
         self._ctransforms = numeric.asobjvector(ref.child_transforms).reshape((2,)*len(self._axes))
         self._cindices = {t: numpy.array(i, dtype=int) for i, t in numpy.ndenumerate(self._ctransforms)}
@@ -620,34 +600,29 @@
         tail = transform.promote(tail[self._nrefine:], self.fromdims)
         if tail[:len(self._etransforms)] != self._etransforms:
             raise ValueError
         tail = tail[len(self._etransforms):]
 
         return flatindex, tail
 
-    def get_evaluable(self, index: evaluable.Array) -> EvaluableTransformChain:
-        return _EvaluableTransformChainFromStructured(self, index)
-
 
 class MaskedTransforms(Transforms):
     '''An order preserving subset of another :class:`Transforms` object.
 
     Parameters
     ----------
     parent : :class:`Transforms`
         The transforms to subset.
     indices : one-dimensional array of :class:`int`\\s
         The strict monotonic increasing indices of ``parent`` transforms to keep.
     '''
 
-    __slots__ = '_parent', '_mask', '_indices'
-
-    @types.apply_annotations
-    def __init__(self, parent: stricttransforms, indices: types.arraydata):
-        assert indices.dtype == int
+    def __init__(self, parent: Transforms, indices: types.arraydata):
+        assert isinstance(parent, Transforms), f'parent={parent!r}'
+        assert isinstance(indices, types.arraydata) and indices.dtype == int, f'indices={indices!r}'
         self._parent = parent
         self._indices = numpy.asarray(indices)
         super().__init__(parent.todims, parent.fromdims)
 
     def __iter__(self):
         for itrans in self._indices:
             yield self._parent[int(itrans)]
@@ -676,25 +651,22 @@
     ----------
     parent : :class:`Transforms`
         The transforms to reorder.
     indices : one-dimensional array of :class:`int`\\s
         The new order of the transforms.
     '''
 
-    __slots__ = '_parent', '_mask', '_indices'
-    __cache__ = '_rindices'
-
-    @types.apply_annotations
-    def __init__(self, parent: stricttransforms, indices: types.arraydata):
-        assert indices.dtype == int
+    def __init__(self, parent: Transforms, indices: types.arraydata):
+        assert isinstance(parent, Transforms), f'parent={parent!r}'
+        assert isinstance(indices, types.arraydata) and indices.dtype == int, f'indices={indices!r}'
         self._parent = parent
         self._indices = numpy.asarray(indices)
         super().__init__(parent.todims, parent.fromdims)
 
-    @property
+    @cached_property
     def _rindices(self):
         return types.frozenarray(numpy.argsort(self._indices), copy=False)
 
     def __iter__(self):
         for itrans in self._indices:
             yield self._parent[int(itrans)]
 
@@ -728,29 +700,29 @@
     derived_attribute : :class:`str`
         The name of the attribute of a :class:`nutils.element.Reference` that
         contains the derived references.
     fromdims : :class:`int`
         The number of dimensions all transforms in this sequence map from.
     '''
 
-    __slots__ = '_parent', '_parent_references', '_derived_transforms'
-    __cache__ = '_offsets'
-
-    @types.apply_annotations
-    def __init__(self, parent: stricttransforms, parent_references: types.strict[References], derived_attribute: types.strictstr, fromdims: types.strictint):
+    def __init__(self, parent: Transforms, parent_references: References, derived_attribute: str, fromdims: Integral):
+        assert isinstance(parent, Transforms), f'parent={parent!r}'
+        assert isinstance(parent_references, References), f'parent_references={parent_references!r}'
+        assert isinstance(derived_attribute, str), f'derived_attribute={derived_attribute!r}'
+        assert isinstance(fromdims, Integral), f'fromdims={fromdims!r}'
         if len(parent) != len(parent_references):
             raise ValueError('`parent` and `parent_references` should have the same length')
         if parent.fromdims != parent_references.ndims:
             raise ValueError('`parent` and `parent_references` have different dimensions')
         self._parent = parent
         self._parent_references = parent_references
         self._derived_transforms = operator.attrgetter(derived_attribute)
         super().__init__(parent.todims, fromdims)
 
-    @property
+    @cached_property
     def _offsets(self):
         return types.frozenarray(numpy.cumsum([0, *(len(self._derived_transforms(ref)) for ref in self._parent_references)]), copy=False)
 
     def __len__(self):
         return self._offsets[-1]
 
     def __iter__(self):
@@ -796,18 +768,19 @@
     derived_attribute : :class:`str`
         The name of the attribute of a :class:`nutils.element.Reference` that
         contains the derived references.
     fromdims : :class:`int`
         The number of dimensions all transforms in this sequence map from.
     '''
 
-    __slots__ = '_parent', '_derived_transforms'
-
-    @types.apply_annotations
-    def __init__(self, parent: stricttransforms, parent_reference: element.strictreference, derived_attribute: types.strictstr, fromdims: types.strictint):
+    def __init__(self, parent: Transforms, parent_reference: element.Reference, derived_attribute: str, fromdims: Integral):
+        assert isinstance(parent, Transforms), f'parent={parent!r}'
+        assert isinstance(parent_reference, element.Reference), f'parent_reference={parent_reference!r}'
+        assert isinstance(derived_attribute, str), f'derived_attribute={derived_attribute!r}'
+        assert isinstance(fromdims, Integral), f'fromdims={fromdims!r}'
         if parent.fromdims != parent_reference.ndims:
             raise ValueError('`parent` and `parent_reference` have different dimensions')
         self._parent = parent
         self._derived_transforms = getattr(parent_reference, derived_attribute)
         super().__init__(parent.todims, fromdims)
 
     def __len__(self):
@@ -841,29 +814,26 @@
 
     Parameters
     ----------
     items: :class:`tuple` of :class:`Transforms` objects
         The :class:`Transforms` objects to chain.
     '''
 
-    __slots__ = '_items'
-    __cache__ = '_offsets'
-
-    @types.apply_annotations
-    def __init__(self, items: types.tuple[stricttransforms]):
+    def __init__(self, items: Tuple[Transforms, ...]):
+        assert isinstance(items, tuple) and all(isinstance(item, Transforms) for item in items), f'items={items!r}'
         if len(items) == 0:
             raise ValueError('Empty chain.')
         if len(set(item.todims for item in items)) != 1:
             raise ValueError('Cannot chain Transforms with different todims.')
         if len(set(item.fromdims for item in items)) != 1:
             raise ValueError('Cannot chain Transforms with different fromdims.')
         self._items = items
         super().__init__(self._items[0].todims, self._items[0].fromdims)
 
-    @property
+    @cached_property
     def _offsets(self):
         return types.frozenarray(numpy.cumsum([0, *map(len, self._items)]), copy=False)
 
     def __len__(self):
         return self._offsets[-1]
 
     def __getitem__(self, index):
@@ -942,113 +912,8 @@
         return EmptyTransforms(todims, fromdims)
     elif len(unchained) == 1:
         return unchained[0]
     else:
         return ChainedTransforms(unchained)
 
 
-class _EvaluableTransformChainFromSequence(EvaluableTransformChain):
-
-    __slots__ = '_sequence', '_index'
-
-    def __init__(self, sequence: Transforms, index: evaluable.Array) -> None:
-        self._sequence = sequence
-        self._index = index
-        super().__init__((index,), sequence.todims, sequence.fromdims)
-
-    def evalf(self, index: numpy.ndarray) -> TransformChain:
-        return self._sequence[index.__index__()]
-
-    def index_with_tail_in(self, __sequence) -> Tuple[evaluable.Array, EvaluableTransformChain]:
-        if __sequence == self._sequence:
-            tails = EvaluableTransformChain.empty(self._sequence.todims)
-            return self._index, tails
-        else:
-            return super().index_with_tail_in(__sequence)
-
-
-class _EvaluableIndexChain(EvaluableTransformChain):
-
-    __slots__ = '_ndim'
-
-    def __init__(self, ndim: int, index: evaluable.Array) -> None:
-        self._ndim = ndim
-        super().__init__((index,), ndim, ndim)
-
-    def evalf(self, index: numpy.ndarray) -> TransformChain:
-        return transform.Index(self._ndim, index.__index__()),
-
-    def apply(self, points: evaluable.Array) -> evaluable.Array:
-        return points
-
-    @property
-    def linear(self) -> evaluable.Array:
-        return evaluable.diagonalize(evaluable.ones((self.todims,)))
-
-
-class _EvaluableTransformChainFromStructured(EvaluableTransformChain):
-
-    __slots__ = '_sequence', '_index'
-
-    def __init__(self, sequence: StructuredTransforms, index: evaluable.Array) -> None:
-        self._sequence = sequence
-        self._index = index
-        super().__init__((index,), sequence.todims, sequence.fromdims)
-
-    def evalf(self, index: numpy.ndarray) -> TransformChain:
-        return self._sequence[index.__index__()]
-
-    def apply(self, points: evaluable.Array) -> evaluable.Array:
-        if len(self._sequence._axes) != 1:
-            return super().apply(points)
-        desired = super().apply(points)
-        axis = self._sequence._axes[0]
-        # axis.map
-        index = self._index + axis.i
-        if axis.mod:
-            index %= axis.mod
-        # edge
-        if axis.isdim:
-            assert evaluable.equalindex(points.shape[-1], 1)
-        else:
-            assert evaluable.equalindex(points.shape[-1], 0)
-            points = evaluable.appendaxes(float(axis.side), (*points.shape[:-1], 1))
-        # children
-        for i in range(self._sequence._nrefine):
-            index, ichild = evaluable.divmod(index, 2)
-            points = .5 * (points + evaluable.appendaxes(ichild, points.shape))
-        # shift
-        return points + evaluable.appendaxes(index, points.shape)
-
-    @property
-    def linear(self) -> evaluable.Array:
-        if not len(self._sequence):
-            return super().linear
-        chain = self._sequence[0]
-        linear = numpy.eye(self.fromdims)
-        for item in reversed(chain):
-            linear = item.linear @ linear
-        assert linear.shape == (self.todims, self.fromdims)
-        return evaluable.asarray(linear)
-
-    @property
-    def basis(self) -> evaluable.Array:
-        if not len(self._sequence) or self.fromdims == self.todims:
-            return super().basis
-        chain = self._sequence[0]
-        basis = numpy.eye(self.fromdims)
-        for item in reversed(chain):
-            basis = item.linear @ basis
-            assert item.fromdims <= item.todims <= item.fromdims + 1
-            if item.todims == item.fromdims + 1:
-                basis = numpy.concatenate([basis, item.ext[:, None]], axis=1)
-        assert basis.shape == (self.todims, self.todims)
-        return evaluable.asarray(basis)
-
-    def index_with_tail_in(self, __sequence) -> Tuple[evaluable.Array, EvaluableTransformChain]:
-        if __sequence == self._sequence:
-            tails = EvaluableTransformChain.empty(self._sequence.todims)
-            return self._index, tails
-        else:
-            return super().index_with_tail_in(__sequence)
-
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/unit.py` & `nutils-8.0/nutils/unit.py`

 * *Files 1% similar despite different names*

```diff
@@ -186,8 +186,8 @@
     pos = len(a) + int(e or 0)
     s = (a + b).rstrip('0')
     return s.ljust(pos, '0') if pos >= len(s) \
         else '0.' + '0' * -pos + s if pos <= 0 \
         else s[:pos] + '.' + s[pos:]
 
 
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/nutils/warnings.py` & `nutils-8.0/nutils/warnings.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-import warnings
+import warnings, contextlib
 
 
 class NutilsWarning(Warning):
     'Base class for warnings from Nutils.'
 
 
 class NutilsDeprecationWarning(NutilsWarning):
@@ -17,24 +17,18 @@
     warnings.warn(message, category, stacklevel=stacklevel)
 
 
 def deprecation(message):
     warnings.warn(message, NutilsDeprecationWarning, stacklevel=2)
 
 
-class via:
+@contextlib.contextmanager
+def via(print):
     '''context manager to set/reset warnings.showwarning'''
 
-    def __init__(self, print):
-        self.print = print
+    oldshowwarning = warnings.showwarning
+    warnings.showwarning = lambda message, category, filename, lineno, *args: print(f'{category.__name__}: {message}\n  In {filename}:{lineno}')
+    yield
+    warnings.showwarning = oldshowwarning
 
-    def __enter__(self):
-        self.oldshowwarning = warnings.showwarning
-        warnings.showwarning = self.showwarning
 
-    def __exit__(self, *args):
-        warnings.showwarning = self.oldshowwarning
-
-    def showwarning(self, message, category, filename, lineno, *args):
-        self.print('{}: {}\n  In {}:{}'.format(category.__name__, message, filename, lineno))
-
-# vim:sw=2:sts=2:et
+# vim:sw=4:sts=4:et
```

### Comparing `nutils-7.3/pyproject.toml` & `nutils-8.0/pyproject.toml`

 * *Files 16% similar despite different names*

```diff
@@ -2,29 +2,32 @@
 name = "nutils"
 readme = "README.md"
 authors = [
     { name = "Evalf", email = "info@evalf.com" },
 ]
 requires-python = '~=3.7'
 dependencies = [
+    "appdirs~=1.0",
+    "bottombar~=2.0.2",
     "numpy>=1.17",
-    "treelog>=1.0b5,<2",
-    "stringly>=1.0b2,<2",
-    "bottombar==1.0",
+    "nutils-poly~=1.0",
+    "psutil~=5.0",
+    "stringly",
+    "treelog>=1.0b5",
 ]
 dynamic = ["description", "version"]
 classifiers = [
     "License :: OSI Approved :: MIT License",
     "Topic :: Scientific/Engineering :: Mathematics",
     "Topic :: Scientific/Engineering :: Physics",
 ]
 
 [project.optional-dependencies]
 docs = ["Sphinx>=1.8"]
-matrix_scipy = ["scipy>=0.13"]
-matrix_mkl = ["mkl"]
 export_mpl = ["matplotlib>=1.3", "pillow>2.6"]
+matrix_mkl = ["mkl"]
+matrix_scipy = ["scipy>=0.13"]
 import_gmsh = ["meshio"]
 
 [build-system]
 requires = ["flit_core >=3.2,<4"]
 build-backend = "flit_core.buildapi"
```

### Comparing `nutils-7.3/tests/test_basis.py` & `nutils-8.0/tests/test_basis.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,12 @@
-from nutils import function, mesh, sparse, transform, transformseq, topology, element
+from nutils import function, mesh, sparse, transformseq, topology, element, numeric
+from nutils.testing import TestCase, parametrize
 import random
 import itertools
-import functools
-from nutils.testing import *
+import numpy
 
 
 class basisTest(TestCase):
 
     def assertContinuous(self, topo, geom, basis, continuity):
         for regularity in range(continuity+1):
             smpl = topo.sample('gauss', 2)
```

### Comparing `nutils-7.3/tests/test_cache.py` & `nutils-8.0/tests/test_cache.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,9 @@
-from nutils import *
-from nutils.testing import *
-import sys
+from nutils import cache
+from nutils.testing import TestCase, unittest
 import contextlib
 import tempfile
 import pathlib
 import threading
 
 
 @contextlib.contextmanager
```

### Comparing `nutils-7.3/tests/test_docs.py` & `nutils-8.0/tests/test_docs.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_element.py` & `nutils-8.0/tests/test_element.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-from nutils import *
-from nutils.testing import *
-import itertools
+from nutils import element, _util as util, types
+from nutils.testing import TestCase, parametrize
+import numpy, math
 
 
 @parametrize
 class elem(TestCase):
 
     def test_ndims(self):
         self.assertEqual(self.ref.ndims, len(self.exactcentroid))
@@ -40,18 +40,14 @@
                 swapped_up = etrans.swapup(ctrans)
                 self.assertNotEqual(swapped_up, None)
                 ctrans_, etrans_ = swapped_up
                 self.assertEqual(etrans * ctrans, ctrans_ * etrans_)
                 swapped_down = etrans_.swapdown(ctrans_)
                 self.assertEqual(swapped_down, (etrans, ctrans))
 
-    @parametrize.enable_if(lambda ref, **kwargs: ref.ndims >= 2)
-    def test_ribbons(self):
-        self.ref.ribbons
-
     @parametrize.enable_if(lambda ref, **kwargs: not isinstance(ref, element.MosaicReference) and ref.ndims >= 1)
     def test_connectivity(self):
         for ichild, edges in enumerate(self.ref.connectivity):
             for iedge, ioppchild in enumerate(edges):
                 if ioppchild != -1:
                     self.assertIn(ichild, self.ref.connectivity[ioppchild])
                     ioppedge = util.index(self.ref.connectivity[ioppchild], ichild)
@@ -68,22 +64,45 @@
                     self.ref.child_transforms[jchild] * self.ref.child_refs[jchild].edge_transforms[jedge])
 
     def test_inside(self):
         self.assertTrue(self.ref.inside(self.exactcentroid))
         if self.ref.ndims:
             self.assertFalse(self.ref.inside(-numpy.ones(self.ref.ndims)))
 
+    @parametrize.enable_if(lambda ref, **kwargs: not isinstance(ref, element.WithChildrenReference) and ref.ndims >= 1)
+    def test_edge_vertices(self):
+        for etrans, eref, everts in zip(self.ref.edge_transforms, self.ref.edge_refs, self.ref.edge_vertices):
+            self.assertAllEqual(self.ref.vertices[everts], etrans.apply(eref.vertices))
+
+    @parametrize.enable_if(lambda ref, **kwargs: not isinstance(ref, element.WithChildrenReference) and ref.ndims >= 1)
+    def test_simplices(self):
+        volume = 0
+        centroid = 0
+        for simplex in self.ref.vertices[self.ref.simplices]:
+            simplex_volume = numpy.linalg.det(simplex[1:] - simplex[0]) / math.factorial(self.ref.ndims)
+            self.assertGreater(simplex_volume, 0)
+            volume += simplex_volume
+            centroid += simplex.mean(axis=0) * simplex_volume
+        centroid /= volume
+        self.assertAlmostEqual(volume, self.ref.volume)
+        self.assertAllAlmostEqual(centroid, self.exactcentroid)
+
+    @parametrize.enable_if(lambda ref, **kwargs: not isinstance(ref, element.WithChildrenReference) and ref.ndims >= 1)
+    def test_simplex_transforms(self):
+        for simplex, strans in zip(self.ref.vertices[self.ref.simplices], self.ref.simplex_transforms):
+            self.assertAllEqual(strans.linear, (simplex[1:] - simplex[0]).T)
+            self.assertAllEqual(strans.offset, simplex[0])
 
 elem('point', ref=element.PointReference(), exactcentroid=numpy.zeros((0,)))
 elem('point2', ref=element.PointReference()**2, exactcentroid=numpy.zeros((0,)))
 elem('line', ref=element.LineReference(), exactcentroid=numpy.array([.5]))
 elem('triangle', ref=element.TriangleReference(), exactcentroid=numpy.array([1/3]*2))
 elem('tetrahedron', ref=element.TetrahedronReference(), exactcentroid=numpy.array([1/4]*3))
 elem('square', ref=element.LineReference()**2, exactcentroid=numpy.array([.5]*2))
 elem('hexagon', ref=element.LineReference()**3, exactcentroid=numpy.array([.5]*3))
 elem('prism1', ref=element.TriangleReference()*element.LineReference(), exactcentroid=numpy.array([1/3, 1/3, 1/2]))
 elem('prism2', ref=element.LineReference()*element.TriangleReference(), exactcentroid=numpy.array([1/2, 1/3, 1/3]))
 line = element.LineReference()
 quad = line**2
-elem('withchildren1', ref=element.WithChildrenReference(quad, [quad, quad.empty, quad.empty, quad.empty]), exactcentroid=numpy.array([1/4, 1/4]))
-elem('withchildren2', ref=element.WithChildrenReference(quad, [quad, quad, quad.empty, quad.empty]), exactcentroid=numpy.array([1/4, 1/2]))
-elem('mosaic', ref=element.MosaicReference(quad, [line, line.empty, line, line.empty], [.25, .75]), exactcentroid=numpy.array([2/3, 2/3]))
+elem('withchildren1', ref=element.WithChildrenReference(quad, (quad, quad.empty, quad.empty, quad.empty)), exactcentroid=numpy.array([1/4, 1/4]))
+elem('withchildren2', ref=element.WithChildrenReference(quad, (quad, quad, quad.empty, quad.empty)), exactcentroid=numpy.array([1/4, 1/2]))
+elem('mosaic', ref=element.MosaicReference(quad, (line, line.empty, line, line.empty), types.arraydata([.25, .75])), exactcentroid=numpy.array([2/3, 2/3]))
```

### Comparing `nutils-7.3/tests/test_elementseq.py` & `nutils-8.0/tests/test_elementseq.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_evaluable.py` & `nutils-8.0/tests/test_evaluable.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,29 +1,31 @@
+from nutils import evaluable, sparse, numeric, _util as util, types, sample
+from nutils.testing import TestCase, parametrize
+import nutils_poly as poly
 import numpy
 import itertools
-import pickle
 import weakref
 import gc
 import warnings as _builtin_warnings
 import collections
 import sys
 import unittest
-from nutils import *
-from nutils.testing import *
-_ = numpy.newaxis
+import functools
+import operator
+import logging
 
 
 @parametrize
 class check(TestCase):
 
     def setUp(self):
         super().setUp()
         numpy.random.seed(0)
         self.arg_names = tuple(map('arg{}'.format, range(len(self.arg_values))))
-        self.args = tuple(evaluable.Argument(name, value.shape, value.dtype) for name, value in zip(self.arg_names, self.arg_values))
+        self.args = tuple(evaluable.Argument(name, tuple(evaluable.constant(n) for n in value.shape), evaluable.asdtype(value.dtype)) for name, value in zip(self.arg_names, self.arg_values))
         self.actual = self.op(*self.args)
         self.desired = self.n_op(*self.arg_values)
         assert numpy.isfinite(self.desired).all(), 'something is wrong with the design of this unit test'
         self.other = numpy.random.normal(size=self.desired.shape)
         self.pairs = [(i, j) for i in range(self.actual.ndim-1) for j in range(i+1, self.actual.ndim) if self.actual.shape[i] == self.actual.shape[j]]
         _builtin_warnings.simplefilter('ignore', evaluable.ExpensiveEvaluationWarning)
 
@@ -58,39 +60,39 @@
         with self.subTest('vanilla'):
             self.assertArrayAlmostEqual(actual.eval(**evalargs), desired, decimal)
         with self.subTest('simplified'):
             self.assertArrayAlmostEqual(actual.simplified.eval(**evalargs), desired, decimal)
         with self.subTest('optimized'):
             self.assertArrayAlmostEqual(actual.optimized_for_numpy.eval(**evalargs), desired, decimal)
         with self.subTest('sparse'):
-            indices, values, shape = sparse.extract(actual.assparse.eval(**evalargs))
+            indices, values, shape = sparse.extract(evaluable.eval_sparse(actual, **evalargs))
             self.assertEqual(tuple(map(int, shape)), desired.shape)
             if not indices:
                 dense = values.sum()
             else:
                 dense = numpy.zeros(desired.shape, values.dtype)
                 numpy.add.at(dense, indices, values)
             self.assertArrayAlmostEqual(dense, desired, decimal)
 
     def test_str(self):
-        a = evaluable.Array((), shape=(2, 3), dtype=float)
+        a = evaluable.Array((), shape=(evaluable.constant(2), evaluable.constant(3)), dtype=float)
         self.assertEqual(str(a), 'nutils.evaluable.Array<f:2,3>')
 
     def test_evalconst(self):
         self.assertFunctionAlmostEqual(decimal=14,
                                        desired=self.n_op(*self.arg_values),
-                                       actual=self.op(*self.arg_values))
+                                       actual=self.op(*map(evaluable.constant, self.arg_values)))
 
     def test_evalzero(self):
         for iarg, arg_value in enumerate(self.arg_values):
             if 0 in arg_value.flat:
                 args = (*self.arg_values[:iarg], numpy.zeros_like(arg_value), *self.arg_values[iarg+1:])
                 self.assertFunctionAlmostEqual(decimal=14,
                                                desired=self.n_op(*args),
-                                               actual=self.op(*args))
+                                               actual=self.op(*[evaluable.zeros_like(arg) if i == iarg else arg for i, arg in enumerate(map(evaluable.constant, args))]))
 
     def test_eval(self):
         self.assertFunctionAlmostEqual(decimal=14,
                                        actual=self.actual,
                                        desired=self.desired)
 
     @unittest.skipIf(sys.version_info < (3, 7), 'time.perf_counter_ns is not available')
@@ -117,26 +119,27 @@
                                        actual=evaluable.transpose(self.actual, trans))
 
     def test_insertaxis(self):
         for axis in range(self.actual.ndim+1):
             with self.subTest(axis=axis):
                 self.assertFunctionAlmostEqual(decimal=14,
                                                desired=numpy.repeat(numpy.expand_dims(self.desired, axis), 2, axis),
-                                               actual=evaluable.insertaxis(self.actual, axis, 2))
+                                               actual=evaluable.insertaxis(self.actual, axis, evaluable.constant(2)))
 
     def test_takediag(self):
         for ax1, ax2 in self.pairs:
             self.assertFunctionAlmostEqual(decimal=14,
                                            desired=numeric.takediag(self.desired, ax1, ax2),
                                            actual=evaluable.takediag(self.actual, ax1, ax2))
 
     def test_eig(self):
         if self.actual.dtype == float:
             for ax1, ax2 in self.pairs:
-                A, L, V = evaluable.Tuple((self.actual, *evaluable.eig(self.actual, axes=(ax1, ax2)))).eval(**dict(zip(self.arg_names, self.arg_values)))
+                items = self.actual, *evaluable.eig(self.actual, axes=(ax1, ax2))
+                A, L, V = evaluable.Tuple(items).simplified.eval(**dict(zip(self.arg_names, self.arg_values)))
                 self.assertArrayAlmostEqual(decimal=11,
                                             actual=(numpy.expand_dims(V, ax2) * numpy.expand_dims(L, ax2+1).swapaxes(ax1, ax2+1)).sum(ax2+1),
                                             desired=(numpy.expand_dims(A, ax2) * numpy.expand_dims(V, ax2+1).swapaxes(ax1, ax2+1)).sum(ax2+1))
 
     def test_inv(self):
         for ax1, ax2 in self.pairs:
             trans = [i for i in range(self.desired.ndim) if i not in (ax1, ax2)] + [ax1, ax2]
@@ -153,23 +156,23 @@
 
     def test_take(self):
         indices = [0, -1]
         for iax, sh in enumerate(self.desired.shape):
             if sh >= 2:
                 self.assertFunctionAlmostEqual(decimal=14,
                                                desired=numpy.take(self.desired, indices, axis=iax),
-                                               actual=evaluable.take(self.actual, indices, axis=iax))
+                                               actual=evaluable.take(self.actual, evaluable.constant(indices), axis=iax))
 
     def test_take_block(self):
         for iax, sh in enumerate(self.desired.shape):
             if sh >= 2:
                 indices = [[0, sh-1], [sh-1, 0]]
                 self.assertFunctionAlmostEqual(decimal=14,
                                                desired=numpy.take(self.desired, indices, axis=iax),
-                                               actual=evaluable._take(self.actual, indices, axis=iax))
+                                               actual=evaluable._take(self.actual, evaluable.constant(indices), axis=iax))
 
     def test_take_nomask(self):
         for iax, sh in enumerate(self.desired.shape):
             if sh >= 2:
                 indices = [0, sh-1]
                 self.assertFunctionAlmostEqual(decimal=14,
                                                desired=numpy.take(self.desired, indices, axis=iax),
@@ -177,41 +180,41 @@
 
     def test_take_reversed(self):
         indices = [-1, 0]
         for iax, sh in enumerate(self.desired.shape):
             if sh >= 2:
                 self.assertFunctionAlmostEqual(decimal=14,
                                                desired=numpy.take(self.desired, indices, axis=iax),
-                                               actual=evaluable.take(self.actual, indices, axis=iax))
+                                               actual=evaluable.take(self.actual, evaluable.constant(indices), axis=iax))
 
     def test_take_duplicate_indices(self):
         for iax, sh in enumerate(self.desired.shape):
             if sh >= 2:
                 indices = [0, sh-1, 0, 0]
                 self.assertFunctionAlmostEqual(decimal=14,
                                                desired=numpy.take(self.desired, indices, axis=iax),
                                                actual=evaluable.take(self.actual, evaluable.Guard(evaluable.asarray(indices)), axis=iax))
 
     def test_inflate(self):
         for iax, sh in enumerate(self.desired.shape):
-            dofmap = evaluable.Constant(numpy.arange(int(sh)) * 2)
+            dofmap = evaluable.constant(numpy.arange(int(sh)) * 2)
             desired = numpy.zeros(self.desired.shape[:iax] + (int(sh)*2-1,) + self.desired.shape[iax+1:], dtype=self.desired.dtype)
             desired[(slice(None),)*iax+(slice(None, None, 2),)] = self.desired
             self.assertFunctionAlmostEqual(decimal=14,
                                            desired=desired,
-                                           actual=evaluable._inflate(self.actual, dofmap=dofmap, length=sh*2-1, axis=iax))
+                                           actual=evaluable._inflate(self.actual, dofmap=dofmap, length=evaluable.constant(sh*2-1), axis=iax))
 
     def test_inflate_duplicate_indices(self):
         for iax, sh in enumerate(self.desired.shape):
             dofmap = numpy.arange(sh) % 2
             desired = numpy.zeros(self.desired.shape[:iax] + (2,) + self.desired.shape[iax+1:], dtype=self.desired.dtype)
             numpy.add.at(desired, (slice(None),)*iax+(dofmap,), self.desired)
             self.assertFunctionAlmostEqual(decimal=14,
                                            desired=desired,
-                                           actual=evaluable._inflate(self.actual, dofmap=dofmap, length=2, axis=iax))
+                                           actual=evaluable._inflate(self.actual, dofmap=evaluable.constant(dofmap), length=evaluable.constant(2), axis=iax))
 
     def test_diagonalize(self):
         for axis in range(self.actual.ndim):
             for newaxis in range(axis+1, self.actual.ndim+1):
                 self.assertFunctionAlmostEqual(decimal=14,
                                                desired=numeric.diagonalize(self.desired, axis, newaxis),
                                                actual=evaluable.diagonalize(self.actual, axis, newaxis))
@@ -314,15 +317,15 @@
 
     def test_unravel(self):
         for idim in range(self.actual.ndim):
             length = self.desired.shape[idim]
             unravelshape = (length//3, 3) if (length % 3 == 0) else (length//2, 2) if (length % 2 == 0) else (length, 1)
             self.assertFunctionAlmostEqual(decimal=14,
                                            desired=self.desired.reshape(self.desired.shape[:idim]+unravelshape+self.desired.shape[idim+1:]),
-                                           actual=evaluable.unravel(self.actual, axis=idim, shape=unravelshape))
+                                           actual=evaluable.unravel(self.actual, axis=idim, shape=tuple(map(evaluable.constant, unravelshape))))
 
     def test_loopsum(self):
         if self.desired.dtype == bool:
             return
         length = 3
         index = evaluable.loop_index('_testindex', length)
         for iarg, arg_value in enumerate(self.arg_values):
@@ -438,24 +441,28 @@
 _check('complex', lambda f: evaluable.astype(f, complex), lambda a: a.astype(complex), ANY(2, 4, 2))
 _check('real', lambda f: evaluable.real(f), lambda a: a.real, ANY(2, 4, 2))
 _check('real-complex', lambda f: evaluable.real(f), lambda a: a.real, ANC(2, 4, 2), hasgrad=False)
 _check('imag', lambda f: evaluable.imag(f), lambda a: a.imag, ANY(2, 4, 2))
 _check('imag-complex', lambda f: evaluable.imag(f), lambda a: a.imag, ANC(2, 4, 2), hasgrad=False)
 _check('conjugate', lambda f: evaluable.conjugate(f), lambda a: a.conjugate(), ANY(2, 4, 2))
 _check('conjugate-complex', lambda f: evaluable.conjugate(f), lambda a: a.conjugate(), ANC(2, 4, 2), hasgrad=False)
-_check('const', lambda f: evaluable.asarray(numpy.arange(16, dtype=float).reshape(2, 4, 2)), lambda a: numpy.arange(16, dtype=float).reshape(2, 4, 2), ANY(2, 4, 2))
-_check('zeros', lambda f: evaluable.zeros([1, 4, 3, 4]), lambda a: numpy.zeros([1, 4, 3, 4]), ANY(4, 3, 4))
-_check('ones', lambda f: evaluable.ones([1, 4, 3, 4]), lambda a: numpy.ones([1, 4, 3, 4]), ANY(4, 3, 4))
-_check('range', lambda f: evaluable.Range(4) + 2, lambda a: numpy.arange(2, 6), ANY(4))
+_check('const', lambda: evaluable.constant(ANY(2, 4, 2)), lambda: ANY(2, 4, 2))
+_check('zeros', lambda: evaluable.zeros(tuple(map(evaluable.constant, [1, 4, 3, 4]))), lambda: numpy.zeros([1, 4, 3, 4]))
+_check('zeros-bool', lambda: evaluable.zeros(tuple(map(evaluable.constant, [1, 4, 3, 4])), dtype=bool), lambda: numpy.zeros([1, 4, 3, 4], dtype=bool))
+_check('ones', lambda: evaluable.ones(tuple(map(evaluable.constant, [1, 4, 3, 4]))), lambda: numpy.ones([1, 4, 3, 4]))
+_check('ones-bool', lambda: evaluable.ones(tuple(map(evaluable.constant, [1, 4, 3, 4])), dtype=bool), lambda: numpy.ones([1, 4, 3, 4], dtype=bool))
+_check('range', lambda: evaluable.Range(evaluable.constant(4)) + 2, lambda: numpy.arange(2, 6))
 _check('sin', evaluable.sin, numpy.sin, ANY(4, 4))
 _check('sin-complex', evaluable.sin, numpy.sin, ANC(4, 4))
 _check('cos', evaluable.cos, numpy.cos, ANY(4, 4))
 _check('cos-complex', evaluable.cos, numpy.cos, ANC(4, 4))
 _check('tan', evaluable.tan, numpy.tan, ANY(4, 4))
 _check('tan-complex', evaluable.tan, numpy.tan, ANC(4, 4))
+_check('sinc', evaluable.sinc, lambda a: numpy.sinc(a/numpy.pi), ANY(4, 4))
+_check('sinc-complex', evaluable.sinc, lambda a: numpy.sinc(a/numpy.pi), ANC(4, 4))
 _check('sqrt', evaluable.sqrt, lambda a: numpy.power(a, .5), NN(4, 4)) # NOTE: not comparing against numpy.sqrt because of AVX-512 related accuracy issues, see #770
 _check('sqrt-complex', evaluable.sqrt, numpy.sqrt, ANC(4, 4))
 _check('log', evaluable.ln, numpy.log, POS(2, 2))
 _check('log-complex', evaluable.ln, numpy.log, NZC(2, 2))
 _check('log2', evaluable.log2, numpy.log2, POS(2, 2))
 _check('log2-complex', evaluable.log2, lambda a: numpy.log(a) * numpy.power(numpy.log(2), -1), NZC(2, 2)) # NOTE: not comparing against numpy.log2 because of AVX-512 related accuracy issues, see #770
 _check('log10', evaluable.log10, numpy.log10, POS(2, 2))
@@ -490,16 +497,16 @@
 _check('ln-complex', evaluable.ln, numpy.log, NZC(4, 4))
 _check('product', lambda a: evaluable.product(a, 2), lambda a: numpy.product(a, 2), ANY(4, 3, 4))
 _check('product-complex', lambda a: evaluable.product(a, 2), lambda a: numpy.product(a, 2), ANC(4, 3, 4))
 _check('sum', lambda a: evaluable.sum(a, 2), lambda a: a.sum(2), ANY(4, 3, 4))
 _check('sum-complex', lambda a: evaluable.sum(a, 2), lambda a: a.sum(2), ANC(4, 3, 4))
 _check('transpose1', lambda a: evaluable.transpose(a, [0, 1, 3, 2]), lambda a: a.transpose([0, 1, 3, 2]), ANY(2, 3, 4, 5))
 _check('transpose2', lambda a: evaluable.transpose(a, [0, 2, 3, 1]), lambda a: a.transpose([0, 2, 3, 1]), ANY(2, 3, 4, 5))
-_check('insertaxis', lambda a: evaluable.insertaxis(a, 1, 3), lambda a: numpy.repeat(a[:, None], 3, 1), ANY(2, 4))
-_check('get', lambda a: evaluable.get(a, 2, 1), lambda a: a[:, :, 1], ANY(4, 3, 4))
+_check('insertaxis', lambda a: evaluable.insertaxis(a, 1, evaluable.constant(3)), lambda a: numpy.repeat(a[:, None], 3, 1), ANY(2, 4))
+_check('get', lambda a: evaluable.get(a, 2, evaluable.constant(1)), lambda a: a[:, :, 1], ANY(4, 3, 4))
 _check('takediag141', lambda a: evaluable.takediag(a, 0, 2), lambda a: numeric.takediag(a, 0, 2), ANY(1, 4, 1))
 _check('takediag434', lambda a: evaluable.takediag(a, 0, 2), lambda a: numeric.takediag(a, 0, 2), ANY(4, 3, 4))
 _check('takediag343', lambda a: evaluable.takediag(a, 0, 2), lambda a: numeric.takediag(a, 0, 2), ANY(3, 4, 3))
 _check('determinant141', lambda a: evaluable.determinant(a, (0, 2)), lambda a: numpy.linalg.det(a.swapaxes(0, 1)), ANY(1, 4, 1))
 _check('determinant141-complex', lambda a: evaluable.determinant(a, (0, 2)), lambda a: numpy.linalg.det(a.swapaxes(0, 1)), ANC(1, 4, 1))
 _check('determinant434', lambda a: evaluable.determinant(a, (0, 2)), lambda a: numpy.linalg.det(a.swapaxes(0, 1)), ANY(4, 3, 4))
 _check('determinant434-complex', lambda a: evaluable.determinant(a, (0, 2)), lambda a: numpy.linalg.det(a.swapaxes(0, 1)), ANC(4, 3, 4))
@@ -509,15 +516,15 @@
 _check('determinant200-complex', lambda a: evaluable.determinant(a, (1, 2)), lambda a: numpy.linalg.det(a) if a.shape[-1] else numpy.ones(a.shape[:-2], complex), numpy.empty((2, 0, 0), dtype=complex), zerograd=True)
 _check('inverse141', lambda a: evaluable.inverse(a, (0, 2)), lambda a: numpy.linalg.inv(a.swapaxes(0, 1)).swapaxes(0, 1), NZ(1, 4, 1))
 _check('inverse141-complex', lambda a: evaluable.inverse(a, (0, 2)), lambda a: numpy.linalg.inv(a.swapaxes(0, 1)).swapaxes(0, 1), NZC(1, 4, 1))
 _check('inverse434', lambda a: evaluable.inverse(a, (0, 2)), lambda a: numpy.linalg.inv(a.swapaxes(0, 1)).swapaxes(0, 1), POS(4, 3, 4)+numpy.eye(4, 4)[:, numpy.newaxis, :])
 _check('inverse434-complex', lambda a: evaluable.inverse(a, (0, 2)), lambda a: numpy.linalg.inv(a.swapaxes(0, 1)).swapaxes(0, 1), ANC(4, 3, 4)+numpy.eye(4, 4)[:, numpy.newaxis, :])
 _check('inverse4422', lambda a: evaluable.inverse(a), lambda a: numpy.linalg.inv(a), POS(4, 4, 2, 2)+numpy.eye(2))
 _check('inverse4422-complex', lambda a: evaluable.inverse(a), lambda a: numpy.linalg.inv(a), ANC(4, 4, 2, 2)+numpy.eye(2))
-_check('repeat', lambda a: evaluable.repeat(a, 3, 1), lambda a: numpy.repeat(a, 3, 1), ANY(4, 1, 4))
+_check('repeat', lambda a: evaluable.repeat(a, evaluable.constant(3), 1), lambda a: numpy.repeat(a, 3, 1), ANY(4, 1, 4))
 _check('diagonalize', lambda a: evaluable.diagonalize(a, 1, 3), lambda a: numeric.diagonalize(a, 1, 3), ANY(4, 4, 4, 4))
 _check('multiply', evaluable.multiply, numpy.multiply, ANY(4, 4), ANY(4, 4))
 _check('multiply-complex', evaluable.multiply, numpy.multiply, ANC(4, 4), 1-1j+ANC(4, 4))
 _check('dot', lambda a, b: evaluable.dot(a, b, axes=1), lambda a, b: (a*b).sum(1), ANY(4, 2, 4), ANY(4, 2, 4))
 _check('divide', evaluable.divide, lambda a, b: a * b**-1, ANY(4, 4), NZ(4, 4))
 _check('divide2', lambda a: evaluable.asarray(a)/2, lambda a: a/2, ANY(4, 1))
 _check('divide-complex', evaluable.divide, lambda a, b: a * b**-1, ANC(4, 4), NZC(4, 4).T)
@@ -528,69 +535,77 @@
 _check('mulsum', lambda a, b: evaluable.multiply(a, b).sum(-2), lambda a, b: (a*b).sum(-2), ANY(4, 2, 4), ANY(4, 2, 4))
 _check('min', lambda a, b: evaluable.Minimum(a, b), numpy.minimum, ANY(4, 4), ANY(4, 4))
 _check('max', lambda a, b: evaluable.Maximum(a, b), numpy.maximum, ANY(4, 4), ANY(4, 4))
 _check('equal', evaluable.Equal, numpy.equal, ANY(4, 4), ANY(4, 4), zerograd=True)
 _check('greater', evaluable.Greater, numpy.greater, ANY(4, 4), ANY(4, 4), zerograd=True)
 _check('less', evaluable.Less, numpy.less, ANY(4, 4), ANY(4, 4), zerograd=True)
 _check('arctan2', evaluable.arctan2, numpy.arctan2, ANY(4, 4), ANY(4, 4))
-_check('stack', lambda a, b: evaluable.stack([a, b], 0), lambda a, b: numpy.concatenate([a[_, :], b[_, :]], axis=0), ANY(4), ANY(4))
+_check('stack', lambda a, b: evaluable.stack([a, b], 0), lambda a, b: numpy.concatenate([a[numpy.newaxis, :], b[numpy.newaxis, :]], axis=0), ANY(4), ANY(4))
 _check('eig', lambda a: evaluable.eig(a+a.swapaxes(0, 1), symmetric=True)[1], lambda a: numpy.linalg.eigh(a+a.swapaxes(0, 1))[1], ANY(4, 4), hasgrad=False)
 _check('eig-complex', lambda a: evaluable.eig(a+a.swapaxes(0, 1))[1], lambda a: numpy.linalg.eig(a+a.swapaxes(0, 1))[1], ANC(4, 4), hasgrad=False)
 _check('mod', lambda a, b: evaluable.mod(a, b), lambda a, b: numpy.mod(a, b), ANY(4), NZ(4), hasgrad=False)
 _check('mask', lambda f: evaluable.mask(f, numpy.array([True, False, True, False, True, False, True]), axis=1), lambda a: a[:, ::2], ANY(4, 7, 4))
 _check('ravel', lambda f: evaluable.ravel(f, axis=1), lambda a: a.reshape(4, 4, 4, 4), ANY(4, 2, 2, 4, 4))
-_check('unravel', lambda f: evaluable.unravel(f, axis=1, shape=[2, 2]), lambda a: a.reshape(4, 2, 2, 4, 4), ANY(4, 4, 4, 4))
-_check('ravelindex', lambda a, b: evaluable.RavelIndex(a, b, 12, 20), lambda a, b: a[..., _, _] * 20 + b, INT(3, 4), INT(4, 5))
-_check('inflate', lambda f: evaluable._inflate(f, dofmap=evaluable.Guard([0, 3]), length=4, axis=1), lambda a: numpy.concatenate([a[:, :1], numpy.zeros_like(a), a[:, 1:]], axis=1), ANY(4, 2, 4))
-_check('inflate-constant', lambda f: evaluable._inflate(f, dofmap=[0, 3], length=4, axis=1), lambda a: numpy.concatenate([a[:, :1], numpy.zeros_like(a), a[:, 1:]], axis=1), ANY(4, 2, 4))
-_check('inflate-duplicate', lambda f: evaluable.Inflate(f, dofmap=[0, 1, 0, 3], length=4), lambda a: numpy.stack([a[:, 0]+a[:, 2], a[:, 1], numpy.zeros_like(a[:, 0]), a[:, 3]], axis=1), ANY(2, 4))
-_check('inflate-block', lambda f: evaluable.Inflate(f, dofmap=[[5, 4, 3], [2, 1, 0]], length=6), lambda a: a.ravel()[::-1], ANY(2, 3))
-_check('inflate-scalar', lambda f: evaluable.Inflate(f, dofmap=1, length=3), lambda a: numpy.array([0, a, 0]), numpy.array(.5))
-_check('inflate-diagonal', lambda f: evaluable.Inflate(evaluable.Inflate(f, 1, 3), 1, 3), lambda a: numpy.diag(numpy.array([0, a, 0])), numpy.array(.5))
-_check('inflate-one', lambda f: evaluable.Inflate(f, 0, 1), lambda a: numpy.array([a]), numpy.array(.5))
-_check('inflate-range', lambda f: evaluable.Inflate(f, evaluable.Range(3), 3), lambda a: a, ANY(3))
-_check('take', lambda f: evaluable.Take(f, [0, 3, 2]), lambda a: a[:, [0, 3, 2]], ANY(2, 4))
-_check('take-duplicate', lambda f: evaluable.Take(f, [0, 3, 0]), lambda a: a[:, [0, 3, 0]], ANY(2, 4))
-_check('choose', lambda a, b, c: evaluable.Choose(a % 2, [b, c]), lambda a, b, c: numpy.choose(a % 2, [b, c]), INT(3, 3), ANY(3, 3), ANY(3, 3))
+_check('unravel', lambda f: evaluable.unravel(f, axis=1, shape=[evaluable.constant(2), evaluable.constant(2)]), lambda a: a.reshape(4, 2, 2, 4, 4), ANY(4, 4, 4, 4))
+_check('ravelindex', lambda a, b: evaluable.RavelIndex(a, b, evaluable.constant(12), evaluable.constant(20)), lambda a, b: a[..., numpy.newaxis, numpy.newaxis] * 20 + b, INT(3, 4), INT(4, 5))
+_check('inflate', lambda f: evaluable._inflate(f, dofmap=evaluable.Guard(evaluable.constant([0, 3])), length=evaluable.constant(4), axis=1), lambda a: numpy.concatenate([a[:, :1], numpy.zeros_like(a), a[:, 1:]], axis=1), ANY(4, 2, 4))
+_check('inflate-constant', lambda f: evaluable._inflate(f, dofmap=evaluable.constant([0, 3]), length=evaluable.constant(4), axis=1), lambda a: numpy.concatenate([a[:, :1], numpy.zeros_like(a), a[:, 1:]], axis=1), ANY(4, 2, 4))
+_check('inflate-duplicate', lambda f: evaluable.Inflate(f, dofmap=evaluable.constant([0, 1, 0, 3]), length=evaluable.constant(4)), lambda a: numpy.stack([a[:, 0]+a[:, 2], a[:, 1], numpy.zeros_like(a[:, 0]), a[:, 3]], axis=1), ANY(2, 4))
+_check('inflate-block', lambda f: evaluable.Inflate(f, dofmap=evaluable.constant([[5, 4, 3], [2, 1, 0]]), length=evaluable.constant(6)), lambda a: a.ravel()[::-1], ANY(2, 3))
+_check('inflate-scalar', lambda f: evaluable.Inflate(f, dofmap=evaluable.constant(1), length=evaluable.constant(3)), lambda a: numpy.array([0, a, 0]), numpy.array(.5))
+_check('inflate-diagonal', lambda f: evaluable.Inflate(evaluable.Inflate(f, evaluable.constant(1), evaluable.constant(3)), evaluable.constant(1), evaluable.constant(3)), lambda a: numpy.diag(numpy.array([0, a, 0])), numpy.array(.5))
+_check('inflate-one', lambda f: evaluable.Inflate(f, evaluable.constant(0), evaluable.constant(1)), lambda a: numpy.array([a]), numpy.array(.5))
+_check('inflate-range', lambda f: evaluable.Inflate(f, evaluable.Range(evaluable.constant(3)), evaluable.constant(3)), lambda a: a, ANY(3))
+_check('take', lambda f: evaluable.Take(f, evaluable.constant([0, 3, 2])), lambda a: a[:, [0, 3, 2]], ANY(2, 4))
+_check('take-duplicate', lambda f: evaluable.Take(f, evaluable.constant([0, 3, 0])), lambda a: a[:, [0, 3, 0]], ANY(2, 4))
+_check('choose', lambda a, b, c: evaluable.Choose(a % 2, b, c), lambda a, b, c: numpy.choose(a % 2, [b, c]), INT(3, 3), ANY(3, 3), ANY(3, 3))
 _check('slice', lambda a: evaluable.asarray(a)[::2], lambda a: a[::2], ANY(5, 3))
-_check('normal1d', lambda a: evaluable.Normal(a), lambda a: numpy.sign(a[..., 0]), NZ(3, 1, 1))
-_check('normal2d', lambda a: evaluable.Normal(a), lambda a: numpy.stack([Q[:, -1]*numpy.sign(R[-1, -1]) for ai in a for Q, R in [numpy.linalg.qr(ai, mode='complete')]], axis=0), POS(1, 2, 2)+numpy.eye(2))
-_check('normal3d', lambda a: evaluable.Normal(a), lambda a: numpy.stack([Q[:, -1]*numpy.sign(R[-1, -1]) for ai in a for Q, R in [numpy.linalg.qr(ai, mode='complete')]], axis=0), POS(2, 3, 3)+numpy.eye(3))
+_check('normal1d', evaluable.Orthonormal, lambda G, a: numpy.sign(a), numpy.zeros([3,1,0]), NZ(3, 1))
+_check('normal2d', evaluable.Orthonormal, lambda G, a: numeric.normalize(a - numeric.normalize(G[...,0]) * ((a * numeric.normalize(G[...,0])).sum(-1))[...,numpy.newaxis]), POS(3, 2, 1), ANY(3, 2))
+_check('normal3d', evaluable.Orthonormal, lambda G, a: numeric.normalize(a - numpy.einsum('pij,pj->pi', G, numpy.linalg.solve(numpy.einsum('pki,pkj->pij', G, G), numpy.einsum('pij,pi->pj', G, a)))), POS(2, 3, 2) + numpy.eye(3)[:,:2], ANY(2, 3))
+_check('normalmanifold', evaluable.Orthonormal, lambda G, a: numeric.normalize(a - numpy.einsum('pij,pj->pi', G, numpy.linalg.solve(numpy.einsum('pki,pkj->pij', G, G), numpy.einsum('pij,pi->pj', G, a)))), POS(2, 3, 1), ANY(2, 3))
 _check('loopsum1', lambda: evaluable.loop_sum(evaluable.loop_index('index', 3), evaluable.loop_index('index', 3)), lambda: numpy.array(3))
 _check('loopsum2', lambda a: evaluable.loop_sum(a, evaluable.loop_index('index', 2)), lambda a: 2*a, ANY(3, 4, 2, 4))
 _check('loopsum3', lambda a: evaluable.loop_sum(evaluable.get(a, 0, evaluable.loop_index('index', 3)), evaluable.loop_index('index', 3)), lambda a: numpy.sum(a, 0), ANY(3, 4, 2, 4))
-_check('loopsum4', lambda: evaluable.loop_sum(evaluable.Inflate(evaluable.loop_index('index', 3), 0, 2), evaluable.loop_index('index', 3)), lambda: numpy.array([3, 0]))
+_check('loopsum4', lambda: evaluable.loop_sum(evaluable.Inflate(evaluable.loop_index('index', 3), evaluable.constant(0), evaluable.constant(2)), evaluable.loop_index('index', 3)), lambda: numpy.array([3, 0]))
 _check('loopsum5', lambda: evaluable.loop_sum(evaluable.loop_index('index', 1), evaluable.loop_index('index', 1)), lambda: numpy.array(0))
+_check('loopsum6', lambda: evaluable.loop_sum(evaluable.Guard(evaluable.constant(1) + evaluable.loop_index('index', 4)), evaluable.loop_index('index', 4)) * evaluable.loop_sum(evaluable.loop_index('index', 4), evaluable.loop_index('index', 4)), lambda: numpy.array(60))
 _check('loopconcatenate1', lambda a: evaluable.loop_concatenate(a+evaluable.prependaxes(evaluable.loop_index('index', 3), a.shape), evaluable.loop_index('index', 3)), lambda a: a+numpy.arange(3)[None], ANY(3, 1))
-_check('loopconcatenate2', lambda: evaluable.loop_concatenate(evaluable.Elemwise([numpy.arange(48).reshape(4, 4, 3)[:, :, a:b] for a, b in util.pairwise([0, 2, 3])], evaluable.loop_index('index', 2), int), evaluable.loop_index('index', 2)), lambda: numpy.arange(48).reshape(4, 4, 3))
+_check('loopconcatenate2', lambda: evaluable.loop_concatenate(evaluable.Elemwise(tuple(types.arraydata(numpy.arange(48).reshape(4, 4, 3)[:, :, a:b]) for a, b in util.pairwise([0, 2, 3])), evaluable.loop_index('index', 2), int), evaluable.loop_index('index', 2)), lambda: numpy.arange(48).reshape(4, 4, 3))
 _check('loopconcatenatecombined', lambda a: evaluable.loop_concatenate_combined([a+evaluable.prependaxes(evaluable.loop_index('index', 3), a.shape)], evaluable.loop_index('index', 3))[0], lambda a: a+numpy.arange(3)[None], ANY(3, 1), hasgrad=False)
 _check('legendre', lambda a: evaluable.Legendre(evaluable.asarray(a), 5), lambda a: numpy.moveaxis(numpy.polynomial.legendre.legval(a, numpy.eye(6)), 0, -1), ANY(3, 4, 3))
 
-_polyval_mask = lambda shape, ndim: 1 if ndim == 0 else numpy.array([sum(i[-ndim:]) < int(shape[-1]) for i in numpy.ndindex(shape)], dtype=int).reshape(shape)
-_polyval_desired = lambda c, x: sum(c[(..., *i)]*(x[(slice(None), *[None]*(c.ndim-x.shape[1]))]**i).prod(-1) for i in itertools.product(*[range(c.shape[-1])]*x.shape[1]) if sum(i) < c.shape[-1])
-_check('polyval_1d_p0', lambda c, x: evaluable.Polyval(c*_polyval_mask(c.shape, x.shape[1]), x), _polyval_desired, POS(1), ANY(4, 1), ndim=1)
-_check('polyval_1d_p1', lambda c, x: evaluable.Polyval(c*_polyval_mask(c.shape, x.shape[1]), x), _polyval_desired, NZ(2), ANY(4, 1), ndim=1)
-_check('polyval_1d_p2', lambda c, x: evaluable.Polyval(c*_polyval_mask(c.shape, x.shape[1]), x), _polyval_desired, ANY(3), ANY(4, 1), ndim=1)
-_check('polyval_2d_p0', lambda c, x: evaluable.Polyval(c*_polyval_mask(c.shape, x.shape[1]), x), _polyval_desired, POS(1, 1), ANY(4, 2), ndim=2)
-_check('polyval_2d_p1', lambda c, x: evaluable.Polyval(c*_polyval_mask(c.shape, x.shape[1]), x), _polyval_desired, ANY(2, 2), ANY(4, 2), ndim=2)
-_check('polyval_2d_p2', lambda c, x: evaluable.Polyval(c*_polyval_mask(c.shape, x.shape[1]), x), _polyval_desired, ANY(3, 3), ANY(4, 2), ndim=2)
-_check('polyval_2d_p1_23', lambda c, x: evaluable.Polyval(c*_polyval_mask(c.shape, x.shape[1]), x), _polyval_desired, ANY(2, 3, 2, 2), ANY(4, 2), ndim=2)
+_check('polyval_1d_p0', lambda c, x: evaluable.Polyval(c, x), poly.eval_outer, POS(1), ANY(4, 1), ndim=1)
+_check('polyval_1d_p1', lambda c, x: evaluable.Polyval(c, x), poly.eval_outer, NZ(2), ANY(4, 1), ndim=1)
+_check('polyval_1d_p2', lambda c, x: evaluable.Polyval(c, x), poly.eval_outer, ANY(3), ANY(4, 1), ndim=1)
+_check('polyval_2d_p0', lambda c, x: evaluable.Polyval(c, x), poly.eval_outer, POS(1), ANY(4, 2), ndim=2)
+_check('polyval_2d_p1', lambda c, x: evaluable.Polyval(c, x), poly.eval_outer, ANY(3), ANY(4, 2), ndim=2)
+_check('polyval_2d_p2', lambda c, x: evaluable.Polyval(c, x), poly.eval_outer, ANY(6), ANY(4, 2), ndim=2)
+_check('polyval_2d_p1_23', lambda c, x: evaluable.Polyval(c, x), poly.eval_outer, ANY(2, 3, 3), ANY(4, 2), ndim=2)
+_check('polymul_x3yz1', lambda l, r: evaluable.PolyMul(l, r, (poly.MulVar.Left, poly.MulVar.Right, poly.MulVar.Right)), lambda l, r: poly.mul(l, r, (poly.MulVar.Left, poly.MulVar.Right, poly.MulVar.Right)), ANY(4, 4, 4), ANY(4, 4, 3), hasgrad=False)
+_check('polymul_x2y0', lambda l, r: evaluable.PolyMul(l, r, (poly.MulVar.Left, poly.MulVar.Right)), lambda l, r: poly.mul(l, r, (poly.MulVar.Left, poly.MulVar.Right)), ANY(4, 4, 3), ANY(4, 4, 1), hasgrad=False)
+_check('polygrad_xy0', lambda c: evaluable.PolyGrad(c, 2), lambda c: poly.grad(c, 2), ANY(4, 1), hasgrad=False)
+_check('polygrad_xy1', lambda c: evaluable.PolyGrad(c, 2), lambda c: poly.grad(c, 2), ANY(2, 2, 3), hasgrad=False)
+_check('polygrad_xy2', lambda c: evaluable.PolyGrad(c, 2), lambda c: poly.grad(c, 2), ANY(4, 4, 6), hasgrad=False)
+
+_check('searchsorted', lambda a: evaluable.SearchSorted(evaluable.asarray(a), array=types.arraydata(numpy.linspace(0, 1, 9)), side='left', sorter=None), lambda a: numpy.searchsorted(numpy.linspace(0, 1, 9), a).astype(int), POS(4, 2))
+_check('searchsorted_sorter', lambda a: evaluable.SearchSorted(evaluable.asarray(a), array=types.arraydata([.2,.8,.4,0,.6,1]), side='left', sorter=types.arraydata([3,0,2,4,1,5])), lambda a: numpy.searchsorted([.2,.8,.4,0,.6,1], a, sorter=[3,0,2,4,1,5]).astype(int), POS(4, 2))
 
 
 class intbounds(TestCase):
 
     @staticmethod
     def R(start, shape):
         # A range of numbers starting at `start` with the given `shape`.
         if isinstance(shape, int):
             size = shape
             shape = shape,
         else:
             size = util.product(shape)
-        return evaluable.Constant(numpy.arange(start, start+size).reshape(*shape))
+        return evaluable.constant(numpy.arange(start, start+size).reshape(*shape))
 
     class S(evaluable.Array):
         # An evaluable scalar argument with given bounds.
         def __init__(self, argname, lower, upper):
             self._argname = argname
             self._lower = lower
             self._upper = upper
@@ -624,28 +639,28 @@
         self.assertEqual(self.R(-4, [2, 3, 4])._intbounds, (-4, 19))
 
     def test_constant_empty(self):
         self.assertEqual(self.R(0, [0])._intbounds, (float('-inf'), float('inf')))
 
     def test_insertaxis(self):
         arg = self.R(-4, [2, 3, 4])
-        self.assertEqual(evaluable.InsertAxis(arg, 2)._intbounds, arg._intbounds)
+        self.assertEqual(evaluable.InsertAxis(arg, evaluable.constant(2))._intbounds, arg._intbounds)
 
     def test_transpose(self):
         arg = self.R(-4, [2, 3, 4])
         self.assertEqual(evaluable.Transpose(arg, (2, 0, 1))._intbounds, arg._intbounds)
 
     def test_multiply(self):
         args = tuple(self.R(low, [high+1-low]) for low, high in ((-13, -5), (-2, 7), (3, 11)))
         for arg1 in args:
             for arg2 in args:
-                self.assertBounds(evaluable.Multiply((evaluable.insertaxis(arg1, 1, arg2.shape[0]), evaluable.insertaxis(arg2, 0, arg1.shape[0]))))
+                self.assertBounds(evaluable.multiply(evaluable.insertaxis(arg1, 1, arg2.shape[0]), evaluable.insertaxis(arg2, 0, arg1.shape[0])))
 
     def test_add(self):
-        self.assertBounds(evaluable.Add((evaluable.insertaxis(self.R(-5, [8]), 1, 5), evaluable.insertaxis(self.R(2, [5]), 0, 8))))
+        self.assertBounds(evaluable.add(evaluable.insertaxis(self.R(-5, [8]), 1, evaluable.constant(5)), evaluable.insertaxis(self.R(2, [5]), 0, evaluable.constant(8))))
 
     def test_sum_zero_axis(self):
         self.assertEqual(evaluable.Sum(self.R(0, [0]))._intbounds, (0, 0))
 
     def test_sum_variable_axis_including_zero(self):
         self.assertEqual(evaluable.Sum(evaluable.Argument('test', (self.S('n', 0, 4),), int))._intbounds, (float('-inf'), float('inf')))
 
@@ -682,57 +697,57 @@
     def test_absolute_positive(self):
         self.assertBounds(evaluable.Absolute(self.R(1, [3])))
 
     def test_absolute_full(self):
         self.assertBounds(evaluable.Absolute(self.R(-3, [7])))
 
     def test_mod_nowrap(self):
-        self.assertBounds(evaluable.Mod(evaluable.insertaxis(self.R(1, [4]), 1, 3), evaluable.insertaxis(self.R(5, [3]), 0, 4)))
+        self.assertBounds(evaluable.Mod(evaluable.insertaxis(self.R(1, [4]), 1, evaluable.constant(3)), evaluable.insertaxis(self.R(5, [3]), 0, evaluable.constant(4))))
 
     def test_mod_wrap_negative(self):
-        self.assertBounds(evaluable.Mod(evaluable.insertaxis(self.R(-3, [7]), 1, 3), evaluable.insertaxis(self.R(5, [3]), 0, 7)))
+        self.assertBounds(evaluable.Mod(evaluable.insertaxis(self.R(-3, [7]), 1, evaluable.constant(3)), evaluable.insertaxis(self.R(5, [3]), 0, evaluable.constant(7))))
 
     def test_mod_wrap_positive(self):
-        self.assertBounds(evaluable.Mod(evaluable.insertaxis(self.R(3, [7]), 1, 3), evaluable.insertaxis(self.R(5, [3]), 0, 7)))
+        self.assertBounds(evaluable.Mod(evaluable.insertaxis(self.R(3, [7]), 1, evaluable.constant(3)), evaluable.insertaxis(self.R(5, [3]), 0, evaluable.constant(7))))
 
     def test_mod_negative_divisor(self):
-        self.assertEqual(evaluable.Mod(evaluable.Argument('d', (2,), int), self.R(-3, [2]))._intbounds, (float('-inf'), float('inf')))
+        self.assertEqual(evaluable.Mod(evaluable.Argument('d', (evaluable.constant(2),), int), self.R(-3, [2]))._intbounds, (float('-inf'), float('inf')))
 
     def test_sign(self):
         for i in range(-2, 3):
             for j in range(i, 3):
                 self.assertBounds(evaluable.Sign(self.R(i, [j-i+1])))
 
     def test_zeros(self):
-        self.assertEqual(evaluable.Zeros((2, 3), int)._intbounds, (0, 0))
+        self.assertEqual(evaluable.Zeros((evaluable.constant(2), evaluable.constant(3)), int)._intbounds, (0, 0))
 
     def test_range(self):
         self.assertEqual(evaluable.Range(self.S('n', 0, 0))._intbounds, (0, 0))
         self.assertBounds(evaluable.Range(self.S('n', 1, 3)), n=3)
 
     def test_inrange_loose(self):
-        self.assertEqual(evaluable.InRange(self.S('n', 3, 5), evaluable.Constant(6))._intbounds, (3, 5))
+        self.assertEqual(evaluable.InRange(self.S('n', 3, 5), evaluable.constant(6))._intbounds, (3, 5))
 
     def test_inrange_strict(self):
         self.assertEqual(evaluable.InRange(self.S('n', float('-inf'), float('inf')), self.S('m', 2, 4))._intbounds, (0, 3))
 
     def test_inrange_empty(self):
-        self.assertEqual(evaluable.InRange(self.S('n', float('-inf'), float('inf')), evaluable.Constant(0))._intbounds, (0, 0))
+        self.assertEqual(evaluable.InRange(self.S('n', float('-inf'), float('inf')), evaluable.constant(0))._intbounds, (0, 0))
 
     def test_npoints(self):
         self.assertEqual(evaluable.NPoints()._intbounds, (0, float('inf')))
 
     def test_bool_to_int(self):
-        self.assertEqual(evaluable.BoolToInt(evaluable.Constant(numpy.array([False, True], dtype=bool)))._intbounds, (0, 1))
+        self.assertEqual(evaluable.BoolToInt(evaluable.constant(numpy.array([False, True], dtype=bool)))._intbounds, (0, 1))
 
     def test_array_from_tuple(self):
-        self.assertEqual(evaluable.ArrayFromTuple(evaluable.Tuple((evaluable.Argument('n', (3,), int),)), 0, (3,), int, _lower=-2, _upper=3)._intbounds, (-2, 3))
+        self.assertEqual(evaluable.ArrayFromTuple(evaluable.Tuple((evaluable.Argument('n', (evaluable.constant(3),), int),)), 0, (evaluable.constant(3),), int, _lower=-2, _upper=3)._intbounds, (-2, 3))
 
     def test_inflate(self):
-        self.assertEqual(evaluable.Inflate(self.R(4, (2, 3)), evaluable.Constant(numpy.arange(6).reshape(2, 3)), 7)._intbounds, (0, 9))
+        self.assertEqual(evaluable.Inflate(self.R(4, (2, 3)), evaluable.constant(numpy.arange(6).reshape(2, 3)), evaluable.constant(7))._intbounds, (0, 9))
 
     def test_normdim_positive(self):
         self.assertEqual(evaluable.NormDim(self.S('l', 2, 4), self.S('i', 1, 3))._intbounds, (1, 3))
 
     def test_normdim_negative(self):
         self.assertEqual(evaluable.NormDim(self.S('l', 4, 4), self.S('i', -3, -1))._intbounds, (1, 3))
 
@@ -742,45 +757,14 @@
     def test_minimum(self):
         self.assertEqual(evaluable.Minimum(self.S('a', 0, 4), self.S('b', 1, 3))._intbounds, (0, 3))
 
     def test_maximum(self):
         self.assertEqual(evaluable.Maximum(self.S('a', 0, 4), self.S('b', 1, 3))._intbounds, (1, 4))
 
 
-class simplifications(TestCase):
-
-    def test_minimum_maximum_bounds(self):
-
-        class R(evaluable.Array):
-            # An evaluable scalar argument with given bounds.
-            def __init__(self, lower, upper):
-                self._lower = lower
-                self._upper = upper
-                super().__init__(args=(evaluable.EVALARGS,), shape=(), dtype=int)
-
-            def evalf(self, evalargs):
-                raise NotImplementedError
-
-            @property
-            def _intbounds(self):
-                return self._lower, self._upper
-
-        a = R(0, 2)
-        b = R(2, 4)
-
-        with self.subTest('min-left'):
-            self.assertEqual(evaluable.Minimum(a, b).simplified, a)
-        with self.subTest('min-right'):
-            self.assertEqual(evaluable.Minimum(b, a).simplified, a)
-        with self.subTest('max-left'):
-            self.assertEqual(evaluable.Maximum(b, a).simplified, b)
-        with self.subTest('max-right'):
-            self.assertEqual(evaluable.Maximum(a, b).simplified, b)
-
-
 class commutativity(TestCase):
 
     def setUp(self):
         super().setUp()
         numpy.random.seed(0)
         self.A = evaluable.asarray(numpy.random.uniform(size=[2, 3]))
         self.B = evaluable.asarray(numpy.random.uniform(size=[2, 3]))
@@ -791,64 +775,38 @@
     def test_multiply(self):
         self.assertEqual(evaluable.multiply(self.A, self.B), evaluable.multiply(self.B, self.A))
 
     def test_dot(self):
         self.assertEqual(evaluable.dot(self.A, self.B, axes=[0]), evaluable.dot(self.B, self.A, axes=[0]))
 
     def test_combined(self):
-        self.assertEqual(evaluable.add(self.A, self.B) * evaluable.insertaxis(evaluable.dot(self.A, self.B, axes=[0]), 0, 2),
-                         evaluable.insertaxis(evaluable.dot(self.B, self.A, axes=[0]), 0, 2) * evaluable.add(self.B, self.A))
+        self.assertEqual(evaluable.add(self.A, self.B) * evaluable.insertaxis(evaluable.dot(self.A, self.B, axes=[0]), 0, evaluable.constant(2)),
+                         evaluable.insertaxis(evaluable.dot(self.B, self.A, axes=[0]), 0, evaluable.constant(2)) * evaluable.add(self.B, self.A))
 
 
 class sampled(TestCase):
 
     def test_match(self):
-        f = evaluable.Sampled(numpy.array([[1, 2], [3, 4]]), numpy.array([[1, 2], [3, 4]]))
+        f = evaluable.Sampled(evaluable.constant([[1, 2], [3, 4]]), evaluable.constant([[1, 2], [3, 4]]), 'none')
         self.assertAllEqual(f.eval(), numpy.eye(2))
 
     def test_no_match(self):
-        f = evaluable.Sampled(numpy.array([[1, 2], [3, 4]]), numpy.array([[3, 4], [1, 2]]))
+        f = evaluable.Sampled(evaluable.constant([[1, 2], [3, 4]]), evaluable.constant([[3, 4], [1, 2]]), 'none')
         with self.assertRaises(Exception):
             f.eval()
 
 
-@parametrize
-class piecewise(TestCase):
-
-    def setUp(self):
-        super().setUp()
-        self.domain, self.geom = mesh.rectilinear([1])
-        x, = self.geom
-        if self.partition:
-            left, mid, right = function.partition(x, .2, .8)
-            self.f = left + function.sin(x) * mid + x**2 * right
-        else:
-            self.f = function.piecewise(x, [.2, .8], 1, function.sin(x), x**2)
-
-    def test_evalf(self):
-        f_ = self.domain.sample('uniform', 4).eval(self.f)  # x=.125, .375, .625, .875
-        assert numpy.equal(f_, [1, numpy.sin(.375), numpy.sin(.625), .875**2]).all()
-
-    def test_deriv(self):
-        g_ = self.domain.sample('uniform', 4).eval(function.grad(self.f, self.geom))  # x=.125, .375, .625, .875
-        assert numpy.equal(g_, [[0], [numpy.cos(.375)], [numpy.cos(.625)], [2*.875]]).all()
-
-
-piecewise(partition=False)
-piecewise(partition=True)
-
-
 class elemwise(TestCase):
 
     def assertElemwise(self, items):
-        items = tuple(map(numpy.array, items))
+        items = tuple(map(types.arraydata, items))
         index = evaluable.Argument('index', (), int)
         elemwise = evaluable.Elemwise(items, index, int)
         for i, item in enumerate(items):
-            self.assertEqual(elemwise.eval(index=i).tolist(), item.tolist())
+            self.assertEqual(elemwise.eval(index=i).tolist(), numpy.asarray(item).tolist())
 
     def test_const_values(self):
         self.assertElemwise((numpy.arange(2*3*4).reshape(2, 3, 4),)*3)
 
     def test_const_shape(self):
         self.assertElemwise(numpy.arange(4*2*3*4).reshape(4, 2, 3, 4))
 
@@ -858,38 +816,59 @@
     def test_var_shape(self):
         self.assertElemwise(numpy.arange(i*j).reshape(i, j) for i, j in ((1, 2), (2, 4)))
 
 
 class derivative(TestCase):
 
     def test_int(self):
-        arg = evaluable.Argument('arg', (2,), int)
-        self.assertEqual(evaluable.derivative(evaluable.insertaxis(arg, 0, 1), arg), evaluable.Zeros((1, 2, 2), int))
+        arg = evaluable.Argument('arg', (evaluable.constant(2),), int)
+        self.assertEqual(evaluable.derivative(evaluable.insertaxis(arg, 0, evaluable.constant(1)), arg), evaluable.Zeros(tuple(map(evaluable.constant, (1, 2, 2))), int))
 
     def test_int_to_float(self):
         arg = evaluable.Argument('arg', (), float)
-        func = evaluable.IntToFloat(evaluable.BoolToInt(evaluable.Greater(arg, 0.)))
+        func = evaluable.IntToFloat(evaluable.BoolToInt(evaluable.Greater(arg, evaluable.zeros(()))))
         self.assertTrue(evaluable.iszero(evaluable.derivative(func, arg)))
 
+    def test_with_derivative(self):
+        arg = evaluable.Argument('arg', (evaluable.constant(3),), float)
+        deriv = numpy.arange(6, dtype=float).reshape(2, 3)
+        func = evaluable.zeros((evaluable.constant(2),), float)
+        func = evaluable.WithDerivative(func, arg, evaluable.asarray(deriv))
+        self.assertAllAlmostEqual(evaluable.derivative(func, arg).eval(), deriv)
+
+    def test_default_derivative(self):
+        # Tests whether `evaluable.Array._derivative` correctly raises an
+        # exception when taking a derivative to one of the arguments present in
+        # its `.arguments`.
+        class DefaultDeriv(evaluable.Array): pass
+        has_arg = evaluable.Argument('has_arg', (), float)
+        has_not_arg = evaluable.Argument('has_not_arg', (), float)
+        func = evaluable.WithDerivative(evaluable.Zeros((), float), has_arg, evaluable.Zeros((), float))
+        func = DefaultDeriv((func,), (), float)
+        with self.assertRaises(NotImplementedError):
+            evaluable.derivative(func, has_arg)
+        self.assertTrue(evaluable.iszero(evaluable.derivative(func, has_not_arg)))
+
 
 class asciitree(TestCase):
 
     @unittest.skipIf(sys.version_info < (3, 6), 'test requires dicts maintaining insertion order')
     def test_asciitree(self):
-        f = evaluable.Sin((evaluable.Zeros((), int))**evaluable.Diagonalize(evaluable.Argument('arg', (2,))))
+        n = evaluable.constant(2)
+        f = evaluable.Sin(evaluable.InsertAxis(evaluable.Inflate(evaluable.constant(1.), evaluable.constant(1), n), n)**evaluable.Diagonalize(evaluable.Argument('arg', (n,))))
         self.assertEqual(f.asciitree(richoutput=True),
                          '%0 = Sin; f:2,2\n'
                          '└ %1 = Power; f:2,2\n'
-                         '  ├ %2 = InsertAxis; f:2,2\n'
-                         '  │ ├ %3 = InsertAxis; f:2\n'
-                         '  │ │ ├ %4 = IntToFloat; f:\n'
-                         '  │ │ │ └ 0\n'
+                         '  ├ %2 = InsertAxis; f:~2,(2)\n'
+                         '  │ ├ %3 = Inflate; f:~2\n'
+                         '  │ │ ├ 1.0\n'
+                         '  │ │ ├ 1\n'
                          '  │ │ └ 2\n'
                          '  │ └ 2\n'
-                         '  └ %5 = Diagonalize; f:2,2\n'
+                         '  └ %4 = Diagonalize; f:2/,2/\n'
                          '    └ Argument; arg; f:2\n')
 
     @unittest.skipIf(sys.version_info < (3, 6), 'test requires dicts maintaining insertion order')
     def test_loop_sum(self):
         i = evaluable.loop_index('i', 2)
         f = evaluable.loop_sum(i, i)
         self.assertEqual(f.asciitree(richoutput=True),
@@ -900,185 +879,243 @@
                          '%B0 = LoopSum\n'
                          '└ func = %B1 = LoopIndex\n'
                          '  └ length = 2\n')
 
     @unittest.skipIf(sys.version_info < (3, 6), 'test requires dicts maintaining insertion order')
     def test_loop_concatenate(self):
         i = evaluable.loop_index('i', 2)
-        f = evaluable.loop_concatenate(evaluable.InsertAxis(i, 1), i)
+        f = evaluable.loop_concatenate(evaluable.InsertAxis(i, evaluable.constant(1)), i)
         self.assertEqual(f.asciitree(richoutput=True),
                          'SUBGRAPHS\n'
                          'A\n'
                          '└ B = Loop\n'
                          'NODES\n'
                          '%B0 = LoopConcatenate\n'
-                         '├ shape[0] = %A1 = Take; i:; [2,2]\n'
-                         '│ ├ %A2 = _SizesToOffsets; i:3; [0,2]\n'
-                         '│ │ └ %A3 = InsertAxis; i:2; [1,1]\n'
+                         '├ shape[0] = %A0 = Take; i:; [2,2]\n'
+                         '│ ├ %A1 = _SizesToOffsets; i:3; [0,2]\n'
+                         '│ │ └ %A2 = InsertAxis; i:(2); [1,1]\n'
                          '│ │   ├ 1\n'
                          '│ │   └ 2\n'
                          '│ └ 2\n'
-                         '├ start = %B4 = Take; i:; [0,2]\n'
-                         '│ ├ %A2\n'
-                         '│ └ %B5 = LoopIndex\n'
+                         '├ start = %B1 = Take; i:; [0,2]\n'
+                         '│ ├ %A1\n'
+                         '│ └ %B2 = LoopIndex\n'
                          '│   └ length = 2\n'
-                         '├ stop = %B6 = Take; i:; [0,2]\n'
-                         '│ ├ %A2\n'
-                         '│ └ %B7 = Add; i:; [1,2]\n'
-                         '│   ├ %B5\n'
+                         '├ stop = %B3 = Take; i:; [0,2]\n'
+                         '│ ├ %A1\n'
+                         '│ └ %B4 = Add; i:; [1,2]\n'
+                         '│   ├ %B2\n'
                          '│   └ 1\n'
-                         '└ func = %B8 = InsertAxis; i:1; [0,1]\n'
-                         '  ├ %B5\n'
+                         '└ func = %B5 = InsertAxis; i:(1); [0,1]\n'
+                         '  ├ %B2\n'
                          '  └ 1\n')
 
     @unittest.skipIf(sys.version_info < (3, 6), 'test requires dicts maintaining insertion order')
     def test_loop_concatenatecombined(self):
         i = evaluable.loop_index('i', 2)
-        f, = evaluable.loop_concatenate_combined([evaluable.InsertAxis(i, 1)], i)
+        f, = evaluable.loop_concatenate_combined([evaluable.InsertAxis(i, evaluable.constant(1))], i)
         self.assertEqual(f.asciitree(richoutput=True),
                          'SUBGRAPHS\n'
                          'A\n'
                          '└ B = Loop\n'
                          'NODES\n'
                          '%B0 = LoopConcatenate\n'
-                         '├ shape[0] = %A1 = Take; i:; [2,2]\n'
-                         '│ ├ %A2 = _SizesToOffsets; i:3; [0,2]\n'
-                         '│ │ └ %A3 = InsertAxis; i:2; [1,1]\n'
+                         '├ shape[0] = %A0 = Take; i:; [2,2]\n'
+                         '│ ├ %A1 = _SizesToOffsets; i:3; [0,2]\n'
+                         '│ │ └ %A2 = InsertAxis; i:(2); [1,1]\n'
                          '│ │   ├ 1\n'
                          '│ │   └ 2\n'
                          '│ └ 2\n'
-                         '├ start = %B4 = Take; i:; [0,2]\n'
-                         '│ ├ %A2\n'
-                         '│ └ %B5 = LoopIndex\n'
+                         '├ start = %B1 = Take; i:; [0,2]\n'
+                         '│ ├ %A1\n'
+                         '│ └ %B2 = LoopIndex\n'
                          '│   └ length = 2\n'
-                         '├ stop = %B6 = Take; i:; [0,2]\n'
-                         '│ ├ %A2\n'
-                         '│ └ %B7 = Add; i:; [1,2]\n'
-                         '│   ├ %B5\n'
+                         '├ stop = %B3 = Take; i:; [0,2]\n'
+                         '│ ├ %A1\n'
+                         '│ └ %B4 = Add; i:; [1,2]\n'
+                         '│   ├ %B2\n'
                          '│   └ 1\n'
-                         '└ func = %B8 = InsertAxis; i:1; [0,1]\n'
-                         '  ├ %B5\n'
+                         '└ func = %B5 = InsertAxis; i:(1); [0,1]\n'
+                         '  ├ %B2\n'
                          '  └ 1\n')
 
 
 class simplify(TestCase):
 
+    def test_minimum_maximum_bounds(self):
+
+        class R(evaluable.Array):
+            # An evaluable scalar argument with given bounds.
+            def __init__(self, lower, upper):
+                self._lower = lower
+                self._upper = upper
+                super().__init__(args=(evaluable.EVALARGS,), shape=(), dtype=int)
+
+            def evalf(self, evalargs):
+                raise NotImplementedError
+
+            @property
+            def _intbounds(self):
+                return self._lower, self._upper
+
+        a = R(0, 2)
+        b = R(2, 4)
+
+        with self.subTest('min-left'):
+            self.assertEqual(evaluable.Minimum(a, b).simplified, a)
+        with self.subTest('min-right'):
+            self.assertEqual(evaluable.Minimum(b, a).simplified, a)
+        with self.subTest('max-left'):
+            self.assertEqual(evaluable.Maximum(b, a).simplified, b)
+        with self.subTest('max-right'):
+            self.assertEqual(evaluable.Maximum(a, b).simplified, b)
+
     def test_multiply_transpose(self):
-        dummy = evaluable.Argument('dummy', shape=[2, 2, 2], dtype=float)
+        dummy = evaluable.Argument('dummy', shape=tuple(map(evaluable.constant, [2, 2, 2])), dtype=float)
         f = evaluable.multiply(dummy,
                                evaluable.Transpose(evaluable.multiply(dummy,
                                                                       evaluable.Transpose(dummy, (2, 0, 1))), (2, 0, 1)))
         # The test below is not only to verify that no simplifications are
         # performed, but also to make sure that simplified does not get stuck in a
         # circular dependence. This used to be the case prior to adding the
         # isinstance(other_trans, Transpose) restriction in Transpose._multiply.
         self.assertEqual(f.simplified, f)
 
     def test_add_sparse(self):
         a = evaluable.Inflate(
-            func=evaluable.Argument('a', shape=[2, 3, 2], dtype=float),
-            dofmap=evaluable.Argument('dofmap', shape=[2], dtype=int),
-            length=3)
+            func=evaluable.Argument('a', shape=tuple(map(evaluable.constant, [2, 3, 2])), dtype=float),
+            dofmap=evaluable.Argument('dofmap', shape=(evaluable.constant(2),), dtype=int),
+            length=evaluable.constant(3))
         b = evaluable.Diagonalize(
-            func=evaluable.Argument('b', shape=[2, 3], dtype=float))
-        c = evaluable.Argument('c', shape=[2, 3, 3], dtype=float)
+            func=evaluable.Argument('b', shape=tuple(map(evaluable.constant, [2, 3])), dtype=float))
+        c = evaluable.Argument('c', shape=tuple(map(evaluable.constant, [2, 3, 3])), dtype=float)
         # Since a and b are both sparse, we expect (a+b)*c to be simplified to a*c+b*c.
         self.assertIsInstance(((a + b) * c).simplified, evaluable.Add)
         # If the sparsity of the terms is equal then sparsity propagates through the addition.
         self.assertIsInstance(((a + a) * c).simplified, evaluable.Inflate)
         self.assertIsInstance(((b + b) * c).simplified, evaluable.Diagonalize)
         # If either term in the addition is dense, the original structure remains.
         self.assertIsInstance(((a + c) * c).simplified, evaluable.Multiply)
         self.assertIsInstance(((c + b) * c).simplified, evaluable.Multiply)
 
+    def test_insert_zero(self):
+        a = evaluable.Argument('test', shape=(evaluable.constant(2,),))
+        inserted = evaluable.InsertAxis(a, length=evaluable.constant(0))
+        self.assertTrue(evaluable.iszero(inserted))
+
+    def test_subtract_equals(self):
+        a = evaluable.Argument('test', shape=(evaluable.constant(2,),))
+        self.assertTrue(evaluable.iszero(a - a))
+
+    def test_equal(self):
+        r = evaluable.Range(evaluable.constant(3))
+        self.assertEqual(
+            evaluable.Equal(r, r).simplified,
+            evaluable.ones(r.shape, bool))
+        self.assertEqual(
+            evaluable.Equal(evaluable.prependaxes(r, r.shape), evaluable.appendaxes(r, r.shape)).simplified,
+            evaluable.Diagonalize(evaluable.ones(r.shape, bool)))
+
+    def test_constant_range(self):
+        self.assertEqual(
+            evaluable.constant(numpy.arange(3)).simplified,
+            evaluable.Range(evaluable.constant(3)))
+
+    def test_swap_take_inflate(self):
+        # test whether inflation to [0, 2] followed by take of [1] simplifies to zero
+        a = evaluable.Argument('test', shape=(evaluable.constant(2),))
+        inflated = evaluable.Inflate(a, dofmap=evaluable.constant([2,0]), length=evaluable.constant(3))
+        taken = evaluable.Take(inflated, indices=evaluable.constant([1]))
+        self.assertTrue(evaluable.iszero(taken))
+
 
 class memory(TestCase):
 
     def assertCollected(self, ref):
         gc.collect()
         if ref() is not None:
             self.fail('object was not garbage collected')
 
     def test_general(self):
         # NOTE: The list of numbers must be unique in the entire test suite. If
         # not, a test leaking this specific array will cause this test to fail.
-        A = evaluable.Constant([1, 2, 3, 98, 513])
+        A = evaluable.constant([1, 2, 3, 98, 513])
         A = weakref.ref(A)
         self.assertCollected(A)
 
     def test_simplified(self):
         # NOTE: The list of numbers must be unique in the entire test suite. If
         # not, a test leaking this specific array will cause this test to fail.
-        A = evaluable.Constant([1, 2, 3, 99, 514])
+        A = evaluable.constant([1, 2, 3, 99, 514])
         A.simplified  # constant simplified to itself, which should be handled as a special case to avoid circular references
         A = weakref.ref(A)
         self.assertCollected(A)
 
     def test_replace(self):
         class MyException(Exception):
             pass
 
         class A(evaluable.Array):
             def __init__(self):
-                super().__init__(args=[], shape=(), dtype=float)
+                super().__init__(args=(), shape=(), dtype=float)
 
             def _simplified(self):
                 raise MyException
-        t = evaluable.Tuple([A()])
+        t = evaluable.Tuple((A(),))
         with self.assertRaises(MyException):
             t.simplified
         with self.assertRaises(MyException):  # make sure no placeholders remain in the replacement cache
             t.simplified
 
 
 class combine_loop_concatenates(TestCase):
 
     def test_same_index(self):
         i = evaluable.loop_index('i', 3)
-        A = evaluable.LoopConcatenate((evaluable.InsertAxis(i, 1), i, i+1, 3,), i._name, i.length)
-        B = evaluable.LoopConcatenate((evaluable.InsertAxis(i, 2), i*2, i*2+2, 6,), i._name, i.length)
+        A = evaluable.LoopConcatenate((evaluable.InsertAxis(i, evaluable.constant(1)), i, i+1, evaluable.constant(3)), i._name, i.length)
+        B = evaluable.LoopConcatenate((evaluable.InsertAxis(i, evaluable.constant(2)), i*2, i*2+2, evaluable.constant(6)), i._name, i.length)
         actual = evaluable.Tuple((A, B))._combine_loop_concatenates(set())
-        L = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(i, 1), i, i+1, 3), (evaluable.InsertAxis(i, 2), i*2, i*2+2, 6)), i._name, i.length)
-        desired = evaluable.Tuple((evaluable.ArrayFromTuple(L, 0, (3,), int, **dict(zip(('_lower', '_upper'), A._intbounds))), evaluable.ArrayFromTuple(L, 1, (6,), int, **dict(zip(('_lower', '_upper'), B._intbounds)))))
+        L = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(i, evaluable.constant(1)), i, i+1, evaluable.constant(3)), (evaluable.InsertAxis(i, evaluable.constant(2)), i*2, i*2+2, evaluable.constant(6))), i._name, i.length)
+        desired = evaluable.Tuple((evaluable.ArrayFromTuple(L, 0, (evaluable.constant(3),), int, **dict(zip(('_lower', '_upper'), A._intbounds))), evaluable.ArrayFromTuple(L, 1, (evaluable.constant(6),), int, **dict(zip(('_lower', '_upper'), B._intbounds)))))
         self.assertEqual(actual, desired)
 
     def test_different_index(self):
         i = evaluable.loop_index('i', 3)
         j = evaluable.loop_index('j', 3)
-        A = evaluable.LoopConcatenate((evaluable.InsertAxis(i, 1), i, i+1, 3,), i._name, i.length)
-        B = evaluable.LoopConcatenate((evaluable.InsertAxis(j, 1), j, j+1, 3,), j._name, j.length)
+        A = evaluable.LoopConcatenate((evaluable.InsertAxis(i, evaluable.constant(1)), i, i+1, evaluable.constant(3)), i._name, i.length)
+        B = evaluable.LoopConcatenate((evaluable.InsertAxis(j, evaluable.constant(1)), j, j+1, evaluable.constant(3)), j._name, j.length)
         actual = evaluable.Tuple((A, B))._combine_loop_concatenates(set())
-        L1 = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(i, 1), i, i+1, 3),), i._name, i.length)
-        L2 = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(j, 1), j, j+1, 3),), j._name, j.length)
-        desired = evaluable.Tuple((evaluable.ArrayFromTuple(L1, 0, (3,), int, **dict(zip(('_lower', '_upper'), A._intbounds))), evaluable.ArrayFromTuple(L2, 0, (3,), int, **dict(zip(('_lower', '_upper'), B._intbounds)))))
+        L1 = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(i, evaluable.constant(1)), i, i+evaluable.constant(1), evaluable.constant(3)),), i._name, i.length)
+        L2 = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(j, evaluable.constant(1)), j, j+evaluable.constant(1), evaluable.constant(3)),), j._name, j.length)
+        desired = evaluable.Tuple((evaluable.ArrayFromTuple(L1, 0, (evaluable.constant(3),), int, **dict(zip(('_lower', '_upper'), A._intbounds))), evaluable.ArrayFromTuple(L2, 0, (evaluable.constant(3),), int, **dict(zip(('_lower', '_upper'), B._intbounds)))))
         self.assertEqual(actual, desired)
 
     def test_nested_invariant(self):
         i = evaluable.loop_index('i', 3)
-        A = evaluable.LoopConcatenate((evaluable.InsertAxis(i, 1), i, i+1, 3,), i._name, i.length)
-        B = evaluable.LoopConcatenate((A, i*3, i*3+3, 9,), i._name, i.length)
+        A = evaluable.LoopConcatenate((evaluable.InsertAxis(i, evaluable.constant(1)), i, i+1, evaluable.constant(3)), i._name, i.length)
+        B = evaluable.LoopConcatenate((A, i*3, i*3+3, evaluable.constant(9)), i._name, i.length)
         actual = evaluable.Tuple((A, B))._combine_loop_concatenates(set())
-        L1 = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(i, 1), i, i+1, 3),), i._name, i.length)
-        A_ = evaluable.ArrayFromTuple(L1, 0, (3,), int, **dict(zip(('_lower', '_upper'), A._intbounds)))
-        L2 = evaluable.LoopConcatenateCombined(((A_, i*3, i*3+3, 9),), i._name, i.length)
+        L1 = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(i, evaluable.constant(1)), i, i+1, evaluable.constant(3)),), i._name, i.length)
+        A_ = evaluable.ArrayFromTuple(L1, 0, (evaluable.constant(3),), int, **dict(zip(('_lower', '_upper'), A._intbounds)))
+        L2 = evaluable.LoopConcatenateCombined(((A_, i*3, i*3+3, evaluable.constant(9)),), i._name, i.length)
         self.assertIn(A_, L2._Evaluable__args)
-        desired = evaluable.Tuple((A_, evaluable.ArrayFromTuple(L2, 0, (9,), int, **dict(zip(('_lower', '_upper'), B._intbounds)))))
+        desired = evaluable.Tuple((A_, evaluable.ArrayFromTuple(L2, 0, (evaluable.constant(9),), int, **dict(zip(('_lower', '_upper'), B._intbounds)))))
         self.assertEqual(actual, desired)
 
     def test_nested_variant(self):
         i = evaluable.loop_index('i', 3)
         j = evaluable.loop_index('j', 3)
-        A = evaluable.LoopConcatenate((evaluable.InsertAxis(i+j, 1), i, i+1, 3,), i._name, i.length)
-        B = evaluable.LoopConcatenate((A, j*3, j*3+3, 9,), j._name, j.length)
+        A = evaluable.LoopConcatenate((evaluable.InsertAxis(i+j, evaluable.constant(1)), i, i+1, evaluable.constant(3)), i._name, i.length)
+        B = evaluable.LoopConcatenate((A, j*3, j*3+3, evaluable.constant(9)), j._name, j.length)
         actual = evaluable.Tuple((A, B))._combine_loop_concatenates(set())
-        L1 = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(i+j, 1), i, i+1, 3),), i._name, i.length)
-        A_ = evaluable.ArrayFromTuple(L1, 0, (3,), int, **dict(zip(('_lower', '_upper'), A._intbounds)))
-        L2 = evaluable.LoopConcatenateCombined(((A_, j*3, j*3+3, 9),), j._name, j.length)
+        L1 = evaluable.LoopConcatenateCombined(((evaluable.InsertAxis(i+j, evaluable.constant(1)), i, i+1, evaluable.constant(3)),), i._name, i.length)
+        A_ = evaluable.ArrayFromTuple(L1, 0, (evaluable.constant(3),), int, **dict(zip(('_lower', '_upper'), A._intbounds)))
+        L2 = evaluable.LoopConcatenateCombined(((A_, j*3, j*3+3, evaluable.constant(9)),), j._name, j.length)
         self.assertNotIn(A_, L2._Evaluable__args)
-        desired = evaluable.Tuple((A_, evaluable.ArrayFromTuple(L2, 0, (9,), int, **dict(zip(('_lower', '_upper'), B._intbounds)))))
+        desired = evaluable.Tuple((A_, evaluable.ArrayFromTuple(L2, 0, (evaluable.constant(9),), int, **dict(zip(('_lower', '_upper'), B._intbounds)))))
         self.assertEqual(actual, desired)
 
 
 class EvaluableConstant(TestCase):
 
     def test_evalf(self):
         self.assertEqual(evaluable.EvaluableConstant(1).evalf(), 1)
@@ -1099,75 +1136,75 @@
         self.assertEqual(evaluable.EvaluableConstant(Test('a very long string with\nmultiple lines'))._node_details, 'a very long strin...')
 
 
 class Einsum(TestCase):
 
     def test_swapaxes(self):
         arg = numpy.arange(6).reshape(2, 3)
-        ret = evaluable.einsum('ij->ji', evaluable.asarray(arg))
+        ret = evaluable.einsum('ij->ji', evaluable.constant(arg))
         self.assertAllEqual(ret.eval(), arg.T)
 
     def test_rollaxes(self):
         arg = numpy.arange(6).reshape(1, 2, 3)
-        ret = evaluable.einsum('Ai->iA', evaluable.asarray(arg))
+        ret = evaluable.einsum('Ai->iA', evaluable.constant(arg))
         self.assertAllEqual(ret.eval(), arg.transpose([2, 0, 1]))
 
     def test_swapgroups(self):
         arg = numpy.arange(24).reshape(1, 2, 3, 4)
-        ret = evaluable.einsum('AB->BA', evaluable.asarray(arg), B=2)
+        ret = evaluable.einsum('AB->BA', evaluable.constant(arg), B=2)
         self.assertAllEqual(ret.eval(), arg.transpose([2, 3, 0, 1]))
 
     def test_matvec(self):
         arg1 = numpy.arange(6).reshape(2, 3)
         arg2 = numpy.arange(6).reshape(3, 2)
-        ret = evaluable.einsum('ij,jk->ik', evaluable.asarray(arg1), evaluable.asarray(arg2))
+        ret = evaluable.einsum('ij,jk->ik', evaluable.constant(arg1), evaluable.constant(arg2))
         self.assertAllEqual(ret.eval(), arg1 @ arg2)
 
     def test_multidot(self):
         arg1 = numpy.arange(6).reshape(2, 3)
         arg2 = numpy.arange(9).reshape(3, 3)
         arg3 = numpy.arange(6).reshape(3, 2)
-        ret = evaluable.einsum('ij,jk,kl->il', evaluable.asarray(arg1), evaluable.asarray(arg2), evaluable.asarray(arg3))
+        ret = evaluable.einsum('ij,jk,kl->il', evaluable.constant(arg1), evaluable.constant(arg2), evaluable.constant(arg3))
         self.assertAllEqual(ret.eval(), arg1 @ arg2 @ arg3)
 
     def test_wrong_args(self):
         arg = numpy.arange(6).reshape(2, 3)
         with self.assertRaisesRegex(ValueError, 'number of arguments does not match format string'):
-            evaluable.einsum('ij,jk->ik', arg)
+            evaluable.einsum('ij,jk->ik', evaluable.constant(arg))
 
     def test_wrong_ellipse(self):
         arg = numpy.arange(6)
         with self.assertRaisesRegex(ValueError, 'argument dimensions are inconsistent with format string'):
-            evaluable.einsum('iAj->jAi', arg)
+            evaluable.einsum('iAj->jAi', evaluable.constant(arg))
 
     def test_wrong_dimension(self):
         arg = numpy.arange(9).reshape(3, 3)
         with self.assertRaisesRegex(ValueError, 'argument dimensions are inconsistent with format string'):
-            evaluable.einsum('ijk->kji', arg)
+            evaluable.einsum('ijk->kji', evaluable.constant(arg))
 
     def test_wrong_multi_ellipse(self):
         arg = numpy.arange(6)
         with self.assertRaisesRegex(ValueError, 'cannot establish length of variable groups A, B'):
-            evaluable.einsum('AB->BA', arg)
+            evaluable.einsum('AB->BA', evaluable.constant(arg))
 
     def test_wrong_indices(self):
         arg = numpy.arange(9).reshape(3, 3)
         with self.assertRaisesRegex(ValueError, 'internal repetitions are not supported'):
-            evaluable.einsum('kk->', arg)
+            evaluable.einsum('kk->', evaluable.constant(arg))
 
     def test_wrong_shapes(self):
         arg1 = numpy.arange(6).reshape(2, 3)
         arg2 = numpy.arange(6).reshape(3, 2)
         with self.assertRaisesRegex(ValueError, 'shapes do not match for axis i0'):
-            ret = evaluable.einsum('ij,ik->jk', evaluable.asarray(arg1), evaluable.asarray(arg2))
+            ret = evaluable.einsum('ij,ik->jk', evaluable.constant(arg1), evaluable.constant(arg2))
 
     def test_wrong_group_dimension(self):
         arg = numpy.arange(6)
         with self.assertRaisesRegex(ValueError, 'axis group dimensions cannot be negative'):
-            evaluable.einsum('Aij->ijA', arg, A=-1)
+            evaluable.einsum('Aij->ijA', evaluable.constant(arg), A=-1)
 
 
 @parametrize
 class AsType(TestCase):
 
     def test_bool(self):
         self.assertEqual(evaluable.astype(True, self.dtype).dtype, self.dtype)
@@ -1189,7 +1226,134 @@
             with self.assertRaises(TypeError):
                 evaluable.astype(1j, self.dtype)
 
 
 AsType(dtype=int)
 AsType(dtype=float)
 AsType(dtype=complex)
+
+
+class unalign(TestCase):
+
+    def test_single_noop(self):
+        ox = evaluable.asarray(numpy.arange(6).reshape(2,3))
+        ux, where = evaluable.unalign(ox)
+        self.assertEqual(where, (0, 1))
+        self.assertEqual(evaluable.align(ux, where, ox.shape).eval().tolist(), ox.eval().tolist())
+
+    def test_single_trans(self):
+        ox = evaluable.Transpose(evaluable.asarray(numpy.arange(6).reshape(2,3)), (1, 0))
+        ux, where = evaluable.unalign(ox)
+        self.assertEqual(where, (1, 0)) # transposed, because this is a single argument
+        self.assertEqual(evaluable.align(ux, where, ox.shape).eval().tolist(), ox.eval().tolist())
+
+    def test_single_ins(self):
+        ox = evaluable.InsertAxis(evaluable.asarray(numpy.arange(2)), evaluable.constant(3))
+        ux, where = evaluable.unalign(ox)
+        self.assertEqual(where, (0,))
+        self.assertEqual(evaluable.align(ux, where, ox.shape).eval().tolist(), ox.eval().tolist())
+
+    def test_single_ins_trans(self):
+        ox = evaluable.Transpose(evaluable.InsertAxis(evaluable.asarray(numpy.arange(3)), evaluable.constant(2)), (1, 0))
+        ux, where = evaluable.unalign(ox)
+        self.assertEqual(where, (1,))
+        self.assertEqual(evaluable.align(ux, where, ox.shape).eval().tolist(), ox.eval().tolist())
+
+    def test_single_naxes_reins(self):
+        # tests reinsertion of an uninserted axis >= naxes
+        ox = evaluable.InsertAxis(evaluable.Transpose(evaluable.InsertAxis(evaluable.asarray(numpy.arange(3)), evaluable.constant(2)), (1, 0)), evaluable.constant(4))
+        ux, where = evaluable.unalign(ox, naxes=2)
+        self.assertEqual(where, (1,))
+        self.assertEqual(evaluable.align(ux, where+(2,), ox.shape).eval().tolist(), ox.eval().tolist())
+
+    def test_single_naxes_trans(self):
+        # tests the transpose of an axis >= naxes
+        ox = evaluable.Transpose(evaluable.InsertAxis(evaluable.asarray(numpy.arange(12).reshape(4, 3)), evaluable.constant(2)), (2, 1, 0))
+        ux, where = evaluable.unalign(ox, naxes=1)
+        self.assertEqual(where, ())
+        self.assertEqual(evaluable.align(ux, where+(1, 2), ox.shape).eval().tolist(), ox.eval().tolist())
+
+    def test_single_naxes_reins_trans(self):
+        # tests the transpose of an uninserted axis >= naxes
+        ox = evaluable.Transpose(evaluable.InsertAxis(evaluable.InsertAxis(evaluable.asarray(numpy.arange(4)), evaluable.constant(2)), evaluable.constant(3)), (1, 2, 0))
+        ux, where = evaluable.unalign(ox, naxes=1)
+        self.assertEqual(where, ())
+        self.assertEqual(evaluable.align(ux, where+(1, 2), ox.shape).eval().tolist(), ox.eval().tolist())
+
+    def test_double_noins(self):
+        ox = evaluable.asarray(numpy.arange(6).reshape(2,3))
+        oy = evaluable.asarray(numpy.arange(6, 12).reshape(2,3))
+        ux, uy, where = evaluable.unalign(ox, oy)
+        self.assertEqual(where, (0, 1))
+        self.assertEqual(evaluable.align(ux, where, ox.shape).eval().tolist(), ox.eval().tolist())
+        self.assertEqual(evaluable.align(uy, where, oy.shape).eval().tolist(), oy.eval().tolist())
+
+    def test_double_disjointins(self):
+        ox = evaluable.Transpose(evaluable.InsertAxis(evaluable.asarray(numpy.arange(3)), evaluable.constant(2)), (1, 0))
+        oy = evaluable.InsertAxis(evaluable.asarray(numpy.arange(2, 4)), evaluable.constant(3))
+        ux, uy, where = evaluable.unalign(ox, oy)
+        self.assertEqual(where, (0, 1)) # not transposed, despite the transpose of the first argument
+        self.assertEqual(evaluable.align(ux, where, ox.shape).eval().tolist(), ox.eval().tolist())
+        self.assertEqual(evaluable.align(uy, where, oy.shape).eval().tolist(), oy.eval().tolist())
+
+    def test_double_commonins(self):
+        ox = evaluable.Transpose(evaluable.InsertAxis(evaluable.asarray(numpy.arange(3)), evaluable.constant(2)), (1, 0))
+        oy = evaluable.zeros((evaluable.constant(2), evaluable.constant(3)), dtype=int)
+        ux, uy, where = evaluable.unalign(ox, oy)
+        self.assertEqual(where, (1,))
+        self.assertEqual(evaluable.align(ux, where, ox.shape).eval().tolist(), ox.eval().tolist())
+        self.assertEqual(evaluable.align(uy, where, oy.shape).eval().tolist(), oy.eval().tolist())
+
+    def test_too_few_axes(self):
+        with self.assertRaises(ValueError):
+            evaluable.unalign(evaluable.zeros((evaluable.constant(2), evaluable.constant(3))), naxes=3)
+
+    def test_unequal_naxes(self):
+        with self.assertRaises(ValueError):
+            evaluable.unalign(evaluable.zeros(tuple(map(evaluable.constant, (2, 3)))), evaluable.zeros(tuple(map(evaluable.constant, (2, 3, 4)))))
+
+
+class log_error(TestCase):
+
+    class Fail(evaluable.Array):
+        def __init__(self, arg1, arg2):
+            super().__init__(args=(arg1, arg2), shape=(), dtype=int)
+        @staticmethod
+        def evalf(arg1, arg2):
+            raise RuntimeError('operation failed intentially.')
+
+    def test(self):
+        a1 = evaluable.asarray(1.)
+        a2 = evaluable.asarray([2.,3.])
+        with self.assertLogs('nutils', logging.ERROR) as cm, self.assertRaises(RuntimeError):
+            self.Fail(a1+evaluable.Sum(a2), a1).eval()
+        self.assertEqual(cm.output[0], '''ERROR:nutils:evaluation failed in step 5/5
+  %0 = EVALARGS --> dict
+  %1 = nutils.evaluable.Constant<f:> --> ndarray<f:>
+  %2 = nutils.evaluable.Constant<f:2> --> ndarray<f:2>
+  %3 = nutils.evaluable.Sum<f:> arr=%2 --> float64
+  %4 = nutils.evaluable.Add<f:> %1 %3 --> float64
+  %5 = tests.test_evaluable.Fail<i:> arg1=%4 arg2=%1 --> operation failed intentially.''')
+
+
+class Poly(TestCase):
+
+    def test_mul_variable_ncoeffs(self):
+        vars = poly.MulVar.Left, poly.MulVar.Right
+        const_coeffs_left = numpy.arange(6, dtype=float)
+        const_coeffs_right = numpy.array([1, 2], dtype=float)
+        eval_ncoeffs_left = evaluable.InRange(evaluable.Argument('ncoeffs_left', (), int), evaluable.constant(10))
+        eval_coeffs_left = evaluable.IntToFloat(evaluable.Range(eval_ncoeffs_left))
+        eval_coeffs_right = evaluable.asarray(const_coeffs_right)
+        numpy.testing.assert_allclose(
+            evaluable.PolyMul(eval_coeffs_left, eval_coeffs_right, vars).eval(ncoeffs_left=numpy.array(6)),
+            poly.mul(const_coeffs_left, const_coeffs_right, vars),
+        )
+
+    def test_grad_variable_ncoeffs(self):
+        const_coeffs = numpy.arange(6, dtype=float)
+        eval_ncoeffs = evaluable.InRange(evaluable.Argument('ncoeffs', (), int), evaluable.constant(10))
+        eval_coeffs = evaluable.IntToFloat(evaluable.Range(eval_ncoeffs))
+        numpy.testing.assert_allclose(
+            evaluable.PolyGrad(eval_coeffs, 2).eval(ncoeffs=numpy.array(6)),
+            poly.grad(const_coeffs, 2),
+        )
```

### Comparing `nutils-7.3/tests/test_export.py` & `nutils-8.0/tests/test_export.py`

 * *Files 26% similar despite different names*

```diff
@@ -24,14 +24,51 @@
                     ax = fig.add_subplot(111)
                     ax.plot([1, 2, 3], [1, 2, 3])
                 with (self.outdir/'test.{}'.format(imagetype)).open('rb') as f:
                     test(f.read())
 
 
 @testing.parametrize
+class triplot(testing.TestCase):
+
+    def setUp(self):
+        super().setUp()
+        self.outdir = pathlib.Path(self.enter_context(tempfile.TemporaryDirectory()))
+        self.enter_context(treelog.set(treelog.DataLog(str(self.outdir))))
+        self.coords = numpy.zeros([self.ndims + 1, self.ndims])
+        self.coords[1:] = numpy.eye(self.ndims)
+        self.tri = numpy.arange(self.ndims + 1)[numpy.newaxis]
+        self.hull = numpy.array([self.tri[0,~m] for m in numpy.eye(self.ndims+1, dtype=bool)])
+        if self.ndims == 3:
+            self.tri = self.hull
+            self.hull = numpy.array([[i,j] for i in range(4) for j in range(i)])
+        self.values = numpy.arange(self.ndims+1, dtype=float) * self.ndims
+
+    @testing.requires('matplotlib', 'PIL')
+    def test_filename(self):
+        export.triplot('test.jpg', self.coords, self.values, tri=self.tri, hull=self.hull)
+
+    @testing.requires('matplotlib', 'PIL')
+    def test_axesobj(self):
+        with export.mplfigure('test.jpg') as fig:
+            ax = fig.add_subplot(111, projection='3d' if self.ndims == 3 else None)
+            im = export.triplot(ax, self.coords, self.values, tri=self.tri, hull=self.hull)
+            if self.ndims == 1:
+                self.assertEqual(im, None)
+            elif self.ndims == 2:
+                self.assertAllEqual(im.get_array(), self.values)
+            elif self.ndims == 3:
+                self.assertAllEqual(im.get_array(), self.values[self.tri].mean(1))
+
+triplot(ndims=1)
+triplot(ndims=2)
+triplot(ndims=3)
+
+
+@testing.parametrize
 class vtk(testing.TestCase):
 
     def setUp(self):
         super().setUp()
         if self.ndims == 1:
             self.x = numpy.array([[0, ], [1, ], [2, ], [3, ]], dtype=self.xtype)
             self.tri = numpy.array([[0, 1], [1, 2], [2, 3]])
```

### Comparing `nutils-7.3/tests/test_expression_v1.py` & `nutils-8.0/tests/test_expression_v1.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,11 @@
+from nutils import evaluable, expression_v1, function, mesh, warnings
+from nutils.testing import TestCase
 import pickle
-from nutils import evaluable, expression_v1, function, mesh
-from nutils.testing import *
+import numpy
 
 _ = lambda arg: (None, arg)
 
 
 class Array:
     def __init__(self, text, shape):
         self.text = text
@@ -1070,15 +1071,15 @@
         self.assertEqualLowered(ns.foo, function.zeros([2, 3]))
         self.assertEqual(ns.default_geometry_name, 'y')
 
     def test_pickle(self):
         orig = expression_v1.Namespace()
         domain, geom = mesh.unitsquare(2, 'square')
         orig.x = geom
-        orig.v = function.stack([1, geom[0], geom[0]**2], 0)
+        orig.v = numpy.stack([1, geom[0], geom[0]**2], 0)
         orig.u = 'v_n ?lhs_n'
         orig.f = 'cosh(x_0)'
         pickled = pickle.loads(pickle.dumps(orig))
         for attr in ('x', 'v', 'u', 'f'):
             self.assertEqualLowered(getattr(pickled, attr), getattr(orig, attr), topo=domain)
         self.assertEqual(pickled.arg_shapes['lhs'], orig.arg_shapes['lhs'])
 
@@ -1139,16 +1140,16 @@
         self.assertEqual(l(ns.eval_('mul(b_i, A_ij, a_j)')), l(ns.eval_('b_i A_ij a_j')))
 
     def test_builtin_functions(self):
         ns = expression_v1.Namespace()
         ns.a = numpy.array([1, 2, 3])
         ns.A = numpy.array([[6, 7, 8], [9, 10, 11]])
         l = lambda f: f.as_evaluable_array.simplified
-        self.assertEqual(l(ns.eval_('norm2(a)')), l(function.norm2(ns.a)))
-        self.assertEqual(l(ns.eval_i('sum:j(A_ij)')), l(function.sum(ns.A, 1)))
+        self.assertEqual(l(ns.eval_('norm2(a)')), l(numpy.linalg.norm(ns.a)))
+        self.assertEqual(l(ns.eval_i('sum:j(A_ij)')), l(numpy.sum(ns.A, 1)))
 
     def test_builtin_jacobian_vector(self):
         ns = expression_v1.Namespace()
         domain, ns.x = mesh.rectilinear([1]*2)
         l = lambda f: evaluable.asarray(domain.sample('gauss', 2)(f)).simplified
         self.assertEqual(l(ns.eval_('J(x)')), l(function.jacobian(ns.x)))
 
@@ -1172,15 +1173,15 @@
 class eval_ast(TestCase):
 
     def setUp(self):
         super().setUp()
         self.domain, x = mesh.rectilinear([2, 2])
         self.ns = expression_v1.Namespace()
         self.ns.x = x
-        self.ns.altgeom = function.concatenate([self.ns.x, [0]], 0)
+        self.ns.altgeom = numpy.concatenate([self.ns.x, [0]], 0)
         self.ns.basis = self.domain.basis('spline', degree=2)
         self.ns.a = 2
         self.ns.a2 = numpy.array([1, 2.])
         self.ns.a3 = numpy.array([1, 2, 3])
         self.ns.a22 = numpy.array([[1, 2], [3, 4]])
         self.ns.a32 = numpy.array([[1, 2], [3, 4], [5, 6]])
         self.x = function.Argument('x', ())
@@ -1193,30 +1194,30 @@
         if indices:
             evaluated = getattr(self.ns, 'eval_'+indices)(s)
         else:
             evaluated = s @ self.ns
         self.assertEqual(lower(evaluated), lower(f))
 
     def test_group(self): self.assertEqualLowered('(a)', self.ns.a)
-    def test_arg(self): self.assertEqualLowered('a2_i ?x_i', function.dot(self.ns.a2, function.Argument('x', [2]), axes=[0]))
+    def test_arg(self): self.assertEqualLowered('a2_i ?x_i', numpy.matmul(self.ns.a2, function.Argument('x', [2])))
     def test_substitute(self): self.assertEqualLowered('(?x_i^2)(x_i=a2_i)', self.ns.a2**2)
     def test_multisubstitute(self): self.assertEqualLowered('(a2_i + ?x_i + ?y_i)(x_i=?y_i, y_i=?x_i)', self.ns.a2 + function.Argument('y', [2]) + function.Argument('x', [2]))
-    def test_call(self): self.assertEqualLowered('sin(a)', function.sin(self.ns.a))
-    def test_call2(self): self.assertEqualLowered('arctan2(a2_i, a3_j)', function.arctan2(self.ns.a2[:, None], self.ns.a3[None, :]), indices='ij')
-    def test_eye(self): self.assertEqualLowered('δ_ij a2_i', function.dot(function.eye(2), self.ns.a2, axes=[0]))
+    def test_call(self): self.assertEqualLowered('sin(a)', numpy.sin(self.ns.a))
+    def test_call2(self): self.assertEqualLowered('arctan2(a2_i, a3_j)', numpy.arctan2(self.ns.a2[:, None], self.ns.a3[None, :]), indices='ij')
+    def test_eye(self): self.assertEqualLowered('δ_ij a2_i', numpy.matmul(function.eye(2), self.ns.a2))
     def test_normal(self): self.assertEqualLowered('n_i', self.ns.x.normal(), topo=self.domain.boundary)
     def test_getitem(self): self.assertEqualLowered('a2_0', self.ns.a2[0])
-    def test_trace(self): self.assertEqualLowered('a22_ii', function.trace(self.ns.a22, 0, 1))
-    def test_sum(self): self.assertEqualLowered('a2_i a2_i', function.sum(self.ns.a2 * self.ns.a2, axis=0))
-    def test_concatenate(self): self.assertEqualLowered('<a, a>_i', function.concatenate([self.ns.a[None], self.ns.a[None]], axis=0))
+    def test_trace(self): self.assertEqualLowered('a22_ii', numpy.trace(self.ns.a22, axis1=0, axis2=1))
+    def test_sum(self): self.assertEqualLowered('a2_i a2_i', numpy.sum(self.ns.a2 * self.ns.a2, axis=0))
+    def test_concatenate(self): self.assertEqualLowered('<a, a>_i', numpy.concatenate([self.ns.a[None], self.ns.a[None]], axis=0))
     def test_grad(self): self.assertEqualLowered('basis_n,0', self.ns.basis.grad(self.ns.x)[:, 0])
     def test_surfgrad(self): self.assertEqualLowered('surfgrad(basis_0, altgeom_i)', function.grad(self.ns.basis[0], self.ns.altgeom, len(self.ns.altgeom)-1))
-    def test_derivative(self): self.assertEqualLowered('d(exp(?x), ?x)', function.derivative(function.exp(self.x), self.x))
+    def test_derivative(self): self.assertEqualLowered('d(exp(?x), ?x)', function.derivative(numpy.exp(self.x), self.x))
     def test_append_axis(self): self.assertEqualLowered('a a2_i', self.ns.a[None]*self.ns.a2)
-    def test_transpose(self): self.assertEqualLowered('a22_ij a22_ji', function.dot(self.ns.a22, self.ns.a22.T, axes=[0, 1]))
+    def test_transpose(self): self.assertEqualLowered('a22_ij a22_ji', numpy.sum(self.ns.a22 * self.ns.a22.T, [0,1]))
     def test_jump(self): self.assertEqualLowered('[a]', function.jump(self.ns.a))
     def test_mean(self): self.assertEqualLowered('{a}', function.mean(self.ns.a))
     def test_neg(self): self.assertEqualLowered('-a', -self.ns.a)
     def test_add(self): self.assertEqualLowered('a + ?x', self.ns.a + self.x)
     def test_sub(self): self.assertEqualLowered('a - ?x', self.ns.a - self.x)
     def test_mul(self): self.assertEqualLowered('a ?x', self.ns.a * self.x)
     def test_truediv(self): self.assertEqualLowered('a / ?x', self.ns.a / self.x)
@@ -1233,10 +1234,10 @@
 
     def test_surfgrad_deprecated(self):
         with self.assertWarns(warnings.NutilsDeprecationWarning):
             self.assertEqualLowered('basis_n;altgeom_0', function.grad(self.ns.basis, self.ns.altgeom, len(self.ns.altgeom)-1)[:, 0])
 
     def test_derivative_deprecated(self):
         with self.assertWarns(warnings.NutilsDeprecationWarning):
-            self.assertEqualLowered('exp(?x)_,?x', function.derivative(function.exp(self.x), self.x))
+            self.assertEqualLowered('exp(?x)_,?x', function.derivative(numpy.exp(self.x), self.x))
 
 # vim:shiftwidth=2:softtabstop=2:expandtab:foldmethod=indent:foldnestmax=2
```

### Comparing `nutils-7.3/tests/test_expression_v2.py` & `nutils-8.0/tests/test_expression_v2.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import functools
 import numpy
 import operator
 from nutils.testing import TestCase
-from nutils import expression_v2, function, mesh, sample
+from nutils import expression_v2, function, mesh, sample, SI
 
 
 class SerializedOps:
 
     def from_int(self, v): return '{}i'.format(v)
     def from_float(self, v): return '{}f'.format(v)
     def scope(self, array): return 'scope({})'.format(array)
@@ -494,15 +494,15 @@
         ns = expression_v2.Namespace()
         ns.f = lambda a: a**2
         self.assertAlmostEqual(('f(2)' @ ns).eval(), 4)
 
     def test_set_function_unexpected_indices(self):
         ns = expression_v2.Namespace()
         with self.assertRaisesRegex(AttributeError, '^Cannot assign a function to an attribute with an underscore.'):
-            ns.f_i = lambda a: function.stack([a, a], axis=-1)
+            ns.f_i = lambda a: numpy.stack([a, a], axis=-1)
 
     def test_set_other(self):
         ns = expression_v2.Namespace()
         with self.assertRaisesRegex(AttributeError, '^Cannot assign an object of type'):
             ns.a = object()
 
     def test_eval(self):
@@ -512,20 +512,20 @@
         self.assertEqual(('1' @ ns).eval().tolist(), 1)
         self.assertEqual(('a_i' @ ns).eval().tolist(), [1, 2])
         self.assertEqual(('a_i b_j' @ ns).eval().export('dense').tolist(), [[1, 2, 3], [2, 4, 6]])
         self.assertEqual(('b_j a_i' @ ns).eval().export('dense').tolist(), [[1, 2, 3], [2, 4, 6]])
 
     def test_eval_tuple_list(self):
         ns = expression_v2.Namespace()
-        self.assertEqual(sample.eval_integrals(*(('1', '2', '3') @ ns)), (1, 2, 3))
-        self.assertEqual(sample.eval_integrals(*(['1', '2', '3'] @ ns)), (1, 2, 3))
+        self.assertEqual(function.eval(('1', '2', '3') @ ns), (1, 2, 3))
+        self.assertEqual(function.eval(['1', '2', '3'] @ ns), (1, 2, 3))
 
     def test_define_for_0d(self):
         ns = expression_v2.Namespace()
-        topo, ns.t = mesh.line(numpy.linspace(0, 1, 3), bnames=['past', 'future'])
+        topo, ns.t = mesh.line(numpy.linspace(0, 1, 3), bnames=('past', 'future'))
         ns.define_for('t', gradient='∂t', normal='nt', jacobians=['dt', 'dtb'])
         ns.basis = topo.basis('spline', degree=1)
         self.assertAlmostEqual(topo.integral('dt' @ ns, degree=2).eval(), 1)
         self.assertAlmostEqual(topo.integral('∂t(t^2) dt' @ ns, degree=2).eval(), 1)
         self.assertAlmostEqual(topo.boundary['future'].integral('nt dtb' @ ns, degree=2).eval(), 1)
         self.assertAlmostEqual(topo.boundary['past'].integral('nt dtb' @ ns, degree=2).eval(), -1)
         with self.assertRaisesRegex(ValueError, 'The curl can only be defined for a geometry with shape'):
@@ -553,42 +553,51 @@
         smpl = topo.sample('gauss', 5)
         assertEvalAlmostEqual = lambda *args: self.assertAllAlmostEqual(*(smpl(f).as_evaluable_array.simplified.eval() for f in args))
         assertEvalAlmostEqual('curl_ij(y δ_j0 - x δ_j1 + z δ_j2)' @ ns, '-2 δ_i2' @ ns)
         assertEvalAlmostEqual('curl_ij(-x^2 δ_j1)' @ ns, '-2 x δ_i2' @ ns)
         assertEvalAlmostEqual('curl_ij((x δ_j0 - z δ_j1 + y δ_j2) δ_k0 + x z δ_j1 δ_k1)' @ ns, '2 δ_i0 δ_k0 - x δ_i0 δ_k1 + z δ_i2 δ_k1' @ ns)
         assertEvalAlmostEqual('curl_ij(∇_j(x y + z))' @ ns, function.zeros((3,)))
 
+    def test_add_single_field(self):
+        ns = expression_v2.Namespace()
+        ns.add_field('u', numpy.array([1,2,3]))
+        self.assertEquals(ns.u.argshapes, dict(u=(3,)))
+        self.assertEquals(ns.u.shape, ())
+
+    def test_add_multiple_fields(self):
+        ns = expression_v2.Namespace()
+        ns.add_field(('u', 'v'), numpy.array([1,2,3]))
+        self.assertEquals(ns.u.argshapes, dict(u=(3,)))
+        self.assertEquals(ns.u.shape, ())
+        self.assertEquals(ns.v.argshapes, dict(v=(3,)))
+        self.assertEquals(ns.v.shape, ())
+
+    def test_add_single_field_multiple_bases(self):
+        ns = expression_v2.Namespace()
+        ns.add_field('u', numpy.array([1,2,3]), numpy.array([4,5,6,7]))
+        self.assertEquals(ns.u.argshapes, dict(u=(3,4)))
+        self.assertEquals(ns.u.shape, ())
+
+    def test_add_single_field_with_shape(self):
+        ns = expression_v2.Namespace()
+        ns.add_field('u', numpy.array([1,2,3]), shape=(2,))
+        self.assertEquals(ns.u.argshapes, dict(u=(3,2)))
+        self.assertEquals(ns.u.shape, (2,))
+
     def test_copy(self):
         ns1 = expression_v2.Namespace()
         ns1.a = 1
         ns2 = ns1.copy_()
         self.assertAlmostEqual(ns2.a.eval(), 1)
 
     def test_copy_replace_array(self):
         ns1 = expression_v2.Namespace()
         ns1.a = function.Argument('x', ())
         ns2 = ns1.copy_(x=1.)
         self.assertAlmostEqual(ns2.a.eval(), 1)
 
-    def test_copy_replace_arraylike(self):
-        class ArrayLike(numpy.lib.mixins.NDArrayOperatorsMixin):
-            '''minimal wrapper class that mimics nutils.SI.Quantity'''
-            def __init__(self, value):
-                self.wrapped = value
-            def __array_ufunc__(self, ufunc, method, *inputs, out=None, **kwargs):
-                if method == '__call__' and ufunc == numpy.divide:
-                    assert all(isinstance(a, ArrayLike) for a in inputs)
-                    return inputs[0].wrapped / inputs[1].wrapped
-                elif method == '__call__' and ufunc == numpy.multiply:
-                    assert isinstance(inputs[1], ArrayLike)
-                    return ArrayLike(inputs[0] * inputs[1].wrapped)
-                else:
-                    return NotImplemented
-            def __array_function__(self, *args):
-                return NotImplemented
-        ArrayLike.reference_quantity = ArrayLike(1.)
-
+    def test_copy_replace_SI_array(self):
         ns1 = expression_v2.Namespace()
-        ns1.a = ArrayLike(function.Argument('x', ()))
+        ns1.a = function.Argument('x', ()) * SI.Length('1m')
         ns2 = ns1.copy_(x=1.)
-        self.assertIsInstance(ns2.a, ArrayLike)
-        self.assertAlmostEqual(ns2.a.wrapped.eval(), 1)
+        self.assertIsInstance(ns2.a, SI.Length)
+        self.assertAlmostEqual((ns2.a / 'm').eval(), 1)
```

### Comparing `nutils-7.3/tests/test_finitecell.py` & `nutils-8.0/tests/test_finitecell.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,11 @@
-from nutils import *
-from nutils.testing import *
+from nutils import topology, mesh, function, evaluable
+from nutils.testing import TestCase, parametrize
 import treelog as log
+import numpy
 
 
 class hierarchical(TestCase):
 
     def setUp(self):
         super().setUp()
         self.ref0, self.geom = mesh.rectilinear([[0, 1, 2]])
@@ -69,19 +70,19 @@
 
     @parametrize.enable_if(lambda gridline, **params: gridline)
     def test_trimmed_boundary(self):
         trimmed = self.domain2.boundary['trimmed']
         gauss1 = trimmed.sample('gauss', 1)
         leftbasis = self.domain0[:1].basis('std', degree=1)
         self.assertTrue(numpy.any(gauss1.eval(leftbasis)))
-        with self.assertRaises(evaluable.EvaluationError):
+        with self.assertRaises(ValueError):
             gauss1.eval(function.opposite(leftbasis))
         rightbasis = self.domain0[1:].basis('std', degree=1)
         self.assertTrue(numpy.any(gauss1.eval(function.opposite(rightbasis))))
-        with self.assertRaises(evaluable.EvaluationError):
+        with self.assertRaises(ValueError):
             gauss1.eval(rightbasis)
 
 
 for boundary in True, False:
     for gridline in True, False:
         trimmedboundary(boundary=boundary, gridline=gridline)
 
@@ -234,15 +235,15 @@
         totalsurface = self.pos.boundary.volume(self.geom)
         totalerr = abs(totalsurface - self.exact_totalsurface) / self.exact_totalsurface
         log.user('total surface error:', totalerr)
         self.assertLess(trimerr, self.errtol, 'trim surface tolerance not met')
         self.assertLess(totalerr, self.errtol, 'total surface tolerance not met')
 
     def test_locate(self):
-        curvegeom = self.geom * (1 + .1 * function.sin(function.norm2(self.geom)*numpy.pi/self.radius))  # interface preserving non-polynomial scaling
+        curvegeom = self.geom * (1 + .1 * numpy.sin(numpy.linalg.norm(self.geom)*numpy.pi/self.radius))  # interface preserving non-polynomial scaling
         for p in numpy.linspace(.001, .999, 20):
             with self.subTest(p=p):
                 point = p * .5**numpy.arange(self.domain.ndims)
                 r = numpy.linalg.norm(point)
                 try:
                     sample = self.pos.locate(curvegeom, [point], tol=1e-12)
                 except topology.LocateError:
@@ -255,15 +256,23 @@
 
 cutdomain('sphere', ndims=3, nelems=2, maxrefine=3, errtol=6e-3)
 cutdomain('circle', ndims=2, nelems=2, maxrefine=5, errtol=2.1e-4)
 
 
 class multitrim(TestCase):
 
-    def test(self):
+    def test_1d(self):
+        domain, geom = mesh.rectilinear([3])
+        trimmed = domain.trim(geom-1.2, maxrefine=0).trim(1.8-geom, maxrefine=0)
+        self.assertEqual(len(trimmed), 1) # trimmed consists of a single line mosaic with two new edges
+        trimmed.check_boundary(geom, elemwise=True, print=self.fail)
+        L = trimmed.integrate(function.J(geom), ischeme='gauss1')
+        numpy.testing.assert_almost_equal(L, .6, decimal=3)
+
+    def test_2d(self):
         domain, geom = mesh.rectilinear([[-1, 1], [-1, 1]])
         geom_rel = (function.rotmat(numpy.pi/6) * geom).sum(-1)
         for itrim in range(4):
             domain = domain.trim(.7+(1-itrim % 2*2)*geom_rel[itrim//2], maxrefine=1, name='trim{}'.format(itrim), ndivisions=16)
         domain.check_boundary(geom, elemwise=True, print=self.fail)
         for itrim in range(4):
             L = domain.boundary['trim{}'.format(itrim)].integrate(function.J(geom), ischeme='gauss1')
@@ -375,18 +384,18 @@
         self.topoB = self.topo - self.topoA
 
     def test_topos(self):
         self.assertEqual(len(self.topoA), 4)
         self.assertEqual(len(self.topoB), 2)
 
     def test_boundaries(self):
-        self.assertEqual(len(self.topoA.boundary), 11)
-        self.assertEqual(len(self.topoB.boundary), 8)
-        self.assertEqual(len(self.topoA.boundary['trimmed']), 5)
-        self.assertEqual(len(self.topoB.boundary['trimmed']), 5)
+        self.assertEqual(len(self.topoA.boundary), 9)
+        self.assertEqual(len(self.topoB.boundary), 6)
+        self.assertEqual(len(self.topoA.boundary['trimmed']), 3)
+        self.assertEqual(len(self.topoB.boundary['trimmed']), 3)
 
     def test_interfaces(self):
         self.assertEqual(len(self.topoA.interfaces), 4)
         self.assertEqual(len(self.topoB.interfaces), 1)
 
     def test_transforms(self):
         self.assertEqual(set(self.topoA.boundary['trimmed'].transforms), set(self.topoB.boundary['trimmed'].opposites))
```

### Comparing `nutils-7.3/tests/test_function.py` & `nutils-8.0/tests/test_function.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,31 +1,35 @@
+from nutils import evaluable, function, mesh, numeric, types, points, transformseq, transform, element, warnings
+from nutils.testing import TestCase, parametrize
+import nutils_poly as poly
 import numpy
 import itertools
-import pickle
 import warnings as _builtin_warnings
-import operator
-from nutils import evaluable, function, mesh, numeric, types, points, transformseq, transform, element
-from nutils.testing import *
-_ = numpy.newaxis
+import functools
+import fractions
 
 
 class Array(TestCase):
 
     def test_cast_ndim_mismatch(self):
         with self.assertRaises(ValueError):
             function.Array.cast([1, 2], ndim=2)
 
     def test_cast_dtype_mismatch(self):
         with self.assertRaises(ValueError):
             function.Array.cast([1.2, 2.3], dtype=int)
 
     def test_cast_invalid_argument(self):
-        with self.assertRaises(ValueError):
+        with self.assertRaisesRegex(ValueError, "cannot convert '132' to Array: unsupported data type"):
             function.Array.cast('132')
 
+    def test_cast_different_shapes(self):
+        with self.assertRaisesRegex(ValueError, 'cannot convert \[\[1, 2, 3\], \[4, 5\]\] to Array: all input arrays must have the same shape'):
+            function.Array.cast([[1,2,3],[4,5]])
+
     def test_ndim(self):
         self.assertEqual(function.Argument('a', (2, 3)).ndim, 2)
 
     def test_size_known(self):
         self.assertEqual(function.Argument('a', (2, 3)).size, 6)
 
     def test_size_0d(self):
@@ -57,29 +61,38 @@
 
     def test_deprecated_simplified(self):
         with self.assertWarns(warnings.NutilsDeprecationWarning):
             function.Array.cast([1, 2]).simplified
 
     def test_different_argument_shapes(self):
         with self.assertRaisesRegex(ValueError, "Argument 'a' has two different shapes"):
-            function.Argument('a', (2,)).sum() + function.Argument('a', (3, 4)).sum()
+            function.Argument('a', (2,)).sum() + function.Argument('a', (3, 4)).sum(-1)
 
     def test_different_argument_dtypes(self):
         with self.assertRaisesRegex(ValueError, "Argument 'a' has two different dtypes"):
             function.Argument('a', (), dtype=float) + function.Argument('a', (), dtype=int)
 
     def test_index(self):
         self.assertEqual(function.Array.cast(2).__index__(), 2)
         with self.assertRaisesRegex(ValueError, "cannot convert non-constant array to index: arguments=foo"):
             function.Argument('foo', shape=(), dtype=int).__index__()
         with self.assertRaisesRegex(ValueError, "cannot convert non-scalar array to index: shape=\(2,\)"):
             function.Array.cast([2, 3]).__index__()
         with self.assertRaisesRegex(ValueError, "cannot convert non-integer array to index: dtype=float"):
             function.Array.cast(2.5).__index__()
 
+    def test_truthiness(self):
+        topo, geom = mesh.unitsquare(4, 'square')
+        with self.assertRaisesRegex(ValueError, 'The truth value of a nutils Array is ambiguous'):
+            min(geom, 1)
+
+    def test_fraction(self):
+        v = function.Array.cast(fractions.Fraction(1, 2))
+        self.assertEqual(v.eval(), .5)
+
 
 class integral_compatibility(TestCase):
 
     def test_eval(self):
         v = numpy.array([1, 2])
         a = function.Argument('a', (2,), dtype=float)
         self.assertAllAlmostEqual(a.eval(a=v), v)
@@ -199,211 +212,226 @@
 
 
 _check('asarray', function.asarray, lambda a: a, ANY(2, 4, 2))
 _check('zeros', lambda: function.zeros([1, 4, 3, 4]), lambda: numpy.zeros([1, 4, 3, 4]))
 _check('ones', lambda: function.ones([1, 4, 3, 4]), lambda: numpy.ones([1, 4, 3, 4]))
 _check('eye', lambda: function.eye(3), lambda: numpy.eye(3))
 
-_check('add', function.add, numpy.add, ANY(4), ANY(4))
-_check('add-complex', function.add, numpy.add, ANY(4), ANC(4))
+_check('add', lambda a, b: numpy.add(a, function.Array.cast(b)), numpy.add, ANY(4), ANY(4))
+_check('add-complex', lambda a, b: numpy.add(a, function.Array.cast(b)), numpy.add, ANY(4), ANC(4))
 _check('Array_add', lambda a, b: function.Array.cast(a) + b, numpy.add, ANY(4, 4), ANY(4))
 _check('Array_radd', lambda a, b: a + function.Array.cast(b), numpy.add, ANY(4, 4), ANY(4))
-_check('subtract', function.subtract, numpy.subtract, ANY(4, 4), ANY(4))
-_check('subtract-complex', function.subtract, numpy.subtract, ANY(4, 4), ANC(4))
+_check('subtract', lambda a, b: numpy.subtract(a, function.Array.cast(b)), numpy.subtract, ANY(4, 4), ANY(4))
+_check('subtract-complex', lambda a, b: numpy.subtract(a, function.Array.cast(b)), numpy.subtract, ANY(4, 4), ANC(4))
 _check('Array_sub', lambda a, b: function.Array.cast(a) - b, numpy.subtract, ANY(4, 4), ANY(4))
 _check('Array_rsub', lambda a, b: a - function.Array.cast(b), numpy.subtract, ANY(4, 4), ANY(4))
-_check('negative', function.negative, numpy.negative, ANY(4))
-_check('negative-complex', function.negative, numpy.negative, ANC(4))
-_check('positive', function.positive, numpy.positive, ANY(4))
-_check('positive-complex', function.positive, numpy.positive, ANC(4))
+_check('negative', lambda a: numpy.negative(function.Array.cast(a)), numpy.negative, ANY(4))
+_check('negative-complex', lambda a: numpy.negative(function.Array.cast(a)), numpy.negative, ANC(4))
+_check('positive', lambda a: numpy.positive(function.Array.cast(a)), numpy.positive, ANY(4))
+_check('positive-complex', lambda a: numpy.positive(function.Array.cast(a)), numpy.positive, ANC(4))
 _check('Array_neg', lambda a: -function.Array.cast(a), numpy.negative, ANY(4))
 _check('Array_pos', lambda a: +function.Array.cast(a), lambda a: a, ANY(4))
-_check('multiply', function.multiply, numpy.multiply, ANY(4, 4), ANY(4))
-_check('multiply-complex', function.multiply, numpy.multiply, ANC(4, 4), 1-1j+ANC(4))
+_check('multiply', lambda a, b: numpy.multiply(a, function.Array.cast(b)), numpy.multiply, ANY(4, 4), ANY(4))
+_check('multiply-complex', lambda a, b: numpy.multiply(a, function.Array.cast(b)), numpy.multiply, ANC(4, 4), 1-1j+ANC(4))
 _check('Array_mul', lambda a, b: function.Array.cast(a) * b, numpy.multiply, ANY(4, 4), ANY(4))
 _check('Array_rmul', lambda a, b: a * function.Array.cast(b), numpy.multiply, ANY(4, 4), ANY(4))
-_check('divide', function.divide, numpy.divide, ANY(4), POS(4))
-_check('divide-complex', function.divide, numpy.divide, ANC(4, 4), NZC(4, 4).T)
+_check('divide', lambda a, b: numpy.divide(a, function.Array.cast(b)), numpy.divide, ANY(4), POS(4))
+_check('divide-complex', lambda a, b: numpy.divide(a, function.Array.cast(b)), numpy.divide, ANC(4, 4), NZC(4, 4).T)
 _check('Array_truediv', lambda a, b: function.Array.cast(a) / b, numpy.divide, ANY(4), POS(4))
 _check('Array_rtruediv', lambda a, b: a / function.Array.cast(b), numpy.divide, ANY(4), POS(4))
-_check('floor_divide', function.floor_divide, numpy.floor_divide, INT(4, 4), 1+NNI(4))
+_check('floor_divide', lambda a, b: numpy.floor_divide(a, function.Array.cast(b)), numpy.floor_divide, INT(4, 4), 1+NNI(4))
 _check('Array_floordiv', lambda a, b: function.Array.cast(a) // b, numpy.floor_divide, INT(4, 4), 1+NNI(4))
 _check('Array_rfloordiv', lambda a, b: a // function.Array.cast(b), numpy.floor_divide, INT(4, 4), 1+NNI(4))
-_check('reciprocal', function.reciprocal, numpy.reciprocal, NZ(4))
-_check('reciprocal-complex', function.reciprocal, numpy.reciprocal, NZC(4))
-_check('power', function.power, numpy.power, POS(4, 4), ANY(4, 4))
-_check('power-complex', function.power, numpy.power, NZC(4, 4), ANY(4, 4))
+_check('reciprocal', lambda a: numpy.reciprocal(function.Array.cast(a)), numpy.reciprocal, NZ(4))
+_check('reciprocal-complex', lambda a: numpy.reciprocal(function.Array.cast(a)), numpy.reciprocal, NZC(4))
+_check('power', lambda a, b: numpy.power(a, function.Array.cast(b)), numpy.power, POS(4, 4), ANY(4, 4))
+_check('power-complex', lambda a, b: numpy.power(a, function.Array.cast(b)), numpy.power, NZC(4, 4), ANY(4, 4))
 _check('Array_pow', lambda a, b: function.Array.cast(a) ** b, numpy.power, POS(4, 4), ANY(4, 4))
 _check('Array_rpow', lambda a, b: a ** function.Array.cast(b), numpy.power, POS(4, 4), ANY(4, 4))
-_check('sqrt', function.sqrt, numpy.sqrt, NN(4))
-_check('sqrt-complex', function.sqrt, numpy.sqrt, ANC(4))
-_check('abs', function.abs, numpy.abs, ANY(4))
-_check('abs-complex', function.abs, numpy.abs, ANC(4))
+_check('sqrt', lambda a: numpy.sqrt(function.Array.cast(a)), numpy.sqrt, NN(4))
+_check('sqrt-complex', lambda a: numpy.sqrt(function.Array.cast(a)), numpy.sqrt, ANC(4))
+_check('abs', lambda a: numpy.abs(function.Array.cast(a)), numpy.abs, ANY(4))
+_check('abs-complex', lambda a: numpy.abs(function.Array.cast(a)), numpy.abs, ANC(4))
 _check('Array_abs', lambda a: abs(function.Array.cast(a)), numpy.abs, ANY(4))
-_check('sign', function.sign, numpy.sign, ANY(4))
-_check('mod', function.mod, numpy.mod, INT(4, 4), 1+NNI(4))
+_check('sign', lambda a: numpy.sign(function.Array.cast(a)), numpy.sign, ANY(4))
+_check('mod', lambda a, b: numpy.mod(a, function.Array.cast(b)), numpy.mod, INT(4, 4), 1+NNI(4))
 _check('Array_mod', lambda a, b: function.Array.cast(a) % b, numpy.mod, INT(4, 4), 1+NNI(4))
 _check('Array_rmod', lambda a, b: a % function.Array.cast(b), numpy.mod, INT(4, 4), 1+NNI(4))
-_check('divmod_div', lambda a, b: function.divmod(a, b)[0], lambda a, b: numpy.divmod(a, b)[0], INT(4, 4), 1+NNI(4))
-_check('divmod_mod', lambda a, b: function.divmod(a, b)[1], lambda a, b: numpy.divmod(a, b)[1], INT(4, 4), 1+NNI(4))
+_check('divmod_div', lambda a, b: numpy.divmod(a, function.Array.cast(b))[0], lambda a, b: numpy.divmod(a, b)[0], INT(4, 4), 1+NNI(4))
+_check('divmod_mod', lambda a, b: numpy.divmod(a, function.Array.cast(b))[1], lambda a, b: numpy.divmod(a, b)[1], INT(4, 4), 1+NNI(4))
 _check('Array_divmod_div', lambda a, b: divmod(function.Array.cast(a), b)[0], lambda a, b: numpy.divmod(a, b)[0], INT(4, 4), 1+NNI(4))
 _check('Array_divmod_mod', lambda a, b: divmod(function.Array.cast(a), b)[1], lambda a, b: numpy.divmod(a, b)[1], INT(4, 4), 1+NNI(4))
 _check('Array_rdivmod_div', lambda a, b: divmod(a, function.Array.cast(b))[0], lambda a, b: numpy.divmod(a, b)[0], INT(4, 4), 1+NNI(4))
 _check('Array_rdivmod_mod', lambda a, b: divmod(a, function.Array.cast(b))[1], lambda a, b: numpy.divmod(a, b)[1], INT(4, 4), 1+NNI(4))
-_check('matmul', function.matmul, numpy.matmul, ANY(4), ANY(4))
-_check('matmul-complex', function.matmul, numpy.matmul, ANY(4), ANC(4))
+_check('matmul', lambda a, b: numpy.matmul(a, function.Array.cast(b)), numpy.matmul, ANY(4), ANY(4))
+_check('matmul-complex', lambda a, b: numpy.matmul(a, function.Array.cast(b)), numpy.matmul, ANY(4), ANC(4))
 _check('Array_matmul_vecvec', lambda a, b: function.Array.cast(a) @ b, numpy.matmul, ANY(4), ANY(4))
 _check('Array_matmul_vecmat', lambda a, b: function.Array.cast(a) @ b, numpy.matmul, ANY(4), ANY(4, 3))
 _check('Array_matmul_matvec', lambda a, b: function.Array.cast(a) @ b, numpy.matmul, ANY(3, 4), ANY(4))
 _check('Array_matmul_matmat', lambda a, b: function.Array.cast(a) @ b, numpy.matmul, ANY(3, 4), ANY(4, 5))
-_check('real', function.real, numpy.real, ANY(4))
-_check('real-complex', function.real, numpy.real, ANC(4))
+_check('real', lambda a: numpy.real(function.Array.cast(a)), numpy.real, ANY(4))
+_check('real-complex', lambda a: numpy.real(function.Array.cast(a)), numpy.real, ANC(4))
 _check('Aray_real-complex', lambda a: function.Array.cast(a).real, numpy.real, ANC(4))
-_check('imag', function.imag, numpy.imag, ANY(4))
-_check('imag-complex', function.imag, numpy.imag, ANC(4))
+_check('imag', lambda a: numpy.imag(function.Array.cast(a)), numpy.imag, ANY(4))
+_check('imag-complex', lambda a: numpy.imag(function.Array.cast(a)), numpy.imag, ANC(4))
 _check('Aray_imag-complex', lambda a: function.Array.cast(a).imag, numpy.imag, ANC(4))
-_check('conjugate', function.conjugate, numpy.conjugate, ANY(4))
-_check('conjugate-complex', function.conjugate, numpy.conjugate, ANC(4))
+_check('conjugate', lambda a: numpy.conjugate(function.Array.cast(a)), numpy.conjugate, ANY(4))
+_check('conjugate-complex', lambda a: numpy.conjugate(function.Array.cast(a)), numpy.conjugate, ANC(4))
 _check('Aray_conjugate-complex', lambda a: function.Array.cast(a).conjugate(), numpy.conjugate, ANC(4))
 
-_check('cos', function.cos, numpy.cos, ANY(4))
-_check('cos-complex', function.cos, numpy.cos, ANC(4))
-_check('sin', function.sin, numpy.sin, ANY(4))
-_check('sin-complex', function.sin, numpy.sin, ANC(4))
-_check('tan', function.tan, numpy.tan, ANY(4))
-_check('tan-complex', function.tan, numpy.tan, ANC(4))
-_check('arccos', function.arccos, numpy.arccos, ANY(4))
-_check('arccos-complex', function.arccos, numpy.arccos, ANC(4))
-_check('arcsin', function.arcsin, numpy.arcsin, ANY(4))
-_check('arcsin-complex', function.arcsin, numpy.arcsin, ANC(4))
-_check('arctan', function.arctan, numpy.arctan, ANY(4))
-_check('arctan-complex', function.arctan, numpy.arctan, ANC(4))
-_check('arctan2', function.arctan2, numpy.arctan2, ANY(4, 1), ANY(1, 4))
-_check('cosh', function.cosh, numpy.cosh, ANY(4))
-_check('cosh-complex', function.cosh, numpy.cosh, ANC(4))
-_check('sinh', function.sinh, numpy.sinh, ANY(4))
-_check('sinh-complex', function.sinh, numpy.sinh, ANC(4))
-_check('tanh', function.tanh, numpy.tanh, ANY(4))
-_check('tanh-complex', function.tanh, numpy.tanh, ANC(4))
-_check('arctanh', function.arctanh, numpy.arctanh, ANY(4))
-_check('arctanh-complex', function.arctanh, numpy.arctanh, ANC(4))
-_check('exp', function.exp, numpy.exp, ANY(4))
-_check('exp-complex', function.exp, numpy.exp, ANC(4))
-_check('log', function.log, numpy.log, POS(4))
-_check('log-complex', function.log, numpy.log, NZC(4))
-_check('log2', function.log2, numpy.log2, POS(4))
-_check('log2-complex', function.log2, numpy.log2, NZC(4))
-_check('log10', function.log10, numpy.log10, POS(4))
-_check('log10-complex', function.log10, numpy.log10, NZC(4))
+_check('cos', lambda a: numpy.cos(function.Array.cast(a)), numpy.cos, ANY(4))
+_check('cos-complex', lambda a: numpy.cos(function.Array.cast(a)), numpy.cos, ANC(4))
+_check('sin', lambda a: numpy.sin(function.Array.cast(a)), numpy.sin, ANY(4))
+_check('sin-complex', lambda a: numpy.sin(function.Array.cast(a)), numpy.sin, ANC(4))
+_check('tan', lambda a: numpy.tan(function.Array.cast(a)), numpy.tan, ANY(4))
+_check('tan-complex', lambda a: numpy.tan(function.Array.cast(a)), numpy.tan, ANC(4))
+_check('arccos', lambda a: numpy.arccos(function.Array.cast(a)), numpy.arccos, ANY(4))
+_check('arccos-complex', lambda a: numpy.arccos(function.Array.cast(a)), numpy.arccos, ANC(4))
+_check('arcsin', lambda a: numpy.arcsin(function.Array.cast(a)), numpy.arcsin, ANY(4))
+_check('arcsin-complex', lambda a: numpy.arcsin(function.Array.cast(a)), numpy.arcsin, ANC(4))
+_check('arctan', lambda a: numpy.arctan(function.Array.cast(a)), numpy.arctan, ANY(4))
+_check('arctan-complex', lambda a: numpy.arctan(function.Array.cast(a)), numpy.arctan, ANC(4))
+_check('arctan2', lambda a, b: numpy.arctan2(a, function.Array.cast(b)), numpy.arctan2, ANY(4, 1), ANY(1, 4))
+_check('sinc', lambda a: numpy.sin(function.Array.cast(a)), numpy.sin, ANY(4))
+_check('sinc-complex', lambda a: numpy.sin(function.Array.cast(a)), numpy.sin, ANC(4))
+_check('cosh', lambda a: numpy.cosh(function.Array.cast(a)), numpy.cosh, ANY(4))
+_check('cosh-complex', lambda a: numpy.cosh(function.Array.cast(a)), numpy.cosh, ANC(4))
+_check('sinh', lambda a: numpy.sinh(function.Array.cast(a)), numpy.sinh, ANY(4))
+_check('sinh-complex', lambda a: numpy.sinh(function.Array.cast(a)), numpy.sinh, ANC(4))
+_check('tanh', lambda a: numpy.tanh(function.Array.cast(a)), numpy.tanh, ANY(4))
+_check('tanh-complex', lambda a: numpy.tanh(function.Array.cast(a)), numpy.tanh, ANC(4))
+_check('arctanh', lambda a: numpy.arctanh(function.Array.cast(a)), numpy.arctanh, ANY(4))
+_check('arctanh-complex', lambda a: numpy.arctanh(function.Array.cast(a)), numpy.arctanh, ANC(4))
+_check('exp', lambda a: numpy.exp(function.Array.cast(a)), numpy.exp, ANY(4))
+_check('exp-complex', lambda a: numpy.exp(function.Array.cast(a)), numpy.exp, ANC(4))
+_check('log', lambda a: numpy.log(function.Array.cast(a)), numpy.log, POS(4))
+_check('log-complex', lambda a: numpy.log(function.Array.cast(a)), numpy.log, NZC(4))
+_check('log2', lambda a: numpy.log2(function.Array.cast(a)), numpy.log2, POS(4))
+_check('log2-complex', lambda a: numpy.log2(function.Array.cast(a)), numpy.log2, NZC(4))
+_check('log10', lambda a: numpy.log10(function.Array.cast(a)), numpy.log10, POS(4))
+_check('log10-complex', lambda a: numpy.log10(function.Array.cast(a)), numpy.log10, NZC(4))
 _check('trignormal', function.trignormal, lambda x: numpy.stack([numpy.cos(x), numpy.sin(x)], axis=-1), ANY(4))
 _check('trigtangent', function.trigtangent, lambda x: numpy.stack([-numpy.sin(x), numpy.cos(x)], axis=-1), ANY(4))
 
-_check('greater', function.greater, numpy.greater, ANY(4, 1), ANY(1, 4))
-_check('equal', function.equal, numpy.equal, ANY(4, 1), ANY(1, 4))
-_check('equal-complex', function.equal, numpy.equal, ANC(4, 1), ANC(1, 4))
-_check('less', function.less, numpy.less, ANY(4, 1), ANY(1, 4))
-_check('min', function.min, numpy.minimum, ANY(4, 1), ANY(1, 4))
-_check('max', function.max, numpy.maximum, ANY(4, 1), ANY(1, 4))
+_check('greater', lambda a, b: numpy.greater(a, function.Array.cast(b)), numpy.greater, ANY(4, 1), ANY(1, 4))
+_check('equal', lambda a, b: numpy.equal(a, function.Array.cast(b)), numpy.equal, ANY(4, 1), ANY(1, 4))
+_check('equal-complex', lambda a, b: numpy.equal(a, function.Array.cast(b)), numpy.equal, ANC(4, 1), ANC(1, 4))
+_check('less', lambda a, b: numpy.less(a, function.Array.cast(b)), numpy.less, ANY(4, 1), ANY(1, 4))
+_check('min', lambda a, b: numpy.minimum(a, function.Array.cast(b)), numpy.minimum, ANY(4, 1), ANY(1, 4))
+_check('max', lambda a, b: numpy.maximum(a, function.Array.cast(b)), numpy.maximum, ANY(4, 1), ANY(1, 4))
 _check('heaviside', function.heaviside, lambda u: numpy.heaviside(u, .5), ANY(4, 4))
 
 ## TODO: opposite
 ## TODO: mean
 ## TODO: jump
 #
-_check('sum', lambda a: function.sum(a, 2), lambda a: a.sum(2), ANY(4, 3, 4))
-_check('sum-bool', lambda a: function.sum(function.greater(a, 0), 2), lambda a: (a > 0).sum(2), ANY(4, 3, 4))
-_check('sum-complex', lambda a: function.sum(a, 2), lambda a: a.sum(2), ANC(4, 3, 4))
+_check('sum', lambda a: numpy.sum(function.Array.cast(a), 2), lambda a: a.sum(2), ANY(4, 3, 4))
+_check('sum-bool', lambda a: numpy.sum(function.Array.cast(a > 0), 2), lambda a: (a > 0).sum(2), ANY(4, 3, 4))
+_check('sum-complex', lambda a: numpy.sum(function.Array.cast(a), 2), lambda a: a.sum(2), ANC(4, 3, 4))
 _check('Array_sum', lambda a: function.Array.cast(a).sum(2), lambda a: a.sum(2), ANY(4, 3, 4))
-_check('product', lambda a: function.product(a, 2), lambda a: numpy.product(a, 2), ANY(4, 3, 4))
-_check('product-bool', lambda a: function.product(function.greater(a, 0), 2), lambda a: numpy.product((a > 0), 2), ANY(4, 3, 4))
-_check('product-complex', lambda a: function.product(a, 2), lambda a: numpy.product(a, 2), ANC(4, 3, 4))
+_check('product', lambda a: numpy.product(function.Array.cast(a), 2), lambda a: numpy.product(a, 2), ANY(4, 3, 4))
+_check('product-bool', lambda a: numpy.product(function.Array.cast(a > 0), 2), lambda a: numpy.product((a > 0), 2), ANY(4, 3, 4))
+_check('product-complex', lambda a: numpy.product(function.Array.cast(a), 2), lambda a: numpy.product(a, 2), ANC(4, 3, 4))
 _check('Array_prod', lambda a: function.Array.cast(a).prod(2), lambda a: numpy.product(a, 2), ANY(4, 3, 4))
 
-_check('dot', lambda a, b: function.dot(a, b, axes=2), lambda a, b: (a*b).sum(2), ANY(4, 2, 4), ANY(4, 2, 4).T)
-_check('dot-complex', lambda a, b: function.dot(a, b, axes=2), lambda a, b: (a*b).sum(2), ANC(4, 2, 4), ANC(4, 2, 4).T)
-_check('Array_dot', lambda a, b: function.Array.cast(a).dot(b, axes=2), lambda a, b: (a*b).sum(2), ANY(4, 2, 4), ANY(4, 2, 4).T)
-_check('vdot', lambda a, b: function.vdot(a, b), numpy.vdot, ANY(4, 2, 4), ANY(4, 2, 4).T)
-_check('vdot-complex', lambda a, b: function.vdot(a, b), numpy.vdot, ANC(4, 2, 4) / 10, ANC(4, 2, 4).T / 10)
-_check('trace', lambda a: function.trace(function.Array.cast(a), 0, 2), lambda a: numpy.trace(a, 0, 0, 2), ANY(3, 2, 3))
-_check('norm2', function.norm2, lambda a: numpy.linalg.norm(a, axis=1), ANY(2, 3))
-_check('norm2-complex', function.norm2, lambda a: numpy.linalg.norm(a, axis=1), ANC(2, 3))
+_check('dot', lambda a, b: numpy.dot(a, function.Array.cast(b)), numpy.dot, ANY(1, 2, 5), ANY(3, 5, 4))
+_check('dot-complex', lambda a, b: numpy.dot(a, function.Array.cast(b)), numpy.dot, ANC(1, 2, 5), ANC(3, 5, 4))
+_check('Array_dot', lambda a, b: function.Array.cast(a).dot(b), lambda a, b: a.dot(b), ANY(4), ANY(4))
+_check('vdot', lambda a, b: numpy.vdot(a, function.Array.cast(b)), numpy.vdot, ANY(4, 2, 4), ANY(4, 2, 4).T)
+_check('vdot-complex', lambda a, b: numpy.vdot(a, function.Array.cast(b)), numpy.vdot, ANC(4, 2, 4) / 10, ANC(4, 2, 4).T / 10)
+_check('trace', lambda a: numpy.trace(function.Array.cast(a), 0, 0, 2), lambda a: numpy.trace(a, 0, 0, 2), ANY(3, 2, 3))
+_check('norm', lambda a: numpy.linalg.norm(function.Array.cast(a), axis=1), lambda a: numpy.linalg.norm(a, axis=1), ANY(2, 3))
+_check('norm-complex', lambda a: numpy.linalg.norm(function.Array.cast(a), axis=1), lambda a: numpy.linalg.norm(a, axis=1), ANC(2, 3))
 _check('normalized', function.normalized, lambda a: a / numpy.linalg.norm(a, axis=1)[:, None], ANY(2, 3))
 _check('normalized-complex', function.normalized, lambda a: a / numpy.linalg.norm(a, axis=1)[:, None], ANC(2, 3))
 _check('Array_normalized', lambda a: function.Array.cast(a).normalized(), lambda a: a / numpy.linalg.norm(a, axis=1)[:, None], ANY(2, 3))
-_check('inverse', lambda a: function.inverse(a+3*numpy.eye(3)), lambda a: numpy.linalg.inv(a+3*numpy.eye(3)), ANY(2, 3, 3))
-_check('inverse-complex', lambda a: function.inverse(a+3*numpy.eye(3)), lambda a: numpy.linalg.inv(a+3*numpy.eye(3)), ANC(2, 3, 3))
-_check('determinant', lambda a: function.determinant(a+3*numpy.eye(3)), lambda a: numpy.linalg.det(a+3*numpy.eye(3)), ANY(2, 3, 3))
-_check('eigval', lambda a: function.eig(a)[0], lambda a: numpy.diag(numpy.linalg.eig(a)[0]), ANY(3, 3))
-_check('eigvec', lambda a: function.eig(a)[1], lambda a: numpy.linalg.eig(a)[1], ANY(3, 3))
-_check('eigval_symmetric', lambda a: function.eig(a+a.T)[0], lambda a: numpy.diag(numpy.linalg.eig(a+a.T)[0]), ANY(3, 3))
-_check('eigvec_symmetric', lambda a: function.eig(a+a.T)[1], lambda a: numpy.linalg.eig(a+a.T)[1], ANY(3, 3))
-_check('takediag', function.takediag, numpy.diag, ANY(3, 3))
+_check('inv', lambda a: numpy.linalg.inv(a+3*function.eye(3)), lambda a: numpy.linalg.inv(a+3*numpy.eye(3)), ANY(2, 3, 3))
+_check('inv-complex', lambda a: numpy.linalg.inv(a+3*function.eye(3)), lambda a: numpy.linalg.inv(a+3*numpy.eye(3)), ANC(2, 3, 3))
+_check('det', lambda a: numpy.linalg.det(a+3*function.eye(3)), lambda a: numpy.linalg.det(a+3*numpy.eye(3)), ANY(2, 3, 3))
+_check('eigval', lambda a: numpy.linalg.eig(function.Array.cast(a))[0], lambda a: numpy.linalg.eig(a)[0], ANY(3, 3))
+_check('eigvec', lambda a: numpy.linalg.eig(function.Array.cast(a))[1], lambda a: numpy.linalg.eig(a)[1], ANY(3, 3))
+_check('eigval_symmetric', lambda a: numpy.linalg.eigh(function.Array.cast(a+a.T))[0], lambda a: numpy.linalg.eigh(a+a.T)[0], ANY(3, 3))
+_check('eigvec_symmetric', lambda a: numpy.linalg.eigh(function.Array.cast(a+a.T))[1], lambda a: numpy.linalg.eigh(a+a.T)[1], ANY(3, 3))
+_check('diagonal', lambda a: numpy.diagonal(function.Array.cast(a), axis1=0, axis2=2), lambda a: numpy.diagonal(a, axis1=0, axis2=2), ANY(3, 2, 3))
+_check('diagonal-posoffset', lambda a: numpy.diagonal(function.Array.cast(a), +1, axis1=0, axis2=2), lambda a: numpy.diagonal(a, +1, axis1=0, axis2=2), ANY(3, 2, 3))
+_check('diagonal-negoffset', lambda a: numpy.diagonal(function.Array.cast(a), -2, axis1=0, axis2=2), lambda a: numpy.diagonal(a, -2, axis1=0, axis2=2), ANY(3, 2, 3))
 _check('diagonalize', function.diagonalize, numpy.diag, ANY(3))
-_check('cross', function.cross, numpy.cross, ANY(3), ANY(3))
-_check('cross-complex', function.cross, numpy.cross, ANC(3), 1-1j+ANC(3))
+_check('cross2', lambda a, b: numpy.cross(a, function.Array.cast(b)), numpy.cross, ANY(3,2), 1+ANY(3,2))
+_check('cross3', lambda a, b: numpy.cross(a, function.Array.cast(b)), numpy.cross, ANY(2,3), 1+ANY(2,3))
+_check('cross3-complex', lambda a, b: numpy.cross(function.Array.cast(a), b), numpy.cross, ANC(2,3), 1-1j+ANC(2,3))
+_check('cross3-axes', lambda a, b: numpy.cross(a, function.Array.cast(b), axisa=2, axisb=0, axisc=1), lambda a, b: numpy.cross(a, b, axisa=2, axisb=0, axisc=1), ANY(2,1,3), ANY(3,1,4))
 _check('outer', function.outer, lambda a, b: a[:, None]*b[None, :], ANY(2, 3), ANY(4, 3))
 _check('outer_self', function.outer, lambda a: a[:, None]*a[None, :], ANY(2, 3))
-_check('square', function.square, numpy.square, ANY(4))
-_check('hypot', function.hypot, numpy.hypot, ANY(4, 4), ANY(4, 4))
+_check('square', lambda a: numpy.square(function.Array.cast(a)), numpy.square, ANY(4))
+_check('hypot', lambda a, b: numpy.hypot(a, function.Array.cast(b)), numpy.hypot, ANY(4, 4), ANY(4, 4))
 
-_check('transpose', lambda a: function.transpose(a, [0, 1, 3, 2]), lambda a: a.transpose([0, 1, 3, 2]), INT(1, 2, 3, 4))
+_check('transpose', lambda a: numpy.transpose(function.Array.cast(a), [0, 1, 3, 2]), lambda a: a.transpose([0, 1, 3, 2]), INT(1, 2, 3, 4))
 _check('Array_transpose', lambda a: function.Array.cast(a).transpose([0, 1, 3, 2]), lambda a: a.transpose([0, 1, 3, 2]), INT(1, 2, 3, 4))
 _check('insertaxis', lambda a: function.insertaxis(a, 2, 3), lambda a: numpy.repeat(numpy.expand_dims(a, 2), 3, 2), INT(3, 2, 4))
 _check('expand_dims', lambda a: function.expand_dims(a, 1), lambda a: numpy.expand_dims(a, 1), INT(2, 3))
-_check('repeat', lambda a: function.repeat(a, 3, 1), lambda a: numpy.repeat(a, 3, 1), INT(2, 1, 4))
-_check('swapaxes', lambda a: function.swapaxes(a, 1, 2), lambda a: numpy.transpose(a, (0, 2, 1)), INT(2, 3, 4))
+_check('repeat', lambda a: numpy.repeat(function.Array.cast(a), 3, 1), lambda a: numpy.repeat(a, 3, 1), INT(2, 1, 4))
+_check('swapaxes', lambda a: numpy.swapaxes(function.Array.cast(a), 1, 2), lambda a: numpy.transpose(a, (0, 2, 1)), INT(2, 3, 4))
 _check('Array_swapaxes', lambda a: function.Array.cast(a).swapaxes(1, 2), lambda a: numpy.transpose(a, (0, 2, 1)), INT(2, 3, 4))
-_check('ravel', lambda a: function.ravel(a, 1), lambda a: numpy.reshape(a, (2, 12, 5)), INT(2, 3, 4, 5))
+_check('reshape', lambda a: numpy.reshape(function.Array.cast(a), (2, -1, 5)), lambda a: numpy.reshape(a, (2, -1, 5)), INT(2, 3, 4, 5))
+_check('ravel', lambda a: numpy.ravel(function.Array.cast(a)), lambda a: numpy.ravel(a), INT(2, 3, 4))
 _check('unravel', lambda a: function.unravel(a, 1, (3, 4)), lambda a: numpy.reshape(a, (2, 3, 4, 5)), INT(2, 12, 5))
-_check('take', lambda a: function.take(a, numpy.array([[0, 2], [1, 3]]), 1), lambda a: numpy.take(a, numpy.array([[0, 2], [1, 3]]), 1), INT(3, 4, 5))
-_check('take_bool', lambda a: function.take(a, numpy.array([False, True, False, True]), 1), lambda a: numpy.compress(numpy.array([False, True, False, True]), a, 1), INT(3, 4, 5))
-_check('get', lambda a: function.take(a, 1, 1), lambda a: numpy.take(a, 1, 1), INT(3, 4, 5))
+_check('take', lambda a: numpy.take(function.Array.cast(a), numpy.array([[0, 2], [1, 3]]), 1), lambda a: numpy.take(a, numpy.array([[0, 2], [1, 3]]), 1), INT(3, 4, 5))
+_check('compress', lambda a: numpy.compress(numpy.array([False, True, False, True]), function.Array.cast(a), 1), lambda a: numpy.compress(numpy.array([False, True, False, True]), a, 1), INT(3, 4, 5))
+_check('get', lambda a: function.get(a, 1, 1), lambda a: numpy.take(a, 1, 1), INT(3, 4, 5))
 _check('scatter', lambda a: function.scatter(a, 3, [2, 0]), lambda a: numpy.stack([a[:, 1], numpy.zeros([4]), a[:, 0]], axis=1), INT(4, 2))
 _check('kronecker', lambda a: function.kronecker(a, 1, 3, 1), lambda a: numpy.stack([numpy.zeros_like(a), a, numpy.zeros_like(a)], axis=1), INT(4, 4))
-_check('concatenate', lambda a, b: function.concatenate([a, b], axis=1), lambda a, b: numpy.concatenate([a, b], axis=1), INT(4, 2, 1), INT(4, 3, 1))
-_check('stack', lambda a, b: function.stack([a, b], 1), lambda a, b: numpy.stack([a, b], 1), INT(4, 2), INT(4, 2))
+_check('concatenate', lambda a, b: numpy.concatenate([a, function.Array.cast(b)], axis=1), lambda a, b: numpy.concatenate([a, b], axis=1), INT(4, 2, 1), INT(4, 3, 1))
+_check('stack', lambda a, b: numpy.stack([a, function.Array.cast(b)], 1), lambda a, b: numpy.stack([a, b], 1), INT(4, 2), INT(4, 2))
+_check('choose', lambda a, b: numpy.choose([0,1], [a, function.Array.cast(b)]), lambda a, b: numpy.choose([0,1], [a, b]), INT(4, 1), INT(1, 2))
+_check('einsum', lambda a, b: numpy.einsum('ik,jkl->ijl', a, function.Array.cast(b)), lambda a, b: numpy.einsum('ik,jkl->ijl', a, b), ANY(2, 4), ANY(3, 4, 2))
+_check('einsum-diag', lambda a: numpy.einsum('ijii->ji', function.Array.cast(a)), lambda a: numpy.einsum('ijii->ji', a), ANY(3, 2, 3, 3))
+_check('einsum-sum', lambda a: numpy.einsum('ijk->i', function.Array.cast(a)), lambda a: numpy.einsum('ijk->i', a), ANY(2, 3, 4))
+_check('einsum-implicit', lambda a: numpy.einsum('i...i', function.Array.cast(a)), lambda a: numpy.einsum('i...i', a), ANY(3, 2, 3))
 
 _check('Array_getitem_scalar', lambda a: function.Array.cast(a)[0], lambda a: a[0], INT(5, 3, 2))
 _check('Array_getitem_scalar_scalar', lambda a: function.Array.cast(a)[0, 1], lambda a: a[0, 1], INT(5, 3, 2))
+_check('Array_getitem_matrix', lambda a: function.Array.cast(a)[numpy.array([[4,3],[2,1]])], lambda a: a[numpy.array([[4,3],[2,1]])], INT(5, 3, 2))
 _check('Array_getitem_slice_step', lambda a: function.Array.cast(a)[:, ::2], lambda a: a[:, ::2], INT(5, 3, 2))
 _check('Array_getitem_ellipsis_scalar', lambda a: function.Array.cast(a)[..., 1], lambda a: a[..., 1], INT(5, 3, 2))
 _check('Array_getitem_ellipsis_scalar_newaxis', lambda a: function.Array.cast(a)[..., 1, None], lambda a: a[..., 1, None], INT(5, 3, 2))
 
 _check('add_T', lambda a: function.add_T(a, (1, 2)), lambda a: a + a.transpose((0, 2, 1)), INT(5, 2, 2))
 _check('Array_add_T', lambda a: function.Array.cast(a).add_T((1, 2)), lambda a: a + a.transpose((0, 2, 1)), INT(5, 2, 2))
 
+_check('searchsorted', lambda a: numpy.searchsorted(numpy.linspace(0, 1, 9), function.Array.cast(a)), lambda a: numpy.searchsorted(numpy.linspace(0, 1, 9), a), POS(4, 2))
+_check('searchsorted_sorter', lambda a: numpy.searchsorted([.2,.8,.4,0,.6,1], function.Array.cast(a), sorter=[3,0,2,4,1,5]), lambda a: numpy.searchsorted([.2,.8,.4,0,.6,1], a, sorter=[3,0,2,4,1,5]), POS(4, 2))
+_check('interp', lambda a: numpy.interp(function.Array.cast(a), [-.5,0,.5], [0,1,0]), lambda a: numpy.interp(a, [-.5,0,.5], [0,1,0]), ANY(4, 2))
+_check('interp_lr', lambda a: numpy.interp(function.Array.cast(a), [-.5,0,.5], [0,1,0], left=-10, right=+10), lambda a: numpy.interp(a, [-.5,0,.5], [0,1,0], left=-10, right=+10), ANY(4, 2))
+
 
 class Unlower(TestCase):
 
     def test(self):
-        e = evaluable.Argument('arg', (2, 3, 4, 5), int)
+        e = evaluable.Argument('arg', tuple(map(evaluable.constant, (2, 3, 4, 5))), int)
         arguments = {'arg': ((2, 3), int)}
-        f = function._Unlower(e, frozenset(), arguments, (2, 3), {}, {})
+        f = function._Unlower(e, frozenset(), arguments, function.LowerArgs((2, 3), {}, {}))
         self.assertEqual(f.shape, (4, 5))
         self.assertEqual(f.dtype, int)
         self.assertEqual(f.arguments, arguments)
-        self.assertEqual(f.lower((2, 3), {}, {}), e)
+        self.assertEqual(f.lower(function.LowerArgs((2, 3), {}, {})), e)
         with self.assertRaises(ValueError):
-            f.lower((3, 4), {}, {})
+            f.lower(function.LowerArgs((3, 4), {}, {}))
 
 
 class Custom(TestCase):
 
     def assertEvalAlmostEqual(self, factual, fdesired, **args):
         with self.subTest('0d-points'):
             self.assertAllAlmostEqual(factual.as_evaluable_array.eval(**args), fdesired.as_evaluable_array.eval(**args))
-        transform_chains = dict(test=(transform.EvaluableTransformChain.from_argument('test', 2, 2),)*2)
         with self.subTest('1d-points'):
-            coords = evaluable.Zeros((5, 2), float)
-            lower_args = coords.shape[:-1], transform_chains, dict(test=coords)
-            self.assertAllAlmostEqual(factual.lower(*lower_args).eval(**args), fdesired.lower(*lower_args).eval(**args))
+            lower_args = function.LowerArgs((evaluable.asarray(5),), {}, {})
+            self.assertAllAlmostEqual(factual.lower(lower_args).eval(**args), fdesired.lower(lower_args).eval(**args))
         with self.subTest('2d-points'):
-            coords = evaluable.Zeros((5, 6, 2), float)
-            lower_args = coords.shape[:-1], transform_chains, dict(test=coords)
-            self.assertAllAlmostEqual(factual.lower(*lower_args).eval(**args), fdesired.lower(*lower_args).eval(**args))
+            lower_args = function.LowerArgs((evaluable.asarray(5), evaluable.asarray(6)), {}, {})
+            self.assertAllAlmostEqual(factual.lower(lower_args).eval(**args), fdesired.lower(lower_args).eval(**args))
 
     def assertMultipy(self, leftval, rightval):
 
         for npointwise in range(leftval. ndim):
 
             class Multiply(function.Custom):
 
@@ -553,15 +581,15 @@
     def test_no_array_args_invalid_shape(self):
 
         class Test(function.Custom):
             @staticmethod
             def evalf():
                 return numpy.array([1, 2, 3])
 
-        with self.assertRaises(evaluable.EvaluationError):
+        with self.assertRaises(ValueError):
             Test((), (), int).eval()
 
     def test_pointwise_singleton_expansion(self):
 
         class Test(function.Custom):
             def __init__(self, args, shapes, npointwise):
                 super().__init__(args=(shapes, *args), shape=(), dtype=float, npointwise=npointwise)
@@ -627,42 +655,43 @@
 
     def test_no_shapes(self):
         with self.assertRaisesRegex(ValueError, 'expected at least one shape but got none'):
             function.broadcast_shapes()
 
     def test_broadcast_to_decrease_dimension(self):
         with self.assertRaisesRegex(ValueError, 'cannot broadcast array .* because the dimension decreases'):
-            function.broadcast_to(function.Argument('a', (2, 3, 4)), (3, 4))
+            numpy.broadcast_to(function.Argument('a', (2, 3, 4)), (3, 4))
 
     def test_broadcast_to_invalid_length(self):
         with self.assertRaisesRegex(ValueError, 'cannot broadcast array .* because input axis .* is neither singleton nor has the desired length'):
-            function.broadcast_to(function.Argument('a', (2, 3, 4)), (2, 5, 4))
+            numpy.broadcast_to(function.Argument('a', (2, 3, 4)), (2, 5, 4))
 
 
 @parametrize
 class sampled(TestCase):
 
     def setUp(self):
         super().setUp()
         self.domain, geom = mesh.unitsquare(4, self.etype)
         basis = self.domain.basis('std', degree=1)
         numpy.random.seed(0)
         self.f = basis.dot(numpy.random.uniform(size=len(basis)))
         sample = self.domain.sample('gauss', 2)
+        print(sample.eval(self.f))
         self.f_sampled = sample.asfunction(sample.eval(self.f))
 
     def test_isarray(self):
         self.assertTrue(function.isarray(self.f_sampled))
 
     def test_values(self):
         diff = self.domain.integrate(self.f - self.f_sampled, ischeme='gauss2')
         self.assertAllAlmostEqual(diff, 0)
 
     def test_pointset(self):
-        with self.assertRaises(evaluable.EvaluationError):
+        with self.assertRaises(ValueError):
             self.domain.integrate(self.f_sampled, ischeme='uniform2')
 
 
 for etype in 'square', 'triangle', 'mixed':
     sampled(etype=etype)
 
 
@@ -671,17 +700,17 @@
 
     def setUp(self):
         super().setUp()
         self.domain, self.geom = mesh.rectilinear([1])
         x, = self.geom
         if self.partition:
             left, mid, right = function.partition(x, .2, .8)
-            self.f = left + function.sin(x) * mid + x**2 * right
+            self.f = left + numpy.sin(x) * mid + x**2 * right
         else:
-            self.f = function.piecewise(x, [.2, .8], 1, function.sin(x), x**2)
+            self.f = function.piecewise(x, [.2, .8], 1, numpy.sin(x), x**2)
 
     def test_evalf(self):
         f_ = self.domain.sample('uniform', 4).eval(self.f)  # x=.125, .375, .625, .875
         assert numpy.equal(f_, [1, numpy.sin(.375), numpy.sin(.625), .875**2]).all()
 
     def test_deriv(self):
         g_ = self.domain.sample('uniform', 4).eval(function.grad(self.f, self.geom))  # x=.125, .375, .625, .875
@@ -692,15 +721,15 @@
 piecewise(partition=True)
 
 
 class elemwise(TestCase):
 
     def setUp(self):
         super().setUp()
-        self.index = function._Wrapper(lambda: evaluable.InRange(evaluable.Argument('index', (), int), 5), shape=(), dtype=int)
+        self.index = function._Wrapper(lambda: evaluable.InRange(evaluable.Argument('index', (), int), evaluable.constant(5)), shape=(), dtype=int)
         self.data = tuple(map(types.frozenarray, (
             numpy.arange(1, 7, dtype=float).reshape(2, 3),
             numpy.arange(2, 8, dtype=float).reshape(2, 3),
             numpy.arange(3, 9, dtype=float).reshape(2, 3),
             numpy.arange(4, 10, dtype=float).reshape(2, 3),
             numpy.arange(6, 12, dtype=float).reshape(2, 3),
         )))
@@ -724,15 +753,15 @@
         a = function.Argument('a', (2,))
         b = function.Array.cast([1, 2.])
         self.assertEqual(function.replace_arguments(a, dict(a=b)).as_evaluable_array, b.as_evaluable_array)
 
     def test_argument(self):
         a = function.Argument('a', (2,))
         b = function.Argument('b', (2,))
-        self.assertEqual(function.replace_arguments(a, dict(a=b)).as_evaluable_array, b.as_evaluable_array)
+        self.assertEqual(function.replace_arguments(a, dict(a='b')).as_evaluable_array, b.as_evaluable_array)
 
     def test_argument_array(self):
         a = function.Argument('a', (2,))
         b = function.Argument('b', (2,))
         c = function.Array.cast([1, 2.])
         self.assertEqual(function.replace_arguments(function.replace_arguments(a, dict(a=b)), dict(b=c)).as_evaluable_array, c.as_evaluable_array)
 
@@ -767,14 +796,19 @@
         with self.assertRaisesRegex(ValueError, "Argument 'foo' has shape \\(2,\\) but the replacement has shape \\(3, 4\\)."):
             function.replace_arguments(function.Argument('foo', (2,), dtype=float), dict(foo=function.zeros((3, 4), dtype=float)))
 
     def test_different_dtype(self):
         with self.assertRaisesRegex(ValueError, "Argument 'foo' has dtype int but the replacement has dtype float."):
             function.replace_arguments(function.Argument('foo', (), dtype=int), dict(foo=function.zeros((), dtype=float)))
 
+    def test_nonempty_spaces(self):
+        topo, geom = mesh.unitsquare(1, 'square')
+        with self.assertRaisesRegex(ValueError, "replacement functions cannot contain spaces, but replacement for Argument 'foo' contains space X."):
+            function.replace_arguments(function.Argument('foo', (2,), dtype=float), dict(foo=geom))
+
 
 class dotarg(TestCase):
 
     def assertEvalAlmostEqual(self, f_actual, desired, **arguments):
         self.assertEqual(f_actual.shape, desired.shape)
         actual = f_actual.as_evaluable_array.eval(**arguments)
         self.assertEqual(actual.shape, desired.shape)
@@ -919,22 +953,34 @@
             self.assertEvalAlmostEqual(domain.boundary[bnd], self.normal(x), n)
 
     def test_normal_2d(self):
         domain, x = mesh.rectilinear([1]*2)
         x = 2*x-0.5
         x = function.unravel(x, 0, [2, 1])
         for bnd, n in ('right', [1, 0]), ('left', [-1, 0]), ('top', [0, 1]), ('bottom', [0, -1]):
-            self.assertEvalAlmostEqual(domain.boundary[bnd], self.normal(x), numpy.array(n)[:, _])
+            self.assertEvalAlmostEqual(domain.boundary[bnd], self.normal(x), numpy.array(n)[:, numpy.newaxis])
 
     def test_normal_3d(self):
         domain, x = mesh.rectilinear([1]*2)
         x = 2*x-0.5
         x = function.unravel(function.unravel(x, 0, [2, 1]), 0, [1, 2])
         for bnd, n in ('right', [1, 0]), ('left', [-1, 0]), ('top', [0, 1]), ('bottom', [0, -1]):
-            self.assertEvalAlmostEqual(domain.boundary[bnd], self.normal(x), numpy.array(n)[_, :, _])
+            self.assertEvalAlmostEqual(domain.boundary[bnd], self.normal(x), numpy.array(n)[numpy.newaxis, :, numpy.newaxis])
+
+    def test_normal_manifold(self):
+        domain, geom = mesh.rectilinear([1]*2)
+        x = numpy.stack([geom[0], geom[1], geom[0]**2 - geom[1]**2])
+        n = self.normal(x) # boundary normal
+        N = self.normal(x, geom) # exterior normal
+        k = -.5 * self.div(N, x, -1) # mean curvature
+        dA = function.jacobian(x, 2)
+        dL = function.jacobian(x, 1)
+        v1 = domain.integrate(2 * k * N * dA, degree=16)
+        v2 = domain.boundary.integrate(n * dL, degree=16)
+        self.assertAllAlmostEqual(v1, v2) # divergence theorem in curved space
 
     def test_dotnorm(self):
         domain, x = mesh.rectilinear([1]*2)
         x = 2*x-0.5
         for bnd, desired in ('right', 1), ('left', -1), ('top', 0), ('bottom', 0):
             self.assertEvalAlmostEqual(domain.boundary[bnd], self.dotnorm([1, 0], x), desired)
 
@@ -977,19 +1023,19 @@
            div=function.div,
            curl=function.curl,
            laplace=function.laplace,
            symgrad=function.symgrad,
            ngrad=function.ngrad,
            nsymgrad=function.nsymgrad)
 derivative('method',
-           normal=lambda geom: function.Array.cast(geom).normal(),
+           normal=lambda geom, refgeom=None: function.Array.cast(geom).normal(refgeom),
            tangent=lambda geom, vec: function.Array.cast(geom).tangent(vec),
            dotnorm=lambda vec, geom: function.Array.cast(vec).dotnorm(geom),
            grad=lambda arg, geom: function.Array.cast(arg).grad(geom),
-           div=lambda arg, geom: function.Array.cast(arg).div(geom),
+           div=lambda arg, geom, ndims=0: function.Array.cast(arg).div(geom, ndims),
            curl=lambda arg, geom: function.Array.cast(arg).curl(geom),
            laplace=lambda arg, geom: function.Array.cast(arg).laplace(geom),
            symgrad=lambda arg, geom: function.Array.cast(arg).symgrad(geom),
            ngrad=lambda arg, geom: function.Array.cast(arg).ngrad(geom),
            nsymgrad=lambda arg, geom: function.Array.cast(arg).nsymgrad(geom))
 
 
@@ -1151,128 +1197,130 @@
         maskedbasis = self.basis[:]
         for ielem in range(self.checknelems):
             self.assertEqual(maskedbasis.get_dofs(ielem).tolist(), self.checkdofs[ielem])
             self.assertEqual(maskedbasis.get_coefficients(ielem).tolist(), self.checkcoeffs[ielem])
 
     def checkeval(self, ielem, points):
         result = numpy.zeros((points.npoints, self.checkndofs,), dtype=float)
-        numpy.add.at(result, (slice(None), numpy.array(self.checkdofs[ielem], dtype=int)), numeric.poly_eval(numpy.array(self.checkcoeffs[ielem], dtype=float), points.coords))
+        if self.checkcoeffs[ielem]:
+            numpy.add.at(result, (slice(None), numpy.array(self.checkdofs[ielem], dtype=int)), poly.eval_outer(numpy.array(self.checkcoeffs[ielem], dtype=float), points.coords))
         return result
 
     def test_lower(self):
         ref = element.PointReference() if self.basis.coords.shape[0] == 0 else element.LineReference()**self.basis.coords.shape[0]
         points = ref.getpoints('bezier', 4)
-        coordinates = evaluable.Constant(points.coords)
-        lowered = self.basis.lower(coordinates.shape[:-1], dict(X=(self.checktransforms.get_evaluable(evaluable.Argument('ielem', (), int)),)*2), dict(X=coordinates))
+        coordinates = evaluable.constant(points.coords)
+        lowerargs = function.LowerArgs.for_space('X', (self.checktransforms,), evaluable.Argument('ielem', (), int), coordinates)
+        lowered = self.basis.lower(lowerargs)
         with _builtin_warnings.catch_warnings():
             _builtin_warnings.simplefilter('ignore', category=evaluable.ExpensiveEvaluationWarning)
             for ielem in range(self.checknelems):
                 value = lowered.eval(ielem=ielem)
                 if value.shape[0] == 1:
                     value = numpy.tile(value, (points.npoints, 1))
                 self.assertAllAlmostEqual(value, self.checkeval(ielem, points))
 
 
 class PlainBasis(CommonBasis, TestCase):
 
     def setUp(self):
         self.checktransforms = transformseq.IndexTransforms(0, 4)
         index, coords = self.mk_index_coords(0, self.checktransforms)
-        self.checkcoeffs = [[1.], [2., 3.], [4., 5.], [6.]]
+        self.checkcoeffs = [[[1.]], [[2.], [3.]], [[4.], [5.]], [[6.]]]
         self.checkdofs = [[0], [2, 3], [1, 3], [2]]
         self.basis = function.PlainBasis(self.checkcoeffs, self.checkdofs, 4, index, coords)
         self.checkndofs = 4
         super().setUp()
 
 
 class DiscontBasis(CommonBasis, TestCase):
 
     def setUp(self):
         self.checktransforms = transformseq.IndexTransforms(0, 4)
         index, coords = self.mk_index_coords(0, self.checktransforms)
-        self.checkcoeffs = [[1.], [2., 3.], [4., 5.], [6.]]
+        self.checkcoeffs = [[[1.]], [[2.], [3.]], [[4.], [5.]], [[6.]]]
         self.basis = function.DiscontBasis(self.checkcoeffs, index, coords)
         self.checkdofs = [[0], [1, 2], [3, 4], [5]]
         self.checkndofs = 6
         super().setUp()
 
 
 class LegendreBasis(CommonBasis, TestCase):
 
     def setUp(self):
         self.checktransforms = transformseq.IndexTransforms(1, 3)
         index, coords = self.mk_index_coords(0, self.checktransforms)
-        self.checkcoeffs = [[[1, 0, 0, 0], [-1, 2, 0, 0], [1, -6, 6, 0], [-1, 12, -30, 20]]]*3
+        self.checkcoeffs = [[[0, 0, 0, 1], [0, 0, 2, -1], [0, 6, -6, 1], [20, -30, 12, -1]]]*3
         self.basis = function.LegendreBasis(3, 3, index, coords)
         self.checkdofs = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]
         self.checkndofs = 12
         self.checkmasks = [[i in [0, 1, 4, 5, 7] for i in range(12)]]
         super().setUp()
 
 
 class MaskedBasis(CommonBasis, TestCase):
 
     def setUp(self):
         self.checktransforms = transformseq.IndexTransforms(0, 4)
         index, coords = self.mk_index_coords(0, self.checktransforms)
-        parent = function.PlainBasis([[1.], [2., 3.], [4., 5.], [6.]], [[0], [2, 3], [1, 3], [2]], 4, index, coords)
+        parent = function.PlainBasis([[[1.]], [[2.], [3.]], [[4.], [5.]], [[6.]]], [[0], [2, 3], [1, 3], [2]], 4, index, coords)
         self.basis = function.MaskedBasis(parent, [0, 2])
-        self.checkcoeffs = [[1.], [2.], [], [6.]]
+        self.checkcoeffs = [[[1.]], [[2.]], [], [[6.]]]
         self.checkdofs = [[0], [1], [], [1]]
         self.checkndofs = 2
         super().setUp()
 
 
 class PrunedBasis(CommonBasis, TestCase):
 
     def setUp(self):
         parent_transforms = transformseq.IndexTransforms(0, 4)
         parent_index, parent_coords = self.mk_index_coords(0, parent_transforms)
         indices = types.frozenarray([0, 2])
         self.checktransforms = parent_transforms[indices]
         index, coords = self.mk_index_coords(0, self.checktransforms)
-        parent = function.PlainBasis([[1.], [2., 3.], [4., 5.], [6.]], [[0], [2, 3], [1, 3], [2]], 4, parent_index, parent_coords)
+        parent = function.PlainBasis([[[1.]], [[2.], [3.]], [[4.], [5.]], [[6.]]], [[0], [2, 3], [1, 3], [2]], 4, parent_index, parent_coords)
         self.basis = function.PrunedBasis(parent, indices, index, coords)
-        self.checkcoeffs = [[1.], [4., 5.]]
+        self.checkcoeffs = [[[1.]], [[4.], [5.]]]
         self.checkdofs = [[0], [1, 2]]
         self.checkndofs = 3
         super().setUp()
 
 
 class StructuredBasis1D(CommonBasis, TestCase):
 
     def setUp(self):
         self.checktransforms = transformseq.IndexTransforms(1, 4)
         index, coords = self.mk_index_coords(1, self.checktransforms)
-        self.basis = function.StructuredBasis([[[[1], [2]], [[3], [4]], [[5], [6]], [[7], [8]]]], [[0, 1, 2, 3]], [[2, 3, 4, 5]], [5], [4], index, coords)
+        self.basis = function.StructuredBasis([[[[1.], [2.]], [[3.], [4.]], [[5.], [6.]], [[7.], [8.]]]], [[0, 1, 2, 3]], [[2, 3, 4, 5]], [5], [4], index, coords)
         self.checkcoeffs = [[[1.], [2.]], [[3.], [4.]], [[5.], [6.]], [[7.], [8.]]]
         self.checkdofs = [[0, 1], [1, 2], [2, 3], [3, 4]]
         self.checkndofs = 5
         super().setUp()
 
 
 class StructuredBasis1DPeriodic(CommonBasis, TestCase):
 
     def setUp(self):
         self.checktransforms = transformseq.IndexTransforms(1, 4)
         index, coords = self.mk_index_coords(1, self.checktransforms)
-        self.basis = function.StructuredBasis([[[[1], [2]], [[3], [4]], [[5], [6]], [[7], [8]]]], [[0, 1, 2, 3]], [[2, 3, 4, 5]], [4], [4], index, coords)
+        self.basis = function.StructuredBasis([[[[1.], [2.]], [[3.], [4.]], [[5.], [6.]], [[7.], [8.]]]], [[0, 1, 2, 3]], [[2, 3, 4, 5]], [4], [4], index, coords)
         self.checkcoeffs = [[[1.], [2.]], [[3.], [4.]], [[5.], [6.]], [[7.], [8.]]]
         self.checkdofs = [[0, 1], [1, 2], [2, 3], [3, 0]]
         self.checkndofs = 4
         super().setUp()
 
 
 class StructuredBasis2D(CommonBasis, TestCase):
 
     def setUp(self):
         self.checktransforms = transformseq.IndexTransforms(2, 4)
         index, coords = self.mk_index_coords(2, self.checktransforms)
-        self.basis = function.StructuredBasis([[[[1], [2]], [[3], [4]]], [[[5], [6]], [[7], [8]]]], [[0, 1], [0, 1]], [[2, 3], [2, 3]], [3, 3], [2, 2], index, coords)
-        self.checkcoeffs = [[[[5.]], [[6.]], [[10.]], [[12.]]], [[[7.]], [[8.]], [[14.]], [[16.]]], [[[15.]], [[18.]], [[20.]], [[24.]]], [[[21.]], [[24.]], [[28.]], [[32.]]]]
+        self.basis = function.StructuredBasis([[[[1.], [2.]], [[3.], [4.]]], [[[5.], [6.]], [[7.], [8.]]]], [[0, 1], [0, 1]], [[2, 3], [2, 3]], [3, 3], [2, 2], index, coords)
+        self.checkcoeffs = [[[5.], [6.], [10.], [12.]], [[7.], [8.], [14.], [16.]], [[15.], [18.], [20.], [24.]], [[21.], [24.], [28.], [32.]]]
         self.checkdofs = [[0, 1, 3, 4], [1, 2, 4, 5], [3, 4, 6, 7], [4, 5, 7, 8]]
         self.checkndofs = 9
         super().setUp()
 
 
 @parametrize
 class SurfaceGradient(TestCase):
@@ -1297,17 +1345,17 @@
                 refgeom = numpy.stack([y])
             else:
                 self.manifold, (y, z) = mesh.unitsquare(nelems=2, etype=self.etype)
                 self.u = y * (1-y) * z * (1-z)
                 refgeom = numpy.stack([y, z])
             x = 1
         # geometry describes a circle/sphere with curvature K
-        self.geom = (x/self.K) * function.stack(
-            (function.cos(y), function.sin(y)) if self.manifold.ndims == 1
-            else (function.cos(y), function.sin(y) * function.cos(z), function.sin(y) * function.sin(z)))
+        self.geom = (x/self.K) * numpy.stack(
+            (numpy.cos(y), numpy.sin(y)) if self.manifold.ndims == 1
+            else (numpy.cos(y), numpy.sin(y) * numpy.cos(z), numpy.sin(y) * numpy.sin(z)))
         self.normal = function.normal(self.geom, refgeom=refgeom)
 
     @property
     def P(self):
         n = len(self.normal)
         return function.eye(n) - self.normal[:, numpy.newaxis] * self.normal
 
@@ -1330,15 +1378,15 @@
         self.assertAllAlmostEqual(*self.manifold.sample('uniform', 2).eval([K, self.K]))
 
     def test_stokes(self):
         # https://en.wikipedia.org/wiki/Laplace%E2%80%93Beltrami_operator#Formal_self-adjointness
         grad = function.surfgrad(self.u, self.geom)
         lapl = function.laplace(self.u, self.geom, -1)
         J = function.J(self.geom)
-        self.assertAlmostEqual(*self.manifold.integrate([function.dot(grad, grad) * J, -self.u * lapl * J], degree=9))
+        self.assertAlmostEqual(*self.manifold.integrate([(grad @ grad) * J, -self.u * lapl * J], degree=9))
 
 
 SurfaceGradient(boundary=False, etype='line')
 SurfaceGradient(boundary=False, etype='square')
 SurfaceGradient(boundary=False, etype='triangle')
 SurfaceGradient(boundary=True, etype='square')
 SurfaceGradient(boundary=True, etype='triangle')
@@ -1355,24 +1403,26 @@
     def test_multiple(self):
         f = function.dotarg('v', numpy.array([1, 2, 3]))
         g = function.dotarg('v', numpy.array([3, 2, 1]))
         retvals = function.eval([f, g], v=numpy.array([4, 5, 6]))
         self.assertEqual(retvals, (4+10+18, 12+10+6))
 
 
-class simplifications(TestCase):
+class linearize(TestCase):
+
+    def test(self):
+        f = function.linearize(function.Argument('u', shape=(3, 4), dtype=float)**3
+                             + function.Argument('p', shape=(), dtype=float), 'u:v,p:q')
+        # test linearization of u**3 + p -> 3 u**2 v + q through evaluation
+        _u = numpy.arange(3, dtype=float)[:,numpy.newaxis].repeat(4, 1)
+        _v = numpy.arange(4, dtype=float)[numpy.newaxis,:].repeat(3, 0)
+        _q = 5.
+        self.assertAllEqual(f.eval(u=_u, v=_v, q=_q).export('dense'), 3 * _u**2 * _v + _q)
 
-    def test_multiply(self):
-        f = function.Argument('test', shape=(2, 3), dtype=float)
-        self.assertIs(f * 1, f)
-        self.assertIs(f * 1., f)
-        f = function.Argument('test', shape=(2, 3), dtype=int)
-        self.assertIs(f * 1, f)
-        self.assertIsNot(f * 1., f)
-
-    def test_divide(self):
-        f = function.Argument('test', shape=(2, 3), dtype=float)
-        self.assertIs(f / 1, f)
-        self.assertIs(f / 1., f)
-        f = function.Argument('test', shape=(2, 3), dtype=int)
-        self.assertIsNot(f / 1, f)
-        self.assertIsNot(f / 1., f)
+
+class attributes(TestCase):
+
+    def test(self):
+        A = function.Argument('test', (2,3))
+        self.assertEqual(numpy.shape(A), (2,3))
+        self.assertEqual(numpy.size(A), 6)
+        self.assertEqual(numpy.ndim(A), 2)
```

### Comparing `nutils-7.3/tests/test_graph.py` & `nutils-8.0/tests/test_graph.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,15 +11,15 @@
         assert '\n' not in label
         self.label = label
         super().__init__(metadata)
 
     def __bool__(self):
         return bool(self.label)
 
-    def _generate_asciitree_nodes(self, cache, graph_ids, id_gen, select, bridge):
+    def _generate_asciitree_nodes(self, cache, graph_ids, select, bridge):
         yield '{}{}\n'.format(select, self.label)
 
     def _collect_graphviz_nodes_edges(self, cache, id_gen, nodes, edges, parent_graph, fill_color=None):
         if self:
             id = next(id_gen)
             nodes.setdefault(parent_graph, []).append('{} [label="{}"];'.format(id, self.label))
             return id
@@ -35,25 +35,24 @@
 
     @unittest.skipIf(sys.version_info < (3, 6), 'test requires dict with insertion order')
     def test_generate_asciitree_nodes(self):
         args = DummyNode('a'), DummyNode('b'), DummyNode()
         kwargs = dict(spam=DummyNode('d'), eggs=DummyNode('e'))
         node = _graph.RegularNode('test', args, kwargs, 'meta')
         cache = {}
-        graph_ids = {None: 'X'}
-        cnt = map(str, itertools.count())
+        graph_ids = {None: (f'%X{i}' for i in itertools.count())}
         with self.subTest('first'):
-            self.assertEqual(list(node._generate_asciitree_nodes(cache, graph_ids, cnt, 'S', 'B')), [
+            self.assertEqual(list(node._generate_asciitree_nodes(cache, graph_ids, 'S', 'B')), [
                              'S%X0 = test\n',
                              'B├ a\n',
                              'B├ b\n',
                              'B├ spam = d\n',
                              'B└ eggs = e\n'])
         with self.subTest('second'):
-            self.assertEqual(list(node._generate_asciitree_nodes(cache, graph_ids, cnt, 'S', 'B')), [
+            self.assertEqual(list(node._generate_asciitree_nodes(cache, graph_ids, 'S', 'B')), [
                              'S%X0\n'])
 
     def test_collect_graphviz_nodes_edges_args(self):
         args = DummyNode('a'), DummyNode('b'), DummyNode()
         node = _graph.RegularNode('test', args, {}, 'meta')
         cache = {}
         nodes = {}
@@ -118,21 +117,20 @@
         self.node = _graph.DuplicatedLeafNode('test', 'meta')
 
     def test_truthiness(self):
         self.assertTrue(self.node)
 
     def test_generate_asciitree_nodes(self):
         cache = {}
-        graph_ids = {None: 'X', self.subgraph: 'Y'}
-        cnt = map(str, itertools.count())
+        graph_ids = {None: (f'%X{i}' for i in itertools.count()), self.subgraph: (f'%Y{i}' for i in itertools.count())}
         with self.subTest('first'):
-            self.assertEqual(list(self.node._generate_asciitree_nodes(cache, graph_ids, cnt, 'S', 'B')), [
+            self.assertEqual(list(self.node._generate_asciitree_nodes(cache, graph_ids, 'S', 'B')), [
                              'Stest\n'])
         with self.subTest('second'):
-            self.assertEqual(list(self.node._generate_asciitree_nodes(cache, graph_ids, cnt, 'S', 'B')), [
+            self.assertEqual(list(self.node._generate_asciitree_nodes(cache, graph_ids, 'S', 'B')), [
                              'Stest\n'])
 
     def test_collect_graphviz_nodes_edges(self):
         cache = {}
         nodes = {}
         edges = []
         cnt = map(str, itertools.count())
@@ -172,15 +170,15 @@
         self.node = _graph.InvisibleNode('meta')
 
     def test_truthiness(self):
         self.assertFalse(self.node)
 
     def test_generate_asciitree_nodes(self):
         cache = {}
-        self.assertEqual(list(self.node._generate_asciitree_nodes({}, {None: 'X'}, map(str, itertools.count()), 'S', 'B')), ['S\n'])
+        self.assertEqual(list(self.node._generate_asciitree_nodes({}, {None: (f'%X{i}' for i in itertools.count())}, 'S', 'B')), ['S\n'])
 
     def test_collect_graphviz_nodes_edges(self):
         cache = {}
         nodes = {}
         edges = []
         cnt = map(str, itertools.count())
         self.assertEqual(self.node._collect_graphviz_nodes_edges({}, map(str, itertools.count()), nodes, edges, None, None), None)
@@ -231,30 +229,30 @@
                          '| : %3 = b\n'
                          '|   : %2\n'
                          ': %2\n')
 
     def test_single_graphviz_source(self):
         self.assertEqual(self.single.generate_graphviz_source(),
                          'digraph {'
-                         'graph [dpi=72];'
+                         'bgcolor="darkgray";'
                          '0 [shape=box,label="d"];'
                          '1 [shape=box,label="c"];'
                          '2 [shape=box,label="a"];'
                          '3 [shape=box,label="b"];'
                          '2 -> 1;'
                          '2 -> 3;'
                          '3 -> 1;'
                          '1 -> 0;'
                          '2 -> 0;'
                          '}')
 
     def test_single_graphviz_source_fill_color(self):
         self.assertEqual(self.single.generate_graphviz_source(fill_color=lambda node: node.metadata),
                          'digraph {'
-                         'graph [dpi=72];'
+                         'bgcolor="darkgray";'
                          '0 [shape=box,label="d"];'
                          '1 [shape=box,label="c",style=filled,fillcolor="red"];'
                          '2 [shape=box,label="a"];'
                          '3 [shape=box,label="b"];'
                          '2 -> 1;'
                          '2 -> 3;'
                          '3 -> 1;'
@@ -268,37 +266,45 @@
                          'A\n'
                          '└ B = B\n'
                          '  ├ C = C\n'
                          '  │ └ D = E\n'
                          '  └ E = D\n'
                          'NODES\n'
                          '%A0 = j\n'
-                         '└ %D1 = i\n'
-                         '  ├ %D2 = e\n'
-                         '  │ └ %A3 = a\n'
-                         '  ├ %C4 = f\n'
-                         '  │ ├ %A5 = b\n'
-                         '  │ │ └ %A3\n'
-                         '  │ └ %D2\n'
-                         '  └ %E6 = g\n'
-                         '    └ %A3\n')
+                         '└ %D0 = i\n'
+                         '  ├ %D1 = e\n'
+                         '  │ └ %A1 = a\n'
+                         '  ├ %C0 = f\n'
+                         '  │ ├ %A2 = b\n'
+                         '  │ │ └ %A1\n'
+                         '  │ └ %D1\n'
+                         '  └ %E0 = g\n'
+                         '    └ %A1\n')
 
     def test_multiple_graphviz_source(self):
         self.assertEqual(self.multiple.generate_graphviz_source(),
                          'digraph {'
-                         'graph [dpi=72];'
+                         'bgcolor="darkgray";'
                          'subgraph cluster7 {'
+                         'bgcolor="lightgray";'
+                         'color="none";'
                          'subgraph cluster8 {'
+                         'bgcolor="lightgray";'
+                         'color="none";'
                          'subgraph cluster9 {'
+                         'bgcolor="lightgray";'
+                         'color="none";'
                          '1 [shape=box,label="i"];'
                          '2 [shape=box,label="e"];'
                          '}'
                          '4 [shape=box,label="f"];'
                          '}'
                          'subgraph cluster10 {'
+                         'bgcolor="lightgray";'
+                         'color="none";'
                          '6 [shape=box,label="g"];'
                          '}'
                          '}'
                          '0 [shape=box,label="j"];'
                          '3 [shape=box,label="a"];'
                          '5 [shape=box,label="b"];'
                          '3 -> 2;'
```

### Comparing `nutils-7.3/tests/test_ischeme.py` & `nutils-8.0/tests/test_ischeme.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,10 @@
-from nutils import *
-from nutils.testing import *
+from nutils import element
+from nutils.testing import TestCase, parametrize
+import numpy
 
 
 @parametrize
 class check(TestCase):
 
     def test(self):
         points, weights = self.ref.getischeme(self.ptype)
```

### Comparing `nutils-7.3/tests/test_matrix.py` & `nutils-8.0/tests/test_matrix.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh.py` & `nutils-8.0/tests/test_mesh.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,12 +1,11 @@
-from nutils import *
-import tempfile
+from nutils import mesh, function, element, transform, topology
+from nutils.testing import TestCase, parametrize, requires
 import pathlib
-import os
-from nutils.testing import *
+import numpy
 
 
 @parametrize
 class gmsh(TestCase):
 
     def setUp(self):
         super().setUp()
@@ -141,7 +140,63 @@
     def test_pum(self):
         for basistype in 'discont', 'std', 'spline':
             for degree in 1, 2, 3:
                 with self.subTest(basistype+str(degree)):
                     basis = self.domain.basis(basistype, degree=degree)
                     values = self.domain.interfaces.sample('uniform', 2).eval(basis*function.J(self.geom))
                     numpy.testing.assert_almost_equal(values.sum(1), 1)
+
+
+@parametrize
+class unitsquare(TestCase):
+
+    def setUp(self):
+        super().setUp()
+        self.domain, self.geom = mesh.unitsquare(nelems=4, etype=self.etype)
+
+    def test_volume(self):
+        self.assertAllAlmostEqual(self.domain.volume(self.geom), 1)
+
+    def test_boundaries(self):
+        self.assertAllAlmostEqual(self.domain.boundary.volume(self.geom), 4)
+        self.domain.check_boundary(geometry=self.geom)
+
+    def test_boundary_groups(self):
+        numpy.testing.assert_almost_equal(self.domain.boundary['left'].sample('gauss', 0).eval(self.geom[0]), 0)
+        numpy.testing.assert_almost_equal(self.domain.boundary['bottom'].sample('gauss', 0).eval(self.geom[1]), 0)
+        numpy.testing.assert_almost_equal(self.domain.boundary['right'].sample('gauss', 0).eval(self.geom[0]), 1)
+        numpy.testing.assert_almost_equal(self.domain.boundary['top'].sample('gauss', 0).eval(self.geom[1]), 1)
+
+    def test_interface(self):
+        geomerr = self.domain.interfaces.sample('uniform', 2).eval(self.geom - function.opposite(self.geom))
+        numpy.testing.assert_almost_equal(geomerr, 0, decimal=15)
+        normalerr = self.domain.interfaces.sample('uniform', 2).eval(self.geom.normal() + function.opposite(self.geom.normal()))
+        numpy.testing.assert_almost_equal(normalerr, 0, decimal=15)
+
+unitsquare(etype='square')
+unitsquare(etype='triangle')
+unitsquare(etype='mixed')
+unitsquare(etype='multipatch')
+
+
+@parametrize
+class unitcircle(TestCase):
+
+    def setUp(self):
+        super().setUp()
+        self.domain, self.geom = mesh.unitcircle(nelems=8, variant=self.variant)
+
+    def test_volume(self):
+        self.assertAllAlmostEqual(self.domain.volume(self.geom, degree=6), numpy.pi)
+
+    def test_boundaries(self):
+        self.assertAllAlmostEqual(self.domain.boundary.volume(self.geom, degree=6), 2 * numpy.pi)
+        self.domain.check_boundary(geometry=self.geom, degree=8)
+
+    def test_interface(self):
+        geomerr = self.domain.interfaces.sample('uniform', 2).eval(self.geom - function.opposite(self.geom))
+        numpy.testing.assert_almost_equal(geomerr, 0, decimal=15)
+        normalerr = self.domain.interfaces.sample('uniform', 2).eval(self.geom.normal() + function.opposite(self.geom.normal()))
+        numpy.testing.assert_almost_equal(normalerr, 0, decimal=14)
+
+unitcircle(variant='rectilinear')
+unitcircle(variant='multipatch')
```

### Comparing `nutils-7.3/tests/test_mesh/mesh2d.geo` & `nutils-8.0/tests/test_mesh/mesh2d.geo`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh2d_p1_v2.msh` & `nutils-8.0/tests/test_mesh/mesh2d_p1_v2.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh2d_p1_v4.msh` & `nutils-8.0/tests/test_mesh/mesh2d_p1_v4.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh2d_p2_v2.msh` & `nutils-8.0/tests/test_mesh/mesh2d_p2_v2.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh2d_p2_v4.msh` & `nutils-8.0/tests/test_mesh/mesh2d_p2_v4.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh2d_p3_v2.msh` & `nutils-8.0/tests/test_mesh/mesh2d_p3_v2.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh2d_p3_v4.msh` & `nutils-8.0/tests/test_mesh/mesh2d_p3_v4.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh2d_p4_v2.msh` & `nutils-8.0/tests/test_mesh/mesh2d_p4_v2.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh2d_p4_v4.msh` & `nutils-8.0/tests/test_mesh/mesh2d_p4_v4.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3d.geo` & `nutils-8.0/tests/test_mesh/mesh3d.geo`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3d_p1_v2.msh` & `nutils-8.0/tests/test_mesh/mesh3d_p1_v2.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3d_p1_v4.msh` & `nutils-8.0/tests/test_mesh/mesh3d_p1_v4.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3d_p2_v2.msh` & `nutils-8.0/tests/test_mesh/mesh3d_p2_v2.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3d_p2_v4.msh` & `nutils-8.0/tests/test_mesh/mesh3d_p2_v4.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3dmani.geo` & `nutils-8.0/tests/test_mesh/mesh3dmani.geo`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3dmani_p1_v2.msh` & `nutils-8.0/tests/test_mesh/mesh3dmani_p1_v2.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3dmani_p1_v4.msh` & `nutils-8.0/tests/test_mesh/mesh3dmani_p1_v4.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3dmani_p2_v2.msh` & `nutils-8.0/tests/test_mesh/mesh3dmani_p2_v2.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_mesh/mesh3dmani_p2_v4.msh` & `nutils-8.0/tests/test_mesh/mesh3dmani_p2_v4.msh`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_normals.py` & `nutils-8.0/tests/test_normals.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,25 @@
-from nutils import *
-from nutils.testing import *
+from nutils import function, mesh
+from nutils.testing import TestCase, parametrize
+import numpy
 
 
 @parametrize
 class check(TestCase):
 
     def setUp(self):
         super().setUp()
         if not self.curved:
             self.domain, self.geom = mesh.rectilinear([[1, 1.5, 2], [-1, 0], [0, 2, 4]][:self.ndims])
             self.curv = 0
         else:
             assert self.ndims == 2
             nodes = numpy.linspace(-.25*numpy.pi, .25*numpy.pi, 3)
             self.domain, (xi, eta) = mesh.rectilinear([nodes, nodes])
-            self.geom = numpy.sqrt(2) * function.stack([function.sin(xi) * function.cos(eta), function.cos(xi) * function.sin(eta)])
+            self.geom = numpy.sqrt(2) * numpy.stack([function.sin(xi) * function.cos(eta), function.cos(xi) * function.sin(eta)])
             self.curv = 1
 
     def zero(self):
         zero = self.domain.boundary.integrate(self.geom.normal()*function.J(self.geom), ischeme='gauss9')
         numpy.testing.assert_almost_equal(zero, 0)
 
     def volume(self):
```

### Comparing `nutils-7.3/tests/test_parallel.py` & `nutils-8.0/tests/test_parallel.py`

 * *Files 5% similar despite different names*

```diff
@@ -15,16 +15,16 @@
     def setUp(self):
         super().setUp()
         self.enter_context(parallel.maxprocs(3))
         _builtin_warnings.filterwarnings('ignore', 'fork is unavailable on this platform', warnings.NutilsWarning)
 
     def test_maxprocs(self):
         with parallel.maxprocs(4):
-            self.assertEqual(parallel._maxprocs.value, 4)
-        self.assertEqual(parallel._maxprocs.value, 3)
+            self.assertEqual(parallel.maxprocs.current, 4)
+        self.assertEqual(parallel.maxprocs.current, 3)
 
     def test_fork(self):
         mask = multiprocessing.RawValue('i', 0)
         lock = multiprocessing.Lock()
         with parallel.fork() as procid, lock:
             mask.value |= 1 << procid
         self.assertEqual(mask.value, 0b111 if canfork else 1)
```

### Comparing `nutils-7.3/tests/test_points.py` & `nutils-8.0/tests/test_points.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,9 +1,10 @@
-from nutils import *
-from nutils.testing import *
+from nutils import element, points, transform, numeric
+from nutils.testing import TestCase, parametrize
+import numpy
 
 
 class gauss(TestCase):
 
     def test_line(self):
         line = element.getsimplex(1)
         for degree in range(1, 8):
@@ -93,57 +94,19 @@
     def test_pyramid(self):
         pyramid = element.getsimplex(1)*element.getsimplex(2)
         for n in range(2, 8):
             bezier = pyramid.getpoints('bezier', n)
             self.assertEqual(bezier.npoints, n*(n*(n+1))//2)
             self.assertEqual(len(bezier.tri), 3*(n-1)**3)
             self.assertEqual(len(bezier.hull), 8*(n-1)**2)
-            fullhull = super(points.TensorPoints, bezier).hull.tolist()  # contains additional internal faces for n >= 3
+            fullhull = points.Points.hull.func(bezier).tolist() # contains additional internal faces for n >= 3
             for h in bezier.hull:  # assert that hull is a subset of fullfull
                 self.assertIn(sorted(h), fullhull)
 
 
-@parametrize
-class cone(TestCase):
-
-    def setUp(self):
-        super().setUp()
-        if self.shape == 'square':
-            self.edgeref = element.getsimplex(1)**2
-        elif self.shape == 'triangle':
-            self.edgeref = element.getsimplex(2)
-        else:
-            raise Exception('invalid shape: {!r}'.format(self.shape))
-        self.etrans = transform.Updim(linear=[[-1., 0], [0, -3], [0, 0]], offset=[1., 3, 1], isflipped=False)
-        self.cone = element.Cone(edgeref=self.edgeref, etrans=self.etrans, tip=[1., 3, 0])
-
-    def test_volume(self):
-        numpy.testing.assert_almost_equal(actual=self.cone.volume, desired=self.edgeref.volume)
-
-    def _test_points(self, *args):
-        points = self.cone.getpoints(*args)
-        if hasattr(points, 'weights'):
-            numpy.testing.assert_almost_equal(actual=self.cone.volume, desired=points.weights.sum())
-        # check that all points lie within pyramid/prism
-        x, y, z = points.coords.T
-        self.assertTrue(numpy.all(numpy.greater_equal(x, 1-z) & numpy.less_equal(x, 1) & numpy.greater_equal(y, 1-z) & numpy.less_equal(y, 3)))
-        if self.shape == 'triangle':
-            self.assertTrue(numpy.less_equal(2-x-y/3, z).all())
-
-    def test_gauss(self):
-        self._test_points('gauss', 3)
-
-    def test_uniform(self):
-        self._test_points('uniform', 3)
-
-
-cone(shape='square')
-cone(shape='triangle')
-
-
 class trimmed(TestCase):
 
     def setUp(self):
         super().setUp()
         quad = element.getsimplex(1)**2
         levels = numeric.overlapping(numpy.arange(-1, 16, 2), n=5)  # linear ramp cutting at x + y == .125
         trimmed = quad.trim(levels.ravel(), maxrefine=2, ndivisions=16)
@@ -160,21 +123,20 @@
 
     def test_weights(self):
         exact = 1-.5*.125**2
         for pnt in self.gauss, self.uniform:
             self.assertLess(abs(pnt.weights.sum()-exact), 1e-15)
 
     def test_points(self):
-        self.assertEqual(self.bezier.npoints, 27)
+        self.assertEqual(self.bezier.npoints, 26)
         for x in [0., .25, .5, .75, 1.]:
             for y in [0., .25, .5, .75, 1.]:
                 if x or y:
                     self.assertIn([x, y], self.bezier.coords.tolist())
         self.assertIn([0., .125], self.bezier.coords.tolist())
-        self.assertIn([.0625, .0625], self.bezier.coords.tolist())
         self.assertIn([.125, 0.], self.bezier.coords.tolist())
 
     def test_tri(self):
-        self.assertEqual(len(self.bezier.tri), 34)
+        self.assertEqual(len(self.bezier.tri), 33)
 
     def test_hull(self):
-        self.assertEqual(len(self.bezier.hull), 18)
+        self.assertEqual(len(self.bezier.hull), 17)
```

### Comparing `nutils-7.3/tests/test_pointsseq.py` & `nutils-8.0/tests/test_pointsseq.py`

 * *Files 0% similar despite different names*

```diff
@@ -146,28 +146,28 @@
     def test_get_evaluable_coords(self):
         coordinates = self.seq.get_evaluable_coords(nutils.evaluable.Argument('index', (), int))
         for index, points in enumerate(self.check):
             self.assertAllEqual(coordinates.eval(index=index), points.coords)
 
     def test_get_evaluable_coords_invalid_ndims(self):
         with self.assertRaises(ValueError):
-            self.seq.get_evaluable_coords(nutils.evaluable.Argument('index', (1,), int))
+            self.seq.get_evaluable_coords(nutils.evaluable.Argument('index', (nutils.evaluable.constant(1),), int))
 
     def test_get_evaluable_coords_invalid_dtype(self):
         with self.assertRaises(ValueError):
             self.seq.get_evaluable_coords(nutils.evaluable.Argument('index', (), float))
 
     def test_get_evaluable_weights(self):
         weights = self.seq.get_evaluable_weights(nutils.evaluable.Argument('index', (), int))
         for index, points in enumerate(self.check):
             self.assertAllEqual(weights.eval(index=index), points.weights)
 
     def test_get_evaluable_weights_invalid_ndims(self):
         with self.assertRaises(ValueError):
-            self.seq.get_evaluable_weights(nutils.evaluable.Argument('index', (1,), int))
+            self.seq.get_evaluable_weights(nutils.evaluable.Argument('index', (nutils.evaluable.constant(1),), int))
 
     def test_get_evaluable_weights_invalid_dtype(self):
         with self.assertRaises(ValueError):
             self.seq.get_evaluable_weights(nutils.evaluable.Argument('index', (), float))
 
 
 class TriHull:
```

### Comparing `nutils-7.3/tests/test_quadrature.py` & `nutils-8.0/tests/test_quadrature.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,11 @@
-from nutils import *
-from nutils.testing import *
+from nutils import element
+from nutils.testing import TestCase, parametrize
 import math
-import re
+import numpy
 
 
 @parametrize
 class gauss(TestCase):
     # Gaussian quadrature and exact integration on different element types
     maxdegree = 7
     exclude = frozenset()
```

### Comparing `nutils-7.3/tests/test_sample.py` & `nutils-8.0/tests/test_sample.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,16 +1,15 @@
-from nutils import *
-import random
-import itertools
-import functools
-import warnings as _builtin_warnings
-from nutils.testing import *
-from nutils.sample import Sample
+from nutils import element, mesh, function, _util as util, evaluable, warnings, sparse
+from nutils.testing import TestCase, parametrize
+from nutils.sample import Sample, eval_integrals, eval_integrals_sparse
 from nutils.pointsseq import PointsSequence
 from nutils.transformseq import IndexTransforms
+import functools
+import warnings as _builtin_warnings
+import numpy
 
 
 class Common:
 
     @property
     def desired_npoints(self):
         return sum(util.product(p.npoints for p in points) for points in self.desired_points)
@@ -50,33 +49,34 @@
     def test_get_evaluable_weights(self):
         assert len(self.desired_points) == self.desired_nelems
         actual = self.sample.get_evaluable_weights(evaluable.Argument('ielem', (), int))
         for ielem, points in enumerate(self.desired_points):
             desired = functools.reduce(lambda l, r: numpy.einsum('...,i->...i', l, r), (p.weights for p in points))
             self.assertAllAlmostEqual(actual.eval(ielem=ielem).tolist(), desired.tolist())
 
-    def test_update_lower_args(self):
+    def test_get_lower_args(self):
         assert len(self.desired_transform_chains) == len(self.desired_points) == self.desired_nelems
-        points_shape, transform_chains, coords = self.sample.update_lower_args(evaluable.Argument('ielem', (), int), (), {}, {})
+        args = self.sample.get_lower_args(evaluable.Argument('ielem', (), int))
         for ielem, (desired_chains, desired_points) in enumerate(zip(self.desired_transform_chains, self.desired_points)):
             assert len(desired_chains) == len(desired_points) == len(self.desired_spaces)
             desired_shape = tuple(p.coords.shape[0] for p in desired_points)
-            actual_shape = tuple(n.__index__() for n in evaluable.Tuple(points_shape).eval(ielem=ielem))
+            actual_shape = tuple(n.__index__() for n in evaluable.Tuple(args.points_shape).eval(ielem=ielem))
             self.assertEqual(actual_shape, desired_shape)
             offset = 0
             for space, desired_chain, desired_point in zip(self.desired_spaces, desired_chains, desired_points):
-                self.assertEqual(transform_chains[space][0].eval(ielem=ielem), desired_chain)
+                (chain, *_), index = args.transform_chains[space]
+                self.assertEqual(chain[index.eval(ielem=ielem).__index__()], desired_chain)
                 desired_coords = desired_point.coords
-                desired_coords = numpy.lib.stride_tricks.as_strided(desired_coords, shape=(*desired_shape, desired_point.ndims,), strides=(0,)*offset+desired_coords.strides[:-1]+(0,)*(len(points_shape)-offset-desired_coords.ndim+1)+desired_coords.strides[-1:])
-                actual_coords = coords[space].eval(ielem=ielem)
+                desired_coords = numpy.lib.stride_tricks.as_strided(desired_coords, shape=(*desired_shape, desired_point.ndims,), strides=(0,)*offset+desired_coords.strides[:-1]+(0,)*(len(args.points_shape)-offset-desired_coords.ndim+1)+desired_coords.strides[-1:])
+                actual_coords = args.coordinates[space].eval(ielem=ielem)
                 self.assertEqual(actual_coords.shape, desired_coords.shape)
                 self.assertAllAlmostEqual(actual_coords, desired_coords)
                 offset += desired_point.coords.ndim - 1
         with self.assertRaisesRegex(ValueError, '^Nested'):
-            self.sample.update_lower_args(evaluable.Argument('ielem2', (), int), points_shape, transform_chains, coords)
+            args | self.sample.get_lower_args(evaluable.Argument('ielem2', (), int))
 
     @property
     def _desired_element_tri(self):
         assert len(self.desired_points) == self.desired_nelems
         for p in self.desired_points:
             yield util.product(p).tri.tolist()
 
@@ -122,17 +122,18 @@
         self.assertEqual(sorted(actual.tolist()), sorted(desired))
 
     def test_take_elements_single(self):
         for ielem in range(self.desired_nelems):
             take = self.sample.take_elements(numpy.array([ielem]))
             self.assertEqual(take.nelems, 1)
             self.assertEqual(take.ndims, self.desired_ndims)
-            points_shape, transform_chains, coords = take.update_lower_args(evaluable.Argument('ielem', (), int), (), {}, {})
+            args = take.get_lower_args(evaluable.Argument('ielem', (), int))
             for space, desired_chain in zip(self.desired_spaces, self.desired_transform_chains[ielem]):
-                self.assertEqual(transform_chains[space][0].eval(ielem=0), desired_chain)
+                (chain, *_), index = args.transform_chains[space]
+                self.assertEqual(chain[index.eval(ielem=0).__index__()], desired_chain)
 
     def test_take_elements_empty(self):
         take = self.sample.take_elements(numpy.array([], int))
         self.assertEqual(take.nelems, 0)
         self.assertEqual(take.npoints, 0)
 
     def test_ones_at(self):
@@ -158,15 +159,15 @@
         self.desired_nelems = 0
         self.desired_transform_chains = ()
         self.desired_points = ()
         self.desired_indices = ()
         self.desired_tri = ()
         self.desired_hull = ()
 
-    def test_update_lower_args(self):
+    def test_get_lower_args(self):
         pass
 
 
 class Add(TestCase, Common):
 
     def setUp(self):
         super().setUp()
@@ -188,17 +189,17 @@
         with self.assertRaises(NotImplementedError):
             super().test_get_evaluable_indices()
 
     def test_get_evaluable_weights(self):
         with self.assertRaises(NotImplementedError):
             super().test_get_evaluable_weights()
 
-    def test_update_lower_args(self):
+    def test_get_lower_args(self):
         with self.assertRaises(NotImplementedError):
-            super().test_update_lower_args()
+            super().test_get_lower_args()
 
     def test_asfunction(self):
         with self.assertRaises(NotImplementedError):
             super().test_asfunction()
 
 
 class Mul(TestCase, Common):
@@ -275,15 +276,15 @@
         self.assertAllAlmostEqual(geomX, geomY[:, numpy.newaxis] * self.slope)
 
     def test_integrate(self):
         self.assertAlmostEqual(self.stitched.integrate(function.J(self.geomY)), 1)
         self.assertAlmostEqual(self.stitched.integrate(function.J(self.geomX)), 5/9)  # NOTE: != norm(slope)
 
     def test_nested(self):
-        with self.assertRaisesRegex(ValueError, 'Nested integrals or samples in the same space are not supported.'):
+        with self.assertRaisesRegex(ValueError, 'Nested integrals or samples in the same space: X, Y.'):
             self.stitched.integral(self.stitched.integral(1)).eval()
         topoZ, geomZ = mesh.line(2, space='Z')
         inner = self.stitched.integral((geomZ - self.geomX) * function.J(self.geomY))
         outer = topoZ.integral(inner * function.J(geomZ), degree=2)
         self.assertAllAlmostEqual(outer.eval(), 2 - self.slope)  # ∫_0^2 dz ∫_0^1 (z - α x) dx = ∫_0^2 (z - .5 α) dz = 2 - α
 
     def test_triplet(self):
@@ -371,14 +372,34 @@
         self.assertAllAlmostEqual(actual, desired)
 
     def test_basis(self):
         with _builtin_warnings.catch_warnings():
             _builtin_warnings.simplefilter('ignore', category=evaluable.ExpensiveEvaluationWarning)
             self.assertAllAlmostEqual(self.sample(self.sample.basis()).as_evaluable_array.eval(), numpy.eye(11))
 
+    def test_basis_nearest(self):
+        unisample = Sample.new('a', (self.transforms, self.transforms),
+            PointsSequence.uniform((element.getsimplex(1)**2).getpoints('uniform', 2), 3))
+        self.assertEqual(unisample.npoints, 12)
+        coords = function.rootcoords('a', 2)
+        bezierpoints = self.sample.eval(coords)
+        uniformpoints = unisample.eval(coords)
+        # Unisample consists of 3 times 4 points occupying the centers of the
+        # four quadrants of a square. The four bezier points of the first and
+        # last square element of self.sample map to the corresponding uniform
+        # points of unisample. The three bezier points of the middle triangular
+        # element map to uniform points 0, 2, and 1 of unisample.
+        nearest = numpy.concatenate([
+            u1 + numpy.linalg.norm(bezierpoints[b1:b2,numpy.newaxis] - uniformpoints[numpy.newaxis,u1:u2], axis=-1).argmin(1)
+                for (b1, u1), (b2, u2) in util.pairwise([(0, 0), (4, 4), (7, 8), (11, 12)])])
+        self.assertAllEqual(nearest, [0, 1, 2, 3, 4, 6, 5, 8, 9, 10, 11])
+        with _builtin_warnings.catch_warnings():
+            _builtin_warnings.simplefilter('ignore', category=evaluable.ExpensiveEvaluationWarning)
+            self.assertAllAlmostEqual(self.sample(unisample.basis(interpolation='nearest')).as_evaluable_array.eval(), numpy.eye(12)[nearest])
+
 
 class CustomIndex(TestCase, Common):
 
     def setUp(self):
         super().setUp()
         line = element.getsimplex(1)
         triangle = element.getsimplex(2)
@@ -490,15 +511,15 @@
 
     def test_asfunction(self):
         func = sum(self.geom**2)
         gauss = self.topo.sample('gauss', 2)
         values = gauss.eval(func)
         sampled = gauss.asfunction(values)
         bezier = self.topo.sample('bezier', 2)
-        with self.assertRaises(evaluable.EvaluationError):
+        with self.assertRaises(ValueError):
             bezier.eval(sampled)
         self.assertAllEqual(gauss.eval(sampled), values)
         arg = function.Argument('dofs', [2, 3])
         self.assertTrue(evaluable.iszero(evaluable.asarray(gauss(function.derivative(sampled, arg)))))
 
 rectilinear(shape=(4,))
 rectilinear(shape=(4,3))
@@ -519,20 +540,21 @@
     def test_eval(self):
         self.assertAllAlmostEqual(
             self.topo.integrate('basis_n d:x' @ self.ns, degree=2),
             self.topo.integral('basis_n d:x' @ self.ns, degree=2).eval(),
             places=15)
 
     def test_eval_integrals(self):
-        v, = sample.eval_integrals(self.topo.integral('basis_n d:x' @ self.ns, degree=2))
+        with self.assertWarns(warnings.NutilsDeprecationWarning):
+            v, = eval_integrals(self.topo.integral('basis_n d:x' @ self.ns, degree=2))
         self.assertAllAlmostEqual(self.topo.integrate('basis_n d:x' @ self.ns, degree=2), v, places=15)
 
     def test_eval_integrals_sparse(self):
         with self.assertWarns(warnings.NutilsDeprecationWarning):
-            data, = sample.eval_integrals_sparse(self.topo.integral('basis_n d:x' @ self.ns, degree=2))
+            data, = eval_integrals_sparse(self.topo.integral('basis_n d:x' @ self.ns, degree=2))
         self.assertAllAlmostEqual(self.topo.integrate('basis_n d:x' @ self.ns, degree=2), sparse.toarray(data), places=15)
 
     def test_args(self):
         self.assertAlmostEqual(
             self.topo.integrate('v d:x' @ self.ns, degree=2, arguments=dict(lhs=self.lhs)),
             self.topo.integral('v d:x' @ self.ns, degree=2).eval(lhs=self.lhs),
             places=15)
```

### Comparing `nutils-7.3/tests/test_solver.py` & `nutils-8.0/tests/test_solver.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,32 +1,59 @@
-from nutils import solver, mesh, function, cache, types, numeric, warnings, evaluable, sparse
-from nutils.testing import *
+from nutils import solver, mesh, function, cache, types, evaluable, sparse
+from nutils.expression_v2 import Namespace
+from nutils.testing import TestCase, parametrize
 import numpy
 import contextlib
 import tempfile
-import itertools
 import logging
 
 
 @contextlib.contextmanager
 def tmpcache():
     with tempfile.TemporaryDirectory() as tmpdir:
         with cache.enable(tmpdir):
             yield
 
 
+def _edit(v):
+    return (v.tolist() if isinstance(v, numpy.ndarray)
+        else tuple(map(_edit, v)) if isinstance(v, tuple)
+        else {k: _edit(v) for (k, v) in v.items()} if isinstance(v, dict)
+        else v) # convert arrays to lists so we can use assertEqual
+
+
 def _test_recursion_cache(testcase, solver_iter):
-    edit = lambda v: v.tolist() if numeric.isarray(v) else tuple(map(edit, v)) if isinstance(v, tuple) else v  # convert arrays to lists
-    read = lambda n: tuple(edit(item) for i, item in zip(range(n), solver_iter()))
+    read = lambda n: tuple(_edit(item) for i, item in zip(range(n), solver_iter()))
     reference = read(5)
     for lengths in [1, 2, 3], [1, 3, 2], [0, 3, 5]:
         with tmpcache():
             for i, length in enumerate(lengths):
                 with testcase.subTest(lengths=lengths, step=i):
-                    testcase.assertEqual(read(length), reference[:length])
+                    if length == 0: # treated as special case because assertLogs would fail
+                        read(0)
+                        continue
+                    with testcase.assertLogs('nutils', 'DEBUG') as cm:
+                        v = read(length)
+                    testcase.assertEqual(v, reference[:length])
+                    testcase.assertRegex('\n'.join(cm.output), '\[cache\.Recursion [0-9a-f]{40}\] start iterating')
+                    testcase.assertRegex('\n'.join(cm.output), '\[cache\.Recursion [0-9a-f]{40}\.0000\] load' if i and max(lengths[:i]) > 0
+                                                          else '\[cache\.Recursion [0-9a-f]{40}\.0000\] cache exhausted')
+
+
+def _test_solve_cache(testcase, solver_gen):
+    _test_recursion_cache(testcase, solver_gen)
+    with testcase.subTest('solve'), tmpcache():
+        v1 = _edit(solver_gen().solve(1e-5))
+        with testcase.assertLogs('nutils', 'DEBUG') as cm:
+            v2, info = _edit(solver_gen().solve_withinfo(1e-5))
+        testcase.assertEqual(v1, v2)
+        testcase.assertRegex('\n'.join(cm.output), '\[cache\.function [0-9a-f]{40}\] load')
+        with testcase.assertLogs('nutils', 'DEBUG') as cm:
+            solver_gen().solve(1e-6)
+        testcase.assertRegex('\n'.join(cm.output), '\[cache\.function [0-9a-f]{40}\] failed to load')
 
 
 class laplace(TestCase):
 
     def setUp(self):
         super().setUp()
         domain, geom = mesh.rectilinear([8, 8])
@@ -39,20 +66,40 @@
 
     def test_res(self):
         for name in 'direct', 'newton':
             with self.subTest(name):
                 if name == 'direct':
                     lhs = solver.solve_linear('dofs', residual=self.residual, constrain=self.cons)
                 else:
-                    lhs = solver.newton('dofs', residual=self.residual, constrain=self.cons).solve(tol=1e-10, maxiter=0)
+                    lhs = solver.newton('dofs', residual=self.residual, constrain=self.cons).solve(tol=1e-10, maxiter=1)
                 res = self.residual.eval(arguments=dict(dofs=lhs))
                 resnorm = numpy.linalg.norm(res[~self.cons.where])
                 self.assertLess(resnorm, 1e-13)
 
 
+class laplace_field(TestCase):
+
+    def setUp(self):
+        super().setUp()
+        domain, geom = mesh.rectilinear([8, 8])
+        basis = domain.basis('std', degree=1)
+        u = function.dotarg('u', basis)
+        v = function.dotarg('v', basis)
+        sqr = domain.boundary['left'].integral(u**2, degree=2)
+        self.cons = solver.optimize('u,', sqr)
+        self.residual = domain.integral((v.grad(geom) @ u.grad(geom))*function.J(geom), degree=2) \
+            + domain.boundary['top'].integral(v*function.J(geom), degree=2)
+
+    def test_res(self):
+        args = solver.solve_linear('u:v', residual=self.residual, constrain=self.cons)
+        res = self.residual.derivative('v').eval(**args)
+        resnorm = numpy.linalg.norm(res[numpy.isnan(self.cons['u'])])
+        self.assertLess(resnorm, 1e-13)
+
+
 @parametrize
 class navierstokes(TestCase):
 
     viscosity = 1e-3
 
     def setUp(self):
         super().setUp()
@@ -61,16 +108,16 @@
         uin = geom[1] * (1-geom[1])
         dx = function.J(geom)
         ubasis = domain.basis('std', degree=2)
         pbasis = domain.basis('std', degree=1)
         if self.single:
             ubasis, pbasis = function.chain([ubasis.vector(2), pbasis])
             dofs = function.Argument('dofs', [len(ubasis)])
-            u = ubasis.dot(dofs)
-            p = pbasis.dot(dofs)
+            u = dofs @ ubasis
+            p = dofs @ pbasis
             dofs = 'dofs'
             ures = gauss.integral((self.viscosity * (ubasis.grad(geom) * (u.grad(geom) + u.grad(geom).T)).sum([-1, -2]) - ubasis.div(geom) * p) * dx)
             dres = gauss.integral((ubasis * (u.grad(geom) * u).sum(-1)).sum(-1) * dx)
         else:
             u = (ubasis[:, numpy.newaxis] * function.Argument('dofs', [len(ubasis), 2])).sum(0)
             p = (pbasis * function.Argument('pdofs', [len(pbasis)])).sum(0)
             dofs = 'dofs', 'pdofs'
@@ -83,72 +130,74 @@
         stokes = solver.solve_linear(dofs, residual=ures + pres if self.single else [ures, pres], constrain=self.cons)
         self.arguments = dict(dofs=stokes) if self.single else stokes
         self.residual = ures + dres + pres if self.single else [ures + dres, pres]
         inertia = gauss.integral(.5 * (u**2).sum(-1) * dx).derivative('dofs')
         self.inertia = inertia if self.single else [inertia, None]
         self.tol = 1e-10
         self.dofs = dofs
-        self.frozen = types.frozenarray if self.single else solver.argdict
 
     def assert_resnorm(self, lhs):
         res = self.residual.eval(arguments=dict(dofs=lhs))[numpy.isnan(self.cons)] if self.single \
             else numpy.concatenate([sparse.toarray(sparse.take(r, [numpy.isnan(self.cons[d])]) if d in self.cons else r)
                                     for d, r in zip(self.dofs, evaluable.eval_sparse(self.residual, **lhs))])
         resnorm = numpy.linalg.norm(res)
         self.assertLess(resnorm, self.tol)
 
     def test_direct(self):
         with self.assertRaises(solver.SolverError):
             solver.solve_linear(self.dofs, residual=self.residual, constrain=self.cons)
 
     def test_newton(self):
-        self.assert_resnorm(solver.newton(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons).solve(tol=self.tol, maxiter=2))
+        self.assert_resnorm(solver.newton(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons).solve(tol=self.tol, maxiter=3))
+
+    def test_newton_vanilla(self):
+        self.assert_resnorm(solver.newton(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, linesearch=None).solve(tol=self.tol, maxiter=3))
 
     def test_newton_medianbased(self):
-        self.assert_resnorm(solver.newton(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, linesearch=solver.MedianBased()).solve(tol=self.tol, maxiter=2))
+        self.assert_resnorm(solver.newton(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, linesearch=solver.MedianBased()).solve(tol=self.tol, maxiter=3))
 
     def test_newton_relax0(self):
-        self.assert_resnorm(solver.newton(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, relax0=.1).solve(tol=self.tol, maxiter=5))
+        self.assert_resnorm(solver.newton(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, relax0=.1).solve(tol=self.tol, maxiter=6))
 
     def test_newton_tolnotreached(self):
         with self.assertLogs('nutils', logging.WARNING) as cm:
-            self.assert_resnorm(solver.newton(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, linrtol=1e-99).solve(tol=self.tol, maxiter=2))
+            self.assert_resnorm(solver.newton(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, linrtol=1e-99).solve(tol=self.tol, maxiter=3))
         for msg in cm.output:
             self.assertIn('solver failed to reach tolerance', msg)
 
-    def test_newton_iter(self):
-        _test_recursion_cache(self, lambda: ((self.frozen(lhs), info.resnorm) for lhs, info in solver.newton(self.dofs, residual=self.residual, constrain=self.cons)))
+    def test_newton_cache(self):
+        _test_solve_cache(self, lambda: solver.newton(self.dofs, residual=self.residual, constrain=self.cons))
 
     def test_pseudotime(self):
         self.assert_resnorm(solver.pseudotime(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, inertia=self.inertia, timestep=1).solve(tol=self.tol, maxiter=12))
 
-    def test_pseudotime_iter(self):
-        _test_recursion_cache(self, lambda: ((self.frozen(lhs), info.resnorm) for lhs, info in solver.pseudotime(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, inertia=self.inertia, timestep=1)))
+    def test_pseudotime_cache(self):
+        _test_solve_cache(self, lambda: solver.pseudotime(self.dofs, residual=self.residual, arguments=self.arguments, constrain=self.cons, inertia=self.inertia, timestep=1))
 
 
 navierstokes(single=False)
 navierstokes(single=True)
 
 
 @parametrize
 class finitestrain(TestCase):
 
     def setUp(self):
         super().setUp()
         domain, geom = mesh.rectilinear([numpy.linspace(0, 1, 9)] * 2)
         ubasis = domain.basis('std', degree=2)
         if self.vector:
-            u = ubasis.vector(2).dot(function.Argument('dofs', [len(ubasis)*2]))
+            u = function.dotarg('dofs', ubasis.vector(2))
         else:
-            u = (ubasis[:, numpy.newaxis] * function.Argument('dofs', [len(ubasis), 2])).sum(0)
+            u = function.dotarg('dofs', ubasis, shape=(2,))
         Geom = geom * [1.1, 1] + u
         self.cons = solver.optimize('dofs', domain.boundary['left,right'].integral((u**2).sum(0), degree=4), droptol=1e-15)
         self.boolcons = ~numpy.isnan(self.cons)
         strain = .5 * (function.outer(Geom.grad(geom), axis=1).sum(0) - function.eye(2))
-        self.energy = domain.integral(((strain**2).sum([0, 1]) + 20*(function.determinant(Geom.grad(geom))-1)**2)*function.J(geom), degree=6)
+        self.energy = domain.integral(((strain**2).sum([0, 1]) + 20*(numpy.linalg.det(Geom.grad(geom))-1)**2)*function.J(geom), degree=6)
         self.residual = self.energy.derivative('dofs')
         self.tol = 1e-10
 
     def assert_resnorm(self, lhs):
         res = evaluable.eval_sparse(self.residual, dofs=lhs)
         resnorm = numpy.linalg.norm(sparse.toarray(res)[~self.boolcons])
         self.assertLess(resnorm, self.tol)
@@ -156,56 +205,59 @@
     def test_direct(self):
         with self.assertRaises(solver.SolverError):
             self.assert_resnorm(solver.solve_linear('dofs', residual=self.residual, constrain=self.cons))
 
     def test_newton(self):
         self.assert_resnorm(solver.newton('dofs', residual=self.residual, constrain=self.cons).solve(tol=self.tol, maxiter=7))
 
+    def test_newton_vanilla(self):
+        self.assert_resnorm(solver.newton('dofs', residual=self.residual, constrain=self.cons, linesearch=None).solve(tol=self.tol, maxiter=7))
+
     def test_newton_boolcons(self):
         self.assert_resnorm(solver.newton('dofs', residual=self.residual, constrain=self.boolcons).solve(tol=self.tol, maxiter=7))
 
-    def test_newton_iter(self):
-        _test_recursion_cache(self, lambda: ((types.frozenarray(lhs), info.resnorm) for lhs, info in solver.newton('dofs', residual=self.residual, constrain=self.cons)))
+    def test_newton_cache(self):
+        _test_solve_cache(self, lambda: solver.newton('dofs', residual=self.residual, constrain=self.cons))
 
     def test_minimize(self):
-        self.assert_resnorm(solver.minimize('dofs', energy=self.energy, constrain=self.cons).solve(tol=self.tol, maxiter=12))
+        self.assert_resnorm(solver.minimize('dofs', energy=self.energy, constrain=self.cons).solve(tol=self.tol, maxiter=13))
 
     def test_minimize_boolcons(self):
-        self.assert_resnorm(solver.minimize('dofs', energy=self.energy, constrain=self.boolcons).solve(tol=self.tol, maxiter=12))
+        self.assert_resnorm(solver.minimize('dofs', energy=self.energy, constrain=self.boolcons).solve(tol=self.tol, maxiter=13))
 
-    def test_minimize_iter(self):
-        _test_recursion_cache(self, lambda: ((types.frozenarray(lhs), info.resnorm) for lhs, info in solver.minimize('dofs', energy=self.energy, constrain=self.cons)))
+    def test_minimize_cache(self):
+        _test_solve_cache(self, lambda: solver.minimize('dofs', energy=self.energy, constrain=self.cons))
 
 
 finitestrain(vector=False)
 finitestrain(vector=True)
 
 
 class optimize(TestCase):
 
     def setUp(self):
         super().setUp()
-        self.ns = function.Namespace()
-        self.domain, self.ns.geom = mesh.rectilinear([2, 2])
-        self.ns.ubasis = self.domain.basis('std', degree=1)
-        self.ns.u = 'ubasis_n ?dofs_n'
+        self.domain, geom = mesh.rectilinear([2, 2])
+        self.ubasis = self.domain.basis('std', degree=1)
+        self.ns = Namespace()
+        self.ns.u = function.dotarg('dofs', self.ubasis)
 
     def test_linear(self):
         err = self.domain.boundary['bottom'].integral('(u - 1)^2' @ self.ns, degree=2)
         cons = solver.optimize('dofs', err, droptol=1e-15)
         numpy.testing.assert_almost_equal(cons, numpy.take([1, numpy.nan], [0, 1, 1, 0, 1, 1, 0, 1, 1]), decimal=15)
 
     def test_nonlinear(self):
-        err = self.domain.boundary['bottom'].integral('(u + .25 u^3 - 1.25)^2 d:geom' @ self.ns, degree=6)
+        err = self.domain.boundary['bottom'].integral('(u + .25 u^3 - 1.25)^2' @ self.ns, degree=6)
         cons = solver.optimize('dofs', err, droptol=1e-15, tol=1e-15)
         numpy.testing.assert_almost_equal(cons, numpy.take([1, numpy.nan], [0, 1, 1, 0, 1, 1, 0, 1, 1]), decimal=15)
 
     def test_nonlinear_multipleroots(self):
         err = self.domain.boundary['bottom'].integral('(u + u^2 - .75)^2' @ self.ns, degree=2)
-        cons = solver.optimize('dofs', err, droptol=1e-15, lhs0=numpy.ones(len(self.ns.ubasis)), tol=1e-10)
+        cons = solver.optimize('dofs', err, droptol=1e-15, lhs0=numpy.ones(len(self.ubasis)), tol=1e-10)
         numpy.testing.assert_almost_equal(cons, numpy.take([.5, numpy.nan], [0, 1, 1, 0, 1, 1, 0, 1, 1]), decimal=15)
 
     def test_nanres(self):
         err = self.domain.integral('(sqrt(1 - u) - .5)^2' @ self.ns, degree=2)
         dofs = solver.optimize('dofs', err, tol=1e-10)
         numpy.testing.assert_almost_equal(dofs, .75)
 
@@ -221,44 +273,49 @@
             dofs = solver.optimize('other', err, tol=1e-10, droptol=1e-10)
 
 
 class burgers(TestCase):
 
     def setUp(self):
         super().setUp()
-        ns = function.Namespace()
-        domain, ns.x = mesh.rectilinear([10], periodic=(0,))
-        ns.basis = domain.basis('discont', degree=1)
-        ns.u = 'basis_n ?dofs_n'
+        domain, geom = mesh.rectilinear([10], periodic=(0,))
+        basis = domain.basis('discont', degree=1)
+        ns = Namespace()
+        ns.x = geom
+        ns.define_for('x', gradient='∇', normal='n', jacobians=('dV', 'dS'))
+        ns.add_field(('u', 'v'), basis)
         ns.f = '.5 u^2'
-        self.residual = domain.integral('-basis_n,0 f d:x' @ ns, degree=2)
-        self.residual += domain.interfaces.integral('-[basis_n] n_0 ({f} - .5 [u] n_0) d:x' @ ns, degree=4)
-        self.inertia = domain.integral('basis_n u d:x' @ ns, degree=5)
-        self.lhs0 = numpy.sin(numpy.arange(len(ns.basis)))  # "random" initial vector
+        self.residual = domain.integral('-∇_0(v) f dV' @ ns, degree=2)
+        self.residual += domain.interfaces.integral('-[v] n_0 ({f} - .5 [u] n_0) dS' @ ns, degree=4)
+        self.inertia = domain.integral('v u dV' @ ns, degree=5)
+        self.lhs0 = numpy.sin(numpy.arange(len(basis)))  # "random" initial vector
 
     def test_iters(self):
-        it = iter(solver.impliciteuler('dofs', residual=self.residual, inertia=self.inertia, lhs0=self.lhs0, timestep=100))  # involves 2-level timestep scaling
-        assert numpy.equal(next(it), self.lhs0).all()
-        self.assertAlmostEqual64(next(it), 'eNpzNBA1NjHuNHQ3FDsTfCbAuNz4nUGZgeyZiDOZxlONmQwU9W3OFJ/pNQAADZIOPA==')
+        it = iter(solver.impliciteuler('u:v', residual=self.residual, inertia=self.inertia, arguments=dict(u=self.lhs0), timestep=100))  # involves 2-level timestep scaling
+        assert numpy.equal(next(it)['u'], self.lhs0).all()
+        self.assertAlmostEqual64(next(it)['u'], 'eNpzNBA1NjHuNHQ3FDsTfCbAuNz4nUGZgeyZiDOZxlONmQwU9W3OFJ/pNQAADZIOPA==')
 
     def test_resume(self):
-        _test_recursion_cache(self, lambda: map(types.frozenarray, solver.impliciteuler('dofs', residual=self.residual, inertia=self.inertia, lhs0=self.lhs0, timestep=1)))
+        _test_recursion_cache(self, lambda: solver.impliciteuler('u:v', residual=self.residual, inertia=self.inertia, arguments=dict(u=self.lhs0), timestep=1))
 
     def test_resume_withscaling(self):
-        _test_recursion_cache(self, lambda: map(types.frozenarray, solver.impliciteuler('dofs', residual=self.residual, inertia=self.inertia, lhs0=self.lhs0, timestep=100)))
+        _test_recursion_cache(self, lambda: solver.impliciteuler('u:v', residual=self.residual, inertia=self.inertia, arguments=dict(u=self.lhs0), timestep=100))
 
 
 class theta_time(TestCase):
 
     def check(self, method, theta):
-        ns = function.Namespace()
+        ns = Namespace()
         topo, ns.x = mesh.rectilinear([1])
-        ns.u_n = '?u_n + <0>_n'
-        inertia = topo.integral('?u_n d:x' @ ns, degree=0)
-        residual = topo.integral('-<1>_n sin(?t) d:x' @ ns, degree=0)
+        ns.define_for('x', jacobians=('dV',))
+        ns.u = function.Argument('u', shape=(1,))
+        ns.t = function.Argument('t', shape=())
+        ns.e = function.ones([1])
+        inertia = topo.integral('u_n dV' @ ns, degree=0)
+        residual = topo.integral('-e_n sin(t) dV' @ ns, degree=0)
         timestep = 0.1
         udesired = numpy.array([0.])
         uactualiter = iter(method(target='u', residual=residual, inertia=inertia, timestep=timestep, lhs0=udesired, timetarget='t'))
         for i in range(5):
             with self.subTest(i=i):
                 uactual = next(uactualiter)
                 self.assertAllAlmostEqual(uactual, udesired)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `nutils-7.3/tests/test_sparse.py` & `nutils-8.0/tests/test_sparse.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_testing.py` & `nutils-8.0/tests/test_testing.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from nutils.testing import *
+from nutils.testing import TestCase
 from nutils import numeric
 import numpy
 
 
 class almostequal64(TestCase):
 
     maxDiff = 5000
```

### Comparing `nutils-7.3/tests/test_topology.py` & `nutils-8.0/tests/test_topology.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,10 @@
-from nutils import *
-from nutils.testing import *
+from nutils import element, mesh, topology, function, transformseq, evaluable, transform, _util as util
+from nutils.testing import TestCase, parametrize
 from nutils.elementseq import References
-from nutils.topology import Topology
 import numpy
 import copy
 import sys
 import pickle
 import subprocess
 import base64
 import itertools
@@ -58,14 +57,20 @@
         actual_coords_flat = as_rounded_list(bezier.eval(self.geom))
         actual_coords = []
         for ielem, desired_elem_coords in enumerate(desired_coords):
             actual_elem_coords = numpy.take(actual_coords_flat, bezier.getindex(ielem), axis=0)
             actual_coords.append(actual_elem_coords.tolist())
         self.assertEqual(sorted(actual_coords), sorted(desired_coords))
 
+    def assertEquivalent(self, topo1, topo2):
+        self.assertEqual(type(topo1), type(topo2))
+        self.assertEqual(topo1.spaces, topo2.spaces)
+        self.assertEqual(topo1.space_dims, topo2.space_dims)
+        self.assertEqual(topo1.references, topo2.references)
+
 
 class CommonTests(CommonAssertions):
 
     def test_empty_like(self):
         empty = self.topo.empty_like()
         self.assertEqual(len(empty), 0)
         self.assertEqual(empty.spaces, self.desired_spaces)
@@ -131,31 +136,31 @@
     def test_unit_integrate(self):
         self.assertAlmostEqual(self.topo.integrate(function.J(self.geom), degree=0), sum(self.desired_volumes))
 
     def test_unit_integrate_elementwise(self):
         self.assertEqual(as_rounded_list(self.topo.integrate_elementwise(function.J(self.geom), degree=0)), self.desired_volumes)
 
     def test_refine_spaces_none(self):
-        self.assertEqual(self.topo.refine_spaces([]), self.topo)
+        self.assertEquivalent(self.topo.refine_spaces([]), self.topo)
 
     def test_invalid_intersections(self):
         with self.assertRaises(ValueError):
-            self.topo & Topology.empty(tuple('other' + space for space in self.desired_spaces), self.desired_space_dims, self.desired_ndims)
+            self.topo & topology.Topology.empty(tuple('other' + space for space in self.desired_spaces), self.desired_space_dims, self.desired_ndims)
         with self.assertRaises(ValueError):
-            self.topo & Topology.empty(self.desired_spaces, tuple(dim + 1 for dim in self.desired_space_dims), self.desired_ndims)
+            self.topo & topology.Topology.empty(self.desired_spaces, tuple(dim + 1 for dim in self.desired_space_dims), self.desired_ndims)
         with self.assertRaises(ValueError):
-            self.topo & Topology.empty(self.desired_spaces, self.desired_space_dims, self.desired_ndims + 1)
+            self.topo & topology.Topology.empty(self.desired_spaces, self.desired_space_dims, self.desired_ndims + 1)
 
     def test_invalid_unions(self):
         with self.assertRaises(ValueError):
-            self.topo | Topology.empty(tuple('other' + space for space in self.desired_spaces), self.desired_space_dims, self.desired_ndims)
+            self.topo | topology.Topology.empty(tuple('other' + space for space in self.desired_spaces), self.desired_space_dims, self.desired_ndims)
         with self.assertRaises(ValueError):
-            self.topo | Topology.empty(self.desired_spaces, tuple(dim + 1 for dim in self.desired_space_dims), self.desired_ndims)
+            self.topo | topology.Topology.empty(self.desired_spaces, tuple(dim + 1 for dim in self.desired_space_dims), self.desired_ndims)
         with self.assertRaises(ValueError):
-            self.topo | Topology.empty(self.desired_spaces, self.desired_space_dims, self.desired_ndims + 1)
+            self.topo | topology.Topology.empty(self.desired_spaces, self.desired_space_dims, self.desired_ndims + 1)
 
     def test_select(self):
         if self.desired_ndims == 0:
             return
         if self.desired_nelems:
             centers = numpy.stack([numpy.mean(v, axis=0) for v in self.desired_vertices])
             center = numpy.mean(centers, axis=0)
@@ -231,15 +236,15 @@
 
 class NewTopologyRefine(TestCase, CommonAssertions):
     # Tests for default implementations of `Topology.refine_*`.
 
     def setUp(self):
         super().setUp()
 
-        class TestTopo(Topology):
+        class TestTopo(topology.Topology):
             def __init__(self, real):
                 self.real = real
                 super().__init__(real.spaces, real.space_dims, real.references)
 
             def refine_spaces(self, spaces):
                 return TestTopo(self.real.refine_spaces(spaces))
 
@@ -287,15 +292,15 @@
 class NewTopologyTake(TestCase, CommonAssertions):
     # Tests for default implementations of `Topology.take` and
     # `Topology.compress`.
 
     def setUp(self):
         super().setUp()
 
-        class TestTopo(Topology):
+        class TestTopo(topology.Topology):
             def __init__(self, real):
                 self.real = real
                 super().__init__(real.spaces, real.space_dims, real.references)
 
             def sample(self, ischeme, degree):
                 return self.real.sample(ischeme, degree)
         topo, self.geom = mesh.newrectilinear([4, 2], spaces=['X', 'Y'])
@@ -412,30 +417,30 @@
 class NewEmpty(TestCase, CommonTests, ConformingTests):
 
     def setUp(self):
         super().setUp()
         self.desired_spaces = 'a', 'b'
         self.desired_space_dims = 1, 2
         self.desired_ndims = 3
-        self.topo = Topology.empty(self.desired_spaces, self.desired_space_dims, self.desired_ndims)
-        self.geom = function.concatenate([function.rootcoords(space, dim) for space, dim in zip(self.desired_spaces, self.desired_space_dims)])
+        self.topo = topology.Topology.empty(self.desired_spaces, self.desired_space_dims, self.desired_ndims)
+        self.geom = numpy.concatenate([function.rootcoords(space, dim) for space, dim in zip(self.desired_spaces, self.desired_space_dims)])
         self.desired_nelems = 0
         self.desired_volumes = []
         self.desired_references = []
         self.desired_vertices = []
 
     def test_opposite(self):
         self.assertEqual(len(~self.topo), 0)
 
     def test_intersection(self):
         atrans = transformseq.IndexTransforms(1, 1, 0)
         btrans = transformseq.IndexTransforms(2, 1, 1)
         other = topology.SimplexTopology('a', numpy.array([[0, 1]]), atrans, atrans) * topology.SimplexTopology('b', numpy.array([[0, 1, 2]]), btrans, btrans)
-        self.assertEqual(self.topo & other, self.topo)
-        self.assertEqual(other & self.topo, self.topo)
+        self.assertEquivalent(self.topo & other, self.topo)
+        self.assertEquivalent(other & self.topo, self.topo)
 
     def test_union(self):
         atrans = transformseq.IndexTransforms(1, 1, 0)
         btrans = transformseq.IndexTransforms(2, 1, 1)
         other = topology.SimplexTopology('a', numpy.array([[0, 1]]), atrans, atrans) * topology.SimplexTopology('b', numpy.array([[0, 1, 2]]), btrans, btrans)
         self.assertEqual(self.topo | other, other)
         self.assertEqual(other | self.topo, other)
@@ -448,15 +453,15 @@
 
 
 class NewDisjointUnion(TestCase, CommonTests, ConformingTests):
 
     def setUp(self):
         super().setUp()
         topo, self.geom = mesh.newrectilinear([8, 3], spaces='XY')
-        self.topo = Topology.disjoint_union(topo.slice(slice(0, 3), 0), topo.slice(slice(4, 8), 0).slice(slice(0, 2), 1))
+        self.topo = topology.Topology.disjoint_union(topo.slice(slice(0, 3), 0), topo.slice(slice(4, 8), 0).slice(slice(0, 2), 1))
         self.desired_spaces = 'X', 'Y'
         self.desired_space_dims = 1, 1
         self.desired_ndims = 2
         self.desired_nelems = 17
         self.desired_volumes = [1] * 17
         self.desired_references = [element.LineReference()**2]*17
         self.desired_vertices = self.mkverts(pairwise(range(4)), pairwise(range(4))) + self.mkverts(pairwise(range(4, 9)), pairwise(range(3)))
@@ -487,28 +492,28 @@
 
     def test_basis_std_degree1(self):
         with self.assertRaises(Exception):
             self.topo.basis('std', degree=1)
 
     def test_trim(self):
         topo, x = mesh.line([0, 1, 2, 3], space='X')
-        topo = Topology.disjoint_union(topo.slice(slice(0, 1), 0), topo.slice(slice(2, 3), 0))
+        topo = topology.Topology.disjoint_union(topo.slice(slice(0, 1), 0), topo.slice(slice(2, 3), 0))
         self.assertEqual(as_rounded_list(topo.trim(x-0.5, maxrefine=0).volume(x[None])), 1.5)
         self.assertEqual(as_rounded_list(topo.trim(x-2.5, maxrefine=0).volume(x[None])), 0.5)
         self.assertEqual(as_rounded_list(topo.trim(0.5-x, maxrefine=0).volume(x[None])), 0.5)
 
 
 class NewMul(TestCase, CommonTests, ConformingTests):
 
     def setUp(self):
         super().setUp()
-        self.topo1, self.x = mesh.line([0, 1, 2], bnames=['a', 'b'], space='X')
-        self.topo2, self.y = mesh.line([0, 1, 2, 3], bnames=['c', 'd'], space='Y')
+        self.topo1, self.x = mesh.line([0, 1, 2], bnames=('a', 'b'), space='X')
+        self.topo2, self.y = mesh.line([0, 1, 2, 3], bnames=('c', 'd'), space='Y')
         self.topo = self.topo1 * self.topo2
-        self.geom = function.stack([self.x, self.y])
+        self.geom = numpy.stack([self.x, self.y])
         self.desired_spaces = 'X', 'Y'
         self.desired_space_dims = 1, 1
         self.desired_ndims = 2
         self.desired_nelems = 6
         self.desired_volumes = [1]*6
         self.desired_references = [element.LineReference()**2]*6
         self.desired_vertices = self.mkverts(pairwise(range(3)), pairwise(range(4)))
@@ -573,15 +578,15 @@
         self.assertEqual(as_rounded_list(self.topo.sample('gauss', 0).eval(topo.indicator('f,h'))), [1, 0, 1, 1, 0, 1])
         self.assertEqual(as_rounded_list(self.topo.sample('gauss', 0).eval(topo.indicator('nonexistent'))), [0, 0, 0, 0, 0, 0])
         with self.assertRaises(NotImplementedError):
             topo.indicator('g')
 
     def test_common_spaces(self):
         with self.assertRaisesRegex(ValueError, '^Cannot multiply'):
-            Topology.empty(['X'], [1], 1) * Topology.empty(['X', 'Y'], [1, 2], 3)
+            topology.Topology.empty(['X'], [1], 1) * topology.Topology.empty(['X', 'Y'], [1, 2], 3)
 
     def test_basis(self):
         self.assertEqual(len(self.topo.basis('spline', degree=1)), 3*4)
         self.assertEqual(len(self.topo.basis('spline', degree=1, periodic=[0])), 2*4)
         self.assertEqual(len(self.topo.basis('spline', degree=1, periodic=[1])), 3*3)
         self.assertEqual(len(self.topo.basis('spline', degree=1, periodic=[0, 1])), 2*3)
         self.assertEqual(len(self.topo.basis('spline', degree=[0, 1])), 2*4)
@@ -607,20 +612,20 @@
             self.topo.basis('spline', degree=1, knotmultiplicities=['a', 'b'])
 
 
 class NewWithGroupAliases(TestCase, CommonTests, ConformingTests):
 
     def setUp(self):
         super().setUp()
-        self.topo1, self.x = mesh.line([0, 1, 2], bnames=['a', 'b'], space='X')
+        self.topo1, self.x = mesh.line([0, 1, 2], bnames=('a', 'b'), space='X')
         self.topo1 = self.topo1.withsubdomain(e=self.topo1[:1])
-        self.topo2, self.y = mesh.line([0, 1, 2, 3], bnames=['c', 'd'], space='Y')
+        self.topo2, self.y = mesh.line([0, 1, 2, 3], bnames=('c', 'd'), space='Y')
         self.topo2 = self.topo2.withsubdomain(f=self.topo2[:1], g=self.topo2[2:])
         self.topo = (self.topo1 * self.topo2).withgroups(vgroups=dict(ealias='e', falias='f', galias='g', fgalias='f,g'))
-        self.geom = function.stack([self.x, self.y])
+        self.geom = numpy.stack([self.x, self.y])
         self.desired_spaces = 'X', 'Y'
         self.desired_space_dims = 1, 1
         self.desired_ndims = 2
         self.desired_nelems = 6
         self.desired_volumes = [1]*6
         self.desired_references = [element.LineReference()**2]*6
         self.desired_vertices = [[[x, y] for x in X for y in Y] for X in pairwise(range(3)) for Y in pairwise(range(4))]
@@ -640,17 +645,18 @@
 class TopologyAssertions:
 
     def assertConnectivity(self, domain, geom):
         boundary = domain.boundary
         interfaces = domain.interfaces
         bmask = numpy.zeros(len(boundary), dtype=int)
         imask = numpy.zeros(len(interfaces), dtype=int)
-        coordinates = evaluable.Points(evaluable.NPoints(), boundary.ndims)
-        transform_chain = transform.EvaluableTransformChain.from_argument('trans', domain.transforms.todims, boundary.ndims)
-        lowered_geom = geom.lower(coordinates.shape[:-1], {domain.space: (transform_chain,)*2}, {domain.space: coordinates}).simplified
+        coordinates = evaluable.Points(evaluable.NPoints(), evaluable.constant(boundary.ndims))
+        edges = domain.transforms.edges(domain.references)
+        iedge = evaluable.Argument('_iedge', (), int)
+        lowered_geom = geom.lower(function.LowerArgs.for_space(domain.space, (edges,), iedge, coordinates)).simplified
         for ielem, ioppelems in enumerate(domain.connectivity):
             for iedge, ioppelem in enumerate(ioppelems):
                 etrans, eref = domain.references[ielem].edges[iedge]
                 trans = domain.transforms[ielem] + (etrans,)
                 if ioppelem == -1:
                     index = boundary.transforms.index(trans)
                     bmask[index] += 1
@@ -664,16 +670,16 @@
                         index = interfaces.transforms.index(opptrans)
                         self.assertEqual(interfaces.opposites[index], trans)
                     else:
                         self.assertEqual(interfaces.opposites[index], opptrans)
                     imask[index] += 1
                     self.assertEqual(eref, opperef)
                     points = eref.getpoints('gauss', 2)
-                    a0 = lowered_geom.eval(trans=trans, _points=points)
-                    a1 = lowered_geom.eval(trans=opptrans, _points=points)
+                    a0 = lowered_geom.eval(_iedge=edges.index(trans), _points=points)
+                    a1 = lowered_geom.eval(_iedge=edges.index(opptrans), _points=points)
                     numpy.testing.assert_array_almost_equal(a0, a1)
         self.assertTrue(numpy.equal(bmask, 1).all())
         self.assertTrue(numpy.equal(imask, 2).all())
 
     def assertBoundaries(self, domain, geom):
         # Test ∫_Ω f_,i = ∫_∂Ω f n_i.
         f = ((0.5 - geom)**2).sum(axis=0)
@@ -728,15 +734,15 @@
 structure(ndims=2, refine=1)
 structure(ndims=3, refine=1)
 
 
 class picklability(TestCase):
 
     def assert_pickle_dump_load(self, data):
-        script = b'from nutils import *\nimport pickle, base64\npickle.loads(base64.decodebytes(b"""' \
+        script = b'import pickle, base64\npickle.loads(base64.decodebytes(b"""' \
             + base64.encodebytes(pickle.dumps(data)) \
             + b'"""))'
         p = subprocess.Popen([sys.executable], stdin=subprocess.PIPE)
         p.communicate(script)
         self.assertEqual(p.wait(), 0, 'unpickling failed')
 
     def test_domain(self):
@@ -750,15 +756,15 @@
     def test_basis(self):
         domain, geom = mesh.rectilinear([[0, 1, 2]]*2)
         basis = domain.basis('spline', degree=2)
         self.assert_pickle_dump_load(basis)
 
 
 @parametrize
-class common_refine(TestCase):
+class common_refine(TestCase, CommonAssertions):
 
     def _shield(self, topo):
         return topo if self.special \
             else topology.TransformChainsTopology(space=topo.space, references=topo.references, transforms=topo.transforms, opposites=topo.opposites)
 
     def test(self):
         dom, geom = mesh.rectilinear([[0, 1, 2], [0, 1, 2]])
@@ -798,15 +804,15 @@
             self.assertEqual(len(iface), 3)
             self.assertAlmostEqual(iface.integrate(function.J(geom), degree=1), 3)
         with self.subTest('refined-left'):
             iface = dom1.refined.boundary['right'] & self._shield(~dom2.boundary)
             self.assertIs(iface, dom1.refined.boundary['right'])
         with self.subTest('refined-right'):
             iface = self._shield(dom1.boundary) & ~dom2.refined.boundary['left']
-            self.assertIs(iface, ~dom2.refined.boundary['left'])
+            self.assertEquivalent(iface, ~dom2.refined.boundary['left'])
         with self.subTest('partial-refined-both'):
             iface = dom1.refined_by([0]).boundary & self._shield(~dom2.refined_by([2]).boundary)
             self.assertEqual(len(iface), 5)
             self.assertAlmostEqual(iface.integrate(function.J(geom), degree=1), 3)
 
 
 common_refine(special=True)  # use special case union implementation
@@ -823,15 +829,15 @@
 
 @parametrize
 class refined(TestCase):
 
     def test_boundary_gradient(self):
         ref = _refined_refs[self.etype]
         space = 'test'
-        domain = topology.ConnectedTopology(space, References.uniform(ref, 1), transformseq.IndexTransforms(ref.ndims, 1), transformseq.IndexTransforms(ref.ndims, 1), ((-1,)*ref.nedges,)).refine(self.ref0)
+        domain = topology.ConnectedTopology(space, References.uniform(ref, 1), transformseq.IndexTransforms(ref.ndims, 1), transformseq.IndexTransforms(ref.ndims, 1), [numpy.repeat(-1, ref.nedges)]).refine(self.ref0)
         geom = function.rootcoords(space, ref.ndims)
         basis = domain.basis('std', degree=1)
         u = domain.projection(geom.sum(), onto=basis, geometry=geom, degree=2)
         bpoints = domain.refine(self.ref1).boundary.refine(self.ref2).sample('uniform', 1)
         g = bpoints.eval(u.grad(geom))
         numpy.testing.assert_allclose(g, 1)
 
@@ -905,62 +911,74 @@
 @parametrize
 class locate(TestCase):
 
     def setUp(self):
         super().setUp()
         domain, geom = mesh.unitsquare(4, etype=self.etype)
         if self.mode == 'nonlinear':
-            geom = function.sin(geom * numpy.pi / 2)  # nonlinear map from [0,1] to [0,1]
+            geom = numpy.sin(geom * numpy.pi / 2)  # nonlinear map from [0,1] to [0,1]
         geom = geom * (.32 if self.mode == 'trimmed' else .2, .7) + (0, .3)  # trimmed: keep 2.5 elements in x-direction
         if self.mode == 'trimmed':
             domain = domain.trim(.2 - geom[0], maxrefine=0)
         self.domain = domain
-        self.geom = geom
+        self.geom = geom * (function.Argument('scale', ()) / .123)
 
     def test(self):
         target = numpy.array([(.2, .3), (.1, .9), (0, 1), (.1, .3)])
-        sample = self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12)
-        located = sample.eval(self.geom)
+        sample = self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12, arguments=dict(scale=.123))
+        located = sample.eval(self.geom, scale=.123)
         self.assertAllAlmostEqual(located, target)
 
     @parametrize.enable_if(lambda etype, mode, **kwargs: etype != 'square' or mode == 'nonlinear')
     def test_maxdist(self):
         target = numpy.array([(.2, .3), (.1, .9), (0, 1), (.1, .3)])
         with self.assertRaises(topology.LocateError):
-            self.domain.locate(self.geom, [(0, .3)], eps=1e-15, tol=1e-12, maxdist=.001)
-        sample = self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12, maxdist=.5)
-        located = sample.eval(self.geom)
+            self.domain.locate(self.geom, [(0, .3)], eps=1e-15, tol=1e-12, maxdist=.001, arguments=dict(scale=.123))
+        sample = self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12, maxdist=.5, arguments=dict(scale=.123))
+        located = sample.eval(self.geom, scale=.123)
         self.assertAllAlmostEqual(located, target)
 
     def test_invalidargs(self):
         target = numpy.array([(.2,), (.1,), (0,)])
         with self.assertRaises(Exception):
-            self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12)
+            self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12, arguments=dict(scale=.123))
 
     def test_invalidpoint(self):
         target = numpy.array([(.3, 1), (.2, .3), (.1, .9), (0, 1), (.1, .3)])
         # the first point is outside the domain, but inside basetopo for mode==trimmed
         with self.subTest('skip_missing=False'), self.assertRaises(topology.LocateError):
-            self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12)
+            self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12, arguments=dict(scale=.123))
         with self.subTest('skip_missing=True'):
-            sample = self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12, skip_missing=True)
+            sample = self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12, arguments=dict(scale=.123), skip_missing=True)
             self.assertEqual(sample.npoints, 4)
 
     def test_boundary(self):
         target = numpy.array([(.2,), (.1,), (0,)])
-        sample = self.domain.boundary['bottom'].locate(self.geom[:1], target, eps=1e-15, tol=1e-12)
-        located = sample.eval(self.geom[:1])
+        sample = self.domain.boundary['bottom'].locate(self.geom[:1], target, eps=1e-15, tol=1e-12, arguments=dict(scale=.123))
+        located = sample.eval(self.geom[:1], scale=.123)
         self.assertAllAlmostEqual(located, target)
 
     def test_boundary_scalar(self):
         target = numpy.array([.3, .9, 1])
-        sample = self.domain.boundary['left'].locate(self.geom[1], target, eps=1e-15, tol=1e-12)
-        located = sample.eval(self.geom[1])
+        sample = self.domain.boundary['left'].locate(self.geom[1], target, eps=1e-15, tol=1e-12, arguments=dict(scale=.123))
+        located = sample.eval(self.geom[1], scale=.123)
         self.assertAllAlmostEqual(located, target)
 
+    def test_missing_argument(self):
+        target = numpy.array([(.2, .3)])
+        with self.assertRaises(Exception):
+            self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12)
+
+    @parametrize.enable_if(lambda etype, mode, **kwargs: etype == 'square' and mode != 'nonlinear')
+    def test_detect_linear(self):
+        target = numpy.array([(.2, .3)])
+        with self.assertLogs('nutils', level='DEBUG') as cm:
+            self.domain.locate(self.geom, target, eps=1e-15, tol=1e-12, arguments=dict(scale=.123))
+        self.assertRegex(cm.output[0], 'locate detected linear geometry')
+
 
 for etype in 'square', 'triangle', 'mixed':
     for mode in 'linear', 'nonlinear', 'trimmed':
         locate(etype=etype, mode=mode, tol=1e-12)
 
 
 @parametrize
@@ -1036,14 +1054,16 @@
         indices = numpy.arange((npatches+1).prod()).reshape(npatches+1)
 
         self.domain, self.geom = mesh.multipatch(
             patches=[indices[tuple(map(slice, i, numpy.array(i)+2))].ravel().tolist() for i in itertools.product(*map(range, npatches))],
             patchverts=tuple(itertools.product(*map(range, npatches+1))),
             nelems=4,
         )
+        if getattr(self, 'refined', False):
+            self.domain = self.domain.refined
 
     def test_spline_basis(self):
         basis = self.domain.basis('spline', degree=2)
         coeffs = self.domain.sample('gauss', 4).eval(basis.sum(0))
         numpy.testing.assert_array_almost_equal(coeffs, numpy.ones(coeffs.shape))
 
     def test_discont_basis(self):
@@ -1059,14 +1079,15 @@
 
     def test_interpatch_interfaces(self):
         self.assertInterfaces(self.domain, self.geom, periodic=False, interfaces=self.domain.interfaces['interpatch'], elemindicator=self.domain.basis('patch'))
 
 
 multipatch_hyperrect('3', npatches=(3,))
 multipatch_hyperrect('2x2', npatches=(2, 2))
+multipatch_hyperrect('2x2-refined', npatches=(2, 2), refined=True)
 multipatch_hyperrect('3x3', npatches=(3, 3))
 multipatch_hyperrect('2x2x3', npatches=(2, 2, 3))
 
 
 class multipatch_L(TestCase):
 
     def setUp(self):
@@ -1209,15 +1230,15 @@
             self.assertEqual(ref, checkreferences[checktransforms.index(trans)])
 
     def test_refine_iter(self):
         level_iter = iter(self.topo.refine_iter)
         check = self.topo
         for i in range(4):
             level = next(level_iter)
-            self.assertEqual(level, check)
+            self.assertIs(level, check)
             check = check.refined
 
 
 class TransformChainsBoundaryTests:
 
     def test_border_transforms(self):
         border = set(map(self.topo.transforms.index, self.topo.border_transforms))
@@ -1306,14 +1327,39 @@
     def test_get_groups_self(self):
         self.assertEqual(len(self.topo.get_groups('b')), 2)
 
     def test_get_groups_parent(self):
         self.assertEqual(len(self.topo.get_groups('a')), 2)
 
 
+class SimplexTopology(TestCase, CommonTests, TransformChainsTests, ConformingTests):
+
+    def setUp(self):
+        super().setUp()
+        coords = numpy.array([[0,0],[0,1],[1,0],[1,1],[.5,.5]])
+        simplices = numpy.array([[0,1,4],[0,2,4],[1,3,4],[2,3,4]])
+        transforms = transformseq.IndexTransforms(2, len(simplices))
+        self.topo = topology.SimplexTopology('X', simplices, transforms, transforms)
+        self.geom = self.topo.basis('std', degree=1) @ coords
+        self.desired_nelems = 4
+        self.desired_spaces = 'X',
+        self.desired_space_dims = 2,
+        self.desired_ndims = 2
+        self.desired_volumes = [.25]*4
+        self.desired_references = [element.TriangleReference()]*4
+        self.desired_vertices = coords[simplices].tolist()
+
+    def test_boundary(self):
+        self.assertIsInstance(self.topo.boundary, topology.SimplexTopology)
+
+    def test_getitem(self):
+        self.assertIsInstance(self.topo[numpy.arange(4) < 2], topology.SimplexTopology)
+        self.assertIsInstance(self.topo[numpy.arange(2)], topology.SimplexTopology)
+
+
 class project(TestCase):
 
     def setUp(self):
         super().setUp()
         self.topo, self.geom = mesh.rectilinear([8])
         self.basis = self.topo.basis('std', degree=1)
```

### Comparing `nutils-7.3/tests/test_transformseq.py` & `nutils-8.0/tests/test_transformseq.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,17 @@
+from nutils import types, transform
 from nutils.testing import TestCase, parametrize
 import nutils.transformseq
 import nutils.element
 import nutils.evaluable
 from nutils.elementseq import References
 import unittest
 import numpy
 import itertools
 import functools
-import types
 
 
 class Common:
 
     def test_todims(self):
         self.assertEqual(self.seq.todims, self.checktodims)
         for trans in self.seq:
@@ -115,15 +115,15 @@
         for i, (trans, ref) in enumerate(zip(self.check, self.checkrefs)):
             self.assertEqual(self.seq.index_with_tail(trans), (i, ()))
             for ctrans in ref.child_transforms:
                 self.assertTrue(self.seq.contains_with_tail(trans+(ctrans,)))
             if self.checkfromdims > 0:
                 for etrans in ref.edge_transforms:
                     for shuffle in lambda t: t, nutils.transform.canonical:
-                        self.assertTrue(self.seq.contains_with_tail(trans+(etrans,)))
+                        self.assertTrue(self.seq.contains_with_tail(shuffle(trans+(etrans,))))
 
     def test_contains_with_tail_missing(self):
         for trans in self.checkmissing:
             self.assertFalse(self.seq.contains_with_tail(trans))
 
     def test_contains(self):
         for i, trans in enumerate(self.check):
@@ -140,38 +140,14 @@
     def test_refined(self):
         refined = self.seq.refined(self.checkrefs)
         assert len(self.check) == len(self.checkrefs)
         ctransforms = (trans+(ctrans,) for trans, ref in zip(self.check, self.checkrefs) for ctrans in ref.child_transforms)
         for i, trans in enumerate(ctransforms):
             self.assertEqual(refined.index(trans), i)
 
-    def test_get_evaluable(self):
-        eindex = nutils.evaluable.InRange(nutils.evaluable.Argument('index', (), int), len(self.check))
-        echain = self.seq.get_evaluable(eindex)
-        for index, chain in enumerate(self.check):
-            self.assertEqual(echain.eval(index=index), chain)
-
-    def test_index_with_tail_in(self):
-        assert len(self.check) == len(self.checkrefs)
-        echain = nutils.transform.EvaluableTransformChain.from_argument('chain', self.checktodims, self.checkfromdims)
-        eindex, etail = echain.index_with_tail_in(self.seq)
-        for i, (trans, ref) in enumerate(zip(self.check, self.checkrefs)):
-            self.assertEqual(int(eindex.eval(chain=trans)), i)
-            self.assertEqual(etail.eval(chain=trans), ())
-            for ctrans in ref.child_transforms:
-                self.assertEqual(self.seq.index_with_tail(trans+(ctrans,)), (i, (ctrans,)))
-        if self.checkfromdims > 0:
-            echain = nutils.transform.EvaluableTransformChain.from_argument('chain', self.checktodims, self.checkfromdims-1)
-            eindex, etail = echain.index_with_tail_in(self.seq)
-            for i, (trans, ref) in enumerate(zip(self.check, self.checkrefs)):
-                for etrans in ref.edge_transforms:
-                    for shuffle in lambda t: t, nutils.transform.canonical:
-                        self.assertEqual(int(eindex.eval(chain=shuffle(trans+(etrans,)))), i)
-                        self.assertEqual(etail.eval(chain=shuffle(trans+(etrans,))), (etrans,))
-
 
 class Edges:
 
     def test_edges(self):
         edges = self.seq.edges(self.checkrefs)
         assert len(self.check) == len(self.checkrefs)
         etransforms = (trans+(etrans,) for trans, ref in zip(self.check, self.checkrefs) for etrans in ref.edge_transforms)
@@ -215,191 +191,191 @@
         self.checktodims = 1
         self.checkfromdims = 1
 
 
 class PlainTransforms1D(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.PlainTransforms([(x1, i10), (x1, i11), (x1, i12), (x1, i13)], 1, 1)
+        self.seq = nutils.transformseq.PlainTransforms(((x1, i10), (x1, i11), (x1, i12), (x1, i13)), 1, 1)
         self.check = (x1, i10), (x1, i11), (x1, i12), (x1, i13)
         self.checkmissing = (l1, i10), (x1, i14), (r1, i10)
         self.checkrefs = References.uniform(line, 4)
         self.checktodims = 1
         self.checkfromdims = 1
 
 
 class PlainTransforms2D(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.PlainTransforms([(x2, i20, i20), (x2, i20, i21), (x2, i21, i20), (x2, i21, i21)], 2, 2)
+        self.seq = nutils.transformseq.PlainTransforms(((x2, i20, i20), (x2, i20, i21), (x2, i21, i20), (x2, i21, i21)), 2, 2)
         self.check = (x2, i20, i20), (x2, i20, i21), (x2, i21, i20), (x2, i21, i21)
         self.checkmissing = (l2, i20, i20), (x2, i20, i22), (x2, i21, i22), (r2, i20, i20)
         self.checkrefs = References.from_iter((square, square, triangle, triangle), 2)
         self.checktodims = 2
         self.checkfromdims = 2
 
 
 class MaskedTransforms(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.MaskedTransforms(nutils.transformseq.PlainTransforms([(x2, i20, i20), (x2, i20, i21), (x2, i21, i20), (x2, i21, i21)], 2, 2), [0, 2])
+        self.seq = nutils.transformseq.MaskedTransforms(nutils.transformseq.PlainTransforms(((x2, i20, i20), (x2, i20, i21), (x2, i21, i20), (x2, i21, i21)), 2, 2), types.arraydata([0, 2]))
         self.check = (x2, i20, i20), (x2, i21, i20)
         self.checkmissing = (l2, i20, i20), (x2, i20, i21), (x2, i21, i21), (x2, i20, i22), (x2, i21, i22), (r2, i20, i20)
         self.checkrefs = References.from_iter((square, triangle), 2)
         self.checktodims = 2
         self.checkfromdims = 2
 
 
 class ReorderedTransforms(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.ReorderedTransforms(nutils.transformseq.PlainTransforms([(x2, i20, i20), (x2, i20, i21), (x2, i21, i20), (x2, i21, i21)], 2, 2), [0, 2, 3, 1])
+        self.seq = nutils.transformseq.ReorderedTransforms(nutils.transformseq.PlainTransforms(((x2, i20, i20), (x2, i20, i21), (x2, i21, i20), (x2, i21, i21)), 2, 2), types.arraydata([0, 2, 3, 1]))
         self.check = (x2, i20, i20), (x2, i21, i20), (x2, i21, i21), (x2, i20, i21)
         self.checkmissing = (l2, i20, i20), (x2, i20, i22), (x2, i21, i22), (r2, i20, i20)
         self.checkrefs = References.uniform(square, 4)
         self.checktodims = 2
         self.checkfromdims = 2
 
 
 class DerivedTransforms(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.DerivedTransforms(nutils.transformseq.PlainTransforms([(x1, i10), (x1, i11)], 1, 1), References.uniform(line, 2), 'child_transforms', 1)
+        self.seq = nutils.transformseq.DerivedTransforms(nutils.transformseq.PlainTransforms(((x1, i10), (x1, i11)), 1, 1), References.uniform(line, 2), 'child_transforms', 1)
         self.check = (x1, i10, c0), (x1, i10, c1), (x1, i11, c0), (x1, i11, c1)
         self.checkmissing = (l1, i10), (x1, i10), (x1, i11), (r1, i10)
         self.checkrefs = References.uniform(line, 4)
         self.checktodims = 1
         self.checkfromdims = 1
 
 
 class UniformDerivedTransforms(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.UniformDerivedTransforms(nutils.transformseq.PlainTransforms([(x1, i10), (x1, i11)], 1, 1), line, 'child_transforms', 1)
+        self.seq = nutils.transformseq.UniformDerivedTransforms(nutils.transformseq.PlainTransforms(((x1, i10), (x1, i11)), 1, 1), line, 'child_transforms', 1)
         self.check = (x1, i10, c0), (x1, i10, c1), (x1, i11, c0), (x1, i11, c1)
         self.checkmissing = (l1, i10), (x1, i10), (x1, i11), (r1, i10)
         self.checkrefs = References.uniform(line, 4)
         self.checktodims = 1
         self.checkfromdims = 1
 
 
 class ChainedTransforms(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.ChainedTransforms([nutils.transformseq.PlainTransforms([(x1, i10), (x1, i11)], 1, 1), nutils.transformseq.PlainTransforms([(x1, i12), (x1, i13)], 1, 1)])
+        self.seq = nutils.transformseq.ChainedTransforms((nutils.transformseq.PlainTransforms(((x1, i10), (x1, i11)), 1, 1), nutils.transformseq.PlainTransforms(((x1, i12), (x1, i13)), 1, 1)))
         self.check = (x1, i10), (x1, i11), (x1, i12), (x1, i13)
         self.checkmissing = (l1, i10), (x1, i14), (r1, i10)
         self.checkrefs = References.uniform(line, 4)
         self.checktodims = 1
         self.checkfromdims = 1
 
 
 class StructuredTransforms1D(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x1, [nutils.transformseq.DimAxis(0, 4, 0, False)], 0)
+        self.seq = nutils.transformseq.StructuredTransforms(x1, (nutils.transformseq.DimAxis(0, 4, 0, False),), 0)
         self.check = (x1, i10), (x1, i11), (x1, i12), (x1, i13)
         self.checkmissing = (l1, i10), (x1,), (x1, i14), (r1, i10), (x1, c1)
         self.checkrefs = References.uniform(line, 4)
         self.checktodims = 1
         self.checkfromdims = 1
 
 
 class StructuredTransforms1DRefined(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x1, [nutils.transformseq.DimAxis(0, 4, 0, False)], 1)
+        self.seq = nutils.transformseq.StructuredTransforms(x1, (nutils.transformseq.DimAxis(0, 4, 0, False),), 1)
         self.check = (x1, i10, c0), (x1, i10, c1), (x1, i11, c0), (x1, i11, c1)
         self.checkmissing = (l1, i10), (x1,), (x1, i10), (x1, i11), (x1, i10, i11), (r1, i10)
         self.checkrefs = References.uniform(line, 4)
         self.checktodims = 1
         self.checkfromdims = 1
 
 
 class StructuredTransforms1DLeft(TestCase, Common):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x1, [nutils.transformseq.IntAxis(3, 4, 9, 0, False)], 0)
+        self.seq = nutils.transformseq.StructuredTransforms(x1, (nutils.transformseq.IntAxis(3, 4, 9, 0, False),), 0)
         self.check = (x1, i13, e1),
         self.checkmissing = (x1, i10, e0), (x1, i12, e0), (x1, i14, e0)
         self.checkrefs = References.uniform(point, 1)
         self.checktodims = 1
         self.checkfromdims = 0
 
 
 class StructuredTransforms1DRight(TestCase, Common):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x1, [nutils.transformseq.IntAxis(2, 3, 9, 0, True)], 0)
+        self.seq = nutils.transformseq.StructuredTransforms(x1, (nutils.transformseq.IntAxis(2, 3, 9, 0, True),), 0)
         self.check = (x1, i12, e0),
         self.checkmissing = (x1, i10, e0), (x1, i13, e1), (x1, i14, e0)
         self.checkrefs = References.uniform(point, 1)
         self.checktodims = 1
         self.checkfromdims = 0
 
 
 class StructuredTransforms1DInterfacesLeft(TestCase, Common):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x1, [nutils.transformseq.IntAxis(1, 4, 9, 0, False)], 0)
+        self.seq = nutils.transformseq.StructuredTransforms(x1, (nutils.transformseq.IntAxis(1, 4, 9, 0, False),), 0)
         self.check = (x1, i11, e1), (x1, i12, e1), (x1, i13, e1)
         self.checkmissing = (x1, i10, e1), (x1, i10, e0), (x1, i11, e0), (x1, i12, e0), (x1, i13, e0)
         self.checkrefs = References.uniform(point, 3)
         self.checktodims = 1
         self.checkfromdims = 0
 
 
 class StructuredTransforms1DInterfacesRight(TestCase, Common):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x1, [nutils.transformseq.IntAxis(0, 3, 9, 0, True)], 0)
+        self.seq = nutils.transformseq.StructuredTransforms(x1, (nutils.transformseq.IntAxis(0, 3, 9, 0, True),), 0)
         self.check = (x1, i10, e0), (x1, i11, e0), (x1, i12, e0)
         self.checkmissing = (x1, i13, e0), (x1, i10, e1), (x1, i11, e1), (x1, i12, e1), (x1, i13, e1)
         self.checkrefs = References.uniform(point, 3)
         self.checktodims = 1
         self.checkfromdims = 0
 
 
 class StructuredTransforms1DPeriodicInterfacesLeft(TestCase, Common):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x1, [nutils.transformseq.IntAxis(1, 5, 4, 0, False)], 0)
+        self.seq = nutils.transformseq.StructuredTransforms(x1, (nutils.transformseq.IntAxis(1, 5, 4, 0, False),), 0)
         self.check = (x1, i11, e1), (x1, i12, e1), (x1, i13, e1), (x1, i10, e1)
         self.checkmissing = (x1, i10, e0), (x1, i11, e0), (x1, i12, e0), (x1, i13, e0), (x1, i14, e0)
         self.checkrefs = References.uniform(point, 4)
         self.checktodims = 1
         self.checkfromdims = 0
 
 
 class StructuredTransforms1DPeriodicInterfacesRight(TestCase, Common):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x1, [nutils.transformseq.IntAxis(0, 4, 4, 0, True)], 0)
+        self.seq = nutils.transformseq.StructuredTransforms(x1, (nutils.transformseq.IntAxis(0, 4, 4, 0, True),), 0)
         self.check = (x1, i10, e0), (x1, i11, e0), (x1, i12, e0), (x1, i13, e0)
         self.checkmissing = (x1, i10, e1), (x1, i11, e1), (x1, i12, e1), (x1, i13, e1), (x1, i14, e1)
         self.checkrefs = References.uniform(point, 4)
         self.checktodims = 1
         self.checkfromdims = 0
 
 
 class StructuredTransforms2D(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x2, [nutils.transformseq.DimAxis(0, 2, 0, False), nutils.transformseq.DimAxis(2, 4, 0, False)], 0)
+        self.seq = nutils.transformseq.StructuredTransforms(x2, (nutils.transformseq.DimAxis(0, 2, 0, False), nutils.transformseq.DimAxis(2, 4, 0, False)), 0)
         self.check = (x2, i20, i22), (x2, i20, i23), (x2, i21, i22), (x2, i21, i23)
         self.checkmissing = (x2,), (x2, i20), (x2, i20, i20), (x2, i20, i21), (x2, i21, i20), (x2, i21, i21)
         self.checkrefs = References.uniform(square, 4)
         self.checktodims = 2
         self.checkfromdims = 2
 
 
 class StructuredTransforms2DRefined(TestCase, Common, Edges):
     def setUp(self):
         super().setUp()
-        self.seq = nutils.transformseq.StructuredTransforms(x2, [nutils.transformseq.DimAxis(0, 2, 0, False), nutils.transformseq.DimAxis(2, 4, 0, False)], 1)
+        self.seq = nutils.transformseq.StructuredTransforms(x2, (nutils.transformseq.DimAxis(0, 2, 0, False), nutils.transformseq.DimAxis(2, 4, 0, False)), 1)
         self.check = (x2, i20, i21, c00), (x2, i20, i21, c01), (x2, i20, i21, c10), (x2, i20, i21, c11)
         self.checkmissing = (x2, i20, i20, c00),
         self.checkrefs = References.uniform(square, 4)
         self.checktodims = 2
         self.checkfromdims = 2
 
 
@@ -420,51 +396,52 @@
         with self.assertRaisesRegex(ValueError, '^invalid dimensions$'):
             nutils.transformseq.EmptyTransforms(1, -1)
         with self.assertRaisesRegex(ValueError, '^invalid dimensions$'):
             nutils.transformseq.EmptyTransforms(1, 2)
 
     def test_PlainTransforms_invalid_todims(self):
         with self.assertRaisesRegex(ValueError, 'expected transforms with todims=2, but got .*'):
-            nutils.transformseq.PlainTransforms([(x1, c0), (x1, c1)], 2, 1)
+            nutils.transformseq.PlainTransforms(((x1, c0), (x1, c1)), 2, 1)
 
     def test_PlainTransforms_invalid_fromdims(self):
         with self.assertRaisesRegex(ValueError, 'expected transforms with fromdims=2, but got .*'):
-            nutils.transformseq.PlainTransforms([(x2, e00), (x2, e11)], 2, 2)
+            nutils.transformseq.PlainTransforms(((x2, e00), (x2, e11)), 2, 2)
 
     def test_PlainTransforms_multiple_fromdims(self):
         with self.assertRaisesRegex(ValueError, 'expected transforms with fromdims=2, but got .*'):
-            nutils.transformseq.PlainTransforms([(x2, c00, e00), (x2, c01, i20, i20)], 2, 2)
+            nutils.transformseq.PlainTransforms(tuple(transform.canonical((x2, *tail)) for tail in ((c00, e00), (c01, i20, i20))), 2, 2)
+            nutils.transformseq.PlainTransforms(tuple(transform.canonical((x2, *tail)) for tail in ((c00, e00), (c01, i20, i20))), 2, 2)
 
     def test_DerivedTransforms_length_mismatch(self):
-        transforms = nutils.transformseq.PlainTransforms([(x1, i10), (x1, i11)], 1, 1)
+        transforms = nutils.transformseq.PlainTransforms(((x1, i10), (x1, i11)), 1, 1)
         references = References.uniform(line, 3)
         with self.assertRaisesRegex(ValueError, '`parent` and `parent_references` should have the same length'):
             nutils.transformseq.DerivedTransforms(transforms, references, 'child_transforms', 1)
 
     def test_DerivedTransforms_ndims_mismatch(self):
-        transforms = nutils.transformseq.PlainTransforms([(x1, i10), (x1, i11)], 1, 1)
+        transforms = nutils.transformseq.PlainTransforms(((x1, i10), (x1, i11)), 1, 1)
         references = References.uniform(square, 2)
         with self.assertRaisesRegex(ValueError, '`parent` and `parent_references` have different dimensions'):
             nutils.transformseq.DerivedTransforms(transforms, references, 'child_transforms', 1)
 
     def test_UniformDerivedTransforms_ndims_mismatch(self):
-        transforms = nutils.transformseq.PlainTransforms([(x1, i10), (x1, i11)], 1, 1)
+        transforms = nutils.transformseq.PlainTransforms(((x1, i10), (x1, i11)), 1, 1)
         with self.assertRaisesRegex(ValueError, '`parent` and `parent_reference` have different dimensions'):
             nutils.transformseq.UniformDerivedTransforms(transforms, square, 'child_transforms', 1)
 
     def test_ChainedTransforms_no_items(self):
         with self.assertRaisesRegex(ValueError, 'Empty chain.'):
-            nutils.transformseq.ChainedTransforms([])
+            nutils.transformseq.ChainedTransforms(())
 
     def test_ChainedTransforms_multiple_todims(self):
-        a = nutils.transformseq.PlainTransforms([(x2, c00, e00), (x2, c00, e01)], 2, 1)
-        b = nutils.transformseq.PlainTransforms([(x1, c0), (x1, c1)], 1, 1)
+        a = nutils.transformseq.PlainTransforms(tuple(transform.canonical((x2, c00, e)) for e in (e00, e01)), 2, 1)
+        b = nutils.transformseq.PlainTransforms(((x1, c0), (x1, c1)), 1, 1)
         with self.assertRaisesRegex(ValueError, 'Cannot chain Transforms with different todims.'):
-            nutils.transformseq.ChainedTransforms([a, b])
+            nutils.transformseq.ChainedTransforms((a, b))
 
     def test_ChainedTransforms_multiple_fromdims(self):
-        a = nutils.transformseq.PlainTransforms([(x2, c00, e00), (x2, c00, e01)], 2, 1)
-        b = nutils.transformseq.PlainTransforms([(x2, c10), (x2, c11)], 2, 2)
+        a = nutils.transformseq.PlainTransforms(tuple(transform.canonical((x2, c00, e)) for e in (e00, e01)), 2, 1)
+        b = nutils.transformseq.PlainTransforms(((x2, c10), (x2, c11)), 2, 2)
         with self.assertRaisesRegex(ValueError, 'Cannot chain Transforms with different fromdims.'):
-            nutils.transformseq.ChainedTransforms([a, b])
+            nutils.transformseq.ChainedTransforms((a, b))
 
 # vim:sw=2:sts=2:et
```

### Comparing `nutils-7.3/tests/test_types.py` & `nutils-8.0/tests/test_types.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,108 +1,20 @@
-from nutils.testing import *
+from nutils.testing import TestCase, parametrize
 import nutils.types
 import inspect
 import pickle
 import itertools
 import ctypes
-import stringly
 import tempfile
-import io
 import os
 import numpy
 import weakref
 import contextlib
-
-
-class apply_annotations(TestCase):
-
-    def test_without_annotations(self):
-        @nutils.types.apply_annotations
-        def f(a, b):
-            return a, b
-        a, b = f(1, 2)
-        self.assertEqual(a, 1)
-        self.assertEqual(b, 2)
-
-    def test_pos_or_kw(self):
-        @nutils.types.apply_annotations
-        def f(a: int, b, c: str):
-            return a, b, c
-        a, b, c = f(1, 2, 3)
-        self.assertEqual(a, 1)
-        self.assertEqual(b, 2)
-        self.assertEqual(c, '3')
-
-    def test_with_signature(self):
-        def f(a):
-            return a
-        f.__signature__ = inspect.Signature([inspect.Parameter('a', inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=str)])
-        f = nutils.types.apply_annotations(f)
-        self.assertEqual(f(1), '1')
-
-    def test_posonly(self):
-        def f(a):
-            return a
-        f.__signature__ = inspect.Signature([inspect.Parameter('a', inspect.Parameter.POSITIONAL_ONLY, annotation=str)])
-        f = nutils.types.apply_annotations(f)
-        self.assertEqual(f(1), '1')
-
-    def test_kwonly(self):
-        @nutils.types.apply_annotations
-        def f(a: str, *, b: int, c: bool):
-            return a, b, c
-        self.assertEqual(f(1, b='2', c=3), ('1', 2, True))
-
-    def test_varpos(self):
-        @nutils.types.apply_annotations
-        def f(a: str, *args):
-            return a, args
-        self.assertEqual(f(1, 2, 3), ('1', (2, 3)))
-
-    def test_varpos_annotated(self):
-        map_str = lambda args: map(str, args)
-
-        @nutils.types.apply_annotations
-        def f(a: str, *args: map_str):
-            return a, args
-        self.assertEqual(f(1, 2, 3), ('1', ('2', '3')))
-
-    def test_varkw(self):
-        @nutils.types.apply_annotations
-        def f(a: str, **kwargs):
-            return a, kwargs
-        self.assertEqual(f(1, b=2, c=3), ('1', dict(b=2, c=3)))
-
-    def test_varkw_annotated(self):
-        map_str = lambda kwargs: {k: str(v) for k, v in kwargs.items()}
-
-        @nutils.types.apply_annotations
-        def f(a: str, **kwargs: map_str):
-            return a, kwargs
-        self.assertEqual(f(1, b=2, c=3), ('1', dict(b='2', c='3')))
-
-    def test_posonly_varkw(self):
-        def f(a, b, **c):
-            return a, b, c
-        f.__signature__ = inspect.Signature([inspect.Parameter('a', inspect.Parameter.POSITIONAL_ONLY, annotation=str),
-                                             inspect.Parameter('b', inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=str, default=None),
-                                             inspect.Parameter('c', inspect.Parameter.VAR_KEYWORD)])
-        f = nutils.types.apply_annotations(f)
-        self.assertEqual(f(1, c=2, d=3), ('1', None, dict(c=2, d=3)))
-        self.assertEqual(f(1, None, c=2, d=3), ('1', None, dict(c=2, d=3)))
-        self.assertEqual(f(1, b=None, c=2, d=3), ('1', None, dict(c=2, d=3)))
-        self.assertEqual(f(1, b=4, c=2, d=3), ('1', '4', dict(c=2, d=3)))
-
-    def test_default_none(self):
-        @nutils.types.apply_annotations
-        def f(a: str = None):
-            return a
-        self.assertEqual(f(), None)
-        self.assertEqual(f(None), None)
-        self.assertEqual(f(1), '1')
+import unittest
+import sys
 
 
 class nutils_hash(TestCase):
 
     class custom:
         @property
         def __nutils_hash__(self):
@@ -121,14 +33,20 @@
         self.assertEqual(nutils.types.nutils_hash(False).hex(), '04a5e8f73dcea55dcd7482a476cf2e7b53d6dc50')
         self.assertEqual(nutils.types.nutils_hash(True).hex(), '3fe990437e1624c831729f2866979254437bb7e9')
 
     def test_int(self):
         self.assertEqual(nutils.types.nutils_hash(1).hex(), '00ec7dea895ebd921e56bbc554688d8b3a1e4dfc')
         self.assertEqual(nutils.types.nutils_hash(2).hex(), '8ae88fa39407cf75e46f9e0aba8c971de2256b14')
 
+    def test_numpy(self):
+        for t in bool, int, float, complex:
+            with self.subTest(t.__name__):
+                for d in numpy.arange(2, dtype=t):
+                    self.assertEqual(nutils.types.nutils_hash(d).hex(), nutils.types.nutils_hash(t(d)).hex())
+
     def test_float(self):
         self.assertEqual(nutils.types.nutils_hash(1.).hex(), 'def4bae4f2a3e29f6ddac537d3fa7c72195e5d8b')
         self.assertEqual(nutils.types.nutils_hash(2.5).hex(), '5216c2bf3c16d8b8ff4d9b79f482e5cea0a4cb95')
 
     def test_complex(self):
         self.assertEqual(nutils.types.nutils_hash(1+0j).hex(), 'cf7a0d933b7bb8d3ca252683b137534a1ecae073')
         self.assertEqual(nutils.types.nutils_hash(2+1j).hex(), 'ee088890528f941a80aa842dad36591b05253e55')
@@ -147,23 +65,35 @@
         self.assertEqual(nutils.types.nutils_hash(b'eggs').hex(), '98f2061978497751cac94f982fd96d9b015b74c3')
 
     def test_tuple(self):
         self.assertEqual(nutils.types.nutils_hash(()).hex(), '15d44755bf0731b2a3e9a5c5c8e0807b61881a1f')
         self.assertEqual(nutils.types.nutils_hash((1,)).hex(), '328b16ebbc1815cf579ae038a35c4d68ebb022af')
         self.assertNotEqual(nutils.types.nutils_hash((1, 'spam')).hex(), nutils.types.nutils_hash(('spam', 1)).hex())
 
+    def test_list(self):
+        self.assertEqual(nutils.types.nutils_hash([]).hex(), '97cf24e05bb79e46a091f869c37f33bca00fb3de')
+        self.assertEqual(nutils.types.nutils_hash([1]).hex(), '6dbffad355664123aea1859cf3266d3c00f97c04')
+        self.assertNotEqual(nutils.types.nutils_hash([1, 'spam']).hex(), nutils.types.nutils_hash(['spam', 1]).hex())
+
     def test_frozenset(self):
         self.assertEqual(nutils.types.nutils_hash(frozenset([1, 2])).hex(), '3862dc7e5321bc8a576c385ed2c12c71b96a375a')
         self.assertEqual(nutils.types.nutils_hash(frozenset(['spam', 'eggs'])).hex(), '2c75fd3db57f5e505e1425ae9ff6dcbbc77fd123')
 
+    def test_set(self):
+        self.assertEqual(nutils.types.nutils_hash({1, 2}).hex(), '7c9837cc4583aa872d5d4184759b61db237d54f4')
+        self.assertEqual(nutils.types.nutils_hash({'spam', 'eggs'}).hex(), 'd7520a52096168b0909c14d87cc428d58bc0a0a2')
+
+    def test_frozendict(self):
+        self.assertEqual(nutils.types.nutils_hash(nutils.types.frozendict({1: 2, 'foo': 'bar'})).hex(), '2faf141728d232cc795f43adbb58f8f86eb9b71d')
+
+    def test_dict(self):
+        self.assertEqual(nutils.types.nutils_hash({1: 2, 'foo': 'bar'}).hex(), '6c17894a11374016735f846ed3ae8ef2b921b4b5')
+
     def test_ndarray(self):
         a = numpy.array([1, 2, 3])
-        with self.assertRaises(TypeError):
-            nutils.types.nutils_hash(a)
-        a.flags.writeable = False
         self.assertEqual(nutils.types.nutils_hash(a).hex(),
                          '299c2c796b4a71b7a2b310ddb29bba0440d77e26' if numpy.int_ == numpy.int64
                          else '9fee185ee111495718c129b4d3a8ae79975f3459')
 
     @unittest.skipIf(sys.version_info < (3, 7), "not supported in this Python version")
     def test_dataclass(self):
         import dataclasses
@@ -199,369 +129,28 @@
             fid, path = tempfile.mkstemp()
             os.write(fid, b'test')
             os.close(fid)
             with open(path, 'rb') as f:
                 f.seek(2)
                 self.assertEqual(nutils.types.nutils_hash(f).hex(), '490e9467ce36ddf487999a7b43d554737385e42f')
                 self.assertEqual(f.tell(), 2)
-            with open(path, 'rb+') as f, self.assertRaises(TypeError):
-                nutils.types.nutils_hash(f).hex()
         finally:
             os.unlink(path)
 
     def test_type_boundmethod(self):
         self.assertEqual(nutils.types.nutils_hash(self.custom().f).hex(), 'ebf7084bb2504922235ab035a9197b9cb4cf47af')
 
     def test_custom(self):
         self.assertEqual(nutils.types.nutils_hash(self.custom()).hex(), b'01234567890123456789'.hex())
 
     def test_unhashable(self):
+        class MyUnhashableClass:
+            pass
         with self.assertRaises(TypeError):
-            nutils.types.nutils_hash([])
-
-
-class CacheMeta(TestCase):
-
-    def test_property(self):
-
-        for withslots in False, True:
-            with self.subTest(withslots=withslots):
-
-                class T(metaclass=nutils.types.CacheMeta):
-                    if withslots:
-                        __slots__ = ()
-                    __cache__ = 'x',
-
-                    @property
-                    def x(self):
-                        nonlocal ncalls
-                        ncalls += 1
-                        return 1
-
-                ncalls = 0
-                t = T()
-                self.assertEqual(ncalls, 0)
-                self.assertEqual(t.x, 1)
-                self.assertEqual(ncalls, 1)
-                self.assertEqual(t.x, 1)
-                self.assertEqual(ncalls, 1)
-
-    def test_set_property(self):
-
-        class T(metaclass=nutils.types.CacheMeta):
-            __cache__ = 'x',
-
-            @property
-            def x(self):
-                return 1
-
-        t = T()
-        with self.assertRaises(AttributeError):
-            t.x = 1
-
-    def test_del_property(self):
-
-        class T(metaclass=nutils.types.CacheMeta):
-            __cache__ = 'x',
-
-            @property
-            def x(self):
-                return 1
-
-        t = T()
-        with self.assertRaises(AttributeError):
-            del t.x
-
-    def test_method_without_args(self):
-
-        for withslots in False, True:
-            with self.subTest(withslots=withslots):
-
-                class T(metaclass=nutils.types.CacheMeta):
-                    if withslots:
-                        __slots__ = ()
-                    __cache__ = 'x',
-
-                    def x(self):
-                        nonlocal ncalls
-                        ncalls += 1
-                        return 1
-
-                ncalls = 0
-                t = T()
-                self.assertEqual(ncalls, 0)
-                self.assertEqual(t.x(), 1)
-                self.assertEqual(ncalls, 1)
-                self.assertEqual(t.x(), 1)
-                self.assertEqual(ncalls, 1)
-
-    def test_method_with_args(self):
-
-        for withslots in False, True:
-            with self.subTest(withslots=withslots):
-
-                class T(metaclass=nutils.types.CacheMeta):
-                    if withslots:
-                        __slots__ = ()
-                    __cache__ = 'x',
-
-                    def x(self, a, b):
-                        nonlocal ncalls
-                        ncalls += 1
-                        return a + b
-
-                ncalls = 0
-                t = T()
-                self.assertEqual(ncalls, 0)
-                self.assertEqual(t.x(1, 2), 3)
-                self.assertEqual(ncalls, 1)
-                self.assertEqual(t.x(a=1, b=2), 3)
-                self.assertEqual(ncalls, 1)
-                self.assertEqual(t.x(2, 2), 4)
-                self.assertEqual(ncalls, 2)
-                self.assertEqual(t.x(a=2, b=2), 4)
-                self.assertEqual(ncalls, 2)
-                self.assertEqual(t.x(1, 2), 3)
-                self.assertEqual(ncalls, 3)
-
-    def test_method_with_args_and_preprocessors(self):
-
-        for withslots in False, True:
-            with self.subTest(withslots=withslots):
-
-                class T(metaclass=nutils.types.CacheMeta):
-                    if withslots:
-                        __slots__ = ()
-                    __cache__ = 'x',
-
-                    @nutils.types.apply_annotations
-                    def x(self, a: int, b: int):
-                        nonlocal ncalls
-                        ncalls += 1
-                        return a + b
-
-                ncalls = 0
-                t = T()
-                self.assertEqual(ncalls, 0)
-                self.assertEqual(t.x(1, 2), 3)
-                self.assertEqual(ncalls, 1)
-                self.assertEqual(t.x(a='1', b='2'), 3)
-                self.assertEqual(ncalls, 1)
-                self.assertEqual(t.x('2', '2'), 4)
-                self.assertEqual(ncalls, 2)
-                self.assertEqual(t.x(a=2, b=2), 4)
-                self.assertEqual(ncalls, 2)
-                self.assertEqual(t.x('1', 2), 3)
-                self.assertEqual(ncalls, 3)
-
-    def test_method_with_kwargs(self):
-
-        for withslots in False, True:
-            with self.subTest(withslots=withslots):
-
-                class T(metaclass=nutils.types.CacheMeta):
-                    if withslots:
-                        __slots__ = ()
-                    __cache__ = 'x',
-
-                    def x(self, a, **kwargs):
-                        nonlocal ncalls
-                        ncalls += 1
-                        return a + sum(kwargs.values())
-
-                ncalls = 0
-                t = T()
-                self.assertEqual(ncalls, 0)
-                self.assertEqual(t.x(1, b=2), 3)
-                self.assertEqual(ncalls, 1)
-                self.assertEqual(t.x(a=1, b=2), 3)
-                self.assertEqual(ncalls, 1)
-                self.assertEqual(t.x(1, b=2, c=3), 6)
-                self.assertEqual(ncalls, 2)
-                self.assertEqual(t.x(a=1, b=2, c=3), 6)
-                self.assertEqual(ncalls, 2)
-
-    def test_subclass_redefined_property(self):
-
-        class T(metaclass=nutils.types.CacheMeta):
-            __cache__ = 'x',
-
-            @property
-            def x(self):
-                return 1
-
-        class U(T):
-            __cache__ = 'x',
-
-            @property
-            def x(self):
-                return super().x + 1
-
-            @property
-            def y(self):
-                return super().x
-
-        u1 = U()
-        self.assertEqual(u1.x, 2)
-        self.assertEqual(u1.y, 1)
-
-        u2 = U()
-        self.assertEqual(u2.y, 1)
-        self.assertEqual(u2.x, 2)
-
-    def test_missing_attribute(self):
-
-        with self.assertRaisesRegex(TypeError, 'Attribute listed in __cache__ is undefined: x'):
-            class T(metaclass=nutils.types.CacheMeta):
-                __cache__ = 'x',
-
-    def test_invalid_attribute(self):
-
-        with self.assertRaisesRegex(TypeError, "Don't know how to cache attribute x: None"):
-            class T(metaclass=nutils.types.CacheMeta):
-                __cache__ = 'x',
-                x = None
-
-    def test_name_mangling(self):
-
-        for withslots in False, True:
-            with self.subTest(withslots=withslots):
-
-                class T(metaclass=nutils.types.CacheMeta):
-                    if withslots:
-                        __slots__ = ()
-                    __cache__ = '__x',
-
-                    @property
-                    def __x(self):
-                        nonlocal ncalls
-                        ncalls += 1
-                        return 1
-
-                    @property
-                    def y(self):
-                        return self.__x
-
-                ncalls = 0
-                t = T()
-                self.assertEqual(ncalls, 0)
-                self.assertEqual(t.y, 1)
-                self.assertEqual(ncalls, 1)
-                self.assertEqual(t.y, 1)
-                self.assertEqual(ncalls, 1)
-
-
-class strictint(TestCase):
-
-    def test_int(self):
-        value = nutils.types.strictint(1)
-        self.assertEqual(value, 1)
-        self.assertEqual(type(value), int)
-
-    def test_numpy_int(self):
-        value = nutils.types.strictint(numpy.int64(1))
-        self.assertEqual(value, 1)
-        self.assertEqual(type(value), int)
-
-    def test_float(self):
-        with self.assertRaises(ValueError):
-            nutils.types.strictint(1.)
-
-    def test_numpy_float(self):
-        with self.assertRaises(ValueError):
-            nutils.types.strictint(numpy.float64(1.))
-
-    def test_complex(self):
-        with self.assertRaises(ValueError):
-            nutils.types.strictint(1+0j)
-
-    def test_str(self):
-        with self.assertRaises(ValueError):
-            nutils.types.strictint('1')
-
-
-class strictfloat(TestCase):
-
-    def test_int(self):
-        value = nutils.types.strictfloat(1)
-        self.assertEqual(value, 1.)
-        self.assertEqual(type(value), float)
-
-    def test_numpy_int(self):
-        value = nutils.types.strictfloat(numpy.int64(1))
-        self.assertEqual(value, 1.)
-        self.assertEqual(type(value), float)
-
-    def test_float(self):
-        value = nutils.types.strictfloat(1.)
-        self.assertEqual(value, 1.)
-        self.assertEqual(type(value), float)
-
-    def test_numpy_float(self):
-        value = nutils.types.strictfloat(numpy.float64(1.))
-        self.assertEqual(value, 1.)
-        self.assertEqual(type(value), float)
-
-    def test_complex(self):
-        with self.assertRaises(ValueError):
-            nutils.types.strictint(1+0j)
-
-    def test_str(self):
-        with self.assertRaises(ValueError):
-            nutils.types.strictfloat('1.')
-
-
-class strictstr(TestCase):
-
-    def test_str(self):
-        value = nutils.types.strictstr('spam')
-        self.assertEqual(value, 'spam')
-        self.assertEqual(type(value), str)
-
-    def test_int(self):
-        with self.assertRaises(ValueError):
-            nutils.types.strictstr(1)
-
-
-class strict(TestCase):
-
-    def test_valid(self):
-        self.assertEqual(nutils.types.strict[int](1), 1)
-
-    def test_invalid(self):
-        with self.assertRaises(ValueError):
-            nutils.types.strict[int]('1')
-
-    def test_call(self):
-        with self.assertRaises(TypeError):
-            nutils.types.strict()
-
-
-class tupletype(TestCase):
-
-    def test_valid1(self):
-        value = nutils.types.tuple[nutils.types.strictint]([])
-        self.assertEqual(value, ())
-        self.assertEqual(type(value), tuple)
-
-    def test_valid2(self):
-        value = nutils.types.tuple[nutils.types.strictint]([1, 2, 3])
-        self.assertEqual(value, (1, 2, 3))
-        self.assertEqual(type(value), tuple)
-
-    def test_invalid(self):
-        with self.assertRaises(ValueError):
-            nutils.types.tuple[nutils.types.strictint]([1, 'spam', 'eggs'])
-
-    def test_without_item_constructor(self):
-        src = 1, 2, 3
-        self.assertEqual(nutils.types.tuple(src), tuple(src))
-
-    def test_name(self):
-        self.assertEqual(nutils.types.tuple[nutils.types.strictint].__name__, 'tuple[nutils.types.strictint]')
+            nutils.types.nutils_hash(MyUnhashableClass())
 
 
 class frozendict(TestCase):
 
     def test_constructor(self):
         src = {'spam': 1, 'eggs': 2.3}
         for name, value in [('mapping', src), ('mapping_view', src.items()), ('iterable', (item for item in src.items())), ('frozendict', nutils.types.frozendict(src))]:
@@ -570,32 +159,14 @@
                 self.assertIsInstance(frozen, nutils.types.frozendict)
                 self.assertEqual(dict(frozen), src)
 
     def test_constructor_invalid(self):
         with self.assertRaises(ValueError):
             nutils.types.frozendict(['spam', 'eggs', 1])
 
-    def test_clsgetitem(self):
-        T = nutils.types.frozendict[str, float]
-        src = {1: 2, 'spam': '2.3'}
-        for name, value in [('mapping', src), ('mapping_view', src.items()), ('iterable', (item for item in src.items()))]:
-            with self.subTest(name):
-                frozen = T(value)
-                self.assertIsInstance(frozen, nutils.types.frozendict)
-                self.assertEqual(dict(frozen), {'1': 2., 'spam': 2.3})
-
-    def test_clsgetitem_invalid_types(self):
-        with self.assertRaises(RuntimeError):
-            nutils.types.frozendict[str, float, bool]
-
-    def test_clsgetitem_invalid_value(self):
-        T = nutils.types.frozendict[str, float]
-        with self.assertRaises(ValueError):
-            T(1)
-
     def test_setitem(self):
         frozen = nutils.types.frozendict({'spam': 1, 'eggs': 2.3})
         with self.assertRaises(TypeError):
             frozen['eggs'] = 3
 
     def test_delitem(self):
         frozen = nutils.types.frozendict({'spam': 1, 'eggs': 2.3})
@@ -679,19 +250,14 @@
         src = 'spam', 'bacon', 'sausage', 'spam'
         for name, value in [('tuple', src), ('frozenmultiset', nutils.types.frozenmultiset(src))]:
             with self.subTest(name=name):
                 frozen = nutils.types.frozenmultiset(value)
                 for item in 'spam', 'bacon', 'sausage':
                     self.assertEqual({k: tuple(frozen).count(k) for k in set(src)}, {'spam': 2, 'bacon': 1, 'sausage': 1})
 
-    def test_clsgetitem(self):
-        src = False, 1, numpy.int64(2)
-        frozen = nutils.types.frozenmultiset[nutils.types.strictint](src)
-        self.assertEqual(set(frozen), {0, 1, 2})
-
     def test_preserve_order(self):
         for src in [('spam', 'bacon', 'sausage', 'spam'), ('spam', 'egg', 'spam', 'spam', 'bacon', 'spam')]:
             with self.subTest(src=src):
                 self.assertEqual(tuple(nutils.types.frozenmultiset(src)), src)
 
     def test_and(self):
         for l, r, lar in [[['spam', 'eggs'], ['spam', 'spam', 'eggs'], ['spam', 'eggs']],
@@ -818,47 +384,14 @@
         b = a[1:]
         f = nutils.types.frozenarray(b, copy=False)
         self.assertIs(f, b)
         self.assertFalse(b.flags.writeable)
         self.assertFalse(a.flags.writeable)
 
 
-class c_array(TestCase):
-
-    def test_idempotence(self):
-        a = numpy.array([1, 2, 3], dtype=numpy.int64)
-        P = nutils.types.c_array[numpy.int64]
-        a_ct = P(a)
-        self.assertEqual(P(a_ct), a_ct)
-
-    def test_list(self):
-        a = [1, 2, 3]
-        a_ct = nutils.types.c_array[numpy.int64](a)
-        self.assertEqual(a_ct.data_as(ctypes.POINTER(ctypes.c_int64)).contents.value, 1)
-
-    def test_array(self):
-        a = numpy.array([1, 2, 3], dtype=numpy.int64)
-        a_ct = nutils.types.c_array[numpy.int64](a)
-        self.assertEqual(a_ct.data_as(ctypes.POINTER(ctypes.c_int64)).contents.value, 1)
-
-    def test_array_invalid_dtype(self):
-        a = numpy.array([1, 2, 3], dtype=numpy.int32)
-        with self.assertRaisesRegex(ValueError, '^Expected dtype .* but array has dtype .*\\.$'):
-            a_ct = nutils.types.c_array[numpy.int64](a)
-
-    def test_array_noncontinguous(self):
-        a = numpy.array([[1, 2], [3, 4]], dtype=numpy.int32).T
-        with self.assertRaisesRegex(ValueError, '^Array is not contiguous\\.$'):
-            a_ct = nutils.types.c_array[numpy.int64](a)
-
-    def test_wo_getitem(self):
-        with self.assertRaises(TypeError):
-            nutils.types.c_array()
-
-
 class T_Immutable(nutils.types.Immutable):
     def __init__(self, x, y, *, z):
         pass
 
 
 class T_Singleton(nutils.types.Singleton):
     def __init__(self, x, y, *, z):
@@ -899,23 +432,14 @@
             def __init__(self, x, y, **kwargs):
                 pass
 
         a = T(x=1, y=2, z=3)
         b = T(1, 2, z=3)
         self.assertEqual(a, b)
 
-    def test_preprocessors(self):
-        class T(self.cls):
-            @nutils.types.apply_annotations
-            def __init__(self, x: int):
-                pass
-
-        self.assertEqual(T(1), T('1'))
-        self.assertEqual(T(1), T(x='1'))
-
     def test_nutils_hash(self):
         class T(self.cls):
             def __init__(self, x, y):
                 pass
 
         class T1(self.cls, version=1):
             def __init__(self, x, y):
```

### Comparing `nutils-7.3/tests/test_unit.py` & `nutils-8.0/tests/test_unit.py`

 * *Files identical despite different names*

### Comparing `nutils-7.3/tests/test_util.py` & `nutils-8.0/tests/test_SI.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,264 +1,251 @@
-from nutils import *
-from nutils.testing import *
-import tempfile
-import pathlib
-import os
-import io
-import contextlib
-import inspect
-
-
-@parametrize
-class tri(TestCase):
-
-    # Triangles and node numbering:
-    #
-    #   2/4-(5)
-    #    | \ |
-    #   (0)-1/3
-
-    def setUp(self):
-        super().setUp()
-        self.x = numpy.array([[0, 0], [1, 0], [0, 1], [1, 0], [0, 1], [1, 1]], dtype=float)
-        self.tri = numpy.array([[0, 1, 2], [3, 4, 5]])
-
-    @requires('scipy')
-    def test_merge(self):
-        tri_merged = util.tri_merge(self.tri, self.x, mergetol=self.mergetol).tolist()
-        tri_expected = self.tri.tolist() if self.mergetol < 0 else [[0, 1, 2], [1, 2, 5]] if self.mergetol < 1 else [[0, 0, 0], [0, 0, 0]]
-        self.assertEqual(tri_merged, tri_expected)
-
-    @requires('matplotlib', 'scipy')
-    def test_interpolate(self):
-        interpolate = util.tri_interpolator(self.tri, self.x, mergetol=self.mergetol)
-        x = [.1, .9],
-        if self.mergetol < 0:
-            with self.assertRaises(RuntimeError):
-                interpolate[x]
-        else:
-            f = interpolate[x]
-            vtri = [0, 0], [1, 0], [0, 1], [10, 10], [10, 10], [1, 1]
-            vx = f(vtri)  # note: v[3] and v[4] should be ignored, leaving a linear ramp
-            self.assertEqual(vx.shape, (1, 2))
-            if self.mergetol < 1:
-                self.assertEqual(vx.tolist(), list(x))
-            else:
-                self.assertTrue(numpy.isnan(vx).all())
-
-    @parametrize.enable_if(lambda mergetol: 0 <= mergetol < 1)
-    @requires('matplotlib', 'scipy')
-    def test_outofbounds(self):
-        interpolate = util.tri_interpolator(self.tri, self.x, mergetol=self.mergetol)
-        x = [.5, .5], [1.5, .5]
-        vtri = 0, 1, 0, 10, 10, 1
-        vx = interpolate[x](vtri)
-        self.assertEqual(vx.shape, (2,))
-        self.assertEqual(vx[0], .5)
-        self.assertTrue(numpy.isnan(vx[1]))
-
-
-tri(mergetol=-1)
-tri(mergetol=0)
-tri(mergetol=.1)
-tri(mergetol=2)
-
-
-class linreg(TestCase):
-
-    def test_linear(self):
-        a = numpy.array([[0, 1], [-1, 0]])
-        b = numpy.array([[0, 1], [0, 1]])
-        linreg = util.linear_regressor()
-        ab0, ab1, ab2 = [linreg.add(x, a * x + b) for x in range(3)]
-        self.assertTrue(numpy.isnan(ab0).all())
-        self.assertEqual([a.tolist(), b.tolist()], ab1.tolist())
-        self.assertEqual([a.tolist(), b.tolist()], ab2.tolist())
-
-
-class pairwise(TestCase):
-
-    def test_normal(self):
-        for n in range(5):
-            with self.subTest(length=n):
-                self.assertEqual(list(util.pairwise(range(n))), list(zip(range(n-1), range(1, n))))
-
-    def test_periodic(self):
-        self.assertEqual(list(util.pairwise((), periodic=True)), [])
-        for n in range(1, 5):
-            with self.subTest(length=n):
-                self.assertEqual(list(util.pairwise(range(n), periodic=True)), [*zip(range(n-1), range(1, n)), (n-1, 0)])
-
-
-class readtext(TestCase):
-
-    def _test(self, method):
-        try:
-            with tempfile.NamedTemporaryFile('w', delete=False) as f:
-                f.write('foobar')
-            self.assertEqual(util.readtext(method(f.name)), 'foobar')
-        finally:  # this instead of simply setting delete=True is required for windows
-            os.remove(str(f.name))
-
-    def test_str(self):
-        self._test(str)
-
-    def test_path(self):
-        self._test(pathlib.Path)
-
-    def test_file(self):
-        self.assertEqual(util.readtext(io.StringIO('foobar')), 'foobar')
-
-    def test_typeerror(self):
-        with self.assertRaises(TypeError):
-            util.readtext(None)
-
-
-class binaryfile(TestCase):
-
-    def setUp(self):
-        super().setUp()
-        fid, self.path = tempfile.mkstemp()
-        self.addCleanup(os.unlink, self.path)
-        os.write(fid, b'foobar')
-        os.close(fid)
-
-    def test_str(self):
-        with util.binaryfile(self.path) as f:
-            self.assertEqual(f.read(), b'foobar')
-
-    def test_path(self):
-        with util.binaryfile(pathlib.Path(self.path)) as f:
-            self.assertEqual(f.read(), b'foobar')
-
-    def test_file(self):
-        with open(self.path, 'rb') as F, util.binaryfile(F) as f:
-            self.assertEqual(f.read(), b'foobar')
-
-    def test_typeerror(self):
-        with self.assertRaises(TypeError):
-            util.binaryfile(None)
-
-
-class single_or_multiple(TestCase):
-
-    def test_function(self):
-        @util.single_or_multiple
-        def square(values):
-            self.assertIsInstance(values, tuple)
-            return [value**2 for value in values]
-        self.assertEqual(square(2), 4)
-        self.assertEqual(square([2, 3]), (4, 9))
-
-    def test_method(self):
-        class T:
-            @util.single_or_multiple
-            def square(self_, values):
-                self.assertIsInstance(self_, T)
-                self.assertIsInstance(values, tuple)
-                return [value**2 for value in values]
-        t = T()
-        self.assertEqual(t.square(2), 4)
-        self.assertEqual(t.square([2, 3]), (4, 9))
-
-
-class positional_only(TestCase):
-
-    def test_simple(self):
-        @util.positional_only
-        def f(x):
-            return x
-        self.assertEqual(f(1), 1)
-        self.assertEqual(str(inspect.signature(f)), '(x, /)')
-
-    def test_mixed(self):
-        @util.positional_only
-        def f(x, *, y):
-            return x, y
-        self.assertEqual(f(1, y=2), (1, 2))
-        self.assertEqual(str(inspect.signature(f)), '(x, /, *, y)')
-
-    def test_varkw(self):
-        @util.positional_only
-        def f(x, y=...):
-            return x, y
-        self.assertEqual(f(1, x=2, y=3), (1, {'x': 2, 'y': 3}))
-        self.assertEqual(str(inspect.signature(f)), '(x, /, **y)')
-
-    def test_simple_method(self):
-        class T:
-            @util.positional_only
-            def f(self_, x):
-                self.assertIsInstance(self_, T)
-                return x
-        t = T()
-        self.assertEqual(t.f(1), 1)
-        self.assertEqual(str(inspect.signature(T.f)), '(self_, x, /)')
-        self.assertEqual(str(inspect.signature(t.f)), '(x, /)')
-
-
-class index(TestCase):
-
-    def _check(self, items):
-        for t in list, tuple, iter:
-            for i in range(2):
-                with self.subTest('{}:{}'.format(t.__name__, i)):
-                    self.assertEqual(util.index(t(items), items[i]), i)
-
-    def test_int(self):
-        self._check([1, 2, 3, 2, 1])
-
-    def test_set(self):
-        self._check([{1, 2}, {2, 3}, {3, 4}, {2, 3}, {1, 2}])
-
-
-class unique(TestCase):
-
-    def test_nokey(self):
-        unique, indices = util.unique([1, 2, 3, 2])
-        self.assertEqual(unique, [1, 2, 3])
-        self.assertEqual(indices, [0, 1, 2, 1])
-
-    def test_key(self):
-        unique, indices = util.unique([[1, 2], [2, 3], [2, 1]], key=frozenset)
-        self.assertEqual(unique, [[1, 2], [2, 3]])
-        self.assertEqual(indices, [0, 1, 0])
-
-
-class cached_property(TestCase):
-
-    def test(self):
-        class A:
-            def __init__(self):
-                self.counter = 0
-
-            @util.cached_property
-            def x(self):
-                self.counter += 1
-                return 'x'
-        a = A()
-        self.assertEqual(a.x, 'x')
-        self.assertEqual(a.x, 'x')
-        self.assertEqual(a.counter, 1)
-
-
-class merge_index_map(TestCase):
-
-    def test_empty_merge_sets(self):
-        index_map, count = util.merge_index_map(4, [])
-        self.assertEqual(index_map.tolist(), [0, 1, 2, 3])
-        self.assertEqual(count, 4)
-
-    def test_merge_set_one(self):
-        index_map, count = util.merge_index_map(4, [[1]])
-        self.assertEqual(index_map.tolist(), [0, 1, 2, 3])
-        self.assertEqual(count, 4)
-
-    def test_multihop1(self):
-        index_map, count = util.merge_index_map(4, [[0, 2], [1, 3], [0, 3]])
-        self.assertEqual(index_map.tolist(), [0, 0, 0, 0])
-        self.assertEqual(count, 1)
-
-    def test_multihop2(self):
-        index_map, count = util.merge_index_map(4, [[2, 3], [1, 2], [0, 3]])
-        self.assertEqual(index_map.tolist(), [0, 0, 0, 0])
-        self.assertEqual(count, 1)
+from nutils import SI
+
+import numpy
+import pickle
+import typing
+import unittest
+
+
+class Dimension(unittest.TestCase):
+
+    def test_multiply(self):
+        self.assertEqual(SI.Velocity * SI.Time, SI.Length)
+
+    def test_divide(self):
+        self.assertEqual(SI.Length / SI.Time, SI.Velocity)
+
+    def test_power(self):
+        self.assertEqual(SI.Length**2, SI.Area)
+        self.assertEqual(SI.Area**.5, SI.Length)
+
+    def test_name(self):
+        self.assertEqual(SI.Force.__name__, '[M*L/T2]')
+        self.assertEqual((SI.Force**.5).__name__, '[M_2*L_2/T]')
+        self.assertEqual((SI.Force**1.5).__name__, '[M3_2*L3_2/T3]')
+
+    def test_fromname(self):
+        self.assertEqual(getattr(SI.Quantity, '[M*L/T2]'), SI.Force)
+        self.assertEqual(getattr(SI.Quantity, '[M_2*L_2/T]'), SI.Force**.5)
+        self.assertEqual(getattr(SI.Quantity, '[M3_2*L3_2/T3]'), SI.Force**1.5)
+
+    def test_typing(self):
+        self.assertEqual(SI.Length | None, typing.Optional[SI.Length])
+        self.assertEqual(None | SI.Length | SI.Time, typing.Optional[typing.Union[SI.Time, SI.Length]])
+
+    def test_pickle(self):
+        T = SI.Length / SI.Time
+        s = pickle.dumps(T)
+        self.assertEqual(pickle.loads(s), T)
+
+
+class Quantity(unittest.TestCase):
+
+    def test_fromstring(self):
+        F = SI.parse('5kN')
+        self.assertEqual(type(F), SI.Force)
+        self.assertEqual(F / 'N', 5000)
+        v = SI.parse('-864km/24h')
+        self.assertEqual(type(v), SI.Velocity)
+        self.assertEqual(v / 'm/s', -10)
+        v = SI.parse('2m/5cm')
+        self.assertEqual(v, 40)
+
+    def test_fromvalue(self):
+        F = SI.Force('10N')
+        self.assertEqual(type(F), SI.Force)
+        self.assertEqual(F / SI.Force('2N'), 5)
+
+    def test_getitem(self):
+        F = SI.units.N * numpy.arange(6).reshape(2, 3)
+        self.assertEqual(F[0, 0], SI.Force('0N'))
+        self.assertEqual(F[0, 1], SI.Force('1N'))
+        self.assertEqual(F[0, 2], SI.Force('2N'))
+        self.assertEqual(F[1, 0], SI.Force('3N'))
+        self.assertEqual(F[1, 1], SI.Force('4N'))
+        self.assertEqual(F[1, 2], SI.Force('5N'))
+
+    def test_setitem(self):
+        F = SI.units.N * numpy.zeros(3)
+        F[0] = SI.Force('1N')
+        F[1] = SI.Force('2N')
+        with self.assertRaisesRegex(TypeError, r'cannot assign \[L2\] to \[M\*L/T2\]'):
+            F[2] = SI.Area('10m2')
+        F[2] = SI.Force('3N')
+        self.assertTrue(numpy.all(F == SI.units.N * numpy.array([1, 2, 3])))
+
+    def test_iter(self):
+        F = SI.units.N * numpy.arange(6).reshape(2, 3)
+        for i, Fi in enumerate(F):
+            for j, Fij in enumerate(Fi):
+                self.assertEqual(Fij, SI.units.N * (i*3+j))
+
+    def test_multiply(self):
+        self.assertEqual(SI.Mass('2kg') * SI.Acceleration('10m/s2'), SI.Force('20N'))
+        self.assertEqual(2 * SI.Acceleration('10m/s2'), SI.Acceleration('20m/s2'))
+        self.assertEqual(SI.Mass('2kg') * 10, SI.Mass('20kg'))
+        self.assertEqual(SI.Time('2s') * SI.Frequency('10/s'), 20)
+        self.assertEqual(numpy.multiply(SI.Mass('2kg'), SI.Acceleration('10m/s2')), SI.Force('20N'))
+
+    def test_matmul(self):
+        self.assertEqual((SI.units.kg * numpy.array([2, 3])) @ (SI.parse('m/s2') * numpy.array([5, -3])), SI.Force('1N'))
+
+    def test_divide(self):
+        self.assertEqual(SI.Length('2m') / SI.Time('10s'), SI.Velocity('.2m/s'))
+        self.assertEqual(2 / SI.Time('10s'), SI.Frequency('.2/s'))
+        self.assertEqual(SI.Length('2m') / 10, SI.Length('.2m'))
+        self.assertEqual(SI.Density('2kg/m3') / SI.Density('10kg/m3'), .2)
+        self.assertEqual(numpy.divide(SI.Length('2m'), SI.Time('10s')), SI.Velocity('.2m/s'))
+
+    def test_power(self):
+        self.assertEqual(SI.Length('3m')**2, SI.Area('9m2'))
+        self.assertEqual(SI.Length('3m')**0, 1)
+        self.assertEqual(numpy.power(SI.Length('3m'), 2), SI.Area('9m2'))
+
+    def test_add(self):
+        self.assertEqual(SI.Mass('2kg') + SI.Mass('3kg'), SI.Mass('5kg'))
+        self.assertEqual(numpy.add(SI.Mass('2kg'), SI.Mass('3kg')), SI.Mass('5kg'))
+        with self.assertRaisesRegex(TypeError, r'incompatible arguments for add: \[M\], \[L\]'):
+            SI.Mass('2kg') + SI.Length('3m')
+
+    def test_sub(self):
+        self.assertEqual(SI.Mass('2kg') - SI.Mass('3kg'), SI.Mass('-1kg'))
+        self.assertEqual(numpy.subtract(SI.Mass('2kg'), SI.Mass('3kg')), SI.Mass('-1kg'))
+        with self.assertRaisesRegex(TypeError, r'incompatible arguments for sub: \[M\], \[L\]'):
+            SI.Mass('2kg') - SI.Length('3m')
+
+    def test_hypot(self):
+        self.assertEqual(numpy.hypot(SI.Mass('3kg'), SI.Mass('4kg')), SI.Mass('5kg'))
+        with self.assertRaisesRegex(TypeError, r'incompatible arguments for hypot: \[M\], \[L\]'):
+            numpy.hypot(SI.Mass('3kg'), SI.Length('4m'))
+
+    def test_neg(self):
+        self.assertEqual(-SI.Mass('2kg'), SI.Mass('-2kg'))
+        self.assertEqual(numpy.negative(SI.Mass('2kg')), SI.Mass('-2kg'))
+
+    def test_pos(self):
+        self.assertEqual(+SI.Mass('2kg'), SI.Mass('2kg'))
+        self.assertEqual(numpy.positive(SI.Mass('2kg')), SI.Mass('2kg'))
+
+    def test_abs(self):
+        self.assertEqual(numpy.abs(SI.Mass('-2kg')), SI.Mass('2kg'))
+
+    def test_sqrt(self):
+        self.assertEqual(numpy.sqrt(SI.Area('4m2')), SI.Length('2m'))
+
+    def test_sum(self):
+        self.assertTrue(numpy.all(numpy.sum(SI.units.kg * numpy.arange(6).reshape(2, 3), 0) == SI.units.kg * numpy.array([3, 5, 7])))
+        self.assertTrue(numpy.all(numpy.sum(SI.units.kg * numpy.arange(6).reshape(2, 3), 1) == SI.units.kg * numpy.array([3, 12])))
+
+    def test_mean(self):
+        self.assertTrue(numpy.all(numpy.mean(SI.units.kg * numpy.arange(6).reshape(2, 3), 0) == SI.units.kg * numpy.array([1.5, 2.5, 3.5])))
+        self.assertTrue(numpy.all(numpy.mean(SI.units.kg * numpy.arange(6).reshape(2, 3), 1) == SI.units.kg * numpy.array([1, 4])))
+
+    def test_broadcast_to(self):
+        v = numpy.array([1, 2, 3])
+        A = SI.units.kg * v
+        B = numpy.broadcast_to(A, (2, 3))
+        self.assertEqual(B.unwrap().shape, (2, 3))
+        self.assertEqual(B[1, 1], SI.Mass('2kg'))
+
+    def test_trace(self):
+        A = SI.units.kg * numpy.arange(18).reshape(3, 2, 3)
+        self.assertTrue(numpy.all(numpy.trace(A, axis1=0, axis2=2) == SI.units.kg * numpy.array([21, 30])))
+
+    def test_ptp(self):
+        A = SI.units.kg * numpy.array([2, -10, 5, 0])
+        self.assertEqual(numpy.ptp(A), SI.Mass('15kg'))
+
+    def test_min(self):
+        A = SI.units.kg * numpy.array([2, -10, 5, 0])
+        self.assertEqual(numpy.max(A), SI.Mass('5kg'))
+
+    def test_max(self):
+        A = SI.units.kg * numpy.array([2, -10, 5, 0])
+        self.assertEqual(numpy.min(A), SI.Mass('-10kg'))
+
+    def test_cmp(self):
+        A = SI.Mass('2kg')
+        B = SI.Mass('3kg')
+        self.assertTrue(A < B)
+        self.assertTrue(numpy.less(A, B))
+        self.assertTrue(A <= B)
+        self.assertTrue(numpy.less_equal(A, B))
+        self.assertFalse(A > B)
+        self.assertFalse(numpy.greater(A, B))
+        self.assertFalse(A >= B)
+        self.assertFalse(numpy.greater_equal(A, B))
+        self.assertFalse(A == B)
+        self.assertFalse(numpy.equal(A, B))
+        self.assertTrue(A != B)
+        self.assertTrue(numpy.not_equal(A, B))
+
+    def test_shape(self):
+        A = SI.Mass('2kg')
+        self.assertEqual(numpy.shape(A), ())
+        A = SI.units.kg * numpy.arange(3)
+        self.assertEqual(numpy.shape(A), (3,))
+        self.assertEqual(A.unwrap().shape, (3,))
+
+    def test_ndim(self):
+        A = SI.Mass('2kg')
+        self.assertEqual(numpy.ndim(A), 0)
+        A = SI.units.kg * numpy.arange(3)
+        self.assertEqual(numpy.ndim(A), 1)
+        self.assertEqual(A.unwrap().ndim, 1)
+
+    def test_size(self):
+        A = SI.Mass('2kg')
+        self.assertEqual(numpy.size(A), 1)
+        A = SI.units.kg * numpy.arange(3)
+        self.assertEqual(numpy.size(A), 3)
+        self.assertEqual(A.unwrap().size, 3)
+
+    def test_isnan(self):
+        self.assertTrue(numpy.isnan(SI.units.kg * float('nan')))
+        self.assertFalse(numpy.isnan(SI.Mass('2kg')))
+
+    def test_isfinite(self):
+        self.assertFalse(numpy.isfinite(SI.units.kg * float('nan')))
+        self.assertFalse(numpy.isfinite(SI.units.kg * float('inf')))
+        self.assertTrue(numpy.isfinite(SI.Mass('2kg')))
+
+    def test_stack(self):
+        A = SI.Mass('2kg')
+        B = SI.Mass('3kg')
+        C = SI.Mass('4kg')
+        D = SI.Time('5s')
+        self.assertTrue(numpy.all(numpy.stack([A, B, C]) == SI.units.kg * numpy.array([2, 3, 4])))
+        with self.assertRaisesRegex(TypeError, r'incompatible arguments for stack: \[M\], \[M\], \[M\], \[T\]'):
+            numpy.stack([A, B, C, D])
+
+    def test_concatenate(self):
+        A = SI.units.kg * numpy.array([1, 2])
+        B = SI.units.kg * numpy.array([3, 4])
+        C = SI.units.s * numpy.array([5, 6])
+        self.assertTrue(numpy.all(numpy.concatenate([A, B]) == SI.units.kg * numpy.array([1, 2, 3, 4])))
+        with self.assertRaisesRegex(TypeError, r'incompatible arguments for concatenate: \[M\], \[M\], \[T\]'):
+            numpy.concatenate([A, B, C])
+
+    def test_format(self):
+        s = 'velocity: {:.1m/s}'.format(SI.parse('9km/h'))
+        self.assertEqual(s, 'velocity: 2.5m/s')
+
+    def test_pickle(self):
+        v = SI.Velocity('2m/s')
+        s = pickle.dumps(v)
+        self.assertEqual(pickle.loads(s), v)
+
+    def test_string_representation(self):
+        F = numpy.array([1.,2.]) * SI.units.N
+        self.assertEqual(str(F), '[1. 2.][M*L/T2]')
+        self.assertEqual(repr(F), 'array([1., 2.])[M*L/T2]')
+
+    def test_wrap_unwrap(self):
+        T = SI.Length / SI.Time
+        v = T.wrap(5.)
+        self.assertIsInstance(v, T)
+        self.assertEqual(v.unwrap(), 5)
+
+    def test_hash(self):
+        v = SI.Velocity('2m/s')
+        h = hash(v)
```

### Comparing `nutils-7.3/PKG-INFO` & `nutils-8.0/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,24 @@
 Metadata-Version: 2.1
 Name: nutils
-Version: 7.3
+Version: 8.0
 Summary: Numerical Utilities for Finite Element Analysis
 Author-email: Evalf <info@evalf.com>
 Requires-Python: ~=3.7
 Description-Content-Type: text/markdown
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Topic :: Scientific/Engineering :: Mathematics
 Classifier: Topic :: Scientific/Engineering :: Physics
+Requires-Dist: appdirs~=1.0
+Requires-Dist: bottombar~=2.0.2
 Requires-Dist: numpy>=1.17
-Requires-Dist: treelog>=1.0b5,<2
-Requires-Dist: stringly>=1.0b2,<2
-Requires-Dist: bottombar==1.0
+Requires-Dist: nutils-poly~=1.0
+Requires-Dist: psutil~=5.0
+Requires-Dist: stringly
+Requires-Dist: treelog>=1.0b5
 Requires-Dist: Sphinx>=1.8 ; extra == "docs"
 Requires-Dist: matplotlib>=1.3 ; extra == "export_mpl"
 Requires-Dist: pillow>2.6 ; extra == "export_mpl"
 Requires-Dist: meshio ; extra == "import_gmsh"
 Requires-Dist: mkl ; extra == "matrix_mkl"
 Requires-Dist: scipy>=0.13 ; extra == "matrix_scipy"
 Provides-Extra: docs
@@ -69,14 +72,18 @@
 
     python3 -m pip install --user https://github.com/evalf/nutils/archive/master.zip
 
 To view which version of Nutils is currently installed, run:
 
     python3 -m pip show nutils
 
+Nutils can be installed in a Windows machine using WSL environment.
+If you want to assemble matrices in parallel using nutils on a Windows machine, 
+then WSL is the way to go. Instructions to setup WSL are available [here][13]. 
+After setting up WSL, nutils can be installed using the above instructions. 
 
 First steps
 -----------
 
 To confirm Nutils and its dependencies are installed correctly, try to run the
 Laplace example or any of the other examples included in this repostitory. Make
 sure to use the same version of an example as the version of Nutils that is
@@ -144,8 +151,9 @@
 [6]: http://docs.nutils.org/en/latest/examples/
 [7]: http://docs.nutils.org/en/latest/nutils/
 [8]: https://matrix.to/#/#nutils-users:matrix.org
 [9]: https://doi.org/10.5281/zenodo.822369
 [10]: https://www.docker.com/
 [11]: https://github.com/orgs/evalf/packages/container/package/nutils
 [12]: https://raw.githubusercontent.com/evalf/nutils/master/examples/laplace.py
+[13]: https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview
```

